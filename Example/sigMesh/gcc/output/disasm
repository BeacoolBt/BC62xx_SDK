
output\a.out:     file format elf32-littlearm


Disassembly of section .text:

00000000 <__isr_vector>:
       0:	10014000 	.word	0x10014000
       4:	00004255 	.word	0x00004255
       8:	0000429d 	.word	0x0000429d
       c:	0000429d 	.word	0x0000429d
	...
      3c:	000025e9 	.word	0x000025e9
      40:	0000429d 	.word	0x0000429d
      44:	0000429d 	.word	0x0000429d
      48:	0000429d 	.word	0x0000429d
      4c:	0000429d 	.word	0x0000429d
      50:	0000429d 	.word	0x0000429d
      54:	0000429d 	.word	0x0000429d
      58:	0000429d 	.word	0x0000429d
      5c:	0000429d 	.word	0x0000429d
      60:	0000429d 	.word	0x0000429d
      64:	0000429d 	.word	0x0000429d
      68:	0000429d 	.word	0x0000429d
      6c:	0000429d 	.word	0x0000429d
      70:	0000429d 	.word	0x0000429d
      74:	0000429d 	.word	0x0000429d
      78:	0000429d 	.word	0x0000429d
      7c:	0000429d 	.word	0x0000429d
      80:	0000429d 	.word	0x0000429d
      84:	0000429d 	.word	0x0000429d
      88:	0000429d 	.word	0x0000429d
      8c:	0000429d 	.word	0x0000429d
      90:	0000429d 	.word	0x0000429d
      94:	0000429d 	.word	0x0000429d

00000098 <Bt_BleCallBack>:
#include "m_api.h"
#include "app_mesh.h"


void Bt_BleCallBack(uint8_t *buf, uint16_t len)
{
      98:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	uint16_t att_hdl = (uint16_t)*buf;
      9a:	7806      	ldrb	r6, [r0, #0]
#include "m_api.h"
#include "app_mesh.h"


void Bt_BleCallBack(uint8_t *buf, uint16_t len)
{
      9c:	0004      	movs	r4, r0
      9e:	000d      	movs	r5, r1
	uint16_t att_hdl = (uint16_t)*buf;
	switch(att_hdl){
      a0:	2e15      	cmp	r6, #21
      a2:	d020      	beq.n	e6 <Bt_BleCallBack+0x4e>
      a4:	d802      	bhi.n	ac <Bt_BleCallBack+0x14>
      a6:	2e09      	cmp	r6, #9
      a8:	d005      	beq.n	b6 <Bt_BleCallBack+0x1e>
      aa:	e021      	b.n	f0 <Bt_BleCallBack+0x58>
      ac:	2e1d      	cmp	r6, #29
      ae:	d00a      	beq.n	c6 <Bt_BleCallBack+0x2e>
      b0:	2e23      	cmp	r6, #35	; 0x23
      b2:	d008      	beq.n	c6 <Bt_BleCallBack+0x2e>
      b4:	e01c      	b.n	f0 <Bt_BleCallBack+0x58>
		case 0x0009:{
			uint8_t val = (uint16_t)*(buf+2);
			if(val){
      b6:	7883      	ldrb	r3, [r0, #2]
      b8:	2b00      	cmp	r3, #0
      ba:	d019      	beq.n	f0 <Bt_BleCallBack+0x58>
				printf("NOTIFY:\r\n");
      bc:	480d      	ldr	r0, [pc, #52]	; (f4 <Bt_BleCallBack+0x5c>)
      be:	3009      	adds	r0, #9
      c0:	f015 fd66 	bl	15b90 <puts>
      c4:	e014      	b.n	f0 <Bt_BleCallBack+0x58>
			}
		}break;
		case GATT_PROV_WRITE_HANDLE:
		case GATT_PROXY_WRITE_HANDLE:{
			#if (BLE_MESH)
			if(OTANONE != gatt_ota_state_get())
      c6:	f000 f937 	bl	338 <gatt_ota_state_get>
      ca:	2800      	cmp	r0, #0
      cc:	d110      	bne.n	f0 <Bt_BleCallBack+0x58>
				break;
			struct mesh_write_req_param para;
			para.con = 0;
      ce:	a901      	add	r1, sp, #4
      d0:	8008      	strh	r0, [r1, #0]
			para.handle = att_hdl;
			para.offset = 0;
      d2:	8088      	strh	r0, [r1, #4]
			para.length = len-2;
      d4:	3d02      	subs	r5, #2
			para.value = buf+2;
      d6:	3402      	adds	r4, #2
			mesh_ble_event_set(MESH_BLE_CON_WRITE_REQ,&para);
      d8:	3008      	adds	r0, #8
			#if (BLE_MESH)
			if(OTANONE != gatt_ota_state_get())
				break;
			struct mesh_write_req_param para;
			para.con = 0;
			para.handle = att_hdl;
      da:	804e      	strh	r6, [r1, #2]
			para.offset = 0;
			para.length = len-2;
      dc:	80cd      	strh	r5, [r1, #6]
			para.value = buf+2;
      de:	608c      	str	r4, [r1, #8]
			mesh_ble_event_set(MESH_BLE_CON_WRITE_REQ,&para);
      e0:	f007 fa14 	bl	750c <mesh_ble_event_set>
			#endif
		}break;
      e4:	e004      	b.n	f0 <Bt_BleCallBack+0x58>
		case OTA_WRITE_HANDLE:{
			gatt_ota_data_deal(buf+2, len - 2);
      e6:	3d02      	subs	r5, #2
      e8:	b2e9      	uxtb	r1, r5
      ea:	3002      	adds	r0, #2
      ec:	f000 fb05 	bl	6fa <gatt_ota_data_deal>
		}break;
		default:{
			
		}break;
	}
}
      f0:	bd7f      	pop	{r0, r1, r2, r3, r4, r5, r6, pc}
      f2:	46c0      	nop			; (mov r8, r8)
      f4:	0001fc9c 	.word	0x0001fc9c

000000f8 <Event_call_back>:

void Event_call_back(uint8_t da)
{
      f8:	b507      	push	{r0, r1, r2, lr}
      fa:	4b18      	ldr	r3, [pc, #96]	; (15c <Event_call_back+0x64>)
      fc:	0001      	movs	r1, r0
	switch(da){
      fe:	2815      	cmp	r0, #21
     100:	d015      	beq.n	12e <Event_call_back+0x36>
     102:	2865      	cmp	r0, #101	; 0x65
     104:	d00e      	beq.n	124 <Event_call_back+0x2c>
     106:	2814      	cmp	r0, #20
     108:	d122      	bne.n	150 <Event_call_back+0x58>
		case 0x65:
			printf("BLE 0x65\r\n");
			break;
		case IPC_EVT_LE_CONNECTED:{
			printf("BLE connect\r\n");
     10a:	331c      	adds	r3, #28
     10c:	0018      	movs	r0, r3
     10e:	f015 fd3f 	bl	15b90 <puts>
			gatt_ota_start();
     112:	f000 f8ed 	bl	2f0 <gatt_ota_start>
			#if (BLE_MESH)
			struct mesh_connected_param para;
			para.con = 0;
     116:	2300      	movs	r3, #0
     118:	a901      	add	r1, sp, #4
			mesh_ble_event_set(MESH_BLE_CON_CONNECTED,&para);
     11a:	2005      	movs	r0, #5
		case IPC_EVT_LE_CONNECTED:{
			printf("BLE connect\r\n");
			gatt_ota_start();
			#if (BLE_MESH)
			struct mesh_connected_param para;
			para.con = 0;
     11c:	800b      	strh	r3, [r1, #0]
			mesh_ble_event_set(MESH_BLE_CON_CONNECTED,&para);
     11e:	f007 f9f5 	bl	750c <mesh_ble_event_set>
			#endif
		}break;
     122:	e019      	b.n	158 <Event_call_back+0x60>

void Event_call_back(uint8_t da)
{
	switch(da){
		case 0x65:
			printf("BLE 0x65\r\n");
     124:	3312      	adds	r3, #18
     126:	0018      	movs	r0, r3
     128:	f015 fd32 	bl	15b90 <puts>
			break;
     12c:	e014      	b.n	158 <Event_call_back+0x60>
			mesh_ble_event_set(MESH_BLE_CON_CONNECTED,&para);
			#endif
		}break;
			
		case IPC_EVT_LE_DISCONNECTED:{
			printf("BLE disconnect\r\n");
     12e:	3329      	adds	r3, #41	; 0x29
     130:	0018      	movs	r0, r3
     132:	f015 fd2d 	bl	15b90 <puts>
			gatt_ota_stop();
     136:	f000 f8f1 	bl	31c <gatt_ota_stop>
			HWRITE(mem_le_adv_enable, 0x01);
     13a:	2201      	movs	r2, #1
     13c:	4b08      	ldr	r3, [pc, #32]	; (160 <Event_call_back+0x68>)
			#if (BLE_MESH)	
			struct mesh_disconnected_param para;
			para.con = 0;
     13e:	a901      	add	r1, sp, #4
		}break;
			
		case IPC_EVT_LE_DISCONNECTED:{
			printf("BLE disconnect\r\n");
			gatt_ota_stop();
			HWRITE(mem_le_adv_enable, 0x01);
     140:	701a      	strb	r2, [r3, #0]
			#if (BLE_MESH)	
			struct mesh_disconnected_param para;
			para.con = 0;
     142:	2300      	movs	r3, #0
			para.reason = 0;
			mesh_ble_event_set(MESH_BLE_CON_DISCONNECTED,&para);
     144:	2006      	movs	r0, #6
			printf("BLE disconnect\r\n");
			gatt_ota_stop();
			HWRITE(mem_le_adv_enable, 0x01);
			#if (BLE_MESH)	
			struct mesh_disconnected_param para;
			para.con = 0;
     146:	800b      	strh	r3, [r1, #0]
			para.reason = 0;
     148:	708b      	strb	r3, [r1, #2]
			mesh_ble_event_set(MESH_BLE_CON_DISCONNECTED,&para);
     14a:	f007 f9df 	bl	750c <mesh_ble_event_set>
     14e:	e003      	b.n	158 <Event_call_back+0x60>
			#endif
		}break;
		default:
			printf("enter event [%d]\r\n", da);
     150:	3339      	adds	r3, #57	; 0x39
     152:	0018      	movs	r0, r3
     154:	f015 fcd2 	bl	15afc <printf>
			break;
	}
}
     158:	bd07      	pop	{r0, r1, r2, pc}
     15a:	46c0      	nop			; (mov r8, r8)
     15c:	0001fc9c 	.word	0x0001fc9c
     160:	100043b1 	.word	0x100043b1

00000164 <Mesh_Adv_Cb>:
void Mesh_Adv_Cb(uint8_t* sour, uint16_t len)
{
     164:	b537      	push	{r0, r1, r2, r4, r5, lr}
     166:	0004      	movs	r4, r0
     168:	000d      	movs	r5, r1
#if (BLE_MESH)	
	if(OTANONE != gatt_ota_state_get())
     16a:	f000 f8e5 	bl	338 <gatt_ota_state_get>
     16e:	2800      	cmp	r0, #0
     170:	d10c      	bne.n	18c <Mesh_Adv_Cb+0x28>
		return;

	struct mesh_adv_report_param para;
	para.info = sour[0];
     172:	466a      	mov	r2, sp
     174:	7823      	ldrb	r3, [r4, #0]
	para.rssi = sour[1];
	para.length = len-8;
     176:	3d08      	subs	r5, #8
#if (BLE_MESH)	
	if(OTANONE != gatt_ota_state_get())
		return;

	struct mesh_adv_report_param para;
	para.info = sour[0];
     178:	7013      	strb	r3, [r2, #0]
	para.rssi = sour[1];
     17a:	7863      	ldrb	r3, [r4, #1]
	para.length = len-8;
	para.data = &sour[8];
	mesh_ble_event_set(MESH_BLE_SCAN_RX_CB,&para);
     17c:	4669      	mov	r1, sp

	struct mesh_adv_report_param para;
	para.info = sour[0];
	para.rssi = sour[1];
	para.length = len-8;
	para.data = &sour[8];
     17e:	3408      	adds	r4, #8
	mesh_ble_event_set(MESH_BLE_SCAN_RX_CB,&para);
     180:	3003      	adds	r0, #3
	if(OTANONE != gatt_ota_state_get())
		return;

	struct mesh_adv_report_param para;
	para.info = sour[0];
	para.rssi = sour[1];
     182:	7053      	strb	r3, [r2, #1]
	para.length = len-8;
     184:	8055      	strh	r5, [r2, #2]
	para.data = &sour[8];
     186:	9401      	str	r4, [sp, #4]
	mesh_ble_event_set(MESH_BLE_SCAN_RX_CB,&para);
     188:	f007 f9c0 	bl	750c <mesh_ble_event_set>
#endif
}
     18c:	bd37      	pop	{r0, r1, r2, r4, r5, pc}

0000018e <ble_read_req_cb>:

void ble_read_req_cb(uint8_t* buf, uint16_t len)
{
     18e:	b570      	push	{r4, r5, r6, lr}
	printf("%s:", __FUNCTION__);
     190:	4c06      	ldr	r4, [pc, #24]	; (1ac <ble_read_req_cb+0x1e>)
	mesh_ble_event_set(MESH_BLE_SCAN_RX_CB,&para);
#endif
}

void ble_read_req_cb(uint8_t* buf, uint16_t len)
{
     192:	0005      	movs	r5, r0
	printf("%s:", __FUNCTION__);
     194:	0021      	movs	r1, r4
     196:	0020      	movs	r0, r4
     198:	314c      	adds	r1, #76	; 0x4c
     19a:	305c      	adds	r0, #92	; 0x5c
     19c:	f015 fcae 	bl	15afc <printf>
	printf("hadler[%x]\r\n", (uint16_t)*buf);
     1a0:	0020      	movs	r0, r4
     1a2:	7829      	ldrb	r1, [r5, #0]
     1a4:	3060      	adds	r0, #96	; 0x60
     1a6:	f015 fca9 	bl	15afc <printf>
}
     1aa:	bd70      	pop	{r4, r5, r6, pc}
     1ac:	0001fc9c 	.word	0x0001fc9c

000001b0 <ble_read_conn_param>:

void ble_read_conn_param(uint8_t* buf, uint16_t len)
{
     1b0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
     1b2:	0006      	movs	r6, r0
	printf("%s:", __FUNCTION__);
     1b4:	480a      	ldr	r0, [pc, #40]	; (1e0 <ble_read_conn_param+0x30>)
	printf("%s:", __FUNCTION__);
	printf("hadler[%x]\r\n", (uint16_t)*buf);
}

void ble_read_conn_param(uint8_t* buf, uint16_t len)
{
     1b6:	000f      	movs	r7, r1
	printf("%s:", __FUNCTION__);
     1b8:	0001      	movs	r1, r0
	for(int i = 0; i < len; ++i){
     1ba:	0035      	movs	r5, r6
	printf("hadler[%x]\r\n", (uint16_t)*buf);
}

void ble_read_conn_param(uint8_t* buf, uint16_t len)
{
	printf("%s:", __FUNCTION__);
     1bc:	316d      	adds	r1, #109	; 0x6d
     1be:	305c      	adds	r0, #92	; 0x5c
     1c0:	f015 fc9c 	bl	15afc <printf>
     1c4:	4c07      	ldr	r4, [pc, #28]	; (1e4 <ble_read_conn_param+0x34>)
	for(int i = 0; i < len; ++i){
     1c6:	1bab      	subs	r3, r5, r6
     1c8:	429f      	cmp	r7, r3
     1ca:	dd05      	ble.n	1d8 <ble_read_conn_param+0x28>
		printf("%02x ", buf[i]);
     1cc:	7829      	ldrb	r1, [r5, #0]
     1ce:	4806      	ldr	r0, [pc, #24]	; (1e8 <ble_read_conn_param+0x38>)
     1d0:	f015 fc94 	bl	15afc <printf>
     1d4:	3501      	adds	r5, #1
     1d6:	e7f6      	b.n	1c6 <ble_read_conn_param+0x16>
	}
	printf("\r\n");
     1d8:	1de0      	adds	r0, r4, #7
     1da:	f015 fcd9 	bl	15b90 <puts>
}
     1de:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
     1e0:	0001fc9c 	.word	0x0001fc9c
     1e4:	0001fd1c 	.word	0x0001fd1c
     1e8:	0001fd1d 	.word	0x0001fd1d

000001ec <main>:

int main()
{	
     1ec:	b570      	push	{r4, r5, r6, lr}
	UART_RemapToPrintf(UARTB, GPIO_UART_TX, GPIO_UART_RX);
     1ee:	221c      	movs	r2, #28
	}
	printf("\r\n");
}

int main()
{	
     1f0:	b08e      	sub	sp, #56	; 0x38
	UART_RemapToPrintf(UARTB, GPIO_UART_TX, GPIO_UART_RX);
     1f2:	211b      	movs	r1, #27
     1f4:	2001      	movs	r0, #1
     1f6:	f001 fbc7 	bl	1988 <UART_RemapToPrintf>
	m_print("-----------%s[%s]-----------\r\n", MESH_VER, MESH_LVER);
     1fa:	4c35      	ldr	r4, [pc, #212]	; (2d0 <main+0xe4>)
     1fc:	0022      	movs	r2, r4
     1fe:	0021      	movs	r1, r4
     200:	0020      	movs	r0, r4
     202:	3209      	adds	r2, #9
     204:	310b      	adds	r1, #11
     206:	3011      	adds	r0, #17
     208:	f004 fbd0 	bl	49ac <m_print>
	M_PRINTF(L_APP,"mesh stack init start");
     20c:	4b31      	ldr	r3, [pc, #196]	; (2d4 <main+0xe8>)
     20e:	681a      	ldr	r2, [r3, #0]
     210:	001e      	movs	r6, r3
     212:	0493      	lsls	r3, r2, #18
     214:	d514      	bpl.n	240 <main+0x54>
     216:	0023      	movs	r3, r4
     218:	0022      	movs	r2, r4
     21a:	0020      	movs	r0, r4
     21c:	4d2e      	ldr	r5, [pc, #184]	; (2d8 <main+0xec>)
     21e:	334d      	adds	r3, #77	; 0x4d
     220:	0029      	movs	r1, r5
     222:	3237      	adds	r2, #55	; 0x37
     224:	9300      	str	r3, [sp, #0]
     226:	303e      	adds	r0, #62	; 0x3e
     228:	2378      	movs	r3, #120	; 0x78
     22a:	f004 fbbf 	bl	49ac <m_print>
     22e:	0020      	movs	r0, r4
     230:	3052      	adds	r0, #82	; 0x52
     232:	f004 fbbb 	bl	49ac <m_print>
     236:	0020      	movs	r0, r4
     238:	1da9      	adds	r1, r5, #6
     23a:	3068      	adds	r0, #104	; 0x68
     23c:	f004 fbb6 	bl	49ac <m_print>

	bool aliStatus = ali_config_data_init();
     240:	f003 ffc8 	bl	41d4 <ali_config_data_init>
	if(!aliStatus){
     244:	2800      	cmp	r0, #0
     246:	d118      	bne.n	27a <main+0x8e>
		M_PRINTF(L_APP,"ali parameter error!");
     248:	6833      	ldr	r3, [r6, #0]
     24a:	049b      	lsls	r3, r3, #18
     24c:	d514      	bpl.n	278 <main+0x8c>
     24e:	0023      	movs	r3, r4
     250:	0022      	movs	r2, r4
     252:	0020      	movs	r0, r4
     254:	4d20      	ldr	r5, [pc, #128]	; (2d8 <main+0xec>)
     256:	334d      	adds	r3, #77	; 0x4d
     258:	0029      	movs	r1, r5
     25a:	3237      	adds	r2, #55	; 0x37
     25c:	9300      	str	r3, [sp, #0]
     25e:	303e      	adds	r0, #62	; 0x3e
     260:	237c      	movs	r3, #124	; 0x7c
     262:	f004 fba3 	bl	49ac <m_print>
     266:	0020      	movs	r0, r4
     268:	306b      	adds	r0, #107	; 0x6b
     26a:	f004 fb9f 	bl	49ac <m_print>
     26e:	0020      	movs	r0, r4
     270:	1da9      	adds	r1, r5, #6
     272:	3068      	adds	r0, #104	; 0x68
     274:	f004 fb9a 	bl	49ac <m_print>
     278:	e7fe      	b.n	278 <main+0x8c>
		while(1);
	}
		
	uint8_t bt_addr[6];
	ali_config_mac_read(bt_addr, 0);
     27a:	2100      	movs	r1, #0
     27c:	a802      	add	r0, sp, #8
     27e:	f003 ff8b 	bl	4198 <ali_config_mac_read>
	mesh_mac_set(true, bt_addr);
     282:	a902      	add	r1, sp, #8
     284:	2001      	movs	r0, #1
     286:	f007 fc59 	bl	7b3c <mesh_mac_set>
	HWRITE(mem_tx_power,0x02);
     28a:	2202      	movs	r2, #2
     28c:	4b13      	ldr	r3, [pc, #76]	; (2dc <main+0xf0>)
	
	tIPCControlBlock cb;
	memset(&cb, 0, sizeof(tIPCControlBlock));
     28e:	2100      	movs	r1, #0
	}
		
	uint8_t bt_addr[6];
	ali_config_mac_read(bt_addr, 0);
	mesh_mac_set(true, bt_addr);
	HWRITE(mem_tx_power,0x02);
     290:	701a      	strb	r2, [r3, #0]
	
	tIPCControlBlock cb;
	memset(&cb, 0, sizeof(tIPCControlBlock));
     292:	a804      	add	r0, sp, #16
     294:	3226      	adds	r2, #38	; 0x26
     296:	f015 fbd9 	bl	15a4c <memset>
	cb.blecb = Bt_BleCallBack;
     29a:	4b11      	ldr	r3, [pc, #68]	; (2e0 <main+0xf4>)
	cb.evtcb = Event_call_back;
	cb.advcb = Mesh_Adv_Cb;
	//cb.readreqcb = ble_read_req_cb;
	cb.readconnparamcb = ble_read_conn_param;
	
	IPC_Initialize(&cb);	//Register callback function.
     29c:	a804      	add	r0, sp, #16
	mesh_mac_set(true, bt_addr);
	HWRITE(mem_tx_power,0x02);
	
	tIPCControlBlock cb;
	memset(&cb, 0, sizeof(tIPCControlBlock));
	cb.blecb = Bt_BleCallBack;
     29e:	9308      	str	r3, [sp, #32]
	cb.evtcb = Event_call_back;
     2a0:	4b10      	ldr	r3, [pc, #64]	; (2e4 <main+0xf8>)
     2a2:	9304      	str	r3, [sp, #16]
	cb.advcb = Mesh_Adv_Cb;
     2a4:	4b10      	ldr	r3, [pc, #64]	; (2e8 <main+0xfc>)
     2a6:	9309      	str	r3, [sp, #36]	; 0x24
	//cb.readreqcb = ble_read_req_cb;
	cb.readconnparamcb = ble_read_conn_param;
     2a8:	4b10      	ldr	r3, [pc, #64]	; (2ec <main+0x100>)
     2aa:	930d      	str	r3, [sp, #52]	; 0x34
	
	IPC_Initialize(&cb);	//Register callback function.
     2ac:	f000 fb88 	bl	9c0 <IPC_Initialize>

#if (BLE_MESH)	
	if(aliStatus){
		app_mesh_init();
     2b0:	f002 fb94 	bl	29dc <app_mesh_init>
		app_mesh_start();
     2b4:	f002 fbec 	bl	2a90 <app_mesh_start>
	}
#endif/*BLE_MESH*/
	//WDT_Enable();

	gatt_ota_init();
     2b8:	f000 fb26 	bl	908 <gatt_ota_init>

	while(1){
		#if (BLE_MESH)
		if(OTANONE == gatt_ota_state_get())
     2bc:	f000 f83c 	bl	338 <gatt_ota_state_get>
     2c0:	2800      	cmp	r0, #0
     2c2:	d101      	bne.n	2c8 <main+0xdc>
			bc_m_mesh_loop();
     2c4:	f008 fffc 	bl	92c0 <bc_m_mesh_loop>
		#endif/*BLE_MESH*/
		//WDT_Kick();

		//ble process
		mesh_ble_process();	
     2c8:	f007 f8fc 	bl	74c4 <mesh_ble_process>
	}
     2cc:	e7f6      	b.n	2bc <main+0xd0>
     2ce:	46c0      	nop			; (mov r8, r8)
     2d0:	0001fd1c 	.word	0x0001fd1c
     2d4:	10010514 	.word	0x10010514
     2d8:	0001fc9c 	.word	0x0001fc9c
     2dc:	10004291 	.word	0x10004291
     2e0:	00000099 	.word	0x00000099
     2e4:	000000f9 	.word	0x000000f9
     2e8:	00000165 	.word	0x00000165
     2ec:	000001b1 	.word	0x000001b1

000002f0 <gatt_ota_start>:
void gatt_ota_start(void)
{
	//stop adv timer
//	SYS_ReleaseTimer(&stGattOtaAdvTimer);
	
	StartOtaFlag = NOSTART;
     2f0:	2201      	movs	r2, #1
     2f2:	4b07      	ldr	r3, [pc, #28]	; (310 <gatt_ota_start+0x20>)

/*used to period set Gatt Ota adv data*/
//static SYS_TIMER_TYPE stGattOtaAdvTimer;//peroid timer	

void gatt_ota_start(void)
{
     2f4:	b510      	push	{r4, lr}
	//stop adv timer
//	SYS_ReleaseTimer(&stGattOtaAdvTimer);
	
	StartOtaFlag = NOSTART;
	IPC_TxControlCmd(IPC_CMD_MTU_EXCHANGE);
     2f6:	2021      	movs	r0, #33	; 0x21
void gatt_ota_start(void)
{
	//stop adv timer
//	SYS_ReleaseTimer(&stGattOtaAdvTimer);
	
	StartOtaFlag = NOSTART;
     2f8:	701a      	strb	r2, [r3, #0]
	IPC_TxControlCmd(IPC_CMD_MTU_EXCHANGE);
     2fa:	f000 fc18 	bl	b2e <IPC_TxControlCmd>
	HWRITE(mem_le_scan_enable,0x00);//stop scan
     2fe:	2300      	movs	r3, #0
     300:	4a04      	ldr	r2, [pc, #16]	; (314 <gatt_ota_start+0x24>)
	HWRITE(mem_le_adv_enable,0x00);//stop adv

	IPC_TxControlCmd(IPC_CMD_UPDATA_CONN);
     302:	2012      	movs	r0, #18
	//stop adv timer
//	SYS_ReleaseTimer(&stGattOtaAdvTimer);
	
	StartOtaFlag = NOSTART;
	IPC_TxControlCmd(IPC_CMD_MTU_EXCHANGE);
	HWRITE(mem_le_scan_enable,0x00);//stop scan
     304:	7013      	strb	r3, [r2, #0]
	HWRITE(mem_le_adv_enable,0x00);//stop adv
     306:	4a04      	ldr	r2, [pc, #16]	; (318 <gatt_ota_start+0x28>)
     308:	7013      	strb	r3, [r2, #0]

	IPC_TxControlCmd(IPC_CMD_UPDATA_CONN);
     30a:	f000 fc10 	bl	b2e <IPC_TxControlCmd>
}
     30e:	bd10      	pop	{r4, pc}
     310:	10010f60 	.word	0x10010f60
     314:	100043ab 	.word	0x100043ab
     318:	100043b1 	.word	0x100043b1

0000031c <gatt_ota_stop>:

void gatt_ota_stop(void)
{
	StartOtaFlag = OTANONE;
     31c:	2200      	movs	r2, #0

	IPC_TxControlCmd(IPC_CMD_UPDATA_CONN);
}

void gatt_ota_stop(void)
{
     31e:	b510      	push	{r4, lr}
	StartOtaFlag = OTANONE;
     320:	4b03      	ldr	r3, [pc, #12]	; (330 <gatt_ota_stop+0x14>)
     322:	701a      	strb	r2, [r3, #0]
	HWRITE(mem_le_scan_enable,0x01);//enable scan
     324:	4b03      	ldr	r3, [pc, #12]	; (334 <gatt_ota_stop+0x18>)
     326:	3201      	adds	r2, #1
     328:	701a      	strb	r2, [r3, #0]
	//start adv timer
	gatt_ota_init();
     32a:	f000 faed 	bl	908 <gatt_ota_init>
}
     32e:	bd10      	pop	{r4, pc}
     330:	10010f60 	.word	0x10010f60
     334:	100043ab 	.word	0x100043ab

00000338 <gatt_ota_state_get>:

uint8_t gatt_ota_state_get(void)
{
	return StartOtaFlag;
     338:	4b01      	ldr	r3, [pc, #4]	; (340 <gatt_ota_state_get+0x8>)
     33a:	7818      	ldrb	r0, [r3, #0]
}
     33c:	4770      	bx	lr
     33e:	46c0      	nop			; (mov r8, r8)
     340:	10010f60 	.word	0x10010f60

00000344 <ota_prog_addr>:
  *@param None.
  *@@return 1:running app one
			2:running app two
  */
uint8_t ota_prog_addr()
{
     344:	b513      	push	{r0, r1, r4, lr}
	uint8_t saddr[3]; 
	uint32_t uintStart;
	QSPI_Init();
	QSPI_ReadFlashData(0,3,saddr);//从flash的特定地址读出数据
     346:	ac01      	add	r4, sp, #4
  */
uint8_t ota_prog_addr()
{
	uint8_t saddr[3]; 
	uint32_t uintStart;
	QSPI_Init();
     348:	f001 f8a4 	bl	1494 <QSPI_Init>
	QSPI_ReadFlashData(0,3,saddr);//从flash的特定地址读出数据
     34c:	0022      	movs	r2, r4
     34e:	2103      	movs	r1, #3
     350:	2000      	movs	r0, #0
     352:	f000 fda5 	bl	ea0 <QSPI_ReadFlashData>
	uintStart = ((saddr[0] << 16) + (saddr[1] << 8) + saddr[2]);
	//M_PRINTF(L_APP, "uintStart[%x]", uintStart);
	if(uintStart == CODE_UPGRADE_START_ADDR+PAGE_SIZE+3){
     356:	7820      	ldrb	r0, [r4, #0]
     358:	7863      	ldrb	r3, [r4, #1]
     35a:	0400      	lsls	r0, r0, #16
     35c:	021b      	lsls	r3, r3, #8
     35e:	18c0      	adds	r0, r0, r3
     360:	78a3      	ldrb	r3, [r4, #2]
     362:	18c0      	adds	r0, r0, r3
		return APP_TWO;
	}
	return APP_ONE;
     364:	4b02      	ldr	r3, [pc, #8]	; (370 <ota_prog_addr+0x2c>)
     366:	18c0      	adds	r0, r0, r3
     368:	4243      	negs	r3, r0
     36a:	4158      	adcs	r0, r3
     36c:	3001      	adds	r0, #1
}
     36e:	bd16      	pop	{r1, r2, r4, pc}
     370:	fffc1efd 	.word	0xfffc1efd

00000374 <ota_crc16_ccitt>:

int ota_crc16_ccitt(int crc, int c)
{
	crc  = (crc >> 8) | (crc << 8);
     374:	1203      	asrs	r3, r0, #8
     376:	0200      	lsls	r0, r0, #8
     378:	4318      	orrs	r0, r3
	crc ^= c & 0xff;	
	crc ^= (crc & 0xff) >> 4;	
	crc ^= crc << 12;	
	crc ^= (crc & 0xff) << 5;	
     37a:	23ff      	movs	r3, #255	; 0xff
}

int ota_crc16_ccitt(int crc, int c)
{
	crc  = (crc >> 8) | (crc << 8);
	crc ^= c & 0xff;	
     37c:	b2c9      	uxtb	r1, r1
     37e:	4048      	eors	r0, r1
	crc ^= (crc & 0xff) >> 4;	
     380:	0601      	lsls	r1, r0, #24
     382:	0f09      	lsrs	r1, r1, #28
     384:	4048      	eors	r0, r1
	crc ^= crc << 12;	
     386:	0301      	lsls	r1, r0, #12
     388:	4048      	eors	r0, r1
	crc ^= (crc & 0xff) << 5;	
     38a:	0142      	lsls	r2, r0, #5
     38c:	015b      	lsls	r3, r3, #5
     38e:	4013      	ands	r3, r2
     390:	4058      	eors	r0, r3
	crc &= 0xffff;	
	return crc;
     392:	b280      	uxth	r0, r0
}
     394:	4770      	bx	lr

00000396 <ota_calc_crc>:

uint16_t ota_calc_crc(uint32_t flashaddr,uint32_t len)
{
     396:	000b      	movs	r3, r1
     398:	b5f0      	push	{r4, r5, r6, r7, lr}
     39a:	33ff      	adds	r3, #255	; 0xff
     39c:	b0c5      	sub	sp, #276	; 0x114
     39e:	0a1b      	lsrs	r3, r3, #8
     3a0:	9303      	str	r3, [sp, #12]
	int i,j,crc;
	uint8_t readbyte[256];
	uint32_t readlen = 0;
	uint32_t readtimes = (len+READ_UINT-1)/READ_UINT;
	crc=0xffff;
	for(i=0;i< readtimes; i++){
     3a2:	2300      	movs	r3, #0
	crc &= 0xffff;	
	return crc;
}

uint16_t ota_calc_crc(uint32_t flashaddr,uint32_t len)
{
     3a4:	000e      	movs	r6, r1
	int i,j,crc;
	uint8_t readbyte[256];
	uint32_t readlen = 0;
	uint32_t readtimes = (len+READ_UINT-1)/READ_UINT;
	crc=0xffff;
     3a6:	4f15      	ldr	r7, [pc, #84]	; (3fc <ota_calc_crc+0x66>)
	crc &= 0xffff;	
	return crc;
}

uint16_t ota_calc_crc(uint32_t flashaddr,uint32_t len)
{
     3a8:	9002      	str	r0, [sp, #8]
	int i,j,crc;
	uint8_t readbyte[256];
	uint32_t readlen = 0;
	uint32_t readtimes = (len+READ_UINT-1)/READ_UINT;
	crc=0xffff;
	for(i=0;i< readtimes; i++){
     3aa:	9301      	str	r3, [sp, #4]
     3ac:	9b01      	ldr	r3, [sp, #4]
     3ae:	9a03      	ldr	r2, [sp, #12]
     3b0:	4293      	cmp	r3, r2
     3b2:	d01f      	beq.n	3f4 <ota_calc_crc+0x5e>
		readlen = len > READ_UINT ? READ_UINT : len;
     3b4:	2380      	movs	r3, #128	; 0x80
     3b6:	0034      	movs	r4, r6
     3b8:	005b      	lsls	r3, r3, #1
     3ba:	429e      	cmp	r6, r3
     3bc:	d900      	bls.n	3c0 <ota_calc_crc+0x2a>
     3be:	001c      	movs	r4, r3

		QSPI_Init();
		QSPI_ReadFlashData(flashaddr,readlen,readbyte);
		flashaddr += readlen;
		len -= readlen;
		for(j=0;j<readlen;j++) {
     3c0:	2500      	movs	r5, #0
	uint32_t readtimes = (len+READ_UINT-1)/READ_UINT;
	crc=0xffff;
	for(i=0;i< readtimes; i++){
		readlen = len > READ_UINT ? READ_UINT : len;

		QSPI_Init();
     3c2:	f001 f867 	bl	1494 <QSPI_Init>
		QSPI_ReadFlashData(flashaddr,readlen,readbyte);
     3c6:	aa04      	add	r2, sp, #16
     3c8:	0021      	movs	r1, r4
     3ca:	9802      	ldr	r0, [sp, #8]
     3cc:	f000 fd68 	bl	ea0 <QSPI_ReadFlashData>
		flashaddr += readlen;
     3d0:	9b02      	ldr	r3, [sp, #8]
		len -= readlen;
     3d2:	1b36      	subs	r6, r6, r4
	for(i=0;i< readtimes; i++){
		readlen = len > READ_UINT ? READ_UINT : len;

		QSPI_Init();
		QSPI_ReadFlashData(flashaddr,readlen,readbyte);
		flashaddr += readlen;
     3d4:	191b      	adds	r3, r3, r4
     3d6:	9302      	str	r3, [sp, #8]
		len -= readlen;
		for(j=0;j<readlen;j++) {
     3d8:	42a5      	cmp	r5, r4
     3da:	d007      	beq.n	3ec <ota_calc_crc+0x56>
			crc = ota_crc16_ccitt(crc,*(readbyte+j));
     3dc:	ab04      	add	r3, sp, #16
     3de:	5d59      	ldrb	r1, [r3, r5]
     3e0:	0038      	movs	r0, r7
     3e2:	f7ff ffc7 	bl	374 <ota_crc16_ccitt>

		QSPI_Init();
		QSPI_ReadFlashData(flashaddr,readlen,readbyte);
		flashaddr += readlen;
		len -= readlen;
		for(j=0;j<readlen;j++) {
     3e6:	3501      	adds	r5, #1
			crc = ota_crc16_ccitt(crc,*(readbyte+j));
     3e8:	0007      	movs	r7, r0
     3ea:	e7f5      	b.n	3d8 <ota_calc_crc+0x42>
	int i,j,crc;
	uint8_t readbyte[256];
	uint32_t readlen = 0;
	uint32_t readtimes = (len+READ_UINT-1)/READ_UINT;
	crc=0xffff;
	for(i=0;i< readtimes; i++){
     3ec:	9b01      	ldr	r3, [sp, #4]
     3ee:	3301      	adds	r3, #1
     3f0:	9301      	str	r3, [sp, #4]
     3f2:	e7db      	b.n	3ac <ota_calc_crc+0x16>
		len -= readlen;
		for(j=0;j<readlen;j++) {
			crc = ota_crc16_ccitt(crc,*(readbyte+j));
		}
	}
	return crc;
     3f4:	b2b8      	uxth	r0, r7
}
     3f6:	b045      	add	sp, #276	; 0x114
     3f8:	bdf0      	pop	{r4, r5, r6, r7, pc}
     3fa:	46c0      	nop			; (mov r8, r8)
     3fc:	0000ffff 	.word	0x0000ffff

00000400 <ota_prog_switch>:

void ota_prog_switch()
{
     400:	b537      	push	{r0, r1, r2, r4, r5, lr}
	uint8_t bootaddr[3]; 
	uint32_t startAddr;
	if(ota_prog_addr()==APP_TWO){
     402:	f7ff ff9f 	bl	344 <ota_prog_addr>
     406:	2802      	cmp	r0, #2
     408:	d001      	beq.n	40e <ota_prog_switch+0xe>
		startAddr = CODE_START_ADDR+PAGE_SIZE+3;
		
	}else{
		startAddr = CODE_UPGRADE_START_ADDR+PAGE_SIZE+3;
     40a:	4b0c      	ldr	r3, [pc, #48]	; (43c <ota_prog_switch+0x3c>)
     40c:	e001      	b.n	412 <ota_prog_switch+0x12>
void ota_prog_switch()
{
	uint8_t bootaddr[3]; 
	uint32_t startAddr;
	if(ota_prog_addr()==APP_TWO){
		startAddr = CODE_START_ADDR+PAGE_SIZE+3;
     40e:	2304      	movs	r3, #4
     410:	33ff      	adds	r3, #255	; 0xff
	}else{
		startAddr = CODE_UPGRADE_START_ADDR+PAGE_SIZE+3;
	}
	bootaddr[0] = (startAddr>>16)&0xff;
	bootaddr[1] = (startAddr>> 8)&0xff;
	bootaddr[2] = (startAddr>> 0)&0xff;
     412:	2503      	movs	r5, #3
		startAddr = CODE_START_ADDR+PAGE_SIZE+3;
		
	}else{
		startAddr = CODE_UPGRADE_START_ADDR+PAGE_SIZE+3;
	}
	bootaddr[0] = (startAddr>>16)&0xff;
     414:	ac01      	add	r4, sp, #4
     416:	0c1a      	lsrs	r2, r3, #16
	bootaddr[1] = (startAddr>> 8)&0xff;
     418:	0a1b      	lsrs	r3, r3, #8
     41a:	7063      	strb	r3, [r4, #1]
		startAddr = CODE_START_ADDR+PAGE_SIZE+3;
		
	}else{
		startAddr = CODE_UPGRADE_START_ADDR+PAGE_SIZE+3;
	}
	bootaddr[0] = (startAddr>>16)&0xff;
     41c:	7022      	strb	r2, [r4, #0]
	bootaddr[1] = (startAddr>> 8)&0xff;
	bootaddr[2] = (startAddr>> 0)&0xff;
     41e:	70a5      	strb	r5, [r4, #2]
	//m_printf_hex(L_APP, "ota_prog_switch", bootaddr, 3);
	QSPI_Init();
     420:	f001 f838 	bl	1494 <QSPI_Init>
	QSPI_PageEraseFlash(0x00);
     424:	2000      	movs	r0, #0
     426:	f000 ffbb 	bl	13a0 <QSPI_PageEraseFlash>
	//QSPI_SectorEraseFlash(0x00);
	QSPI_WriteFlashData(0x00,3,bootaddr);
     42a:	0029      	movs	r1, r5
     42c:	0022      	movs	r2, r4
     42e:	2000      	movs	r0, #0
     430:	f000 fe76 	bl	1120 <QSPI_WriteFlashData>
	HW_REG_8BIT(reg_map(CORE_RESET),0x03);
     434:	4b02      	ldr	r3, [pc, #8]	; (440 <ota_prog_switch+0x40>)
     436:	701d      	strb	r5, [r3, #0]
}
     438:	bd37      	pop	{r0, r1, r2, r4, r5, pc}
     43a:	46c0      	nop			; (mov r8, r8)
     43c:	0003e103 	.word	0x0003e103
     440:	10008010 	.word	0x10008010

00000444 <ota_code_crc>:
  *@param None.
  *@return !0: fail.
			0: pass.
*/
int8_t ota_code_crc(uint32_t len)
{
     444:	b5f0      	push	{r4, r5, r6, r7, lr}
     446:	b087      	sub	sp, #28
     448:	9003      	str	r0, [sp, #12]
	uint32_t flashaddr,flashaddrS,varaddr;
	uint8_t readbuf[4];
	uint32_t length = 0;
	uint16_t crc;
	//step1:get app flashaddr	
	if(ota_prog_addr() == APP_TWO){ //check out addr 0x1000 code
     44a:	f7ff ff7b 	bl	344 <ota_prog_addr>
     44e:	2802      	cmp	r0, #2
     450:	d102      	bne.n	458 <ota_code_crc+0x14>
		flashaddrS = CODE_START_ADDR+PAGE_SIZE+3;//0x2003;
     452:	2704      	movs	r7, #4
     454:	37ff      	adds	r7, #255	; 0xff
     456:	e000      	b.n	45a <ota_code_crc+0x16>
	}
	else{
		flashaddrS = CODE_UPGRADE_START_ADDR+PAGE_SIZE+3;//0x40003;
     458:	4f5a      	ldr	r7, [pc, #360]	; (5c4 <ota_code_crc+0x180>)
	}
	flashaddr = flashaddrS;

	//step2:get 0xaa55 and length	
	QSPI_Init();
	QSPI_ReadFlashData(flashaddr,4,readbuf);
     45a:	ac05      	add	r4, sp, #20
		flashaddrS = CODE_UPGRADE_START_ADDR+PAGE_SIZE+3;//0x40003;
	}
	flashaddr = flashaddrS;

	//step2:get 0xaa55 and length	
	QSPI_Init();
     45c:	f001 f81a 	bl	1494 <QSPI_Init>
	QSPI_ReadFlashData(flashaddr,4,readbuf);
     460:	0022      	movs	r2, r4
     462:	2104      	movs	r1, #4
     464:	0038      	movs	r0, r7
     466:	f000 fd1b 	bl	ea0 <QSPI_ReadFlashData>
	if(!(*readbuf == 0xaa && *(readbuf+1) == 0x55))
     46a:	7823      	ldrb	r3, [r4, #0]
     46c:	2baa      	cmp	r3, #170	; 0xaa
     46e:	d000      	beq.n	472 <ota_code_crc+0x2e>
     470:	e091      	b.n	596 <ota_code_crc+0x152>
     472:	7863      	ldrb	r3, [r4, #1]
     474:	2b55      	cmp	r3, #85	; 0x55
     476:	d000      	beq.n	47a <ota_code_crc+0x36>
     478:	e08d      	b.n	596 <ota_code_crc+0x152>
		return -1;
	length |= *(readbuf+2);
	length |= *(readbuf+3)<<8;
     47a:	8863      	ldrh	r3, [r4, #2]
	flashaddr += 4;
     47c:	1d3d      	adds	r5, r7, #4

	//step3:get bt code
	crc = ota_calc_crc(flashaddr,length-2);	
     47e:	1e99      	subs	r1, r3, #2
     480:	0028      	movs	r0, r5
	QSPI_Init();
	QSPI_ReadFlashData(flashaddr,4,readbuf);
	if(!(*readbuf == 0xaa && *(readbuf+1) == 0x55))
		return -1;
	length |= *(readbuf+2);
	length |= *(readbuf+3)<<8;
     482:	9301      	str	r3, [sp, #4]
	flashaddr += 4;

	//step3:get bt code
	crc = ota_calc_crc(flashaddr,length-2);	
     484:	f7ff ff87 	bl	396 <ota_calc_crc>
     488:	0006      	movs	r6, r0
	flashaddr += length;
     48a:	9b01      	ldr	r3, [sp, #4]
     48c:	195d      	adds	r5, r3, r5

	//step4:compare to bt code crc
	QSPI_Init();
     48e:	f001 f801 	bl	1494 <QSPI_Init>
	QSPI_ReadFlashData(flashaddr-2,2,readbuf);
     492:	0022      	movs	r2, r4
     494:	1ea8      	subs	r0, r5, #2
     496:	2102      	movs	r1, #2
     498:	f000 fd02 	bl	ea0 <QSPI_ReadFlashData>

	if(!(*(readbuf+1) == (crc&0xff) && *readbuf == ((crc>>8)&0xff)))
     49c:	7862      	ldrb	r2, [r4, #1]
     49e:	b2f3      	uxtb	r3, r6
     4a0:	429a      	cmp	r2, r3
     4a2:	d17b      	bne.n	59c <ota_code_crc+0x158>
     4a4:	0a36      	lsrs	r6, r6, #8
     4a6:	7823      	ldrb	r3, [r4, #0]
     4a8:	b2b6      	uxth	r6, r6
     4aa:	42b3      	cmp	r3, r6
     4ac:	d176      	bne.n	59c <ota_code_crc+0x158>
		return -2;

	//step5:skip variable data
	while(1){
		length = 0;
		QSPI_Init();
     4ae:	f000 fff1 	bl	1494 <QSPI_Init>
		QSPI_ReadFlashData(flashaddr,4,readbuf);
     4b2:	0022      	movs	r2, r4
     4b4:	2104      	movs	r1, #4
     4b6:	0028      	movs	r0, r5
     4b8:	f000 fcf2 	bl	ea0 <QSPI_ReadFlashData>
		if(!(*readbuf == 0xaa && *(readbuf+1) == 0x55))
     4bc:	7823      	ldrb	r3, [r4, #0]
     4be:	2baa      	cmp	r3, #170	; 0xaa
     4c0:	d16f      	bne.n	5a2 <ota_code_crc+0x15e>
     4c2:	7863      	ldrb	r3, [r4, #1]
     4c4:	2b55      	cmp	r3, #85	; 0x55
     4c6:	d16c      	bne.n	5a2 <ota_code_crc+0x15e>
			return -3;
		length |= *(readbuf+2);
		length |= *(readbuf+3)<<8;

		flashaddr = flashaddr+length+6;
     4c8:	8866      	ldrh	r6, [r4, #2]
		QSPI_Init();
     4ca:	f000 ffe3 	bl	1494 <QSPI_Init>
		if(!(*readbuf == 0xaa && *(readbuf+1) == 0x55))
			return -3;
		length |= *(readbuf+2);
		length |= *(readbuf+3)<<8;

		flashaddr = flashaddr+length+6;
     4ce:	1976      	adds	r6, r6, r5
     4d0:	1db5      	adds	r5, r6, #6
		QSPI_Init();
		QSPI_ReadFlashData(flashaddr,1,readbuf);
     4d2:	0022      	movs	r2, r4
     4d4:	2101      	movs	r1, #1
     4d6:	0028      	movs	r0, r5
     4d8:	f000 fce2 	bl	ea0 <QSPI_ReadFlashData>
		if(*readbuf == 0xff)
     4dc:	7823      	ldrb	r3, [r4, #0]
     4de:	9301      	str	r3, [sp, #4]
     4e0:	2bff      	cmp	r3, #255	; 0xff
     4e2:	d1e4      	bne.n	4ae <ota_code_crc+0x6a>
		{	
			QSPI_ReadFlashData(flashaddr-3,3,readbuf);
     4e4:	1cf0      	adds	r0, r6, #3
     4e6:	2103      	movs	r1, #3
     4e8:	0022      	movs	r2, r4
     4ea:	f000 fcd9 	bl	ea0 <QSPI_ReadFlashData>
			varaddr  = *(readbuf);
			varaddr |= *(readbuf+1) << 8;
			varaddr |= *(readbuf+2) << 24;
     4ee:	7865      	ldrb	r5, [r4, #1]
     4f0:	78a3      	ldrb	r3, [r4, #2]
		QSPI_Init();
		QSPI_ReadFlashData(flashaddr,1,readbuf);
		if(*readbuf == 0xff)
		{	
			QSPI_ReadFlashData(flashaddr-3,3,readbuf);
			varaddr  = *(readbuf);
     4f2:	7822      	ldrb	r2, [r4, #0]
			varaddr |= *(readbuf+1) << 8;
			varaddr |= *(readbuf+2) << 24;
     4f4:	061b      	lsls	r3, r3, #24
     4f6:	022d      	lsls	r5, r5, #8
     4f8:	431d      	orrs	r5, r3
     4fa:	4315      	orrs	r5, r2
			break;	
		}
	}
	flashaddr++;
	//step6:get m0 code
	QSPI_Init();
     4fc:	f000 ffca 	bl	1494 <QSPI_Init>
	QSPI_ReadFlashData(flashaddr,4,readbuf);
     500:	1df0      	adds	r0, r6, #7
     502:	0022      	movs	r2, r4
     504:	2104      	movs	r1, #4
     506:	f000 fccb 	bl	ea0 <QSPI_ReadFlashData>
	if(!(*readbuf == 0xaa && *(readbuf+1) == 0x55))
     50a:	7823      	ldrb	r3, [r4, #0]
     50c:	2baa      	cmp	r3, #170	; 0xaa
     50e:	d14b      	bne.n	5a8 <ota_code_crc+0x164>
     510:	7863      	ldrb	r3, [r4, #1]
     512:	2b55      	cmp	r3, #85	; 0x55
     514:	d148      	bne.n	5a8 <ota_code_crc+0x164>
	length = 0;
	length |= *(readbuf+2);
	length |= *(readbuf+3)<<8;
	flashaddr += 4;
	
	if(((len - varaddr - 2)&0x00ffff) != length){
     516:	9b03      	ldr	r3, [sp, #12]
     518:	8862      	ldrh	r2, [r4, #2]
     51a:	1b5d      	subs	r5, r3, r5
     51c:	1eab      	subs	r3, r5, #2
	if(!(*readbuf == 0xaa && *(readbuf+1) == 0x55))
		return -5;
	length = 0;
	length |= *(readbuf+2);
	length |= *(readbuf+3)<<8;
	flashaddr += 4;
     51e:	360b      	adds	r6, #11
	
	if(((len - varaddr - 2)&0x00ffff) != length){
     520:	b29b      	uxth	r3, r3
	if(!(*readbuf == 0xaa && *(readbuf+1) == 0x55))
		return -5;
	length = 0;
	length |= *(readbuf+2);
	length |= *(readbuf+3)<<8;
	flashaddr += 4;
     522:	9602      	str	r6, [sp, #8]
	
	if(((len - varaddr - 2)&0x00ffff) != length){
     524:	429a      	cmp	r2, r3
     526:	d142      	bne.n	5ae <ota_code_crc+0x16a>
		return -6;
	}
	crc = ota_calc_crc(flashaddr,(len-varaddr-4));
     528:	1f29      	subs	r1, r5, #4
     52a:	0030      	movs	r0, r6
     52c:	f7ff ff33 	bl	396 <ota_calc_crc>
     530:	0006      	movs	r6, r0
	//flashaddr += length;
	flashaddr += (len-varaddr-2);
     532:	9b02      	ldr	r3, [sp, #8]
     534:	195d      	adds	r5, r3, r5
	//step7: compare m0 code crc
	QSPI_Init();
     536:	f000 ffad 	bl	1494 <QSPI_Init>
	QSPI_ReadFlashData(flashaddr-2,2,readbuf);
     53a:	0022      	movs	r2, r4
     53c:	1f28      	subs	r0, r5, #4
     53e:	2102      	movs	r1, #2
     540:	f000 fcae 	bl	ea0 <QSPI_ReadFlashData>

	if(!(*(readbuf+1) == (crc&0xff) && *readbuf == ((crc>>8)&0xff)))
     544:	9b01      	ldr	r3, [sp, #4]
     546:	7862      	ldrb	r2, [r4, #1]
     548:	4033      	ands	r3, r6
     54a:	429a      	cmp	r2, r3
     54c:	d132      	bne.n	5b4 <ota_code_crc+0x170>
     54e:	0a36      	lsrs	r6, r6, #8
     550:	7823      	ldrb	r3, [r4, #0]
     552:	b2b6      	uxth	r6, r6
     554:	42b3      	cmp	r3, r6
     556:	d12d      	bne.n	5b4 <ota_code_crc+0x170>
	if(((len - varaddr - 2)&0x00ffff) != length){
		return -6;
	}
	crc = ota_calc_crc(flashaddr,(len-varaddr-4));
	//flashaddr += length;
	flashaddr += (len-varaddr-2);
     558:	3d02      	subs	r5, #2

	//step8: calc all crc
	length = flashaddr - flashaddrS; 
	flashaddr = flashaddrS;

	crc = ota_calc_crc( flashaddr, length);
     55a:	1be9      	subs	r1, r5, r7
     55c:	0038      	movs	r0, r7
     55e:	f7ff ff1a 	bl	396 <ota_calc_crc>
     562:	0006      	movs	r6, r0
	flashaddr += length;
	
	//step9: compare all code crc
	printf("last crc addr= %lx\n",flashaddr);
     564:	4818      	ldr	r0, [pc, #96]	; (5c8 <ota_code_crc+0x184>)
     566:	0029      	movs	r1, r5
     568:	3009      	adds	r0, #9
     56a:	f015 fac7 	bl	15afc <printf>
	QSPI_Init();
     56e:	f000 ff91 	bl	1494 <QSPI_Init>
	QSPI_ReadFlashData(flashaddr,2,readbuf);
     572:	0022      	movs	r2, r4
     574:	2102      	movs	r1, #2
     576:	0028      	movs	r0, r5
     578:	f000 fc92 	bl	ea0 <QSPI_ReadFlashData>
	
	if(!(*(readbuf+1) == (crc&0xff) && *readbuf == ((crc>>8)&0xff)))
     57c:	9b01      	ldr	r3, [sp, #4]
     57e:	7862      	ldrb	r2, [r4, #1]
     580:	4033      	ands	r3, r6
     582:	429a      	cmp	r2, r3
     584:	d119      	bne.n	5ba <ota_code_crc+0x176>
     586:	0a36      	lsrs	r6, r6, #8
     588:	7823      	ldrb	r3, [r4, #0]
     58a:	b2b6      	uxth	r6, r6
		return -8;

	return 0;
     58c:	2000      	movs	r0, #0
	//step9: compare all code crc
	printf("last crc addr= %lx\n",flashaddr);
	QSPI_Init();
	QSPI_ReadFlashData(flashaddr,2,readbuf);
	
	if(!(*(readbuf+1) == (crc&0xff) && *readbuf == ((crc>>8)&0xff)))
     58e:	42b3      	cmp	r3, r6
     590:	d015      	beq.n	5be <ota_code_crc+0x17a>
		return -8;
     592:	3808      	subs	r0, #8
     594:	e013      	b.n	5be <ota_code_crc+0x17a>

	//step2:get 0xaa55 and length	
	QSPI_Init();
	QSPI_ReadFlashData(flashaddr,4,readbuf);
	if(!(*readbuf == 0xaa && *(readbuf+1) == 0x55))
		return -1;
     596:	2001      	movs	r0, #1
     598:	4240      	negs	r0, r0
     59a:	e010      	b.n	5be <ota_code_crc+0x17a>
	//step4:compare to bt code crc
	QSPI_Init();
	QSPI_ReadFlashData(flashaddr-2,2,readbuf);

	if(!(*(readbuf+1) == (crc&0xff) && *readbuf == ((crc>>8)&0xff)))
		return -2;
     59c:	2002      	movs	r0, #2
     59e:	4240      	negs	r0, r0
     5a0:	e00d      	b.n	5be <ota_code_crc+0x17a>
	while(1){
		length = 0;
		QSPI_Init();
		QSPI_ReadFlashData(flashaddr,4,readbuf);
		if(!(*readbuf == 0xaa && *(readbuf+1) == 0x55))
			return -3;
     5a2:	2003      	movs	r0, #3
     5a4:	4240      	negs	r0, r0
     5a6:	e00a      	b.n	5be <ota_code_crc+0x17a>
	flashaddr++;
	//step6:get m0 code
	QSPI_Init();
	QSPI_ReadFlashData(flashaddr,4,readbuf);
	if(!(*readbuf == 0xaa && *(readbuf+1) == 0x55))
		return -5;
     5a8:	2005      	movs	r0, #5
     5aa:	4240      	negs	r0, r0
     5ac:	e007      	b.n	5be <ota_code_crc+0x17a>
	length |= *(readbuf+2);
	length |= *(readbuf+3)<<8;
	flashaddr += 4;
	
	if(((len - varaddr - 2)&0x00ffff) != length){
		return -6;
     5ae:	2006      	movs	r0, #6
     5b0:	4240      	negs	r0, r0
     5b2:	e004      	b.n	5be <ota_code_crc+0x17a>
	//step7: compare m0 code crc
	QSPI_Init();
	QSPI_ReadFlashData(flashaddr-2,2,readbuf);

	if(!(*(readbuf+1) == (crc&0xff) && *readbuf == ((crc>>8)&0xff)))
		return -7;
     5b4:	2007      	movs	r0, #7
     5b6:	4240      	negs	r0, r0
     5b8:	e001      	b.n	5be <ota_code_crc+0x17a>
	printf("last crc addr= %lx\n",flashaddr);
	QSPI_Init();
	QSPI_ReadFlashData(flashaddr,2,readbuf);
	
	if(!(*(readbuf+1) == (crc&0xff) && *readbuf == ((crc>>8)&0xff)))
		return -8;
     5ba:	2008      	movs	r0, #8
     5bc:	4240      	negs	r0, r0

	return 0;
}
     5be:	b007      	add	sp, #28
     5c0:	bdf0      	pop	{r4, r5, r6, r7, pc}
     5c2:	46c0      	nop			; (mov r8, r8)
     5c4:	0003e103 	.word	0x0003e103
     5c8:	0001fd9c 	.word	0x0001fd9c

000005cc <Ble_SendDataSimple>:


void Ble_SendDataSimple(uint16_t handle, uint8_t* data, uint16_t len)//eg handle = 0x0008
{	
     5cc:	b510      	push	{r4, lr}
	int cnt;
	if(len<0 || len>20)
     5ce:	2a14      	cmp	r2, #20
     5d0:	d801      	bhi.n	5d6 <Ble_SendDataSimple+0xa>
     5d2:	f000 f9b5 	bl	940 <Ble_SendDataSimple.part.0>
	//	memcpy(dataAy,data,len);
	for(cnt=0; cnt<len+2; cnt++)
		*(dataAy+cnt) = *(data+cnt);
		
	IPC_TxPacket(temp);
}
     5d6:	bd10      	pop	{r4, pc}

000005d8 <OTA_flash_init>:
**/
static uint32_t otaErasePage;
static uint32_t writeAddr;
uint8_t OTA_flash_init(uint32_t startAdd)
{
	otaErasePage = startAdd&PAGE_MASK;
     5d8:	23ff      	movs	r3, #255	; 0xff
     5da:	0002      	movs	r2, r0
 ** return !0:write failed.
**/
static uint32_t otaErasePage;
static uint32_t writeAddr;
uint8_t OTA_flash_init(uint32_t startAdd)
{
     5dc:	b510      	push	{r4, lr}
	otaErasePage = startAdd&PAGE_MASK;
     5de:	4c05      	ldr	r4, [pc, #20]	; (5f4 <OTA_flash_init+0x1c>)
     5e0:	439a      	bics	r2, r3
     5e2:	60a2      	str	r2, [r4, #8]
	writeAddr = startAdd;
     5e4:	60e0      	str	r0, [r4, #12]
	QSPI_Init();
     5e6:	f000 ff55 	bl	1494 <QSPI_Init>
	QSPI_PageEraseFlash(otaErasePage);
     5ea:	68a0      	ldr	r0, [r4, #8]
     5ec:	f000 fed8 	bl	13a0 <QSPI_PageEraseFlash>
	return 0;
}
     5f0:	2000      	movs	r0, #0
     5f2:	bd10      	pop	{r4, pc}
     5f4:	10010f60 	.word	0x10010f60

000005f8 <OTA_WriteFlash>:

uint8_t OTA_WriteFlash(uint32_t flashaddr, uint32_t len, uint8_t* data)
{
     5f8:	b5f0      	push	{r4, r5, r6, r7, lr}
	//	if(data[i]!=tbuf[i])
	//		return -1;
	//}
	//erase reserve byte of page
	//M_PRINTF(L_APP, "flashaddr[%x] otaErasePage[%x] writeAddr[%x]", flashaddr, otaErasePage, writeAddr);
	if(writeAddr > flashaddr){//write back
     5fa:	4d2c      	ldr	r5, [pc, #176]	; (6ac <OTA_WriteFlash+0xb4>)
	QSPI_PageEraseFlash(otaErasePage);
	return 0;
}

uint8_t OTA_WriteFlash(uint32_t flashaddr, uint32_t len, uint8_t* data)
{
     5fc:	4c2c      	ldr	r4, [pc, #176]	; (6b0 <OTA_WriteFlash+0xb8>)
	//	if(data[i]!=tbuf[i])
	//		return -1;
	//}
	//erase reserve byte of page
	//M_PRINTF(L_APP, "flashaddr[%x] otaErasePage[%x] writeAddr[%x]", flashaddr, otaErasePage, writeAddr);
	if(writeAddr > flashaddr){//write back
     5fe:	68eb      	ldr	r3, [r5, #12]
	QSPI_PageEraseFlash(otaErasePage);
	return 0;
}

uint8_t OTA_WriteFlash(uint32_t flashaddr, uint32_t len, uint8_t* data)
{
     600:	44a5      	add	sp, r4
     602:	000f      	movs	r7, r1
     604:	0004      	movs	r4, r0
     606:	9203      	str	r2, [sp, #12]
	//	if(data[i]!=tbuf[i])
	//		return -1;
	//}
	//erase reserve byte of page
	//M_PRINTF(L_APP, "flashaddr[%x] otaErasePage[%x] writeAddr[%x]", flashaddr, otaErasePage, writeAddr);
	if(writeAddr > flashaddr){//write back
     608:	4283      	cmp	r3, r0
     60a:	d91c      	bls.n	646 <OTA_WriteFlash+0x4e>
		otaErasePage = flashaddr&PAGE_MASK;
     60c:	0003      	movs	r3, r0
     60e:	26ff      	movs	r6, #255	; 0xff
     610:	43b3      	bics	r3, r6
		int tlen = flashaddr&(PAGE_SIZE-1);
     612:	4006      	ands	r6, r0
	//		return -1;
	//}
	//erase reserve byte of page
	//M_PRINTF(L_APP, "flashaddr[%x] otaErasePage[%x] writeAddr[%x]", flashaddr, otaErasePage, writeAddr);
	if(writeAddr > flashaddr){//write back
		otaErasePage = flashaddr&PAGE_MASK;
     614:	60ab      	str	r3, [r5, #8]
		int tlen = flashaddr&(PAGE_SIZE-1);
		QSPI_Init();
     616:	f000 ff3d 	bl	1494 <QSPI_Init>
		QSPI_ReadFlashData(otaErasePage, tlen,tbuf);
     61a:	aa05      	add	r2, sp, #20
     61c:	0031      	movs	r1, r6
     61e:	68a8      	ldr	r0, [r5, #8]
     620:	f000 fc3e 	bl	ea0 <QSPI_ReadFlashData>
		QSPI_PageEraseFlash(otaErasePage);
     624:	68a8      	ldr	r0, [r5, #8]
     626:	f000 febb 	bl	13a0 <QSPI_PageEraseFlash>
		QSPI_WriteFlashData(otaErasePage,tlen,tbuf);
     62a:	aa05      	add	r2, sp, #20
     62c:	0031      	movs	r1, r6
     62e:	68a8      	ldr	r0, [r5, #8]
     630:	f000 fd76 	bl	1120 <QSPI_WriteFlashData>
		m_printf(L_APP, "flashaddr[%x] otaErasePage[%x] tlen[%x]", flashaddr, otaErasePage, tlen);
     634:	2080      	movs	r0, #128	; 0x80
     636:	491f      	ldr	r1, [pc, #124]	; (6b4 <OTA_WriteFlash+0xbc>)
     638:	9600      	str	r6, [sp, #0]
     63a:	68ab      	ldr	r3, [r5, #8]
     63c:	0022      	movs	r2, r4
     63e:	311d      	adds	r1, #29
     640:	0180      	lsls	r0, r0, #6
     642:	f004 f9d5 	bl	49f0 <m_printf>
	}
	if(otaErasePage+PAGE_SIZE < flashaddr+len){//forward
     646:	4d19      	ldr	r5, [pc, #100]	; (6ac <OTA_WriteFlash+0xb4>)
     648:	19e6      	adds	r6, r4, r7
     64a:	68ab      	ldr	r3, [r5, #8]
     64c:	3301      	adds	r3, #1
     64e:	33ff      	adds	r3, #255	; 0xff
     650:	42b3      	cmp	r3, r6
     652:	d209      	bcs.n	668 <OTA_WriteFlash+0x70>
		//erase new page
		otaErasePage = (flashaddr+len)&PAGE_MASK;
     654:	23ff      	movs	r3, #255	; 0xff
     656:	0032      	movs	r2, r6
     658:	439a      	bics	r2, r3
     65a:	60aa      	str	r2, [r5, #8]
		QSPI_Init();
     65c:	f000 ff1a 	bl	1494 <QSPI_Init>
		QSPI_PageEraseFlash(otaErasePage);
     660:	68a8      	ldr	r0, [r5, #8]
     662:	f000 fe9d 	bl	13a0 <QSPI_PageEraseFlash>
     666:	e001      	b.n	66c <OTA_WriteFlash+0x74>
		//M_PRINTF(L_APP, "2");
	}else 
	//M_PRINTF(L_APP, "3");

	QSPI_Init();
     668:	f000 ff14 	bl	1494 <QSPI_Init>
	//write data
	QSPI_WriteFlashData(flashaddr,len,data);
     66c:	9a03      	ldr	r2, [sp, #12]
     66e:	0039      	movs	r1, r7
     670:	0020      	movs	r0, r4
     672:	f000 fd55 	bl	1120 <QSPI_WriteFlashData>
	//read and compare
	QSPI_ReadFlashData(flashaddr,len,tbuf);
     676:	aa05      	add	r2, sp, #20
     678:	0039      	movs	r1, r7
     67a:	0020      	movs	r0, r4
     67c:	f000 fc10 	bl	ea0 <QSPI_ReadFlashData>
	writeAddr = flashaddr+len;
	for(int i=0; i<len; i++){														//将需要修改数据copy到pagebuf中
     680:	2300      	movs	r3, #0
	QSPI_Init();
	//write data
	QSPI_WriteFlashData(flashaddr,len,data);
	//read and compare
	QSPI_ReadFlashData(flashaddr,len,tbuf);
	writeAddr = flashaddr+len;
     682:	60ee      	str	r6, [r5, #12]
	for(int i=0; i<len; i++){														//将需要修改数据copy到pagebuf中
     684:	42bb      	cmp	r3, r7
     686:	d009      	beq.n	69c <OTA_WriteFlash+0xa4>
		if(data[i] != tbuf[i])
     688:	200c      	movs	r0, #12
     68a:	9a03      	ldr	r2, [sp, #12]
     68c:	5cd1      	ldrb	r1, [r2, r3]
     68e:	aa02      	add	r2, sp, #8
     690:	1812      	adds	r2, r2, r0
     692:	5cd2      	ldrb	r2, [r2, r3]
     694:	4291      	cmp	r1, r2
     696:	d103      	bne.n	6a0 <OTA_WriteFlash+0xa8>
	//write data
	QSPI_WriteFlashData(flashaddr,len,data);
	//read and compare
	QSPI_ReadFlashData(flashaddr,len,tbuf);
	writeAddr = flashaddr+len;
	for(int i=0; i<len; i++){														//将需要修改数据copy到pagebuf中
     698:	3301      	adds	r3, #1
     69a:	e7f3      	b.n	684 <OTA_WriteFlash+0x8c>
		if(data[i] != tbuf[i])
			return 1;
	}
	
	return 0;
     69c:	2000      	movs	r0, #0
     69e:	e000      	b.n	6a2 <OTA_WriteFlash+0xaa>
	//read and compare
	QSPI_ReadFlashData(flashaddr,len,tbuf);
	writeAddr = flashaddr+len;
	for(int i=0; i<len; i++){														//将需要修改数据copy到pagebuf中
		if(data[i] != tbuf[i])
			return 1;
     6a0:	2001      	movs	r0, #1
	}
	
	return 0;
}
     6a2:	238d      	movs	r3, #141	; 0x8d
     6a4:	009b      	lsls	r3, r3, #2
     6a6:	449d      	add	sp, r3
     6a8:	bdf0      	pop	{r4, r5, r6, r7, pc}
     6aa:	46c0      	nop			; (mov r8, r8)
     6ac:	10010f60 	.word	0x10010f60
     6b0:	fffffdcc 	.word	0xfffffdcc
     6b4:	0001fd9c 	.word	0x0001fd9c

000006b8 <ota_cmd_to_app>:

void ota_cmd_to_app(uint8_t cType, uint16_t pTemp, uint8_t CheckResult)
{
     6b8:	b513      	push	{r0, r1, r4, lr}
	uint8_t cbuf[5];
	cbuf[0] = 0xab;
     6ba:	466c      	mov	r4, sp
     6bc:	23ab      	movs	r3, #171	; 0xab
	cbuf[1] = cType;
	cbuf[2] = pTemp & 0xff; 	//pTemp:00 01-->01 00
     6be:	70a1      	strb	r1, [r4, #2]
	cbuf[3] = (pTemp>>8) & 0xff;
     6c0:	0a09      	lsrs	r1, r1, #8
}

void ota_cmd_to_app(uint8_t cType, uint16_t pTemp, uint8_t CheckResult)
{
	uint8_t cbuf[5];
	cbuf[0] = 0xab;
     6c2:	7023      	strb	r3, [r4, #0]
	cbuf[1] = cType;
     6c4:	7060      	strb	r0, [r4, #1]
	cbuf[2] = pTemp & 0xff; 	//pTemp:00 01-->01 00
	cbuf[3] = (pTemp>>8) & 0xff;
     6c6:	70e1      	strb	r1, [r4, #3]
	switch(cType){
     6c8:	28c1      	cmp	r0, #193	; 0xc1
     6ca:	d009      	beq.n	6e0 <ota_cmd_to_app+0x28>
     6cc:	28c2      	cmp	r0, #194	; 0xc2
     6ce:	d00d      	beq.n	6ec <ota_cmd_to_app+0x34>
     6d0:	28c0      	cmp	r0, #192	; 0xc0
     6d2:	d111      	bne.n	6f8 <ota_cmd_to_app+0x40>
     6d4:	2204      	movs	r2, #4
     6d6:	4669      	mov	r1, sp
     6d8:	38a7      	subs	r0, #167	; 0xa7
     6da:	f000 f931 	bl	940 <Ble_SendDataSimple.part.0>
     6de:	e00b      	b.n	6f8 <ota_cmd_to_app+0x40>
     6e0:	2204      	movs	r2, #4
     6e2:	4669      	mov	r1, sp
     6e4:	2019      	movs	r0, #25
     6e6:	f000 f92b 	bl	940 <Ble_SendDataSimple.part.0>
     6ea:	e005      	b.n	6f8 <ota_cmd_to_app+0x40>
			break;
		case CMD_OTA_DATA:
			Ble_SendDataSimple(OTA_INDICATE_HANDLE,cbuf,4);
			break;
		case CMD_OTA_END:
			cbuf[4] = CheckResult;
     6ec:	7122      	strb	r2, [r4, #4]
     6ee:	4669      	mov	r1, sp
     6f0:	2205      	movs	r2, #5
     6f2:	2019      	movs	r0, #25
     6f4:	f000 f924 	bl	940 <Ble_SendDataSimple.part.0>
			Ble_SendDataSimple(OTA_INDICATE_HANDLE,cbuf,5);
			break;
	}
}
     6f8:	bd13      	pop	{r0, r1, r4, pc}

000006fa <gatt_ota_data_deal>:

void gatt_ota_data_deal(uint8_t* dat, uint8_t length)
{
     6fa:	b5f0      	push	{r4, r5, r6, r7, lr}
	static uint32_t packetSum=0;
	static uint16_t PacketLength = 0;
	static uint16_t CurPacketLen = 0;
	uint8_t* dataTmp = dat;
	//m_printf_hex(L_APP, "ota data recv", dat, length);
	if(dat[0] == 0xba && dat[1] == CMD_OTA_DATA 
     6fc:	7803      	ldrb	r3, [r0, #0]
			break;
	}
}

void gatt_ota_data_deal(uint8_t* dat, uint8_t length)
{
     6fe:	b085      	sub	sp, #20
     700:	0006      	movs	r6, r0
     702:	9101      	str	r1, [sp, #4]
	static uint32_t packetSum=0;
	static uint16_t PacketLength = 0;
	static uint16_t CurPacketLen = 0;
	uint8_t* dataTmp = dat;
	//m_printf_hex(L_APP, "ota data recv", dat, length);
	if(dat[0] == 0xba && dat[1] == CMD_OTA_DATA 
     704:	2bba      	cmp	r3, #186	; 0xba
     706:	d11d      	bne.n	744 <gatt_ota_data_deal+0x4a>
     708:	7847      	ldrb	r7, [r0, #1]
     70a:	4c7a      	ldr	r4, [pc, #488]	; (8f4 <gatt_ota_data_deal+0x1fa>)
     70c:	2fc1      	cmp	r7, #193	; 0xc1
     70e:	d10e      	bne.n	72e <gatt_ota_data_deal+0x34>
		&& dat[2] == (cur_packet_id&0xFF) 
     710:	4979      	ldr	r1, [pc, #484]	; (8f8 <gatt_ota_data_deal+0x1fe>)
     712:	7880      	ldrb	r0, [r0, #2]
     714:	880a      	ldrh	r2, [r1, #0]
     716:	b2d3      	uxtb	r3, r2
     718:	4298      	cmp	r0, r3
     71a:	d000      	beq.n	71e <gatt_ota_data_deal+0x24>
     71c:	e0ba      	b.n	894 <gatt_ota_data_deal+0x19a>
		&& dat[3] == (cur_packet_id >> 8&0xFF)){
     71e:	78f3      	ldrb	r3, [r6, #3]
     720:	0a12      	lsrs	r2, r2, #8
     722:	4293      	cmp	r3, r2
     724:	d000      	beq.n	728 <gatt_ota_data_deal+0x2e>
     726:	e0b5      	b.n	894 <gatt_ota_data_deal+0x19a>
		data_retransmit_flag = 1;		
     728:	2301      	movs	r3, #1
     72a:	80a3      	strh	r3, [r4, #4]
     72c:	e0b2      	b.n	894 <gatt_ota_data_deal+0x19a>
	}
	
	if(*dat++ == 0xba){
		switch(*(dat++)){
     72e:	2fc2      	cmp	r7, #194	; 0xc2
     730:	d03b      	beq.n	7aa <gatt_ota_data_deal+0xb0>
     732:	2fff      	cmp	r7, #255	; 0xff
     734:	d100      	bne.n	738 <gatt_ota_data_deal+0x3e>
     736:	e087      	b.n	848 <gatt_ota_data_deal+0x14e>
     738:	2fc0      	cmp	r7, #192	; 0xc0
     73a:	d103      	bne.n	744 <gatt_ota_data_deal+0x4a>
			case CMD_OTA_START://oxba,oxc0
				if(StartOtaFlag == NOSTART){	//收到start的包后，确定OTA地址和置标志位。				
     73c:	7823      	ldrb	r3, [r4, #0]
     73e:	2b01      	cmp	r3, #1
     740:	d100      	bne.n	744 <gatt_ota_data_deal+0x4a>
     742:	e089      	b.n	858 <gatt_ota_data_deal+0x15e>
			default:
				break;
		
		}
	}
	if(data_start_flag == 1 && StartOtaFlag == OTAPROCESSING){
     744:	4c6b      	ldr	r4, [pc, #428]	; (8f4 <gatt_ota_data_deal+0x1fa>)
     746:	8863      	ldrh	r3, [r4, #2]
     748:	2b01      	cmp	r3, #1
     74a:	d000      	beq.n	74e <gatt_ota_data_deal+0x54>
     74c:	e0cf      	b.n	8ee <gatt_ota_data_deal+0x1f4>
     74e:	7823      	ldrb	r3, [r4, #0]
     750:	2b03      	cmp	r3, #3
     752:	d000      	beq.n	756 <gatt_ota_data_deal+0x5c>
     754:	e0cb      	b.n	8ee <gatt_ota_data_deal+0x1f4>
     756:	0033      	movs	r3, r6
     758:	2100      	movs	r1, #0
     75a:	69e2      	ldr	r2, [r4, #28]
		//calc check sum
		for(int i = 0; i < length;  i++){	
     75c:	9d01      	ldr	r5, [sp, #4]
     75e:	1b98      	subs	r0, r3, r6
     760:	4285      	cmp	r5, r0
     762:	dd04      	ble.n	76e <gatt_ota_data_deal+0x74>
			packetSum += dataTmp[i];
     764:	7819      	ldrb	r1, [r3, #0]
     766:	3301      	adds	r3, #1
     768:	1852      	adds	r2, r2, r1
     76a:	2101      	movs	r1, #1
     76c:	e7f6      	b.n	75c <gatt_ota_data_deal+0x62>
     76e:	2900      	cmp	r1, #0
     770:	d000      	beq.n	774 <gatt_ota_data_deal+0x7a>
     772:	61e2      	str	r2, [r4, #28]
		}
		//write flash data
		uint8_t writeStatus = 0;
		writeStatus = OTA_WriteFlash(cflashaddr,(uint32_t)length, dataTmp);
     774:	0032      	movs	r2, r6
     776:	9901      	ldr	r1, [sp, #4]
     778:	6960      	ldr	r0, [r4, #20]
     77a:	f7ff ff3d 	bl	5f8 <OTA_WriteFlash>
		//m_printf_hex(L_APP, "ota data crc", dataTmp, length);
		//M_PRINTF(L_APP, "writeStatus[%x]", writeStatus);
		cflashaddr += length;
     77e:	6963      	ldr	r3, [r4, #20]
     780:	9901      	ldr	r1, [sp, #4]
		for(int i = 0; i < length;  i++){	
			packetSum += dataTmp[i];
		}
		//write flash data
		uint8_t writeStatus = 0;
		writeStatus = OTA_WriteFlash(cflashaddr,(uint32_t)length, dataTmp);
     782:	0002      	movs	r2, r0
		//m_printf_hex(L_APP, "ota data crc", dataTmp, length);
		//M_PRINTF(L_APP, "writeStatus[%x]", writeStatus);
		cflashaddr += length;
     784:	185b      	adds	r3, r3, r1
     786:	6163      	str	r3, [r4, #20]
		CurPacketLen += length;
     788:	8d23      	ldrh	r3, [r4, #40]	; 0x28
     78a:	185b      	adds	r3, r3, r1
     78c:	b29b      	uxth	r3, r3
     78e:	8523      	strh	r3, [r4, #40]	; 0x28
		if(writeStatus == 0){
     790:	2800      	cmp	r0, #0
     792:	d000      	beq.n	796 <gatt_ota_data_deal+0x9c>
     794:	e0ab      	b.n	8ee <gatt_ota_data_deal+0x1f4>
			if(CurPacketLen == PacketLength){
     796:	8c61      	ldrh	r1, [r4, #34]	; 0x22
     798:	4299      	cmp	r1, r3
     79a:	d000      	beq.n	79e <gatt_ota_data_deal+0xa4>
     79c:	e0a7      	b.n	8ee <gatt_ota_data_deal+0x1f4>
				data_start_flag = 0;
     79e:	8060      	strh	r0, [r4, #2]
				ota_cmd_to_app(CMD_OTA_DATA,PacketId,0);//CMD_OTA_DATA_H
     7a0:	8c21      	ldrh	r1, [r4, #32]
     7a2:	20c1      	movs	r0, #193	; 0xc1
     7a4:	f7ff ff88 	bl	6b8 <ota_cmd_to_app>
     7a8:	e0a1      	b.n	8ee <gatt_ota_data_deal+0x1f4>
				dataTmp = dat;
				length = length - 6;
				packetSum = 0;
				break;
			case CMD_OTA_END:
				cSum += packetSum;
     7aa:	69a3      	ldr	r3, [r4, #24]
     7ac:	69e2      	ldr	r2, [r4, #28]
     7ae:	189b      	adds	r3, r3, r2
				if(StartOtaFlag != OTAPROCESSING)
     7b0:	7822      	ldrb	r2, [r4, #0]
				dataTmp = dat;
				length = length - 6;
				packetSum = 0;
				break;
			case CMD_OTA_END:
				cSum += packetSum;
     7b2:	61a3      	str	r3, [r4, #24]
				if(StartOtaFlag != OTAPROCESSING)
     7b4:	2a03      	cmp	r2, #3
     7b6:	d000      	beq.n	7ba <gatt_ota_data_deal+0xc0>
     7b8:	e099      	b.n	8ee <gatt_ota_data_deal+0x1f4>
				CheckSum = *(dat++);
				CheckSum |= *(dat++)<<8;
				CheckSum |= *(dat++)<<16;
				mCheckSum = cflashaddr - OTAStartAddr;
				
				m_printf(L_APP, "CheckSum[%x] cSum[%x]", CheckSum, cSum);
     7ba:	2080      	movs	r0, #128	; 0x80
				if(StartOtaFlag != OTAPROCESSING)
					return;
				uint32_t mCheckSum;
				uint32_t CheckSum;
				PacketId = *(dat++);
				PacketId |= *(dat++)<<8;
     7bc:	78f2      	ldrb	r2, [r6, #3]
     7be:	78b1      	ldrb	r1, [r6, #2]
     7c0:	0212      	lsls	r2, r2, #8
     7c2:	430a      	orrs	r2, r1
     7c4:	8422      	strh	r2, [r4, #32]
				CheckSum = *(dat++);
				CheckSum |= *(dat++)<<8;
				CheckSum |= *(dat++)<<16;
     7c6:	7975      	ldrb	r5, [r6, #5]
     7c8:	79b2      	ldrb	r2, [r6, #6]
     7ca:	022d      	lsls	r5, r5, #8
     7cc:	0412      	lsls	r2, r2, #16
					return;
				uint32_t mCheckSum;
				uint32_t CheckSum;
				PacketId = *(dat++);
				PacketId |= *(dat++)<<8;
				CheckSum = *(dat++);
     7ce:	7931      	ldrb	r1, [r6, #4]
				CheckSum |= *(dat++)<<8;
				CheckSum |= *(dat++)<<16;
     7d0:	4315      	orrs	r5, r2
				mCheckSum = cflashaddr - OTAStartAddr;
     7d2:	6962      	ldr	r2, [r4, #20]
				uint32_t CheckSum;
				PacketId = *(dat++);
				PacketId |= *(dat++)<<8;
				CheckSum = *(dat++);
				CheckSum |= *(dat++)<<8;
				CheckSum |= *(dat++)<<16;
     7d4:	430d      	orrs	r5, r1
				mCheckSum = cflashaddr - OTAStartAddr;
     7d6:	9202      	str	r2, [sp, #8]
				
				m_printf(L_APP, "CheckSum[%x] cSum[%x]", CheckSum, cSum);
     7d8:	4948      	ldr	r1, [pc, #288]	; (8fc <gatt_ota_data_deal+0x202>)
				PacketId = *(dat++);
				PacketId |= *(dat++)<<8;
				CheckSum = *(dat++);
				CheckSum |= *(dat++)<<8;
				CheckSum |= *(dat++)<<16;
				mCheckSum = cflashaddr - OTAStartAddr;
     7da:	6922      	ldr	r2, [r4, #16]
				
				m_printf(L_APP, "CheckSum[%x] cSum[%x]", CheckSum, cSum);
     7dc:	3145      	adds	r1, #69	; 0x45
				PacketId = *(dat++);
				PacketId |= *(dat++)<<8;
				CheckSum = *(dat++);
				CheckSum |= *(dat++)<<8;
				CheckSum |= *(dat++)<<16;
				mCheckSum = cflashaddr - OTAStartAddr;
     7de:	9203      	str	r2, [sp, #12]
				
				m_printf(L_APP, "CheckSum[%x] cSum[%x]", CheckSum, cSum);
     7e0:	0180      	lsls	r0, r0, #6
     7e2:	002a      	movs	r2, r5
     7e4:	f004 f904 	bl	49f0 <m_printf>
				if(CheckSum == cSum){
     7e8:	69a3      	ldr	r3, [r4, #24]
     7ea:	429d      	cmp	r5, r3
     7ec:	d124      	bne.n	838 <gatt_ota_data_deal+0x13e>
					int8_t status = ota_code_crc(mCheckSum);
     7ee:	9b02      	ldr	r3, [sp, #8]
     7f0:	9a03      	ldr	r2, [sp, #12]
     7f2:	1a98      	subs	r0, r3, r2
     7f4:	f7ff fe26 	bl	444 <ota_code_crc>
					m_printf(L_APP, "code crc status[%d]", status);
     7f8:	0002      	movs	r2, r0
				CheckSum |= *(dat++)<<16;
				mCheckSum = cflashaddr - OTAStartAddr;
				
				m_printf(L_APP, "CheckSum[%x] cSum[%x]", CheckSum, cSum);
				if(CheckSum == cSum){
					int8_t status = ota_code_crc(mCheckSum);
     7fa:	0005      	movs	r5, r0
					m_printf(L_APP, "code crc status[%d]", status);
     7fc:	2080      	movs	r0, #128	; 0x80
     7fe:	493f      	ldr	r1, [pc, #252]	; (8fc <gatt_ota_data_deal+0x202>)
     800:	0180      	lsls	r0, r0, #6
     802:	315b      	adds	r1, #91	; 0x5b
     804:	f004 f8f4 	bl	49f0 <m_printf>
     808:	8c21      	ldrh	r1, [r4, #32]
					if(!status){
     80a:	2d00      	cmp	r5, #0
     80c:	d10d      	bne.n	82a <gatt_ota_data_deal+0x130>
						ota_cmd_to_app(CMD_OTA_END,PacketId,0x55);
     80e:	2255      	movs	r2, #85	; 0x55
     810:	0038      	movs	r0, r7
     812:	f7ff ff51 	bl	6b8 <ota_cmd_to_app>
						uint32_t count = 100000;
						while(count--)
     816:	4c3a      	ldr	r4, [pc, #232]	; (900 <gatt_ota_data_deal+0x206>)
     818:	3c01      	subs	r4, #1
     81a:	2c00      	cmp	r4, #0
     81c:	d002      	beq.n	824 <gatt_ota_data_deal+0x12a>
							IPC_DealSingleStep();
     81e:	f000 f9fd 	bl	c1c <IPC_DealSingleStep>
     822:	e7f9      	b.n	818 <gatt_ota_data_deal+0x11e>
						ota_prog_switch();
     824:	f7ff fdec 	bl	400 <ota_prog_switch>
     828:	e78c      	b.n	744 <gatt_ota_data_deal+0x4a>
					}
					else{
						StartOtaFlag = NOSTART;
     82a:	2301      	movs	r3, #1
						ota_cmd_to_app(CMD_OTA_END,PacketId,0);
     82c:	2200      	movs	r2, #0
     82e:	0038      	movs	r0, r7
						while(count--)
							IPC_DealSingleStep();
						ota_prog_switch();
					}
					else{
						StartOtaFlag = NOSTART;
     830:	7023      	strb	r3, [r4, #0]
						ota_cmd_to_app(CMD_OTA_END,PacketId,0);
     832:	f7ff ff41 	bl	6b8 <ota_cmd_to_app>
     836:	e785      	b.n	744 <gatt_ota_data_deal+0x4a>
					}	
				}else{
					StartOtaFlag = NOSTART;
     838:	2301      	movs	r3, #1
					ota_cmd_to_app(CMD_OTA_END,PacketId,0);
     83a:	8c21      	ldrh	r1, [r4, #32]
     83c:	2200      	movs	r2, #0
     83e:	0038      	movs	r0, r7
					else{
						StartOtaFlag = NOSTART;
						ota_cmd_to_app(CMD_OTA_END,PacketId,0);
					}	
				}else{
					StartOtaFlag = NOSTART;
     840:	7023      	strb	r3, [r4, #0]
					ota_cmd_to_app(CMD_OTA_END,PacketId,0);
     842:	f7ff ff39 	bl	6b8 <ota_cmd_to_app>
     846:	e77d      	b.n	744 <gatt_ota_data_deal+0x4a>
				}
		
				break;
			case CMD_OTA_RESET:
				if(StartOtaFlag != OTAPROCESSING)
     848:	7823      	ldrb	r3, [r4, #0]
     84a:	2b03      	cmp	r3, #3
     84c:	d14f      	bne.n	8ee <gatt_ota_data_deal+0x1f4>
					return;
				ota_prog_switch();
     84e:	f7ff fdd7 	bl	400 <ota_prog_switch>
				StartOtaFlag = NOSTART;
     852:	2301      	movs	r3, #1
     854:	7023      	strb	r3, [r4, #0]
				break; 
     856:	e775      	b.n	744 <gatt_ota_data_deal+0x4a>
	
	if(*dat++ == 0xba){
		switch(*(dat++)){
			case CMD_OTA_START://oxba,oxc0
				if(StartOtaFlag == NOSTART){	//收到start的包后，确定OTA地址和置标志位。				
					StartOtaFlag = OTASTART;
     858:	3301      	adds	r3, #1
     85a:	7023      	strb	r3, [r4, #0]
					
					uint8_t sts = ota_prog_addr();
     85c:	f7ff fd72 	bl	344 <ota_prog_addr>
					if(sts == APP_TWO){ //check out addr 0x1000 code
     860:	2802      	cmp	r0, #2
     862:	d103      	bne.n	86c <gatt_ota_data_deal+0x172>
						OTAStartAddr = CODE_START_ADDR+PAGE_SIZE;//0x2000;
     864:	2380      	movs	r3, #128	; 0x80
     866:	005b      	lsls	r3, r3, #1
     868:	6123      	str	r3, [r4, #16]
     86a:	e001      	b.n	870 <gatt_ota_data_deal+0x176>
					}
					else{
						OTAStartAddr = CODE_UPGRADE_START_ADDR+PAGE_SIZE;//0x40000;
     86c:	4b25      	ldr	r3, [pc, #148]	; (904 <gatt_ota_data_deal+0x20a>)
     86e:	6123      	str	r3, [r4, #16]
					}
					cflashaddr = OTAStartAddr;
					cSum = 0;
     870:	2500      	movs	r5, #0
						OTAStartAddr = CODE_START_ADDR+PAGE_SIZE;//0x2000;
					}
					else{
						OTAStartAddr = CODE_UPGRADE_START_ADDR+PAGE_SIZE;//0x40000;
					}
					cflashaddr = OTAStartAddr;
     872:	6923      	ldr	r3, [r4, #16]
					cSum = 0;
					packetSum = 0;
					//M_PRINTF(L_APP, "cflashaddr[%x]", cflashaddr);
					IPC_TxControlCmd(IPC_CMD_UPDATA_CONN);
     874:	2012      	movs	r0, #18
						OTAStartAddr = CODE_START_ADDR+PAGE_SIZE;//0x2000;
					}
					else{
						OTAStartAddr = CODE_UPGRADE_START_ADDR+PAGE_SIZE;//0x40000;
					}
					cflashaddr = OTAStartAddr;
     876:	6163      	str	r3, [r4, #20]
					cSum = 0;
     878:	61a5      	str	r5, [r4, #24]
					packetSum = 0;
     87a:	61e5      	str	r5, [r4, #28]
					//M_PRINTF(L_APP, "cflashaddr[%x]", cflashaddr);
					IPC_TxControlCmd(IPC_CMD_UPDATA_CONN);
     87c:	f000 f957 	bl	b2e <IPC_TxControlCmd>
					ota_cmd_to_app(CMD_OTA_START,PACKETNUM,0);//CMD_OTA_START_H
     880:	2187      	movs	r1, #135	; 0x87
     882:	002a      	movs	r2, r5
     884:	0089      	lsls	r1, r1, #2
     886:	20c0      	movs	r0, #192	; 0xc0
     888:	f7ff ff16 	bl	6b8 <ota_cmd_to_app>
					OTA_flash_init(OTAStartAddr);
     88c:	6920      	ldr	r0, [r4, #16]
     88e:	f7ff fea3 	bl	5d8 <OTA_flash_init>
     892:	e757      	b.n	744 <gatt_ota_data_deal+0x4a>
				} 
				break;
			case CMD_OTA_DATA:
				if(StartOtaFlag == OTASTART){
     894:	7823      	ldrb	r3, [r4, #0]
     896:	2b02      	cmp	r3, #2
     898:	d101      	bne.n	89e <gatt_ota_data_deal+0x1a4>
					StartOtaFlag = OTAPROCESSING;
     89a:	2303      	movs	r3, #3
     89c:	7023      	strb	r3, [r4, #0]
				}
				if(StartOtaFlag != OTAPROCESSING)
     89e:	7823      	ldrb	r3, [r4, #0]
     8a0:	2b03      	cmp	r3, #3
     8a2:	d124      	bne.n	8ee <gatt_ota_data_deal+0x1f4>
					return;
				PacketId = *(dat++);
				PacketId |= *(dat++)<<8;
				PacketLength = *(dat++);
				PacketLength |= *(dat++)<<8;
     8a4:	7972      	ldrb	r2, [r6, #5]
     8a6:	7935      	ldrb	r5, [r6, #4]
					StartOtaFlag = OTAPROCESSING;
				}
				if(StartOtaFlag != OTAPROCESSING)
					return;
				PacketId = *(dat++);
				PacketId |= *(dat++)<<8;
     8a8:	78f3      	ldrb	r3, [r6, #3]
				PacketLength = *(dat++);
				PacketLength |= *(dat++)<<8;
     8aa:	0212      	lsls	r2, r2, #8
     8ac:	432a      	orrs	r2, r5
					StartOtaFlag = OTAPROCESSING;
				}
				if(StartOtaFlag != OTAPROCESSING)
					return;
				PacketId = *(dat++);
				PacketId |= *(dat++)<<8;
     8ae:	021b      	lsls	r3, r3, #8
				PacketLength = *(dat++);
				PacketLength |= *(dat++)<<8;
     8b0:	8462      	strh	r2, [r4, #34]	; 0x22

				if(data_retransmit_flag == 1){
     8b2:	88a2      	ldrh	r2, [r4, #4]
					StartOtaFlag = OTAPROCESSING;
				}
				if(StartOtaFlag != OTAPROCESSING)
					return;
				PacketId = *(dat++);
				PacketId |= *(dat++)<<8;
     8b4:	4303      	orrs	r3, r0
     8b6:	8423      	strh	r3, [r4, #32]
				PacketLength = *(dat++);
				PacketLength |= *(dat++)<<8;
     8b8:	1db0      	adds	r0, r6, #6

				if(data_retransmit_flag == 1){
     8ba:	2a01      	cmp	r2, #1
     8bc:	d105      	bne.n	8ca <gatt_ota_data_deal+0x1d0>
					data_retransmit_flag = 0;
     8be:	2200      	movs	r2, #0
					cflashaddr = flashaddrsaved;
     8c0:	6a65      	ldr	r5, [r4, #36]	; 0x24
				PacketId |= *(dat++)<<8;
				PacketLength = *(dat++);
				PacketLength |= *(dat++)<<8;

				if(data_retransmit_flag == 1){
					data_retransmit_flag = 0;
     8c2:	80a2      	strh	r2, [r4, #4]
					cflashaddr = flashaddrsaved;
     8c4:	6165      	str	r5, [r4, #20]
					packetSum = 0;
     8c6:	61e2      	str	r2, [r4, #28]
     8c8:	e001      	b.n	8ce <gatt_ota_data_deal+0x1d4>
				}
				else{
					flashaddrsaved = cflashaddr;
     8ca:	6962      	ldr	r2, [r4, #20]
     8cc:	6262      	str	r2, [r4, #36]	; 0x24
					
				}
				cSum += packetSum;
     8ce:	69a2      	ldr	r2, [r4, #24]
     8d0:	69e5      	ldr	r5, [r4, #28]
				//M_PRINTF(L_APP, "PacketId[%x] PacketLength[%x] cflashaddr[%x]", PacketId, PacketLength, cflashaddr);
				cur_packet_id = PacketId; 
     8d2:	800b      	strh	r3, [r1, #0]
				}
				else{
					flashaddrsaved = cflashaddr;
					
				}
				cSum += packetSum;
     8d4:	1952      	adds	r2, r2, r5
     8d6:	61a2      	str	r2, [r4, #24]
				//M_PRINTF(L_APP, "PacketId[%x] PacketLength[%x] cflashaddr[%x]", PacketId, PacketLength, cflashaddr);
				cur_packet_id = PacketId; 
				CurPacketLen = 0;
				data_start_flag = 1;
     8d8:	2201      	movs	r2, #1
					
				}
				cSum += packetSum;
				//M_PRINTF(L_APP, "PacketId[%x] PacketLength[%x] cflashaddr[%x]", PacketId, PacketLength, cflashaddr);
				cur_packet_id = PacketId; 
				CurPacketLen = 0;
     8da:	2300      	movs	r3, #0
				data_start_flag = 1;
     8dc:	8062      	strh	r2, [r4, #2]
				dataTmp = dat;
				length = length - 6;
     8de:	9a01      	ldr	r2, [sp, #4]
					
				}
				cSum += packetSum;
				//M_PRINTF(L_APP, "PacketId[%x] PacketLength[%x] cflashaddr[%x]", PacketId, PacketLength, cflashaddr);
				cur_packet_id = PacketId; 
				CurPacketLen = 0;
     8e0:	8523      	strh	r3, [r4, #40]	; 0x28
				data_start_flag = 1;
				dataTmp = dat;
				length = length - 6;
     8e2:	3a06      	subs	r2, #6
     8e4:	b2d2      	uxtb	r2, r2
     8e6:	9201      	str	r2, [sp, #4]
				packetSum = 0;
     8e8:	61e3      	str	r3, [r4, #28]
				cSum += packetSum;
				//M_PRINTF(L_APP, "PacketId[%x] PacketLength[%x] cflashaddr[%x]", PacketId, PacketLength, cflashaddr);
				cur_packet_id = PacketId; 
				CurPacketLen = 0;
				data_start_flag = 1;
				dataTmp = dat;
     8ea:	0006      	movs	r6, r0
				length = length - 6;
				packetSum = 0;
				break;
     8ec:	e72a      	b.n	744 <gatt_ota_data_deal+0x4a>
		}
		
		//M_PRINTF(L_APP, "writeStatus[%d] CurPacketLen[%x] PacketLength[%x]", writeStatus, CurPacketLen, PacketLength);
		return;
	}
}
     8ee:	b005      	add	sp, #20
     8f0:	bdf0      	pop	{r4, r5, r6, r7, pc}
     8f2:	46c0      	nop			; (mov r8, r8)
     8f4:	10010f60 	.word	0x10010f60
     8f8:	10010500 	.word	0x10010500
     8fc:	0001fd9c 	.word	0x0001fd9c
     900:	000186a1 	.word	0x000186a1
     904:	0003e100 	.word	0x0003e100

00000908 <gatt_ota_init>:
//	/*send adv data*/
//	//BLE_SendAdvData(ADV_TYPE_NOMAL, 1600, 4, sizeof(data), data);
//}

void gatt_ota_init(void)
{
     908:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	//set adv resp data
	uint8_t _data[] = {0x07, 0x09, 0x5a, 0x58, 0x2d, 0x4f, 0x54, 0x41, 0x0c+6, 0xff, 'B', 'C', '6', '2', '1', '8'};
     90a:	2410      	movs	r4, #16
     90c:	4906      	ldr	r1, [pc, #24]	; (928 <gatt_ota_init+0x20>)
     90e:	0022      	movs	r2, r4
     910:	316f      	adds	r1, #111	; 0x6f
     912:	4668      	mov	r0, sp
     914:	f015 f85c 	bl	159d0 <memcpy>
	memcpy((unsigned char*)reg_map(mem_le_scan_data),_data,sizeof(_data));
     918:	0022      	movs	r2, r4
     91a:	4669      	mov	r1, sp
     91c:	4803      	ldr	r0, [pc, #12]	; (92c <gatt_ota_init+0x24>)
     91e:	f015 f857 	bl	159d0 <memcpy>
	HWRITE(mem_le_scan_data_len,sizeof(_data));
     922:	4b03      	ldr	r3, [pc, #12]	; (930 <gatt_ota_init+0x28>)
     924:	701c      	strb	r4, [r3, #0]
	//start timer for clear
//	SYS_SetTimer(&stGattOtaAdvTimer, GATT_OTA_PERIOD_NUM, 
//					TIMER_CYCLE, (Timer_Expire_CB)_gatt_ota_adv_period_set);
}
     926:	bd1f      	pop	{r0, r1, r2, r3, r4, pc}
     928:	0001fd9c 	.word	0x0001fd9c
     92c:	100043d3 	.word	0x100043d3
     930:	100043d2 	.word	0x100043d2

00000934 <gatt_ota_deinit>:
void gatt_ota_deinit(void)
{
//	SYS_ReleaseTimer(&stGattOtaAdvTimer);
	HWRITE(mem_le_scan_data_len,0);
     934:	2200      	movs	r2, #0
     936:	4b01      	ldr	r3, [pc, #4]	; (93c <gatt_ota_deinit+0x8>)
     938:	701a      	strb	r2, [r3, #0]
}
     93a:	4770      	bx	lr
     93c:	100043d2 	.word	0x100043d2

00000940 <Ble_SendDataSimple.part.0>:

	return 0;
}


void Ble_SendDataSimple(uint16_t handle, uint8_t* data, uint16_t len)//eg handle = 0x0008
     940:	b570      	push	{r4, r5, r6, lr}
     942:	b088      	sub	sp, #32
     944:	0014      	movs	r4, r2
     946:	0006      	movs	r6, r0
{	
	int cnt;
	if(len<0 || len>20)
		return;
	uint8_t BleSendData[30]={0};
     948:	221e      	movs	r2, #30

	return 0;
}


void Ble_SendDataSimple(uint16_t handle, uint8_t* data, uint16_t len)//eg handle = 0x0008
     94a:	000d      	movs	r5, r1
{	
	int cnt;
	if(len<0 || len>20)
		return;
	uint8_t BleSendData[30]={0};
     94c:	4668      	mov	r0, sp
     94e:	2100      	movs	r1, #0
     950:	f015 f87c 	bl	15a4c <memset>
	IPC_DATA_FORMAT* temp = (IPC_DATA_FORMAT*)BleSendData;
	temp->ipctype =IPC_BLE_DATA;
     954:	466a      	mov	r2, sp
     956:	2305      	movs	r3, #5
     958:	7013      	strb	r3, [r2, #0]
	temp->len = len+2;
     95a:	1ca3      	adds	r3, r4, #2
     95c:	7053      	strb	r3, [r2, #1]
	temp->ipcUnion.uBleData.mhandle = handle;
	unsigned char *dataAy = (unsigned char *)&temp->ipcUnion.uBleData.data;

	//	memcpy(dataAy,data,len);
	for(cnt=0; cnt<len+2; cnt++)
     95e:	2300      	movs	r3, #0
		return;
	uint8_t BleSendData[30]={0};
	IPC_DATA_FORMAT* temp = (IPC_DATA_FORMAT*)BleSendData;
	temp->ipctype =IPC_BLE_DATA;
	temp->len = len+2;
	temp->ipcUnion.uBleData.mhandle = handle;
     960:	8056      	strh	r6, [r2, #2]
	unsigned char *dataAy = (unsigned char *)&temp->ipcUnion.uBleData.data;

	//	memcpy(dataAy,data,len);
	for(cnt=0; cnt<len+2; cnt++)
     962:	3401      	adds	r4, #1
     964:	42a3      	cmp	r3, r4
     966:	dc05      	bgt.n	974 <Ble_SendDataSimple.part.0+0x34>
		*(dataAy+cnt) = *(data+cnt);
     968:	001a      	movs	r2, r3
     96a:	5ce9      	ldrb	r1, [r5, r3]
     96c:	446a      	add	r2, sp
     96e:	7111      	strb	r1, [r2, #4]
	temp->len = len+2;
	temp->ipcUnion.uBleData.mhandle = handle;
	unsigned char *dataAy = (unsigned char *)&temp->ipcUnion.uBleData.data;

	//	memcpy(dataAy,data,len);
	for(cnt=0; cnt<len+2; cnt++)
     970:	3301      	adds	r3, #1
     972:	e7f7      	b.n	964 <Ble_SendDataSimple.part.0+0x24>
		*(dataAy+cnt) = *(data+cnt);
		
	IPC_TxPacket(temp);
     974:	4668      	mov	r0, sp
     976:	f000 f8d1 	bl	b1c <IPC_TxPacket>
}
     97a:	b008      	add	sp, #32
     97c:	bd70      	pop	{r4, r5, r6, pc}
     97e:	46c0      	nop			; (mov r8, r8)

00000980 <hw_delay>:

#define BW(addr)			(int)*(addr) << 24 | (int)*(addr + 1) << 16 | (int)*(addr + 2) << 8 | *(addr + 3)

static inline void hw_delay() 
{
	__asm__ __volatile__("nop");
     980:	46c0      	nop			; (mov r8, r8)
	__asm__ __volatile__("nop");
     982:	46c0      	nop			; (mov r8, r8)
	__asm__ __volatile__("nop");
     984:	46c0      	nop			; (mov r8, r8)
	__asm__ __volatile__("nop");
     986:	46c0      	nop			; (mov r8, r8)
	__asm__ __volatile__("nop");
     988:	46c0      	nop			; (mov r8, r8)
}
     98a:	4770      	bx	lr

0000098c <HR_REG_24BIT>:
	return_data = (return_data | ((H_data << 8) & 0xFF00));
	return return_data;
}

static inline uint32_t HR_REG_24BIT(uint32_t reg)
{
     98c:	b570      	push	{r4, r5, r6, lr}
     98e:	0006      	movs	r6, r0
	uint32_t return_data = 0;
	hw_delay();
     990:	f7ff fff6 	bl	980 <hw_delay>
	return_data = HR_REG_8BIT(reg);
     994:	7834      	ldrb	r4, [r6, #0]
	hw_delay();
     996:	f7ff fff3 	bl	980 <hw_delay>
	return_data = return_data |(HR_REG_8BIT(reg + 1)<<8);
     99a:	7875      	ldrb	r5, [r6, #1]
	hw_delay();
     99c:	f7ff fff0 	bl	980 <hw_delay>
	return_data = return_data | (HR_REG_8BIT(reg + 2)<<16);
     9a0:	78b3      	ldrb	r3, [r6, #2]
{
	uint32_t return_data = 0;
	hw_delay();
	return_data = HR_REG_8BIT(reg);
	hw_delay();
	return_data = return_data |(HR_REG_8BIT(reg + 1)<<8);
     9a2:	b2ed      	uxtb	r5, r5
	hw_delay();
	return_data = return_data | (HR_REG_8BIT(reg + 2)<<16);
	
	return return_data;
     9a4:	0228      	lsls	r0, r5, #8
     9a6:	041b      	lsls	r3, r3, #16

static inline uint32_t HR_REG_24BIT(uint32_t reg)
{
	uint32_t return_data = 0;
	hw_delay();
	return_data = HR_REG_8BIT(reg);
     9a8:	b2e4      	uxtb	r4, r4
	hw_delay();
	return_data = return_data |(HR_REG_8BIT(reg + 1)<<8);
	hw_delay();
	return_data = return_data | (HR_REG_8BIT(reg + 2)<<16);
	
	return return_data;
     9aa:	4318      	orrs	r0, r3
     9ac:	4320      	orrs	r0, r4
}
     9ae:	bd70      	pop	{r4, r5, r6, pc}

000009b0 <IpcDefaultCallBack>:
uint8_t gIPC_test;


void IpcDefaultCallBack(uint8_t len,uint8_t *dataPtr)
{
	gIPC_test++;
     9b0:	4a02      	ldr	r2, [pc, #8]	; (9bc <IpcDefaultCallBack+0xc>)
     9b2:	7813      	ldrb	r3, [r2, #0]
     9b4:	3301      	adds	r3, #1
     9b6:	7013      	strb	r3, [r2, #0]
	return;
}
     9b8:	4770      	bx	lr
     9ba:	46c0      	nop			; (mov r8, r8)
     9bc:	100127f8 	.word	0x100127f8

000009c0 <IPC_Initialize>:

void IPC_Initialize(tIPCControlBlock *Cb)
{
	ipcCb = *Cb;
     9c0:	4a05      	ldr	r2, [pc, #20]	; (9d8 <IPC_Initialize+0x18>)
	gIPC_test++;
	return;
}

void IPC_Initialize(tIPCControlBlock *Cb)
{
     9c2:	b510      	push	{r4, lr}
	ipcCb = *Cb;
     9c4:	0013      	movs	r3, r2
     9c6:	c816      	ldmia	r0!, {r1, r2, r4}
     9c8:	c316      	stmia	r3!, {r1, r2, r4}
     9ca:	c816      	ldmia	r0!, {r1, r2, r4}
     9cc:	c316      	stmia	r3!, {r1, r2, r4}
     9ce:	c816      	ldmia	r0!, {r1, r2, r4}
     9d0:	c316      	stmia	r3!, {r1, r2, r4}
     9d2:	6802      	ldr	r2, [r0, #0]
     9d4:	601a      	str	r2, [r3, #0]
}
     9d6:	bd10      	pop	{r4, pc}
     9d8:	10010f8c 	.word	0x10010f8c

000009dc <IPC_init>:

void IPC_init(tIPCHandleCbArray cbArrayPtr)
{
	ipcCbArray = cbArrayPtr;
     9dc:	4b01      	ldr	r3, [pc, #4]	; (9e4 <IPC_init+0x8>)
     9de:	6298      	str	r0, [r3, #40]	; 0x28
	return;
}
     9e0:	4770      	bx	lr
     9e2:	46c0      	nop			; (mov r8, r8)
     9e4:	10010f8c 	.word	0x10010f8c

000009e8 <ipcRx>:

static void ipcRx(uint8_t* Dest, uint16_t Len)
{
     9e8:	b570      	push	{r4, r5, r6, lr}
     9ea:	0005      	movs	r5, r0
	uint32_t RxPtr = HR_REG_24BIT(reg_map(IPC_RX_READ_PTR));
     9ec:	4810      	ldr	r0, [pc, #64]	; (a30 <ipcRx+0x48>)
	ipcCbArray = cbArrayPtr;
	return;
}

static void ipcRx(uint8_t* Dest, uint16_t Len)
{
     9ee:	000c      	movs	r4, r1
	uint32_t RxPtr = HR_REG_24BIT(reg_map(IPC_RX_READ_PTR));
     9f0:	f7ff ffcc 	bl	98c <HR_REG_24BIT>
	for (uint16_t i=0; i<Len; i++) {
		Dest[i] = HREAD(RxPtr);
     9f4:	2180      	movs	r1, #128	; 0x80
}

static void ipcRx(uint8_t* Dest, uint16_t Len)
{
	uint32_t RxPtr = HR_REG_24BIT(reg_map(IPC_RX_READ_PTR));
	for (uint16_t i=0; i<Len; i++) {
     9f6:	2300      	movs	r3, #0
		Dest[i] = HREAD(RxPtr);
		if(++RxPtr >= IPC_RX_END) 
     9f8:	4e0e      	ldr	r6, [pc, #56]	; (a34 <ipcRx+0x4c>)

static void ipcRx(uint8_t* Dest, uint16_t Len)
{
	uint32_t RxPtr = HR_REG_24BIT(reg_map(IPC_RX_READ_PTR));
	for (uint16_t i=0; i<Len; i++) {
		Dest[i] = HREAD(RxPtr);
     9fa:	0549      	lsls	r1, r1, #21
}

static void ipcRx(uint8_t* Dest, uint16_t Len)
{
	uint32_t RxPtr = HR_REG_24BIT(reg_map(IPC_RX_READ_PTR));
	for (uint16_t i=0; i<Len; i++) {
     9fc:	b29a      	uxth	r2, r3
     9fe:	4294      	cmp	r4, r2
     a00:	d909      	bls.n	a16 <ipcRx+0x2e>
		Dest[i] = HREAD(RxPtr);
     a02:	000a      	movs	r2, r1
     a04:	4302      	orrs	r2, r0
     a06:	7812      	ldrb	r2, [r2, #0]
		if(++RxPtr >= IPC_RX_END) 
     a08:	3001      	adds	r0, #1

static void ipcRx(uint8_t* Dest, uint16_t Len)
{
	uint32_t RxPtr = HR_REG_24BIT(reg_map(IPC_RX_READ_PTR));
	for (uint16_t i=0; i<Len; i++) {
		Dest[i] = HREAD(RxPtr);
     a0a:	54ea      	strb	r2, [r5, r3]
		if(++RxPtr >= IPC_RX_END) 
     a0c:	42b0      	cmp	r0, r6
     a0e:	d900      	bls.n	a12 <ipcRx+0x2a>
			RxPtr = IPC_RX_HEAD;
     a10:	4809      	ldr	r0, [pc, #36]	; (a38 <ipcRx+0x50>)
     a12:	3301      	adds	r3, #1
     a14:	e7f2      	b.n	9fc <ipcRx+0x14>
	}
	
	HWRITE24BIT(IPC_RX_READ_PTR, RxPtr);
     a16:	4b06      	ldr	r3, [pc, #24]	; (a30 <ipcRx+0x48>)
     a18:	b2c2      	uxtb	r2, r0
     a1a:	701a      	strb	r2, [r3, #0]
     a1c:	1203      	asrs	r3, r0, #8
     a1e:	4a07      	ldr	r2, [pc, #28]	; (a3c <ipcRx+0x54>)
     a20:	b2db      	uxtb	r3, r3
     a22:	7013      	strb	r3, [r2, #0]
     a24:	1400      	asrs	r0, r0, #16
     a26:	4b06      	ldr	r3, [pc, #24]	; (a40 <ipcRx+0x58>)
     a28:	b2c0      	uxtb	r0, r0
     a2a:	7018      	strb	r0, [r3, #0]
}
     a2c:	bd70      	pop	{r4, r5, r6, pc}
     a2e:	46c0      	nop			; (mov r8, r8)
     a30:	1001030c 	.word	0x1001030c
     a34:	000104ff 	.word	0x000104ff
     a38:	00010350 	.word	0x00010350
     a3c:	1001030d 	.word	0x1001030d
     a40:	1001030e 	.word	0x1001030e

00000a44 <ipcTx>:

static void ipcTx(uint8_t* Src, uint8_t Len)
{
     a44:	b570      	push	{r4, r5, r6, lr}
     a46:	0004      	movs	r4, r0
	int me;
	uint32_t TxPtr = HR_REG_24BIT(reg_map(IPC_TX_WRITE_PTR));
     a48:	4810      	ldr	r0, [pc, #64]	; (a8c <ipcTx+0x48>)
	
	HWRITE24BIT(IPC_RX_READ_PTR, RxPtr);
}

static void ipcTx(uint8_t* Src, uint8_t Len)
{
     a4a:	000d      	movs	r5, r1
	int me;
	uint32_t TxPtr = HR_REG_24BIT(reg_map(IPC_TX_WRITE_PTR));
     a4c:	f7ff ff9e 	bl	98c <HR_REG_24BIT>
	for (uint16_t i=0; i<Len; i++) {
		HWRITE(TxPtr, Src[i]);
     a50:	2280      	movs	r2, #128	; 0x80
     a52:	0023      	movs	r3, r4
		if(++TxPtr >= IPC_TX_END) 
     a54:	490e      	ldr	r1, [pc, #56]	; (a90 <ipcTx+0x4c>)
     a56:	1965      	adds	r5, r4, r5
static void ipcTx(uint8_t* Src, uint8_t Len)
{
	int me;
	uint32_t TxPtr = HR_REG_24BIT(reg_map(IPC_TX_WRITE_PTR));
	for (uint16_t i=0; i<Len; i++) {
		HWRITE(TxPtr, Src[i]);
     a58:	0552      	lsls	r2, r2, #21

static void ipcTx(uint8_t* Src, uint8_t Len)
{
	int me;
	uint32_t TxPtr = HR_REG_24BIT(reg_map(IPC_TX_WRITE_PTR));
	for (uint16_t i=0; i<Len; i++) {
     a5a:	429d      	cmp	r5, r3
     a5c:	d00a      	beq.n	a74 <ipcTx+0x30>
		HWRITE(TxPtr, Src[i]);
     a5e:	0014      	movs	r4, r2
     a60:	781e      	ldrb	r6, [r3, #0]
     a62:	4304      	orrs	r4, r0
		if(++TxPtr >= IPC_TX_END) 
     a64:	3001      	adds	r0, #1
static void ipcTx(uint8_t* Src, uint8_t Len)
{
	int me;
	uint32_t TxPtr = HR_REG_24BIT(reg_map(IPC_TX_WRITE_PTR));
	for (uint16_t i=0; i<Len; i++) {
		HWRITE(TxPtr, Src[i]);
     a66:	7026      	strb	r6, [r4, #0]
		if(++TxPtr >= IPC_TX_END) 
     a68:	4288      	cmp	r0, r1
     a6a:	d901      	bls.n	a70 <ipcTx+0x2c>
			TxPtr = IPC_TX_HEAD;
     a6c:	2080      	movs	r0, #128	; 0x80
     a6e:	0240      	lsls	r0, r0, #9
     a70:	3301      	adds	r3, #1
     a72:	e7f2      	b.n	a5a <ipcTx+0x16>
		me=100;
		while(me--);
	}
	HWRITE24BIT(IPC_TX_WRITE_PTR, TxPtr);
     a74:	4b05      	ldr	r3, [pc, #20]	; (a8c <ipcTx+0x48>)
     a76:	b2c2      	uxtb	r2, r0
     a78:	701a      	strb	r2, [r3, #0]
     a7a:	1203      	asrs	r3, r0, #8
     a7c:	4a05      	ldr	r2, [pc, #20]	; (a94 <ipcTx+0x50>)
     a7e:	b2db      	uxtb	r3, r3
     a80:	7013      	strb	r3, [r2, #0]
     a82:	1400      	asrs	r0, r0, #16
     a84:	4b04      	ldr	r3, [pc, #16]	; (a98 <ipcTx+0x54>)
     a86:	b2c0      	uxtb	r0, r0
     a88:	7018      	strb	r0, [r3, #0]
}
     a8a:	bd70      	pop	{r4, r5, r6, pc}
     a8c:	10010300 	.word	0x10010300
     a90:	000102ff 	.word	0x000102ff
     a94:	10010301 	.word	0x10010301
     a98:	10010302 	.word	0x10010302

00000a9c <IPC_TxBufferIsEnough>:

unsigned char IPC_TxBufferIsEnough(uint8_t Len)
{
     a9c:	b570      	push	{r4, r5, r6, lr}
     a9e:	0005      	movs	r5, r0
	uint32_t TxPtr = HR_REG_24BIT(reg_map(IPC_TX_WRITE_PTR));
     aa0:	480c      	ldr	r0, [pc, #48]	; (ad4 <IPC_TxBufferIsEnough+0x38>)
     aa2:	f7ff ff73 	bl	98c <HR_REG_24BIT>
     aa6:	0004      	movs	r4, r0
	uint32_t TxReadPtr = HR_REG_24BIT(reg_map(IPC_TX_READ_PTR));
     aa8:	480b      	ldr	r0, [pc, #44]	; (ad8 <IPC_TxBufferIsEnough+0x3c>)
     aaa:	f7ff ff6f 	bl	98c <HR_REG_24BIT>

	for (uint16_t i=0; i<Len; i++) {
     aae:	2300      	movs	r3, #0
		if(++TxPtr >= IPC_TX_END) 
     ab0:	4a0a      	ldr	r2, [pc, #40]	; (adc <IPC_TxBufferIsEnough+0x40>)
unsigned char IPC_TxBufferIsEnough(uint8_t Len)
{
	uint32_t TxPtr = HR_REG_24BIT(reg_map(IPC_TX_WRITE_PTR));
	uint32_t TxReadPtr = HR_REG_24BIT(reg_map(IPC_TX_READ_PTR));

	for (uint16_t i=0; i<Len; i++) {
     ab2:	b2ad      	uxth	r5, r5
     ab4:	42ab      	cmp	r3, r5
     ab6:	d209      	bcs.n	acc <IPC_TxBufferIsEnough+0x30>
		if(++TxPtr >= IPC_TX_END) 
     ab8:	3401      	adds	r4, #1
     aba:	4294      	cmp	r4, r2
     abc:	d901      	bls.n	ac2 <IPC_TxBufferIsEnough+0x26>
			TxPtr = IPC_TX_HEAD;
     abe:	2480      	movs	r4, #128	; 0x80
     ac0:	0264      	lsls	r4, r4, #9

		if(TxPtr == TxReadPtr)
     ac2:	4284      	cmp	r4, r0
     ac4:	d004      	beq.n	ad0 <IPC_TxBufferIsEnough+0x34>
unsigned char IPC_TxBufferIsEnough(uint8_t Len)
{
	uint32_t TxPtr = HR_REG_24BIT(reg_map(IPC_TX_WRITE_PTR));
	uint32_t TxReadPtr = HR_REG_24BIT(reg_map(IPC_TX_READ_PTR));

	for (uint16_t i=0; i<Len; i++) {
     ac6:	3301      	adds	r3, #1
     ac8:	b29b      	uxth	r3, r3
     aca:	e7f3      	b.n	ab4 <IPC_TxBufferIsEnough+0x18>

		if(TxPtr == TxReadPtr)
			return 0;

	}
	return 1;
     acc:	2001      	movs	r0, #1
     ace:	e000      	b.n	ad2 <IPC_TxBufferIsEnough+0x36>
	for (uint16_t i=0; i<Len; i++) {
		if(++TxPtr >= IPC_TX_END) 
			TxPtr = IPC_TX_HEAD;

		if(TxPtr == TxReadPtr)
			return 0;
     ad0:	2000      	movs	r0, #0

	}
	return 1;
}
     ad2:	bd70      	pop	{r4, r5, r6, pc}
     ad4:	10010300 	.word	0x10010300
     ad8:	10010304 	.word	0x10010304
     adc:	000102ff 	.word	0x000102ff

00000ae0 <IPC_WaitBufferEnough>:

unsigned char IPC_WaitBufferEnough(uint8_t Len)
{
     ae0:	b510      	push	{r4, lr}
     ae2:	0004      	movs	r4, r0
	int m;
	while(1){
		if(IPC_TxBufferIsEnough(Len))
     ae4:	0020      	movs	r0, r4
     ae6:	f7ff ffd9 	bl	a9c <IPC_TxBufferIsEnough>
     aea:	2800      	cmp	r0, #0
     aec:	d0fa      	beq.n	ae4 <IPC_WaitBufferEnough+0x4>
		{
			m = 1000;
			while(m--);
		}
	}
}
     aee:	2001      	movs	r0, #1
     af0:	bd10      	pop	{r4, pc}

00000af2 <IPC_TxCommon>:

void IPC_TxCommon(uint8_t Type, uint8_t* Dt, uint8_t Len)
{
     af2:	b570      	push	{r4, r5, r6, lr}
	ipcSendBuff[0] = Type;
     af4:	4d07      	ldr	r5, [pc, #28]	; (b14 <IPC_TxCommon+0x22>)
	if (Len == 0 || Len > IPC_TX_BUFF_LEN-2)
     af6:	1e53      	subs	r3, r2, #1
		}
	}
}

void IPC_TxCommon(uint8_t Type, uint8_t* Dt, uint8_t Len)
{
     af8:	0014      	movs	r4, r2
	ipcSendBuff[0] = Type;
     afa:	7028      	strb	r0, [r5, #0]
	if (Len == 0 || Len > IPC_TX_BUFF_LEN-2)
     afc:	2b1b      	cmp	r3, #27
     afe:	d808      	bhi.n	b12 <IPC_TxCommon+0x20>
		return;
	ipcSendBuff[1] = Len;
	memcpy(&ipcSendBuff[2], Dt, Len);
     b00:	4805      	ldr	r0, [pc, #20]	; (b18 <IPC_TxCommon+0x26>)
	ipcTx(ipcSendBuff, Len + 2);
     b02:	3402      	adds	r4, #2
void IPC_TxCommon(uint8_t Type, uint8_t* Dt, uint8_t Len)
{
	ipcSendBuff[0] = Type;
	if (Len == 0 || Len > IPC_TX_BUFF_LEN-2)
		return;
	ipcSendBuff[1] = Len;
     b04:	706a      	strb	r2, [r5, #1]
	memcpy(&ipcSendBuff[2], Dt, Len);
     b06:	f014 ff63 	bl	159d0 <memcpy>
	ipcTx(ipcSendBuff, Len + 2);
     b0a:	b2e1      	uxtb	r1, r4
     b0c:	0028      	movs	r0, r5
     b0e:	f7ff ff99 	bl	a44 <ipcTx>
}
     b12:	bd70      	pop	{r4, r5, r6, pc}
     b14:	100127da 	.word	0x100127da
     b18:	100127dc 	.word	0x100127dc

00000b1c <IPC_TxPacket>:

void IPC_TxPacket(IPC_DATA_FORMAT *packet)
{
	if (packet->len == 0)
     b1c:	7841      	ldrb	r1, [r0, #1]
	memcpy(&ipcSendBuff[2], Dt, Len);
	ipcTx(ipcSendBuff, Len + 2);
}

void IPC_TxPacket(IPC_DATA_FORMAT *packet)
{
     b1e:	b510      	push	{r4, lr}
	if (packet->len == 0)
     b20:	2900      	cmp	r1, #0
     b22:	d003      	beq.n	b2c <IPC_TxPacket+0x10>
		return;

	ipcTx((unsigned char*)packet,  packet->len+ 2);
     b24:	3102      	adds	r1, #2
     b26:	b2c9      	uxtb	r1, r1
     b28:	f7ff ff8c 	bl	a44 <ipcTx>
}
     b2c:	bd10      	pop	{r4, pc}

00000b2e <IPC_TxControlCmd>:

void IPC_TxControlCmd(uint8_t Cmd)
{
     b2e:	b573      	push	{r0, r1, r4, r5, r6, lr}
#define IPC_CMD_LEN 3
	uint8_t cmdBuff[IPC_CMD_LEN] = {IPC_CONTROL_CMD,0x01};
     b30:	2503      	movs	r5, #3
     b32:	ac01      	add	r4, sp, #4

	ipcTx((unsigned char*)packet,  packet->len+ 2);
}

void IPC_TxControlCmd(uint8_t Cmd)
{
     b34:	0006      	movs	r6, r0
#define IPC_CMD_LEN 3
	uint8_t cmdBuff[IPC_CMD_LEN] = {IPC_CONTROL_CMD,0x01};
     b36:	002a      	movs	r2, r5
     b38:	2100      	movs	r1, #0
     b3a:	0020      	movs	r0, r4
     b3c:	f014 ff86 	bl	15a4c <memset>
     b40:	2301      	movs	r3, #1
	cmdBuff[IPC_CMD_LEN - 1] = Cmd;
	ipcTx(cmdBuff, IPC_CMD_LEN);
     b42:	0029      	movs	r1, r5
     b44:	0020      	movs	r0, r4

void IPC_TxControlCmd(uint8_t Cmd)
{
#define IPC_CMD_LEN 3
	uint8_t cmdBuff[IPC_CMD_LEN] = {IPC_CONTROL_CMD,0x01};
	cmdBuff[IPC_CMD_LEN - 1] = Cmd;
     b46:	70a6      	strb	r6, [r4, #2]
}

void IPC_TxControlCmd(uint8_t Cmd)
{
#define IPC_CMD_LEN 3
	uint8_t cmdBuff[IPC_CMD_LEN] = {IPC_CONTROL_CMD,0x01};
     b48:	7023      	strb	r3, [r4, #0]
     b4a:	7063      	strb	r3, [r4, #1]
	cmdBuff[IPC_CMD_LEN - 1] = Cmd;
	ipcTx(cmdBuff, IPC_CMD_LEN);
     b4c:	f7ff ff7a 	bl	a44 <ipcTx>
}
     b50:	bd73      	pop	{r0, r1, r4, r5, r6, pc}

00000b52 <IPC_GetBBDIsconnectReason>:
     b52:	2000      	movs	r0, #0
     b54:	4770      	bx	lr

00000b56 <IPC_CheckServerConenct>:
}

uint8_t IPC_CheckServerConenct()
{
	return 0;
}
     b56:	2000      	movs	r0, #0
     b58:	4770      	bx	lr

00000b5a <IPC_CheckReconnect>:

uint8_t IPC_CheckReconnect()
{
	return 0;
}
     b5a:	2000      	movs	r0, #0
     b5c:	4770      	bx	lr

00000b5e <IPC_WaitLpm>:

void IPC_WaitLpm()
{
     b5e:	b510      	push	{r4, lr}
	int dayloop = 10000;
	while(dayloop--) hw_delay();
     b60:	4c03      	ldr	r4, [pc, #12]	; (b70 <IPC_WaitLpm+0x12>)
     b62:	3c01      	subs	r4, #1
     b64:	2c00      	cmp	r4, #0
     b66:	d002      	beq.n	b6e <IPC_WaitLpm+0x10>
     b68:	f7ff ff0a 	bl	980 <hw_delay>
     b6c:	e7f9      	b.n	b62 <IPC_WaitLpm+0x4>
}
     b6e:	bd10      	pop	{r4, pc}
     b70:	00002711 	.word	0x00002711

00000b74 <IPC_AbandonLpm>:

void IPC_AbandonLpm()
{
     b74:	b510      	push	{r4, lr}
	hw_delay();
     b76:	f7ff ff03 	bl	980 <hw_delay>
	//HW_REG_8BIT(IPC_M0_BUSY_FALG_ADDR, 0);
}
     b7a:	bd10      	pop	{r4, pc}

00000b7c <IPC_DisableLpm>:
     b7c:	b510      	push	{r4, lr}
     b7e:	f7ff feff 	bl	980 <hw_delay>
     b82:	bd10      	pop	{r4, pc}

00000b84 <IPC_EnableLpm>:
	hw_delay();
	//HW_REG_8BIT(IPC_LPM_FLAG_ADDR, 0);
}

void IPC_EnableLpm()
{
     b84:	b510      	push	{r4, lr}
	hw_delay();
     b86:	f7ff fefb 	bl	980 <hw_delay>
	//HW_REG_8BIT(IPC_LPM_FLAG_ADDR, 1);
}
     b8a:	bd10      	pop	{r4, pc}

00000b8c <IPC_IsTxBuffEmpty>:


uint8_t IPC_IsTxBuffEmpty()
{
     b8c:	b510      	push	{r4, lr}
	uint32_t TxReadPtr = HR_REG_24BIT(reg_map(IPC_TX_READ_PTR));
     b8e:	4806      	ldr	r0, [pc, #24]	; (ba8 <IPC_IsTxBuffEmpty+0x1c>)
     b90:	f7ff fefc 	bl	98c <HR_REG_24BIT>
     b94:	0004      	movs	r4, r0
	uint32_t TxWritePtr = HR_REG_24BIT(reg_map(IPC_TX_WRITE_PTR));
     b96:	4805      	ldr	r0, [pc, #20]	; (bac <IPC_IsTxBuffEmpty+0x20>)
     b98:	f7ff fef8 	bl	98c <HR_REG_24BIT>
     b9c:	1a20      	subs	r0, r4, r0
     b9e:	4244      	negs	r4, r0
     ba0:	4160      	adcs	r0, r4
	if (TxWritePtr == TxReadPtr)
		return 1;
	return 0;
}
     ba2:	b2c0      	uxtb	r0, r0
     ba4:	bd10      	pop	{r4, pc}
     ba6:	46c0      	nop			; (mov r8, r8)
     ba8:	10010304 	.word	0x10010304
     bac:	10010300 	.word	0x10010300

00000bb0 <IPC_IsRxBuffEmpty>:

uint8_t IPC_IsRxBuffEmpty()
{
     bb0:	b510      	push	{r4, lr}
	uint32_t RxReadPtr = HR_REG_24BIT(reg_map(IPC_RX_READ_PTR));
     bb2:	4806      	ldr	r0, [pc, #24]	; (bcc <IPC_IsRxBuffEmpty+0x1c>)
     bb4:	f7ff feea 	bl	98c <HR_REG_24BIT>
     bb8:	0004      	movs	r4, r0
	uint32_t RxWritePtr = HR_REG_24BIT(reg_map(IPC_RX_WRITE_PTR));
     bba:	4805      	ldr	r0, [pc, #20]	; (bd0 <IPC_IsRxBuffEmpty+0x20>)
     bbc:	f7ff fee6 	bl	98c <HR_REG_24BIT>
     bc0:	1a20      	subs	r0, r4, r0
     bc2:	4244      	negs	r4, r0
     bc4:	4160      	adcs	r0, r4
//	printf("RxReadPtr = %06x, RxWritePtr = %06x \n",RxReadPtr,RxWritePtr);
	if (RxReadPtr == RxWritePtr)
		return 1;
	return 0;
}
     bc6:	b2c0      	uxtb	r0, r0
     bc8:	bd10      	pop	{r4, pc}
     bca:	46c0      	nop			; (mov r8, r8)
     bcc:	1001030c 	.word	0x1001030c
     bd0:	10010308 	.word	0x10010308

00000bd4 <IPC_HandleRxPacket>:

uint16_t a2dpLen;


void IPC_HandleRxPacket()
{
     bd4:	b570      	push	{r4, r5, r6, lr}
	uint8_t *pbuff = ipcReadBuff;
	if (IPC_IsRxBuffEmpty())
     bd6:	f7ff ffeb 	bl	bb0 <IPC_IsRxBuffEmpty>
     bda:	2800      	cmp	r0, #0
     bdc:	d117      	bne.n	c0e <IPC_HandleRxPacket+0x3a>
		return;

	ipcRx(ipcReadBuff, 2);
     bde:	4c0c      	ldr	r4, [pc, #48]	; (c10 <IPC_HandleRxPacket+0x3c>)
     be0:	2102      	movs	r1, #2
     be2:	0020      	movs	r0, r4
     be4:	f7ff ff00 	bl	9e8 <ipcRx>
	if(*pbuff > IPC_TYPE_START && *pbuff < IPC_TYPE_NUM)
     be8:	7823      	ldrb	r3, [r4, #0]
     bea:	3b01      	subs	r3, #1
     bec:	2b0a      	cmp	r3, #10
     bee:	d80d      	bhi.n	c0c <IPC_HandleRxPacket+0x38>
	{
		ipcRx(ipcReadBuff+2, *(pbuff+1));	
     bf0:	4d08      	ldr	r5, [pc, #32]	; (c14 <IPC_HandleRxPacket+0x40>)
     bf2:	7861      	ldrb	r1, [r4, #1]
     bf4:	0028      	movs	r0, r5
     bf6:	f7ff fef7 	bl	9e8 <ipcRx>
		//(*gIPCHandleCb[*pbuff])(*(pbuff+1),pbuff+2);
		(*(*ipcCbArray)[*pbuff])(*(pbuff+1),pbuff+2);
     bfa:	4b07      	ldr	r3, [pc, #28]	; (c18 <IPC_HandleRxPacket+0x44>)
     bfc:	7860      	ldrb	r0, [r4, #1]
     bfe:	6a9a      	ldr	r2, [r3, #40]	; 0x28
     c00:	7823      	ldrb	r3, [r4, #0]
     c02:	0029      	movs	r1, r5
     c04:	009b      	lsls	r3, r3, #2
     c06:	589b      	ldr	r3, [r3, r2]
     c08:	4798      	blx	r3
     c0a:	e000      	b.n	c0e <IPC_HandleRxPacket+0x3a>
     c0c:	e7fe      	b.n	c0c <IPC_HandleRxPacket+0x38>
	else
	{
		while(1);
	}

}
     c0e:	bd70      	pop	{r4, r5, r6, pc}
     c10:	10012712 	.word	0x10012712
     c14:	10012714 	.word	0x10012714
     c18:	10010f8c 	.word	0x10010f8c

00000c1c <IPC_DealSingleStep>:

void IPC_DealSingleStep()
{
     c1c:	b570      	push	{r4, r5, r6, lr}
#define IPC_FRAME_HEAD_SIZE 3
	uint8_t *pbuff = ipcReadBuff;//СΪ30ֽ
	if (IPC_IsRxBuffEmpty())
     c1e:	f7ff ffc7 	bl	bb0 <IPC_IsRxBuffEmpty>
     c22:	2800      	cmp	r0, #0
     c24:	d000      	beq.n	c28 <IPC_DealSingleStep+0xc>
     c26:	e082      	b.n	d2e <IPC_DealSingleStep+0x112>
		return;
			
	ipcRx(ipcReadBuff, IPC_FRAME_HEAD_SIZE);
     c28:	4d41      	ldr	r5, [pc, #260]	; (d30 <IPC_DealSingleStep+0x114>)
     c2a:	2103      	movs	r1, #3
     c2c:	0028      	movs	r0, r5
     c2e:	f7ff fedb 	bl	9e8 <ipcRx>
 		
	if (*pbuff == IPC_CONTROL_EVT) {
     c32:	782b      	ldrb	r3, [r5, #0]
     c34:	2b02      	cmp	r3, #2
     c36:	d108      	bne.n	c4a <IPC_DealSingleStep+0x2e>
		pbuff += 2;
		if(ipcCb.evtcb) ipcCb.evtcb(*pbuff);//յ
     c38:	4b3e      	ldr	r3, [pc, #248]	; (d34 <IPC_DealSingleStep+0x118>)
     c3a:	4e3f      	ldr	r6, [pc, #252]	; (d38 <IPC_DealSingleStep+0x11c>)
     c3c:	681b      	ldr	r3, [r3, #0]
		return;
			
	ipcRx(ipcReadBuff, IPC_FRAME_HEAD_SIZE);
 		
	if (*pbuff == IPC_CONTROL_EVT) {
		pbuff += 2;
     c3e:	0034      	movs	r4, r6
		if(ipcCb.evtcb) ipcCb.evtcb(*pbuff);//յ
     c40:	2b00      	cmp	r3, #0
     c42:	d016      	beq.n	c72 <IPC_DealSingleStep+0x56>
     c44:	78a8      	ldrb	r0, [r5, #2]
     c46:	4798      	blx	r3
     c48:	e013      	b.n	c72 <IPC_DealSingleStep+0x56>
}

void IPC_DealSingleStep()
{
#define IPC_FRAME_HEAD_SIZE 3
	uint8_t *pbuff = ipcReadBuff;//СΪ30ֽ
     c4a:	002c      	movs	r4, r5
 		
	if (*pbuff == IPC_CONTROL_EVT) {
		pbuff += 2;
		if(ipcCb.evtcb) ipcCb.evtcb(*pbuff);//յ
	}
	else if (*pbuff == IPC_SPP_DATA) {
     c4c:	2b04      	cmp	r3, #4
     c4e:	d110      	bne.n	c72 <IPC_DealSingleStep+0x56>
		pbuff++;
		ipcRx(ipcReadBuff+IPC_FRAME_HEAD_SIZE, *pbuff -1);
     c50:	7869      	ldrb	r1, [r5, #1]
     c52:	483a      	ldr	r0, [pc, #232]	; (d3c <IPC_DealSingleStep+0x120>)
     c54:	3901      	subs	r1, #1
     c56:	b289      	uxth	r1, r1
     c58:	f7ff fec6 	bl	9e8 <ipcRx>
		if(ipcCb.sppcb) ipcCb.sppcb(pbuff+1, *pbuff);
     c5c:	4b35      	ldr	r3, [pc, #212]	; (d34 <IPC_DealSingleStep+0x118>)
     c5e:	4d38      	ldr	r5, [pc, #224]	; (d40 <IPC_DealSingleStep+0x124>)
     c60:	685b      	ldr	r3, [r3, #4]
     c62:	2b00      	cmp	r3, #0
     c64:	d004      	beq.n	c70 <IPC_DealSingleStep+0x54>
     c66:	7861      	ldrb	r1, [r4, #1]
     c68:	4833      	ldr	r0, [pc, #204]	; (d38 <IPC_DealSingleStep+0x11c>)
     c6a:	4798      	blx	r3
	if (*pbuff == IPC_CONTROL_EVT) {
		pbuff += 2;
		if(ipcCb.evtcb) ipcCb.evtcb(*pbuff);//յ
	}
	else if (*pbuff == IPC_SPP_DATA) {
		pbuff++;
     c6c:	002c      	movs	r4, r5
     c6e:	e000      	b.n	c72 <IPC_DealSingleStep+0x56>
     c70:	002c      	movs	r4, r5
		ipcRx(ipcReadBuff+IPC_FRAME_HEAD_SIZE, *pbuff -1);
		if(ipcCb.sppcb) ipcCb.sppcb(pbuff+1, *pbuff);
	}	
	if (*pbuff == IPC_BLE_DATA) {
     c72:	7823      	ldrb	r3, [r4, #0]
     c74:	2b05      	cmp	r3, #5
     c76:	d10a      	bne.n	c8e <IPC_DealSingleStep+0x72>
		pbuff++;
		ipcRx(ipcReadBuff+IPC_FRAME_HEAD_SIZE, *pbuff -1);				
     c78:	7861      	ldrb	r1, [r4, #1]
     c7a:	4830      	ldr	r0, [pc, #192]	; (d3c <IPC_DealSingleStep+0x120>)
     c7c:	3901      	subs	r1, #1
     c7e:	b289      	uxth	r1, r1
     c80:	f7ff feb2 	bl	9e8 <ipcRx>
		if(ipcCb.blecb) ipcCb.blecb(pbuff+1, *pbuff);//յ
     c84:	4b2b      	ldr	r3, [pc, #172]	; (d34 <IPC_DealSingleStep+0x118>)
     c86:	691b      	ldr	r3, [r3, #16]
     c88:	2b00      	cmp	r3, #0
     c8a:	d14d      	bne.n	d28 <IPC_DealSingleStep+0x10c>
     c8c:	e04f      	b.n	d2e <IPC_DealSingleStep+0x112>
	}	
	else if (*pbuff == IPC_HID_DATA) {
     c8e:	2b03      	cmp	r3, #3
     c90:	d10a      	bne.n	ca8 <IPC_DealSingleStep+0x8c>
		pbuff++;
		ipcRx(ipcReadBuff+IPC_FRAME_HEAD_SIZE, *pbuff -1);
     c92:	7861      	ldrb	r1, [r4, #1]
     c94:	4829      	ldr	r0, [pc, #164]	; (d3c <IPC_DealSingleStep+0x120>)
     c96:	3901      	subs	r1, #1
     c98:	b289      	uxth	r1, r1
     c9a:	f7ff fea5 	bl	9e8 <ipcRx>
		if(ipcCb.hidcb) ipcCb.hidcb(pbuff+1, *pbuff);
     c9e:	4b25      	ldr	r3, [pc, #148]	; (d34 <IPC_DealSingleStep+0x118>)
     ca0:	699b      	ldr	r3, [r3, #24]
     ca2:	2b00      	cmp	r3, #0
     ca4:	d140      	bne.n	d28 <IPC_DealSingleStep+0x10c>
     ca6:	e042      	b.n	d2e <IPC_DealSingleStep+0x112>
	}
	else if (*pbuff == IPC_MESH_DATA) {
     ca8:	2b07      	cmp	r3, #7
     caa:	d110      	bne.n	cce <IPC_DealSingleStep+0xb2>
 		pbuff++;
		ipcRx(ipcReadBuff+IPC_FRAME_HEAD_SIZE, *pbuff -1);
     cac:	7861      	ldrb	r1, [r4, #1]
     cae:	4823      	ldr	r0, [pc, #140]	; (d3c <IPC_DealSingleStep+0x120>)
     cb0:	3901      	subs	r1, #1
     cb2:	b289      	uxth	r1, r1
     cb4:	f7ff fe98 	bl	9e8 <ipcRx>
		if(ipcCb.meshcb) ipcCb.meshcb(*(pbuff+1), pbuff+2, *pbuff-1);
     cb8:	4b1e      	ldr	r3, [pc, #120]	; (d34 <IPC_DealSingleStep+0x118>)
     cba:	69db      	ldr	r3, [r3, #28]
     cbc:	2b00      	cmp	r3, #0
     cbe:	d036      	beq.n	d2e <IPC_DealSingleStep+0x112>
     cc0:	7862      	ldrb	r2, [r4, #1]
     cc2:	1ce1      	adds	r1, r4, #3
     cc4:	3a01      	subs	r2, #1
     cc6:	b292      	uxth	r2, r2
     cc8:	78a0      	ldrb	r0, [r4, #2]
     cca:	4798      	blx	r3
     ccc:	e02f      	b.n	d2e <IPC_DealSingleStep+0x112>
	}
	else if (*pbuff == IPC_A2DP_DATA) {
     cce:	2b0a      	cmp	r3, #10
     cd0:	d111      	bne.n	cf6 <IPC_DealSingleStep+0xda>
		pbuff++;
		a2dpLen = pbuff[0]|pbuff[1]<<8;
     cd2:	78a1      	ldrb	r1, [r4, #2]
     cd4:	7863      	ldrb	r3, [r4, #1]
		ipcRx(ipcReadBuff+IPC_FRAME_HEAD_SIZE, a2dpLen);
     cd6:	4c19      	ldr	r4, [pc, #100]	; (d3c <IPC_DealSingleStep+0x120>)
		ipcRx(ipcReadBuff+IPC_FRAME_HEAD_SIZE, *pbuff -1);
		if(ipcCb.meshcb) ipcCb.meshcb(*(pbuff+1), pbuff+2, *pbuff-1);
	}
	else if (*pbuff == IPC_A2DP_DATA) {
		pbuff++;
		a2dpLen = pbuff[0]|pbuff[1]<<8;
     cd8:	4d1a      	ldr	r5, [pc, #104]	; (d44 <IPC_DealSingleStep+0x128>)
     cda:	0209      	lsls	r1, r1, #8
     cdc:	4319      	orrs	r1, r3
		ipcRx(ipcReadBuff+IPC_FRAME_HEAD_SIZE, a2dpLen);
     cde:	0020      	movs	r0, r4
		ipcRx(ipcReadBuff+IPC_FRAME_HEAD_SIZE, *pbuff -1);
		if(ipcCb.meshcb) ipcCb.meshcb(*(pbuff+1), pbuff+2, *pbuff-1);
	}
	else if (*pbuff == IPC_A2DP_DATA) {
		pbuff++;
		a2dpLen = pbuff[0]|pbuff[1]<<8;
     ce0:	8029      	strh	r1, [r5, #0]
		ipcRx(ipcReadBuff+IPC_FRAME_HEAD_SIZE, a2dpLen);
     ce2:	f7ff fe81 	bl	9e8 <ipcRx>
		if(ipcCb.a2dpcb) ipcCb.a2dpcb(ipcReadBuff+IPC_FRAME_HEAD_SIZE,a2dpLen);
     ce6:	4b13      	ldr	r3, [pc, #76]	; (d34 <IPC_DealSingleStep+0x118>)
     ce8:	6a1b      	ldr	r3, [r3, #32]
     cea:	2b00      	cmp	r3, #0
     cec:	d01f      	beq.n	d2e <IPC_DealSingleStep+0x112>
     cee:	8829      	ldrh	r1, [r5, #0]
     cf0:	0020      	movs	r0, r4
     cf2:	4798      	blx	r3
     cf4:	e01b      	b.n	d2e <IPC_DealSingleStep+0x112>
	}
	else if(*pbuff == IPC_MESH_ADV_DATA) {
     cf6:	2b08      	cmp	r3, #8
     cf8:	d10a      	bne.n	d10 <IPC_DealSingleStep+0xf4>
		pbuff++;
		ipcRx(ipcReadBuff+IPC_FRAME_HEAD_SIZE,*pbuff -1);
     cfa:	7861      	ldrb	r1, [r4, #1]
     cfc:	480f      	ldr	r0, [pc, #60]	; (d3c <IPC_DealSingleStep+0x120>)
     cfe:	3901      	subs	r1, #1
     d00:	b289      	uxth	r1, r1
     d02:	f7ff fe71 	bl	9e8 <ipcRx>
		if(ipcCb.advcb) ipcCb.advcb(pbuff+1,*pbuff);
     d06:	4b0b      	ldr	r3, [pc, #44]	; (d34 <IPC_DealSingleStep+0x118>)
     d08:	695b      	ldr	r3, [r3, #20]
     d0a:	2b00      	cmp	r3, #0
     d0c:	d10c      	bne.n	d28 <IPC_DealSingleStep+0x10c>
     d0e:	e00e      	b.n	d2e <IPC_DealSingleStep+0x112>
	}else if(*pbuff == IPC_READ_CONN_PARA) {
     d10:	2b0c      	cmp	r3, #12
     d12:	d10c      	bne.n	d2e <IPC_DealSingleStep+0x112>
		pbuff++;
		ipcRx(ipcReadBuff+IPC_FRAME_HEAD_SIZE,*pbuff-1);
     d14:	7861      	ldrb	r1, [r4, #1]
     d16:	4809      	ldr	r0, [pc, #36]	; (d3c <IPC_DealSingleStep+0x120>)
     d18:	3901      	subs	r1, #1
     d1a:	b289      	uxth	r1, r1
     d1c:	f7ff fe64 	bl	9e8 <ipcRx>
		if(ipcCb.readconnparamcb) ipcCb.readconnparamcb(pbuff+1,*pbuff);//
     d20:	4b04      	ldr	r3, [pc, #16]	; (d34 <IPC_DealSingleStep+0x118>)
     d22:	6a5b      	ldr	r3, [r3, #36]	; 0x24
     d24:	2b00      	cmp	r3, #0
     d26:	d002      	beq.n	d2e <IPC_DealSingleStep+0x112>
     d28:	7861      	ldrb	r1, [r4, #1]
     d2a:	1ca0      	adds	r0, r4, #2
     d2c:	4798      	blx	r3
	}
//	while(1);
}
     d2e:	bd70      	pop	{r4, r5, r6, pc}
     d30:	10012712 	.word	0x10012712
     d34:	10010f8c 	.word	0x10010f8c
     d38:	10012714 	.word	0x10012714
     d3c:	10012715 	.word	0x10012715
     d40:	10012713 	.word	0x10012713
     d44:	100127fa 	.word	0x100127fa

00000d48 <IPC_set_ack_flag>:

void IPC_set_ack_flag()
{
  HWRITE(IPC_MCU_PHASE,IPC_MCU_PHASE1_ACK);
     d48:	2302      	movs	r3, #2
     d4a:	490b      	ldr	r1, [pc, #44]	; (d78 <IPC_set_ack_flag+0x30>)
	}
//	while(1);
}

void IPC_set_ack_flag()
{
     d4c:	b570      	push	{r4, r5, r6, lr}
  HWRITE(IPC_MCU_PHASE,IPC_MCU_PHASE1_ACK);
     d4e:	700b      	strb	r3, [r1, #0]
  HWRITE(IPC_MCU_STATE,IPC_MCU_STATE_RUNNING);
     d50:	4b0a      	ldr	r3, [pc, #40]	; (d7c <IPC_set_ack_flag+0x34>)
     d52:	2200      	movs	r2, #0
  while(HREAD(IPC_MCU_STATE))
     d54:	001c      	movs	r4, r3
    {
    HWRITE(0x4ff1,IPC_MCU_STATE_HIBERNATE);
     d56:	2601      	movs	r6, #1
     d58:	4d09      	ldr	r5, [pc, #36]	; (d80 <IPC_set_ack_flag+0x38>)
}

void IPC_set_ack_flag()
{
  HWRITE(IPC_MCU_PHASE,IPC_MCU_PHASE1_ACK);
  HWRITE(IPC_MCU_STATE,IPC_MCU_STATE_RUNNING);
     d5a:	701a      	strb	r2, [r3, #0]
  while(HREAD(IPC_MCU_STATE))
     d5c:	7818      	ldrb	r0, [r3, #0]
     d5e:	2800      	cmp	r0, #0
     d60:	d002      	beq.n	d68 <IPC_set_ack_flag+0x20>
    {
    HWRITE(0x4ff1,IPC_MCU_STATE_HIBERNATE);
     d62:	702e      	strb	r6, [r5, #0]
    HWRITE(IPC_MCU_STATE,IPC_MCU_STATE_RUNNING);
     d64:	7022      	strb	r2, [r4, #0]
     d66:	e7f9      	b.n	d5c <IPC_set_ack_flag+0x14>
    }
  while(HREAD(IPC_MCU_PHASE) != IPC_MCU_PHASE1_ACK)
     d68:	4a03      	ldr	r2, [pc, #12]	; (d78 <IPC_set_ack_flag+0x30>)
    {
    HWRITE(IPC_MCU_PHASE,IPC_MCU_PHASE1_ACK);
     d6a:	3002      	adds	r0, #2
  while(HREAD(IPC_MCU_STATE))
    {
    HWRITE(0x4ff1,IPC_MCU_STATE_HIBERNATE);
    HWRITE(IPC_MCU_STATE,IPC_MCU_STATE_RUNNING);
    }
  while(HREAD(IPC_MCU_PHASE) != IPC_MCU_PHASE1_ACK)
     d6c:	780b      	ldrb	r3, [r1, #0]
     d6e:	2b02      	cmp	r3, #2
     d70:	d001      	beq.n	d76 <IPC_set_ack_flag+0x2e>
    {
    HWRITE(IPC_MCU_PHASE,IPC_MCU_PHASE1_ACK);
     d72:	7010      	strb	r0, [r2, #0]
     d74:	e7fa      	b.n	d6c <IPC_set_ack_flag+0x24>
    }
}
     d76:	bd70      	pop	{r4, r5, r6, pc}
     d78:	10004333 	.word	0x10004333
     d7c:	10004334 	.word	0x10004334
     d80:	10004ff1 	.word	0x10004ff1

00000d84 <IPC_set_nack_flag>:

void IPC_set_nack_flag()
{
	HWRITE(IPC_MCU_PHASE,IPC_MCU_PHASE1_NACK);
     d84:	2201      	movs	r2, #1
     d86:	4b03      	ldr	r3, [pc, #12]	; (d94 <IPC_set_nack_flag+0x10>)
     d88:	701a      	strb	r2, [r3, #0]
	HWRITE(IPC_MCU_STATE,IPC_MCU_STATE_RUNNING);
     d8a:	2200      	movs	r2, #0
     d8c:	4b02      	ldr	r3, [pc, #8]	; (d98 <IPC_set_nack_flag+0x14>)
     d8e:	701a      	strb	r2, [r3, #0]
}
     d90:	4770      	bx	lr
     d92:	46c0      	nop			; (mov r8, r8)
     d94:	10004333 	.word	0x10004333
     d98:	10004334 	.word	0x10004334

00000d9c <IPC_clear_flag>:

void IPC_clear_flag()
{
	HWRITE(IPC_MCU_PHASE,IPC_MCU_PHASE_IDLE);
     d9c:	2300      	movs	r3, #0
     d9e:	4a02      	ldr	r2, [pc, #8]	; (da8 <IPC_clear_flag+0xc>)
     da0:	7013      	strb	r3, [r2, #0]
	HWRITE(IPC_MCU_STATE,IPC_MCU_STATE_RUNNING);
     da2:	4a02      	ldr	r2, [pc, #8]	; (dac <IPC_clear_flag+0x10>)
     da4:	7013      	strb	r3, [r2, #0]
}
     da6:	4770      	bx	lr
     da8:	10004333 	.word	0x10004333
     dac:	10004334 	.word	0x10004334

00000db0 <IPC_wait_ack>:
	int i;
	while(1)
	{
		i = 500;
		while(i--);
		switch (HREAD(IPC_MCU_PHASE))
     db0:	4a02      	ldr	r2, [pc, #8]	; (dbc <IPC_wait_ack+0xc>)
     db2:	7813      	ldrb	r3, [r2, #0]
     db4:	2b00      	cmp	r3, #0
     db6:	d1fc      	bne.n	db2 <IPC_wait_ack+0x2>
				break;
			case IPC_MCU_PHASE_IDLE:
				return;
		}
	}
}
     db8:	4770      	bx	lr
     dba:	46c0      	nop			; (mov r8, r8)
     dbc:	10004333 	.word	0x10004333

00000dc0 <Start>:
#endif


void __attribute__((noinline)) Start()
{
	__ASM("nop");
     dc0:	46c0      	nop			; (mov r8, r8)
}
     dc2:	4770      	bx	lr

00000dc4 <FillSendCMD>:
{
	//uint8_t j;
	buf[0] = cmd;
	//for(j = 0;j < 3;j++);
//	QSPI_Delay(1);
	buf[1] = flash_addr >> 16;
     dc4:	1413      	asrs	r3, r2, #16
     dc6:	7043      	strb	r3, [r0, #1]
	//for(j = 0;j < 3;j++);
//	QSPI_Delay(1);
	buf[2] = flash_addr >> 8;
     dc8:	1213      	asrs	r3, r2, #8
*/

void __attribute__((noinline))   FillSendCMD(uint8_t *buf, uint8_t cmd, int flash_addr)
{
	//uint8_t j;
	buf[0] = cmd;
     dca:	7001      	strb	r1, [r0, #0]
	//for(j = 0;j < 3;j++);
//	QSPI_Delay(1);
	buf[1] = flash_addr >> 16;
	//for(j = 0;j < 3;j++);
//	QSPI_Delay(1);
	buf[2] = flash_addr >> 8;
     dcc:	7083      	strb	r3, [r0, #2]
	//for(j = 0;j < 3;j++);
//	QSPI_Delay(1);
	buf[3] = flash_addr;
     dce:	70c2      	strb	r2, [r0, #3]
}
     dd0:	4770      	bx	lr

00000dd2 <ReadFlashDSPI>:
//	}
}
*/

void  ReadFlashDSPI(uint8_t cammond,int flash_addr, int rxlen, uint8_t *rxbuf)
{
     dd2:	b5f0      	push	{r4, r5, r6, r7, lr}
     dd4:	001e      	movs	r6, r3
//	int addr;
//	volatile unsigned int i, j;
	uint8_t mode, delay;
#ifdef RAM10000
	uint8_t temp[4]={0,0,0,0};
     dd6:	2300      	movs	r3, #0
//	}
}
*/

void  ReadFlashDSPI(uint8_t cammond,int flash_addr, int rxlen, uint8_t *rxbuf)
{
     dd8:	b085      	sub	sp, #20
//	int addr;
//	volatile unsigned int i, j;
	uint8_t mode, delay;
#ifdef RAM10000
	uint8_t temp[4]={0,0,0,0};
     dda:	ac03      	add	r4, sp, #12
//	}
}
*/

void  ReadFlashDSPI(uint8_t cammond,int flash_addr, int rxlen, uint8_t *rxbuf)
{
     ddc:	0015      	movs	r5, r2
//	volatile unsigned int i, j;
	uint8_t mode, delay;
#ifdef RAM10000
	uint8_t temp[4]={0,0,0,0};
#endif
	FillSendCMD(temp, cammond, flash_addr);
     dde:	000a      	movs	r2, r1
     de0:	0001      	movs	r1, r0
     de2:	0020      	movs	r0, r4
{
//	int addr;
//	volatile unsigned int i, j;
	uint8_t mode, delay;
#ifdef RAM10000
	uint8_t temp[4]={0,0,0,0};
     de4:	9303      	str	r3, [sp, #12]
#endif
	FillSendCMD(temp, cammond, flash_addr);
     de6:	f7ff ffed 	bl	dc4 <FillSendCMD>
	mode = HREAD(CORE_QSPI_CTRL);
     dea:	4a1b      	ldr	r2, [pc, #108]	; (e58 <ReadFlashDSPI+0x86>)
		HWRITE(CORE_QSPI_CTRL  , 0x45);//mode&0xb8 |0x05
#else
		HWRITE(CORE_QSPI_CTRL  , 0x05);//mode&0xb8 |0x05
#endif
		HWRITE(CORE_QSPI_DELAY, 8);
		HWRITEW(CORE_QSPI_TXADDR , (int)temp);
     dec:	b2e0      	uxtb	r0, r4
	uint8_t mode, delay;
#ifdef RAM10000
	uint8_t temp[4]={0,0,0,0};
#endif
	FillSendCMD(temp, cammond, flash_addr);
	mode = HREAD(CORE_QSPI_CTRL);
     dee:	7813      	ldrb	r3, [r2, #0]
		HWRITE(CORE_QSPI_CTRL  , 0x45);//mode&0xb8 |0x05
#else
		HWRITE(CORE_QSPI_CTRL  , 0x05);//mode&0xb8 |0x05
#endif
		HWRITE(CORE_QSPI_DELAY, 8);
		HWRITEW(CORE_QSPI_TXADDR , (int)temp);
     df0:	4684      	mov	ip, r0
	uint8_t mode, delay;
#ifdef RAM10000
	uint8_t temp[4]={0,0,0,0};
#endif
	FillSendCMD(temp, cammond, flash_addr);
	mode = HREAD(CORE_QSPI_CTRL);
     df2:	b2db      	uxtb	r3, r3
     df4:	9300      	str	r3, [sp, #0]
	delay = HREAD(CORE_QSPI_DELAY);
     df6:	4b19      	ldr	r3, [pc, #100]	; (e5c <ReadFlashDSPI+0x8a>)
		HWRITE(CORE_QSPI_CTRL  , 0x45);//mode&0xb8 |0x05
#else
		HWRITE(CORE_QSPI_CTRL  , 0x05);//mode&0xb8 |0x05
#endif
		HWRITE(CORE_QSPI_DELAY, 8);
		HWRITEW(CORE_QSPI_TXADDR , (int)temp);
     df8:	4667      	mov	r7, ip
#ifdef RAM10000
	uint8_t temp[4]={0,0,0,0};
#endif
	FillSendCMD(temp, cammond, flash_addr);
	mode = HREAD(CORE_QSPI_CTRL);
	delay = HREAD(CORE_QSPI_DELAY);
     dfa:	7819      	ldrb	r1, [r3, #0]
		HWRITE(CORE_QSPI_CTRL  , 0x45);//mode&0xb8 |0x05
#else
		HWRITE(CORE_QSPI_CTRL  , 0x05);//mode&0xb8 |0x05
#endif
		HWRITE(CORE_QSPI_DELAY, 8);
		HWRITEW(CORE_QSPI_TXADDR , (int)temp);
     dfc:	4818      	ldr	r0, [pc, #96]	; (e60 <ReadFlashDSPI+0x8e>)
#ifdef RAM10000
	uint8_t temp[4]={0,0,0,0};
#endif
	FillSendCMD(temp, cammond, flash_addr);
	mode = HREAD(CORE_QSPI_CTRL);
	delay = HREAD(CORE_QSPI_DELAY);
     dfe:	b2c9      	uxtb	r1, r1
     e00:	9101      	str	r1, [sp, #4]
#ifdef RAM10000
		HWRITE(CORE_QSPI_CTRL  , 0x45);//mode&0xb8 |0x05
     e02:	2145      	movs	r1, #69	; 0x45
     e04:	7011      	strb	r1, [r2, #0]
#else
		HWRITE(CORE_QSPI_CTRL  , 0x05);//mode&0xb8 |0x05
#endif
		HWRITE(CORE_QSPI_DELAY, 8);
     e06:	393d      	subs	r1, #61	; 0x3d
		HWRITEW(CORE_QSPI_TXADDR , (int)temp);
     e08:	410c      	asrs	r4, r1
#ifdef RAM10000
		HWRITE(CORE_QSPI_CTRL  , 0x45);//mode&0xb8 |0x05
#else
		HWRITE(CORE_QSPI_CTRL  , 0x05);//mode&0xb8 |0x05
#endif
		HWRITE(CORE_QSPI_DELAY, 8);
     e0a:	7019      	strb	r1, [r3, #0]
		HWRITEW(CORE_QSPI_TXADDR , (int)temp);
     e0c:	7007      	strb	r7, [r0, #0]
     e0e:	4815      	ldr	r0, [pc, #84]	; (e64 <ReadFlashDSPI+0x92>)
     e10:	b2e4      	uxtb	r4, r4
     e12:	7004      	strb	r4, [r0, #0]
		HWRITEW(CORE_QSPI_TXLEN , 4);
     e14:	2404      	movs	r4, #4
     e16:	4814      	ldr	r0, [pc, #80]	; (e68 <ReadFlashDSPI+0x96>)
     e18:	7004      	strb	r4, [r0, #0]
     e1a:	2400      	movs	r4, #0
     e1c:	4813      	ldr	r0, [pc, #76]	; (e6c <ReadFlashDSPI+0x9a>)
     e1e:	7004      	strb	r4, [r0, #0]
		HWRITEW(CORE_QSPI_RXADDR , (int)rxbuf);
     e20:	b2f4      	uxtb	r4, r6
     e22:	410e      	asrs	r6, r1
     e24:	4812      	ldr	r0, [pc, #72]	; (e70 <ReadFlashDSPI+0x9e>)
     e26:	b2f6      	uxtb	r6, r6
     e28:	7004      	strb	r4, [r0, #0]
		HWRITEW(CORE_QSPI_RXLEN , rxlen);
     e2a:	b2ec      	uxtb	r4, r5
     e2c:	410d      	asrs	r5, r1
		HWRITE(CORE_QSPI_CTRL  , 0x05);//mode&0xb8 |0x05
#endif
		HWRITE(CORE_QSPI_DELAY, 8);
		HWRITEW(CORE_QSPI_TXADDR , (int)temp);
		HWRITEW(CORE_QSPI_TXLEN , 4);
		HWRITEW(CORE_QSPI_RXADDR , (int)rxbuf);
     e2e:	4811      	ldr	r0, [pc, #68]	; (e74 <ReadFlashDSPI+0xa2>)
		HWRITEW(CORE_QSPI_RXLEN , rxlen);
     e30:	b2ed      	uxtb	r5, r5
		HWRITE(CORE_QSPI_CTRL  , 0x05);//mode&0xb8 |0x05
#endif
		HWRITE(CORE_QSPI_DELAY, 8);
		HWRITEW(CORE_QSPI_TXADDR , (int)temp);
		HWRITEW(CORE_QSPI_TXLEN , 4);
		HWRITEW(CORE_QSPI_RXADDR , (int)rxbuf);
     e32:	7006      	strb	r6, [r0, #0]
		HWRITEW(CORE_QSPI_RXLEN , rxlen);
     e34:	4810      	ldr	r0, [pc, #64]	; (e78 <ReadFlashDSPI+0xa6>)
     e36:	7004      	strb	r4, [r0, #0]
     e38:	4810      	ldr	r0, [pc, #64]	; (e7c <ReadFlashDSPI+0xaa>)
		
		HWRITE(CORE_DMA_START , 8);
		//for(j = 0;j < 20;j++);
		while(!(HREAD(CORE_DMA_STATUS) & 8) );
     e3a:	4c11      	ldr	r4, [pc, #68]	; (e80 <ReadFlashDSPI+0xae>)
#endif
		HWRITE(CORE_QSPI_DELAY, 8);
		HWRITEW(CORE_QSPI_TXADDR , (int)temp);
		HWRITEW(CORE_QSPI_TXLEN , 4);
		HWRITEW(CORE_QSPI_RXADDR , (int)rxbuf);
		HWRITEW(CORE_QSPI_RXLEN , rxlen);
     e3c:	7005      	strb	r5, [r0, #0]
		
		HWRITE(CORE_DMA_START , 8);
     e3e:	4811      	ldr	r0, [pc, #68]	; (e84 <ReadFlashDSPI+0xb2>)
     e40:	7001      	strb	r1, [r0, #0]
		//for(j = 0;j < 20;j++);
		while(!(HREAD(CORE_DMA_STATUS) & 8) );
     e42:	7820      	ldrb	r0, [r4, #0]
     e44:	4208      	tst	r0, r1
     e46:	d0fc      	beq.n	e42 <ReadFlashDSPI+0x70>
		HWRITE(CORE_QSPI_CTRL, mode);
     e48:	4669      	mov	r1, sp
     e4a:	7809      	ldrb	r1, [r1, #0]
     e4c:	7011      	strb	r1, [r2, #0]
		HWRITE(CORE_QSPI_DELAY , delay);
     e4e:	466a      	mov	r2, sp
     e50:	7912      	ldrb	r2, [r2, #4]
     e52:	701a      	strb	r2, [r3, #0]
}
     e54:	b005      	add	sp, #20
     e56:	bdf0      	pop	{r4, r5, r6, r7, pc}
     e58:	100080a0 	.word	0x100080a0
     e5c:	100080a1 	.word	0x100080a1
     e60:	100080a4 	.word	0x100080a4
     e64:	100080a5 	.word	0x100080a5
     e68:	100080a2 	.word	0x100080a2
     e6c:	100080a3 	.word	0x100080a3
     e70:	100080a6 	.word	0x100080a6
     e74:	100080a7 	.word	0x100080a7
     e78:	100080a8 	.word	0x100080a8
     e7c:	100080a9 	.word	0x100080a9
     e80:	10008330 	.word	0x10008330
     e84:	1000800a 	.word	0x1000800a
     e88:	46c0      	nop			; (mov r8, r8)
     e8a:	46c0      	nop			; (mov r8, r8)
     e8c:	46c0      	nop			; (mov r8, r8)
     e8e:	46c0      	nop			; (mov r8, r8)
     e90:	46c0      	nop			; (mov r8, r8)
     e92:	46c0      	nop			; (mov r8, r8)
     e94:	46c0      	nop			; (mov r8, r8)
     e96:	46c0      	nop			; (mov r8, r8)
     e98:	46c0      	nop			; (mov r8, r8)
     e9a:	46c0      	nop			; (mov r8, r8)
     e9c:	46c0      	nop			; (mov r8, r8)
     e9e:	46c0      	nop			; (mov r8, r8)

00000ea0 <QSPI_ReadFlashData>:

void __attribute__((noinline,aligned(32))) QSPI_ReadFlashData(int flash_addr, int len, uint8_t *rxbuf)
{
     ea0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
     ea2:	0007      	movs	r7, r0
     ea4:	000d      	movs	r5, r1
     ea6:	0016      	movs	r6, r2
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
     ea8:	b672      	cpsid	i
	OS_ENTER_CRITICAL();
	int i=0,j=0;

	for(i = len,j=0;i>0;i = i -0x40,j = j+0x40){
     eaa:	0014      	movs	r4, r2
     eac:	2d00      	cmp	r5, #0
     eae:	dd10      	ble.n	ed2 <QSPI_ReadFlashData+0x32>
     eb0:	1bb9      	subs	r1, r7, r6
		if(i>0x40)
			ReadFlashDSPI(0x3b,flash_addr+j,0x40,rxbuf+j);
     eb2:	1909      	adds	r1, r1, r4
     eb4:	0023      	movs	r3, r4
{
	OS_ENTER_CRITICAL();
	int i=0,j=0;

	for(i = len,j=0;i>0;i = i -0x40,j = j+0x40){
		if(i>0x40)
     eb6:	2d40      	cmp	r5, #64	; 0x40
     eb8:	dd04      	ble.n	ec4 <QSPI_ReadFlashData+0x24>
			ReadFlashDSPI(0x3b,flash_addr+j,0x40,rxbuf+j);
     eba:	2240      	movs	r2, #64	; 0x40
     ebc:	203b      	movs	r0, #59	; 0x3b
     ebe:	f7ff ff88 	bl	dd2 <ReadFlashDSPI>
     ec2:	e003      	b.n	ecc <QSPI_ReadFlashData+0x2c>
		else
			ReadFlashDSPI(0x3b,flash_addr+j,i,rxbuf+j);	
     ec4:	002a      	movs	r2, r5
     ec6:	203b      	movs	r0, #59	; 0x3b
     ec8:	f7ff ff83 	bl	dd2 <ReadFlashDSPI>
void __attribute__((noinline,aligned(32))) QSPI_ReadFlashData(int flash_addr, int len, uint8_t *rxbuf)
{
	OS_ENTER_CRITICAL();
	int i=0,j=0;

	for(i = len,j=0;i>0;i = i -0x40,j = j+0x40){
     ecc:	3d40      	subs	r5, #64	; 0x40
     ece:	3440      	adds	r4, #64	; 0x40
     ed0:	e7ec      	b.n	eac <QSPI_ReadFlashData+0xc>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
     ed2:	b662      	cpsie	i
			ReadFlashDSPI(0x3b,flash_addr+j,0x40,rxbuf+j);
		else
			ReadFlashDSPI(0x3b,flash_addr+j,i,rxbuf+j);	
	}
	OS_EXIT_CRITICAL();
}
     ed4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
     ed6:	46c0      	nop			; (mov r8, r8)
     ed8:	46c0      	nop			; (mov r8, r8)
     eda:	46c0      	nop			; (mov r8, r8)
     edc:	46c0      	nop			; (mov r8, r8)
     ede:	46c0      	nop			; (mov r8, r8)

00000ee0 <ReadFlashSPI>:

void __attribute__((noinline,aligned(32))) ReadFlashSPI(uint8_t *txdata,int txlen,uint8_t *rxbuf,int rxlen)
{
     ee0:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
//	volatile int i, j;
	uint8_t mode, delay;
		mode = HREAD(CORE_QSPI_CTRL);
     ee2:	4d1c      	ldr	r5, [pc, #112]	; (f54 <ReadFlashSPI+0x74>)
     ee4:	782e      	ldrb	r6, [r5, #0]
     ee6:	b2f4      	uxtb	r4, r6
     ee8:	9400      	str	r4, [sp, #0]
		delay = HREAD(CORE_QSPI_DELAY);
     eea:	4c1b      	ldr	r4, [pc, #108]	; (f58 <ReadFlashSPI+0x78>)
     eec:	7827      	ldrb	r7, [r4, #0]
     eee:	b2ff      	uxtb	r7, r7
     ef0:	9701      	str	r7, [sp, #4]
#ifdef RAM10000
		HWRITE(CORE_QSPI_CTRL , 0x44);// 0x40  mode&0xb8 |0x00
     ef2:	2744      	movs	r7, #68	; 0x44
     ef4:	702f      	strb	r7, [r5, #0]
#else
		HWRITE(CORE_QSPI_CTRL , 0x04);// 0x40  mode&0xb8 |0x00
#endif
		HWRITE(CORE_QSPI_DELAY , 0x0);
     ef6:	2700      	movs	r7, #0
     ef8:	7027      	strb	r7, [r4, #0]
		HWRITEW(CORE_QSPI_TXADDR ,(int)txdata );
     efa:	b2c7      	uxtb	r7, r0
     efc:	46bc      	mov	ip, r7
     efe:	4666      	mov	r6, ip
     f00:	4f16      	ldr	r7, [pc, #88]	; (f5c <ReadFlashSPI+0x7c>)
     f02:	1200      	asrs	r0, r0, #8
     f04:	703e      	strb	r6, [r7, #0]
     f06:	4f16      	ldr	r7, [pc, #88]	; (f60 <ReadFlashSPI+0x80>)
     f08:	b2c0      	uxtb	r0, r0
     f0a:	7038      	strb	r0, [r7, #0]
		HWRITEW(CORE_QSPI_TXLEN , txlen);
     f0c:	4815      	ldr	r0, [pc, #84]	; (f64 <ReadFlashSPI+0x84>)
     f0e:	b2cf      	uxtb	r7, r1
     f10:	7007      	strb	r7, [r0, #0]
     f12:	1209      	asrs	r1, r1, #8
     f14:	4814      	ldr	r0, [pc, #80]	; (f68 <ReadFlashSPI+0x88>)
     f16:	b2c9      	uxtb	r1, r1
     f18:	7001      	strb	r1, [r0, #0]
		HWRITEW(CORE_QSPI_RXADDR , (int)rxbuf);
     f1a:	4914      	ldr	r1, [pc, #80]	; (f6c <ReadFlashSPI+0x8c>)
     f1c:	b2d0      	uxtb	r0, r2
     f1e:	7008      	strb	r0, [r1, #0]
     f20:	1212      	asrs	r2, r2, #8
     f22:	4913      	ldr	r1, [pc, #76]	; (f70 <ReadFlashSPI+0x90>)
     f24:	b2d2      	uxtb	r2, r2
     f26:	700a      	strb	r2, [r1, #0]
		HWRITEW(CORE_QSPI_RXLEN , rxlen);
     f28:	4a12      	ldr	r2, [pc, #72]	; (f74 <ReadFlashSPI+0x94>)
     f2a:	b2d9      	uxtb	r1, r3
     f2c:	7011      	strb	r1, [r2, #0]
     f2e:	121b      	asrs	r3, r3, #8
     f30:	4a11      	ldr	r2, [pc, #68]	; (f78 <ReadFlashSPI+0x98>)
     f32:	b2db      	uxtb	r3, r3
     f34:	7013      	strb	r3, [r2, #0]
		HWRITE(CORE_DMA_START , 8);
     f36:	2308      	movs	r3, #8
     f38:	4a10      	ldr	r2, [pc, #64]	; (f7c <ReadFlashSPI+0x9c>)
		//for(j = 0;j < 20;j++);
		while(!(HREAD(CORE_DMA_STATUS) & 8) );
     f3a:	4911      	ldr	r1, [pc, #68]	; (f80 <ReadFlashSPI+0xa0>)
		HWRITE(CORE_QSPI_DELAY , 0x0);
		HWRITEW(CORE_QSPI_TXADDR ,(int)txdata );
		HWRITEW(CORE_QSPI_TXLEN , txlen);
		HWRITEW(CORE_QSPI_RXADDR , (int)rxbuf);
		HWRITEW(CORE_QSPI_RXLEN , rxlen);
		HWRITE(CORE_DMA_START , 8);
     f3c:	7013      	strb	r3, [r2, #0]
		//for(j = 0;j < 20;j++);
		while(!(HREAD(CORE_DMA_STATUS) & 8) );
     f3e:	780a      	ldrb	r2, [r1, #0]
     f40:	421a      	tst	r2, r3
     f42:	d0fc      	beq.n	f3e <ReadFlashSPI+0x5e>
		HWRITE(CORE_QSPI_CTRL , mode);
     f44:	466b      	mov	r3, sp
     f46:	781b      	ldrb	r3, [r3, #0]
     f48:	702b      	strb	r3, [r5, #0]
		HWRITE(CORE_QSPI_DELAY , delay);
     f4a:	466b      	mov	r3, sp
     f4c:	791b      	ldrb	r3, [r3, #4]
     f4e:	7023      	strb	r3, [r4, #0]
}
     f50:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
     f52:	46c0      	nop			; (mov r8, r8)
     f54:	100080a0 	.word	0x100080a0
     f58:	100080a1 	.word	0x100080a1
     f5c:	100080a4 	.word	0x100080a4
     f60:	100080a5 	.word	0x100080a5
     f64:	100080a2 	.word	0x100080a2
     f68:	100080a3 	.word	0x100080a3
     f6c:	100080a6 	.word	0x100080a6
     f70:	100080a7 	.word	0x100080a7
     f74:	100080a8 	.word	0x100080a8
     f78:	100080a9 	.word	0x100080a9
     f7c:	1000800a 	.word	0x1000800a
     f80:	10008330 	.word	0x10008330
     f84:	46c0      	nop			; (mov r8, r8)
     f86:	46c0      	nop			; (mov r8, r8)
     f88:	46c0      	nop			; (mov r8, r8)
     f8a:	46c0      	nop			; (mov r8, r8)
     f8c:	46c0      	nop			; (mov r8, r8)
     f8e:	46c0      	nop			; (mov r8, r8)
     f90:	46c0      	nop			; (mov r8, r8)
     f92:	46c0      	nop			; (mov r8, r8)
     f94:	46c0      	nop			; (mov r8, r8)
     f96:	46c0      	nop			; (mov r8, r8)
     f98:	46c0      	nop			; (mov r8, r8)
     f9a:	46c0      	nop			; (mov r8, r8)
     f9c:	46c0      	nop			; (mov r8, r8)
     f9e:	46c0      	nop			; (mov r8, r8)

00000fa0 <QSPI_ReadFlashRDID>:
void __attribute__((noinline,aligned(32))) QSPI_ReadFlashRDID(uint8_t *rxbuf)
{
#ifdef RAM10000
	uint8_t temp[1]={0};
#endif
	temp[0] = 0x9f;
     fa0:	239f      	movs	r3, #159	; 0x9f
		HWRITE(CORE_QSPI_CTRL , mode);
		HWRITE(CORE_QSPI_DELAY , delay);
}

void __attribute__((noinline,aligned(32))) QSPI_ReadFlashRDID(uint8_t *rxbuf)
{
     fa2:	b507      	push	{r0, r1, r2, lr}
     fa4:	0002      	movs	r2, r0
#ifdef RAM10000
	uint8_t temp[1]={0};
#endif
	temp[0] = 0x9f;
     fa6:	a801      	add	r0, sp, #4
     fa8:	7003      	strb	r3, [r0, #0]
	ReadFlashSPI(temp,1,rxbuf,3);
     faa:	2101      	movs	r1, #1
     fac:	3b9c      	subs	r3, #156	; 0x9c
     fae:	f7ff ff97 	bl	ee0 <ReadFlashSPI>
}
     fb2:	bd07      	pop	{r0, r1, r2, pc}
     fb4:	46c0      	nop			; (mov r8, r8)
     fb6:	46c0      	nop			; (mov r8, r8)
     fb8:	46c0      	nop			; (mov r8, r8)
     fba:	46c0      	nop			; (mov r8, r8)
     fbc:	46c0      	nop			; (mov r8, r8)
     fbe:	46c0      	nop			; (mov r8, r8)

00000fc0 <QSPI_ReadFlashReg>:
void __attribute__((noinline,aligned(32))) QSPI_ReadFlashReg(uint8_t *rxbuf)
{
#ifdef RAM10000
	uint8_t temp2[1]={0};
#endif
	temp2[0] = 0x05;
     fc0:	2305      	movs	r3, #5
	temp[0] = 0x9f;
	ReadFlashSPI(temp,1,rxbuf,3);
}

void __attribute__((noinline,aligned(32))) QSPI_ReadFlashReg(uint8_t *rxbuf)
{
     fc2:	b537      	push	{r0, r1, r2, r4, r5, lr}
#ifdef RAM10000
	uint8_t temp2[1]={0};
#endif
	temp2[0] = 0x05;
     fc4:	ac01      	add	r4, sp, #4
     fc6:	7023      	strb	r3, [r4, #0]
	ReadFlashSPI(temp2,1,rxbuf,1); //s7-s0
     fc8:	3b04      	subs	r3, #4
	temp[0] = 0x9f;
	ReadFlashSPI(temp,1,rxbuf,3);
}

void __attribute__((noinline,aligned(32))) QSPI_ReadFlashReg(uint8_t *rxbuf)
{
     fca:	0005      	movs	r5, r0
#ifdef RAM10000
	uint8_t temp2[1]={0};
#endif
	temp2[0] = 0x05;
	ReadFlashSPI(temp2,1,rxbuf,1); //s7-s0
     fcc:	0002      	movs	r2, r0
     fce:	0019      	movs	r1, r3
     fd0:	0020      	movs	r0, r4
     fd2:	f7ff ff85 	bl	ee0 <ReadFlashSPI>
	temp2[0] = 0x35;
     fd6:	2335      	movs	r3, #53	; 0x35
     fd8:	7023      	strb	r3, [r4, #0]
	ReadFlashSPI(temp2,1,rxbuf+1,1);	//s15-s8
     fda:	3b34      	subs	r3, #52	; 0x34
     fdc:	1c6a      	adds	r2, r5, #1
     fde:	0019      	movs	r1, r3
     fe0:	0020      	movs	r0, r4
     fe2:	f7ff ff7d 	bl	ee0 <ReadFlashSPI>
}
     fe6:	bd37      	pop	{r0, r1, r2, r4, r5, pc}
     fe8:	46c0      	nop			; (mov r8, r8)
     fea:	46c0      	nop			; (mov r8, r8)
     fec:	46c0      	nop			; (mov r8, r8)
     fee:	46c0      	nop			; (mov r8, r8)
     ff0:	46c0      	nop			; (mov r8, r8)
     ff2:	46c0      	nop			; (mov r8, r8)
     ff4:	46c0      	nop			; (mov r8, r8)
     ff6:	46c0      	nop			; (mov r8, r8)
     ff8:	46c0      	nop			; (mov r8, r8)
     ffa:	46c0      	nop			; (mov r8, r8)
     ffc:	46c0      	nop			; (mov r8, r8)
     ffe:	46c0      	nop			; (mov r8, r8)

00001000 <QSPI_ReadFlashREMS>:

void __attribute__((noinline,aligned(32))) QSPI_ReadFlashREMS(uint8_t *rxbuf)
{
#ifdef RAM10000
	uint8_t temp[4]={0,0,0,0};
    1000:	2300      	movs	r3, #0
	temp2[0] = 0x35;
	ReadFlashSPI(temp2,1,rxbuf+1,1);	//s15-s8
}

void __attribute__((noinline,aligned(32))) QSPI_ReadFlashREMS(uint8_t *rxbuf)
{
    1002:	b507      	push	{r0, r1, r2, lr}
    1004:	0002      	movs	r2, r0
#ifdef RAM10000
	uint8_t temp[4]={0,0,0,0};
    1006:	9301      	str	r3, [sp, #4]
    1008:	a801      	add	r0, sp, #4
#endif
	temp[0] = 0x90;
    100a:	3390      	adds	r3, #144	; 0x90
    100c:	7003      	strb	r3, [r0, #0]
	ReadFlashSPI(temp,4,rxbuf,2); //s7-s0
    100e:	2104      	movs	r1, #4
    1010:	3b8e      	subs	r3, #142	; 0x8e
    1012:	f7ff ff65 	bl	ee0 <ReadFlashSPI>
}
    1016:	bd07      	pop	{r0, r1, r2, pc}
    1018:	46c0      	nop			; (mov r8, r8)
    101a:	46c0      	nop			; (mov r8, r8)
    101c:	46c0      	nop			; (mov r8, r8)
    101e:	46c0      	nop			; (mov r8, r8)

00001020 <QSPI_ReadFlashUID>:

void __attribute__((noinline,aligned(32))) QSPI_ReadFlashUID(uint8_t *rxbuf)
{
    1020:	b537      	push	{r0, r1, r2, r4, r5, lr}
#ifdef RAM10000
	uint8_t temp[5]={0,0,0,0,0};
    1022:	2405      	movs	r4, #5
	temp[0] = 0x90;
	ReadFlashSPI(temp,4,rxbuf,2); //s7-s0
}

void __attribute__((noinline,aligned(32))) QSPI_ReadFlashUID(uint8_t *rxbuf)
{
    1024:	0005      	movs	r5, r0
#ifdef RAM10000
	uint8_t temp[5]={0,0,0,0,0};
    1026:	0022      	movs	r2, r4
    1028:	2100      	movs	r1, #0
    102a:	4668      	mov	r0, sp
    102c:	f014 fd0e 	bl	15a4c <memset>
#endif
	temp[0] = 0x4b;
    1030:	466a      	mov	r2, sp
    1032:	234b      	movs	r3, #75	; 0x4b
	ReadFlashSPI(temp,5,rxbuf,8); //s7-s0
    1034:	0021      	movs	r1, r4
void __attribute__((noinline,aligned(32))) QSPI_ReadFlashUID(uint8_t *rxbuf)
{
#ifdef RAM10000
	uint8_t temp[5]={0,0,0,0,0};
#endif
	temp[0] = 0x4b;
    1036:	7013      	strb	r3, [r2, #0]
	ReadFlashSPI(temp,5,rxbuf,8); //s7-s0
    1038:	4668      	mov	r0, sp
    103a:	002a      	movs	r2, r5
    103c:	3b43      	subs	r3, #67	; 0x43
    103e:	f7ff ff4f 	bl	ee0 <ReadFlashSPI>
}
    1042:	bd37      	pop	{r0, r1, r2, r4, r5, pc}
    1044:	46c0      	nop			; (mov r8, r8)
    1046:	46c0      	nop			; (mov r8, r8)
    1048:	46c0      	nop			; (mov r8, r8)
    104a:	46c0      	nop			; (mov r8, r8)
    104c:	46c0      	nop			; (mov r8, r8)
    104e:	46c0      	nop			; (mov r8, r8)
    1050:	46c0      	nop			; (mov r8, r8)
    1052:	46c0      	nop			; (mov r8, r8)
    1054:	46c0      	nop			; (mov r8, r8)
    1056:	46c0      	nop			; (mov r8, r8)
    1058:	46c0      	nop			; (mov r8, r8)
    105a:	46c0      	nop			; (mov r8, r8)
    105c:	46c0      	nop			; (mov r8, r8)
    105e:	46c0      	nop			; (mov r8, r8)

00001060 <WaitFlashFinish>:

void  WaitFlashFinish()
{
//	uint8_t j;
#ifdef RAM10000
	uint8_t readreg[2] =  {0,0};
    1060:	2300      	movs	r3, #0
	temp[0] = 0x4b;
	ReadFlashSPI(temp,5,rxbuf,8); //s7-s0
}

void  WaitFlashFinish()
{
    1062:	b537      	push	{r0, r1, r2, r4, r5, lr}
	uint8_t readreg[2] =  {0,0};
#endif
	do{
		//for(j = 0;j < 40;j++);
		QSPI_ReadFlashReg(readreg);
	}	while((readreg[0]&0x01));
    1064:	2501      	movs	r5, #1

void  WaitFlashFinish()
{
//	uint8_t j;
#ifdef RAM10000
	uint8_t readreg[2] =  {0,0};
    1066:	ac01      	add	r4, sp, #4
    1068:	7023      	strb	r3, [r4, #0]
    106a:	7063      	strb	r3, [r4, #1]
#endif
	do{
		//for(j = 0;j < 40;j++);
		QSPI_ReadFlashReg(readreg);
    106c:	0020      	movs	r0, r4
    106e:	f7ff ffa7 	bl	fc0 <QSPI_ReadFlashReg>
	}	while((readreg[0]&0x01));
    1072:	7823      	ldrb	r3, [r4, #0]
    1074:	422b      	tst	r3, r5
    1076:	d1f9      	bne.n	106c <WaitFlashFinish+0xc>
}
    1078:	bd37      	pop	{r0, r1, r2, r4, r5, pc}

0000107a <WriteFlashData>:

void WriteFlashData( int txlen, uint8_t *txdata)
{
    107a:	b5f0      	push	{r4, r5, r6, r7, lr}
    107c:	000c      	movs	r4, r1
    107e:	b085      	sub	sp, #20
    1080:	0005      	movs	r5, r0
	volatile int j;
	uint8_t mode, delay;
	FlashWriteEnable();
    1082:	f000 f96d 	bl	1360 <FlashWriteEnable>
	mode = HREAD(CORE_QSPI_CTRL);
    1086:	4a1c      	ldr	r2, [pc, #112]	; (10f8 <WriteFlashData+0x7e>)
	delay = HREAD(CORE_QSPI_DELAY);
    1088:	4b1c      	ldr	r3, [pc, #112]	; (10fc <WriteFlashData+0x82>)
void WriteFlashData( int txlen, uint8_t *txdata)
{
	volatile int j;
	uint8_t mode, delay;
	FlashWriteEnable();
	mode = HREAD(CORE_QSPI_CTRL);
    108a:	7816      	ldrb	r6, [r2, #0]
	delay = HREAD(CORE_QSPI_DELAY);
    108c:	7818      	ldrb	r0, [r3, #0]
		HWRITE(CORE_QSPI_CTRL ,0x44);//mode&0xf8 |0x40
#else
		HWRITE(CORE_QSPI_CTRL ,0x04);//mode&0xf8 |0x40
#endif
		HWRITE(CORE_QSPI_DELAY , 0x0);
		HWRITEW(CORE_QSPI_TXADDR , (int)txdata);
    108e:	b2e7      	uxtb	r7, r4
{
	volatile int j;
	uint8_t mode, delay;
	FlashWriteEnable();
	mode = HREAD(CORE_QSPI_CTRL);
	delay = HREAD(CORE_QSPI_DELAY);
    1090:	b2c1      	uxtb	r1, r0
    1092:	9101      	str	r1, [sp, #4]
		HWRITE(CORE_QSPI_CTRL ,0x44);//mode&0xf8 |0x40
#else
		HWRITE(CORE_QSPI_CTRL ,0x04);//mode&0xf8 |0x40
#endif
		HWRITE(CORE_QSPI_DELAY , 0x0);
		HWRITEW(CORE_QSPI_TXADDR , (int)txdata);
    1094:	46bc      	mov	ip, r7
	uint8_t mode, delay;
	FlashWriteEnable();
	mode = HREAD(CORE_QSPI_CTRL);
	delay = HREAD(CORE_QSPI_DELAY);
#ifdef RAM10000
		HWRITE(CORE_QSPI_CTRL ,0x44);//mode&0xf8 |0x40
    1096:	2144      	movs	r1, #68	; 0x44
#else
		HWRITE(CORE_QSPI_CTRL ,0x04);//mode&0xf8 |0x40
#endif
		HWRITE(CORE_QSPI_DELAY , 0x0);
		HWRITEW(CORE_QSPI_TXADDR , (int)txdata);
    1098:	4660      	mov	r0, ip
	uint8_t mode, delay;
	FlashWriteEnable();
	mode = HREAD(CORE_QSPI_CTRL);
	delay = HREAD(CORE_QSPI_DELAY);
#ifdef RAM10000
		HWRITE(CORE_QSPI_CTRL ,0x44);//mode&0xf8 |0x40
    109a:	7011      	strb	r1, [r2, #0]
#else
		HWRITE(CORE_QSPI_CTRL ,0x04);//mode&0xf8 |0x40
#endif
		HWRITE(CORE_QSPI_DELAY , 0x0);
    109c:	2100      	movs	r1, #0
		HWRITEW(CORE_QSPI_TXADDR , (int)txdata);
    109e:	4f18      	ldr	r7, [pc, #96]	; (1100 <WriteFlashData+0x86>)
#ifdef RAM10000
		HWRITE(CORE_QSPI_CTRL ,0x44);//mode&0xf8 |0x40
#else
		HWRITE(CORE_QSPI_CTRL ,0x04);//mode&0xf8 |0x40
#endif
		HWRITE(CORE_QSPI_DELAY , 0x0);
    10a0:	7019      	strb	r1, [r3, #0]
		HWRITEW(CORE_QSPI_TXADDR , (int)txdata);
    10a2:	1224      	asrs	r4, r4, #8
    10a4:	7038      	strb	r0, [r7, #0]
    10a6:	4f17      	ldr	r7, [pc, #92]	; (1104 <WriteFlashData+0x8a>)
    10a8:	b2e4      	uxtb	r4, r4
    10aa:	703c      	strb	r4, [r7, #0]
		HWRITEW(CORE_QSPI_TXLEN , txlen );
    10ac:	4c16      	ldr	r4, [pc, #88]	; (1108 <WriteFlashData+0x8e>)
    10ae:	b2ef      	uxtb	r7, r5
    10b0:	7027      	strb	r7, [r4, #0]
    10b2:	122c      	asrs	r4, r5, #8
    10b4:	4f15      	ldr	r7, [pc, #84]	; (110c <WriteFlashData+0x92>)
    10b6:	b2e4      	uxtb	r4, r4
    10b8:	703c      	strb	r4, [r7, #0]
		HWRITEW(CORE_QSPI_RXLEN , 0);
		HWRITE(CORE_DMA_START , 8);
    10ba:	2708      	movs	r7, #8
		HWRITE(CORE_QSPI_CTRL ,0x04);//mode&0xf8 |0x40
#endif
		HWRITE(CORE_QSPI_DELAY , 0x0);
		HWRITEW(CORE_QSPI_TXADDR , (int)txdata);
		HWRITEW(CORE_QSPI_TXLEN , txlen );
		HWRITEW(CORE_QSPI_RXLEN , 0);
    10bc:	4c14      	ldr	r4, [pc, #80]	; (1110 <WriteFlashData+0x96>)
void WriteFlashData( int txlen, uint8_t *txdata)
{
	volatile int j;
	uint8_t mode, delay;
	FlashWriteEnable();
	mode = HREAD(CORE_QSPI_CTRL);
    10be:	b2f6      	uxtb	r6, r6
		HWRITE(CORE_QSPI_CTRL ,0x04);//mode&0xf8 |0x40
#endif
		HWRITE(CORE_QSPI_DELAY , 0x0);
		HWRITEW(CORE_QSPI_TXADDR , (int)txdata);
		HWRITEW(CORE_QSPI_TXLEN , txlen );
		HWRITEW(CORE_QSPI_RXLEN , 0);
    10c0:	7021      	strb	r1, [r4, #0]
    10c2:	4c14      	ldr	r4, [pc, #80]	; (1114 <WriteFlashData+0x9a>)
    10c4:	7021      	strb	r1, [r4, #0]
		HWRITE(CORE_DMA_START , 8);
    10c6:	4c14      	ldr	r4, [pc, #80]	; (1118 <WriteFlashData+0x9e>)
    10c8:	7027      	strb	r7, [r4, #0]
		for(j = 0;j <(txlen*10);j++);
    10ca:	9103      	str	r1, [sp, #12]
    10cc:	310a      	adds	r1, #10
    10ce:	434d      	muls	r5, r1
    10d0:	9903      	ldr	r1, [sp, #12]
    10d2:	428d      	cmp	r5, r1
    10d4:	dd03      	ble.n	10de <WriteFlashData+0x64>
    10d6:	9903      	ldr	r1, [sp, #12]
    10d8:	3101      	adds	r1, #1
    10da:	9103      	str	r1, [sp, #12]
    10dc:	e7f8      	b.n	10d0 <WriteFlashData+0x56>
		while(!(HREAD(CORE_DMA_STATUS) & 8) );
    10de:	2108      	movs	r1, #8
    10e0:	4d0e      	ldr	r5, [pc, #56]	; (111c <WriteFlashData+0xa2>)
    10e2:	782c      	ldrb	r4, [r5, #0]
    10e4:	420c      	tst	r4, r1
    10e6:	d0fc      	beq.n	10e2 <WriteFlashData+0x68>
		HWRITE(CORE_QSPI_CTRL , mode);
    10e8:	7016      	strb	r6, [r2, #0]
		HWRITE(CORE_QSPI_DELAY , delay);
    10ea:	466a      	mov	r2, sp
    10ec:	7912      	ldrb	r2, [r2, #4]
    10ee:	701a      	strb	r2, [r3, #0]
		WaitFlashFinish();
    10f0:	f7ff ffb6 	bl	1060 <WaitFlashFinish>
}
    10f4:	b005      	add	sp, #20
    10f6:	bdf0      	pop	{r4, r5, r6, r7, pc}
    10f8:	100080a0 	.word	0x100080a0
    10fc:	100080a1 	.word	0x100080a1
    1100:	100080a4 	.word	0x100080a4
    1104:	100080a5 	.word	0x100080a5
    1108:	100080a2 	.word	0x100080a2
    110c:	100080a3 	.word	0x100080a3
    1110:	100080a8 	.word	0x100080a8
    1114:	100080a9 	.word	0x100080a9
    1118:	1000800a 	.word	0x1000800a
    111c:	10008330 	.word	0x10008330

00001120 <QSPI_WriteFlashData>:

void  __attribute__((noinline,aligned(32))) QSPI_WriteFlashData(int flash_addr, int txlen, uint8_t *txdata)
{
    1120:	b5f0      	push	{r4, r5, r6, r7, lr}
    1122:	0006      	movs	r6, r0
    1124:	b089      	sub	sp, #36	; 0x24
    1126:	000d      	movs	r5, r1
    1128:	0014      	movs	r4, r2
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
    112a:	b672      	cpsid	i
	OS_ENTER_CRITICAL();
	int i=0,j=0,x=0, offset=0;
#ifdef RAM10000
	uint8_t temp[0x10+4]={0};	
    112c:	2214      	movs	r2, #20
    112e:	2100      	movs	r1, #0
    1130:	a803      	add	r0, sp, #12
    1132:	f014 fc8b 	bl	15a4c <memset>
    1136:	9400      	str	r4, [sp, #0]
#endif
	for(i = txlen,j=0;i>0;i = i -0x10,j = j+0x10){
    1138:	2d00      	cmp	r5, #0
    113a:	dc00      	bgt.n	113e <QSPI_WriteFlashData+0x1e>
    113c:	e09a      	b.n	1274 <QSPI_WriteFlashData+0x154>
    113e:	4c4f      	ldr	r4, [pc, #316]	; (127c <QSPI_WriteFlashData+0x15c>)
		
		if(i>0x10){
    1140:	2d10      	cmp	r5, #16
    1142:	dd49      	ble.n	11d8 <QSPI_WriteFlashData+0xb8>
    1144:	0033      	movs	r3, r6
    1146:	3310      	adds	r3, #16
    1148:	9301      	str	r3, [sp, #4]
			offset = (flash_addr+j +0x10)%0x100;
    114a:	401c      	ands	r4, r3
    114c:	d503      	bpl.n	1156 <QSPI_WriteFlashData+0x36>
    114e:	484c      	ldr	r0, [pc, #304]	; (1280 <QSPI_WriteFlashData+0x160>)
    1150:	3c01      	subs	r4, #1
    1152:	4304      	orrs	r4, r0
    1154:	3401      	adds	r4, #1
		 	if(offset < 0x10 && offset !=0)
		 	{
				FillSendCMD(temp, 0x02, flash_addr+j);
    1156:	0032      	movs	r2, r6
    1158:	2102      	movs	r1, #2
    115a:	a803      	add	r0, sp, #12
#endif
	for(i = txlen,j=0;i>0;i = i -0x10,j = j+0x10){
		
		if(i>0x10){
			offset = (flash_addr+j +0x10)%0x100;
		 	if(offset < 0x10 && offset !=0)
    115c:	2c0f      	cmp	r4, #15
    115e:	dc2b      	bgt.n	11b8 <QSPI_WriteFlashData+0x98>
    1160:	2c00      	cmp	r4, #0
    1162:	d029      	beq.n	11b8 <QSPI_WriteFlashData+0x98>
		 	{
				FillSendCMD(temp, 0x02, flash_addr+j);
    1164:	f7ff fe2e 	bl	dc4 <FillSendCMD>
				for(x = 0;x < 0x10-offset;x++)  
    1168:	2210      	movs	r2, #16
    116a:	2300      	movs	r3, #0
    116c:	1b12      	subs	r2, r2, r4
    116e:	4293      	cmp	r3, r2
    1170:	da06      	bge.n	1180 <QSPI_WriteFlashData+0x60>
					temp[x+4] = txdata[j+x];
    1172:	9800      	ldr	r0, [sp, #0]
    1174:	a903      	add	r1, sp, #12
    1176:	5cc0      	ldrb	r0, [r0, r3]
    1178:	18c9      	adds	r1, r1, r3
    117a:	7108      	strb	r0, [r1, #4]
		if(i>0x10){
			offset = (flash_addr+j +0x10)%0x100;
		 	if(offset < 0x10 && offset !=0)
		 	{
				FillSendCMD(temp, 0x02, flash_addr+j);
				for(x = 0;x < 0x10-offset;x++)  
    117c:	3301      	adds	r3, #1
    117e:	e7f6      	b.n	116e <QSPI_WriteFlashData+0x4e>
    1180:	43d7      	mvns	r7, r2
					temp[x+4] = txdata[j+x];
				WriteFlashData(0x10-offset +4,temp);
    1182:	2014      	movs	r0, #20
    1184:	a903      	add	r1, sp, #12
    1186:	1b00      	subs	r0, r0, r4
    1188:	17ff      	asrs	r7, r7, #31
    118a:	4017      	ands	r7, r2
    118c:	f7ff ff75 	bl	107a <WriteFlashData>
				
				FillSendCMD(temp, 0x02, flash_addr+j+0x10-offset);
    1190:	9b01      	ldr	r3, [sp, #4]
    1192:	2102      	movs	r1, #2
    1194:	1b1a      	subs	r2, r3, r4
    1196:	a803      	add	r0, sp, #12
    1198:	f7ff fe14 	bl	dc4 <FillSendCMD>
    119c:	a903      	add	r1, sp, #12
				for(;x < 0x10;x++)  
    119e:	2f10      	cmp	r7, #16
    11a0:	d006      	beq.n	11b0 <QSPI_WriteFlashData+0x90>
					temp[x+4-0x10 + offset] = txdata[j+x];
    11a2:	9a00      	ldr	r2, [sp, #0]
    11a4:	19e3      	adds	r3, r4, r7
    11a6:	5dd2      	ldrb	r2, [r2, r7]
    11a8:	3b0c      	subs	r3, #12
    11aa:	54ca      	strb	r2, [r1, r3]
				for(x = 0;x < 0x10-offset;x++)  
					temp[x+4] = txdata[j+x];
				WriteFlashData(0x10-offset +4,temp);
				
				FillSendCMD(temp, 0x02, flash_addr+j+0x10-offset);
				for(;x < 0x10;x++)  
    11ac:	3701      	adds	r7, #1
    11ae:	e7f6      	b.n	119e <QSPI_WriteFlashData+0x7e>
					temp[x+4-0x10 + offset] = txdata[j+x];
				WriteFlashData(offset+4,temp);
    11b0:	1d20      	adds	r0, r4, #4
    11b2:	f7ff ff62 	bl	107a <WriteFlashData>
    11b6:	e057      	b.n	1268 <QSPI_WriteFlashData+0x148>
		 	}else
		 		{	
				FillSendCMD(temp, 0x02, flash_addr+j);
    11b8:	f7ff fe04 	bl	dc4 <FillSendCMD>
				for(x = 0;x < 0x10;x++)  
    11bc:	2300      	movs	r3, #0
					temp[x+4] = txdata[j+x];
    11be:	9900      	ldr	r1, [sp, #0]
    11c0:	aa03      	add	r2, sp, #12
    11c2:	5cc9      	ldrb	r1, [r1, r3]
    11c4:	18d2      	adds	r2, r2, r3
					temp[x+4-0x10 + offset] = txdata[j+x];
				WriteFlashData(offset+4,temp);
		 	}else
		 		{	
				FillSendCMD(temp, 0x02, flash_addr+j);
				for(x = 0;x < 0x10;x++)  
    11c6:	3301      	adds	r3, #1
					temp[x+4] = txdata[j+x];
    11c8:	7111      	strb	r1, [r2, #4]
					temp[x+4-0x10 + offset] = txdata[j+x];
				WriteFlashData(offset+4,temp);
		 	}else
		 		{	
				FillSendCMD(temp, 0x02, flash_addr+j);
				for(x = 0;x < 0x10;x++)  
    11ca:	2b10      	cmp	r3, #16
    11cc:	d1f7      	bne.n	11be <QSPI_WriteFlashData+0x9e>
					temp[x+4] = txdata[j+x];
				WriteFlashData(0x10+4,temp);
    11ce:	a903      	add	r1, sp, #12
    11d0:	2014      	movs	r0, #20
    11d2:	f7ff ff52 	bl	107a <WriteFlashData>
    11d6:	e047      	b.n	1268 <QSPI_WriteFlashData+0x148>
				}
		}
		else
		{
			offset = (flash_addr+j +i)%0x100;
    11d8:	19ab      	adds	r3, r5, r6
    11da:	9301      	str	r3, [sp, #4]
    11dc:	401c      	ands	r4, r3
    11de:	d503      	bpl.n	11e8 <QSPI_WriteFlashData+0xc8>
    11e0:	4827      	ldr	r0, [pc, #156]	; (1280 <QSPI_WriteFlashData+0x160>)
    11e2:	3c01      	subs	r4, #1
    11e4:	4304      	orrs	r4, r0
    11e6:	3401      	adds	r4, #1
		 	if(offset <  i && offset != 0 )
		 	{
				FillSendCMD(temp, 0x02, flash_addr+j);
    11e8:	0032      	movs	r2, r6
    11ea:	2102      	movs	r1, #2
    11ec:	a803      	add	r0, sp, #12
				}
		}
		else
		{
			offset = (flash_addr+j +i)%0x100;
		 	if(offset <  i && offset != 0 )
    11ee:	42a5      	cmp	r5, r4
    11f0:	dd2b      	ble.n	124a <QSPI_WriteFlashData+0x12a>
    11f2:	2c00      	cmp	r4, #0
    11f4:	d029      	beq.n	124a <QSPI_WriteFlashData+0x12a>
		 	{
				FillSendCMD(temp, 0x02, flash_addr+j);
    11f6:	f7ff fde5 	bl	dc4 <FillSendCMD>
				for(x = 0;x <i- offset;x++)  
    11fa:	2300      	movs	r3, #0
    11fc:	1b28      	subs	r0, r5, r4
    11fe:	4283      	cmp	r3, r0
    1200:	da06      	bge.n	1210 <QSPI_WriteFlashData+0xf0>
					temp[x+4] = txdata[j+x];
    1202:	9900      	ldr	r1, [sp, #0]
    1204:	aa03      	add	r2, sp, #12
    1206:	5cc9      	ldrb	r1, [r1, r3]
    1208:	18d2      	adds	r2, r2, r3
    120a:	7111      	strb	r1, [r2, #4]
		{
			offset = (flash_addr+j +i)%0x100;
		 	if(offset <  i && offset != 0 )
		 	{
				FillSendCMD(temp, 0x02, flash_addr+j);
				for(x = 0;x <i- offset;x++)  
    120c:	3301      	adds	r3, #1
    120e:	e7f6      	b.n	11fe <QSPI_WriteFlashData+0xde>
    1210:	43c7      	mvns	r7, r0
    1212:	17ff      	asrs	r7, r7, #31
					temp[x+4] = txdata[j+x];
				WriteFlashData(i- offset+4,temp);
    1214:	a903      	add	r1, sp, #12
    1216:	4007      	ands	r7, r0
    1218:	3004      	adds	r0, #4
    121a:	f7ff ff2e 	bl	107a <WriteFlashData>
				
				FillSendCMD(temp, 0x02, flash_addr+j+i-offset);
    121e:	9b01      	ldr	r3, [sp, #4]
    1220:	2102      	movs	r1, #2
    1222:	1b1a      	subs	r2, r3, r4
    1224:	a803      	add	r0, sp, #12
    1226:	f7ff fdcd 	bl	dc4 <FillSendCMD>
    122a:	1b62      	subs	r2, r4, r5
				for(;x < i;x++)  
    122c:	42bd      	cmp	r5, r7
    122e:	dd07      	ble.n	1240 <QSPI_WriteFlashData+0x120>
					temp[x+4-i + offset] = txdata[j+x];
    1230:	19d3      	adds	r3, r2, r7
    1232:	a903      	add	r1, sp, #12
    1234:	18cb      	adds	r3, r1, r3
    1236:	9900      	ldr	r1, [sp, #0]
    1238:	5dc9      	ldrb	r1, [r1, r7]
				for(x = 0;x <i- offset;x++)  
					temp[x+4] = txdata[j+x];
				WriteFlashData(i- offset+4,temp);
				
				FillSendCMD(temp, 0x02, flash_addr+j+i-offset);
				for(;x < i;x++)  
    123a:	3701      	adds	r7, #1
					temp[x+4-i + offset] = txdata[j+x];
    123c:	7119      	strb	r1, [r3, #4]
    123e:	e7f5      	b.n	122c <QSPI_WriteFlashData+0x10c>
				WriteFlashData(offset+4,temp);
    1240:	1d20      	adds	r0, r4, #4
    1242:	a903      	add	r1, sp, #12
    1244:	f7ff ff19 	bl	107a <WriteFlashData>
    1248:	e00e      	b.n	1268 <QSPI_WriteFlashData+0x148>
		 	}else
			 	{
			 	FillSendCMD(temp, 0x02, flash_addr+j);
    124a:	f7ff fdbb 	bl	dc4 <FillSendCMD>
				for(x = 0;x < i;x++)  
    124e:	2300      	movs	r3, #0
					temp[x+4] = txdata[j+x];
    1250:	9900      	ldr	r1, [sp, #0]
    1252:	aa03      	add	r2, sp, #12
    1254:	5cc9      	ldrb	r1, [r1, r3]
    1256:	18d2      	adds	r2, r2, r3
					temp[x+4-i + offset] = txdata[j+x];
				WriteFlashData(offset+4,temp);
		 	}else
			 	{
			 	FillSendCMD(temp, 0x02, flash_addr+j);
				for(x = 0;x < i;x++)  
    1258:	3301      	adds	r3, #1
					temp[x+4] = txdata[j+x];
    125a:	7111      	strb	r1, [r2, #4]
					temp[x+4-i + offset] = txdata[j+x];
				WriteFlashData(offset+4,temp);
		 	}else
			 	{
			 	FillSendCMD(temp, 0x02, flash_addr+j);
				for(x = 0;x < i;x++)  
    125c:	429d      	cmp	r5, r3
    125e:	d1f7      	bne.n	1250 <QSPI_WriteFlashData+0x130>
					temp[x+4] = txdata[j+x];
				WriteFlashData(i+4,temp);
    1260:	1d28      	adds	r0, r5, #4
    1262:	a903      	add	r1, sp, #12
    1264:	f7ff ff09 	bl	107a <WriteFlashData>
    1268:	9b00      	ldr	r3, [sp, #0]
	OS_ENTER_CRITICAL();
	int i=0,j=0,x=0, offset=0;
#ifdef RAM10000
	uint8_t temp[0x10+4]={0};	
#endif
	for(i = txlen,j=0;i>0;i = i -0x10,j = j+0x10){
    126a:	3d10      	subs	r5, #16
    126c:	3310      	adds	r3, #16
    126e:	3610      	adds	r6, #16
    1270:	9300      	str	r3, [sp, #0]
    1272:	e761      	b.n	1138 <QSPI_WriteFlashData+0x18>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
    1274:	b662      	cpsie	i
				WriteFlashData(i+4,temp);
				}
		}
	}
	OS_EXIT_CRITICAL();
}
    1276:	b009      	add	sp, #36	; 0x24
    1278:	bdf0      	pop	{r4, r5, r6, r7, pc}
    127a:	46c0      	nop			; (mov r8, r8)
    127c:	800000ff 	.word	0x800000ff
    1280:	ffffff00 	.word	0xffffff00
    1284:	46c0      	nop			; (mov r8, r8)
    1286:	46c0      	nop			; (mov r8, r8)
    1288:	46c0      	nop			; (mov r8, r8)
    128a:	46c0      	nop			; (mov r8, r8)
    128c:	46c0      	nop			; (mov r8, r8)
    128e:	46c0      	nop			; (mov r8, r8)
    1290:	46c0      	nop			; (mov r8, r8)
    1292:	46c0      	nop			; (mov r8, r8)
    1294:	46c0      	nop			; (mov r8, r8)
    1296:	46c0      	nop			; (mov r8, r8)
    1298:	46c0      	nop			; (mov r8, r8)
    129a:	46c0      	nop			; (mov r8, r8)
    129c:	46c0      	nop			; (mov r8, r8)
    129e:	46c0      	nop			; (mov r8, r8)

000012a0 <SendFlashWithoutRx>:
void __attribute__((noinline,aligned(32))) SendFlashWithoutRx(uint8_t *txdata,int txlen)
{
    12a0:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
		HWRITE(CORE_QSPI_CTRL,0x44 );// 0x40
#else
		HWRITE(CORE_QSPI_CTRL,0x04 );// 0x40
#endif
		HWRITE(CORE_QSPI_DELAY , 0x0);
		HWRITEW(CORE_QSPI_TXADDR , (int)txdata);
    12a2:	b2c7      	uxtb	r7, r0
//	volatile int i, j;
	uint8_t mode, delay;
	mode = HREAD(CORE_QSPI_CTRL);
	delay = HREAD(CORE_QSPI_DELAY);
#ifdef RAM10000
		HWRITE(CORE_QSPI_CTRL,0x44 );// 0x40
    12a4:	2644      	movs	r6, #68	; 0x44
#else
		HWRITE(CORE_QSPI_CTRL,0x04 );// 0x40
#endif
		HWRITE(CORE_QSPI_DELAY , 0x0);
		HWRITEW(CORE_QSPI_TXADDR , (int)txdata);
    12a6:	46bc      	mov	ip, r7
}
void __attribute__((noinline,aligned(32))) SendFlashWithoutRx(uint8_t *txdata,int txlen)
{
//	volatile int i, j;
	uint8_t mode, delay;
	mode = HREAD(CORE_QSPI_CTRL);
    12a8:	4a14      	ldr	r2, [pc, #80]	; (12fc <SendFlashWithoutRx+0x5c>)
	delay = HREAD(CORE_QSPI_DELAY);
    12aa:	4b15      	ldr	r3, [pc, #84]	; (1300 <SendFlashWithoutRx+0x60>)
}
void __attribute__((noinline,aligned(32))) SendFlashWithoutRx(uint8_t *txdata,int txlen)
{
//	volatile int i, j;
	uint8_t mode, delay;
	mode = HREAD(CORE_QSPI_CTRL);
    12ac:	7815      	ldrb	r5, [r2, #0]
	delay = HREAD(CORE_QSPI_DELAY);
    12ae:	781c      	ldrb	r4, [r3, #0]
		HWRITE(CORE_QSPI_CTRL,0x44 );// 0x40
#else
		HWRITE(CORE_QSPI_CTRL,0x04 );// 0x40
#endif
		HWRITE(CORE_QSPI_DELAY , 0x0);
		HWRITEW(CORE_QSPI_TXADDR , (int)txdata);
    12b0:	4f14      	ldr	r7, [pc, #80]	; (1304 <SendFlashWithoutRx+0x64>)
void __attribute__((noinline,aligned(32))) SendFlashWithoutRx(uint8_t *txdata,int txlen)
{
//	volatile int i, j;
	uint8_t mode, delay;
	mode = HREAD(CORE_QSPI_CTRL);
	delay = HREAD(CORE_QSPI_DELAY);
    12b2:	b2e4      	uxtb	r4, r4
    12b4:	9401      	str	r4, [sp, #4]
#ifdef RAM10000
		HWRITE(CORE_QSPI_CTRL,0x44 );// 0x40
    12b6:	7016      	strb	r6, [r2, #0]
#else
		HWRITE(CORE_QSPI_CTRL,0x04 );// 0x40
#endif
		HWRITE(CORE_QSPI_DELAY , 0x0);
		HWRITEW(CORE_QSPI_TXADDR , (int)txdata);
    12b8:	4664      	mov	r4, ip
#ifdef RAM10000
		HWRITE(CORE_QSPI_CTRL,0x44 );// 0x40
#else
		HWRITE(CORE_QSPI_CTRL,0x04 );// 0x40
#endif
		HWRITE(CORE_QSPI_DELAY , 0x0);
    12ba:	2600      	movs	r6, #0
		HWRITEW(CORE_QSPI_TXADDR , (int)txdata);
    12bc:	1200      	asrs	r0, r0, #8
#ifdef RAM10000
		HWRITE(CORE_QSPI_CTRL,0x44 );// 0x40
#else
		HWRITE(CORE_QSPI_CTRL,0x04 );// 0x40
#endif
		HWRITE(CORE_QSPI_DELAY , 0x0);
    12be:	701e      	strb	r6, [r3, #0]
		HWRITEW(CORE_QSPI_TXADDR , (int)txdata);
    12c0:	703c      	strb	r4, [r7, #0]
    12c2:	4f11      	ldr	r7, [pc, #68]	; (1308 <SendFlashWithoutRx+0x68>)
    12c4:	b2c0      	uxtb	r0, r0
    12c6:	7038      	strb	r0, [r7, #0]
		HWRITEW(CORE_QSPI_TXLEN, txlen);
    12c8:	4810      	ldr	r0, [pc, #64]	; (130c <SendFlashWithoutRx+0x6c>)
    12ca:	b2cf      	uxtb	r7, r1
    12cc:	7007      	strb	r7, [r0, #0]
    12ce:	1209      	asrs	r1, r1, #8
    12d0:	480f      	ldr	r0, [pc, #60]	; (1310 <SendFlashWithoutRx+0x70>)
    12d2:	b2c9      	uxtb	r1, r1
    12d4:	7001      	strb	r1, [r0, #0]
		HWRITEW(CORE_QSPI_RXLEN , 0);
    12d6:	490f      	ldr	r1, [pc, #60]	; (1314 <SendFlashWithoutRx+0x74>)
		HWRITE(CORE_DMA_START , 8);
    12d8:	480f      	ldr	r0, [pc, #60]	; (1318 <SendFlashWithoutRx+0x78>)
		HWRITE(CORE_QSPI_CTRL,0x04 );// 0x40
#endif
		HWRITE(CORE_QSPI_DELAY , 0x0);
		HWRITEW(CORE_QSPI_TXADDR , (int)txdata);
		HWRITEW(CORE_QSPI_TXLEN, txlen);
		HWRITEW(CORE_QSPI_RXLEN , 0);
    12da:	700e      	strb	r6, [r1, #0]
    12dc:	490f      	ldr	r1, [pc, #60]	; (131c <SendFlashWithoutRx+0x7c>)
}
void __attribute__((noinline,aligned(32))) SendFlashWithoutRx(uint8_t *txdata,int txlen)
{
//	volatile int i, j;
	uint8_t mode, delay;
	mode = HREAD(CORE_QSPI_CTRL);
    12de:	b2ed      	uxtb	r5, r5
		HWRITE(CORE_QSPI_CTRL,0x04 );// 0x40
#endif
		HWRITE(CORE_QSPI_DELAY , 0x0);
		HWRITEW(CORE_QSPI_TXADDR , (int)txdata);
		HWRITEW(CORE_QSPI_TXLEN, txlen);
		HWRITEW(CORE_QSPI_RXLEN , 0);
    12e0:	700e      	strb	r6, [r1, #0]
		HWRITE(CORE_DMA_START , 8);
    12e2:	2108      	movs	r1, #8
		//for(j = 0;j < 20;j++);
		while(!(HREAD(CORE_DMA_STATUS) & 8) );
    12e4:	4e0e      	ldr	r6, [pc, #56]	; (1320 <SendFlashWithoutRx+0x80>)
#endif
		HWRITE(CORE_QSPI_DELAY , 0x0);
		HWRITEW(CORE_QSPI_TXADDR , (int)txdata);
		HWRITEW(CORE_QSPI_TXLEN, txlen);
		HWRITEW(CORE_QSPI_RXLEN , 0);
		HWRITE(CORE_DMA_START , 8);
    12e6:	7001      	strb	r1, [r0, #0]
		//for(j = 0;j < 20;j++);
		while(!(HREAD(CORE_DMA_STATUS) & 8) );
    12e8:	7830      	ldrb	r0, [r6, #0]
    12ea:	4208      	tst	r0, r1
    12ec:	d0fc      	beq.n	12e8 <SendFlashWithoutRx+0x48>
		HWRITE(CORE_QSPI_CTRL , mode);
    12ee:	7015      	strb	r5, [r2, #0]
		HWRITE(CORE_QSPI_DELAY , delay);
    12f0:	466a      	mov	r2, sp
    12f2:	7912      	ldrb	r2, [r2, #4]
    12f4:	701a      	strb	r2, [r3, #0]
		WaitFlashFinish();
    12f6:	f7ff feb3 	bl	1060 <WaitFlashFinish>

}
    12fa:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
    12fc:	100080a0 	.word	0x100080a0
    1300:	100080a1 	.word	0x100080a1
    1304:	100080a4 	.word	0x100080a4
    1308:	100080a5 	.word	0x100080a5
    130c:	100080a2 	.word	0x100080a2
    1310:	100080a3 	.word	0x100080a3
    1314:	100080a8 	.word	0x100080a8
    1318:	1000800a 	.word	0x1000800a
    131c:	100080a9 	.word	0x100080a9
    1320:	10008330 	.word	0x10008330
    1324:	46c0      	nop			; (mov r8, r8)
    1326:	46c0      	nop			; (mov r8, r8)
    1328:	46c0      	nop			; (mov r8, r8)
    132a:	46c0      	nop			; (mov r8, r8)
    132c:	46c0      	nop			; (mov r8, r8)
    132e:	46c0      	nop			; (mov r8, r8)
    1330:	46c0      	nop			; (mov r8, r8)
    1332:	46c0      	nop			; (mov r8, r8)
    1334:	46c0      	nop			; (mov r8, r8)
    1336:	46c0      	nop			; (mov r8, r8)
    1338:	46c0      	nop			; (mov r8, r8)
    133a:	46c0      	nop			; (mov r8, r8)
    133c:	46c0      	nop			; (mov r8, r8)
    133e:	46c0      	nop			; (mov r8, r8)

00001340 <QSPI_FlashDeepPowerDown>:
{
#ifdef RAM10000
	uint8_t temp[1]={0};
#endif
	int i;
	temp[0] = 0xb9;
    1340:	23b9      	movs	r3, #185	; 0xb9

}


void  __attribute__((noinline,aligned(32)))  QSPI_FlashDeepPowerDown()
{
    1342:	b507      	push	{r0, r1, r2, lr}
#ifdef RAM10000
	uint8_t temp[1]={0};
#endif
	int i;
	temp[0] = 0xb9;
	SendFlashWithoutRx(temp,1);
    1344:	2101      	movs	r1, #1
{
#ifdef RAM10000
	uint8_t temp[1]={0};
#endif
	int i;
	temp[0] = 0xb9;
    1346:	a801      	add	r0, sp, #4
    1348:	7003      	strb	r3, [r0, #0]
	SendFlashWithoutRx(temp,1);
    134a:	f7ff ffa9 	bl	12a0 <SendFlashWithoutRx>
	for(i=0;i<5000;i++);
}
    134e:	bd07      	pop	{r0, r1, r2, pc}
    1350:	46c0      	nop			; (mov r8, r8)
    1352:	46c0      	nop			; (mov r8, r8)
    1354:	46c0      	nop			; (mov r8, r8)
    1356:	46c0      	nop			; (mov r8, r8)
    1358:	46c0      	nop			; (mov r8, r8)
    135a:	46c0      	nop			; (mov r8, r8)
    135c:	46c0      	nop			; (mov r8, r8)
    135e:	46c0      	nop			; (mov r8, r8)

00001360 <FlashWriteEnable>:
void  __attribute__((noinline,aligned(32)))  FlashWriteEnable()
{
#ifdef RAM10000
	uint8_t temp2[1]={0};
#endif
	temp2[0] = 0x06;
    1360:	2306      	movs	r3, #6
	SendFlashWithoutRx(temp,1);
	for(i=0;i<5000;i++);
}

void  __attribute__((noinline,aligned(32)))  FlashWriteEnable()
{
    1362:	b507      	push	{r0, r1, r2, lr}
#ifdef RAM10000
	uint8_t temp2[1]={0};
#endif
	temp2[0] = 0x06;
	SendFlashWithoutRx(temp2,1);
    1364:	2101      	movs	r1, #1
void  __attribute__((noinline,aligned(32)))  FlashWriteEnable()
{
#ifdef RAM10000
	uint8_t temp2[1]={0};
#endif
	temp2[0] = 0x06;
    1366:	a801      	add	r0, sp, #4
    1368:	7003      	strb	r3, [r0, #0]
	SendFlashWithoutRx(temp2,1);
    136a:	f7ff ff99 	bl	12a0 <SendFlashWithoutRx>
}
    136e:	bd07      	pop	{r0, r1, r2, pc}
    1370:	46c0      	nop			; (mov r8, r8)
    1372:	46c0      	nop			; (mov r8, r8)
    1374:	46c0      	nop			; (mov r8, r8)
    1376:	46c0      	nop			; (mov r8, r8)
    1378:	46c0      	nop			; (mov r8, r8)
    137a:	46c0      	nop			; (mov r8, r8)
    137c:	46c0      	nop			; (mov r8, r8)
    137e:	46c0      	nop			; (mov r8, r8)

00001380 <QSPI_FlashWriteDisable>:
void  __attribute__((noinline,aligned(32)))  QSPI_FlashWriteDisable()
{
#ifdef RAM10000
	uint8_t temp[1]={0};
#endif
	temp[0] = 0x04;
    1380:	2304      	movs	r3, #4
	temp2[0] = 0x06;
	SendFlashWithoutRx(temp2,1);
}

void  __attribute__((noinline,aligned(32)))  QSPI_FlashWriteDisable()
{
    1382:	b507      	push	{r0, r1, r2, lr}
#ifdef RAM10000
	uint8_t temp[1]={0};
#endif
	temp[0] = 0x04;
	SendFlashWithoutRx(temp,1);
    1384:	2101      	movs	r1, #1
void  __attribute__((noinline,aligned(32)))  QSPI_FlashWriteDisable()
{
#ifdef RAM10000
	uint8_t temp[1]={0};
#endif
	temp[0] = 0x04;
    1386:	a801      	add	r0, sp, #4
    1388:	7003      	strb	r3, [r0, #0]
	SendFlashWithoutRx(temp,1);
    138a:	f7ff ff89 	bl	12a0 <SendFlashWithoutRx>
}
    138e:	bd07      	pop	{r0, r1, r2, pc}
    1390:	46c0      	nop			; (mov r8, r8)
    1392:	46c0      	nop			; (mov r8, r8)
    1394:	46c0      	nop			; (mov r8, r8)
    1396:	46c0      	nop			; (mov r8, r8)
    1398:	46c0      	nop			; (mov r8, r8)
    139a:	46c0      	nop			; (mov r8, r8)
    139c:	46c0      	nop			; (mov r8, r8)
    139e:	46c0      	nop			; (mov r8, r8)

000013a0 <QSPI_PageEraseFlash>:

void __attribute__((noinline,aligned(32))) QSPI_PageEraseFlash(int flash_addr)
{
    13a0:	b507      	push	{r0, r1, r2, lr}
    13a2:	0002      	movs	r2, r0
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
    13a4:	b672      	cpsid	i
	OS_ENTER_CRITICAL();
#ifdef RAM10000
	uint8_t temp[4]={0};
    13a6:	2300      	movs	r3, #0
#endif
	FillSendCMD(temp, 0x81, flash_addr);
    13a8:	a801      	add	r0, sp, #4
    13aa:	2181      	movs	r1, #129	; 0x81

void __attribute__((noinline,aligned(32))) QSPI_PageEraseFlash(int flash_addr)
{
	OS_ENTER_CRITICAL();
#ifdef RAM10000
	uint8_t temp[4]={0};
    13ac:	9301      	str	r3, [sp, #4]
#endif
	FillSendCMD(temp, 0x81, flash_addr);
    13ae:	f7ff fd09 	bl	dc4 <FillSendCMD>
	FlashWriteEnable();	
    13b2:	f7ff ffd5 	bl	1360 <FlashWriteEnable>
	SendFlashWithoutRx(temp,4);
    13b6:	2104      	movs	r1, #4
    13b8:	a801      	add	r0, sp, #4
    13ba:	f7ff ff71 	bl	12a0 <SendFlashWithoutRx>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
    13be:	b662      	cpsie	i
	OS_EXIT_CRITICAL();
}
    13c0:	bd07      	pop	{r0, r1, r2, pc}
    13c2:	46c0      	nop			; (mov r8, r8)
    13c4:	46c0      	nop			; (mov r8, r8)
    13c6:	46c0      	nop			; (mov r8, r8)
    13c8:	46c0      	nop			; (mov r8, r8)
    13ca:	46c0      	nop			; (mov r8, r8)
    13cc:	46c0      	nop			; (mov r8, r8)
    13ce:	46c0      	nop			; (mov r8, r8)
    13d0:	46c0      	nop			; (mov r8, r8)
    13d2:	46c0      	nop			; (mov r8, r8)
    13d4:	46c0      	nop			; (mov r8, r8)
    13d6:	46c0      	nop			; (mov r8, r8)
    13d8:	46c0      	nop			; (mov r8, r8)
    13da:	46c0      	nop			; (mov r8, r8)
    13dc:	46c0      	nop			; (mov r8, r8)
    13de:	46c0      	nop			; (mov r8, r8)

000013e0 <QSPI_WriteFlashReg>:

void   __attribute__((noinline,aligned(32)))  QSPI_WriteFlashReg(uint8_t *txbuf)
{
    13e0:	b573      	push	{r0, r1, r4, r5, r6, lr}
#ifdef RAM10000
	uint8_t temp[3]={0};
    13e2:	2503      	movs	r5, #3
    13e4:	ac01      	add	r4, sp, #4
	SendFlashWithoutRx(temp,4);
	OS_EXIT_CRITICAL();
}

void   __attribute__((noinline,aligned(32)))  QSPI_WriteFlashReg(uint8_t *txbuf)
{
    13e6:	0006      	movs	r6, r0
#ifdef RAM10000
	uint8_t temp[3]={0};
    13e8:	002a      	movs	r2, r5
    13ea:	2100      	movs	r1, #0
    13ec:	0020      	movs	r0, r4
    13ee:	f014 fb2d 	bl	15a4c <memset>
#endif
	temp[0] = 0x01;
    13f2:	2301      	movs	r3, #1
    13f4:	7023      	strb	r3, [r4, #0]
	temp[1] = txbuf[0];
    13f6:	7833      	ldrb	r3, [r6, #0]
    13f8:	7063      	strb	r3, [r4, #1]
	temp[2] = txbuf[1];
    13fa:	7873      	ldrb	r3, [r6, #1]
    13fc:	70a3      	strb	r3, [r4, #2]
	FlashWriteEnable();
    13fe:	f7ff ffaf 	bl	1360 <FlashWriteEnable>
	SendFlashWithoutRx(temp,3);	//s15-s8
    1402:	0029      	movs	r1, r5
    1404:	0020      	movs	r0, r4
    1406:	f7ff ff4b 	bl	12a0 <SendFlashWithoutRx>
}
    140a:	bd73      	pop	{r0, r1, r4, r5, r6, pc}
    140c:	46c0      	nop			; (mov r8, r8)
    140e:	46c0      	nop			; (mov r8, r8)
    1410:	46c0      	nop			; (mov r8, r8)
    1412:	46c0      	nop			; (mov r8, r8)
    1414:	46c0      	nop			; (mov r8, r8)
    1416:	46c0      	nop			; (mov r8, r8)
    1418:	46c0      	nop			; (mov r8, r8)
    141a:	46c0      	nop			; (mov r8, r8)
    141c:	46c0      	nop			; (mov r8, r8)
    141e:	46c0      	nop			; (mov r8, r8)

00001420 <QSPI_FlashQuadEnable>:

void   __attribute__((noinline,aligned(32)))   QSPI_FlashQuadEnable(uint8_t on)
{
#ifdef RAM10000
	uint8_t temp[2]={0};
    1420:	2300      	movs	r3, #0
	FlashWriteEnable();
	SendFlashWithoutRx(temp,3);	//s15-s8
}

void   __attribute__((noinline,aligned(32)))   QSPI_FlashQuadEnable(uint8_t on)
{
    1422:	b537      	push	{r0, r1, r2, r4, r5, lr}
#ifdef RAM10000
	uint8_t temp[2]={0};
    1424:	ac01      	add	r4, sp, #4
	FlashWriteEnable();
	SendFlashWithoutRx(temp,3);	//s15-s8
}

void   __attribute__((noinline,aligned(32)))   QSPI_FlashQuadEnable(uint8_t on)
{
    1426:	0005      	movs	r5, r0
#ifdef RAM10000
	uint8_t temp[2]={0};
#endif
	QSPI_ReadFlashReg(temp);
    1428:	0020      	movs	r0, r4
}

void   __attribute__((noinline,aligned(32)))   QSPI_FlashQuadEnable(uint8_t on)
{
#ifdef RAM10000
	uint8_t temp[2]={0};
    142a:	8023      	strh	r3, [r4, #0]
#endif
	QSPI_ReadFlashReg(temp);
    142c:	f7ff fdc8 	bl	fc0 <QSPI_ReadFlashReg>
    1430:	7863      	ldrb	r3, [r4, #1]
    1432:	2202      	movs	r2, #2
	if(on)
    1434:	2d00      	cmp	r5, #0
    1436:	d002      	beq.n	143e <QSPI_FlashQuadEnable+0x1e>
		temp[1] = temp[1] |0x02;	
    1438:	4313      	orrs	r3, r2
    143a:	7063      	strb	r3, [r4, #1]
    143c:	e001      	b.n	1442 <QSPI_FlashQuadEnable+0x22>
	else
		temp[1] = temp[1] &0xfd;
    143e:	4393      	bics	r3, r2
    1440:	7063      	strb	r3, [r4, #1]
	QSPI_WriteFlashReg(temp);
    1442:	0020      	movs	r0, r4
    1444:	f7ff ffcc 	bl	13e0 <QSPI_WriteFlashReg>
}
    1448:	bd37      	pop	{r0, r1, r2, r4, r5, pc}
    144a:	46c0      	nop			; (mov r8, r8)
    144c:	46c0      	nop			; (mov r8, r8)
    144e:	46c0      	nop			; (mov r8, r8)
    1450:	46c0      	nop			; (mov r8, r8)
    1452:	46c0      	nop			; (mov r8, r8)
    1454:	46c0      	nop			; (mov r8, r8)
    1456:	46c0      	nop			; (mov r8, r8)
    1458:	46c0      	nop			; (mov r8, r8)
    145a:	46c0      	nop			; (mov r8, r8)
    145c:	46c0      	nop			; (mov r8, r8)
    145e:	46c0      	nop			; (mov r8, r8)

00001460 <End>:


void __attribute__((noinline,aligned(32)))    End()
{
	__ASM("nop");
    1460:	46c0      	nop			; (mov r8, r8)
}
    1462:	4770      	bx	lr
    1464:	46c0      	nop			; (mov r8, r8)
    1466:	46c0      	nop			; (mov r8, r8)
    1468:	46c0      	nop			; (mov r8, r8)
    146a:	46c0      	nop			; (mov r8, r8)
    146c:	46c0      	nop			; (mov r8, r8)
    146e:	46c0      	nop			; (mov r8, r8)
    1470:	46c0      	nop			; (mov r8, r8)
    1472:	46c0      	nop			; (mov r8, r8)
    1474:	46c0      	nop			; (mov r8, r8)
    1476:	46c0      	nop			; (mov r8, r8)
    1478:	46c0      	nop			; (mov r8, r8)
    147a:	46c0      	nop			; (mov r8, r8)
    147c:	46c0      	nop			; (mov r8, r8)
    147e:	46c0      	nop			; (mov r8, r8)

00001480 <prefetch>:

void __attribute__((noinline,aligned(32)))   prefetch(int start_addr, int end_addr)
{
	int addr= 0;
	for(addr = (int)start_addr & (~0x1f);addr < (int)end_addr + 32;addr += 32)
    1480:	231f      	movs	r3, #31
    1482:	4398      	bics	r0, r3
    1484:	0003      	movs	r3, r0
    1486:	311f      	adds	r1, #31
    1488:	428b      	cmp	r3, r1
    148a:	dc02      	bgt.n	1492 <prefetch+0x12>
	{
		__ASM("ldr r0,[%0]": : "r"(addr) :"%r0");
    148c:	6818      	ldr	r0, [r3, #0]
}

void __attribute__((noinline,aligned(32)))   prefetch(int start_addr, int end_addr)
{
	int addr= 0;
	for(addr = (int)start_addr & (~0x1f);addr < (int)end_addr + 32;addr += 32)
    148e:	3320      	adds	r3, #32
    1490:	e7fa      	b.n	1488 <prefetch+0x8>
	{
		__ASM("ldr r0,[%0]": : "r"(addr) :"%r0");
//			__ASM("ldr r0,[%0]": : "r"(addr) :);
	}
}
    1492:	4770      	bx	lr

00001494 <QSPI_Init>:

void QSPI_Init()
{
	int a,b;
	a = (int)Start;
    1494:	4806      	ldr	r0, [pc, #24]	; (14b0 <QSPI_Init+0x1c>)
	b = (int)End;
    1496:	4b07      	ldr	r3, [pc, #28]	; (14b4 <QSPI_Init+0x20>)
//			__ASM("ldr r0,[%0]": : "r"(addr) :);
	}
}

void QSPI_Init()
{
    1498:	b510      	push	{r4, lr}
	int a,b;
	a = (int)Start;
	b = (int)End;
	if(a<b)
    149a:	4298      	cmp	r0, r3
    149c:	da03      	bge.n	14a6 <QSPI_Init+0x12>
		prefetch(a,b);
    149e:	0019      	movs	r1, r3
    14a0:	f7ff ffee 	bl	1480 <prefetch>
    14a4:	e003      	b.n	14ae <QSPI_Init+0x1a>
	else
		prefetch(b,a);
    14a6:	0001      	movs	r1, r0
    14a8:	0018      	movs	r0, r3
    14aa:	f7ff ffe9 	bl	1480 <prefetch>
}
    14ae:	bd10      	pop	{r4, pc}
    14b0:	00000dc1 	.word	0x00000dc1
    14b4:	00001461 	.word	0x00001461

000014b8 <_Qspi_WritebyEarsePage>:

void _Qspi_WritebyEarsePage(uint32_t flash_addr,uint32_t len,uint8_t* tbuf)
{		
    14b8:	b5f0      	push	{r4, r5, r6, r7, lr}
    14ba:	0017      	movs	r7, r2
	uint32_t i=0;
	uint8_t pagebuf[PAGE_SIZE] = {0};
	
	memset(pagebuf,0xff,PAGE_SIZE);												//ÿֽڶΪff													
    14bc:	2280      	movs	r2, #128	; 0x80
	else
		prefetch(b,a);
}

void _Qspi_WritebyEarsePage(uint32_t flash_addr,uint32_t len,uint8_t* tbuf)
{		
    14be:	b0c1      	sub	sp, #260	; 0x104
    14c0:	0005      	movs	r5, r0
	uint32_t i=0;
	uint8_t pagebuf[PAGE_SIZE] = {0};
	
	memset(pagebuf,0xff,PAGE_SIZE);												//ÿֽڶΪff													
    14c2:	0052      	lsls	r2, r2, #1
	else
		prefetch(b,a);
}

void _Qspi_WritebyEarsePage(uint32_t flash_addr,uint32_t len,uint8_t* tbuf)
{		
    14c4:	000e      	movs	r6, r1
	uint32_t i=0;
	uint8_t pagebuf[PAGE_SIZE] = {0};
	
	memset(pagebuf,0xff,PAGE_SIZE);												//ÿֽڶΪff													
    14c6:	4668      	mov	r0, sp
    14c8:	21ff      	movs	r1, #255	; 0xff
    14ca:	f014 fabf 	bl	15a4c <memset>

	QSPI_Init();
    14ce:	f7ff ffe1 	bl	1494 <QSPI_Init>
	QSPI_ReadFlashData((flash_addr/PAGE_SIZE)*PAGE_SIZE,PAGE_SIZE,pagebuf);//flashжĵݵpagebuf
    14d2:	2180      	movs	r1, #128	; 0x80
    14d4:	0a2c      	lsrs	r4, r5, #8
    14d6:	0224      	lsls	r4, r4, #8
    14d8:	466a      	mov	r2, sp
    14da:	0049      	lsls	r1, r1, #1
    14dc:	0020      	movs	r0, r4
    14de:	f7ff fcdf 	bl	ea0 <QSPI_ReadFlashData>

	for(i=0; i<len; i++)														//Ҫ޸copypagebuf
    14e2:	2300      	movs	r3, #0
		pagebuf[flash_addr%256 +i] = *(tbuf + i);
    14e4:	b2ea      	uxtb	r2, r5
	memset(pagebuf,0xff,PAGE_SIZE);												//ÿֽڶΪff													

	QSPI_Init();
	QSPI_ReadFlashData((flash_addr/PAGE_SIZE)*PAGE_SIZE,PAGE_SIZE,pagebuf);//flashжĵݵpagebuf

	for(i=0; i<len; i++)														//Ҫ޸copypagebuf
    14e6:	42b3      	cmp	r3, r6
    14e8:	d005      	beq.n	14f6 <_Qspi_WritebyEarsePage+0x3e>
		pagebuf[flash_addr%256 +i] = *(tbuf + i);
    14ea:	0019      	movs	r1, r3
    14ec:	5cf8      	ldrb	r0, [r7, r3]
    14ee:	4469      	add	r1, sp
    14f0:	5488      	strb	r0, [r1, r2]
	memset(pagebuf,0xff,PAGE_SIZE);												//ÿֽڶΪff													

	QSPI_Init();
	QSPI_ReadFlashData((flash_addr/PAGE_SIZE)*PAGE_SIZE,PAGE_SIZE,pagebuf);//flashжĵݵpagebuf

	for(i=0; i<len; i++)														//Ҫ޸copypagebuf
    14f2:	3301      	adds	r3, #1
    14f4:	e7f7      	b.n	14e6 <_Qspi_WritebyEarsePage+0x2e>
		pagebuf[flash_addr%256 +i] = *(tbuf + i);

	QSPI_Init();
    14f6:	f7ff ffcd 	bl	1494 <QSPI_Init>
	QSPI_PageEraseFlash(flash_addr);											//page
    14fa:	0028      	movs	r0, r5
    14fc:	f7ff ff50 	bl	13a0 <QSPI_PageEraseFlash>

	QSPI_Init();
    1500:	f7ff ffc8 	bl	1494 <QSPI_Init>
	QSPI_WriteFlashData((flash_addr/PAGE_SIZE)*PAGE_SIZE,PAGE_SIZE,pagebuf);	//õµpagebufдflash
    1504:	2180      	movs	r1, #128	; 0x80
    1506:	466a      	mov	r2, sp
    1508:	0049      	lsls	r1, r1, #1
    150a:	0020      	movs	r0, r4
    150c:	f7ff fe08 	bl	1120 <QSPI_WriteFlashData>
}
    1510:	b041      	add	sp, #260	; 0x104
    1512:	bdf0      	pop	{r4, r5, r6, r7, pc}

00001514 <QSPI_WriteFlashDatabyPage>:


void QSPI_WriteFlashDatabyPage(int flash_addr, int txlen, uint8_t *txdata)
{
    1514:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	uint32_t i=0;
//	uint8_t pagebuf[PAGE_SIZE] = {0};
	uint32_t packnum = 0;
	uint32_t ilen = (PAGE_SIZE - flash_addr % PAGE_SIZE);
    1516:	4c1c      	ldr	r4, [pc, #112]	; (1588 <QSPI_WriteFlashDatabyPage+0x74>)
	QSPI_WriteFlashData((flash_addr/PAGE_SIZE)*PAGE_SIZE,PAGE_SIZE,pagebuf);	//õµpagebufдflash
}


void QSPI_WriteFlashDatabyPage(int flash_addr, int txlen, uint8_t *txdata)
{
    1518:	0007      	movs	r7, r0
    151a:	000d      	movs	r5, r1
    151c:	0016      	movs	r6, r2
	uint32_t i=0;
//	uint8_t pagebuf[PAGE_SIZE] = {0};
	uint32_t packnum = 0;
	uint32_t ilen = (PAGE_SIZE - flash_addr % PAGE_SIZE);
    151e:	4004      	ands	r4, r0
    1520:	d503      	bpl.n	152a <QSPI_WriteFlashDatabyPage+0x16>
    1522:	4b1a      	ldr	r3, [pc, #104]	; (158c <QSPI_WriteFlashDatabyPage+0x78>)
    1524:	3c01      	subs	r4, #1
    1526:	431c      	orrs	r4, r3
    1528:	3401      	adds	r4, #1
    152a:	2380      	movs	r3, #128	; 0x80
    152c:	005b      	lsls	r3, r3, #1
    152e:	1b1c      	subs	r4, r3, r4
		
	ilen = ilen>txlen?txlen:ilen;						//ȷһҳдĳ
    1530:	42ac      	cmp	r4, r5
    1532:	d900      	bls.n	1536 <QSPI_WriteFlashDatabyPage+0x22>
    1534:	002c      	movs	r4, r5

	_Qspi_WritebyEarsePage(flash_addr,ilen,txdata);		//дҪдĵһpage
    1536:	0032      	movs	r2, r6
    1538:	0021      	movs	r1, r4
    153a:	0038      	movs	r0, r7
    153c:	f7ff ffbc 	bl	14b8 <_Qspi_WritebyEarsePage>

	flash_addr += ilen;									//дһҳ֮ƫ
	txdata += ilen;
    1540:	1933      	adds	r3, r6, r4
	txlen -= ilen;
    1542:	1b2e      	subs	r6, r5, r4
	ilen = ilen>txlen?txlen:ilen;						//ȷһҳдĳ

	_Qspi_WritebyEarsePage(flash_addr,ilen,txdata);		//дҪдĵһpage

	flash_addr += ilen;									//дһҳ֮ƫ
	txdata += ilen;
    1544:	9300      	str	r3, [sp, #0]
	txlen -= ilen;

	packnum = (txlen + 255)/PAGE_SIZE; 					//ʣݻҪдҳ
    1546:	0033      	movs	r3, r6
    1548:	33ff      	adds	r3, #255	; 0xff
		
	ilen = ilen>txlen?txlen:ilen;						//ȷһҳдĳ

	_Qspi_WritebyEarsePage(flash_addr,ilen,txdata);		//дҪдĵһpage

	flash_addr += ilen;									//дһҳ֮ƫ
    154a:	19e7      	adds	r7, r4, r7
	txdata += ilen;
	txlen -= ilen;

	packnum = (txlen + 255)/PAGE_SIZE; 					//ʣݻҪдҳ
    154c:	17dc      	asrs	r4, r3, #31
    154e:	b2e4      	uxtb	r4, r4
    1550:	18e4      	adds	r4, r4, r3

	for(i=0; i<packnum; i++){							//ѭдʣ
    1552:	2300      	movs	r3, #0

	flash_addr += ilen;									//дһҳ֮ƫ
	txdata += ilen;
	txlen -= ilen;

	packnum = (txlen + 255)/PAGE_SIZE; 					//ʣݻҪдҳ
    1554:	1224      	asrs	r4, r4, #8

	for(i=0; i<packnum; i++){							//ѭдʣ
    1556:	9301      	str	r3, [sp, #4]
    1558:	9b01      	ldr	r3, [sp, #4]
    155a:	42a3      	cmp	r3, r4
    155c:	d013      	beq.n	1586 <QSPI_WriteFlashDatabyPage+0x72>
	
		ilen = txlen>PAGE_SIZE?PAGE_SIZE:txlen;
    155e:	2380      	movs	r3, #128	; 0x80
    1560:	0035      	movs	r5, r6
    1562:	005b      	lsls	r3, r3, #1
    1564:	429e      	cmp	r6, r3
    1566:	dd00      	ble.n	156a <QSPI_WriteFlashDatabyPage+0x56>
    1568:	001d      	movs	r5, r3
		_Qspi_WritebyEarsePage(flash_addr,ilen,txdata);
    156a:	0038      	movs	r0, r7
    156c:	9a00      	ldr	r2, [sp, #0]
    156e:	0029      	movs	r1, r5
    1570:	f7ff ffa2 	bl	14b8 <_Qspi_WritebyEarsePage>

		flash_addr += ilen;
		txdata += ilen;
    1574:	9b00      	ldr	r3, [sp, #0]
	for(i=0; i<packnum; i++){							//ѭдʣ
	
		ilen = txlen>PAGE_SIZE?PAGE_SIZE:txlen;
		_Qspi_WritebyEarsePage(flash_addr,ilen,txdata);

		flash_addr += ilen;
    1576:	19ef      	adds	r7, r5, r7
		txdata += ilen;
    1578:	195b      	adds	r3, r3, r5
    157a:	9300      	str	r3, [sp, #0]
	txdata += ilen;
	txlen -= ilen;

	packnum = (txlen + 255)/PAGE_SIZE; 					//ʣݻҪдҳ

	for(i=0; i<packnum; i++){							//ѭдʣ
    157c:	9b01      	ldr	r3, [sp, #4]
		ilen = txlen>PAGE_SIZE?PAGE_SIZE:txlen;
		_Qspi_WritebyEarsePage(flash_addr,ilen,txdata);

		flash_addr += ilen;
		txdata += ilen;
		txlen -= ilen;
    157e:	1b76      	subs	r6, r6, r5
	txdata += ilen;
	txlen -= ilen;

	packnum = (txlen + 255)/PAGE_SIZE; 					//ʣݻҪдҳ

	for(i=0; i<packnum; i++){							//ѭдʣ
    1580:	3301      	adds	r3, #1
    1582:	9301      	str	r3, [sp, #4]
    1584:	e7e8      	b.n	1558 <QSPI_WriteFlashDatabyPage+0x44>
		flash_addr += ilen;
		txdata += ilen;
		txlen -= ilen;
	}
	
}
    1586:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
    1588:	800000ff 	.word	0x800000ff
    158c:	ffffff00 	.word	0xffffff00

00001590 <hw_delay>:

#define BW(addr)			(int)*(addr) << 24 | (int)*(addr + 1) << 16 | (int)*(addr + 2) << 8 | *(addr + 3)

static inline void hw_delay() 
{
	__asm__ __volatile__("nop");
    1590:	46c0      	nop			; (mov r8, r8)
	__asm__ __volatile__("nop");
    1592:	46c0      	nop			; (mov r8, r8)
	__asm__ __volatile__("nop");
    1594:	46c0      	nop			; (mov r8, r8)
	__asm__ __volatile__("nop");
    1596:	46c0      	nop			; (mov r8, r8)
	__asm__ __volatile__("nop");
    1598:	46c0      	nop			; (mov r8, r8)
}
    159a:	4770      	bx	lr

0000159c <HW_REG_16BIT>:
#define OS_ENTER_CRITICAL() __disable_irq() 
#define OS_EXIT_CRITICAL() __enable_irq() 


static inline void HW_REG_16BIT(uint32_t reg, uint16_t word)
{
    159c:	b570      	push	{r4, r5, r6, lr}
    159e:	000c      	movs	r4, r1
    15a0:	0005      	movs	r5, r0
    HW_REG_8BIT(reg, word & 0x00FF);
    15a2:	b2cb      	uxtb	r3, r1
    15a4:	7003      	strb	r3, [r0, #0]
    hw_delay();
    HW_REG_8BIT(reg + 1,(word >> 8));
    15a6:	0a24      	lsrs	r4, r4, #8


static inline void HW_REG_16BIT(uint32_t reg, uint16_t word)
{
    HW_REG_8BIT(reg, word & 0x00FF);
    hw_delay();
    15a8:	f7ff fff2 	bl	1590 <hw_delay>
    HW_REG_8BIT(reg + 1,(word >> 8));
    15ac:	706c      	strb	r4, [r5, #1]
}
    15ae:	bd70      	pop	{r4, r5, r6, pc}

000015b0 <HR_REG_16BIT>:
static inline uint16_t HR_REG_16BIT(uint32_t reg)
{
    15b0:	b570      	push	{r4, r5, r6, lr}
    15b2:	0005      	movs	r5, r0
	uint16_t return_data = 0;
	uint16_t H_data = 0;
	hw_delay();
    15b4:	f7ff ffec 	bl	1590 <hw_delay>
	return_data = HR_REG_8BIT(reg);
    15b8:	782c      	ldrb	r4, [r5, #0]
	hw_delay();
    15ba:	f7ff ffe9 	bl	1590 <hw_delay>
	H_data = HR_REG_8BIT(reg + 1);
    15be:	7868      	ldrb	r0, [r5, #1]
static inline uint16_t HR_REG_16BIT(uint32_t reg)
{
	uint16_t return_data = 0;
	uint16_t H_data = 0;
	hw_delay();
	return_data = HR_REG_8BIT(reg);
    15c0:	b2e4      	uxtb	r4, r4
	hw_delay();
	H_data = HR_REG_8BIT(reg + 1);
	return_data = (return_data | ((H_data << 8) & 0xFF00));
	return return_data;
    15c2:	0200      	lsls	r0, r0, #8
    15c4:	4320      	orrs	r0, r4
}
    15c6:	bd70      	pop	{r4, r5, r6, pc}

000015c8 <usartInitByBackup>:

UartxRegControlBackup regBeck[UART_PER_NUM];


static void usartInitByBackup(USART_TypeDef USARTx)
{
    15c8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	uint16_t UartxCtrlAdr = 0;
	UartxRegDef *UartAdr = NULL;
	/*set uart control*/
	if(USARTx == UARTA) {
    15ca:	2800      	cmp	r0, #0
    15cc:	d004      	beq.n	15d8 <usartInitByBackup+0x10>
		UartxCtrlAdr = CORE_UART_CTRL;
		UartAdr = (UartxRegDef *)(reg_map(CORE_UART_BAUD));
	}else if(USARTx == UARTB) {
    15ce:	2801      	cmp	r0, #1
    15d0:	d105      	bne.n	15de <usartInitByBackup+0x16>
		UartxCtrlAdr = CORE_UARTB_CTRL;
		UartAdr = (UartxRegDef *)(reg_map(CORE_UARTB_BAUD));
    15d2:	4e1b      	ldr	r6, [pc, #108]	; (1640 <usartInitByBackup+0x78>)
	/*set uart control*/
	if(USARTx == UARTA) {
		UartxCtrlAdr = CORE_UART_CTRL;
		UartAdr = (UartxRegDef *)(reg_map(CORE_UART_BAUD));
	}else if(USARTx == UARTB) {
		UartxCtrlAdr = CORE_UARTB_CTRL;
    15d4:	4b1b      	ldr	r3, [pc, #108]	; (1644 <usartInitByBackup+0x7c>)
    15d6:	e004      	b.n	15e2 <usartInitByBackup+0x1a>
	uint16_t UartxCtrlAdr = 0;
	UartxRegDef *UartAdr = NULL;
	/*set uart control*/
	if(USARTx == UARTA) {
		UartxCtrlAdr = CORE_UART_CTRL;
		UartAdr = (UartxRegDef *)(reg_map(CORE_UART_BAUD));
    15d8:	4e1b      	ldr	r6, [pc, #108]	; (1648 <usartInitByBackup+0x80>)
{
	uint16_t UartxCtrlAdr = 0;
	UartxRegDef *UartAdr = NULL;
	/*set uart control*/
	if(USARTx == UARTA) {
		UartxCtrlAdr = CORE_UART_CTRL;
    15da:	4b1c      	ldr	r3, [pc, #112]	; (164c <usartInitByBackup+0x84>)
    15dc:	e001      	b.n	15e2 <usartInitByBackup+0x1a>


static void usartInitByBackup(USART_TypeDef USARTx)
{
	uint16_t UartxCtrlAdr = 0;
	UartxRegDef *UartAdr = NULL;
    15de:	2600      	movs	r6, #0
UartxRegControlBackup regBeck[UART_PER_NUM];


static void usartInitByBackup(USART_TypeDef USARTx)
{
	uint16_t UartxCtrlAdr = 0;
    15e0:	0033      	movs	r3, r6
	}else if(USARTx == UARTB) {
		UartxCtrlAdr = CORE_UARTB_CTRL;
		UartAdr = (UartxRegDef *)(reg_map(CORE_UARTB_BAUD));
	}

	HWCOR(UartxCtrlAdr, 1);
    15e2:	2580      	movs	r5, #128	; 0x80
    15e4:	2201      	movs	r2, #1
    15e6:	056d      	lsls	r5, r5, #21
    15e8:	431d      	orrs	r5, r3
    15ea:	782b      	ldrb	r3, [r5, #0]

	/*init all reg by backup*/
	HW_REG_16BIT(((uint32_t)(&UartAdr->Baudrate)), regBeck[USARTx].rbu.Baudrate);
    15ec:	4f18      	ldr	r7, [pc, #96]	; (1650 <usartInitByBackup+0x88>)
	}else if(USARTx == UARTB) {
		UartxCtrlAdr = CORE_UARTB_CTRL;
		UartAdr = (UartxRegDef *)(reg_map(CORE_UARTB_BAUD));
	}

	HWCOR(UartxCtrlAdr, 1);
    15ee:	4393      	bics	r3, r2
    15f0:	702b      	strb	r3, [r5, #0]

	/*init all reg by backup*/
	HW_REG_16BIT(((uint32_t)(&UartAdr->Baudrate)), regBeck[USARTx].rbu.Baudrate);
    15f2:	0104      	lsls	r4, r0, #4
    15f4:	5be1      	ldrh	r1, [r4, r7]
    15f6:	0030      	movs	r0, r6
    15f8:	f7ff ffd0 	bl	159c <HW_REG_16BIT>
	HW_REG_16BIT(((uint32_t)(&UartAdr->TxSadr)), (uint32_t)regBeck[USARTx].rbu.TxSadr);
    15fc:	0030      	movs	r0, r6
    15fe:	193c      	adds	r4, r7, r4
    1600:	8921      	ldrh	r1, [r4, #8]
    1602:	3008      	adds	r0, #8
    1604:	f7ff ffca 	bl	159c <HW_REG_16BIT>
	HW_REG_16BIT(((uint32_t)(&UartAdr->TxEadr)), (uint32_t)regBeck[USARTx].rbu.TxEadr);
    1608:	0030      	movs	r0, r6
    160a:	8961      	ldrh	r1, [r4, #10]
    160c:	300a      	adds	r0, #10
    160e:	f7ff ffc5 	bl	159c <HW_REG_16BIT>
	HW_REG_16BIT(((uint32_t)(&UartAdr->TxWptr)), (uint32_t)regBeck[USARTx].rbu.TxSadr);
    1612:	0030      	movs	r0, r6
    1614:	8921      	ldrh	r1, [r4, #8]
    1616:	300c      	adds	r0, #12
    1618:	f7ff ffc0 	bl	159c <HW_REG_16BIT>
	HW_REG_16BIT(((uint32_t)(&UartAdr->RxSadr)), (uint32_t)regBeck[USARTx].rbu.RxSadr);
    161c:	1cb0      	adds	r0, r6, #2
    161e:	8861      	ldrh	r1, [r4, #2]
    1620:	f7ff ffbc 	bl	159c <HW_REG_16BIT>
	HW_REG_16BIT(((uint32_t)(&UartAdr->RxEadr)), (uint32_t)regBeck[USARTx].rbu.RxEadr);
    1624:	1d30      	adds	r0, r6, #4
    1626:	88a1      	ldrh	r1, [r4, #4]
    1628:	f7ff ffb8 	bl	159c <HW_REG_16BIT>
	HW_REG_16BIT(((uint32_t)(&UartAdr->RxRptr)), (uint32_t)regBeck[USARTx].rbu.RxSadr);
    162c:	1db0      	adds	r0, r6, #6
    162e:	8861      	ldrh	r1, [r4, #2]
    1630:	f7ff ffb4 	bl	159c <HW_REG_16BIT>
	HWOR(UartxCtrlAdr, regBeck[USARTx].cbu);
    1634:	782a      	ldrb	r2, [r5, #0]
    1636:	7ba3      	ldrb	r3, [r4, #14]
    1638:	4313      	orrs	r3, r2
    163a:	702b      	strb	r3, [r5, #0]
}
    163c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    163e:	46c0      	nop			; (mov r8, r8)
    1640:	10008072 	.word	0x10008072
    1644:	00008071 	.word	0x00008071
    1648:	10008052 	.word	0x10008052
    164c:	00008060 	.word	0x00008060
    1650:	100127fc 	.word	0x100127fc

00001654 <USART_Init>:

void USART_Init(USART_TypeDef USARTx, USART_InitTypeDef* USART_InitStruct)
{	
#define UARTC_BIT_ENABLE (1<<0)
#define BAUD_USE_SETTING (1<<7)
	HWRITE(CORE_UART_CLKSEL, 1);
    1654:	2201      	movs	r2, #1
    1656:	4b37      	ldr	r3, [pc, #220]	; (1734 <USART_Init+0xe0>)
	return SUCCESS;
}
#endif

void USART_Init(USART_TypeDef USARTx, USART_InitTypeDef* USART_InitStruct)
{	
    1658:	b5f0      	push	{r4, r5, r6, r7, lr}
#define UARTC_BIT_ENABLE (1<<0)
#define BAUD_USE_SETTING (1<<7)
	HWRITE(CORE_UART_CLKSEL, 1);
    165a:	701a      	strb	r2, [r3, #0]
	HWCOR(CORE_CLKOFF + 1, 0x80);
    165c:	237f      	movs	r3, #127	; 0x7f
    165e:	4a36      	ldr	r2, [pc, #216]	; (1738 <USART_Init+0xe4>)
	return SUCCESS;
}
#endif

void USART_Init(USART_TypeDef USARTx, USART_InitTypeDef* USART_InitStruct)
{	
    1660:	0005      	movs	r5, r0
#define UARTC_BIT_ENABLE (1<<0)
#define BAUD_USE_SETTING (1<<7)
	HWRITE(CORE_UART_CLKSEL, 1);
	HWCOR(CORE_CLKOFF + 1, 0x80);
    1662:	7810      	ldrb	r0, [r2, #0]
	return SUCCESS;
}
#endif

void USART_Init(USART_TypeDef USARTx, USART_InitTypeDef* USART_InitStruct)
{	
    1664:	b087      	sub	sp, #28
#define UARTC_BIT_ENABLE (1<<0)
#define BAUD_USE_SETTING (1<<7)
	HWRITE(CORE_UART_CLKSEL, 1);
	HWCOR(CORE_CLKOFF + 1, 0x80);
    1666:	4003      	ands	r3, r0
    1668:	7013      	strb	r3, [r2, #0]

	void *Ptr = NULL;
	uint8_t CtrValue = 0;

	/*check parameter*/
	ASSERT(USART_InitStruct != NULL);
    166a:	2900      	cmp	r1, #0
    166c:	d100      	bne.n	1670 <USART_Init+0x1c>
    166e:	e7fe      	b.n	166e <USART_Init+0x1a>
	ASSERT(IS_USARTAB(USARTx));
    1670:	2d01      	cmp	r5, #1
    1672:	d8fd      	bhi.n	1670 <USART_Init+0x1c>
	ASSERT(IS_UARTE_BAUDRATE(USART_InitStruct->USART_BaudRate));
    1674:	680b      	ldr	r3, [r1, #0]
    1676:	4a31      	ldr	r2, [pc, #196]	; (173c <USART_Init+0xe8>)
    1678:	1e58      	subs	r0, r3, #1
    167a:	4290      	cmp	r0, r2
    167c:	d8fd      	bhi.n	167a <USART_Init+0x26>
	ASSERT(IS_USART_WORD_LENGTH(USART_InitStruct->USART_WordLength));
    167e:	888a      	ldrh	r2, [r1, #4]
    1680:	9201      	str	r2, [sp, #4]
    1682:	9a01      	ldr	r2, [sp, #4]
    1684:	2a00      	cmp	r2, #0
    1686:	d001      	beq.n	168c <USART_Init+0x38>
    1688:	2a04      	cmp	r2, #4
    168a:	d1fa      	bne.n	1682 <USART_Init+0x2e>
	ASSERT(IS_USART_STOPBITS(USART_InitStruct->USART_StopBits));
    168c:	88ca      	ldrh	r2, [r1, #6]
    168e:	9202      	str	r2, [sp, #8]
    1690:	9a02      	ldr	r2, [sp, #8]
    1692:	2a00      	cmp	r2, #0
    1694:	d001      	beq.n	169a <USART_Init+0x46>
    1696:	2a08      	cmp	r2, #8
    1698:	d1fa      	bne.n	1690 <USART_Init+0x3c>
	ASSERT(IS_USART_PARITY(USART_InitStruct->USART_Parity));
    169a:	890a      	ldrh	r2, [r1, #8]
    169c:	9203      	str	r2, [sp, #12]
    169e:	9a03      	ldr	r2, [sp, #12]
    16a0:	2a00      	cmp	r2, #0
    16a2:	d001      	beq.n	16a8 <USART_Init+0x54>
    16a4:	2a02      	cmp	r2, #2
    16a6:	d1fa      	bne.n	169e <USART_Init+0x4a>
	ASSERT(IS_USART_MODE(USART_InitStruct->USART_Mode));
    16a8:	894a      	ldrh	r2, [r1, #10]
    16aa:	9204      	str	r2, [sp, #16]
    16ac:	9a04      	ldr	r2, [sp, #16]
    16ae:	2a40      	cmp	r2, #64	; 0x40
    16b0:	d001      	beq.n	16b6 <USART_Init+0x62>
    16b2:	2a00      	cmp	r2, #0
    16b4:	d1fa      	bne.n	16ac <USART_Init+0x58>
	ASSERT(IS_USART_HARDWARE_FLOW_CONTROL(USART_InitStruct->USART_HardwareFlowControl));
    16b6:	898f      	ldrh	r7, [r1, #12]
    16b8:	2f00      	cmp	r7, #0
    16ba:	d001      	beq.n	16c0 <USART_Init+0x6c>
    16bc:	2f10      	cmp	r7, #16
    16be:	d1fb      	bne.n	16b8 <USART_Init+0x64>
	ASSERT(IS_USART_TXLen(USART_InitStruct->USART_TXLen));
    16c0:	89ce      	ldrh	r6, [r1, #14]
    16c2:	2e00      	cmp	r6, #0
    16c4:	d100      	bne.n	16c8 <USART_Init+0x74>
    16c6:	e7fe      	b.n	16c6 <USART_Init+0x72>
	ASSERT(IS_USART_RXLen(USART_InitStruct->USART_RXLen));
    16c8:	8a0a      	ldrh	r2, [r1, #16]
    16ca:	9205      	str	r2, [sp, #20]
    16cc:	2a00      	cmp	r2, #0
    16ce:	d100      	bne.n	16d2 <USART_Init+0x7e>
    16d0:	e7fe      	b.n	16d0 <USART_Init+0x7c>

	/*init baud backup*/
	regBeck[USARTx].rbu.Baudrate = USART_InitStruct->USART_BaudRate;
    16d2:	4a1b      	ldr	r2, [pc, #108]	; (1740 <USART_Init+0xec>)
    16d4:	012c      	lsls	r4, r5, #4
    16d6:	52a3      	strh	r3, [r4, r2]
	
	/*init tx ring buffer backup*/
	Ptr = malloc(USART_InitStruct->USART_TXLen);
    16d8:	0030      	movs	r0, r6
    16da:	f013 fe93 	bl	15404 <malloc>
	regBeck[USARTx].rbu.TxSadr = (uint32_t)Ptr;
    16de:	4a18      	ldr	r2, [pc, #96]	; (1740 <USART_Init+0xec>)
    16e0:	b283      	uxth	r3, r0
    16e2:	1914      	adds	r4, r2, r4
    16e4:	8123      	strh	r3, [r4, #8]

	ASSERT(Ptr != NULL);	
    16e6:	2800      	cmp	r0, #0
    16e8:	d100      	bne.n	16ec <USART_Init+0x98>
    16ea:	e7fe      	b.n	16ea <USART_Init+0x96>
	regBeck[USARTx].rbu.TxEadr = ((uint32_t)Ptr) + USART_InitStruct->USART_TXLen;
    16ec:	18f6      	adds	r6, r6, r3
    16ee:	8166      	strh	r6, [r4, #10]
	Ptr = NULL;
	
	/*init rx ring buffer backup*/
	Ptr = malloc(USART_InitStruct->USART_RXLen);
    16f0:	9805      	ldr	r0, [sp, #20]
    16f2:	f013 fe87 	bl	15404 <malloc>
	regBeck[USARTx].rbu.RxSadr = (uint32_t)Ptr;
    16f6:	b283      	uxth	r3, r0
    16f8:	8063      	strh	r3, [r4, #2]
	ASSERT(Ptr != NULL);	
    16fa:	2800      	cmp	r0, #0
    16fc:	d100      	bne.n	1700 <USART_Init+0xac>
    16fe:	e7fe      	b.n	16fe <USART_Init+0xaa>
	regBeck[USARTx].rbu.RxEadr = ((uint32_t)Ptr) + USART_InitStruct->USART_RXLen;
    1700:	9a05      	ldr	r2, [sp, #20]
    1702:	18d3      	adds	r3, r2, r3
    1704:	80a3      	strh	r3, [r4, #4]

	CtrValue =  USART_InitStruct->USART_Mode | USART_InitStruct->USART_HardwareFlowControl |\
			  USART_InitStruct->USART_Parity |USART_InitStruct->USART_StopBits| \
			  USART_InitStruct->USART_WordLength|BAUD_USE_SETTING|UARTC_BIT_ENABLE;
	
	regBeck[USARTx].cbu = CtrValue;
    1706:	237f      	movs	r3, #127	; 0x7f
    1708:	9a01      	ldr	r2, [sp, #4]
    170a:	425b      	negs	r3, r3
    170c:	4313      	orrs	r3, r2
    170e:	9a02      	ldr	r2, [sp, #8]
    1710:	4313      	orrs	r3, r2
    1712:	9a03      	ldr	r2, [sp, #12]
    1714:	4313      	orrs	r3, r2
    1716:	9a04      	ldr	r2, [sp, #16]
    1718:	4313      	orrs	r3, r2
    171a:	433b      	orrs	r3, r7
    171c:	73a3      	strb	r3, [r4, #14]

	/*init rx ring buffer regs*/
	if(USARTx == UARTA) {
    171e:	2d00      	cmp	r5, #0
    1720:	d103      	bne.n	172a <USART_Init+0xd6>
		usartInitByBackup(UARTA);
    1722:	0028      	movs	r0, r5
    1724:	f7ff ff50 	bl	15c8 <usartInitByBackup>
    1728:	e002      	b.n	1730 <USART_Init+0xdc>
		//DEV_Register(Device_Id_UartA, usartAReinit, NULL);
	}
	else {
		usartInitByBackup(UARTB);
    172a:	2001      	movs	r0, #1
    172c:	f7ff ff4c 	bl	15c8 <usartInitByBackup>
		//DEV_Register(Device_Id_UartB, usartBReinit, NULL);
	}

}
    1730:	b007      	add	sp, #28
    1732:	bdf0      	pop	{r4, r5, r6, r7, pc}
    1734:	10008043 	.word	0x10008043
    1738:	10008051 	.word	0x10008051
    173c:	00008ffe 	.word	0x00008ffe
    1740:	100127fc 	.word	0x100127fc

00001744 <USART_DeInit>:


void USART_DeInit(USART_TypeDef USARTx)
{
    1744:	b510      	push	{r4, lr}
	UartxRegDef *UartAdr = NULL;
	ASSERT(IS_USARTAB(USARTx));
    1746:	2801      	cmp	r0, #1
    1748:	d8fd      	bhi.n	1746 <USART_DeInit+0x2>
    174a:	2201      	movs	r2, #1
	
	if(USARTx == UARTA) {
    174c:	2800      	cmp	r0, #0
    174e:	d108      	bne.n	1762 <USART_DeInit+0x1e>
		HWOR(reg_map(CORE_UART_CTRL), (1<<0));
    1750:	4b0b      	ldr	r3, [pc, #44]	; (1780 <USART_DeInit+0x3c>)
		HWOR(reg_map(CORE_UART_CTRL), (0<<0));
		UartAdr = (UartxRegDef *)(reg_map(CORE_UART_BAUD));
    1752:	4c0c      	ldr	r4, [pc, #48]	; (1784 <USART_DeInit+0x40>)
{
	UartxRegDef *UartAdr = NULL;
	ASSERT(IS_USARTAB(USARTx));
	
	if(USARTx == UARTA) {
		HWOR(reg_map(CORE_UART_CTRL), (1<<0));
    1754:	7819      	ldrb	r1, [r3, #0]
    1756:	430a      	orrs	r2, r1
    1758:	701a      	strb	r2, [r3, #0]
		HWOR(reg_map(CORE_UART_CTRL), (0<<0));
    175a:	781a      	ldrb	r2, [r3, #0]
    175c:	b2d2      	uxtb	r2, r2
    175e:	701a      	strb	r2, [r3, #0]
    1760:	e007      	b.n	1772 <USART_DeInit+0x2e>
		UartAdr = (UartxRegDef *)(reg_map(CORE_UART_BAUD));
	}else {

		HWOR(reg_map(CORE_UARTB_CTRL), (1<<0));
    1762:	4b09      	ldr	r3, [pc, #36]	; (1788 <USART_DeInit+0x44>)
		HWOR(reg_map(CORE_UARTB_CTRL), (0<<0));
		UartAdr = (UartxRegDef *)(reg_map(CORE_UARTB_BAUD));
    1764:	4c09      	ldr	r4, [pc, #36]	; (178c <USART_DeInit+0x48>)
		HWOR(reg_map(CORE_UART_CTRL), (1<<0));
		HWOR(reg_map(CORE_UART_CTRL), (0<<0));
		UartAdr = (UartxRegDef *)(reg_map(CORE_UART_BAUD));
	}else {

		HWOR(reg_map(CORE_UARTB_CTRL), (1<<0));
    1766:	7819      	ldrb	r1, [r3, #0]
    1768:	430a      	orrs	r2, r1
    176a:	701a      	strb	r2, [r3, #0]
		HWOR(reg_map(CORE_UARTB_CTRL), (0<<0));
    176c:	781a      	ldrb	r2, [r3, #0]
    176e:	b2d2      	uxtb	r2, r2
    1770:	701a      	strb	r2, [r3, #0]
		UartAdr = (UartxRegDef *)(reg_map(CORE_UARTB_BAUD));
	}
	free((void *)((uint32_t)(UartAdr->TxSadr)));
    1772:	8920      	ldrh	r0, [r4, #8]
    1774:	f013 fe50 	bl	15418 <free>
	free((void *)((uint32_t)(UartAdr->RxSadr)));
    1778:	8860      	ldrh	r0, [r4, #2]
    177a:	f013 fe4d 	bl	15418 <free>
}
    177e:	bd10      	pop	{r4, pc}
    1780:	10008060 	.word	0x10008060
    1784:	10008052 	.word	0x10008052
    1788:	10008071 	.word	0x10008071
    178c:	10008072 	.word	0x10008072

00001790 <USART_SendData>:



void USART_SendData(USART_TypeDef USARTx, uint16_t Data)
{
    1790:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    1792:	0006      	movs	r6, r0
    1794:	9101      	str	r1, [sp, #4]
	UartxRegDef * UartAdr = NULL;
	uint16_t  WPtr = 0; 
	ASSERT(IS_USARTAB(USARTx));
    1796:	2e01      	cmp	r6, #1
    1798:	d8fd      	bhi.n	1796 <USART_SendData+0x6>
	
	if(USARTx == UARTA) {
    179a:	2e00      	cmp	r6, #0
    179c:	d001      	beq.n	17a2 <USART_SendData+0x12>
		UartAdr = (UartxRegDef *)(reg_map(CORE_UART_BAUD));	
	}else {
		UartAdr = (UartxRegDef *)(reg_map(CORE_UARTB_BAUD));
    179e:	4c15      	ldr	r4, [pc, #84]	; (17f4 <USART_SendData+0x64>)
    17a0:	e000      	b.n	17a4 <USART_SendData+0x14>
	UartxRegDef * UartAdr = NULL;
	uint16_t  WPtr = 0; 
	ASSERT(IS_USARTAB(USARTx));
	
	if(USARTx == UARTA) {
		UartAdr = (UartxRegDef *)(reg_map(CORE_UART_BAUD));	
    17a2:	4c15      	ldr	r4, [pc, #84]	; (17f8 <USART_SendData+0x68>)
	}else {
		UartAdr = (UartxRegDef *)(reg_map(CORE_UARTB_BAUD));
	}
	ASSERT((&UartAdr->TxSadr  != NULL));
	
	WPtr = HR_REG_16BIT((uint32_t)(&UartAdr->TxWptr));
    17a4:	0027      	movs	r7, r4
    17a6:	370c      	adds	r7, #12
    17a8:	0038      	movs	r0, r7
    17aa:	f7ff ff01 	bl	15b0 <HR_REG_16BIT>
    17ae:	0005      	movs	r5, r0
	if(USARTx == UARTA) {
    17b0:	2e00      	cmp	r6, #0
    17b2:	d104      	bne.n	17be <USART_SendData+0x2e>
		while(HREAD(CORE_UART_TX_ITEMS) > 0);
    17b4:	4a11      	ldr	r2, [pc, #68]	; (17fc <USART_SendData+0x6c>)
    17b6:	7813      	ldrb	r3, [r2, #0]
    17b8:	2b00      	cmp	r3, #0
    17ba:	d1fc      	bne.n	17b6 <USART_SendData+0x26>
    17bc:	e003      	b.n	17c6 <USART_SendData+0x36>
	}else {
		while(HREAD(CORE_UARTB_TX_ITEMS) > 0);
    17be:	4a10      	ldr	r2, [pc, #64]	; (1800 <USART_SendData+0x70>)
    17c0:	7813      	ldrb	r3, [r2, #0]
    17c2:	2b00      	cmp	r3, #0
    17c4:	d1fc      	bne.n	17c0 <USART_SendData+0x30>
	}	
	HW_REG_8BIT(WPtr|M0_MEMORY_BASE,Data);	
    17c6:	466a      	mov	r2, sp
	RB_UPDATE_PTR(WPtr, HR_REG_16BIT((uint32_t)(&UartAdr->TxSadr)),  HR_REG_16BIT((uint32_t)(&UartAdr->TxEadr)));	
    17c8:	0020      	movs	r0, r4
	if(USARTx == UARTA) {
		while(HREAD(CORE_UART_TX_ITEMS) > 0);
	}else {
		while(HREAD(CORE_UARTB_TX_ITEMS) > 0);
	}	
	HW_REG_8BIT(WPtr|M0_MEMORY_BASE,Data);	
    17ca:	4b0e      	ldr	r3, [pc, #56]	; (1804 <USART_SendData+0x74>)
    17cc:	7912      	ldrb	r2, [r2, #4]
    17ce:	432b      	orrs	r3, r5
    17d0:	701a      	strb	r2, [r3, #0]
	RB_UPDATE_PTR(WPtr, HR_REG_16BIT((uint32_t)(&UartAdr->TxSadr)),  HR_REG_16BIT((uint32_t)(&UartAdr->TxEadr)));	
    17d2:	300a      	adds	r0, #10
    17d4:	f7ff feec 	bl	15b0 <HR_REG_16BIT>
    17d8:	1c69      	adds	r1, r5, #1
    17da:	b289      	uxth	r1, r1
    17dc:	4285      	cmp	r5, r0
    17de:	d104      	bne.n	17ea <USART_SendData+0x5a>
	if(USARTx == UARTA) {
		UartAdr = (UartxRegDef *)(reg_map(CORE_UART_BAUD));	
	}else {
		UartAdr = (UartxRegDef *)(reg_map(CORE_UARTB_BAUD));
	}
	ASSERT((&UartAdr->TxSadr  != NULL));
    17e0:	0020      	movs	r0, r4
    17e2:	3008      	adds	r0, #8
		while(HREAD(CORE_UART_TX_ITEMS) > 0);
	}else {
		while(HREAD(CORE_UARTB_TX_ITEMS) > 0);
	}	
	HW_REG_8BIT(WPtr|M0_MEMORY_BASE,Data);	
	RB_UPDATE_PTR(WPtr, HR_REG_16BIT((uint32_t)(&UartAdr->TxSadr)),  HR_REG_16BIT((uint32_t)(&UartAdr->TxEadr)));	
    17e4:	f7ff fee4 	bl	15b0 <HR_REG_16BIT>
    17e8:	0001      	movs	r1, r0
	HW_REG_16BIT((uint32_t)(&UartAdr->TxWptr),  WPtr);                                                                                                		
    17ea:	0038      	movs	r0, r7
    17ec:	f7ff fed6 	bl	159c <HW_REG_16BIT>
}
    17f0:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
    17f2:	46c0      	nop			; (mov r8, r8)
    17f4:	10008072 	.word	0x10008072
    17f8:	10008052 	.word	0x10008052
    17fc:	1000830e 	.word	0x1000830e
    1800:	10008356 	.word	0x10008356
    1804:	10010000 	.word	0x10010000

00001808 <USART_ReceiveData>:



uint16_t USART_ReceiveData(USART_TypeDef USARTx)
{	
    1808:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	UartxRegDef *UartAdr = NULL;
	uint16_t  RPtr = 0;
	uint16_t  RdData = 0;
	ASSERT(IS_USARTAB(USARTx)); 
    180a:	2801      	cmp	r0, #1
    180c:	d8fd      	bhi.n	180a <USART_ReceiveData+0x2>

	if(USARTx == UARTA) {
    180e:	2800      	cmp	r0, #0
    1810:	d001      	beq.n	1816 <USART_ReceiveData+0xe>
		UartAdr = (UartxRegDef *)(reg_map(CORE_UART_BAUD));	
	}else {
		UartAdr = (UartxRegDef *)(reg_map(CORE_UARTB_BAUD));
    1812:	4c0e      	ldr	r4, [pc, #56]	; (184c <USART_ReceiveData+0x44>)
    1814:	e000      	b.n	1818 <USART_ReceiveData+0x10>
	uint16_t  RPtr = 0;
	uint16_t  RdData = 0;
	ASSERT(IS_USARTAB(USARTx)); 

	if(USARTx == UARTA) {
		UartAdr = (UartxRegDef *)(reg_map(CORE_UART_BAUD));	
    1816:	4c0e      	ldr	r4, [pc, #56]	; (1850 <USART_ReceiveData+0x48>)
	}else {
		UartAdr = (UartxRegDef *)(reg_map(CORE_UARTB_BAUD));
	}
	RPtr = HR_REG_16BIT((uint32_t)(&UartAdr->RxRptr));
    1818:	1da5      	adds	r5, r4, #6
    181a:	0028      	movs	r0, r5
    181c:	f7ff fec8 	bl	15b0 <HR_REG_16BIT>
    1820:	0007      	movs	r7, r0
	RdData = HR_REG_16BIT(RPtr|M0_MEMORY_BASE);
    1822:	480c      	ldr	r0, [pc, #48]	; (1854 <USART_ReceiveData+0x4c>)
    1824:	4338      	orrs	r0, r7
    1826:	f7ff fec3 	bl	15b0 <HR_REG_16BIT>
    182a:	0006      	movs	r6, r0
	RB_UPDATE_PTR(RPtr, HR_REG_16BIT((uint32_t)(&UartAdr->RxSadr)), HR_REG_16BIT((uint32_t)(&UartAdr->RxEadr)));
    182c:	1d20      	adds	r0, r4, #4
    182e:	f7ff febf 	bl	15b0 <HR_REG_16BIT>
    1832:	1c79      	adds	r1, r7, #1
    1834:	b289      	uxth	r1, r1
    1836:	4287      	cmp	r7, r0
    1838:	d103      	bne.n	1842 <USART_ReceiveData+0x3a>
    183a:	1ca0      	adds	r0, r4, #2
    183c:	f7ff feb8 	bl	15b0 <HR_REG_16BIT>
    1840:	0001      	movs	r1, r0
	HW_REG_16BIT((uint32_t)(&UartAdr->RxRptr), RPtr);	
    1842:	0028      	movs	r0, r5
    1844:	f7ff feaa 	bl	159c <HW_REG_16BIT>
	return RdData;
}
    1848:	0030      	movs	r0, r6
    184a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    184c:	10008072 	.word	0x10008072
    1850:	10008052 	.word	0x10008052
    1854:	10010000 	.word	0x10010000

00001858 <USART_GetRxCount>:


uint16_t USART_GetRxCount(USART_TypeDef USARTx)
{
    1858:	b510      	push	{r4, lr}
	ASSERT(IS_USARTAB(USARTx));
    185a:	2801      	cmp	r0, #1
    185c:	d8fd      	bhi.n	185a <USART_GetRxCount+0x2>
	if(USARTx == UARTA) {
    185e:	2800      	cmp	r0, #0
    1860:	d103      	bne.n	186a <USART_GetRxCount+0x12>
		return HR_REG_16BIT(reg_map(CORE_UART_RX_ITEMS));
    1862:	4804      	ldr	r0, [pc, #16]	; (1874 <USART_GetRxCount+0x1c>)
    1864:	f7ff fea4 	bl	15b0 <HR_REG_16BIT>
    1868:	e002      	b.n	1870 <USART_GetRxCount+0x18>
	}else {
		return HR_REG_16BIT(reg_map(CORE_UARTB_RX_ITEMS));
    186a:	4803      	ldr	r0, [pc, #12]	; (1878 <USART_GetRxCount+0x20>)
    186c:	f7ff fea0 	bl	15b0 <HR_REG_16BIT>
	}
}
    1870:	bd10      	pop	{r4, pc}
    1872:	46c0      	nop			; (mov r8, r8)
    1874:	10008312 	.word	0x10008312
    1878:	1000835a 	.word	0x1000835a

0000187c <USART_ReadDatatoBuff>:


uint16_t USART_ReadDatatoBuff(USART_TypeDef USARTx, uint8_t* RxBuff, uint16_t RxSize)
{
    187c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    187e:	000d      	movs	r5, r1
    1880:	0016      	movs	r6, r2
	uint16_t RxLen = 0;	
	uint16_t RPtr = 0;
	uint16_t RdataLen = 0;
	uint32_t RxITEMS = 0;
	UartxRegDef *UartAdr = NULL;
	ASSERT(IS_USARTAB(USARTx));
    1882:	2801      	cmp	r0, #1
    1884:	d8fd      	bhi.n	1882 <USART_ReadDatatoBuff+0x6>
	ASSERT(RxBuff != NULL);
    1886:	2d00      	cmp	r5, #0
    1888:	d100      	bne.n	188c <USART_ReadDatatoBuff+0x10>
    188a:	e7fe      	b.n	188a <USART_ReadDatatoBuff+0xe>
	
	if(USARTx == UARTA) {
    188c:	2800      	cmp	r0, #0
    188e:	d002      	beq.n	1896 <USART_ReadDatatoBuff+0x1a>
		UartAdr = (UartxRegDef *)(reg_map(CORE_UART_BAUD));
		RxITEMS = reg_map(CORE_UART_RX_ITEMS);
	}else {
		UartAdr = (UartxRegDef *)(reg_map(CORE_UARTB_BAUD));
    1890:	4f1a      	ldr	r7, [pc, #104]	; (18fc <USART_ReadDatatoBuff+0x80>)
		RxITEMS = reg_map(CORE_UARTB_RX_ITEMS);
    1892:	481b      	ldr	r0, [pc, #108]	; (1900 <USART_ReadDatatoBuff+0x84>)
    1894:	e001      	b.n	189a <USART_ReadDatatoBuff+0x1e>
	UartxRegDef *UartAdr = NULL;
	ASSERT(IS_USARTAB(USARTx));
	ASSERT(RxBuff != NULL);
	
	if(USARTx == UARTA) {
		UartAdr = (UartxRegDef *)(reg_map(CORE_UART_BAUD));
    1896:	4f1b      	ldr	r7, [pc, #108]	; (1904 <USART_ReadDatatoBuff+0x88>)
		RxITEMS = reg_map(CORE_UART_RX_ITEMS);
    1898:	481b      	ldr	r0, [pc, #108]	; (1908 <USART_ReadDatatoBuff+0x8c>)
	}else {
		UartAdr = (UartxRegDef *)(reg_map(CORE_UARTB_BAUD));
		RxITEMS = reg_map(CORE_UARTB_RX_ITEMS);
	}
	RxLen = HR_REG_16BIT(reg_map(RxITEMS)); 
    189a:	f7ff fe89 	bl	15b0 <HR_REG_16BIT>
	if (RxSize!=0) {
    189e:	2e00      	cmp	r6, #0
    18a0:	d003      	beq.n	18aa <USART_ReadDatatoBuff+0x2e>
		if (RxLen < RxSize) return 0; else RxLen = RxSize;
    18a2:	2300      	movs	r3, #0
    18a4:	42b0      	cmp	r0, r6
    18a6:	d204      	bcs.n	18b2 <USART_ReadDatatoBuff+0x36>
    18a8:	e025      	b.n	18f6 <USART_ReadDatatoBuff+0x7a>
    18aa:	0033      	movs	r3, r6
	}
	if (0 == RxLen) {
    18ac:	2800      	cmp	r0, #0
    18ae:	d022      	beq.n	18f6 <USART_ReadDatatoBuff+0x7a>
    18b0:	0006      	movs	r6, r0
        return 0;
	} else {
		RPtr = HR_REG_16BIT((uint32_t)(&UartAdr->RxRptr));
    18b2:	1dbb      	adds	r3, r7, #6
    18b4:	0018      	movs	r0, r3
    18b6:	9300      	str	r3, [sp, #0]
    18b8:	f7ff fe7a 	bl	15b0 <HR_REG_16BIT>
    18bc:	0004      	movs	r4, r0
    18be:	19ab      	adds	r3, r5, r6
    18c0:	9301      	str	r3, [sp, #4]
		for(RdataLen = 0; RdataLen<RxLen; RdataLen++ ){
    18c2:	9b01      	ldr	r3, [sp, #4]
    18c4:	429d      	cmp	r5, r3
    18c6:	d011      	beq.n	18ec <USART_ReadDatatoBuff+0x70>
			RxBuff[RdataLen] = HR_REG_8BIT(RPtr|M0_MEMORY_BASE);   
    18c8:	4b10      	ldr	r3, [pc, #64]	; (190c <USART_ReadDatatoBuff+0x90>)
			RB_UPDATE_PTR(RPtr, HR_REG_16BIT((uint32_t)(&UartAdr->RxSadr)), HR_REG_16BIT((uint32_t)(&UartAdr->RxEadr)));
    18ca:	1d38      	adds	r0, r7, #4
	if (0 == RxLen) {
        return 0;
	} else {
		RPtr = HR_REG_16BIT((uint32_t)(&UartAdr->RxRptr));
		for(RdataLen = 0; RdataLen<RxLen; RdataLen++ ){
			RxBuff[RdataLen] = HR_REG_8BIT(RPtr|M0_MEMORY_BASE);   
    18cc:	4323      	orrs	r3, r4
    18ce:	781b      	ldrb	r3, [r3, #0]
    18d0:	702b      	strb	r3, [r5, #0]
			RB_UPDATE_PTR(RPtr, HR_REG_16BIT((uint32_t)(&UartAdr->RxSadr)), HR_REG_16BIT((uint32_t)(&UartAdr->RxEadr)));
    18d2:	f7ff fe6d 	bl	15b0 <HR_REG_16BIT>
    18d6:	4284      	cmp	r4, r0
    18d8:	d104      	bne.n	18e4 <USART_ReadDatatoBuff+0x68>
    18da:	1cb8      	adds	r0, r7, #2
    18dc:	f7ff fe68 	bl	15b0 <HR_REG_16BIT>
    18e0:	0004      	movs	r4, r0
    18e2:	e001      	b.n	18e8 <USART_ReadDatatoBuff+0x6c>
    18e4:	3401      	adds	r4, #1
    18e6:	b2a4      	uxth	r4, r4
    18e8:	3501      	adds	r5, #1
    18ea:	e7ea      	b.n	18c2 <USART_ReadDatatoBuff+0x46>
		}
	}
	HW_REG_16BIT((uint32_t)(&UartAdr->RxRptr), (RPtr));
    18ec:	0021      	movs	r1, r4
    18ee:	9800      	ldr	r0, [sp, #0]
    18f0:	f7ff fe54 	bl	159c <HW_REG_16BIT>
	return RdataLen;
    18f4:	0033      	movs	r3, r6
}
    18f6:	0018      	movs	r0, r3
    18f8:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
    18fa:	46c0      	nop			; (mov r8, r8)
    18fc:	10008072 	.word	0x10008072
    1900:	1000835a 	.word	0x1000835a
    1904:	10008052 	.word	0x10008052
    1908:	10008312 	.word	0x10008312
    190c:	10010000 	.word	0x10010000

00001910 <USART_SendDataFromBuff>:

uint16_t USART_SendDataFromBuff(USART_TypeDef USARTx, uint8_t* TxBuff, uint16_t TxLen)
{
    1910:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    1912:	000d      	movs	r5, r1
    1914:	0017      	movs	r7, r2
	uint16_t  WPtr = 0;
	uint16_t  SDataLen = 0;	
	UartxRegDef *UartAdr = NULL;
	ASSERT(IS_USARTAB(USARTx));
    1916:	2801      	cmp	r0, #1
    1918:	d8fd      	bhi.n	1916 <USART_SendDataFromBuff+0x6>
	ASSERT(TxBuff != 0);
    191a:	2d00      	cmp	r5, #0
    191c:	d100      	bne.n	1920 <USART_SendDataFromBuff+0x10>
    191e:	e7fe      	b.n	191e <USART_SendDataFromBuff+0xe>
	ASSERT(TxLen > 0);
    1920:	2f00      	cmp	r7, #0
    1922:	d100      	bne.n	1926 <USART_SendDataFromBuff+0x16>
    1924:	e7fe      	b.n	1924 <USART_SendDataFromBuff+0x14>
	
	if(USARTx == UARTA) {
    1926:	2800      	cmp	r0, #0
    1928:	d001      	beq.n	192e <USART_SendDataFromBuff+0x1e>
		UartAdr = (UartxRegDef *)(reg_map(CORE_UART_BAUD));	
	}else {
		UartAdr = (UartxRegDef *)(reg_map(CORE_UARTB_BAUD));
    192a:	4e14      	ldr	r6, [pc, #80]	; (197c <USART_SendDataFromBuff+0x6c>)
    192c:	e000      	b.n	1930 <USART_SendDataFromBuff+0x20>
	ASSERT(IS_USARTAB(USARTx));
	ASSERT(TxBuff != 0);
	ASSERT(TxLen > 0);
	
	if(USARTx == UARTA) {
		UartAdr = (UartxRegDef *)(reg_map(CORE_UART_BAUD));	
    192e:	4e14      	ldr	r6, [pc, #80]	; (1980 <USART_SendDataFromBuff+0x70>)
	}else {
		UartAdr = (UartxRegDef *)(reg_map(CORE_UARTB_BAUD));
	}
   	WPtr = HR_REG_16BIT((uint32_t)(&UartAdr->TxWptr));
    1930:	0033      	movs	r3, r6
    1932:	330c      	adds	r3, #12
    1934:	0018      	movs	r0, r3
    1936:	9300      	str	r3, [sp, #0]
    1938:	f7ff fe3a 	bl	15b0 <HR_REG_16BIT>
    193c:	0004      	movs	r4, r0
    193e:	19eb      	adds	r3, r5, r7
    1940:	9301      	str	r3, [sp, #4]
   	for (uint16_t i=0; i<TxLen; i++)  {	
    1942:	9b01      	ldr	r3, [sp, #4]
    1944:	429d      	cmp	r5, r3
    1946:	d013      	beq.n	1970 <USART_SendDataFromBuff+0x60>
		HW_REG_8BIT(WPtr|M0_MEMORY_BASE,TxBuff[i]);	
		RB_UPDATE_PTR(WPtr, HR_REG_16BIT((uint32_t)(&UartAdr->TxSadr)),  HR_REG_16BIT((uint32_t)(&UartAdr->TxEadr)));	   
    1948:	0030      	movs	r0, r6
	}else {
		UartAdr = (UartxRegDef *)(reg_map(CORE_UARTB_BAUD));
	}
   	WPtr = HR_REG_16BIT((uint32_t)(&UartAdr->TxWptr));
   	for (uint16_t i=0; i<TxLen; i++)  {	
		HW_REG_8BIT(WPtr|M0_MEMORY_BASE,TxBuff[i]);	
    194a:	4b0e      	ldr	r3, [pc, #56]	; (1984 <USART_SendDataFromBuff+0x74>)
    194c:	782a      	ldrb	r2, [r5, #0]
    194e:	4323      	orrs	r3, r4
    1950:	701a      	strb	r2, [r3, #0]
		RB_UPDATE_PTR(WPtr, HR_REG_16BIT((uint32_t)(&UartAdr->TxSadr)),  HR_REG_16BIT((uint32_t)(&UartAdr->TxEadr)));	   
    1952:	300a      	adds	r0, #10
    1954:	f7ff fe2c 	bl	15b0 <HR_REG_16BIT>
    1958:	4284      	cmp	r4, r0
    195a:	d105      	bne.n	1968 <USART_SendDataFromBuff+0x58>
    195c:	0030      	movs	r0, r6
    195e:	3008      	adds	r0, #8
    1960:	f7ff fe26 	bl	15b0 <HR_REG_16BIT>
    1964:	0004      	movs	r4, r0
    1966:	e001      	b.n	196c <USART_SendDataFromBuff+0x5c>
    1968:	3401      	adds	r4, #1
    196a:	b2a4      	uxth	r4, r4
    196c:	3501      	adds	r5, #1
    196e:	e7e8      	b.n	1942 <USART_SendDataFromBuff+0x32>
		SDataLen++;	
	}
	HW_REG_16BIT((uint32_t)(&UartAdr->TxWptr),  WPtr);  
    1970:	9800      	ldr	r0, [sp, #0]
    1972:	0021      	movs	r1, r4
    1974:	f7ff fe12 	bl	159c <HW_REG_16BIT>
	return SDataLen;
}
    1978:	0038      	movs	r0, r7
    197a:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
    197c:	10008072 	.word	0x10008072
    1980:	10008052 	.word	0x10008052
    1984:	10010000 	.word	0x10010000

00001988 <UART_RemapToPrintf>:

static USART_TypeDef _printf_uart;

int UART_RemapToPrintf(USART_TypeDef USARTx, uint8_t txPin, uint8_t rxPin)
{
    1988:	000b      	movs	r3, r1
    198a:	b570      	push	{r4, r5, r6, lr}
    198c:	0016      	movs	r6, r2
	_printf_uart = USARTx;
	/*init gpio*/	
	GPIO_CFG cfgTx ={FUNC_UARTB_TXD, GFG_PULLUP};
    198e:	4c0e      	ldr	r4, [pc, #56]	; (19c8 <UART_RemapToPrintf+0x40>)

static USART_TypeDef _printf_uart;

int UART_RemapToPrintf(USART_TypeDef USARTx, uint8_t txPin, uint8_t rxPin)
{
	_printf_uart = USARTx;
    1990:	4d0e      	ldr	r5, [pc, #56]	; (19cc <UART_RemapToPrintf+0x44>)
}

static USART_TypeDef _printf_uart;

int UART_RemapToPrintf(USART_TypeDef USARTx, uint8_t txPin, uint8_t rxPin)
{
    1992:	b088      	sub	sp, #32
	_printf_uart = USARTx;
	/*init gpio*/	
	GPIO_CFG cfgTx ={FUNC_UARTB_TXD, GFG_PULLUP};
    1994:	7822      	ldrb	r2, [r4, #0]
    1996:	a901      	add	r1, sp, #4

static USART_TypeDef _printf_uart;

int UART_RemapToPrintf(USART_TypeDef USARTx, uint8_t txPin, uint8_t rxPin)
{
	_printf_uart = USARTx;
    1998:	7028      	strb	r0, [r5, #0]
	/*init gpio*/	
	GPIO_CFG cfgTx ={FUNC_UARTB_TXD, GFG_PULLUP};
	bc_gpio_init(txPin, &cfgTx);
    199a:	0018      	movs	r0, r3

int UART_RemapToPrintf(USART_TypeDef USARTx, uint8_t txPin, uint8_t rxPin)
{
	_printf_uart = USARTx;
	/*init gpio*/	
	GPIO_CFG cfgTx ={FUNC_UARTB_TXD, GFG_PULLUP};
    199c:	700a      	strb	r2, [r1, #0]
	bc_gpio_init(txPin, &cfgTx);
    199e:	f000 faa7 	bl	1ef0 <bc_gpio_init>
	
	GPIO_CFG cfgRx ={FUNC_UARTB_RXD, GFG_PULLUP};
    19a2:	7863      	ldrb	r3, [r4, #1]
	bc_gpio_init(rxPin, &cfgRx);
    19a4:	0030      	movs	r0, r6
	_printf_uart = USARTx;
	/*init gpio*/	
	GPIO_CFG cfgTx ={FUNC_UARTB_TXD, GFG_PULLUP};
	bc_gpio_init(txPin, &cfgTx);
	
	GPIO_CFG cfgRx ={FUNC_UARTB_RXD, GFG_PULLUP};
    19a6:	a902      	add	r1, sp, #8
    19a8:	700b      	strb	r3, [r1, #0]
	bc_gpio_init(rxPin, &cfgRx);
    19aa:	f000 faa1 	bl	1ef0 <bc_gpio_init>

	/*cofig uart parameter*/	
	USART_InitTypeDef Uart = {BAUD921600, DATA_BITS_8b, STOP_BITS_1, PARITY_EVEN,
    19ae:	a903      	add	r1, sp, #12
    19b0:	000a      	movs	r2, r1
    19b2:	1d23      	adds	r3, r4, #4
    19b4:	cb51      	ldmia	r3!, {r0, r4, r6}
    19b6:	c251      	stmia	r2!, {r0, r4, r6}
    19b8:	cb11      	ldmia	r3!, {r0, r4}
    19ba:	c211      	stmia	r2!, {r0, r4}
								MODE_DUPLEX, FLOW_CTRL_NONE, 128, 128};
	USART_Init(_printf_uart, &Uart);
    19bc:	7828      	ldrb	r0, [r5, #0]
    19be:	f7ff fe49 	bl	1654 <USART_Init>
	return 0;
}
    19c2:	2000      	movs	r0, #0
    19c4:	b008      	add	sp, #32
    19c6:	bd70      	pop	{r4, r5, r6, pc}
    19c8:	0001fe1c 	.word	0x0001fe1c
    19cc:	10010fb8 	.word	0x10010fb8

000019d0 <UART_PutChar>:

void UART_PutChar(char c)
{
	if(_printf_uart)
    19d0:	4b04      	ldr	r3, [pc, #16]	; (19e4 <UART_PutChar+0x14>)
	USART_Init(_printf_uart, &Uart);
	return 0;
}

void UART_PutChar(char c)
{
    19d2:	0001      	movs	r1, r0
	if(_printf_uart)
    19d4:	7818      	ldrb	r0, [r3, #0]
	USART_Init(_printf_uart, &Uart);
	return 0;
}

void UART_PutChar(char c)
{
    19d6:	b510      	push	{r4, lr}
	if(_printf_uart)
    19d8:	2800      	cmp	r0, #0
    19da:	d002      	beq.n	19e2 <UART_PutChar+0x12>
		USART_SendData(_printf_uart, (uint16_t)c);
    19dc:	b289      	uxth	r1, r1
    19de:	f7ff fed7 	bl	1790 <USART_SendData>
}
    19e2:	bd10      	pop	{r4, pc}
    19e4:	10010fb8 	.word	0x10010fb8

000019e8 <bc_flash_erase>:
#define APP_SIZE				(FLASH_START_ADDR+FLASH_SIZE-APP_START_ADDR)

uint32_t bc_flash_erase(uint32_t addr, uint32_t page_cnt)
{

	if((addr&(PAGE_SIZE-1))!= 0 && (addr+PAGE_SIZE*page_cnt)>APP_SIZE)
    19e8:	b2c3      	uxtb	r3, r0

#define APP_START_ADDR			(SECTION_START_ADDR+SECTION_SIZE*SECTION_NUM)
#define APP_SIZE				(FLASH_START_ADDR+FLASH_SIZE-APP_START_ADDR)

uint32_t bc_flash_erase(uint32_t addr, uint32_t page_cnt)
{
    19ea:	b570      	push	{r4, r5, r6, lr}
    19ec:	0004      	movs	r4, r0
    19ee:	000d      	movs	r5, r1

	if((addr&(PAGE_SIZE-1))!= 0 && (addr+PAGE_SIZE*page_cnt)>APP_SIZE)
    19f0:	2b00      	cmp	r3, #0
    19f2:	d006      	beq.n	1a02 <bc_flash_erase+0x1a>
    19f4:	22d0      	movs	r2, #208	; 0xd0
    19f6:	020b      	lsls	r3, r1, #8
    19f8:	181b      	adds	r3, r3, r0
    19fa:	0152      	lsls	r2, r2, #5
		return 1;
    19fc:	2001      	movs	r0, #1
#define APP_SIZE				(FLASH_START_ADDR+FLASH_SIZE-APP_START_ADDR)

uint32_t bc_flash_erase(uint32_t addr, uint32_t page_cnt)
{

	if((addr&(PAGE_SIZE-1))!= 0 && (addr+PAGE_SIZE*page_cnt)>APP_SIZE)
    19fe:	4293      	cmp	r3, r2
    1a00:	d80e      	bhi.n	1a20 <bc_flash_erase+0x38>
		return 1;
	addr += APP_START_ADDR;
    1a02:	4b08      	ldr	r3, [pc, #32]	; (1a24 <bc_flash_erase+0x3c>)
#ifndef RELEASE
		printf( "erase data addr=0x%08x\r\n", addr);
#endif
	QSPI_Init();
	for(int i = 0; i < page_cnt; ++i){
    1a04:	2600      	movs	r6, #0
uint32_t bc_flash_erase(uint32_t addr, uint32_t page_cnt)
{

	if((addr&(PAGE_SIZE-1))!= 0 && (addr+PAGE_SIZE*page_cnt)>APP_SIZE)
		return 1;
	addr += APP_START_ADDR;
    1a06:	18e4      	adds	r4, r4, r3
#ifndef RELEASE
		printf( "erase data addr=0x%08x\r\n", addr);
#endif
	QSPI_Init();
    1a08:	f7ff fd44 	bl	1494 <QSPI_Init>
	for(int i = 0; i < page_cnt; ++i){
    1a0c:	42ae      	cmp	r6, r5
    1a0e:	d006      	beq.n	1a1e <bc_flash_erase+0x36>
		QSPI_PageEraseFlash(addr+i*PAGE_SIZE);
    1a10:	0020      	movs	r0, r4
    1a12:	3401      	adds	r4, #1
    1a14:	f7ff fcc4 	bl	13a0 <QSPI_PageEraseFlash>
	addr += APP_START_ADDR;
#ifndef RELEASE
		printf( "erase data addr=0x%08x\r\n", addr);
#endif
	QSPI_Init();
	for(int i = 0; i < page_cnt; ++i){
    1a18:	3601      	adds	r6, #1
    1a1a:	34ff      	adds	r4, #255	; 0xff
    1a1c:	e7f6      	b.n	1a0c <bc_flash_erase+0x24>
		QSPI_PageEraseFlash(addr+i*PAGE_SIZE);
	}
	return 0;	
    1a1e:	2000      	movs	r0, #0
}
    1a20:	bd70      	pop	{r4, r5, r6, pc}
    1a22:	46c0      	nop			; (mov r8, r8)
    1a24:	0007e600 	.word	0x0007e600

00001a28 <bc_flash_read>:

uint32_t bc_flash_read(uint32_t addr, uint32_t len, uint8_t* buf)
{
    1a28:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    1a2a:	0005      	movs	r5, r0
    1a2c:	000e      	movs	r6, r1
    1a2e:	0017      	movs	r7, r2
	if(len < 1 ||(((addr+len-1)&PAGE_MASK) != ((addr)&PAGE_MASK)) || buf == NULL){
		return 1;
    1a30:	2401      	movs	r4, #1
	return 0;	
}

uint32_t bc_flash_read(uint32_t addr, uint32_t len, uint8_t* buf)
{
	if(len < 1 ||(((addr+len-1)&PAGE_MASK) != ((addr)&PAGE_MASK)) || buf == NULL){
    1a32:	2900      	cmp	r1, #0
    1a34:	d011      	beq.n	1a5a <bc_flash_read+0x32>
    1a36:	23ff      	movs	r3, #255	; 0xff
    1a38:	1e44      	subs	r4, r0, #1
    1a3a:	1864      	adds	r4, r4, r1
    1a3c:	4044      	eors	r4, r0
    1a3e:	439c      	bics	r4, r3
    1a40:	d10a      	bne.n	1a58 <bc_flash_read+0x30>
    1a42:	2a00      	cmp	r2, #0
    1a44:	d008      	beq.n	1a58 <bc_flash_read+0x30>
	}
	addr += APP_START_ADDR;
#ifndef RELEASE
	printf("read addr=%08xx\r\n", addr);
#endif
	QSPI_Init();
    1a46:	f7ff fd25 	bl	1494 <QSPI_Init>
	QSPI_ReadFlashData(addr,len,buf);
    1a4a:	4b05      	ldr	r3, [pc, #20]	; (1a60 <bc_flash_read+0x38>)
    1a4c:	003a      	movs	r2, r7
    1a4e:	18e8      	adds	r0, r5, r3
    1a50:	0031      	movs	r1, r6
    1a52:	f7ff fa25 	bl	ea0 <QSPI_ReadFlashData>
		printf("%02x ", buf[i]);
	}
	printf("\r\n");
#endif

	return 0;
    1a56:	e000      	b.n	1a5a <bc_flash_read+0x32>
}

uint32_t bc_flash_read(uint32_t addr, uint32_t len, uint8_t* buf)
{
	if(len < 1 ||(((addr+len-1)&PAGE_MASK) != ((addr)&PAGE_MASK)) || buf == NULL){
		return 1;
    1a58:	2401      	movs	r4, #1
	}
	printf("\r\n");
#endif

	return 0;
}
    1a5a:	0020      	movs	r0, r4
    1a5c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    1a5e:	46c0      	nop			; (mov r8, r8)
    1a60:	0007e600 	.word	0x0007e600

00001a64 <bc_flash_write>:

uint32_t bc_flash_write(uint32_t addr, uint32_t len, uint8_t* buf)
{
    1a64:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    1a66:	0005      	movs	r5, r0
    1a68:	000e      	movs	r6, r1
    1a6a:	0017      	movs	r7, r2
	if(len < 1 || (((addr+len-1)&PAGE_MASK) != ((addr)&PAGE_MASK))|| buf == NULL){
		return 1;
    1a6c:	2401      	movs	r4, #1
	return 0;
}

uint32_t bc_flash_write(uint32_t addr, uint32_t len, uint8_t* buf)
{
	if(len < 1 || (((addr+len-1)&PAGE_MASK) != ((addr)&PAGE_MASK))|| buf == NULL){
    1a6e:	2900      	cmp	r1, #0
    1a70:	d011      	beq.n	1a96 <bc_flash_write+0x32>
    1a72:	23ff      	movs	r3, #255	; 0xff
    1a74:	1e44      	subs	r4, r0, #1
    1a76:	1864      	adds	r4, r4, r1
    1a78:	4044      	eors	r4, r0
    1a7a:	439c      	bics	r4, r3
    1a7c:	d10a      	bne.n	1a94 <bc_flash_write+0x30>
    1a7e:	2a00      	cmp	r2, #0
    1a80:	d008      	beq.n	1a94 <bc_flash_write+0x30>
	}
	addr += APP_START_ADDR;
#ifndef RELEASE
	printf("write addr = %08x\r\n", addr);
#endif
	QSPI_Init();
    1a82:	f7ff fd07 	bl	1494 <QSPI_Init>
	QSPI_WriteFlashData(addr,len,buf);
    1a86:	4b05      	ldr	r3, [pc, #20]	; (1a9c <bc_flash_write+0x38>)
    1a88:	003a      	movs	r2, r7
    1a8a:	18e8      	adds	r0, r5, r3
    1a8c:	0031      	movs	r1, r6
    1a8e:	f7ff fb47 	bl	1120 <QSPI_WriteFlashData>
#ifndef RELEASE
	printf("write end\r\n");
#endif
	return 0;
    1a92:	e000      	b.n	1a96 <bc_flash_write+0x32>
}

uint32_t bc_flash_write(uint32_t addr, uint32_t len, uint8_t* buf)
{
	if(len < 1 || (((addr+len-1)&PAGE_MASK) != ((addr)&PAGE_MASK))|| buf == NULL){
		return 1;
    1a94:	2401      	movs	r4, #1
	QSPI_WriteFlashData(addr,len,buf);
#ifndef RELEASE
	printf("write end\r\n");
#endif
	return 0;
}
    1a96:	0020      	movs	r0, r4
    1a98:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    1a9a:	46c0      	nop			; (mov r8, r8)
    1a9c:	0007e600 	.word	0x0007e600

00001aa0 <HW_REG_16BIT>:
#define OS_EXIT_CRITICAL() __enable_irq() 


static inline void HW_REG_16BIT(uint32_t reg, uint16_t word)
{
    HW_REG_8BIT(reg, word & 0x00FF);
    1aa0:	b2cb      	uxtb	r3, r1
    1aa2:	7003      	strb	r3, [r0, #0]

#define BW(addr)			(int)*(addr) << 24 | (int)*(addr + 1) << 16 | (int)*(addr + 2) << 8 | *(addr + 3)

static inline void hw_delay() 
{
	__asm__ __volatile__("nop");
    1aa4:	46c0      	nop			; (mov r8, r8)
	__asm__ __volatile__("nop");
    1aa6:	46c0      	nop			; (mov r8, r8)
	__asm__ __volatile__("nop");
    1aa8:	46c0      	nop			; (mov r8, r8)
	__asm__ __volatile__("nop");
    1aaa:	46c0      	nop			; (mov r8, r8)
	__asm__ __volatile__("nop");
    1aac:	46c0      	nop			; (mov r8, r8)
    hw_delay();
    HW_REG_8BIT(reg + 1,(word >> 8));
    1aae:	0a09      	lsrs	r1, r1, #8
    1ab0:	7041      	strb	r1, [r0, #1]
}
    1ab2:	4770      	bx	lr

00001ab4 <PWM_Init>:

void PWM_Init(uint8_t channel, struct PWM_CTRL_BITS *bits)
{
	tPWM_CTRL_REG_GRP *pwm = (tPWM_CTRL_REG_GRP *)(reg_map(PWM_BASE));
	//pwm0
	if (channel&PWM_CH0)	pwm ->PWM0.bits = *bits;
    1ab4:	07c3      	lsls	r3, r0, #31
    1ab6:	d502      	bpl.n	1abe <PWM_Init+0xa>
    1ab8:	780a      	ldrb	r2, [r1, #0]
    1aba:	4b13      	ldr	r3, [pc, #76]	; (1b08 <PWM_Init+0x54>)
    1abc:	711a      	strb	r2, [r3, #4]
	//pwm1
	if (channel&PWM_CH1)	pwm ->PWM1.bits = *bits;
    1abe:	0783      	lsls	r3, r0, #30
    1ac0:	d502      	bpl.n	1ac8 <PWM_Init+0x14>
    1ac2:	780a      	ldrb	r2, [r1, #0]
    1ac4:	4b10      	ldr	r3, [pc, #64]	; (1b08 <PWM_Init+0x54>)
    1ac6:	725a      	strb	r2, [r3, #9]
	//pwm2
	if (channel&PWM_CH2)	pwm ->PWM2.bits = *bits;
    1ac8:	0743      	lsls	r3, r0, #29
    1aca:	d502      	bpl.n	1ad2 <PWM_Init+0x1e>
    1acc:	780a      	ldrb	r2, [r1, #0]
    1ace:	4b0e      	ldr	r3, [pc, #56]	; (1b08 <PWM_Init+0x54>)
    1ad0:	739a      	strb	r2, [r3, #14]
	//pwm3
	if (channel&PWM_CH3)	pwm ->PWM3.bits = *bits;
    1ad2:	0703      	lsls	r3, r0, #28
    1ad4:	d502      	bpl.n	1adc <PWM_Init+0x28>
    1ad6:	780a      	ldrb	r2, [r1, #0]
    1ad8:	4b0b      	ldr	r3, [pc, #44]	; (1b08 <PWM_Init+0x54>)
    1ada:	74da      	strb	r2, [r3, #19]
	//pwm4
	if (channel&PWM_CH4)	pwm ->PWM4.bits = *bits;
    1adc:	06c3      	lsls	r3, r0, #27
    1ade:	d502      	bpl.n	1ae6 <PWM_Init+0x32>
    1ae0:	780a      	ldrb	r2, [r1, #0]
    1ae2:	4b09      	ldr	r3, [pc, #36]	; (1b08 <PWM_Init+0x54>)
    1ae4:	761a      	strb	r2, [r3, #24]
	//pwm5
	if (channel&PWM_CH5)	pwm ->PWM5.bits = *bits;
    1ae6:	0683      	lsls	r3, r0, #26
    1ae8:	d502      	bpl.n	1af0 <PWM_Init+0x3c>
    1aea:	780a      	ldrb	r2, [r1, #0]
    1aec:	4b06      	ldr	r3, [pc, #24]	; (1b08 <PWM_Init+0x54>)
    1aee:	775a      	strb	r2, [r3, #29]
	//pwm6
	if (channel&PWM_CH6)	pwm ->PWM6.bits = *bits;
    1af0:	0643      	lsls	r3, r0, #25
    1af2:	d502      	bpl.n	1afa <PWM_Init+0x46>
    1af4:	780a      	ldrb	r2, [r1, #0]
    1af6:	4b05      	ldr	r3, [pc, #20]	; (1b0c <PWM_Init+0x58>)
    1af8:	77da      	strb	r2, [r3, #31]
	//pwm7
	if (channel&PWM_CH7)	pwm ->PWM7.bits = *bits;
    1afa:	b240      	sxtb	r0, r0
    1afc:	2800      	cmp	r0, #0
    1afe:	da02      	bge.n	1b06 <PWM_Init+0x52>
    1b00:	780a      	ldrb	r2, [r1, #0]
    1b02:	4b03      	ldr	r3, [pc, #12]	; (1b10 <PWM_Init+0x5c>)
    1b04:	77da      	strb	r2, [r3, #31]
}
    1b06:	4770      	bx	lr
    1b08:	100080cd 	.word	0x100080cd
    1b0c:	100080d0 	.word	0x100080d0
    1b10:	100080d5 	.word	0x100080d5

00001b14 <PWM_DeInit>:

void PWM_DeInit(uint8_t channel)
{
	tPWM_CTRL_REG_GRP *pwm = (tPWM_CTRL_REG_GRP *)(reg_map(PWM_BASE));
	//pwm0
	if (channel&PWM_CH0)	pwm ->PWM0.bits.ENABLE = PWM_DISABLE;
    1b14:	07c3      	lsls	r3, r0, #31
    1b16:	d504      	bpl.n	1b22 <PWM_DeInit+0xe>
    1b18:	2120      	movs	r1, #32
    1b1a:	4a1b      	ldr	r2, [pc, #108]	; (1b88 <PWM_DeInit+0x74>)
    1b1c:	7913      	ldrb	r3, [r2, #4]
    1b1e:	438b      	bics	r3, r1
    1b20:	7113      	strb	r3, [r2, #4]
	//pwm1
	if (channel&PWM_CH1)	pwm ->PWM1.bits.ENABLE = PWM_DISABLE;
    1b22:	0783      	lsls	r3, r0, #30
    1b24:	d504      	bpl.n	1b30 <PWM_DeInit+0x1c>
    1b26:	2120      	movs	r1, #32
    1b28:	4a17      	ldr	r2, [pc, #92]	; (1b88 <PWM_DeInit+0x74>)
    1b2a:	7a53      	ldrb	r3, [r2, #9]
    1b2c:	438b      	bics	r3, r1
    1b2e:	7253      	strb	r3, [r2, #9]
	//pwm2
	if (channel&PWM_CH2)	pwm ->PWM2.bits.ENABLE = PWM_DISABLE;
    1b30:	0743      	lsls	r3, r0, #29
    1b32:	d504      	bpl.n	1b3e <PWM_DeInit+0x2a>
    1b34:	2120      	movs	r1, #32
    1b36:	4a14      	ldr	r2, [pc, #80]	; (1b88 <PWM_DeInit+0x74>)
    1b38:	7b93      	ldrb	r3, [r2, #14]
    1b3a:	438b      	bics	r3, r1
    1b3c:	7393      	strb	r3, [r2, #14]
	//pwm3
	if (channel&PWM_CH3)	pwm ->PWM3.bits.ENABLE = PWM_DISABLE;
    1b3e:	0703      	lsls	r3, r0, #28
    1b40:	d504      	bpl.n	1b4c <PWM_DeInit+0x38>
    1b42:	2120      	movs	r1, #32
    1b44:	4a10      	ldr	r2, [pc, #64]	; (1b88 <PWM_DeInit+0x74>)
    1b46:	7cd3      	ldrb	r3, [r2, #19]
    1b48:	438b      	bics	r3, r1
    1b4a:	74d3      	strb	r3, [r2, #19]
	//pwm4
	if (channel&PWM_CH4)	pwm ->PWM4.bits.ENABLE = PWM_DISABLE;
    1b4c:	06c3      	lsls	r3, r0, #27
    1b4e:	d504      	bpl.n	1b5a <PWM_DeInit+0x46>
    1b50:	2120      	movs	r1, #32
    1b52:	4a0d      	ldr	r2, [pc, #52]	; (1b88 <PWM_DeInit+0x74>)
    1b54:	7e13      	ldrb	r3, [r2, #24]
    1b56:	438b      	bics	r3, r1
    1b58:	7613      	strb	r3, [r2, #24]
	//pwm5
	if (channel&PWM_CH5)	pwm ->PWM5.bits.ENABLE = PWM_DISABLE;
    1b5a:	2120      	movs	r1, #32
    1b5c:	4208      	tst	r0, r1
    1b5e:	d003      	beq.n	1b68 <PWM_DeInit+0x54>
    1b60:	4a09      	ldr	r2, [pc, #36]	; (1b88 <PWM_DeInit+0x74>)
    1b62:	7f53      	ldrb	r3, [r2, #29]
    1b64:	438b      	bics	r3, r1
    1b66:	7753      	strb	r3, [r2, #29]
	//pwm6
	if (channel&PWM_CH6)	pwm ->PWM6.bits.ENABLE = PWM_DISABLE;
    1b68:	0643      	lsls	r3, r0, #25
    1b6a:	d504      	bpl.n	1b76 <PWM_DeInit+0x62>
    1b6c:	2120      	movs	r1, #32
    1b6e:	4a07      	ldr	r2, [pc, #28]	; (1b8c <PWM_DeInit+0x78>)
    1b70:	7fd3      	ldrb	r3, [r2, #31]
    1b72:	438b      	bics	r3, r1
    1b74:	77d3      	strb	r3, [r2, #31]
	//pwm7
	if (channel&PWM_CH7)	pwm ->PWM7.bits.ENABLE = PWM_DISABLE;
    1b76:	b240      	sxtb	r0, r0
    1b78:	2800      	cmp	r0, #0
    1b7a:	da04      	bge.n	1b86 <PWM_DeInit+0x72>
    1b7c:	2120      	movs	r1, #32
    1b7e:	4a04      	ldr	r2, [pc, #16]	; (1b90 <PWM_DeInit+0x7c>)
    1b80:	7fd3      	ldrb	r3, [r2, #31]
    1b82:	438b      	bics	r3, r1
    1b84:	77d3      	strb	r3, [r2, #31]
}
    1b86:	4770      	bx	lr
    1b88:	100080cd 	.word	0x100080cd
    1b8c:	100080d0 	.word	0x100080d0
    1b90:	100080d5 	.word	0x100080d5

00001b94 <PWM_Start>:

void PWM_Start(uint8_t channel)
{
	tPWM_CTRL_REG_GRP *pwm = (tPWM_CTRL_REG_GRP *)(reg_map(PWM_BASE));
	//pwm0
	if (channel&PWM_CH0)	pwm ->PWM0.bits.ENABLE = PWM_ENABLE;
    1b94:	07c3      	lsls	r3, r0, #31
    1b96:	d504      	bpl.n	1ba2 <PWM_Start+0xe>
    1b98:	2120      	movs	r1, #32
    1b9a:	4a1b      	ldr	r2, [pc, #108]	; (1c08 <PWM_Start+0x74>)
    1b9c:	7913      	ldrb	r3, [r2, #4]
    1b9e:	430b      	orrs	r3, r1
    1ba0:	7113      	strb	r3, [r2, #4]
	//pwm1
	if (channel&PWM_CH1)	pwm ->PWM1.bits.ENABLE = PWM_ENABLE;
    1ba2:	0783      	lsls	r3, r0, #30
    1ba4:	d504      	bpl.n	1bb0 <PWM_Start+0x1c>
    1ba6:	2120      	movs	r1, #32
    1ba8:	4a17      	ldr	r2, [pc, #92]	; (1c08 <PWM_Start+0x74>)
    1baa:	7a53      	ldrb	r3, [r2, #9]
    1bac:	430b      	orrs	r3, r1
    1bae:	7253      	strb	r3, [r2, #9]
	//pwm2
	if (channel&PWM_CH2)	pwm ->PWM2.bits.ENABLE = PWM_ENABLE;
    1bb0:	0743      	lsls	r3, r0, #29
    1bb2:	d504      	bpl.n	1bbe <PWM_Start+0x2a>
    1bb4:	2120      	movs	r1, #32
    1bb6:	4a14      	ldr	r2, [pc, #80]	; (1c08 <PWM_Start+0x74>)
    1bb8:	7b93      	ldrb	r3, [r2, #14]
    1bba:	430b      	orrs	r3, r1
    1bbc:	7393      	strb	r3, [r2, #14]
	//pwm3
	if (channel&PWM_CH3)	pwm ->PWM3.bits.ENABLE = PWM_ENABLE;
    1bbe:	0703      	lsls	r3, r0, #28
    1bc0:	d504      	bpl.n	1bcc <PWM_Start+0x38>
    1bc2:	2120      	movs	r1, #32
    1bc4:	4a10      	ldr	r2, [pc, #64]	; (1c08 <PWM_Start+0x74>)
    1bc6:	7cd3      	ldrb	r3, [r2, #19]
    1bc8:	430b      	orrs	r3, r1
    1bca:	74d3      	strb	r3, [r2, #19]
	//pwm4
	if (channel&PWM_CH4)	pwm ->PWM4.bits.ENABLE = PWM_ENABLE;
    1bcc:	06c3      	lsls	r3, r0, #27
    1bce:	d504      	bpl.n	1bda <PWM_Start+0x46>
    1bd0:	2120      	movs	r1, #32
    1bd2:	4a0d      	ldr	r2, [pc, #52]	; (1c08 <PWM_Start+0x74>)
    1bd4:	7e13      	ldrb	r3, [r2, #24]
    1bd6:	430b      	orrs	r3, r1
    1bd8:	7613      	strb	r3, [r2, #24]
	//pwm5
	if (channel&PWM_CH5)	pwm ->PWM5.bits.ENABLE = PWM_ENABLE;
    1bda:	2120      	movs	r1, #32
    1bdc:	4208      	tst	r0, r1
    1bde:	d003      	beq.n	1be8 <PWM_Start+0x54>
    1be0:	4a09      	ldr	r2, [pc, #36]	; (1c08 <PWM_Start+0x74>)
    1be2:	7f53      	ldrb	r3, [r2, #29]
    1be4:	430b      	orrs	r3, r1
    1be6:	7753      	strb	r3, [r2, #29]
	//pwm6
	if (channel&PWM_CH6)	pwm ->PWM6.bits.ENABLE = PWM_ENABLE;
    1be8:	0643      	lsls	r3, r0, #25
    1bea:	d504      	bpl.n	1bf6 <PWM_Start+0x62>
    1bec:	2120      	movs	r1, #32
    1bee:	4a07      	ldr	r2, [pc, #28]	; (1c0c <PWM_Start+0x78>)
    1bf0:	7fd3      	ldrb	r3, [r2, #31]
    1bf2:	430b      	orrs	r3, r1
    1bf4:	77d3      	strb	r3, [r2, #31]
	//pwm7
	if (channel&PWM_CH7)	pwm ->PWM7.bits.ENABLE = PWM_ENABLE;
    1bf6:	b240      	sxtb	r0, r0
    1bf8:	2800      	cmp	r0, #0
    1bfa:	da04      	bge.n	1c06 <PWM_Start+0x72>
    1bfc:	2120      	movs	r1, #32
    1bfe:	4a04      	ldr	r2, [pc, #16]	; (1c10 <PWM_Start+0x7c>)
    1c00:	7fd3      	ldrb	r3, [r2, #31]
    1c02:	430b      	orrs	r3, r1
    1c04:	77d3      	strb	r3, [r2, #31]
}
    1c06:	4770      	bx	lr
    1c08:	100080cd 	.word	0x100080cd
    1c0c:	100080d0 	.word	0x100080d0
    1c10:	100080d5 	.word	0x100080d5

00001c14 <PWM_SetPnCnt>:


void PWM_SetPnCnt(uint8_t channel, uint16_t pcnt, uint16_t ncnt)
{
    1c14:	b570      	push	{r4, r5, r6, lr}
    1c16:	0004      	movs	r4, r0
    1c18:	000d      	movs	r5, r1
    1c1a:	0016      	movs	r6, r2
	//tPWM_CTRL_REG_GRP *pwm = (tPWM_CTRL_REG_GRP *)(reg_map(PWM_BASE));

	
	if (channel&PWM_CH0) {
    1c1c:	07c3      	lsls	r3, r0, #31
    1c1e:	d507      	bpl.n	1c30 <PWM_SetPnCnt+0x1c>
		HW_REG_16BIT(reg_map(CORE_PWM0_NCNT), ncnt);
    1c20:	0011      	movs	r1, r2
    1c22:	4827      	ldr	r0, [pc, #156]	; (1cc0 <PWM_SetPnCnt+0xac>)
    1c24:	f7ff ff3c 	bl	1aa0 <HW_REG_16BIT>
		HW_REG_16BIT(reg_map(CORE_PWM0_PCNT), pcnt);
    1c28:	0029      	movs	r1, r5
    1c2a:	4826      	ldr	r0, [pc, #152]	; (1cc4 <PWM_SetPnCnt+0xb0>)
    1c2c:	f7ff ff38 	bl	1aa0 <HW_REG_16BIT>
	}

	if (channel&PWM_CH1) {
    1c30:	07a3      	lsls	r3, r4, #30
    1c32:	d507      	bpl.n	1c44 <PWM_SetPnCnt+0x30>
		HW_REG_16BIT(reg_map(CORE_PWM1_NCNT), ncnt);
    1c34:	0031      	movs	r1, r6
    1c36:	4824      	ldr	r0, [pc, #144]	; (1cc8 <PWM_SetPnCnt+0xb4>)
    1c38:	f7ff ff32 	bl	1aa0 <HW_REG_16BIT>
		HW_REG_16BIT(reg_map(CORE_PWM1_PCNT), pcnt);
    1c3c:	0029      	movs	r1, r5
    1c3e:	4823      	ldr	r0, [pc, #140]	; (1ccc <PWM_SetPnCnt+0xb8>)
    1c40:	f7ff ff2e 	bl	1aa0 <HW_REG_16BIT>
	}

	if (channel&PWM_CH2) {
    1c44:	0763      	lsls	r3, r4, #29
    1c46:	d507      	bpl.n	1c58 <PWM_SetPnCnt+0x44>
		HW_REG_16BIT(reg_map(CORE_PWM2_NCNT), ncnt);
    1c48:	0031      	movs	r1, r6
    1c4a:	4821      	ldr	r0, [pc, #132]	; (1cd0 <PWM_SetPnCnt+0xbc>)
    1c4c:	f7ff ff28 	bl	1aa0 <HW_REG_16BIT>
		HW_REG_16BIT(reg_map(CORE_PWM2_PCNT), pcnt);
    1c50:	0029      	movs	r1, r5
    1c52:	4820      	ldr	r0, [pc, #128]	; (1cd4 <PWM_SetPnCnt+0xc0>)
    1c54:	f7ff ff24 	bl	1aa0 <HW_REG_16BIT>
	}

	if (channel&PWM_CH3) {
    1c58:	0723      	lsls	r3, r4, #28
    1c5a:	d507      	bpl.n	1c6c <PWM_SetPnCnt+0x58>
		HW_REG_16BIT(reg_map(CORE_PWM3_NCNT), ncnt);
    1c5c:	0031      	movs	r1, r6
    1c5e:	481e      	ldr	r0, [pc, #120]	; (1cd8 <PWM_SetPnCnt+0xc4>)
    1c60:	f7ff ff1e 	bl	1aa0 <HW_REG_16BIT>
		HW_REG_16BIT(reg_map(CORE_PWM3_PCNT), pcnt);
    1c64:	0029      	movs	r1, r5
    1c66:	481d      	ldr	r0, [pc, #116]	; (1cdc <PWM_SetPnCnt+0xc8>)
    1c68:	f7ff ff1a 	bl	1aa0 <HW_REG_16BIT>
	}

	if (channel&PWM_CH4) {
    1c6c:	06e3      	lsls	r3, r4, #27
    1c6e:	d507      	bpl.n	1c80 <PWM_SetPnCnt+0x6c>
		HW_REG_16BIT(reg_map(CORE_PWM4_NCNT), ncnt);
    1c70:	0031      	movs	r1, r6
    1c72:	481b      	ldr	r0, [pc, #108]	; (1ce0 <PWM_SetPnCnt+0xcc>)
    1c74:	f7ff ff14 	bl	1aa0 <HW_REG_16BIT>
		HW_REG_16BIT(reg_map(CORE_PWM4_PCNT), pcnt);
    1c78:	0029      	movs	r1, r5
    1c7a:	481a      	ldr	r0, [pc, #104]	; (1ce4 <PWM_SetPnCnt+0xd0>)
    1c7c:	f7ff ff10 	bl	1aa0 <HW_REG_16BIT>
	}

	if (channel&PWM_CH5) {
    1c80:	06a3      	lsls	r3, r4, #26
    1c82:	d507      	bpl.n	1c94 <PWM_SetPnCnt+0x80>
		HW_REG_16BIT(reg_map(CORE_PWM5_NCNT), ncnt);
    1c84:	0031      	movs	r1, r6
    1c86:	4818      	ldr	r0, [pc, #96]	; (1ce8 <PWM_SetPnCnt+0xd4>)
    1c88:	f7ff ff0a 	bl	1aa0 <HW_REG_16BIT>
		HW_REG_16BIT(reg_map(CORE_PWM5_PCNT), pcnt);
    1c8c:	0029      	movs	r1, r5
    1c8e:	4817      	ldr	r0, [pc, #92]	; (1cec <PWM_SetPnCnt+0xd8>)
    1c90:	f7ff ff06 	bl	1aa0 <HW_REG_16BIT>
	}

	if (channel&PWM_CH6) {
    1c94:	0663      	lsls	r3, r4, #25
    1c96:	d507      	bpl.n	1ca8 <PWM_SetPnCnt+0x94>
		HW_REG_16BIT(reg_map(CORE_PWM6_NCNT), ncnt);
    1c98:	0031      	movs	r1, r6
    1c9a:	4815      	ldr	r0, [pc, #84]	; (1cf0 <PWM_SetPnCnt+0xdc>)
    1c9c:	f7ff ff00 	bl	1aa0 <HW_REG_16BIT>
		HW_REG_16BIT(reg_map(CORE_PWM6_PCNT), pcnt);
    1ca0:	0029      	movs	r1, r5
    1ca2:	4814      	ldr	r0, [pc, #80]	; (1cf4 <PWM_SetPnCnt+0xe0>)
    1ca4:	f7ff fefc 	bl	1aa0 <HW_REG_16BIT>
	}

	if (channel&PWM_CH7) {
    1ca8:	b264      	sxtb	r4, r4
    1caa:	2c00      	cmp	r4, #0
    1cac:	da07      	bge.n	1cbe <PWM_SetPnCnt+0xaa>
		HW_REG_16BIT(reg_map(CORE_PWM7_NCNT), ncnt);
    1cae:	0031      	movs	r1, r6
    1cb0:	4811      	ldr	r0, [pc, #68]	; (1cf8 <PWM_SetPnCnt+0xe4>)
    1cb2:	f7ff fef5 	bl	1aa0 <HW_REG_16BIT>
		HW_REG_16BIT(reg_map(CORE_PWM7_PCNT), pcnt);
    1cb6:	0029      	movs	r1, r5
    1cb8:	4810      	ldr	r0, [pc, #64]	; (1cfc <PWM_SetPnCnt+0xe8>)
    1cba:	f7ff fef1 	bl	1aa0 <HW_REG_16BIT>
	}

}
    1cbe:	bd70      	pop	{r4, r5, r6, pc}
    1cc0:	100080cf 	.word	0x100080cf
    1cc4:	100080cd 	.word	0x100080cd
    1cc8:	100080d4 	.word	0x100080d4
    1ccc:	100080d2 	.word	0x100080d2
    1cd0:	100080d9 	.word	0x100080d9
    1cd4:	100080d7 	.word	0x100080d7
    1cd8:	100080de 	.word	0x100080de
    1cdc:	100080dc 	.word	0x100080dc
    1ce0:	100080e3 	.word	0x100080e3
    1ce4:	100080e1 	.word	0x100080e1
    1ce8:	100080e8 	.word	0x100080e8
    1cec:	100080e6 	.word	0x100080e6
    1cf0:	100080ed 	.word	0x100080ed
    1cf4:	100080eb 	.word	0x100080eb
    1cf8:	100080f2 	.word	0x100080f2
    1cfc:	100080f0 	.word	0x100080f0

00001d00 <SYS_TimerExpireDefaultHandle>:

void SYS_TimerExpireDefaultHandle(int params)
{
	// YC_LOG_ERROR("default timer expire !\r\n");
	while(0);
}
    1d00:	4770      	bx	lr

00001d02 <SYS_TimerInit>:

void SYS_TimerInit()
{
	//initial timer lists
	pheader = &header_Timer;
    1d02:	4b0d      	ldr	r3, [pc, #52]	; (1d38 <SYS_TimerInit+0x36>)
    1d04:	4a0d      	ldr	r2, [pc, #52]	; (1d3c <SYS_TimerInit+0x3a>)
	// YC_LOG_ERROR("default timer expire !\r\n");
	while(0);
}

void SYS_TimerInit()
{
    1d06:	b510      	push	{r4, lr}
	//initial timer lists
	pheader = &header_Timer;
    1d08:	6013      	str	r3, [r2, #0]
	pheader->pNextTimer = NULL;
	pheader->pfExpireCb = SYS_TimerExpireDefaultHandle;
    1d0a:	4a0d      	ldr	r2, [pc, #52]	; (1d40 <SYS_TimerInit+0x3e>)

void SYS_TimerInit()
{
	//initial timer lists
	pheader = &header_Timer;
	pheader->pNextTimer = NULL;
    1d0c:	2100      	movs	r1, #0
	pheader->pfExpireCb = SYS_TimerExpireDefaultHandle;
    1d0e:	60da      	str	r2, [r3, #12]
	pheader->mTimerStatus = TIMER_START;
    1d10:	2201      	movs	r2, #1
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) < 0)
  {
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
    1d12:	24c0      	movs	r4, #192	; 0xc0
    1d14:	721a      	strb	r2, [r3, #8]
	pheader->mTimerValue = 0;
    1d16:	6019      	str	r1, [r3, #0]

void SYS_TimerInit()
{
	//initial timer lists
	pheader = &header_Timer;
	pheader->pNextTimer = NULL;
    1d18:	6119      	str	r1, [r3, #16]
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
  {
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
    1d1a:	4a0a      	ldr	r2, [pc, #40]	; (1d44 <SYS_TimerInit+0x42>)
    1d1c:	4b0a      	ldr	r3, [pc, #40]	; (1d48 <SYS_TimerInit+0x46>)
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) < 0)
  {
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
    1d1e:	480b      	ldr	r0, [pc, #44]	; (1d4c <SYS_TimerInit+0x4a>)
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
  {
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
    1d20:	6053      	str	r3, [r2, #4]
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) < 0)
  {
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
    1d22:	6a03      	ldr	r3, [r0, #32]
    1d24:	0624      	lsls	r4, r4, #24
    1d26:	021b      	lsls	r3, r3, #8
    1d28:	0a1b      	lsrs	r3, r3, #8
    1d2a:	4323      	orrs	r3, r4
    1d2c:	6203      	str	r3, [r0, #32]
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
    1d2e:	2307      	movs	r3, #7
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
    1d30:	6091      	str	r1, [r2, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
    1d32:	6013      	str	r3, [r2, #0]
	pheader->pfExpireCb = SYS_TimerExpireDefaultHandle;
	pheader->mTimerStatus = TIMER_START;
	pheader->mTimerValue = 0;

	SysTick_Config(SYSTEM_CLOCK/1000); //each  systick interrupt is 1ms
}
    1d34:	bd10      	pop	{r4, pc}
    1d36:	46c0      	nop			; (mov r8, r8)
    1d38:	10012824 	.word	0x10012824
    1d3c:	10012820 	.word	0x10012820
    1d40:	00001d01 	.word	0x00001d01
    1d44:	e000e010 	.word	0xe000e010
    1d48:	00005dbf 	.word	0x00005dbf
    1d4c:	e000ed00 	.word	0xe000ed00

00001d50 <SYS_SetTimer>:


//union is 10ms
bool SYS_SetTimer(SYS_TIMER_TYPE *pTimer, int tick,TIMER_TYPE isSingle,Timer_Expire_CB pfExpire_CB)
{
    1d50:	b570      	push	{r4, r5, r6, lr}
    1d52:	1e04      	subs	r4, r0, #0
	SYS_TIMER_TYPE *pTemp;
	if(pTimer == NULL)
    1d54:	d01c      	beq.n	1d90 <SYS_SetTimer+0x40>
	{
		return false;
	}
	
	if (pfExpire_CB == NULL)
    1d56:	2b00      	cmp	r3, #0
    1d58:	d102      	bne.n	1d60 <SYS_SetTimer+0x10>
	{
		pTimer->pfExpireCb = SYS_TimerExpireDefaultHandle;
    1d5a:	4b0e      	ldr	r3, [pc, #56]	; (1d94 <SYS_SetTimer+0x44>)
    1d5c:	60c3      	str	r3, [r0, #12]
    1d5e:	e000      	b.n	1d62 <SYS_SetTimer+0x12>
	}
	else
	{
		pTimer->pfExpireCb = pfExpire_CB;
    1d60:	60c3      	str	r3, [r0, #12]
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
    1d62:	b672      	cpsid	i
	}
	OS_ENTER_CRITICAL();
	pTimer->mTick = tick;
	pTimer->mTimerValue = sys_tick_count+tick;
	pTimer->mTimerStatus = TIMER_START;
    1d64:	2501      	movs	r5, #1
	{
		pTimer->pfExpireCb = pfExpire_CB;
	}
	OS_ENTER_CRITICAL();
	pTimer->mTick = tick;
	pTimer->mTimerValue = sys_tick_count+tick;
    1d66:	4b0c      	ldr	r3, [pc, #48]	; (1d98 <SYS_SetTimer+0x48>)
	else
	{
		pTimer->pfExpireCb = pfExpire_CB;
	}
	OS_ENTER_CRITICAL();
	pTimer->mTick = tick;
    1d68:	6061      	str	r1, [r4, #4]
	pTimer->mTimerValue = sys_tick_count+tick;
    1d6a:	681b      	ldr	r3, [r3, #0]
	pTimer->mTimerStatus = TIMER_START;
    1d6c:	7225      	strb	r5, [r4, #8]
	{
		pTimer->pfExpireCb = pfExpire_CB;
	}
	OS_ENTER_CRITICAL();
	pTimer->mTick = tick;
	pTimer->mTimerValue = sys_tick_count+tick;
    1d6e:	1859      	adds	r1, r3, r1
    1d70:	6021      	str	r1, [r4, #0]
	pTimer->mTimerStatus = TIMER_START;
	pTimer->mIsCycle = isSingle;
    1d72:	7262      	strb	r2, [r4, #9]

	pTimer->cbParams = (int32_t)pTimer;
    1d74:	6164      	str	r4, [r4, #20]
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
    1d76:	b662      	cpsie	i
	OS_EXIT_CRITICAL();
	if (SYS_TimerisExist(pTimer))
    1d78:	0020      	movs	r0, r4
    1d7a:	f000 f811 	bl	1da0 <SYS_TimerisExist>
    1d7e:	2800      	cmp	r0, #0
    1d80:	d106      	bne.n	1d90 <SYS_SetTimer+0x40>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
    1d82:	b672      	cpsid	i
		//printf("timer exised and set timer success\r\n");
		return true;
	}
	OS_ENTER_CRITICAL();
	//insert to list
	pTemp = pheader;
    1d84:	4b05      	ldr	r3, [pc, #20]	; (1d9c <SYS_SetTimer+0x4c>)
    1d86:	681a      	ldr	r2, [r3, #0]
	pheader = pTimer;
    1d88:	601c      	str	r4, [r3, #0]
		//printf("timer exised and set timer success\r\n");
		return true;
	}
	OS_ENTER_CRITICAL();
	//insert to list
	pTemp = pheader;
    1d8a:	6122      	str	r2, [r4, #16]
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
    1d8c:	b662      	cpsie	i
	pheader = pTimer;
	pheader->pNextTimer = pTemp;
	OS_EXIT_CRITICAL();
	//printf("set timer success\n");
	//YC_LOG_INFO("set timer %d \r\n",pTimer->cbParams);
	return true;
    1d8e:	0028      	movs	r0, r5
}
    1d90:	bd70      	pop	{r4, r5, r6, pc}
    1d92:	46c0      	nop			; (mov r8, r8)
    1d94:	00001d01 	.word	0x00001d01
    1d98:	1001281c 	.word	0x1001281c
    1d9c:	10012820 	.word	0x10012820

00001da0 <SYS_TimerisExist>:

bool SYS_TimerisExist(SYS_TIMER_TYPE *pTimer)
{
    1da0:	1e01      	subs	r1, r0, #0
	SYS_TIMER_TYPE *pTemp;
	if (pTimer == NULL)
    1da2:	d00b      	beq.n	1dbc <SYS_TimerisExist+0x1c>
	{
		return false;
	}
	for(pTemp = pheader; pTemp->pNextTimer != NULL; pTemp = pTemp->pNextTimer)
    1da4:	4b06      	ldr	r3, [pc, #24]	; (1dc0 <SYS_TimerisExist+0x20>)
    1da6:	681a      	ldr	r2, [r3, #0]
    1da8:	6913      	ldr	r3, [r2, #16]
    1daa:	2b00      	cmp	r3, #0
    1dac:	d003      	beq.n	1db6 <SYS_TimerisExist+0x16>
	{
		if (pTimer == pTemp)
    1dae:	428a      	cmp	r2, r1
    1db0:	d003      	beq.n	1dba <SYS_TimerisExist+0x1a>
    1db2:	001a      	movs	r2, r3
    1db4:	e7f8      	b.n	1da8 <SYS_TimerisExist+0x8>
bool SYS_TimerisExist(SYS_TIMER_TYPE *pTimer)
{
	SYS_TIMER_TYPE *pTemp;
	if (pTimer == NULL)
	{
		return false;
    1db6:	0018      	movs	r0, r3
    1db8:	e000      	b.n	1dbc <SYS_TimerisExist+0x1c>
	}
	for(pTemp = pheader; pTemp->pNextTimer != NULL; pTemp = pTemp->pNextTimer)
	{
		if (pTimer == pTemp)
		{
			return true;
    1dba:	2001      	movs	r0, #1
		}
	}
	return false;
}
    1dbc:	4770      	bx	lr
    1dbe:	46c0      	nop			; (mov r8, r8)
    1dc0:	10012820 	.word	0x10012820

00001dc4 <SYS_ResetTimer>:


bool SYS_ResetTimer(SYS_TIMER_TYPE *pTimer)
{
    1dc4:	1e01      	subs	r1, r0, #0
	SYS_TIMER_TYPE *pTemp;
	if (pTimer == NULL)
    1dc6:	d010      	beq.n	1dea <SYS_ResetTimer+0x26>
	{
		return false;
	}
	for(pTemp = pheader; pTemp->pNextTimer != NULL; pTemp = pTemp->pNextTimer)
    1dc8:	4b08      	ldr	r3, [pc, #32]	; (1dec <SYS_ResetTimer+0x28>)
    1dca:	681a      	ldr	r2, [r3, #0]
    1dcc:	6913      	ldr	r3, [r2, #16]
    1dce:	2b00      	cmp	r3, #0
    1dd0:	d00a      	beq.n	1de8 <SYS_ResetTimer+0x24>
	{
		if (pTimer == pTemp)
    1dd2:	428a      	cmp	r2, r1
    1dd4:	d106      	bne.n	1de4 <SYS_ResetTimer+0x20>
		{
			pTimer->mTimerValue = sys_tick_count+(pTimer->mTick);
    1dd6:	4b06      	ldr	r3, [pc, #24]	; (1df0 <SYS_ResetTimer+0x2c>)
    1dd8:	6851      	ldr	r1, [r2, #4]
    1dda:	681b      	ldr	r3, [r3, #0]
			return true;
    1ddc:	2001      	movs	r0, #1
	}
	for(pTemp = pheader; pTemp->pNextTimer != NULL; pTemp = pTemp->pNextTimer)
	{
		if (pTimer == pTemp)
		{
			pTimer->mTimerValue = sys_tick_count+(pTimer->mTick);
    1dde:	18cb      	adds	r3, r1, r3
    1de0:	6013      	str	r3, [r2, #0]
			return true;
    1de2:	e002      	b.n	1dea <SYS_ResetTimer+0x26>
    1de4:	001a      	movs	r2, r3
    1de6:	e7f1      	b.n	1dcc <SYS_ResetTimer+0x8>
bool SYS_ResetTimer(SYS_TIMER_TYPE *pTimer)
{
	SYS_TIMER_TYPE *pTemp;
	if (pTimer == NULL)
	{
		return false;
    1de8:	0018      	movs	r0, r3
			pTimer->mTimerValue = sys_tick_count+(pTimer->mTick);
			return true;
		}
	}
	return false;
}
    1dea:	4770      	bx	lr
    1dec:	10012820 	.word	0x10012820
    1df0:	1001281c 	.word	0x1001281c

00001df4 <SYS_TimerTest>:
	for (pTimer = pheader; pTimer->pNextTimer != NULL; pTimer = pTimer->pNextTimer)
	{
		i++;
	}
	//YC_LOG_INFO("timer count %d \r\n",i);
}
    1df4:	4770      	bx	lr

00001df6 <SYS_timerPolling>:

void SYS_timerPolling()
{
    1df6:	b510      	push	{r4, lr}
	SYS_TIMER_TYPE *pTimer;
	
	if (sys_Timer_Check_Flag)
    1df8:	4b11      	ldr	r3, [pc, #68]	; (1e40 <SYS_timerPolling+0x4a>)
    1dfa:	781a      	ldrb	r2, [r3, #0]
    1dfc:	2a00      	cmp	r2, #0
    1dfe:	d01d      	beq.n	1e3c <SYS_timerPolling+0x46>
	{
		sys_Timer_Check_Flag = false;
    1e00:	2200      	movs	r2, #0
    1e02:	701a      	strb	r2, [r3, #0]
		//SYS_TimerTest();
	//	printf("2\n");
		for (pTimer = pheader; pTimer->pNextTimer != NULL; pTimer = pTimer->pNextTimer)
    1e04:	4b0f      	ldr	r3, [pc, #60]	; (1e44 <SYS_timerPolling+0x4e>)
    1e06:	681c      	ldr	r4, [r3, #0]
    1e08:	6923      	ldr	r3, [r4, #16]
    1e0a:	2b00      	cmp	r3, #0
    1e0c:	d016      	beq.n	1e3c <SYS_timerPolling+0x46>
		{
	//		printf("3\n");
			if (pTimer->mTimerStatus == TIMER_START)
    1e0e:	7a23      	ldrb	r3, [r4, #8]
    1e10:	2b01      	cmp	r3, #1
    1e12:	d111      	bne.n	1e38 <SYS_timerPolling+0x42>
			{
		//		printf("sys_tick_count = %d\n",sys_tick_count);
		//		printf("pTimer->mTimerValue = %d\n",pTimer->mTimerValue);
		//		printf("timer %d in\r\n",pTimer->cbParams);
				if (pTimer->mTimerValue <= sys_tick_count)
    1e14:	4b0c      	ldr	r3, [pc, #48]	; (1e48 <SYS_timerPolling+0x52>)
    1e16:	6822      	ldr	r2, [r4, #0]
    1e18:	681b      	ldr	r3, [r3, #0]
    1e1a:	429a      	cmp	r2, r3
    1e1c:	d80c      	bhi.n	1e38 <SYS_timerPolling+0x42>
				{
		//			printf("5\n");
					if (pTimer->mIsCycle == TIMER_SINGLE)
    1e1e:	7a62      	ldrb	r2, [r4, #9]
    1e20:	2a00      	cmp	r2, #0
    1e22:	d103      	bne.n	1e2c <SYS_timerPolling+0x36>
					{
				//		printf("timer release %d in\r\n",pTimer->cbParams);
						SYS_ReleaseTimer(pTimer);
    1e24:	0020      	movs	r0, r4
    1e26:	f000 f811 	bl	1e4c <SYS_ReleaseTimer>
    1e2a:	e002      	b.n	1e32 <SYS_timerPolling+0x3c>
					}
					else
					{					
				//		printf("timer cycle in\r\n");
				//		printf("timer release %d in\r\n",pTimer->cbParams);
						pTimer->mTimerValue = sys_tick_count+(pTimer->mTick);
    1e2c:	6862      	ldr	r2, [r4, #4]
    1e2e:	18d3      	adds	r3, r2, r3
    1e30:	6023      	str	r3, [r4, #0]
					}
			//		printf("6\n");
					pTimer->pfExpireCb(pTimer->cbParams);
    1e32:	6960      	ldr	r0, [r4, #20]
    1e34:	68e3      	ldr	r3, [r4, #12]
    1e36:	4798      	blx	r3
	if (sys_Timer_Check_Flag)
	{
		sys_Timer_Check_Flag = false;
		//SYS_TimerTest();
	//	printf("2\n");
		for (pTimer = pheader; pTimer->pNextTimer != NULL; pTimer = pTimer->pNextTimer)
    1e38:	6924      	ldr	r4, [r4, #16]
    1e3a:	e7e5      	b.n	1e08 <SYS_timerPolling+0x12>
					pTimer->pfExpireCb(pTimer->cbParams);
				}
			}
		}
	}
}
    1e3c:	bd10      	pop	{r4, pc}
    1e3e:	46c0      	nop			; (mov r8, r8)
    1e40:	1001283c 	.word	0x1001283c
    1e44:	10012820 	.word	0x10012820
    1e48:	1001281c 	.word	0x1001281c

00001e4c <SYS_ReleaseTimer>:

bool SYS_ReleaseTimer(SYS_TIMER_TYPE *pTimer)
{
    1e4c:	b510      	push	{r4, lr}
    1e4e:	1e01      	subs	r1, r0, #0
	SYS_TIMER_TYPE *pTemp, *pPre;
	if (pTimer == NULL)
    1e50:	d01a      	beq.n	1e88 <SYS_ReleaseTimer+0x3c>
	{
		return false;
	}

	if (pTimer == &header_Timer)
    1e52:	4b0e      	ldr	r3, [pc, #56]	; (1e8c <SYS_ReleaseTimer+0x40>)
bool SYS_ReleaseTimer(SYS_TIMER_TYPE *pTimer)
{
	SYS_TIMER_TYPE *pTemp, *pPre;
	if (pTimer == NULL)
	{
		return false;
    1e54:	2000      	movs	r0, #0
	}

	if (pTimer == &header_Timer)
    1e56:	4299      	cmp	r1, r3
    1e58:	d016      	beq.n	1e88 <SYS_ReleaseTimer+0x3c>
	{
		return false;
	}

	for(pTemp = pPre = pheader; pTemp->pNextTimer != NULL; pPre = pTemp,pTemp = pTemp->pNextTimer)
    1e5a:	4b0d      	ldr	r3, [pc, #52]	; (1e90 <SYS_ReleaseTimer+0x44>)
    1e5c:	681a      	ldr	r2, [r3, #0]
    1e5e:	0018      	movs	r0, r3
    1e60:	0014      	movs	r4, r2
    1e62:	6913      	ldr	r3, [r2, #16]
    1e64:	2b00      	cmp	r3, #0
    1e66:	d00e      	beq.n	1e86 <SYS_ReleaseTimer+0x3a>
	{
		if (pTimer == pTemp)
    1e68:	428a      	cmp	r2, r1
    1e6a:	d109      	bne.n	1e80 <SYS_ReleaseTimer+0x34>
		{
			pTemp->mTimerStatus = TIMER_STOP;
    1e6c:	2100      	movs	r1, #0
    1e6e:	7211      	strb	r1, [r2, #8]
			if (pPre == pTemp) //delete the first one element
    1e70:	4294      	cmp	r4, r2
    1e72:	d102      	bne.n	1e7a <SYS_ReleaseTimer+0x2e>
			{
				pheader = pTemp->pNextTimer;
    1e74:	6003      	str	r3, [r0, #0]
			{
				pPre->pNextTimer = pTemp->pNextTimer;
			}

			//YC_LOG_INFO("release timer %d,%d \r\n",pPre->cbParams,pTimer->cbParams);
			return true;
    1e76:	2001      	movs	r0, #1
    1e78:	e006      	b.n	1e88 <SYS_ReleaseTimer+0x3c>
			{
				pheader = pTemp->pNextTimer;
			}
			else
			{
				pPre->pNextTimer = pTemp->pNextTimer;
    1e7a:	6123      	str	r3, [r4, #16]
			}

			//YC_LOG_INFO("release timer %d,%d \r\n",pPre->cbParams,pTimer->cbParams);
			return true;
    1e7c:	2001      	movs	r0, #1
    1e7e:	e003      	b.n	1e88 <SYS_ReleaseTimer+0x3c>
    1e80:	0014      	movs	r4, r2
    1e82:	001a      	movs	r2, r3
    1e84:	e7ed      	b.n	1e62 <SYS_ReleaseTimer+0x16>
bool SYS_ReleaseTimer(SYS_TIMER_TYPE *pTimer)
{
	SYS_TIMER_TYPE *pTemp, *pPre;
	if (pTimer == NULL)
	{
		return false;
    1e86:	0018      	movs	r0, r3
			//YC_LOG_INFO("release timer %d,%d \r\n",pPre->cbParams,pTimer->cbParams);
			return true;
		}
	}
	return false;
}
    1e88:	bd10      	pop	{r4, pc}
    1e8a:	46c0      	nop			; (mov r8, r8)
    1e8c:	10012824 	.word	0x10012824
    1e90:	10012820 	.word	0x10012820

00001e94 <SYS_ReleaseAllTimer>:
void SYS_ReleaseAllTimer()
{
	SYS_TIMER_TYPE *pTemp;
	for(pTemp = pheader; pTemp->pNextTimer != NULL; pTemp = pTemp->pNextTimer)
	{
		pTemp->mTimerStatus = TIMER_STOP;
    1e94:	2000      	movs	r0, #0
}

void SYS_ReleaseAllTimer()
{
	SYS_TIMER_TYPE *pTemp;
	for(pTemp = pheader; pTemp->pNextTimer != NULL; pTemp = pTemp->pNextTimer)
    1e96:	4b05      	ldr	r3, [pc, #20]	; (1eac <SYS_ReleaseAllTimer+0x18>)
    1e98:	681a      	ldr	r2, [r3, #0]
    1e9a:	6911      	ldr	r1, [r2, #16]
    1e9c:	2900      	cmp	r1, #0
    1e9e:	d002      	beq.n	1ea6 <SYS_ReleaseAllTimer+0x12>
	{
		pTemp->mTimerStatus = TIMER_STOP;
    1ea0:	7210      	strb	r0, [r2, #8]
    1ea2:	000a      	movs	r2, r1
    1ea4:	e7f9      	b.n	1e9a <SYS_ReleaseAllTimer+0x6>
	}
	pheader = &header_Timer;
    1ea6:	4a02      	ldr	r2, [pc, #8]	; (1eb0 <SYS_ReleaseAllTimer+0x1c>)
    1ea8:	601a      	str	r2, [r3, #0]
}
    1eaa:	4770      	bx	lr
    1eac:	10012820 	.word	0x10012820
    1eb0:	10012824 	.word	0x10012824

00001eb4 <SYStick_handle>:

void SYStick_handle()
{
	if(++tmpCnt%10 == 0){//each	systick interrupt is 10ms
    1eb4:	4b08      	ldr	r3, [pc, #32]	; (1ed8 <SYStick_handle+0x24>)
	}
	pheader = &header_Timer;
}

void SYStick_handle()
{
    1eb6:	b510      	push	{r4, lr}
	if(++tmpCnt%10 == 0){//each	systick interrupt is 10ms
    1eb8:	681a      	ldr	r2, [r3, #0]
    1eba:	210a      	movs	r1, #10
    1ebc:	1c50      	adds	r0, r2, #1
    1ebe:	6018      	str	r0, [r3, #0]
    1ec0:	f002 fa15 	bl	42ee <__aeabi_uidiv>
    1ec4:	2900      	cmp	r1, #0
    1ec6:	d106      	bne.n	1ed6 <SYStick_handle+0x22>
		sys_tick_count++; //10
    1ec8:	4a04      	ldr	r2, [pc, #16]	; (1edc <SYStick_handle+0x28>)
    1eca:	6813      	ldr	r3, [r2, #0]
    1ecc:	3301      	adds	r3, #1
    1ece:	6013      	str	r3, [r2, #0]
		sys_Timer_Check_Flag = true;
    1ed0:	2201      	movs	r2, #1
    1ed2:	4b03      	ldr	r3, [pc, #12]	; (1ee0 <SYStick_handle+0x2c>)
    1ed4:	701a      	strb	r2, [r3, #0]
	}
}
    1ed6:	bd10      	pop	{r4, pc}
    1ed8:	10010fbc 	.word	0x10010fbc
    1edc:	1001281c 	.word	0x1001281c
    1ee0:	1001283c 	.word	0x1001283c

00001ee4 <hw_delay>:

#define BW(addr)			(int)*(addr) << 24 | (int)*(addr + 1) << 16 | (int)*(addr + 2) << 8 | *(addr + 3)

static inline void hw_delay() 
{
	__asm__ __volatile__("nop");
    1ee4:	46c0      	nop			; (mov r8, r8)
	__asm__ __volatile__("nop");
    1ee6:	46c0      	nop			; (mov r8, r8)
	__asm__ __volatile__("nop");
    1ee8:	46c0      	nop			; (mov r8, r8)
	__asm__ __volatile__("nop");
    1eea:	46c0      	nop			; (mov r8, r8)
	__asm__ __volatile__("nop");
    1eec:	46c0      	nop			; (mov r8, r8)
}
    1eee:	4770      	bx	lr

00001ef0 <bc_gpio_init>:
#define IS_VALID_PIN(PIN)
#endif

void bc_gpio_init(uint8_t pin, GPIO_CFG* t)
{
	ASSERT(t != NULL);
    1ef0:	2900      	cmp	r1, #0
    1ef2:	d100      	bne.n	1ef6 <bc_gpio_init+0x6>
    1ef4:	e7fe      	b.n	1ef4 <bc_gpio_init+0x4>
    1ef6:	2301      	movs	r3, #1
    1ef8:	281c      	cmp	r0, #28
    1efa:	d803      	bhi.n	1f04 <bc_gpio_init+0x14>
    1efc:	4a07      	ldr	r2, [pc, #28]	; (1f1c <bc_gpio_init+0x2c>)
    1efe:	2301      	movs	r3, #1
    1f00:	40c2      	lsrs	r2, r0
    1f02:	4393      	bics	r3, r2
    1f04:	b2db      	uxtb	r3, r3
	ASSERT(IS_VALID_PIN(pin));
    1f06:	2b00      	cmp	r3, #0
    1f08:	d1fd      	bne.n	1f06 <bc_gpio_init+0x16>
	HWRITE(CORE_GPIO_CONF + pin, *(uint8_t*)t);
    1f0a:	4b05      	ldr	r3, [pc, #20]	; (1f20 <bc_gpio_init+0x30>)
    1f0c:	18c0      	adds	r0, r0, r3
    1f0e:	2380      	movs	r3, #128	; 0x80
    1f10:	055b      	lsls	r3, r3, #21
    1f12:	4318      	orrs	r0, r3
    1f14:	780b      	ldrb	r3, [r1, #0]
    1f16:	7003      	strb	r3, [r0, #0]
}
    1f18:	4770      	bx	lr
    1f1a:	46c0      	nop			; (mov r8, r8)
    1f1c:	1b884040 	.word	0x1b884040
    1f20:	00008080 	.word	0x00008080

00001f24 <bc_gpio_deinit>:

void bc_gpio_deinit(uint8_t pin, GPIO_CFG* t)
{
	ASSERT(t != NULL);
    1f24:	2900      	cmp	r1, #0
    1f26:	d100      	bne.n	1f2a <bc_gpio_deinit+0x6>
    1f28:	e7fe      	b.n	1f28 <bc_gpio_deinit+0x4>
    1f2a:	2301      	movs	r3, #1
    1f2c:	281c      	cmp	r0, #28
    1f2e:	d803      	bhi.n	1f38 <bc_gpio_deinit+0x14>
    1f30:	4a03      	ldr	r2, [pc, #12]	; (1f40 <bc_gpio_deinit+0x1c>)
    1f32:	2301      	movs	r3, #1
    1f34:	40c2      	lsrs	r2, r0
    1f36:	4393      	bics	r3, r2
    1f38:	b2db      	uxtb	r3, r3
	ASSERT(IS_VALID_PIN(pin));
    1f3a:	2b00      	cmp	r3, #0
    1f3c:	d1fd      	bne.n	1f3a <bc_gpio_deinit+0x16>
}
    1f3e:	4770      	bx	lr
    1f40:	1b884040 	.word	0x1b884040

00001f44 <bc_gpio_set>:

void bc_gpio_set(uint8_t pin, bool val)
{
    1f44:	b570      	push	{r4, r5, r6, lr}
    1f46:	2301      	movs	r3, #1
    1f48:	0004      	movs	r4, r0
    1f4a:	000d      	movs	r5, r1
    1f4c:	281c      	cmp	r0, #28
    1f4e:	d803      	bhi.n	1f58 <bc_gpio_set+0x14>
    1f50:	4a0b      	ldr	r2, [pc, #44]	; (1f80 <bc_gpio_set+0x3c>)
    1f52:	2301      	movs	r3, #1
    1f54:	40c2      	lsrs	r2, r0
    1f56:	4393      	bics	r3, r2
    1f58:	b2db      	uxtb	r3, r3
	ASSERT(IS_VALID_PIN(pin));
    1f5a:	2b00      	cmp	r3, #0
    1f5c:	d1fd      	bne.n	1f5a <bc_gpio_set+0x16>
	//GPIO_SetOut(pin, val);
	hw_delay();
    1f5e:	f7ff ffc1 	bl	1ee4 <hw_delay>
    1f62:	4b08      	ldr	r3, [pc, #32]	; (1f84 <bc_gpio_set+0x40>)
    1f64:	18e4      	adds	r4, r4, r3
    1f66:	2380      	movs	r3, #128	; 0x80
    1f68:	055b      	lsls	r3, r3, #21
	if (val)
		HWRITE(CORE_GPIO_CONF + pin, GPCFG_OUTPUT_HIGH);
    1f6a:	431c      	orrs	r4, r3
void bc_gpio_set(uint8_t pin, bool val)
{
	ASSERT(IS_VALID_PIN(pin));
	//GPIO_SetOut(pin, val);
	hw_delay();
	if (val)
    1f6c:	2d00      	cmp	r5, #0
    1f6e:	d002      	beq.n	1f76 <bc_gpio_set+0x32>
		HWRITE(CORE_GPIO_CONF + pin, GPCFG_OUTPUT_HIGH);
    1f70:	233f      	movs	r3, #63	; 0x3f
    1f72:	7023      	strb	r3, [r4, #0]
    1f74:	e001      	b.n	1f7a <bc_gpio_set+0x36>
	else
		HWRITE(CORE_GPIO_CONF + pin, GPCFG_OUTPUT_LOW);
    1f76:	233e      	movs	r3, #62	; 0x3e
    1f78:	7023      	strb	r3, [r4, #0]
	hw_delay();
    1f7a:	f7ff ffb3 	bl	1ee4 <hw_delay>
}
    1f7e:	bd70      	pop	{r4, r5, r6, pc}
    1f80:	1b884040 	.word	0x1b884040
    1f84:	00008080 	.word	0x00008080

00001f88 <bc_gpio_get>:

bool bc_gpio_get(uint8_t pin)
{
    1f88:	b510      	push	{r4, lr}
    1f8a:	2301      	movs	r3, #1
    1f8c:	0004      	movs	r4, r0
    1f8e:	281c      	cmp	r0, #28
    1f90:	d803      	bhi.n	1f9a <bc_gpio_get+0x12>
    1f92:	4a0d      	ldr	r2, [pc, #52]	; (1fc8 <bc_gpio_get+0x40>)
    1f94:	2301      	movs	r3, #1
    1f96:	40c2      	lsrs	r2, r0
    1f98:	4393      	bics	r3, r2
    1f9a:	b2db      	uxtb	r3, r3
	ASSERT(IS_VALID_PIN(pin));
    1f9c:	2b00      	cmp	r3, #0
    1f9e:	d1fd      	bne.n	1f9c <bc_gpio_get+0x14>
	hw_delay();
    1fa0:	f7ff ffa0 	bl	1ee4 <hw_delay>
	register uint8_t group = 0;
	uint8_t st = 0;
	
	queue = (pin & 7);
	group = pin >> 3 & 3;
	st = HREAD(CORE_GPIO_IN+group);
    1fa4:	06e3      	lsls	r3, r4, #27
    1fa6:	4a09      	ldr	r2, [pc, #36]	; (1fcc <bc_gpio_get+0x44>)
    1fa8:	0f9b      	lsrs	r3, r3, #30
    1faa:	189b      	adds	r3, r3, r2
    1fac:	2280      	movs	r2, #128	; 0x80
    1fae:	0552      	lsls	r2, r2, #21
    1fb0:	4313      	orrs	r3, r2
    1fb2:	781a      	ldrb	r2, [r3, #0]
	return (st & (1 << queue));
    1fb4:	2307      	movs	r3, #7
    1fb6:	401c      	ands	r4, r3
    1fb8:	3b06      	subs	r3, #6
    1fba:	40a3      	lsls	r3, r4
    1fbc:	0018      	movs	r0, r3
    1fbe:	4010      	ands	r0, r2
    1fc0:	1e43      	subs	r3, r0, #1
    1fc2:	4198      	sbcs	r0, r3
    1fc4:	b2c0      	uxtb	r0, r0
}
    1fc6:	bd10      	pop	{r4, pc}
    1fc8:	1b884040 	.word	0x1b884040
    1fcc:	0000831c 	.word	0x0000831c

00001fd0 <WDT_Enable>:
#include "bc62xx_wdt.h"

void WDT_Enable(void)
{
	uint8_t config = *((volatile byte*)(0x10008043));
	config |= (1<<2);
    1fd0:	2104      	movs	r1, #4
#include "bc62xx_wdt.h"

void WDT_Enable(void)
{
	uint8_t config = *((volatile byte*)(0x10008043));
    1fd2:	4a04      	ldr	r2, [pc, #16]	; (1fe4 <WDT_Enable+0x14>)
    1fd4:	7813      	ldrb	r3, [r2, #0]
	config |= (1<<2);
    1fd6:	430b      	orrs	r3, r1
	*((volatile byte*)(0x10008043)) = config;
    1fd8:	7013      	strb	r3, [r2, #0]
	*((volatile byte*)(0x10008004)) = 0x2;
    1fda:	2202      	movs	r2, #2
    1fdc:	4b02      	ldr	r3, [pc, #8]	; (1fe8 <WDT_Enable+0x18>)
    1fde:	701a      	strb	r2, [r3, #0]
}
    1fe0:	4770      	bx	lr
    1fe2:	46c0      	nop			; (mov r8, r8)
    1fe4:	10008043 	.word	0x10008043
    1fe8:	10008004 	.word	0x10008004

00001fec <WDT_Disable>:

void WDT_Disable(void)
{
	uint8_t config = *((volatile byte*)(0x10008043));
	config &= (~(1<<2));
    1fec:	2104      	movs	r1, #4
	*((volatile byte*)(0x10008004)) = 0x2;
}

void WDT_Disable(void)
{
	uint8_t config = *((volatile byte*)(0x10008043));
    1fee:	4a02      	ldr	r2, [pc, #8]	; (1ff8 <WDT_Disable+0xc>)
    1ff0:	7813      	ldrb	r3, [r2, #0]
	config &= (~(1<<2));
    1ff2:	438b      	bics	r3, r1
	*((volatile byte*)(0x10008043)) = config;
    1ff4:	7013      	strb	r3, [r2, #0]
}
    1ff6:	4770      	bx	lr
    1ff8:	10008043 	.word	0x10008043

00001ffc <WDT_Kick>:

void WDT_Kick(void)
{
	*((volatile byte*)(0x10008004)) = 0x2;
    1ffc:	2202      	movs	r2, #2
    1ffe:	4b01      	ldr	r3, [pc, #4]	; (2004 <WDT_Kick+0x8>)
    2000:	701a      	strb	r2, [r3, #0]
    2002:	4770      	bx	lr
    2004:	10008004 	.word	0x10008004

00002008 <_breath_timer_cb>:
***********************************************************/

static void _cw_ctrl(light_cw_t* t);

static void _breath_timer_cb(int params)
{
    2008:	b510      	push	{r4, lr}
	uint8_t _sts = led_cw_do_breath();
    200a:	f000 f905 	bl	2218 <led_cw_do_breath>
#ifndef RELEASE
	printf("_breath_timer_cb _sts[%x]\r\n", _sts);
#endif
	if(1 != _sts){
    200e:	2801      	cmp	r0, #1
    2010:	d003      	beq.n	201a <_breath_timer_cb+0x12>
		SYS_ReleaseTimer(&breathTmr);
    2012:	4802      	ldr	r0, [pc, #8]	; (201c <_breath_timer_cb+0x14>)
    2014:	3024      	adds	r0, #36	; 0x24
    2016:	f7ff ff19 	bl	1e4c <SYS_ReleaseTimer>
	}
}
    201a:	bd10      	pop	{r4, pc}
    201c:	10010fc0 	.word	0x10010fc0

00002020 <_breath_timer_start>:

static void _breath_timer_start(void)
{
	ucPeriodCnt = 0;
    2020:	2300      	movs	r3, #0
		SYS_ReleaseTimer(&breathTmr);
	}
}

static void _breath_timer_start(void)
{
    2022:	b510      	push	{r4, lr}
	ucPeriodCnt = 0;
    2024:	4804      	ldr	r0, [pc, #16]	; (2038 <_breath_timer_start+0x18>)
	SYS_SetTimer(&breathTmr, 4, TIMER_CYCLE, _breath_timer_cb);
    2026:	2201      	movs	r2, #1
	}
}

static void _breath_timer_start(void)
{
	ucPeriodCnt = 0;
    2028:	8383      	strh	r3, [r0, #28]
	SYS_SetTimer(&breathTmr, 4, TIMER_CYCLE, _breath_timer_cb);
    202a:	2104      	movs	r1, #4
    202c:	3024      	adds	r0, #36	; 0x24
    202e:	4b03      	ldr	r3, [pc, #12]	; (203c <_breath_timer_start+0x1c>)
    2030:	f7ff fe8e 	bl	1d50 <SYS_SetTimer>
}
    2034:	bd10      	pop	{r4, pc}
    2036:	46c0      	nop			; (mov r8, r8)
    2038:	10010fc0 	.word	0x10010fc0
    203c:	00002009 	.word	0x00002009

00002040 <led_cw_set_temperature>:

void led_cw_set_temperature(uint16_t tp, breath_t* breath)
{
    2040:	b570      	push	{r4, r5, r6, lr}
    2042:	0005      	movs	r5, r0
    2044:	1e0e      	subs	r6, r1, #0
    2046:	4c0d      	ldr	r4, [pc, #52]	; (207c <led_cw_set_temperature+0x3c>)
	if(breath){
    2048:	d013      	beq.n	2072 <led_cw_set_temperature+0x32>
		deltaTp = (tp > lcw.tp)?(tp - lcw.tp):(lcw.tp - tp);
    204a:	89e0      	ldrh	r0, [r4, #14]
    204c:	42a8      	cmp	r0, r5
    204e:	d202      	bcs.n	2056 <led_cw_set_temperature+0x16>
    2050:	1a28      	subs	r0, r5, r0
    2052:	b280      	uxth	r0, r0
    2054:	e001      	b.n	205a <led_cw_set_temperature+0x1a>
    2056:	1b40      	subs	r0, r0, r5
    2058:	b280      	uxth	r0, r0
		deltaTp= deltaTp/breath->pCnt;
    205a:	8871      	ldrh	r1, [r6, #2]
    205c:	f002 f947 	bl	42ee <__aeabi_uidiv>
    2060:	b280      	uxth	r0, r0
    2062:	8420      	strh	r0, [r4, #32]
		if(deltaTp){
    2064:	2800      	cmp	r0, #0
    2066:	d004      	beq.n	2072 <led_cw_set_temperature+0x32>
			lcw.breath = breath;
    2068:	6026      	str	r6, [r4, #0]
			lcw.tpTarget = tp;
    206a:	8225      	strh	r5, [r4, #16]
			_breath_timer_start();
    206c:	f7ff ffd8 	bl	2020 <_breath_timer_start>
			return;
    2070:	e003      	b.n	207a <led_cw_set_temperature+0x3a>
		}
	}
	lcw.tp = tp;
    2072:	81e5      	strh	r5, [r4, #14]
	lcw.tpTarget = lcw.tp;
    2074:	8225      	strh	r5, [r4, #16]
	_cw_ctrl(&lcw);
    2076:	f000 fa0e 	bl	2496 <_cw_ctrl.constprop.1>
}
    207a:	bd70      	pop	{r4, r5, r6, pc}
    207c:	10010fc0 	.word	0x10010fc0

00002080 <led_cw_get_temperature>:

uint16_t led_cw_get_temperature(void)
{
	return lcw.tpTarget;
    2080:	4b01      	ldr	r3, [pc, #4]	; (2088 <led_cw_get_temperature+0x8>)
    2082:	8a18      	ldrh	r0, [r3, #16]
}
    2084:	4770      	bx	lr
    2086:	46c0      	nop			; (mov r8, r8)
    2088:	10010fc0 	.word	0x10010fc0

0000208c <led_cw_set_lightness>:

void led_cw_set_lightness(uint16_t ln, breath_t* breath)
{
    208c:	b570      	push	{r4, r5, r6, lr}
    208e:	0005      	movs	r5, r0
    2090:	1e0e      	subs	r6, r1, #0
    2092:	4c0d      	ldr	r4, [pc, #52]	; (20c8 <led_cw_set_lightness+0x3c>)
	if(breath){
    2094:	d013      	beq.n	20be <led_cw_set_lightness+0x32>
		deltaLn = (ln > lcw.ln)?(ln - lcw.ln):(lcw.ln - ln);
    2096:	8960      	ldrh	r0, [r4, #10]
    2098:	42a8      	cmp	r0, r5
    209a:	d202      	bcs.n	20a2 <led_cw_set_lightness+0x16>
    209c:	1a28      	subs	r0, r5, r0
    209e:	b280      	uxth	r0, r0
    20a0:	e001      	b.n	20a6 <led_cw_set_lightness+0x1a>
    20a2:	1b40      	subs	r0, r0, r5
    20a4:	b280      	uxth	r0, r0
		deltaLn = deltaLn/breath->pCnt;
    20a6:	8871      	ldrh	r1, [r6, #2]
    20a8:	f002 f921 	bl	42ee <__aeabi_uidiv>
    20ac:	b280      	uxth	r0, r0
    20ae:	83e0      	strh	r0, [r4, #30]
		if(deltaLn){
    20b0:	2800      	cmp	r0, #0
    20b2:	d004      	beq.n	20be <led_cw_set_lightness+0x32>
			lcw.breath = breath;
    20b4:	6026      	str	r6, [r4, #0]
			lcw.lnTarget = ln;
    20b6:	81a5      	strh	r5, [r4, #12]
			_breath_timer_start();
    20b8:	f7ff ffb2 	bl	2020 <_breath_timer_start>
			return;
    20bc:	e003      	b.n	20c6 <led_cw_set_lightness+0x3a>
		}
	}
	lcw.ln = ln;
    20be:	8165      	strh	r5, [r4, #10]
	lcw.lnTarget = lcw.ln;
    20c0:	81a5      	strh	r5, [r4, #12]
	_cw_ctrl(&lcw);
    20c2:	f000 f9e8 	bl	2496 <_cw_ctrl.constprop.1>
}
    20c6:	bd70      	pop	{r4, r5, r6, pc}
    20c8:	10010fc0 	.word	0x10010fc0

000020cc <led_cw_get_lightness>:
uint16_t led_cw_get_lightness(void)
{
	return lcw.lnTarget;
    20cc:	4b01      	ldr	r3, [pc, #4]	; (20d4 <led_cw_get_lightness+0x8>)
    20ce:	8998      	ldrh	r0, [r3, #12]
}
    20d0:	4770      	bx	lr
    20d2:	46c0      	nop			; (mov r8, r8)
    20d4:	10010fc0 	.word	0x10010fc0

000020d8 <led_cw_set_on_off>:

void led_cw_set_on_off(uint8_t on, breath_t* breath)
{
    20d8:	b570      	push	{r4, r5, r6, lr}
    20da:	0005      	movs	r5, r0
    20dc:	1e0e      	subs	r6, r1, #0
    20de:	4c0e      	ldr	r4, [pc, #56]	; (2118 <led_cw_set_on_off+0x40>)
	if(breath && (on != lcw.on)){//the target lightness need to be restore
    20e0:	d015      	beq.n	210e <led_cw_set_on_off+0x36>
    20e2:	7a23      	ldrb	r3, [r4, #8]
    20e4:	4283      	cmp	r3, r0
    20e6:	d012      	beq.n	210e <led_cw_set_on_off+0x36>
    20e8:	8963      	ldrh	r3, [r4, #10]

		if(on){
			lcw.lnTarget = lcw.ln;
    20ea:	81a3      	strh	r3, [r4, #12]

void led_cw_set_on_off(uint8_t on, breath_t* breath)
{
	if(breath && (on != lcw.on)){//the target lightness need to be restore

		if(on){
    20ec:	2800      	cmp	r0, #0
    20ee:	d001      	beq.n	20f4 <led_cw_set_on_off+0x1c>
			lcw.lnTarget = lcw.ln;
			lcw.ln = 0;
    20f0:	2300      	movs	r3, #0
    20f2:	8163      	strh	r3, [r4, #10]
		}
		else{
			lcw.lnTarget = lcw.ln;
		}
		deltaLn = lcw.lnTarget;
		deltaLn = deltaLn/breath->pCnt;
    20f4:	8871      	ldrh	r1, [r6, #2]
    20f6:	89a0      	ldrh	r0, [r4, #12]
    20f8:	f002 f8f9 	bl	42ee <__aeabi_uidiv>
    20fc:	b280      	uxth	r0, r0
    20fe:	83e0      	strh	r0, [r4, #30]
		if(deltaLn){
    2100:	2800      	cmp	r0, #0
    2102:	d004      	beq.n	210e <led_cw_set_on_off+0x36>
			lcw.breath = breath;
    2104:	6026      	str	r6, [r4, #0]
			lcw.onTarget = on;
    2106:	7265      	strb	r5, [r4, #9]
			_breath_timer_start();
    2108:	f7ff ff8a 	bl	2020 <_breath_timer_start>
			return;
    210c:	e003      	b.n	2116 <led_cw_set_on_off+0x3e>
			}
	}
	lcw.on = on;
    210e:	7225      	strb	r5, [r4, #8]
	lcw.onTarget = lcw.on;
    2110:	7265      	strb	r5, [r4, #9]
	_cw_ctrl(&lcw);
    2112:	f000 f9c0 	bl	2496 <_cw_ctrl.constprop.1>
}
    2116:	bd70      	pop	{r4, r5, r6, pc}
    2118:	10010fc0 	.word	0x10010fc0

0000211c <led_cw_get_on_off>:
uint8_t led_cw_get_on_off(void)
{
	return lcw.onTarget;
    211c:	4b01      	ldr	r3, [pc, #4]	; (2124 <led_cw_get_on_off+0x8>)
    211e:	7a58      	ldrb	r0, [r3, #9]
}
    2120:	4770      	bx	lr
    2122:	46c0      	nop			; (mov r8, r8)
    2124:	10010fc0 	.word	0x10010fc0

00002128 <led_cw_init>:


void led_cw_init(light_cw_t* t)
{
    2128:	b530      	push	{r4, r5, lr}
	/*init gpio*/	
	GPIO_CFG cfg4 ={FUNC_PWM_OUT4, GFG_PULLUP};
    212a:	4d18      	ldr	r5, [pc, #96]	; (218c <led_cw_init+0x64>)
	return lcw.onTarget;
}


void led_cw_init(light_cw_t* t)
{
    212c:	b085      	sub	sp, #20
	/*init gpio*/	
	GPIO_CFG cfg4 ={FUNC_PWM_OUT4, GFG_PULLUP};
    212e:	782b      	ldrb	r3, [r5, #0]
    2130:	a901      	add	r1, sp, #4
	return lcw.onTarget;
}


void led_cw_init(light_cw_t* t)
{
    2132:	0004      	movs	r4, r0
	/*init gpio*/	
	GPIO_CFG cfg4 ={FUNC_PWM_OUT4, GFG_PULLUP};
	bc_gpio_init(ALI_PWM4_C, &cfg4);
    2134:	2017      	movs	r0, #23


void led_cw_init(light_cw_t* t)
{
	/*init gpio*/	
	GPIO_CFG cfg4 ={FUNC_PWM_OUT4, GFG_PULLUP};
    2136:	700b      	strb	r3, [r1, #0]
	bc_gpio_init(ALI_PWM4_C, &cfg4);
    2138:	f7ff feda 	bl	1ef0 <bc_gpio_init>
	
	GPIO_CFG cfg5 ={FUNC_PWM_OUT5, GFG_PULLUP};
    213c:	786b      	ldrb	r3, [r5, #1]
    213e:	a902      	add	r1, sp, #8
	bc_gpio_init(ALI_PWM5_W, &cfg5);
    2140:	2018      	movs	r0, #24
{
	/*init gpio*/	
	GPIO_CFG cfg4 ={FUNC_PWM_OUT4, GFG_PULLUP};
	bc_gpio_init(ALI_PWM4_C, &cfg4);
	
	GPIO_CFG cfg5 ={FUNC_PWM_OUT5, GFG_PULLUP};
    2142:	700b      	strb	r3, [r1, #0]
	bc_gpio_init(ALI_PWM5_W, &cfg5);
    2144:	f7ff fed4 	bl	1ef0 <bc_gpio_init>
	
	struct PWM_CTRL_BITS bits = {0};
    2148:	2300      	movs	r3, #0
    214a:	ad03      	add	r5, sp, #12
	PWM_Init(PWM_CH4, &bits);
    214c:	0029      	movs	r1, r5
    214e:	2010      	movs	r0, #16
	bc_gpio_init(ALI_PWM4_C, &cfg4);
	
	GPIO_CFG cfg5 ={FUNC_PWM_OUT5, GFG_PULLUP};
	bc_gpio_init(ALI_PWM5_W, &cfg5);
	
	struct PWM_CTRL_BITS bits = {0};
    2150:	702b      	strb	r3, [r5, #0]
	PWM_Init(PWM_CH4, &bits);
    2152:	f7ff fcaf 	bl	1ab4 <PWM_Init>
	PWM_Init(PWM_CH5, &bits);
    2156:	0029      	movs	r1, r5
    2158:	2020      	movs	r0, #32
    215a:	f7ff fcab 	bl	1ab4 <PWM_Init>
    215e:	4b0c      	ldr	r3, [pc, #48]	; (2190 <led_cw_init+0x68>)
	if(t==NULL){
    2160:	2c00      	cmp	r4, #0
    2162:	d109      	bne.n	2178 <led_cw_init+0x50>
		lcw.ln = ALI_DEFAULT_LN_VAL;
    2164:	2224      	movs	r2, #36	; 0x24
    2166:	4252      	negs	r2, r2
    2168:	815a      	strh	r2, [r3, #10]
		lcw.tp = ALI_DEFAULT_TP_VAL;
    216a:	4a0a      	ldr	r2, [pc, #40]	; (2194 <led_cw_init+0x6c>)
    216c:	81da      	strh	r2, [r3, #14]
		lcw.on = ALI_DEFAULT_ON_VAL;
    216e:	2201      	movs	r2, #1
    2170:	721a      	strb	r2, [r3, #8]
		lcw.freq = ALI_FREQUENCY_16K;
    2172:	4a09      	ldr	r2, [pc, #36]	; (2198 <led_cw_init+0x70>)
    2174:	809a      	strh	r2, [r3, #4]
    2176:	e004      	b.n	2182 <led_cw_init+0x5a>
	}
	else{
		lcw = *t;
    2178:	cc07      	ldmia	r4!, {r0, r1, r2}
    217a:	c307      	stmia	r3!, {r0, r1, r2}
    217c:	001a      	movs	r2, r3
    217e:	cc0a      	ldmia	r4!, {r1, r3}
    2180:	c20a      	stmia	r2!, {r1, r3}
	}
	_cw_ctrl(&lcw);
    2182:	f000 f988 	bl	2496 <_cw_ctrl.constprop.1>
}
    2186:	b005      	add	sp, #20
    2188:	bd30      	pop	{r4, r5, pc}
    218a:	46c0      	nop			; (mov r8, r8)
    218c:	0001fe34 	.word	0x0001fe34
    2190:	10010fc0 	.word	0x10010fc0
    2194:	000028a0 	.word	0x000028a0
    2198:	000005dc 	.word	0x000005dc

0000219c <led_cw_set_breath>:
	PWM_DeInit(PWM_CH4);
	PWM_DeInit(PWM_CH5);
}

void led_cw_set_breath(breath_t* t)
{
    219c:	b570      	push	{r4, r5, r6, lr}
    219e:	0005      	movs	r5, r0
	switch(t->mode){
    21a0:	7800      	ldrb	r0, [r0, #0]
    21a2:	0740      	lsls	r0, r0, #29
    21a4:	0f40      	lsrs	r0, r0, #29
    21a6:	2804      	cmp	r0, #4
    21a8:	d830      	bhi.n	220c <led_cw_set_breath+0x70>
    21aa:	4c19      	ldr	r4, [pc, #100]	; (2210 <led_cw_set_breath+0x74>)
    21ac:	f01b fdd2 	bl	1dd54 <__gnu_thumb1_case_uqi>
    21b0:	1e10032b 	.word	0x1e10032b
    21b4:	20          	.byte	0x20
    21b5:	00          	.byte	0x00
		case BREATH_MODE_FLOW:{
		}break;
		case BREATH_MODE_L2H:{
			lcw.lnTarget = ALI_DEFAULT_LN_VAL;
    21b6:	2324      	movs	r3, #36	; 0x24
    21b8:	425b      	negs	r3, r3
    21ba:	81a3      	strh	r3, [r4, #12]
			lcw.ln = 0;
    21bc:	2300      	movs	r3, #0
    21be:	8163      	strh	r3, [r4, #10]
			lcw.onTarget = 1;
    21c0:	3301      	adds	r3, #1
    21c2:	7263      	strb	r3, [r4, #9]
			deltaLn = ALI_DEFAULT_LN_VAL/t->pCnt;
    21c4:	8869      	ldrh	r1, [r5, #2]
    21c6:	4813      	ldr	r0, [pc, #76]	; (2214 <led_cw_set_breath+0x78>)
    21c8:	f002 f869 	bl	429e <__aeabi_idiv>
    21cc:	83e0      	strh	r0, [r4, #30]
		}break;
    21ce:	e01a      	b.n	2206 <led_cw_set_breath+0x6a>
		case BREATH_MODE_H2L:{
			lcw.lnTarget = 0;
    21d0:	2300      	movs	r3, #0
			lcw.ln = ALI_DEFAULT_LN_VAL;
    21d2:	2224      	movs	r2, #36	; 0x24
			lcw.ln = 0;
			lcw.onTarget = 1;
			deltaLn = ALI_DEFAULT_LN_VAL/t->pCnt;
		}break;
		case BREATH_MODE_H2L:{
			lcw.lnTarget = 0;
    21d4:	81a3      	strh	r3, [r4, #12]
			lcw.ln = ALI_DEFAULT_LN_VAL;
			lcw.onTarget = 0;
    21d6:	7263      	strb	r3, [r4, #9]
			lcw.onTarget = 1;
			deltaLn = ALI_DEFAULT_LN_VAL/t->pCnt;
		}break;
		case BREATH_MODE_H2L:{
			lcw.lnTarget = 0;
			lcw.ln = ALI_DEFAULT_LN_VAL;
    21d8:	4252      	negs	r2, r2
			lcw.onTarget = 0;
			lcw.on = 1;
    21da:	3301      	adds	r3, #1
			lcw.onTarget = 1;
			deltaLn = ALI_DEFAULT_LN_VAL/t->pCnt;
		}break;
		case BREATH_MODE_H2L:{
			lcw.lnTarget = 0;
			lcw.ln = ALI_DEFAULT_LN_VAL;
    21dc:	8162      	strh	r2, [r4, #10]
			lcw.onTarget = 0;
			lcw.on = 1;
    21de:	7223      	strb	r3, [r4, #8]
			deltaLn = ALI_DEFAULT_LN_VAL/t->pCnt;
    21e0:	8869      	ldrh	r1, [r5, #2]
    21e2:	480c      	ldr	r0, [pc, #48]	; (2214 <led_cw_set_breath+0x78>)
    21e4:	f002 f85b 	bl	429e <__aeabi_idiv>
    21e8:	83e0      	strh	r0, [r4, #30]
		}break;
    21ea:	e00c      	b.n	2206 <led_cw_set_breath+0x6a>
		case BREATH_MODE_L2H2L:{
			lcw.lnTarget = 0;//ALI_DEFAULT_LN_VAL;
    21ec:	2300      	movs	r3, #0
    21ee:	e001      	b.n	21f4 <led_cw_set_breath+0x58>
			deltaLn = ALI_DEFAULT_LN_VAL/t->pCnt;
			if(deltaLn == 0)
				return;
		}break;
		case BREATH_MODE_H2L2H:{
			lcw.lnTarget = ALI_DEFAULT_LN_VAL;
    21f0:	2324      	movs	r3, #36	; 0x24
    21f2:	425b      	negs	r3, r3
    21f4:	81a3      	strh	r3, [r4, #12]
			lcw.ln = ALI_DEFAULT_LN_VAL;
    21f6:	8163      	strh	r3, [r4, #10]
			deltaLn = ALI_DEFAULT_LN_VAL/t->pCnt;
    21f8:	8869      	ldrh	r1, [r5, #2]
    21fa:	4806      	ldr	r0, [pc, #24]	; (2214 <led_cw_set_breath+0x78>)
    21fc:	f002 f84f 	bl	429e <__aeabi_idiv>
    2200:	83e0      	strh	r0, [r4, #30]
			if(deltaLn == 0)
    2202:	2800      	cmp	r0, #0
    2204:	d002      	beq.n	220c <led_cw_set_breath+0x70>
		}break;
		default:{
			return;
		}break;
	}
	lcw.breath = t;
    2206:	6025      	str	r5, [r4, #0]
#ifndef RELEASE
	printf("mode[%x] rCnt[%x] pCnt[%x]", lcw.breath->mode, lcw.breath->rCnt,
											lcw.breath->pCnt);
#endif
	_breath_timer_start();
    2208:	f7ff ff0a 	bl	2020 <_breath_timer_start>
}
    220c:	bd70      	pop	{r4, r5, r6, pc}
    220e:	46c0      	nop			; (mov r8, r8)
    2210:	10010fc0 	.word	0x10010fc0
    2214:	0000ffdc 	.word	0x0000ffdc

00002218 <led_cw_do_breath>:
 			2 failed
 ****************************************************************************************
 */
uint8_t  led_cw_do_breath(void)
{
	if(lcw.breath == NULL || (deltaLn == 0 && deltaTp == 0)){
    2218:	4b5e      	ldr	r3, [pc, #376]	; (2394 <led_cw_do_breath+0x17c>)
 			1 need continue do
 			2 failed
 ****************************************************************************************
 */
uint8_t  led_cw_do_breath(void)
{
    221a:	b570      	push	{r4, r5, r6, lr}
	if(lcw.breath == NULL || (deltaLn == 0 && deltaTp == 0)){
    221c:	681d      	ldr	r5, [r3, #0]
		//use target ctl
		return 2;
    221e:	2002      	movs	r0, #2
 			2 failed
 ****************************************************************************************
 */
uint8_t  led_cw_do_breath(void)
{
	if(lcw.breath == NULL || (deltaLn == 0 && deltaTp == 0)){
    2220:	2d00      	cmp	r5, #0
    2222:	d100      	bne.n	2226 <led_cw_do_breath+0xe>
    2224:	e0b5      	b.n	2392 <led_cw_do_breath+0x17a>
    2226:	8bda      	ldrh	r2, [r3, #30]
    2228:	2a00      	cmp	r2, #0
    222a:	d103      	bne.n	2234 <led_cw_do_breath+0x1c>
    222c:	8c19      	ldrh	r1, [r3, #32]
    222e:	2900      	cmp	r1, #0
    2230:	d100      	bne.n	2234 <led_cw_do_breath+0x1c>
    2232:	e0ae      	b.n	2392 <led_cw_do_breath+0x17a>
	uint8_t _sts = 1;
#ifndef RELEASE
	printf("deltaLn[%x]deltaTp[%x]ucPeriodCnt[%x] mode[%x]\r\n", deltaLn, deltaTp, ucPeriodCnt, lcw.breath->mode);
#endif
	
	switch(lcw.breath->mode){
    2234:	7829      	ldrb	r1, [r5, #0]
    2236:	0748      	lsls	r0, r1, #29
    2238:	0f40      	lsrs	r0, r0, #29
    223a:	2804      	cmp	r0, #4
    223c:	d900      	bls.n	2240 <led_cw_do_breath+0x28>
    223e:	e0a3      	b.n	2388 <led_cw_do_breath+0x170>
    2240:	886c      	ldrh	r4, [r5, #2]
    2242:	f01b fd87 	bl	1dd54 <__gnu_thumb1_case_uqi>
    2246:	3003      	.short	0x3003
    2248:	5c43      	.short	0x5c43
    224a:	70          	.byte	0x70
    224b:	00          	.byte	0x00
		case BREATH_MODE_FLOW:{
			if(ucPeriodCnt < lcw.breath->pCnt){
    224c:	8b98      	ldrh	r0, [r3, #28]
    224e:	4284      	cmp	r4, r0
    2250:	d916      	bls.n	2280 <led_cw_do_breath+0x68>
				if(lcw.onTarget > lcw.on 
    2252:	7a58      	ldrb	r0, [r3, #9]
    2254:	7a19      	ldrb	r1, [r3, #8]
    2256:	4288      	cmp	r0, r1
    2258:	d804      	bhi.n	2264 <led_cw_do_breath+0x4c>
					|| ((lcw.onTarget == lcw.on) 
    225a:	d107      	bne.n	226c <led_cw_do_breath+0x54>
					&& lcw.lnTarget > lcw.ln))
    225c:	8998      	ldrh	r0, [r3, #12]
    225e:	8959      	ldrh	r1, [r3, #10]
    2260:	4288      	cmp	r0, r1
    2262:	d903      	bls.n	226c <led_cw_do_breath+0x54>
					lcw.ln += deltaLn;
    2264:	8959      	ldrh	r1, [r3, #10]
    2266:	1852      	adds	r2, r2, r1
    2268:	815a      	strh	r2, [r3, #10]
    226a:	e002      	b.n	2272 <led_cw_do_breath+0x5a>
				else 
					lcw.ln -= deltaLn;
    226c:	8959      	ldrh	r1, [r3, #10]
    226e:	1a8a      	subs	r2, r1, r2
    2270:	815a      	strh	r2, [r3, #10]
				if(lcw.tpTarget > lcw.tp)
    2272:	89da      	ldrh	r2, [r3, #14]
    2274:	8a18      	ldrh	r0, [r3, #16]
    2276:	8c19      	ldrh	r1, [r3, #32]
    2278:	4290      	cmp	r0, r2
    227a:	d800      	bhi.n	227e <led_cw_do_breath+0x66>
    227c:	e074      	b.n	2368 <led_cw_do_breath+0x150>
    227e:	e05d      	b.n	233c <led_cw_do_breath+0x124>
					lcw.tp += deltaTp;
				else
					lcw.tp -= deltaTp;
			}
			else{
				if(--lcw.breath->rCnt == 0){
    2280:	201f      	movs	r0, #31
    2282:	2407      	movs	r4, #7
    2284:	08ca      	lsrs	r2, r1, #3
    2286:	321f      	adds	r2, #31
    2288:	4002      	ands	r2, r0
    228a:	00d0      	lsls	r0, r2, #3
    228c:	4021      	ands	r1, r4
    228e:	4301      	orrs	r1, r0
    2290:	7029      	strb	r1, [r5, #0]
    2292:	2a00      	cmp	r2, #0
    2294:	d06c      	beq.n	2370 <led_cw_do_breath+0x158>
					_sts = 0;
				}
				else{
					ucPeriodCnt = 0;
    2296:	2200      	movs	r2, #0
    2298:	839a      	strh	r2, [r3, #28]
					lcw.ln = lcw.lnTarget;
    229a:	899a      	ldrh	r2, [r3, #12]
{
	if(lcw.breath == NULL || (deltaLn == 0 && deltaTp == 0)){
		//use target ctl
		return 2;
	}
	uint8_t _sts = 1;
    229c:	3c06      	subs	r4, #6
				if(--lcw.breath->rCnt == 0){
					_sts = 0;
				}
				else{
					ucPeriodCnt = 0;
					lcw.ln = lcw.lnTarget;
    229e:	815a      	strh	r2, [r3, #10]
					lcw.tp = lcw.tpTarget;
    22a0:	8a1a      	ldrh	r2, [r3, #16]
    22a2:	81da      	strh	r2, [r3, #14]
    22a4:	e071      	b.n	238a <led_cw_do_breath+0x172>
				}
			}
		}break;
		case BREATH_MODE_L2H:{
			if(ucPeriodCnt < lcw.breath->pCnt){
    22a6:	8b98      	ldrh	r0, [r3, #28]
    22a8:	4284      	cmp	r4, r0
    22aa:	d842      	bhi.n	2332 <led_cw_do_breath+0x11a>
				lcw.ln += deltaLn;
				lcw.tp += deltaTp;
			}
			else{
				if(--lcw.breath->rCnt == 0){
    22ac:	201f      	movs	r0, #31
    22ae:	2407      	movs	r4, #7
    22b0:	08ca      	lsrs	r2, r1, #3
    22b2:	321f      	adds	r2, #31
    22b4:	4002      	ands	r2, r0
    22b6:	00d0      	lsls	r0, r2, #3
    22b8:	4021      	ands	r1, r4
    22ba:	4301      	orrs	r1, r0
    22bc:	7029      	strb	r1, [r5, #0]
    22be:	2a00      	cmp	r2, #0
    22c0:	d056      	beq.n	2370 <led_cw_do_breath+0x158>
					_sts = 0;
				}
				else{
					ucPeriodCnt = 0;
    22c2:	2200      	movs	r2, #0
{
	if(lcw.breath == NULL || (deltaLn == 0 && deltaTp == 0)){
		//use target ctl
		return 2;
	}
	uint8_t _sts = 1;
    22c4:	3c06      	subs	r4, #6
			else{
				if(--lcw.breath->rCnt == 0){
					_sts = 0;
				}
				else{
					ucPeriodCnt = 0;
    22c6:	839a      	strh	r2, [r3, #28]
					lcw.ln = 0;
    22c8:	815a      	strh	r2, [r3, #10]
    22ca:	e05e      	b.n	238a <led_cw_do_breath+0x172>
				}
			}
		}break;
		case BREATH_MODE_H2L:{
			if(ucPeriodCnt < lcw.breath->pCnt){
    22cc:	8b98      	ldrh	r0, [r3, #28]
    22ce:	4284      	cmp	r4, r0
    22d0:	d904      	bls.n	22dc <led_cw_do_breath+0xc4>
				lcw.ln -= deltaLn;
    22d2:	8959      	ldrh	r1, [r3, #10]
{
	if(lcw.breath == NULL || (deltaLn == 0 && deltaTp == 0)){
		//use target ctl
		return 2;
	}
	uint8_t _sts = 1;
    22d4:	2401      	movs	r4, #1
				}
			}
		}break;
		case BREATH_MODE_H2L:{
			if(ucPeriodCnt < lcw.breath->pCnt){
				lcw.ln -= deltaLn;
    22d6:	1a8a      	subs	r2, r1, r2
    22d8:	815a      	strh	r2, [r3, #10]
    22da:	e056      	b.n	238a <led_cw_do_breath+0x172>
			}
			else{
				if(--lcw.breath->rCnt == 0){
    22dc:	201f      	movs	r0, #31
    22de:	2407      	movs	r4, #7
    22e0:	08ca      	lsrs	r2, r1, #3
    22e2:	321f      	adds	r2, #31
    22e4:	4002      	ands	r2, r0
    22e6:	00d0      	lsls	r0, r2, #3
    22e8:	4021      	ands	r1, r4
    22ea:	4301      	orrs	r1, r0
    22ec:	7029      	strb	r1, [r5, #0]
    22ee:	2a00      	cmp	r2, #0
    22f0:	d03e      	beq.n	2370 <led_cw_do_breath+0x158>
					_sts = 0;
				}
				else{
					ucPeriodCnt = 0;
    22f2:	2200      	movs	r2, #0
    22f4:	839a      	strh	r2, [r3, #28]
					lcw.ln = ALI_DEFAULT_LN_VAL;
    22f6:	3a24      	subs	r2, #36	; 0x24
    22f8:	815a      	strh	r2, [r3, #10]
{
	if(lcw.breath == NULL || (deltaLn == 0 && deltaTp == 0)){
		//use target ctl
		return 2;
	}
	uint8_t _sts = 1;
    22fa:	3c06      	subs	r4, #6
    22fc:	e045      	b.n	238a <led_cw_do_breath+0x172>
					lcw.ln = ALI_DEFAULT_LN_VAL;
				}
			}
		}break;
		case BREATH_MODE_L2H2L:{
			if(ucPeriodCnt < lcw.breath->pCnt){
    22fe:	8b98      	ldrh	r0, [r3, #28]
    2300:	4284      	cmp	r4, r0
    2302:	d816      	bhi.n	2332 <led_cw_do_breath+0x11a>
				lcw.ln += deltaLn;
				lcw.tp += deltaTp;
			}
			else if(ucPeriodCnt < (lcw.breath->pCnt<<1)){
    2304:	0064      	lsls	r4, r4, #1
    2306:	42a0      	cmp	r0, r4
    2308:	db29      	blt.n	235e <led_cw_do_breath+0x146>
				lcw.ln -= deltaLn;
				lcw.tp -= deltaTp;
			}
			else{
				if(--lcw.breath->rCnt == 0){
    230a:	241f      	movs	r4, #31
    230c:	2607      	movs	r6, #7
    230e:	08c8      	lsrs	r0, r1, #3
    2310:	301f      	adds	r0, #31
    2312:	4020      	ands	r0, r4
    2314:	00c4      	lsls	r4, r0, #3
    2316:	4031      	ands	r1, r6
    2318:	4321      	orrs	r1, r4
    231a:	7029      	strb	r1, [r5, #0]
    231c:	2800      	cmp	r0, #0
    231e:	d027      	beq.n	2370 <led_cw_do_breath+0x158>
					_sts = 0;
				}
				else{
					ucPeriodCnt = 0;
    2320:	2100      	movs	r1, #0
    2322:	8399      	strh	r1, [r3, #28]
    2324:	e005      	b.n	2332 <led_cw_do_breath+0x11a>
					lcw.tp += deltaTp;
				}
			}
		}break;
		case BREATH_MODE_H2L2H:{
			if(ucPeriodCnt < lcw.breath->pCnt){
    2326:	8b98      	ldrh	r0, [r3, #28]
    2328:	4284      	cmp	r4, r0
    232a:	d818      	bhi.n	235e <led_cw_do_breath+0x146>
				lcw.ln -= deltaLn;
				lcw.tp -= deltaTp;
			}
			else if(ucPeriodCnt < (lcw.breath->pCnt<<1)){
    232c:	0064      	lsls	r4, r4, #1
    232e:	42a0      	cmp	r0, r4
    2330:	da08      	bge.n	2344 <led_cw_do_breath+0x12c>
				
				lcw.ln += deltaLn;
    2332:	8959      	ldrh	r1, [r3, #10]
    2334:	1852      	adds	r2, r2, r1
    2336:	815a      	strh	r2, [r3, #10]
				lcw.tp += deltaTp;
    2338:	89d9      	ldrh	r1, [r3, #14]
    233a:	8c1a      	ldrh	r2, [r3, #32]
    233c:	188a      	adds	r2, r1, r2
    233e:	81da      	strh	r2, [r3, #14]
{
	if(lcw.breath == NULL || (deltaLn == 0 && deltaTp == 0)){
		//use target ctl
		return 2;
	}
	uint8_t _sts = 1;
    2340:	2401      	movs	r4, #1
    2342:	e022      	b.n	238a <led_cw_do_breath+0x172>
				
				lcw.ln += deltaLn;
				lcw.tp += deltaTp;
			}
			else{
				if(--lcw.breath->rCnt == 0){
    2344:	241f      	movs	r4, #31
    2346:	2607      	movs	r6, #7
    2348:	08c8      	lsrs	r0, r1, #3
    234a:	301f      	adds	r0, #31
    234c:	4020      	ands	r0, r4
    234e:	00c4      	lsls	r4, r0, #3
    2350:	4031      	ands	r1, r6
    2352:	4321      	orrs	r1, r4
    2354:	7029      	strb	r1, [r5, #0]
    2356:	2800      	cmp	r0, #0
    2358:	d00a      	beq.n	2370 <led_cw_do_breath+0x158>
					_sts = 0;
				}
				else{
					ucPeriodCnt = 0;
    235a:	2100      	movs	r1, #0
    235c:	8399      	strh	r1, [r3, #28]
					lcw.ln -= deltaLn;
    235e:	8959      	ldrh	r1, [r3, #10]
    2360:	1a8a      	subs	r2, r1, r2
    2362:	815a      	strh	r2, [r3, #10]
					lcw.tp -= deltaTp;
    2364:	8c19      	ldrh	r1, [r3, #32]
    2366:	89da      	ldrh	r2, [r3, #14]
    2368:	1a52      	subs	r2, r2, r1
    236a:	81da      	strh	r2, [r3, #14]
{
	if(lcw.breath == NULL || (deltaLn == 0 && deltaTp == 0)){
		//use target ctl
		return 2;
	}
	uint8_t _sts = 1;
    236c:	2401      	movs	r4, #1
    236e:	e00c      	b.n	238a <led_cw_do_breath+0x172>

	if(_sts == 0){
		lcw.on = lcw.onTarget;
		lcw.ln = lcw.lnTarget;
		lcw.ln = lcw.lnTarget;
		lcw.breath = NULL;
    2370:	2400      	movs	r4, #0
			_sts = 2;
		}break;
	}

	if(_sts == 0){
		lcw.on = lcw.onTarget;
    2372:	7a5a      	ldrb	r2, [r3, #9]
		lcw.ln = lcw.lnTarget;
		lcw.ln = lcw.lnTarget;
		lcw.breath = NULL;
    2374:	601c      	str	r4, [r3, #0]
			_sts = 2;
		}break;
	}

	if(_sts == 0){
		lcw.on = lcw.onTarget;
    2376:	721a      	strb	r2, [r3, #8]
		lcw.ln = lcw.lnTarget;
    2378:	899a      	ldrh	r2, [r3, #12]
		lcw.ln = lcw.lnTarget;
		lcw.breath = NULL;
		deltaTp = 0;
    237a:	841c      	strh	r4, [r3, #32]
		}break;
	}

	if(_sts == 0){
		lcw.on = lcw.onTarget;
		lcw.ln = lcw.lnTarget;
    237c:	815a      	strh	r2, [r3, #10]
		lcw.ln = lcw.lnTarget;
		lcw.breath = NULL;
		deltaTp = 0;
		deltaLn = 0;
    237e:	83dc      	strh	r4, [r3, #30]
	}
	else{
		ucPeriodCnt++;
	}
	_cw_ctrl(&lcw);
    2380:	f000 f889 	bl	2496 <_cw_ctrl.constprop.1>
	return _sts;
    2384:	0020      	movs	r0, r4
    2386:	e004      	b.n	2392 <led_cw_do_breath+0x17a>
					lcw.tp -= deltaTp;
				}
			}
		}break;
		default:{
			_sts = 2;
    2388:	2402      	movs	r4, #2
		lcw.breath = NULL;
		deltaTp = 0;
		deltaLn = 0;
	}
	else{
		ucPeriodCnt++;
    238a:	8b9a      	ldrh	r2, [r3, #28]
    238c:	3201      	adds	r2, #1
    238e:	839a      	strh	r2, [r3, #28]
    2390:	e7f6      	b.n	2380 <led_cw_do_breath+0x168>
	}
	_cw_ctrl(&lcw);
	return _sts;
}
    2392:	bd70      	pop	{r4, r5, r6, pc}
    2394:	10010fc0 	.word	0x10010fc0

00002398 <led_cw_breath_is_running>:

bool led_cw_breath_is_running(void)
{
    2398:	b510      	push	{r4, lr}
	return SYS_TimerisExist(&breathTmr);
    239a:	4802      	ldr	r0, [pc, #8]	; (23a4 <led_cw_breath_is_running+0xc>)
    239c:	3024      	adds	r0, #36	; 0x24
    239e:	f7ff fcff 	bl	1da0 <SYS_TimerisExist>
}
    23a2:	bd10      	pop	{r4, pc}
    23a4:	10010fc0 	.word	0x10010fc0

000023a8 <led_ltn_ctrl>:


void led_ltn_ctrl(light_ltn_t* t)
{
    23a8:	b510      	push	{r4, lr}
#ifndef RELEASE
	printf("------ln[%x]",ltn.ln);
#endif
	uint16_t ln = ltn.ln/0x28f * (ALI_FREQUENCY_16K/100);//[1,100]
    23aa:	4b0e      	ldr	r3, [pc, #56]	; (23e4 <led_ltn_ctrl+0x3c>)
    23ac:	490e      	ldr	r1, [pc, #56]	; (23e8 <led_ltn_ctrl+0x40>)
    23ae:	8b58      	ldrh	r0, [r3, #26]
    23b0:	f001 ff9d 	bl	42ee <__aeabi_uidiv>
    23b4:	230f      	movs	r3, #15
    23b6:	4358      	muls	r0, r3
    23b8:	b281      	uxth	r1, r0
	if(ln){
    23ba:	2900      	cmp	r1, #0
    23bc:	d009      	beq.n	23d2 <led_ltn_ctrl+0x2a>
		PWM_SetPnCnt(PWM_CH5, ln, ALI_FREQUENCY_16K-ln);
    23be:	4a0b      	ldr	r2, [pc, #44]	; (23ec <led_ltn_ctrl+0x44>)
    23c0:	2020      	movs	r0, #32
    23c2:	1a52      	subs	r2, r2, r1
    23c4:	b292      	uxth	r2, r2
    23c6:	f7ff fc25 	bl	1c14 <PWM_SetPnCnt>
		PWM_Start(PWM_CH5);
    23ca:	2020      	movs	r0, #32
    23cc:	f7ff fbe2 	bl	1b94 <PWM_Start>
		return;
    23d0:	e006      	b.n	23e0 <led_ltn_ctrl+0x38>
	}
	PWM_SetPnCnt(PWM_CH5, 0, 0);
    23d2:	2020      	movs	r0, #32
    23d4:	000a      	movs	r2, r1
    23d6:	f7ff fc1d 	bl	1c14 <PWM_SetPnCnt>
	PWM_DeInit(PWM_CH5);
    23da:	2020      	movs	r0, #32
    23dc:	f7ff fb9a 	bl	1b14 <PWM_DeInit>
}
    23e0:	bd10      	pop	{r4, pc}
    23e2:	46c0      	nop			; (mov r8, r8)
    23e4:	10010fc0 	.word	0x10010fc0
    23e8:	0000028f 	.word	0x0000028f
    23ec:	000005dc 	.word	0x000005dc

000023f0 <led_ltn_set_lightness>:


void led_ltn_set_lightness(uint16_t ln)
{
    23f0:	b510      	push	{r4, lr}
	ltn.ln = ln;
    23f2:	4b03      	ldr	r3, [pc, #12]	; (2400 <led_ltn_set_lightness+0x10>)
    23f4:	8358      	strh	r0, [r3, #26]
	led_ltn_ctrl(&ltn);
    23f6:	3314      	adds	r3, #20
    23f8:	0018      	movs	r0, r3
    23fa:	f7ff ffd5 	bl	23a8 <led_ltn_ctrl>
}
    23fe:	bd10      	pop	{r4, pc}
    2400:	10010fc0 	.word	0x10010fc0

00002404 <led_ltn_get_lightness>:

uint16_t led_ltn_get_lightness(void)
{
	return ltn.ln;
    2404:	4b01      	ldr	r3, [pc, #4]	; (240c <led_ltn_get_lightness+0x8>)
    2406:	8b58      	ldrh	r0, [r3, #26]
}
    2408:	4770      	bx	lr
    240a:	46c0      	nop			; (mov r8, r8)
    240c:	10010fc0 	.word	0x10010fc0

00002410 <led_ltn_set_on_off>:

void led_ltn_set_on_off(uint8_t on)
{
	ltn.ln = on?65535:0;  
    2410:	1e42      	subs	r2, r0, #1
    2412:	4190      	sbcs	r0, r2
{
	return ltn.ln;
}

void led_ltn_set_on_off(uint8_t on)
{
    2414:	b510      	push	{r4, lr}
	ltn.ln = on?65535:0;  
    2416:	4b04      	ldr	r3, [pc, #16]	; (2428 <led_ltn_set_on_off+0x18>)
    2418:	4240      	negs	r0, r0
    241a:	8358      	strh	r0, [r3, #26]
	led_ltn_ctrl(&ltn);
    241c:	3314      	adds	r3, #20
    241e:	0018      	movs	r0, r3
    2420:	f7ff ffc2 	bl	23a8 <led_ltn_ctrl>
}
    2424:	bd10      	pop	{r4, pc}
    2426:	46c0      	nop			; (mov r8, r8)
    2428:	10010fc0 	.word	0x10010fc0

0000242c <led_ltn_get_on_off>:

uint8_t led_ltn_get_on_off(void)
{
	return ltn.ln?1:0;
    242c:	4b02      	ldr	r3, [pc, #8]	; (2438 <led_ltn_get_on_off+0xc>)
    242e:	8b58      	ldrh	r0, [r3, #26]
    2430:	1e43      	subs	r3, r0, #1
    2432:	4198      	sbcs	r0, r3
    2434:	b2c0      	uxtb	r0, r0
}
    2436:	4770      	bx	lr
    2438:	10010fc0 	.word	0x10010fc0

0000243c <led_ltn_init>:

void led_ltn_init(light_ltn_t* t)
{
    243c:	b513      	push	{r0, r1, r4, lr}
	GPIO_CFG cfg4 ={FUNC_PWM_OUT5, GFG_PULLUP};
    243e:	466a      	mov	r2, sp
    2440:	4b0e      	ldr	r3, [pc, #56]	; (247c <led_ltn_init+0x40>)
	bc_gpio_init(ALI_PWM5_W, &cfg4);
    2442:	4669      	mov	r1, sp
	return ltn.ln?1:0;
}

void led_ltn_init(light_ltn_t* t)
{
	GPIO_CFG cfg4 ={FUNC_PWM_OUT5, GFG_PULLUP};
    2444:	785b      	ldrb	r3, [r3, #1]
{
	return ltn.ln?1:0;
}

void led_ltn_init(light_ltn_t* t)
{
    2446:	0004      	movs	r4, r0
	GPIO_CFG cfg4 ={FUNC_PWM_OUT5, GFG_PULLUP};
	bc_gpio_init(ALI_PWM5_W, &cfg4);
    2448:	2018      	movs	r0, #24
	return ltn.ln?1:0;
}

void led_ltn_init(light_ltn_t* t)
{
	GPIO_CFG cfg4 ={FUNC_PWM_OUT5, GFG_PULLUP};
    244a:	7013      	strb	r3, [r2, #0]
	bc_gpio_init(ALI_PWM5_W, &cfg4);
    244c:	f7ff fd50 	bl	1ef0 <bc_gpio_init>

	struct PWM_CTRL_BITS bits = {0};
    2450:	2300      	movs	r3, #0
    2452:	a901      	add	r1, sp, #4
	//bits.ENABLE = PWM_DISABLE;
	//bits.HIGHF = 0;
	//bits.SYNC = 0;
	//bits.VAL = 0;
	PWM_Init(PWM_CH5, &bits);
    2454:	2020      	movs	r0, #32
void led_ltn_init(light_ltn_t* t)
{
	GPIO_CFG cfg4 ={FUNC_PWM_OUT5, GFG_PULLUP};
	bc_gpio_init(ALI_PWM5_W, &cfg4);

	struct PWM_CTRL_BITS bits = {0};
    2456:	700b      	strb	r3, [r1, #0]
	//bits.ENABLE = PWM_DISABLE;
	//bits.HIGHF = 0;
	//bits.SYNC = 0;
	//bits.VAL = 0;
	PWM_Init(PWM_CH5, &bits);
    2458:	f7ff fb2c 	bl	1ab4 <PWM_Init>
    245c:	4b08      	ldr	r3, [pc, #32]	; (2480 <led_ltn_init+0x44>)
	if(t==NULL){
    245e:	2c00      	cmp	r4, #0
    2460:	d103      	bne.n	246a <led_ltn_init+0x2e>
		ltn.ln = ALI_DEFAULT_LN_VAL;
    2462:	2224      	movs	r2, #36	; 0x24
    2464:	4252      	negs	r2, r2
    2466:	835a      	strh	r2, [r3, #26]
    2468:	e003      	b.n	2472 <led_ltn_init+0x36>
	}
	else{
		ltn = *t;
    246a:	001a      	movs	r2, r3
    246c:	3214      	adds	r2, #20
    246e:	cc03      	ldmia	r4!, {r0, r1}
    2470:	c203      	stmia	r2!, {r0, r1}
	}
	led_ltn_ctrl(&ltn);
    2472:	3314      	adds	r3, #20
    2474:	0018      	movs	r0, r3
    2476:	f7ff ff97 	bl	23a8 <led_ltn_ctrl>
}
    247a:	bd13      	pop	{r0, r1, r4, pc}
    247c:	0001fe34 	.word	0x0001fe34
    2480:	10010fc0 	.word	0x10010fc0

00002484 <led_rgb_set_color>:
 * FOR RGB
 */
void led_rgb_set_color(uint16_t r, uint16_t g, uint16_t b)
{

}
    2484:	4770      	bx	lr

00002486 <led_rgb_get_color>:

void led_rgb_get_color(uint16_t* r, uint16_t* g, uint16_t* b)
{

}
    2486:	4770      	bx	lr

00002488 <led_rgb_set_lightness>:

void led_rgb_set_lightness(uint16_t ln)
{

}
    2488:	4770      	bx	lr

0000248a <led_rgb_get_lightness>:

uint16_t led_rgb_get_lightness(void)
{
	return 0;
}
    248a:	2000      	movs	r0, #0
    248c:	4770      	bx	lr

0000248e <led_rgb_set_on_off>:

void led_rgb_set_on_off(uint8_t on)
{

}
    248e:	4770      	bx	lr

00002490 <led_rgb_get_on_off>:

uint8_t led_rgb_get_on_off(void)
{
	return 0;
}
    2490:	2000      	movs	r0, #0
    2492:	4770      	bx	lr

00002494 <led_rgb_init>:

void led_rgb_init(light_rgb_t* t)
{

}
    2494:	4770      	bx	lr

00002496 <_cw_ctrl.constprop.1>:
		lcw = *t;
	}
	_cw_ctrl(&lcw);
}

static void _cw_ctrl(light_cw_t* t)
    2496:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	uint8_t ln = lcw.ln/0x28f;//[1,100]
	//uint8_t ln = ((lcw.ln/0x28f)*(lcw.ln/0x28f))/100;//[1,100]
	uint8_t tp = (lcw.tp-800)/192;//[0,100]
	//ln = ln*ln/100;
	uint16_t c,w;
	if(t->on || t->onTarget){
    2498:	4c31      	ldr	r4, [pc, #196]	; (2560 <_cw_ctrl.constprop.1+0xca>)
    249a:	8925      	ldrh	r5, [r4, #8]
    249c:	2d00      	cmp	r5, #0
    249e:	d04d      	beq.n	253c <_cw_ctrl.constprop.1+0xa6>
		uint16_t _percent = lcw.freq/100;
    24a0:	88a3      	ldrh	r3, [r4, #4]
    24a2:	21c0      	movs	r1, #192	; 0xc0
    24a4:	9300      	str	r3, [sp, #0]
    24a6:	89e0      	ldrh	r0, [r4, #14]
    24a8:	4b2e      	ldr	r3, [pc, #184]	; (2564 <_cw_ctrl.constprop.1+0xce>)
    24aa:	18c0      	adds	r0, r0, r3
    24ac:	f001 fef7 	bl	429e <__aeabi_idiv>
		c = tp*_percent*ln/100;
    24b0:	2164      	movs	r1, #100	; 0x64
    24b2:	b2c7      	uxtb	r7, r0
    24b4:	9800      	ldr	r0, [sp, #0]
    24b6:	f001 ff1a 	bl	42ee <__aeabi_uidiv>
    24ba:	492b      	ldr	r1, [pc, #172]	; (2568 <_cw_ctrl.constprop.1+0xd2>)
    24bc:	b286      	uxth	r6, r0
    24be:	8960      	ldrh	r0, [r4, #10]
    24c0:	f001 ff15 	bl	42ee <__aeabi_uidiv>
    24c4:	b283      	uxth	r3, r0
    24c6:	0030      	movs	r0, r6
    24c8:	4378      	muls	r0, r7
    24ca:	2164      	movs	r1, #100	; 0x64
    24cc:	4358      	muls	r0, r3
    24ce:	9301      	str	r3, [sp, #4]
    24d0:	f001 fee5 	bl	429e <__aeabi_idiv>
		w = (100-tp)*_percent*ln/100;
    24d4:	2164      	movs	r1, #100	; 0x64
	uint8_t tp = (lcw.tp-800)/192;//[0,100]
	//ln = ln*ln/100;
	uint16_t c,w;
	if(t->on || t->onTarget){
		uint16_t _percent = lcw.freq/100;
		c = tp*_percent*ln/100;
    24d6:	b285      	uxth	r5, r0
		w = (100-tp)*_percent*ln/100;
    24d8:	1bc8      	subs	r0, r1, r7
    24da:	4370      	muls	r0, r6
    24dc:	9b01      	ldr	r3, [sp, #4]
    24de:	4358      	muls	r0, r3
    24e0:	f001 fedd 	bl	429e <__aeabi_idiv>
    24e4:	b286      	uxth	r6, r0
#ifndef RELEASE
		printf("on[%d] ln[%d] tp[%d] c[%d] w[%d]\r\n",t->on||t->onTarget, ln, tp, c, w);
#endif
		if(c){
    24e6:	2d00      	cmp	r5, #0
    24e8:	d00a      	beq.n	2500 <_cw_ctrl.constprop.1+0x6a>
			PWM_SetPnCnt(PWM_CH4, c, lcw.freq-c);//cold
    24ea:	9b00      	ldr	r3, [sp, #0]
    24ec:	0029      	movs	r1, r5
    24ee:	1b5a      	subs	r2, r3, r5
    24f0:	b292      	uxth	r2, r2
    24f2:	2010      	movs	r0, #16
    24f4:	f7ff fb8e 	bl	1c14 <PWM_SetPnCnt>
			PWM_Start(PWM_CH4);
    24f8:	2010      	movs	r0, #16
    24fa:	f7ff fb4b 	bl	1b94 <PWM_Start>
    24fe:	e007      	b.n	2510 <_cw_ctrl.constprop.1+0x7a>
		}
		else{
			PWM_SetPnCnt(PWM_CH4, 0, 0);
    2500:	2010      	movs	r0, #16
    2502:	002a      	movs	r2, r5
    2504:	0029      	movs	r1, r5
    2506:	f7ff fb85 	bl	1c14 <PWM_SetPnCnt>
			PWM_DeInit(PWM_CH4);
    250a:	2010      	movs	r0, #16
    250c:	f7ff fb02 	bl	1b14 <PWM_DeInit>
		}
		if(w){
    2510:	2e00      	cmp	r6, #0
    2512:	d00a      	beq.n	252a <_cw_ctrl.constprop.1+0x94>
			PWM_SetPnCnt(PWM_CH5, w, lcw.freq-w);//warm
    2514:	88a2      	ldrh	r2, [r4, #4]
    2516:	0031      	movs	r1, r6
    2518:	1b92      	subs	r2, r2, r6
    251a:	b292      	uxth	r2, r2
    251c:	2020      	movs	r0, #32
    251e:	f7ff fb79 	bl	1c14 <PWM_SetPnCnt>
			PWM_Start(PWM_CH5);
    2522:	2020      	movs	r0, #32
    2524:	f7ff fb36 	bl	1b94 <PWM_Start>
    2528:	e018      	b.n	255c <_cw_ctrl.constprop.1+0xc6>
		}
		else{
			PWM_SetPnCnt(PWM_CH5, 0, 0);
    252a:	0032      	movs	r2, r6
    252c:	0031      	movs	r1, r6
    252e:	2020      	movs	r0, #32
    2530:	f7ff fb70 	bl	1c14 <PWM_SetPnCnt>
			PWM_DeInit(PWM_CH5);
    2534:	2020      	movs	r0, #32
    2536:	f7ff faed 	bl	1b14 <PWM_DeInit>
    253a:	e00f      	b.n	255c <_cw_ctrl.constprop.1+0xc6>
		}
		return;
	}
	
	PWM_SetPnCnt(PWM_CH4, 0, 0);
    253c:	002a      	movs	r2, r5
    253e:	0029      	movs	r1, r5
    2540:	2010      	movs	r0, #16
    2542:	f7ff fb67 	bl	1c14 <PWM_SetPnCnt>
	PWM_SetPnCnt(PWM_CH5, 0, 0);
    2546:	002a      	movs	r2, r5
    2548:	0029      	movs	r1, r5
    254a:	2020      	movs	r0, #32
    254c:	f7ff fb62 	bl	1c14 <PWM_SetPnCnt>
	PWM_DeInit(PWM_CH4);
    2550:	2010      	movs	r0, #16
    2552:	f7ff fadf 	bl	1b14 <PWM_DeInit>
	PWM_DeInit(PWM_CH5);
    2556:	2020      	movs	r0, #32
    2558:	f7ff fadc 	bl	1b14 <PWM_DeInit>
}
    255c:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
    255e:	46c0      	nop			; (mov r8, r8)
    2560:	10010fc0 	.word	0x10010fc0
    2564:	fffffce0 	.word	0xfffffce0
    2568:	0000028f 	.word	0x0000028f

0000256c <systick_init>:
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) < 0)
  {
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
    256c:	20c0      	movs	r0, #192	; 0xc0
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
  {
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
    256e:	4a07      	ldr	r2, [pc, #28]	; (258c <systick_init+0x20>)
    2570:	4b07      	ldr	r3, [pc, #28]	; (2590 <systick_init+0x24>)
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) < 0)
  {
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
    2572:	4908      	ldr	r1, [pc, #32]	; (2594 <systick_init+0x28>)
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
  {
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
    2574:	6053      	str	r3, [r2, #4]
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) < 0)
  {
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
    2576:	6a0b      	ldr	r3, [r1, #32]
    2578:	0600      	lsls	r0, r0, #24
    257a:	021b      	lsls	r3, r3, #8
    257c:	0a1b      	lsrs	r3, r3, #8
    257e:	4303      	orrs	r3, r0
    2580:	620b      	str	r3, [r1, #32]
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
    2582:	2300      	movs	r3, #0
    2584:	6093      	str	r3, [r2, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
    2586:	3307      	adds	r3, #7
    2588:	6013      	str	r3, [r2, #0]
uint32_t tick_count = 0;

void systick_init(void)
{
   SysTick_Config(SystemCoreClock/TICK_PER_SECOND);
}
    258a:	4770      	bx	lr
    258c:	e000e010 	.word	0xe000e010
    2590:	00005dbf 	.word	0x00005dbf
    2594:	e000ed00 	.word	0xe000ed00

00002598 <systick_get_us>:
// Return system uptime in microseconds (rollover in 70minutes)
uint32_t systick_get_us(void) 
{
    2598:	b510      	push	{r4, lr}
    do {
        ms = tick_count;
        cycle_cnt = SysTick->VAL;
    } while (ms != tick_count);
	
    return ms * TICK_US + (SysTick->LOAD - cycle_cnt) * TICK_US / SysTick->LOAD;
    259a:	24fa      	movs	r4, #250	; 0xfa
{

    register uint32_t ms, cycle_cnt;
    do {
        ms = tick_count;
        cycle_cnt = SysTick->VAL;
    259c:	4a06      	ldr	r2, [pc, #24]	; (25b8 <systick_get_us+0x20>)
    } while (ms != tick_count);
	
    return ms * TICK_US + (SysTick->LOAD - cycle_cnt) * TICK_US / SysTick->LOAD;
    259e:	00a4      	lsls	r4, r4, #2
{

    register uint32_t ms, cycle_cnt;
    do {
        ms = tick_count;
        cycle_cnt = SysTick->VAL;
    25a0:	6890      	ldr	r0, [r2, #8]
    } while (ms != tick_count);
	
    return ms * TICK_US + (SysTick->LOAD - cycle_cnt) * TICK_US / SysTick->LOAD;
    25a2:	6853      	ldr	r3, [r2, #4]
    25a4:	6851      	ldr	r1, [r2, #4]
    25a6:	1a18      	subs	r0, r3, r0
    25a8:	4360      	muls	r0, r4
    25aa:	f001 fea0 	bl	42ee <__aeabi_uidiv>
uint32_t systick_get_us(void) 
{

    register uint32_t ms, cycle_cnt;
    do {
        ms = tick_count;
    25ae:	4b03      	ldr	r3, [pc, #12]	; (25bc <systick_get_us+0x24>)
        cycle_cnt = SysTick->VAL;
    } while (ms != tick_count);
	
    return ms * TICK_US + (SysTick->LOAD - cycle_cnt) * TICK_US / SysTick->LOAD;
    25b0:	681b      	ldr	r3, [r3, #0]
    25b2:	435c      	muls	r4, r3
    25b4:	1900      	adds	r0, r0, r4
}
    25b6:	bd10      	pop	{r4, pc}
    25b8:	e000e010 	.word	0xe000e010
    25bc:	10010ffc 	.word	0x10010ffc

000025c0 <systick_get_ms>:
uint32_t systick_get_ms(void)
{
 return tick_count;
    25c0:	4b01      	ldr	r3, [pc, #4]	; (25c8 <systick_get_ms+0x8>)
    25c2:	6818      	ldr	r0, [r3, #0]
}
    25c4:	4770      	bx	lr
    25c6:	46c0      	nop			; (mov r8, r8)
    25c8:	10010ffc 	.word	0x10010ffc

000025cc <delay_us>:
void delay_us(uint32_t us)
{
    25cc:	b570      	push	{r4, r5, r6, lr}
    25ce:	0004      	movs	r4, r0
    uint32_t now = systick_get_us();
    25d0:	f7ff ffe2 	bl	2598 <systick_get_us>
    25d4:	0005      	movs	r5, r0
    while (systick_get_us() - now < us);
    25d6:	f7ff ffdf 	bl	2598 <systick_get_us>
    25da:	1b40      	subs	r0, r0, r5
    25dc:	42a0      	cmp	r0, r4
    25de:	d3fa      	bcc.n	25d6 <delay_us+0xa>
}
    25e0:	bd70      	pop	{r4, r5, r6, pc}

000025e2 <delay_ms>:
void delay_ms(uint32_t ms)
{
      uint32_t now = tick_count;
    while (tick_count - now < ms);
    25e2:	2800      	cmp	r0, #0
    25e4:	d1fd      	bne.n	25e2 <delay_ms>
}
    25e6:	4770      	bx	lr

000025e8 <SysTick_Handler>:
void SysTick_Handler(void) 
{
    25e8:	b510      	push	{r4, lr}
	tick_count++;
    25ea:	4a03      	ldr	r2, [pc, #12]	; (25f8 <SysTick_Handler+0x10>)
    25ec:	6813      	ldr	r3, [r2, #0]
    25ee:	3301      	adds	r3, #1
    25f0:	6013      	str	r3, [r2, #0]
	SYStick_handle();
    25f2:	f7ff fc5f 	bl	1eb4 <SYStick_handle>
    25f6:	bd10      	pop	{r4, pc}
    25f8:	10010ffc 	.word	0x10010ffc

000025fc <_fstat>:
#include "bc62xx_ble.h"
//#include "Drv_debug.h"

int _fstat (int fd, struct stat *pStat)
{
	pStat->st_mode = S_IFCHR;
    25fc:	2380      	movs	r3, #128	; 0x80
    25fe:	019b      	lsls	r3, r3, #6
	return 0;
}
    2600:	2000      	movs	r0, #0
#include "bc62xx_ble.h"
//#include "Drv_debug.h"

int _fstat (int fd, struct stat *pStat)
{
	pStat->st_mode = S_IFCHR;
    2602:	604b      	str	r3, [r1, #4]
	return 0;
}
    2604:	4770      	bx	lr

00002606 <_close>:

int _close(int fd)
{
	return -1;
}
    2606:	2001      	movs	r0, #1
    2608:	4240      	negs	r0, r0
    260a:	4770      	bx	lr

0000260c <_write>:

extern void UART_PutChar(char c);
int _write (int fd, char *ptr, int len)
{
    260c:	b570      	push	{r4, r5, r6, lr}
    260e:	000e      	movs	r6, r1
    2610:	0014      	movs	r4, r2
    2612:	000d      	movs	r5, r1
	int i = 0;

	if (fd > 2)
    2614:	2802      	cmp	r0, #2
    2616:	dc09      	bgt.n	262c <_write+0x20>
		return -1;

	while(*ptr && (i < len))\
    2618:	7828      	ldrb	r0, [r5, #0]
    261a:	2800      	cmp	r0, #0
    261c:	d009      	beq.n	2632 <_write+0x26>
    261e:	1bab      	subs	r3, r5, r6
    2620:	429c      	cmp	r4, r3
    2622:	dd06      	ble.n	2632 <_write+0x26>
	{
		UART_PutChar(*ptr);
    2624:	f7ff f9d4 	bl	19d0 <UART_PutChar>
		i++;
		ptr++;
    2628:	3501      	adds	r5, #1
    262a:	e7f5      	b.n	2618 <_write+0xc>
int _write (int fd, char *ptr, int len)
{
	int i = 0;

	if (fd > 2)
		return -1;
    262c:	2001      	movs	r0, #1
    262e:	4240      	negs	r0, r0
    2630:	e000      	b.n	2634 <_write+0x28>
    2632:	0020      	movs	r0, r4
		i++;
		ptr++;
	}
   
 	return len;
}
    2634:	bd70      	pop	{r4, r5, r6, pc}

00002636 <_isatty>:

int _isatty (int fd)
{
	return 1;
}
    2636:	2001      	movs	r0, #1
    2638:	4770      	bx	lr

0000263a <_lseek>:

int _lseek(int fd, int offset, int fromwhere)
{
	return 0;
}
    263a:	2000      	movs	r0, #0
    263c:	4770      	bx	lr

0000263e <_read>:

int _read (int fd, char *pBuffer, int size)
{
	return 0;
}
    263e:	2000      	movs	r0, #0
    2640:	4770      	bx	lr

00002642 <_sbrk>:
caddr_t _sbrk(int increment)
{
	extern char end asm("end");
	register char *pStack asm("sp");
	static char *s_pHeapEnd;
	if (!s_pHeapEnd)
    2642:	4b08      	ldr	r3, [pc, #32]	; (2664 <_sbrk+0x22>)
{
	return 0;
}

caddr_t _sbrk(int increment)
{
    2644:	0002      	movs	r2, r0
	extern char end asm("end");
	register char *pStack asm("sp");
	static char *s_pHeapEnd;
	if (!s_pHeapEnd)
    2646:	6819      	ldr	r1, [r3, #0]
    2648:	2900      	cmp	r1, #0
    264a:	d101      	bne.n	2650 <_sbrk+0xe>
		s_pHeapEnd = &end;
    264c:	4906      	ldr	r1, [pc, #24]	; (2668 <_sbrk+0x26>)
    264e:	6019      	str	r1, [r3, #0]

	if (s_pHeapEnd + increment > pStack)
    2650:	4669      	mov	r1, sp
    2652:	6818      	ldr	r0, [r3, #0]
    2654:	1882      	adds	r2, r0, r2
    2656:	428a      	cmp	r2, r1
    2658:	d801      	bhi.n	265e <_sbrk+0x1c>
		return (caddr_t)-1;

	char *pOldHeapEnd = s_pHeapEnd;
	s_pHeapEnd += increment;
    265a:	601a      	str	r2, [r3, #0]
	return (caddr_t)pOldHeapEnd;
    265c:	e001      	b.n	2662 <_sbrk+0x20>
	static char *s_pHeapEnd;
	if (!s_pHeapEnd)
		s_pHeapEnd = &end;

	if (s_pHeapEnd + increment > pStack)
		return (caddr_t)-1;
    265e:	2001      	movs	r0, #1
    2660:	4240      	negs	r0, r0

	char *pOldHeapEnd = s_pHeapEnd;
	s_pHeapEnd += increment;
	return (caddr_t)pOldHeapEnd;
}
    2662:	4770      	bx	lr
    2664:	10011000 	.word	0x10011000
    2668:	100128b0 	.word	0x100128b0

0000266c <_exit>:

void _exit(int status)
{
    266c:	e7fe      	b.n	266c <_exit>

0000266e <Default_Handler>:
	while(1);
}


void Default_Handler(void)
{
    266e:	b510      	push	{r4, lr}
	printf("\r\n\r\nDefault_Handler\r\n\r\n");
    2670:	4801      	ldr	r0, [pc, #4]	; (2678 <Default_Handler+0xa>)
    2672:	f013 fa8d 	bl	15b90 <puts>
    2676:	e7fe      	b.n	2676 <Default_Handler+0x8>
    2678:	0001fe36 	.word	0x0001fe36

0000267c <bc_sys_reset>:
 ****************************************************************************************
 */
uint32_t bc_sys_reset(void)
{
	//HWRITE(CORE_RESET, 1);
	HWRITE(CORE_RESET,0x03);
    267c:	2203      	movs	r2, #3
    267e:	4b02      	ldr	r3, [pc, #8]	; (2688 <bc_sys_reset+0xc>)
	return 0;
}
    2680:	2000      	movs	r0, #0
 ****************************************************************************************
 */
uint32_t bc_sys_reset(void)
{
	//HWRITE(CORE_RESET, 1);
	HWRITE(CORE_RESET,0x03);
    2682:	701a      	strb	r2, [r3, #0]
	return 0;
}
    2684:	4770      	bx	lr
    2686:	46c0      	nop			; (mov r8, r8)
    2688:	10008010 	.word	0x10008010

0000268c <bc_sys_check_sum>:

uint8_t bc_sys_check_sum(uint8_t* data, int len)
{
	uint8_t crc = 0x00;/* init crc value*/ 
    268c:	2300      	movs	r3, #0
	do{
		crc += data[--len];
    268e:	3901      	subs	r1, #1
    2690:	5c42      	ldrb	r2, [r0, r1]
    2692:	189b      	adds	r3, r3, r2
    2694:	b2db      	uxtb	r3, r3
	}while(len);
    2696:	2900      	cmp	r1, #0
    2698:	d1f9      	bne.n	268e <bc_sys_check_sum+0x2>
	return crc;
}
    269a:	0018      	movs	r0, r3
    269c:	4770      	bx	lr
    269e:	46c0      	nop			; (mov r8, r8)

000026a0 <app_mesh_enabled_cb>:
		.app_deinit = ali_heating_table_deinit,
	},
};
__STATIC void app_mesh_enabled_cb(uint16_t status)
{
	M_PRINTF(L_APP, "");
    26a0:	4b0d      	ldr	r3, [pc, #52]	; (26d8 <app_mesh_enabled_cb+0x38>)
		.app_init = ali_heating_table_init,
		.app_deinit = ali_heating_table_deinit,
	},
};
__STATIC void app_mesh_enabled_cb(uint16_t status)
{
    26a2:	b537      	push	{r0, r1, r2, r4, r5, lr}
	M_PRINTF(L_APP, "");
    26a4:	681b      	ldr	r3, [r3, #0]
    26a6:	049b      	lsls	r3, r3, #18
    26a8:	d515      	bpl.n	26d6 <app_mesh_enabled_cb+0x36>
    26aa:	4c0c      	ldr	r4, [pc, #48]	; (26dc <app_mesh_enabled_cb+0x3c>)
    26ac:	4d0c      	ldr	r5, [pc, #48]	; (26e0 <app_mesh_enabled_cb+0x40>)
    26ae:	0023      	movs	r3, r4
    26b0:	0022      	movs	r2, r4
    26b2:	0020      	movs	r0, r4
    26b4:	3344      	adds	r3, #68	; 0x44
    26b6:	0029      	movs	r1, r5
    26b8:	322a      	adds	r2, #42	; 0x2a
    26ba:	9300      	str	r3, [sp, #0]
    26bc:	3035      	adds	r0, #53	; 0x35
    26be:	233f      	movs	r3, #63	; 0x3f
    26c0:	f002 f974 	bl	49ac <m_print>
    26c4:	0020      	movs	r0, r4
    26c6:	3058      	adds	r0, #88	; 0x58
    26c8:	f002 f970 	bl	49ac <m_print>
    26cc:	0020      	movs	r0, r4
    26ce:	1da9      	adds	r1, r5, #6
    26d0:	3059      	adds	r0, #89	; 0x59
    26d2:	f002 f96b 	bl	49ac <m_print>
}
    26d6:	bd37      	pop	{r0, r1, r2, r4, r5, pc}
    26d8:	10010514 	.word	0x10010514
    26dc:	0001fed0 	.word	0x0001fed0
    26e0:	0001fe50 	.word	0x0001fe50

000026e4 <app_mesh_disabled_cb>:

__STATIC void app_mesh_disabled_cb(uint16_t status)
{
	M_PRINTF(L_APP, "");
    26e4:	4b10      	ldr	r3, [pc, #64]	; (2728 <app_mesh_disabled_cb+0x44>)
{
	M_PRINTF(L_APP, "");
}

__STATIC void app_mesh_disabled_cb(uint16_t status)
{
    26e6:	b537      	push	{r0, r1, r2, r4, r5, lr}
	M_PRINTF(L_APP, "");
    26e8:	681b      	ldr	r3, [r3, #0]
    26ea:	049b      	lsls	r3, r3, #18
    26ec:	d515      	bpl.n	271a <app_mesh_disabled_cb+0x36>
    26ee:	4c0f      	ldr	r4, [pc, #60]	; (272c <app_mesh_disabled_cb+0x48>)
    26f0:	4d0f      	ldr	r5, [pc, #60]	; (2730 <app_mesh_disabled_cb+0x4c>)
    26f2:	0023      	movs	r3, r4
    26f4:	0022      	movs	r2, r4
    26f6:	0020      	movs	r0, r4
    26f8:	335c      	adds	r3, #92	; 0x5c
    26fa:	0029      	movs	r1, r5
    26fc:	322a      	adds	r2, #42	; 0x2a
    26fe:	9300      	str	r3, [sp, #0]
    2700:	3035      	adds	r0, #53	; 0x35
    2702:	2344      	movs	r3, #68	; 0x44
    2704:	f002 f952 	bl	49ac <m_print>
    2708:	0020      	movs	r0, r4
    270a:	3058      	adds	r0, #88	; 0x58
    270c:	f002 f94e 	bl	49ac <m_print>
    2710:	0020      	movs	r0, r4
    2712:	1da9      	adds	r1, r5, #6
    2714:	3059      	adds	r0, #89	; 0x59
    2716:	f002 f949 	bl	49ac <m_print>
	ali_app->app_t->factory_reset();
    271a:	4b06      	ldr	r3, [pc, #24]	; (2734 <app_mesh_disabled_cb+0x50>)
    271c:	681b      	ldr	r3, [r3, #0]
    271e:	6a1b      	ldr	r3, [r3, #32]
    2720:	681b      	ldr	r3, [r3, #0]
    2722:	4798      	blx	r3
}
    2724:	bd37      	pop	{r0, r1, r2, r4, r5, pc}
    2726:	46c0      	nop			; (mov r8, r8)
    2728:	10010514 	.word	0x10010514
    272c:	0001fed0 	.word	0x0001fed0
    2730:	0001fe50 	.word	0x0001fe50
    2734:	10011004 	.word	0x10011004

00002738 <app_mesh_prov_timeout_timer_cb>:
static void app_mesh_prov_timeout_timer_cb(void* param)
{
    2738:	b510      	push	{r4, lr}
	bc_m_bcn_stop_tx_unprov_bcn();
    273a:	f006 fdde 	bl	92fa <bc_m_bcn_stop_tx_unprov_bcn>
}
    273e:	bd10      	pop	{r4, pc}

00002740 <app_mesh_prov_state_cb>:

__STATIC void app_mesh_prov_state_cb(uint8_t state, uint16_t status)
{
	
	M_PRINTF(L_APP, "state[%s]", app_mesh_prov_state_str[state]);
    2740:	4b1a      	ldr	r3, [pc, #104]	; (27ac <app_mesh_prov_state_cb+0x6c>)
{
	bc_m_bcn_stop_tx_unprov_bcn();
}

__STATIC void app_mesh_prov_state_cb(uint8_t state, uint16_t status)
{
    2742:	b573      	push	{r0, r1, r4, r5, r6, lr}
	
	M_PRINTF(L_APP, "state[%s]", app_mesh_prov_state_str[state]);
    2744:	681b      	ldr	r3, [r3, #0]
{
	bc_m_bcn_stop_tx_unprov_bcn();
}

__STATIC void app_mesh_prov_state_cb(uint8_t state, uint16_t status)
{
    2746:	0005      	movs	r5, r0
	
	M_PRINTF(L_APP, "state[%s]", app_mesh_prov_state_str[state]);
    2748:	049b      	lsls	r3, r3, #18
    274a:	d518      	bpl.n	277e <app_mesh_prov_state_cb+0x3e>
    274c:	4c18      	ldr	r4, [pc, #96]	; (27b0 <app_mesh_prov_state_cb+0x70>)
    274e:	4e19      	ldr	r6, [pc, #100]	; (27b4 <app_mesh_prov_state_cb+0x74>)
    2750:	0023      	movs	r3, r4
    2752:	0022      	movs	r2, r4
    2754:	0020      	movs	r0, r4
    2756:	3371      	adds	r3, #113	; 0x71
    2758:	322a      	adds	r2, #42	; 0x2a
    275a:	9300      	str	r3, [sp, #0]
    275c:	0031      	movs	r1, r6
    275e:	234f      	movs	r3, #79	; 0x4f
    2760:	3035      	adds	r0, #53	; 0x35
    2762:	f002 f923 	bl	49ac <m_print>
    2766:	4b14      	ldr	r3, [pc, #80]	; (27b8 <app_mesh_prov_state_cb+0x78>)
    2768:	4814      	ldr	r0, [pc, #80]	; (27bc <app_mesh_prov_state_cb+0x7c>)
    276a:	00aa      	lsls	r2, r5, #2
    276c:	58d1      	ldr	r1, [r2, r3]
    276e:	3008      	adds	r0, #8
    2770:	f002 f91c 	bl	49ac <m_print>
    2774:	0020      	movs	r0, r4
    2776:	1db1      	adds	r1, r6, #6
    2778:	3059      	adds	r0, #89	; 0x59
    277a:	f002 f917 	bl	49ac <m_print>
    277e:	4c10      	ldr	r4, [pc, #64]	; (27c0 <app_mesh_prov_state_cb+0x80>)
	if(state == M_PROV_STARTED){
    2780:	2d00      	cmp	r5, #0
    2782:	d107      	bne.n	2794 <app_mesh_prov_state_cb+0x54>
			SYS_SetTimer(&ali_app->provTimeoutTimer, (int)ALI_PROV_TIMEOUT_TIME/10, 
    2784:	6820      	ldr	r0, [r4, #0]
    2786:	4b0f      	ldr	r3, [pc, #60]	; (27c4 <app_mesh_prov_state_cb+0x84>)
    2788:	002a      	movs	r2, r5
    278a:	490f      	ldr	r1, [pc, #60]	; (27c8 <app_mesh_prov_state_cb+0x88>)
    278c:	3008      	adds	r0, #8
    278e:	f7ff fadf 	bl	1d50 <SYS_SetTimer>
    2792:	e005      	b.n	27a0 <app_mesh_prov_state_cb+0x60>
						TIMER_SINGLE, (Timer_Expire_CB)app_mesh_prov_timeout_timer_cb);
	}
	if(state == M_PROV_SUCCEED_APP){
    2794:	2d03      	cmp	r5, #3
    2796:	d103      	bne.n	27a0 <app_mesh_prov_state_cb+0x60>
		SYS_ReleaseTimer(&ali_app->provTimeoutTimer);
    2798:	6820      	ldr	r0, [r4, #0]
    279a:	3008      	adds	r0, #8
    279c:	f7ff fb56 	bl	1e4c <SYS_ReleaseTimer>
	}

	ali_app->app_t->prov_state_cb(state);
    27a0:	6823      	ldr	r3, [r4, #0]
    27a2:	0028      	movs	r0, r5
    27a4:	6a1b      	ldr	r3, [r3, #32]
    27a6:	685b      	ldr	r3, [r3, #4]
    27a8:	4798      	blx	r3
}
    27aa:	bd73      	pop	{r0, r1, r4, r5, r6, pc}
    27ac:	10010514 	.word	0x10010514
    27b0:	0001fed0 	.word	0x0001fed0
    27b4:	0001fe50 	.word	0x0001fe50
    27b8:	10010504 	.word	0x10010504
    27bc:	0001ff50 	.word	0x0001ff50
    27c0:	10011004 	.word	0x10011004
    27c4:	00002739 	.word	0x00002739
    27c8:	0000ea60 	.word	0x0000ea60

000027cc <app_mesh_prov_param_req_cb>:
__STATIC void app_mesh_prov_param_req_cb(void)
{
    27cc:	b530      	push	{r4, r5, lr}
	m_api_prov_param_cfm_t cfm;
	ali_uuid_t uuid;
	ali_config_uuid_read(&uuid);
	memcpy(cfm.dev_uuid ,&uuid, M_DEV_UUID_LEN);
    27ce:	2510      	movs	r5, #16
	}

	ali_app->app_t->prov_state_cb(state);
}
__STATIC void app_mesh_prov_param_req_cb(void)
{
    27d0:	b08d      	sub	sp, #52	; 0x34
	m_api_prov_param_cfm_t cfm;
	ali_uuid_t uuid;
	ali_config_uuid_read(&uuid);
	memcpy(cfm.dev_uuid ,&uuid, M_DEV_UUID_LEN);
    27d2:	ac04      	add	r4, sp, #16
}
__STATIC void app_mesh_prov_param_req_cb(void)
{
	m_api_prov_param_cfm_t cfm;
	ali_uuid_t uuid;
	ali_config_uuid_read(&uuid);
    27d4:	4668      	mov	r0, sp
    27d6:	f001 fc11 	bl	3ffc <ali_config_uuid_read>
	memcpy(cfm.dev_uuid ,&uuid, M_DEV_UUID_LEN);
    27da:	002a      	movs	r2, r5
    27dc:	4669      	mov	r1, sp
    27de:	0020      	movs	r0, r4
    27e0:	f013 f8f6 	bl	159d0 <memcpy>
	m_printf_hex(L_APP, "prov param req cb", cfm.dev_uuid, M_DEV_UUID_LEN);
    27e4:	2080      	movs	r0, #128	; 0x80
    27e6:	490b      	ldr	r1, [pc, #44]	; (2814 <app_mesh_prov_param_req_cb+0x48>)
    27e8:	002b      	movs	r3, r5
    27ea:	0022      	movs	r2, r4
    27ec:	3112      	adds	r1, #18
    27ee:	0180      	lsls	r0, r0, #6
    27f0:	f002 f93c 	bl	4a6c <m_printf_hex>
	
	cfm.static_oob = M_PROV_STATIC_OOB_AVAILABLE;
    27f4:	2301      	movs	r3, #1
	cfm.pub_key_oob = M_PROV_PUB_KEY_OOB_USED;
	cfm.out_oob_size = 1;
	cfm.in_oob_size = 0;
    27f6:	2200      	movs	r2, #0
	cfm.out_oob_action = M_PROV_OUT_OOB_NUMERIC;
    27f8:	2108      	movs	r1, #8
	cfm.in_oob_action = 0;
	cfm.nb_elt = 1;
	cfm.info = 0;

	bc_m_prov_param_rsp(&cfm);
    27fa:	0020      	movs	r0, r4
	ali_uuid_t uuid;
	ali_config_uuid_read(&uuid);
	memcpy(cfm.dev_uuid ,&uuid, M_DEV_UUID_LEN);
	m_printf_hex(L_APP, "prov param req cb", cfm.dev_uuid, M_DEV_UUID_LEN);
	
	cfm.static_oob = M_PROV_STATIC_OOB_AVAILABLE;
    27fc:	75e3      	strb	r3, [r4, #23]
	cfm.pub_key_oob = M_PROV_PUB_KEY_OOB_USED;
    27fe:	75a3      	strb	r3, [r4, #22]
	cfm.out_oob_size = 1;
    2800:	7623      	strb	r3, [r4, #24]
	cfm.in_oob_size = 0;
    2802:	7662      	strb	r2, [r4, #25]
	cfm.out_oob_action = M_PROV_OUT_OOB_NUMERIC;
    2804:	8361      	strh	r1, [r4, #26]
	cfm.in_oob_action = 0;
    2806:	83a2      	strh	r2, [r4, #28]
	cfm.nb_elt = 1;
    2808:	77a3      	strb	r3, [r4, #30]
	cfm.info = 0;
    280a:	77e2      	strb	r2, [r4, #31]

	bc_m_prov_param_rsp(&cfm);
    280c:	f006 fce8 	bl	91e0 <bc_m_prov_param_rsp>
}
    2810:	b00d      	add	sp, #52	; 0x34
    2812:	bd30      	pop	{r4, r5, pc}
    2814:	0001ff50 	.word	0x0001ff50

00002818 <app_mesh_prov_oob_auth_req_cb>:
__STATIC void app_mesh_prov_oob_auth_req_cb(uint8_t auth_method, uint16_t auth_action, uint8_t auth_size)
{
    2818:	b5f0      	push	{r4, r5, r6, r7, lr}
	uint8_t auth_data[16];
	
	M_PRINTF(L_APP,"auth_method:0x%02x,auth_action:0x%04x,auth_size:0x%02x", auth_method, auth_action, auth_size);
    281a:	4b1a      	ldr	r3, [pc, #104]	; (2884 <app_mesh_prov_oob_auth_req_cb+0x6c>)
	cfm.info = 0;

	bc_m_prov_param_rsp(&cfm);
}
__STATIC void app_mesh_prov_oob_auth_req_cb(uint8_t auth_method, uint16_t auth_action, uint8_t auth_size)
{
    281c:	b089      	sub	sp, #36	; 0x24
	uint8_t auth_data[16];
	
	M_PRINTF(L_APP,"auth_method:0x%02x,auth_action:0x%04x,auth_size:0x%02x", auth_method, auth_action, auth_size);
    281e:	681b      	ldr	r3, [r3, #0]
	cfm.info = 0;

	bc_m_prov_param_rsp(&cfm);
}
__STATIC void app_mesh_prov_oob_auth_req_cb(uint8_t auth_method, uint16_t auth_action, uint8_t auth_size)
{
    2820:	9002      	str	r0, [sp, #8]
    2822:	9103      	str	r1, [sp, #12]
    2824:	0016      	movs	r6, r2
	uint8_t auth_data[16];
	
	M_PRINTF(L_APP,"auth_method:0x%02x,auth_action:0x%04x,auth_size:0x%02x", auth_method, auth_action, auth_size);
    2826:	049b      	lsls	r3, r3, #18
    2828:	d519      	bpl.n	285e <app_mesh_prov_oob_auth_req_cb+0x46>
    282a:	4d17      	ldr	r5, [pc, #92]	; (2888 <app_mesh_prov_oob_auth_req_cb+0x70>)
    282c:	4c17      	ldr	r4, [pc, #92]	; (288c <app_mesh_prov_oob_auth_req_cb+0x74>)
    282e:	002b      	movs	r3, r5
    2830:	0022      	movs	r2, r4
    2832:	0020      	movs	r0, r4
    2834:	4f16      	ldr	r7, [pc, #88]	; (2890 <app_mesh_prov_oob_auth_req_cb+0x78>)
    2836:	3324      	adds	r3, #36	; 0x24
    2838:	322a      	adds	r2, #42	; 0x2a
    283a:	9300      	str	r3, [sp, #0]
    283c:	0039      	movs	r1, r7
    283e:	2371      	movs	r3, #113	; 0x71
    2840:	3035      	adds	r0, #53	; 0x35
    2842:	f002 f8b3 	bl	49ac <m_print>
    2846:	0028      	movs	r0, r5
    2848:	9902      	ldr	r1, [sp, #8]
    284a:	3042      	adds	r0, #66	; 0x42
    284c:	0033      	movs	r3, r6
    284e:	9a03      	ldr	r2, [sp, #12]
    2850:	f002 f8ac 	bl	49ac <m_print>
    2854:	0020      	movs	r0, r4
    2856:	1db9      	adds	r1, r7, #6
    2858:	3059      	adds	r0, #89	; 0x59
    285a:	f002 f8a7 	bl	49ac <m_print>

	ali_config_auth_val_read(auth_data);
    285e:	a804      	add	r0, sp, #16
    2860:	f001 fc42 	bl	40e8 <ali_config_auth_val_read>
									
	m_printf_hex(L_APP, "auth val request", auth_data, 16);
    2864:	2080      	movs	r0, #128	; 0x80
    2866:	4908      	ldr	r1, [pc, #32]	; (2888 <app_mesh_prov_oob_auth_req_cb+0x70>)
    2868:	2310      	movs	r3, #16
    286a:	aa04      	add	r2, sp, #16
    286c:	3179      	adds	r1, #121	; 0x79
    286e:	0180      	lsls	r0, r0, #6
    2870:	f002 f8fc 	bl	4a6c <m_printf_hex>
	
    bc_m_prov_oob_auth_rsp(1, auth_size, auth_data);
    2874:	aa04      	add	r2, sp, #16
    2876:	0031      	movs	r1, r6
    2878:	2001      	movs	r0, #1
    287a:	f006 fcb5 	bl	91e8 <bc_m_prov_oob_auth_rsp>
}
    287e:	b009      	add	sp, #36	; 0x24
    2880:	bdf0      	pop	{r4, r5, r6, r7, pc}
    2882:	46c0      	nop			; (mov r8, r8)
    2884:	10010514 	.word	0x10010514
    2888:	0001ff50 	.word	0x0001ff50
    288c:	0001fed0 	.word	0x0001fed0
    2890:	0001fe50 	.word	0x0001fe50

00002894 <app_mesh_buf_block_freed_cb>:
__STATIC void app_mesh_buf_block_freed_cb(uint8_t block_id)
{
	M_PRINTF(L_APP, "");
    2894:	4b0d      	ldr	r3, [pc, #52]	; (28cc <app_mesh_buf_block_freed_cb+0x38>)
	m_printf_hex(L_APP, "auth val request", auth_data, 16);
	
    bc_m_prov_oob_auth_rsp(1, auth_size, auth_data);
}
__STATIC void app_mesh_buf_block_freed_cb(uint8_t block_id)
{
    2896:	b537      	push	{r0, r1, r2, r4, r5, lr}
	M_PRINTF(L_APP, "");
    2898:	681b      	ldr	r3, [r3, #0]
    289a:	049b      	lsls	r3, r3, #18
    289c:	d515      	bpl.n	28ca <app_mesh_buf_block_freed_cb+0x36>
    289e:	4c0c      	ldr	r4, [pc, #48]	; (28d0 <app_mesh_buf_block_freed_cb+0x3c>)
    28a0:	4b0c      	ldr	r3, [pc, #48]	; (28d4 <app_mesh_buf_block_freed_cb+0x40>)
    28a2:	0022      	movs	r2, r4
    28a4:	0020      	movs	r0, r4
    28a6:	4d0c      	ldr	r5, [pc, #48]	; (28d8 <app_mesh_buf_block_freed_cb+0x44>)
    28a8:	330a      	adds	r3, #10
    28aa:	0029      	movs	r1, r5
    28ac:	322a      	adds	r2, #42	; 0x2a
    28ae:	9300      	str	r3, [sp, #0]
    28b0:	3035      	adds	r0, #53	; 0x35
    28b2:	237b      	movs	r3, #123	; 0x7b
    28b4:	f002 f87a 	bl	49ac <m_print>
    28b8:	0020      	movs	r0, r4
    28ba:	3058      	adds	r0, #88	; 0x58
    28bc:	f002 f876 	bl	49ac <m_print>
    28c0:	0020      	movs	r0, r4
    28c2:	1da9      	adds	r1, r5, #6
    28c4:	3059      	adds	r0, #89	; 0x59
    28c6:	f002 f871 	bl	49ac <m_print>
}
    28ca:	bd37      	pop	{r0, r1, r2, r4, r5, pc}
    28cc:	10010514 	.word	0x10010514
    28d0:	0001fed0 	.word	0x0001fed0
    28d4:	0001ffd0 	.word	0x0001ffd0
    28d8:	0001fe50 	.word	0x0001fe50

000028dc <app_mesh_loaded_cb>:
__STATIC void app_mesh_loaded_cb(uint16_t status)
{
	M_PRINTF(L_APP, "");
    28dc:	4b0d      	ldr	r3, [pc, #52]	; (2914 <app_mesh_loaded_cb+0x38>)
__STATIC void app_mesh_buf_block_freed_cb(uint8_t block_id)
{
	M_PRINTF(L_APP, "");
}
__STATIC void app_mesh_loaded_cb(uint16_t status)
{
    28de:	b537      	push	{r0, r1, r2, r4, r5, lr}
	M_PRINTF(L_APP, "");
    28e0:	681b      	ldr	r3, [r3, #0]
    28e2:	049b      	lsls	r3, r3, #18
    28e4:	d515      	bpl.n	2912 <app_mesh_loaded_cb+0x36>
    28e6:	4c0c      	ldr	r4, [pc, #48]	; (2918 <app_mesh_loaded_cb+0x3c>)
    28e8:	4b0c      	ldr	r3, [pc, #48]	; (291c <app_mesh_loaded_cb+0x40>)
    28ea:	0022      	movs	r2, r4
    28ec:	0020      	movs	r0, r4
    28ee:	4d0c      	ldr	r5, [pc, #48]	; (2920 <app_mesh_loaded_cb+0x44>)
    28f0:	3326      	adds	r3, #38	; 0x26
    28f2:	0029      	movs	r1, r5
    28f4:	322a      	adds	r2, #42	; 0x2a
    28f6:	9300      	str	r3, [sp, #0]
    28f8:	3035      	adds	r0, #53	; 0x35
    28fa:	237f      	movs	r3, #127	; 0x7f
    28fc:	f002 f856 	bl	49ac <m_print>
    2900:	0020      	movs	r0, r4
    2902:	3058      	adds	r0, #88	; 0x58
    2904:	f002 f852 	bl	49ac <m_print>
    2908:	0020      	movs	r0, r4
    290a:	1da9      	adds	r1, r5, #6
    290c:	3059      	adds	r0, #89	; 0x59
    290e:	f002 f84d 	bl	49ac <m_print>
}
    2912:	bd37      	pop	{r0, r1, r2, r4, r5, pc}
    2914:	10010514 	.word	0x10010514
    2918:	0001fed0 	.word	0x0001fed0
    291c:	0001ffd0 	.word	0x0001ffd0
    2920:	0001fe50 	.word	0x0001fe50

00002924 <app_mesh_api_update_ind_cb>:

__STATIC void app_mesh_api_update_ind_cb(uint8_t type, uint16_t len, uint8_t *data)
{
    2924:	b510      	push	{r4, lr}
	bc_m_param_save(type, len, data);
    2926:	f006 fcd6 	bl	92d6 <bc_m_param_save>
}
    292a:	bd10      	pop	{r4, pc}

0000292c <app_mesh_reset_ind_cb>:

__STATIC void app_mesh_reset_ind_cb(void)
{
	M_PRINTF(L_APP, "");
    292c:	4b0e      	ldr	r3, [pc, #56]	; (2968 <app_mesh_reset_ind_cb+0x3c>)
{
	bc_m_param_save(type, len, data);
}

__STATIC void app_mesh_reset_ind_cb(void)
{
    292e:	b537      	push	{r0, r1, r2, r4, r5, lr}
	M_PRINTF(L_APP, "");
    2930:	681b      	ldr	r3, [r3, #0]
    2932:	049b      	lsls	r3, r3, #18
    2934:	d515      	bpl.n	2962 <app_mesh_reset_ind_cb+0x36>
    2936:	4c0d      	ldr	r4, [pc, #52]	; (296c <app_mesh_reset_ind_cb+0x40>)
    2938:	4b0d      	ldr	r3, [pc, #52]	; (2970 <app_mesh_reset_ind_cb+0x44>)
    293a:	0022      	movs	r2, r4
    293c:	0020      	movs	r0, r4
    293e:	4d0d      	ldr	r5, [pc, #52]	; (2974 <app_mesh_reset_ind_cb+0x48>)
    2940:	3339      	adds	r3, #57	; 0x39
    2942:	0029      	movs	r1, r5
    2944:	322a      	adds	r2, #42	; 0x2a
    2946:	9300      	str	r3, [sp, #0]
    2948:	3035      	adds	r0, #53	; 0x35
    294a:	2389      	movs	r3, #137	; 0x89
    294c:	f002 f82e 	bl	49ac <m_print>
    2950:	0020      	movs	r0, r4
    2952:	3058      	adds	r0, #88	; 0x58
    2954:	f002 f82a 	bl	49ac <m_print>
    2958:	0020      	movs	r0, r4
    295a:	1da9      	adds	r1, r5, #6
    295c:	3059      	adds	r0, #89	; 0x59
    295e:	f002 f825 	bl	49ac <m_print>
	bc_m_disable();
    2962:	f006 f9e1 	bl	8d28 <bc_m_disable>
}
    2966:	bd37      	pop	{r0, r1, r2, r4, r5, pc}
    2968:	10010514 	.word	0x10010514
    296c:	0001fed0 	.word	0x0001fed0
    2970:	0001ffd0 	.word	0x0001ffd0
    2974:	0001fe50 	.word	0x0001fe50

00002978 <app_mesh_compo_data_req_cb>:

__STATIC void app_mesh_compo_data_req_cb(uint8_t page)
{
    2978:	b570      	push	{r4, r5, r6, lr}
	M_PRINTF(L_APP, "");
    297a:	4b14      	ldr	r3, [pc, #80]	; (29cc <app_mesh_compo_data_req_cb+0x54>)
	M_PRINTF(L_APP, "");
	bc_m_disable();
}

__STATIC void app_mesh_compo_data_req_cb(uint8_t page)
{
    297c:	b088      	sub	sp, #32
	M_PRINTF(L_APP, "");
    297e:	681b      	ldr	r3, [r3, #0]
    2980:	4d13      	ldr	r5, [pc, #76]	; (29d0 <app_mesh_compo_data_req_cb+0x58>)
    2982:	049b      	lsls	r3, r3, #18
    2984:	d515      	bpl.n	29b2 <app_mesh_compo_data_req_cb+0x3a>
    2986:	4c13      	ldr	r4, [pc, #76]	; (29d4 <app_mesh_compo_data_req_cb+0x5c>)
    2988:	002b      	movs	r3, r5
    298a:	0022      	movs	r2, r4
    298c:	0020      	movs	r0, r4
    298e:	4e12      	ldr	r6, [pc, #72]	; (29d8 <app_mesh_compo_data_req_cb+0x60>)
    2990:	334f      	adds	r3, #79	; 0x4f
    2992:	0031      	movs	r1, r6
    2994:	322a      	adds	r2, #42	; 0x2a
    2996:	9300      	str	r3, [sp, #0]
    2998:	3035      	adds	r0, #53	; 0x35
    299a:	238f      	movs	r3, #143	; 0x8f
    299c:	f002 f806 	bl	49ac <m_print>
    29a0:	0020      	movs	r0, r4
    29a2:	3058      	adds	r0, #88	; 0x58
    29a4:	f002 f802 	bl	49ac <m_print>
    29a8:	0020      	movs	r0, r4
    29aa:	1db1      	adds	r1, r6, #6
    29ac:	3059      	adds	r0, #89	; 0x59
    29ae:	f001 fffd 	bl	49ac <m_print>
	uint8_t compo_data[] = {0xfc, 0x02, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x01, 0x00, 0x01, 0x00, 0x05, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x10, 0x00, 0x13, 0x03, 0x13};
    29b2:	0029      	movs	r1, r5
    29b4:	2218      	movs	r2, #24
    29b6:	316a      	adds	r1, #106	; 0x6a
    29b8:	a802      	add	r0, sp, #8
    29ba:	f013 f809 	bl	159d0 <memcpy>
	}
	else {
		data_len = 1;
	}

	bc_m_compo_data_cfm(page, data_len, compo_data);
    29be:	aa02      	add	r2, sp, #8
    29c0:	2118      	movs	r1, #24
    29c2:	2000      	movs	r0, #0
    29c4:	f006 fc08 	bl	91d8 <bc_m_compo_data_cfm>
}
    29c8:	b008      	add	sp, #32
    29ca:	bd70      	pop	{r4, r5, r6, pc}
    29cc:	10010514 	.word	0x10010514
    29d0:	0001ffd0 	.word	0x0001ffd0
    29d4:	0001fed0 	.word	0x0001fed0
    29d8:	0001fe50 	.word	0x0001fe50

000029dc <app_mesh_init>:
 	.cb_update_ind		= app_mesh_api_update_ind_cb,
 	.cb_reset_ind		= app_mesh_reset_ind_cb,
 	.cb_compo_data_req	= app_mesh_compo_data_req_cb,
};
uint8_t app_mesh_init(void)
{
    29dc:	b5f0      	push	{r4, r5, r6, r7, lr}
    29de:	b085      	sub	sp, #20
	bc_m_mesh_init();
    29e0:	f006 fc31 	bl	9246 <bc_m_mesh_init>
	
	ali_app = ke_malloc(sizeof(ali_app_t), 0);
    29e4:	2100      	movs	r1, #0
    29e6:	2024      	movs	r0, #36	; 0x24
    29e8:	f004 fc7a 	bl	72e0 <ke_malloc>
    29ec:	4c1a      	ldr	r4, [pc, #104]	; (2a58 <app_mesh_init+0x7c>)
	memset(ali_app, 0, sizeof(ali_app_t));
    29ee:	2224      	movs	r2, #36	; 0x24
    29f0:	2100      	movs	r1, #0
};
uint8_t app_mesh_init(void)
{
	bc_m_mesh_init();
	
	ali_app = ke_malloc(sizeof(ali_app_t), 0);
    29f2:	6020      	str	r0, [r4, #0]
	memset(ali_app, 0, sizeof(ali_app_t));
    29f4:	f013 f82a 	bl	15a4c <memset>
	uint8_t dType = ali_config_device_type_get();
    29f8:	f001 fbe4 	bl	41c4 <ali_config_device_type_get>
	M_PRINTF(L_APP, "device type[%d]", dType);
    29fc:	4b17      	ldr	r3, [pc, #92]	; (2a5c <app_mesh_init+0x80>)
{
	bc_m_mesh_init();
	
	ali_app = ke_malloc(sizeof(ali_app_t), 0);
	memset(ali_app, 0, sizeof(ali_app_t));
	uint8_t dType = ali_config_device_type_get();
    29fe:	0007      	movs	r7, r0
	M_PRINTF(L_APP, "device type[%d]", dType);
    2a00:	681b      	ldr	r3, [r3, #0]
    2a02:	9403      	str	r4, [sp, #12]
    2a04:	049b      	lsls	r3, r3, #18
    2a06:	d517      	bpl.n	2a38 <app_mesh_init+0x5c>
    2a08:	4e15      	ldr	r6, [pc, #84]	; (2a60 <app_mesh_init+0x84>)
    2a0a:	4c16      	ldr	r4, [pc, #88]	; (2a64 <app_mesh_init+0x88>)
    2a0c:	0033      	movs	r3, r6
    2a0e:	0022      	movs	r2, r4
    2a10:	0020      	movs	r0, r4
    2a12:	4d15      	ldr	r5, [pc, #84]	; (2a68 <app_mesh_init+0x8c>)
    2a14:	332c      	adds	r3, #44	; 0x2c
    2a16:	322a      	adds	r2, #42	; 0x2a
    2a18:	9300      	str	r3, [sp, #0]
    2a1a:	0029      	movs	r1, r5
    2a1c:	23b3      	movs	r3, #179	; 0xb3
    2a1e:	3035      	adds	r0, #53	; 0x35
    2a20:	f001 ffc4 	bl	49ac <m_print>
    2a24:	0030      	movs	r0, r6
    2a26:	0039      	movs	r1, r7
    2a28:	303a      	adds	r0, #58	; 0x3a
    2a2a:	f001 ffbf 	bl	49ac <m_print>
    2a2e:	0020      	movs	r0, r4
    2a30:	1da9      	adds	r1, r5, #6
    2a32:	3059      	adds	r0, #89	; 0x59
    2a34:	f001 ffba 	bl	49ac <m_print>
	ali_app->app_t = &ali_app_array[dType];
    2a38:	9b03      	ldr	r3, [sp, #12]
    2a3a:	4c0b      	ldr	r4, [pc, #44]	; (2a68 <app_mesh_init+0x8c>)
    2a3c:	6819      	ldr	r1, [r3, #0]
    2a3e:	2314      	movs	r3, #20
    2a40:	0022      	movs	r2, r4
    2a42:	435f      	muls	r7, r3
    2a44:	3248      	adds	r2, #72	; 0x48
    2a46:	19d3      	adds	r3, r2, r7
	ali_app->app_t->app_init(&ali_app->model, &ali_app->model_cnt);
    2a48:	19e7      	adds	r7, r4, r7
	
	ali_app = ke_malloc(sizeof(ali_app_t), 0);
	memset(ali_app, 0, sizeof(ali_app_t));
	uint8_t dType = ali_config_device_type_get();
	M_PRINTF(L_APP, "device type[%d]", dType);
	ali_app->app_t = &ali_app_array[dType];
    2a4a:	620b      	str	r3, [r1, #32]
	ali_app->app_t->app_init(&ali_app->model, &ali_app->model_cnt);
    2a4c:	1d08      	adds	r0, r1, #4
    2a4e:	6d7b      	ldr	r3, [r7, #84]	; 0x54
    2a50:	4798      	blx	r3

	return 0;
}
    2a52:	2000      	movs	r0, #0
    2a54:	b005      	add	sp, #20
    2a56:	bdf0      	pop	{r4, r5, r6, r7, pc}
    2a58:	10011004 	.word	0x10011004
    2a5c:	10010514 	.word	0x10010514
    2a60:	00020050 	.word	0x00020050
    2a64:	0001fed0 	.word	0x0001fed0
    2a68:	0001fe50 	.word	0x0001fe50

00002a6c <app_mesh_deinit>:

void app_mesh_deinit(void)
{
    2a6c:	b510      	push	{r4, lr}
	ASSERT_ERR(ali_app && ali_app->model);
    2a6e:	4c07      	ldr	r4, [pc, #28]	; (2a8c <app_mesh_deinit+0x20>)
    2a70:	6823      	ldr	r3, [r4, #0]
    2a72:	685a      	ldr	r2, [r3, #4]
    2a74:	2a00      	cmp	r2, #0
    2a76:	d100      	bne.n	2a7a <app_mesh_deinit+0xe>
    2a78:	e7fe      	b.n	2a78 <app_mesh_deinit+0xc>
	ali_app->app_t->app_deinit(&ali_app->model);
    2a7a:	1d18      	adds	r0, r3, #4
    2a7c:	6a1b      	ldr	r3, [r3, #32]
    2a7e:	691b      	ldr	r3, [r3, #16]
    2a80:	4798      	blx	r3
	ke_free(ali_app);
    2a82:	6820      	ldr	r0, [r4, #0]
    2a84:	f004 fc30 	bl	72e8 <ke_free>
}
    2a88:	bd10      	pop	{r4, pc}
    2a8a:	46c0      	nop			; (mov r8, r8)
    2a8c:	10011004 	.word	0x10011004

00002a90 <app_mesh_start>:
void app_mesh_start(void)
{
    2a90:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	uint16_t status = M_ERR_NO_ERROR;
	m_printf(L_APP, "app mesh start:\r\n");
    2a92:	4c2d      	ldr	r4, [pc, #180]	; (2b48 <app_mesh_start+0xb8>)
    2a94:	2080      	movs	r0, #128	; 0x80
    2a96:	0021      	movs	r1, r4
    2a98:	0180      	lsls	r0, r0, #6
    2a9a:	314a      	adds	r1, #74	; 0x4a
    2a9c:	f001 ffa8 	bl	49f0 <m_printf>

	//set api callback function
	bc_m_set(&app_mesh_cb);
    2aa0:	1d20      	adds	r0, r4, #4
    2aa2:	f006 f915 	bl	8cd0 <bc_m_set>
	// Set clock information
	status = bc_m_set_run_time(0, 0);
    2aa6:	2100      	movs	r1, #0
    2aa8:	0008      	movs	r0, r1
    2aaa:	f006 f957 	bl	8d5c <bc_m_set_run_time>
    2aae:	0006      	movs	r6, r0
	ASSERT_ERR(status == M_ERR_NO_ERROR);
    2ab0:	2e00      	cmp	r6, #0
    2ab2:	d1fd      	bne.n	2ab0 <app_mesh_start+0x20>

	//register all models
	bc_mm_register_models(ali_app->model, ali_app->model_cnt);
    2ab4:	4f25      	ldr	r7, [pc, #148]	; (2b4c <app_mesh_start+0xbc>)
    2ab6:	683b      	ldr	r3, [r7, #0]
    2ab8:	7819      	ldrb	r1, [r3, #0]
    2aba:	6858      	ldr	r0, [r3, #4]
    2abc:	f002 ff18 	bl	58f0 <bc_mm_register_models>

	//if proved ;load flash config data
	uint32_t len  = bc_m_param_data_len();
    2ac0:	f006 fc0d 	bl	92de <bc_m_param_data_len>
    2ac4:	1e05      	subs	r5, r0, #0
	if(len && ali_app->app_t->prov_state_get()){
    2ac6:	d036      	beq.n	2b36 <app_mesh_start+0xa6>
    2ac8:	683b      	ldr	r3, [r7, #0]
    2aca:	6a1b      	ldr	r3, [r3, #32]
    2acc:	689b      	ldr	r3, [r3, #8]
    2ace:	4798      	blx	r3
    2ad0:	2800      	cmp	r0, #0
    2ad2:	d030      	beq.n	2b36 <app_mesh_start+0xa6>
		ASSERT_ERR(len);
		uint8_t *data = ke_malloc(len, 0);
    2ad4:	0031      	movs	r1, r6
    2ad6:	0028      	movs	r0, r5
    2ad8:	f004 fc02 	bl	72e0 <ke_malloc>
    2adc:	1e06      	subs	r6, r0, #0
		ASSERT_ERR(data);
    2ade:	d100      	bne.n	2ae2 <app_mesh_start+0x52>
    2ae0:	e7fe      	b.n	2ae0 <app_mesh_start+0x50>
		bc_m_param_get_data(len, data);
    2ae2:	0001      	movs	r1, r0
    2ae4:	0028      	movs	r0, r5
    2ae6:	f006 fbfe 	bl	92e6 <bc_m_param_get_data>

		status =  bc_m_load_stored_info(len, data);
    2aea:	b2a8      	uxth	r0, r5
    2aec:	0031      	movs	r1, r6
    2aee:	f006 f9a3 	bl	8e38 <bc_m_load_stored_info>
    2af2:	1e07      	subs	r7, r0, #0
		if(M_ERR_NO_ERROR != status){
    2af4:	d001      	beq.n	2afa <app_mesh_start+0x6a>
			bc_m_clear_config();
    2af6:	f006 fbea 	bl	92ce <bc_m_clear_config>
		}
		ke_free(data);
    2afa:	0030      	movs	r0, r6
    2afc:	f004 fbf4 	bl	72e8 <ke_free>
		M_PRINTF(L_APP, "load stored config data status[%x]", status);
    2b00:	4b13      	ldr	r3, [pc, #76]	; (2b50 <app_mesh_start+0xc0>)
    2b02:	681b      	ldr	r3, [r3, #0]
    2b04:	049b      	lsls	r3, r3, #18
    2b06:	d516      	bpl.n	2b36 <app_mesh_start+0xa6>
    2b08:	4d12      	ldr	r5, [pc, #72]	; (2b54 <app_mesh_start+0xc4>)
    2b0a:	0023      	movs	r3, r4
    2b0c:	002a      	movs	r2, r5
    2b0e:	0028      	movs	r0, r5
    2b10:	4e11      	ldr	r6, [pc, #68]	; (2b58 <app_mesh_start+0xc8>)
    2b12:	335c      	adds	r3, #92	; 0x5c
    2b14:	322a      	adds	r2, #42	; 0x2a
    2b16:	9300      	str	r3, [sp, #0]
    2b18:	0031      	movs	r1, r6
    2b1a:	23db      	movs	r3, #219	; 0xdb
    2b1c:	3035      	adds	r0, #53	; 0x35
    2b1e:	f001 ff45 	bl	49ac <m_print>
    2b22:	0020      	movs	r0, r4
    2b24:	0039      	movs	r1, r7
    2b26:	306b      	adds	r0, #107	; 0x6b
    2b28:	f001 ff40 	bl	49ac <m_print>
    2b2c:	0028      	movs	r0, r5
    2b2e:	1db1      	adds	r1, r6, #6
    2b30:	3059      	adds	r0, #89	; 0x59
    2b32:	f001 ff3b 	bl	49ac <m_print>
	}

	// Enable the stack
	bc_m_enable();
    2b36:	f006 f8df 	bl	8cf8 <bc_m_enable>
	m_printf(L_APP, "mesh stack enabled\r\n");
    2b3a:	2080      	movs	r0, #128	; 0x80
    2b3c:	4907      	ldr	r1, [pc, #28]	; (2b5c <app_mesh_start+0xcc>)
    2b3e:	0180      	lsls	r0, r0, #6
    2b40:	310e      	adds	r1, #14
    2b42:	f001 ff55 	bl	49f0 <m_printf>
}
    2b46:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
    2b48:	00020050 	.word	0x00020050
    2b4c:	10011004 	.word	0x10011004
    2b50:	10010514 	.word	0x10010514
    2b54:	0001fed0 	.word	0x0001fed0
    2b58:	0001fe50 	.word	0x0001fe50
    2b5c:	000200d0 	.word	0x000200d0

00002b60 <_ready_to_indicate>:

static void ali_light_period_ind_timer_cb(void* param);

static void _ready_to_indicate(bool random)
{
	if(p_ali_light == NULL)
    2b60:	4b0d      	ldr	r3, [pc, #52]	; (2b98 <_ready_to_indicate+0x38>)
static ali_light_t* p_ali_light = NULL;

static void ali_light_period_ind_timer_cb(void* param);

static void _ready_to_indicate(bool random)
{
    2b62:	b510      	push	{r4, lr}
	if(p_ali_light == NULL)
    2b64:	681a      	ldr	r2, [r3, #0]
    2b66:	001c      	movs	r4, r3
    2b68:	2a00      	cmp	r2, #0
    2b6a:	d013      	beq.n	2b94 <_ready_to_indicate+0x34>
		return;
	uint32_t delay_time = M_ALIS_INDICATION_PERIOD;
	if(random){
    2b6c:	2800      	cmp	r0, #0
    2b6e:	d002      	beq.n	2b76 <_ready_to_indicate+0x16>
		delay_time = bc_mm_alis_get_random_time();
    2b70:	f003 f88e 	bl	5c90 <bc_mm_alis_get_random_time>
    2b74:	e000      	b.n	2b78 <_ready_to_indicate+0x18>

static void _ready_to_indicate(bool random)
{
	if(p_ali_light == NULL)
		return;
	uint32_t delay_time = M_ALIS_INDICATION_PERIOD;
    2b76:	4809      	ldr	r0, [pc, #36]	; (2b9c <_ready_to_indicate+0x3c>)
	if(random){
		delay_time = bc_mm_alis_get_random_time();
	}
	
	//if bound
	if(p_ali_light->provState){
    2b78:	6824      	ldr	r4, [r4, #0]
    2b7a:	7863      	ldrb	r3, [r4, #1]
    2b7c:	2b00      	cmp	r3, #0
    2b7e:	d009      	beq.n	2b94 <_ready_to_indicate+0x34>
		SYS_SetTimer(&p_ali_light->periodIndTimer, (int)delay_time/10, 
    2b80:	210a      	movs	r1, #10
    2b82:	f001 fb8c 	bl	429e <__aeabi_idiv>
    2b86:	0001      	movs	r1, r0
    2b88:	0020      	movs	r0, r4
    2b8a:	4b05      	ldr	r3, [pc, #20]	; (2ba0 <_ready_to_indicate+0x40>)
    2b8c:	3044      	adds	r0, #68	; 0x44
    2b8e:	2200      	movs	r2, #0
    2b90:	f7ff f8de 	bl	1d50 <SYS_SetTimer>
					TIMER_SINGLE, (Timer_Expire_CB)ali_light_period_ind_timer_cb);
	}
}
    2b94:	bd10      	pop	{r4, pc}
    2b96:	46c0      	nop			; (mov r8, r8)
    2b98:	10011008 	.word	0x10011008
    2b9c:	0002bf20 	.word	0x0002bf20
    2ba0:	00002da1 	.word	0x00002da1

00002ba4 <ali_light_cw_set_on_off>:
#endif
}
void ali_light_cw_set_on_off(uint8_t on)
{
#ifdef BREATH_CONFIG
	p_ali_light->breath.mode = BREATH_MODE_FLOW;
    2ba4:	4b06      	ldr	r3, [pc, #24]	; (2bc0 <ali_light_cw_set_on_off+0x1c>)
	p_ali_light->breath.rCnt = 1;
    2ba6:	2208      	movs	r2, #8
#endif
}
void ali_light_cw_set_on_off(uint8_t on)
{
#ifdef BREATH_CONFIG
	p_ali_light->breath.mode = BREATH_MODE_FLOW;
    2ba8:	681b      	ldr	r3, [r3, #0]
#else
	led_cw_init(NULL);
#endif
}
void ali_light_cw_set_on_off(uint8_t on)
{
    2baa:	b510      	push	{r4, lr}
#ifdef BREATH_CONFIG
	p_ali_light->breath.mode = BREATH_MODE_FLOW;
    2bac:	0019      	movs	r1, r3
    2bae:	315c      	adds	r1, #92	; 0x5c
	p_ali_light->breath.rCnt = 1;
    2bb0:	700a      	strb	r2, [r1, #0]
	p_ali_light->breath.pCnt = REPEAT_COUNTER;
    2bb2:	335e      	adds	r3, #94	; 0x5e
    2bb4:	3220      	adds	r2, #32
    2bb6:	801a      	strh	r2, [r3, #0]
	led_cw_set_on_off(on, &p_ali_light->breath);
    2bb8:	f7ff fa8e 	bl	20d8 <led_cw_set_on_off>
#else
	led_cw_set_on_off(on, NULL);
#endif
}
    2bbc:	bd10      	pop	{r4, pc}
    2bbe:	46c0      	nop			; (mov r8, r8)
    2bc0:	10011008 	.word	0x10011008

00002bc4 <ali_light_cw_get_on_off>:
uint8_t ali_light_cw_get_on_off(void)
{
    2bc4:	b510      	push	{r4, lr}
	return led_cw_get_on_off();
    2bc6:	f7ff faa9 	bl	211c <led_cw_get_on_off>
}
    2bca:	bd10      	pop	{r4, pc}

00002bcc <ali_light_cw_set_lightness>:
void ali_light_cw_set_lightness(uint16_t ln)
{
#ifdef BREATH_CONFIG
	p_ali_light->breath.mode = BREATH_MODE_FLOW;
    2bcc:	4b06      	ldr	r3, [pc, #24]	; (2be8 <ali_light_cw_set_lightness+0x1c>)
	p_ali_light->breath.rCnt = 1;
    2bce:	2208      	movs	r2, #8
	return led_cw_get_on_off();
}
void ali_light_cw_set_lightness(uint16_t ln)
{
#ifdef BREATH_CONFIG
	p_ali_light->breath.mode = BREATH_MODE_FLOW;
    2bd0:	681b      	ldr	r3, [r3, #0]
uint8_t ali_light_cw_get_on_off(void)
{
	return led_cw_get_on_off();
}
void ali_light_cw_set_lightness(uint16_t ln)
{
    2bd2:	b510      	push	{r4, lr}
#ifdef BREATH_CONFIG
	p_ali_light->breath.mode = BREATH_MODE_FLOW;
    2bd4:	0019      	movs	r1, r3
    2bd6:	315c      	adds	r1, #92	; 0x5c
	p_ali_light->breath.rCnt = 1;
    2bd8:	700a      	strb	r2, [r1, #0]
	p_ali_light->breath.pCnt = REPEAT_COUNTER;
    2bda:	335e      	adds	r3, #94	; 0x5e
    2bdc:	3220      	adds	r2, #32
    2bde:	801a      	strh	r2, [r3, #0]
	led_cw_set_lightness(ln, &p_ali_light->breath);
    2be0:	f7ff fa54 	bl	208c <led_cw_set_lightness>
#else
	led_cw_set_lightness(ln, NULL);
#endif
}
    2be4:	bd10      	pop	{r4, pc}
    2be6:	46c0      	nop			; (mov r8, r8)
    2be8:	10011008 	.word	0x10011008

00002bec <ali_light_cw_get_lightness>:
uint16_t ali_light_cw_get_lightness(void)
{
    2bec:	b510      	push	{r4, lr}
	return led_cw_get_lightness();
    2bee:	f7ff fa6d 	bl	20cc <led_cw_get_lightness>
}
    2bf2:	bd10      	pop	{r4, pc}

00002bf4 <ali_light_cw_set_temperature>:
void ali_light_cw_set_temperature(uint16_t tp)
{
#ifdef BREATH_CONFIG
	p_ali_light->breath.mode = BREATH_MODE_FLOW;
    2bf4:	4b06      	ldr	r3, [pc, #24]	; (2c10 <ali_light_cw_set_temperature+0x1c>)
	p_ali_light->breath.rCnt = 1;
    2bf6:	2208      	movs	r2, #8
	return led_cw_get_lightness();
}
void ali_light_cw_set_temperature(uint16_t tp)
{
#ifdef BREATH_CONFIG
	p_ali_light->breath.mode = BREATH_MODE_FLOW;
    2bf8:	681b      	ldr	r3, [r3, #0]
uint16_t ali_light_cw_get_lightness(void)
{
	return led_cw_get_lightness();
}
void ali_light_cw_set_temperature(uint16_t tp)
{
    2bfa:	b510      	push	{r4, lr}
#ifdef BREATH_CONFIG
	p_ali_light->breath.mode = BREATH_MODE_FLOW;
    2bfc:	0019      	movs	r1, r3
    2bfe:	315c      	adds	r1, #92	; 0x5c
	p_ali_light->breath.rCnt = 1;
    2c00:	700a      	strb	r2, [r1, #0]
	p_ali_light->breath.pCnt = REPEAT_COUNTER;
    2c02:	335e      	adds	r3, #94	; 0x5e
    2c04:	3220      	adds	r2, #32
    2c06:	801a      	strh	r2, [r3, #0]
	led_cw_set_temperature(tp, &p_ali_light->breath);
    2c08:	f7ff fa1a 	bl	2040 <led_cw_set_temperature>
#else
	led_cw_set_temperature(tp, NULL);
#endif
}
    2c0c:	bd10      	pop	{r4, pc}
    2c0e:	46c0      	nop			; (mov r8, r8)
    2c10:	10011008 	.word	0x10011008

00002c14 <ali_light_cw_get_temperature>:
uint16_t ali_light_cw_get_temperature(void)
{
    2c14:	b510      	push	{r4, lr}
	return led_cw_get_temperature();
    2c16:	f7ff fa33 	bl	2080 <led_cw_get_temperature>
}
    2c1a:	bd10      	pop	{r4, pc}

00002c1c <ali_light_ltn_set_on_off>:

void ali_light_ltn_set_on_off(uint8_t on)
{
    2c1c:	b510      	push	{r4, lr}
	led_ltn_set_on_off(on);
    2c1e:	f7ff fbf7 	bl	2410 <led_ltn_set_on_off>
}
    2c22:	bd10      	pop	{r4, pc}

00002c24 <ali_light_ltn_get_on_off>:
uint8_t ali_light_ltn_get_on_off(void)
{
    2c24:	b510      	push	{r4, lr}
	return led_ltn_get_on_off();
    2c26:	f7ff fc01 	bl	242c <led_ltn_get_on_off>
}
    2c2a:	bd10      	pop	{r4, pc}

00002c2c <ali_light_ltn_set_lightness>:

void ali_light_ltn_set_lightness(uint16_t ln)
{
    2c2c:	b510      	push	{r4, lr}
	led_ltn_set_lightness(ln);
    2c2e:	f7ff fbdf 	bl	23f0 <led_ltn_set_lightness>
}
    2c32:	bd10      	pop	{r4, pc}

00002c34 <ali_light_ltn_get_lightness>:
uint16_t ali_light_ltn_get_lightness(void)
{
    2c34:	b510      	push	{r4, lr}
	return led_ltn_get_lightness();
    2c36:	f7ff fbe5 	bl	2404 <led_ltn_get_lightness>
}
    2c3a:	bd10      	pop	{r4, pc}

00002c3c <ali_light_bind_timer_cb>:

static void ali_light_bind_timer_cb(void* param)
{
    2c3c:	b5f0      	push	{r4, r5, r6, r7, lr}
	uint16_t status;

	if(!p_ali_light->provState){
    2c3e:	4e54      	ldr	r6, [pc, #336]	; (2d90 <ali_light_bind_timer_cb+0x154>)
{
	return led_ltn_get_lightness();
}

static void ali_light_bind_timer_cb(void* param)
{
    2c40:	b087      	sub	sp, #28
	uint16_t status;

	if(!p_ali_light->provState){
    2c42:	6834      	ldr	r4, [r6, #0]
    2c44:	7865      	ldrb	r5, [r4, #1]
    2c46:	2d00      	cmp	r5, #0
    2c48:	d10f      	bne.n	2c6a <ali_light_bind_timer_cb+0x2e>
		p_ali_light->provState = 1;
    2c4a:	2701      	movs	r7, #1
		p_ali_light->saveCfgCrc = bc_sys_check_sum((uint8_t*)p_ali_light, ALI_LIGHT_SAVE_LEN-1);
    2c4c:	2113      	movs	r1, #19
static void ali_light_bind_timer_cb(void* param)
{
	uint16_t status;

	if(!p_ali_light->provState){
		p_ali_light->provState = 1;
    2c4e:	7067      	strb	r7, [r4, #1]
		p_ali_light->saveCfgCrc = bc_sys_check_sum((uint8_t*)p_ali_light, ALI_LIGHT_SAVE_LEN-1);
    2c50:	0020      	movs	r0, r4
    2c52:	f7ff fd1b 	bl	268c <bc_sys_check_sum>
		bc_flash_erase(FLASH_ALI_START_ADDRRESS, 1);
    2c56:	0039      	movs	r1, r7
{
	uint16_t status;

	if(!p_ali_light->provState){
		p_ali_light->provState = 1;
		p_ali_light->saveCfgCrc = bc_sys_check_sum((uint8_t*)p_ali_light, ALI_LIGHT_SAVE_LEN-1);
    2c58:	74e0      	strb	r0, [r4, #19]
		bc_flash_erase(FLASH_ALI_START_ADDRRESS, 1);
    2c5a:	0028      	movs	r0, r5
    2c5c:	f7fe fec4 	bl	19e8 <bc_flash_erase>
		bc_flash_write(FLASH_ALI_START_ADDRRESS, ALI_LIGHT_SAVE_LEN,(uint8_t*)p_ali_light);
    2c60:	6832      	ldr	r2, [r6, #0]
    2c62:	2114      	movs	r1, #20
    2c64:	0028      	movs	r0, r5
    2c66:	f7fe fefd 	bl	1a64 <bc_flash_write>
	}
	//model bind
	m_lid_t app_key_lid = 0;
    2c6a:	2517      	movs	r5, #23
    2c6c:	2000      	movs	r0, #0
    2c6e:	446d      	add	r5, sp
	status = bc_m_key_app_find(0, &app_key_lid);
    2c70:	0029      	movs	r1, r5
		p_ali_light->saveCfgCrc = bc_sys_check_sum((uint8_t*)p_ali_light, ALI_LIGHT_SAVE_LEN-1);
		bc_flash_erase(FLASH_ALI_START_ADDRRESS, 1);
		bc_flash_write(FLASH_ALI_START_ADDRRESS, ALI_LIGHT_SAVE_LEN,(uint8_t*)p_ali_light);
	}
	//model bind
	m_lid_t app_key_lid = 0;
    2c72:	7028      	strb	r0, [r5, #0]
	status = bc_m_key_app_find(0, &app_key_lid);
    2c74:	f006 fb45 	bl	9302 <bc_m_key_app_find>
    2c78:	1e04      	subs	r4, r0, #0
	if (status != M_ERR_NO_ERROR){
    2c7a:	d028      	beq.n	2cce <ali_light_bind_timer_cb+0x92>
		M_PRINTF(L_FND, "m_tb_key_app_find error");
    2c7c:	4b45      	ldr	r3, [pc, #276]	; (2d94 <ali_light_bind_timer_cb+0x158>)
    2c7e:	681b      	ldr	r3, [r3, #0]
    2c80:	051b      	lsls	r3, r3, #20
    2c82:	d400      	bmi.n	2c86 <ali_light_bind_timer_cb+0x4a>
    2c84:	e081      	b.n	2d8a <ali_light_bind_timer_cb+0x14e>
    2c86:	4c44      	ldr	r4, [pc, #272]	; (2d98 <ali_light_bind_timer_cb+0x15c>)
    2c88:	0023      	movs	r3, r4
    2c8a:	0022      	movs	r2, r4
    2c8c:	0020      	movs	r0, r4
    2c8e:	3340      	adds	r3, #64	; 0x40
    2c90:	0021      	movs	r1, r4
    2c92:	3225      	adds	r2, #37	; 0x25
    2c94:	9300      	str	r3, [sp, #0]
    2c96:	3031      	adds	r0, #49	; 0x31
    2c98:	2385      	movs	r3, #133	; 0x85
    2c9a:	f001 fe87 	bl	49ac <m_print>
    2c9e:	0020      	movs	r0, r4
    2ca0:	3058      	adds	r0, #88	; 0x58
    2ca2:	f001 fe83 	bl	49ac <m_print>
    2ca6:	0020      	movs	r0, r4
    2ca8:	1da1      	adds	r1, r4, #6
    2caa:	3070      	adds	r0, #112	; 0x70
    2cac:	f001 fe7e 	bl	49ac <m_print>
    2cb0:	e06b      	b.n	2d8a <ali_light_bind_timer_cb+0x14e>
    2cb2:	0123      	lsls	r3, r4, #4
    2cb4:	18ff      	adds	r7, r7, r3
		return;
	}
	for(uint8_t i = 0; i < p_ali_light->model_cnt; ++i){
		mesh_model_t* t = &p_ali_light->model[i];
		status = bc_m_key_model_bind(app_key_lid, t->lid);
    2cb6:	3769      	adds	r7, #105	; 0x69
    2cb8:	7839      	ldrb	r1, [r7, #0]
    2cba:	7828      	ldrb	r0, [r5, #0]
    2cbc:	f006 fb29 	bl	9312 <bc_m_key_model_bind>
		if (status == M_ERR_NO_ERROR){
    2cc0:	2800      	cmp	r0, #0
    2cc2:	d102      	bne.n	2cca <ali_light_bind_timer_cb+0x8e>
			// Inform the Model IO manager
			bc_m_mio_bind(t->lid);
    2cc4:	7838      	ldrb	r0, [r7, #0]
    2cc6:	f006 fb20 	bl	930a <bc_m_mio_bind>
	status = bc_m_key_app_find(0, &app_key_lid);
	if (status != M_ERR_NO_ERROR){
		M_PRINTF(L_FND, "m_tb_key_app_find error");
		return;
	}
	for(uint8_t i = 0; i < p_ali_light->model_cnt; ++i){
    2cca:	3401      	adds	r4, #1
    2ccc:	b2e4      	uxtb	r4, r4
    2cce:	6837      	ldr	r7, [r6, #0]
    2cd0:	003b      	movs	r3, r7
    2cd2:	3360      	adds	r3, #96	; 0x60
    2cd4:	781b      	ldrb	r3, [r3, #0]
    2cd6:	42a3      	cmp	r3, r4
    2cd8:	d8eb      	bhi.n	2cb2 <ali_light_bind_timer_cb+0x76>
    2cda:	2700      	movs	r7, #0
	}
	
	//model subscription
	// Add address to the subscription list
	//灯的所有model自行绑定组播地址0xC000，0xCFFF。
	for(uint8_t i = 0; i < p_ali_light->model_cnt; ++i){
    2cdc:	6834      	ldr	r4, [r6, #0]
    2cde:	0023      	movs	r3, r4
    2ce0:	3360      	adds	r3, #96	; 0x60
    2ce2:	781b      	ldrb	r3, [r3, #0]
    2ce4:	429f      	cmp	r7, r3
    2ce6:	d20e      	bcs.n	2d06 <ali_light_bind_timer_cb+0xca>
		mesh_model_t* t = &p_ali_light->model[i];
		//status = bc_m_mio_add_subscription(t->lid, 0xF000);
		bc_m_mio_add_subscription(t->lid, ALI_GROUP_ADDRESS_LIGHT);
    2ce8:	21c0      	movs	r1, #192	; 0xc0
    2cea:	013b      	lsls	r3, r7, #4
    2cec:	18e4      	adds	r4, r4, r3
    2cee:	3469      	adds	r4, #105	; 0x69
    2cf0:	0209      	lsls	r1, r1, #8
    2cf2:	7820      	ldrb	r0, [r4, #0]
    2cf4:	f006 fb11 	bl	931a <bc_m_mio_add_subscription>
	}
	
	//model subscription
	// Add address to the subscription list
	//灯的所有model自行绑定组播地址0xC000，0xCFFF。
	for(uint8_t i = 0; i < p_ali_light->model_cnt; ++i){
    2cf8:	3701      	adds	r7, #1
		mesh_model_t* t = &p_ali_light->model[i];
		//status = bc_m_mio_add_subscription(t->lid, 0xF000);
		bc_m_mio_add_subscription(t->lid, ALI_GROUP_ADDRESS_LIGHT);
		bc_m_mio_add_subscription(t->lid, 0xCFFF);
    2cfa:	7820      	ldrb	r0, [r4, #0]
    2cfc:	4927      	ldr	r1, [pc, #156]	; (2d9c <ali_light_bind_timer_cb+0x160>)
    2cfe:	f006 fb0c 	bl	931a <bc_m_mio_add_subscription>
	}
	
	//model subscription
	// Add address to the subscription list
	//灯的所有model自行绑定组播地址0xC000，0xCFFF。
	for(uint8_t i = 0; i < p_ali_light->model_cnt; ++i){
    2d02:	b2ff      	uxtb	r7, r7
    2d04:	e7ea      	b.n	2cdc <ali_light_bind_timer_cb+0xa0>
		bc_m_mio_add_subscription(t->lid, ALI_GROUP_ADDRESS_LIGHT);
		bc_m_mio_add_subscription(t->lid, 0xCFFF);
		
	}
	mesh_model_t* t = &p_ali_light->model[p_ali_light->model_cnt-1];
	bc_m_mio_add_subscription(t->lid, M_ALI_VENDER_ADDR);
    2d06:	21f0      	movs	r1, #240	; 0xf0
    2d08:	011b      	lsls	r3, r3, #4
    2d0a:	18e4      	adds	r4, r4, r3
    2d0c:	3459      	adds	r4, #89	; 0x59
    2d0e:	0209      	lsls	r1, r1, #8
    2d10:	7820      	ldrb	r0, [r4, #0]
    2d12:	f006 fb02 	bl	931a <bc_m_mio_add_subscription>

	// Set publication parameters
    status = bc_m_mio_set_publi_param(t->lid, M_ALI_VENDER_ADDR, NULL,
    2d16:	2182      	movs	r1, #130	; 0x82
    2d18:	782b      	ldrb	r3, [r5, #0]
    2d1a:	7820      	ldrb	r0, [r4, #0]
    2d1c:	9102      	str	r1, [sp, #8]
    2d1e:	395a      	subs	r1, #90	; 0x5a
    2d20:	9101      	str	r1, [sp, #4]
    2d22:	3922      	subs	r1, #34	; 0x22
    2d24:	2200      	movs	r2, #0
    2d26:	9100      	str	r1, [sp, #0]
    2d28:	21f0      	movs	r1, #240	; 0xf0
    2d2a:	9203      	str	r2, [sp, #12]
    2d2c:	0209      	lsls	r1, r1, #8
    2d2e:	f006 faf8 	bl	9322 <bc_m_mio_set_publi_param>
                                      app_key_lid, M_ALI_PUBLISH_TTL, M_ALI_PUBLISH_PERIOD,
                                     M_ALI_PUBLISH_RETX, 0);
	M_PRINTF(L_APP, "t->lid[%x] p_ali_light->model_cnt[%x] status[%x]",t->lid, p_ali_light->model_cnt, status);
    2d32:	4b18      	ldr	r3, [pc, #96]	; (2d94 <ali_light_bind_timer_cb+0x158>)
	}
	mesh_model_t* t = &p_ali_light->model[p_ali_light->model_cnt-1];
	bc_m_mio_add_subscription(t->lid, M_ALI_VENDER_ADDR);

	// Set publication parameters
    status = bc_m_mio_set_publi_param(t->lid, M_ALI_VENDER_ADDR, NULL,
    2d34:	0007      	movs	r7, r0
                                      app_key_lid, M_ALI_PUBLISH_TTL, M_ALI_PUBLISH_PERIOD,
                                     M_ALI_PUBLISH_RETX, 0);
	M_PRINTF(L_APP, "t->lid[%x] p_ali_light->model_cnt[%x] status[%x]",t->lid, p_ali_light->model_cnt, status);
    2d36:	681b      	ldr	r3, [r3, #0]
    2d38:	049b      	lsls	r3, r3, #18
    2d3a:	d519      	bpl.n	2d70 <ali_light_bind_timer_cb+0x134>
    2d3c:	4d16      	ldr	r5, [pc, #88]	; (2d98 <ali_light_bind_timer_cb+0x15c>)
    2d3e:	002b      	movs	r3, r5
    2d40:	002a      	movs	r2, r5
    2d42:	0028      	movs	r0, r5
    2d44:	3340      	adds	r3, #64	; 0x40
    2d46:	3225      	adds	r2, #37	; 0x25
    2d48:	9300      	str	r3, [sp, #0]
    2d4a:	0029      	movs	r1, r5
    2d4c:	23a2      	movs	r3, #162	; 0xa2
    2d4e:	3031      	adds	r0, #49	; 0x31
    2d50:	f001 fe2c 	bl	49ac <m_print>
    2d54:	0028      	movs	r0, r5
    2d56:	6833      	ldr	r3, [r6, #0]
    2d58:	7821      	ldrb	r1, [r4, #0]
    2d5a:	3360      	adds	r3, #96	; 0x60
    2d5c:	781a      	ldrb	r2, [r3, #0]
    2d5e:	3073      	adds	r0, #115	; 0x73
    2d60:	003b      	movs	r3, r7
    2d62:	f001 fe23 	bl	49ac <m_print>
    2d66:	0028      	movs	r0, r5
    2d68:	1da9      	adds	r1, r5, #6
    2d6a:	3070      	adds	r0, #112	; 0x70
    2d6c:	f001 fe1e 	bl	49ac <m_print>

#ifdef BREATH_CONFIG
	p_ali_light->breath.mode = BREATH_MODE_H2L2H;
    2d70:	6833      	ldr	r3, [r6, #0]
	p_ali_light->breath.rCnt = 3;
    2d72:	221c      	movs	r2, #28
                                      app_key_lid, M_ALI_PUBLISH_TTL, M_ALI_PUBLISH_PERIOD,
                                     M_ALI_PUBLISH_RETX, 0);
	M_PRINTF(L_APP, "t->lid[%x] p_ali_light->model_cnt[%x] status[%x]",t->lid, p_ali_light->model_cnt, status);

#ifdef BREATH_CONFIG
	p_ali_light->breath.mode = BREATH_MODE_H2L2H;
    2d74:	0018      	movs	r0, r3
    2d76:	305c      	adds	r0, #92	; 0x5c
	p_ali_light->breath.rCnt = 3;
    2d78:	7002      	strb	r2, [r0, #0]
	p_ali_light->breath.pCnt = 50;
    2d7a:	335e      	adds	r3, #94	; 0x5e
    2d7c:	3216      	adds	r2, #22
    2d7e:	801a      	strh	r2, [r3, #0]
	led_cw_set_breath(&p_ali_light->breath);
    2d80:	f7ff fa0c 	bl	219c <led_cw_set_breath>
#endif
	_ready_to_indicate(true);
    2d84:	2001      	movs	r0, #1
    2d86:	f7ff feeb 	bl	2b60 <_ready_to_indicate>
}
    2d8a:	b007      	add	sp, #28
    2d8c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    2d8e:	46c0      	nop			; (mov r8, r8)
    2d90:	10011008 	.word	0x10011008
    2d94:	10010514 	.word	0x10010514
    2d98:	000200f3 	.word	0x000200f3
    2d9c:	0000cfff 	.word	0x0000cfff

00002da0 <ali_light_period_ind_timer_cb>:

static void ali_light_period_ind_timer_cb(void* param)
{
    2da0:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	uint8_t data[12];
	
	int len = 1;
	data[0] = 0;
    2da2:	2600      	movs	r6, #0
    2da4:	ad01      	add	r5, sp, #4
    2da6:	702e      	strb	r6, [r5, #0]
	led_cw_set_on_off(on, NULL);
#endif
}
uint8_t ali_light_cw_get_on_off(void)
{
	return led_cw_get_on_off();
    2da8:	f7ff f9b8 	bl	211c <led_cw_get_on_off>
{
	uint8_t data[12];
	
	int len = 1;
	data[0] = 0;
	len += bc_mm_alis_set_onoff_status(&data[len], ali_light_cw_get_on_off());
    2dac:	466b      	mov	r3, sp
    2dae:	1e41      	subs	r1, r0, #1
    2db0:	4188      	sbcs	r0, r1
    2db2:	b2c1      	uxtb	r1, r0
    2db4:	1d58      	adds	r0, r3, #5
    2db6:	f002 fdfb 	bl	59b0 <bc_mm_alis_set_onoff_status>
    2dba:	1c44      	adds	r4, r0, #1
	led_cw_set_lightness(ln, NULL);
#endif
}
uint16_t ali_light_cw_get_lightness(void)
{
	return led_cw_get_lightness();
    2dbc:	f7ff f986 	bl	20cc <led_cw_get_lightness>
    2dc0:	0001      	movs	r1, r0
	uint8_t data[12];
	
	int len = 1;
	data[0] = 0;
	len += bc_mm_alis_set_onoff_status(&data[len], ali_light_cw_get_on_off());
	len += bc_mm_alis_set_ltn_status(&data[len], ali_light_cw_get_lightness());
    2dc2:	1928      	adds	r0, r5, r4
    2dc4:	f002 fe12 	bl	59ec <bc_mm_alis_set_ltn_status>
    2dc8:	1904      	adds	r4, r0, r4
	led_cw_set_temperature(tp, NULL);
#endif
}
uint16_t ali_light_cw_get_temperature(void)
{
	return led_cw_get_temperature();
    2dca:	f7ff f959 	bl	2080 <led_cw_get_temperature>
    2dce:	0001      	movs	r1, r0
	
	int len = 1;
	data[0] = 0;
	len += bc_mm_alis_set_onoff_status(&data[len], ali_light_cw_get_on_off());
	len += bc_mm_alis_set_ltn_status(&data[len], ali_light_cw_get_lightness());
	len += bc_mm_alis_set_tmp_status(&data[len], ali_light_cw_get_temperature());
    2dd0:	1928      	adds	r0, r5, r4
    2dd2:	f002 fe2b 	bl	5a2c <bc_mm_alis_set_tmp_status>
    2dd6:	1904      	adds	r4, r0, r4
	
	m_printf_hex(L_APP, "ali_light_period_ind_timer_cb", data, len);
    2dd8:	2080      	movs	r0, #128	; 0x80
    2dda:	490b      	ldr	r1, [pc, #44]	; (2e08 <ali_light_period_ind_timer_cb+0x68>)
    2ddc:	002a      	movs	r2, r5
    2dde:	0023      	movs	r3, r4
    2de0:	3124      	adds	r1, #36	; 0x24
    2de2:	0180      	lsls	r0, r0, #6
    2de4:	f001 fe42 	bl	4a6c <m_printf_hex>
	bc_mm_ali_vendor_send(p_ali_light->model[3].lid, MM_MSG_ALIS_ATTR_INDICATION, data, len);
    2de8:	4a08      	ldr	r2, [pc, #32]	; (2e0c <ali_light_period_ind_timer_cb+0x6c>)
    2dea:	b2a3      	uxth	r3, r4
    2dec:	6812      	ldr	r2, [r2, #0]
    2dee:	21d4      	movs	r1, #212	; 0xd4
    2df0:	3299      	adds	r2, #153	; 0x99
    2df2:	7810      	ldrb	r0, [r2, #0]
    2df4:	002a      	movs	r2, r5
    2df6:	f002 feef 	bl	5bd8 <bc_mm_ali_vendor_send>
	_ready_to_indicate(false);
    2dfa:	0030      	movs	r0, r6
    2dfc:	f7ff feb0 	bl	2b60 <_ready_to_indicate>
	bc_m_ali_save_seq_iv();
    2e00:	f006 fa75 	bl	92ee <bc_m_ali_save_seq_iv>
}
    2e04:	bd7f      	pop	{r0, r1, r2, r3, r4, r5, r6, pc}
    2e06:	46c0      	nop			; (mov r8, r8)
    2e08:	00020173 	.word	0x00020173
    2e0c:	10011008 	.word	0x10011008

00002e10 <ali_light_quick_restore_timer_cb>:

static void ali_light_quick_restore_timer_cb(void *t)
{
	M_PRINTF(L_APP, "");
    2e10:	4b16      	ldr	r3, [pc, #88]	; (2e6c <ali_light_quick_restore_timer_cb+0x5c>)
	_ready_to_indicate(false);
	bc_m_ali_save_seq_iv();
}

static void ali_light_quick_restore_timer_cb(void *t)
{
    2e12:	b573      	push	{r0, r1, r4, r5, r6, lr}
	M_PRINTF(L_APP, "");
    2e14:	681b      	ldr	r3, [r3, #0]
    2e16:	049b      	lsls	r3, r3, #18
    2e18:	d515      	bpl.n	2e46 <ali_light_quick_restore_timer_cb+0x36>
    2e1a:	4d15      	ldr	r5, [pc, #84]	; (2e70 <ali_light_quick_restore_timer_cb+0x60>)
    2e1c:	4c15      	ldr	r4, [pc, #84]	; (2e74 <ali_light_quick_restore_timer_cb+0x64>)
    2e1e:	002b      	movs	r3, r5
    2e20:	0022      	movs	r2, r4
    2e22:	0020      	movs	r0, r4
    2e24:	3342      	adds	r3, #66	; 0x42
    2e26:	0021      	movs	r1, r4
    2e28:	3225      	adds	r2, #37	; 0x25
    2e2a:	9300      	str	r3, [sp, #0]
    2e2c:	3031      	adds	r0, #49	; 0x31
    2e2e:	23bf      	movs	r3, #191	; 0xbf
    2e30:	f001 fdbc 	bl	49ac <m_print>
    2e34:	0028      	movs	r0, r5
    2e36:	3063      	adds	r0, #99	; 0x63
    2e38:	f001 fdb8 	bl	49ac <m_print>
    2e3c:	0020      	movs	r0, r4
    2e3e:	1da1      	adds	r1, r4, #6
    2e40:	3070      	adds	r0, #112	; 0x70
    2e42:	f001 fdb3 	bl	49ac <m_print>
	p_ali_light->quickTime = 0;
    2e46:	2400      	movs	r4, #0
    2e48:	4e0b      	ldr	r6, [pc, #44]	; (2e78 <ali_light_quick_restore_timer_cb+0x68>)
	p_ali_light->saveCfgCrc = bc_sys_check_sum((uint8_t*)p_ali_light, ALI_LIGHT_SAVE_LEN-1);
    2e4a:	2113      	movs	r1, #19
}

static void ali_light_quick_restore_timer_cb(void *t)
{
	M_PRINTF(L_APP, "");
	p_ali_light->quickTime = 0;
    2e4c:	6835      	ldr	r5, [r6, #0]
    2e4e:	702c      	strb	r4, [r5, #0]
	p_ali_light->saveCfgCrc = bc_sys_check_sum((uint8_t*)p_ali_light, ALI_LIGHT_SAVE_LEN-1);
    2e50:	0028      	movs	r0, r5
    2e52:	f7ff fc1b 	bl	268c <bc_sys_check_sum>
	bc_flash_erase(FLASH_ALI_START_ADDRRESS, 1);
    2e56:	2101      	movs	r1, #1

static void ali_light_quick_restore_timer_cb(void *t)
{
	M_PRINTF(L_APP, "");
	p_ali_light->quickTime = 0;
	p_ali_light->saveCfgCrc = bc_sys_check_sum((uint8_t*)p_ali_light, ALI_LIGHT_SAVE_LEN-1);
    2e58:	74e8      	strb	r0, [r5, #19]
	bc_flash_erase(FLASH_ALI_START_ADDRRESS, 1);
    2e5a:	0020      	movs	r0, r4
    2e5c:	f7fe fdc4 	bl	19e8 <bc_flash_erase>
	bc_flash_write(FLASH_ALI_START_ADDRRESS, ALI_LIGHT_SAVE_LEN,(uint8_t*)p_ali_light);
    2e60:	6832      	ldr	r2, [r6, #0]
    2e62:	2114      	movs	r1, #20
    2e64:	0020      	movs	r0, r4
    2e66:	f7fe fdfd 	bl	1a64 <bc_flash_write>
}
    2e6a:	bd73      	pop	{r0, r1, r4, r5, r6, pc}
    2e6c:	10010514 	.word	0x10010514
    2e70:	00020173 	.word	0x00020173
    2e74:	000200f3 	.word	0x000200f3
    2e78:	10011008 	.word	0x10011008

00002e7c <ali_light_quick_restore_init>:

uint8_t ali_light_quick_restore_init(void)
{
    2e7c:	b573      	push	{r0, r1, r4, r5, r6, lr}
	if(p_ali_light->quickTime++ < ALI_QUICK_START_CNT){//0 1 2 3 4
    2e7e:	4d25      	ldr	r5, [pc, #148]	; (2f14 <ali_light_quick_restore_init+0x98>)
    2e80:	682c      	ldr	r4, [r5, #0]
    2e82:	002e      	movs	r6, r5
    2e84:	7823      	ldrb	r3, [r4, #0]
    2e86:	1c5a      	adds	r2, r3, #1
    2e88:	7022      	strb	r2, [r4, #0]
    2e8a:	2b04      	cmp	r3, #4
    2e8c:	d80f      	bhi.n	2eae <ali_light_quick_restore_init+0x32>
		p_ali_light->saveCfgCrc = bc_sys_check_sum((uint8_t*)p_ali_light, ALI_LIGHT_SAVE_LEN-1);
    2e8e:	2113      	movs	r1, #19
    2e90:	0020      	movs	r0, r4
    2e92:	f7ff fbfb 	bl	268c <bc_sys_check_sum>
		bc_flash_erase(FLASH_ALI_START_ADDRRESS, 1);
    2e96:	2101      	movs	r1, #1
}

uint8_t ali_light_quick_restore_init(void)
{
	if(p_ali_light->quickTime++ < ALI_QUICK_START_CNT){//0 1 2 3 4
		p_ali_light->saveCfgCrc = bc_sys_check_sum((uint8_t*)p_ali_light, ALI_LIGHT_SAVE_LEN-1);
    2e98:	74e0      	strb	r0, [r4, #19]
		bc_flash_erase(FLASH_ALI_START_ADDRRESS, 1);
    2e9a:	2000      	movs	r0, #0
    2e9c:	f7fe fda4 	bl	19e8 <bc_flash_erase>
		bc_flash_write(FLASH_ALI_START_ADDRRESS, ALI_LIGHT_SAVE_LEN,(uint8_t*)p_ali_light);
    2ea0:	682a      	ldr	r2, [r5, #0]
    2ea2:	2114      	movs	r1, #20
    2ea4:	2000      	movs	r0, #0
    2ea6:	f7fe fddd 	bl	1a64 <bc_flash_write>
		return 0;
    2eaa:	2000      	movs	r0, #0
    2eac:	e031      	b.n	2f12 <ali_light_quick_restore_init+0x96>
	}
	M_PRINTF(L_APP, "");
    2eae:	4b1a      	ldr	r3, [pc, #104]	; (2f18 <ali_light_quick_restore_init+0x9c>)
    2eb0:	681b      	ldr	r3, [r3, #0]
    2eb2:	049b      	lsls	r3, r3, #18
    2eb4:	d515      	bpl.n	2ee2 <ali_light_quick_restore_init+0x66>
    2eb6:	4d19      	ldr	r5, [pc, #100]	; (2f1c <ali_light_quick_restore_init+0xa0>)
    2eb8:	4c19      	ldr	r4, [pc, #100]	; (2f20 <ali_light_quick_restore_init+0xa4>)
    2eba:	002b      	movs	r3, r5
    2ebc:	0022      	movs	r2, r4
    2ebe:	0020      	movs	r0, r4
    2ec0:	3364      	adds	r3, #100	; 0x64
    2ec2:	0021      	movs	r1, r4
    2ec4:	3225      	adds	r2, #37	; 0x25
    2ec6:	9300      	str	r3, [sp, #0]
    2ec8:	3031      	adds	r0, #49	; 0x31
    2eca:	23ce      	movs	r3, #206	; 0xce
    2ecc:	f001 fd6e 	bl	49ac <m_print>
    2ed0:	0028      	movs	r0, r5
    2ed2:	3063      	adds	r0, #99	; 0x63
    2ed4:	f001 fd6a 	bl	49ac <m_print>
    2ed8:	0020      	movs	r0, r4
    2eda:	1da1      	adds	r1, r4, #6
    2edc:	3070      	adds	r0, #112	; 0x70
    2ede:	f001 fd65 	bl	49ac <m_print>
#ifdef BREATH_CONFIG
	p_ali_light->breath.mode = BREATH_MODE_H2L2H;
    2ee2:	6833      	ldr	r3, [r6, #0]
	p_ali_light->breath.rCnt = 5;
    2ee4:	222c      	movs	r2, #44	; 0x2c
		bc_flash_write(FLASH_ALI_START_ADDRRESS, ALI_LIGHT_SAVE_LEN,(uint8_t*)p_ali_light);
		return 0;
	}
	M_PRINTF(L_APP, "");
#ifdef BREATH_CONFIG
	p_ali_light->breath.mode = BREATH_MODE_H2L2H;
    2ee6:	0018      	movs	r0, r3
    2ee8:	305c      	adds	r0, #92	; 0x5c
	p_ali_light->breath.rCnt = 5;
    2eea:	7002      	strb	r2, [r0, #0]
	p_ali_light->breath.pCnt = 50;
    2eec:	335e      	adds	r3, #94	; 0x5e
    2eee:	3206      	adds	r2, #6
    2ef0:	801a      	strh	r2, [r3, #0]
	led_cw_set_breath(&p_ali_light->breath);
    2ef2:	f7ff f953 	bl	219c <led_cw_set_breath>

	while(led_cw_breath_is_running()){
    2ef6:	f7ff fa4f 	bl	2398 <led_cw_breath_is_running>
    2efa:	1e04      	subs	r4, r0, #0
    2efc:	d002      	beq.n	2f04 <ali_light_quick_restore_init+0x88>
		SYS_timerPolling();
    2efe:	f7fe ff7a 	bl	1df6 <SYS_timerPolling>
    2f02:	e7f8      	b.n	2ef6 <ali_light_quick_restore_init+0x7a>
		led_cw_set_on_off(i%2,NULL);
		M_PRINTF(L_APP, "led status = %d", i%2);
	}while(i-->1);
#endif
	//restore flash parameter
	bc_m_clear_config();
    2f04:	f006 f9e3 	bl	92ce <bc_m_clear_config>
	//clear quick count
	bc_flash_erase(FLASH_ALI_START_ADDRRESS, 1);	
    2f08:	2101      	movs	r1, #1
    2f0a:	0020      	movs	r0, r4
    2f0c:	f7fe fd6c 	bl	19e8 <bc_flash_erase>
	return 1;
    2f10:	2001      	movs	r0, #1
}
    2f12:	bd76      	pop	{r1, r2, r4, r5, r6, pc}
    2f14:	10011008 	.word	0x10011008
    2f18:	10010514 	.word	0x10010514
    2f1c:	00020173 	.word	0x00020173
    2f20:	000200f3 	.word	0x000200f3

00002f24 <ali_light_prov_state_cb>:

void ali_light_prov_state_cb(uint8_t state)
{
    2f24:	b510      	push	{r4, lr}
#ifdef APP_FOR_ALI
	if(state == M_PROV_SUCCEED_APP){
    2f26:	2803      	cmp	r0, #3
    2f28:	d107      	bne.n	2f3a <ali_light_prov_state_cb+0x16>
		SYS_SetTimer(&p_ali_light->bindDelayTimer, (int)50/10, 
    2f2a:	4b04      	ldr	r3, [pc, #16]	; (2f3c <ali_light_prov_state_cb+0x18>)
    2f2c:	2200      	movs	r2, #0
    2f2e:	6818      	ldr	r0, [r3, #0]
    2f30:	2105      	movs	r1, #5
    2f32:	302c      	adds	r0, #44	; 0x2c
    2f34:	4b02      	ldr	r3, [pc, #8]	; (2f40 <ali_light_prov_state_cb+0x1c>)
    2f36:	f7fe ff0b 	bl	1d50 <SYS_SetTimer>
					TIMER_SINGLE, (Timer_Expire_CB)ali_light_bind_timer_cb);
		return;
	}
#endif 
}
    2f3a:	bd10      	pop	{r4, pc}
    2f3c:	10011008 	.word	0x10011008
    2f40:	00002c3d 	.word	0x00002c3d

00002f44 <ali_light_prov_state_get>:

uint8_t ali_light_prov_state_get(void)
{
	M_PRINTF(L_APP, "bond status[%d]", p_ali_light->provState);
    2f44:	4b11      	ldr	r3, [pc, #68]	; (2f8c <ali_light_prov_state_get+0x48>)
	}
#endif 
}

uint8_t ali_light_prov_state_get(void)
{
    2f46:	b573      	push	{r0, r1, r4, r5, r6, lr}
	M_PRINTF(L_APP, "bond status[%d]", p_ali_light->provState);
    2f48:	681b      	ldr	r3, [r3, #0]
    2f4a:	4e11      	ldr	r6, [pc, #68]	; (2f90 <ali_light_prov_state_get+0x4c>)
    2f4c:	049b      	lsls	r3, r3, #18
    2f4e:	d516      	bpl.n	2f7e <ali_light_prov_state_get+0x3a>
    2f50:	4c10      	ldr	r4, [pc, #64]	; (2f94 <ali_light_prov_state_get+0x50>)
    2f52:	4d11      	ldr	r5, [pc, #68]	; (2f98 <ali_light_prov_state_get+0x54>)
    2f54:	0022      	movs	r2, r4
    2f56:	0020      	movs	r0, r4
    2f58:	1c6b      	adds	r3, r5, #1
    2f5a:	3225      	adds	r2, #37	; 0x25
    2f5c:	9300      	str	r3, [sp, #0]
    2f5e:	0021      	movs	r1, r4
    2f60:	23f9      	movs	r3, #249	; 0xf9
    2f62:	3031      	adds	r0, #49	; 0x31
    2f64:	f001 fd22 	bl	49ac <m_print>
    2f68:	0028      	movs	r0, r5
    2f6a:	6833      	ldr	r3, [r6, #0]
    2f6c:	301a      	adds	r0, #26
    2f6e:	7859      	ldrb	r1, [r3, #1]
    2f70:	f001 fd1c 	bl	49ac <m_print>
    2f74:	0020      	movs	r0, r4
    2f76:	1da1      	adds	r1, r4, #6
    2f78:	3070      	adds	r0, #112	; 0x70
    2f7a:	f001 fd17 	bl	49ac <m_print>
	return p_ali_light->provState == 1;
    2f7e:	6833      	ldr	r3, [r6, #0]
    2f80:	7858      	ldrb	r0, [r3, #1]
    2f82:	3801      	subs	r0, #1
    2f84:	4242      	negs	r2, r0
    2f86:	4142      	adcs	r2, r0
    2f88:	b2d0      	uxtb	r0, r2
}
    2f8a:	bd76      	pop	{r1, r2, r4, r5, r6, pc}
    2f8c:	10010514 	.word	0x10010514
    2f90:	10011008 	.word	0x10011008
    2f94:	000200f3 	.word	0x000200f3
    2f98:	000201f3 	.word	0x000201f3

00002f9c <ali_light_factory_reset>:

void ali_light_factory_reset()
{
    2f9c:	b510      	push	{r4, lr}
	bc_m_clear_config();
    2f9e:	f006 f996 	bl	92ce <bc_m_clear_config>
	bc_flash_erase(FLASH_ALI_START_ADDRRESS, 1);
    2fa2:	2101      	movs	r1, #1
    2fa4:	2000      	movs	r0, #0
    2fa6:	f7fe fd1f 	bl	19e8 <bc_flash_erase>
	bc_sys_reset();
    2faa:	f7ff fb67 	bl	267c <bc_sys_reset>
}
    2fae:	bd10      	pop	{r4, pc}

00002fb0 <ali_light_param_init>:
	p_ali_light->key_pre = 0;
	p_ali_light->key_next = 0;
}
#endif
uint8_t ali_light_param_init()
{
    2fb0:	b5f0      	push	{r4, r5, r6, r7, lr}
	memset(p_ali_light, 0, sizeof(ali_light_t));
    2fb2:	4c43      	ldr	r4, [pc, #268]	; (30c0 <ali_light_param_init+0x110>)
	p_ali_light->key_pre = 0;
	p_ali_light->key_next = 0;
}
#endif
uint8_t ali_light_param_init()
{
    2fb4:	b089      	sub	sp, #36	; 0x24
	memset(p_ali_light, 0, sizeof(ali_light_t));
    2fb6:	6825      	ldr	r5, [r4, #0]
    2fb8:	22c4      	movs	r2, #196	; 0xc4
    2fba:	2100      	movs	r1, #0
    2fbc:	0028      	movs	r0, r5
    2fbe:	f012 fd45 	bl	15a4c <memset>
	//read saved parameter
	bc_flash_read(FLASH_ALI_START_ADDRRESS, ALI_LIGHT_SAVE_LEN,(uint8_t*)p_ali_light);
    2fc2:	002a      	movs	r2, r5
    2fc4:	2114      	movs	r1, #20
    2fc6:	2000      	movs	r0, #0
    2fc8:	f7fe fd2e 	bl	1a28 <bc_flash_read>
	uint8_t tCrc = bc_sys_check_sum((uint8_t*)p_ali_light, ALI_LIGHT_SAVE_LEN-1);
    2fcc:	2113      	movs	r1, #19
    2fce:	6820      	ldr	r0, [r4, #0]
    2fd0:	f7ff fb5c 	bl	268c <bc_sys_check_sum>
	if(p_ali_light->saveCfgCrc != tCrc){
    2fd4:	6825      	ldr	r5, [r4, #0]
    2fd6:	7ceb      	ldrb	r3, [r5, #19]
    2fd8:	4283      	cmp	r3, r0
    2fda:	d008      	beq.n	2fee <ali_light_param_init+0x3e>
		memset((uint8_t*)p_ali_light, 0, ALI_LIGHT_SAVE_LEN);
    2fdc:	2214      	movs	r2, #20
    2fde:	2100      	movs	r1, #0
    2fe0:	0028      	movs	r0, r5
    2fe2:	f012 fd33 	bl	15a4c <memset>
		p_ali_light->dType = ali_config_device_type_get();
    2fe6:	f001 f8ed 	bl	41c4 <ali_config_device_type_get>
    2fea:	70a8      	strb	r0, [r5, #2]
    2fec:	e03f      	b.n	306e <ali_light_param_init+0xbe>
	}else{
		if(p_ali_light->dType != ali_config_device_type_get()){//change device type
    2fee:	78ad      	ldrb	r5, [r5, #2]
    2ff0:	f001 f8e8 	bl	41c4 <ali_config_device_type_get>
    2ff4:	4285      	cmp	r5, r0
    2ff6:	d03a      	beq.n	306e <ali_light_param_init+0xbe>
			M_PRINTF(L_APP, "device type is changed [%d] to [%d]", p_ali_light->dType, ali_config_device_type_get());
    2ff8:	4b32      	ldr	r3, [pc, #200]	; (30c4 <ali_light_param_init+0x114>)
    2ffa:	681b      	ldr	r3, [r3, #0]
    2ffc:	049b      	lsls	r3, r3, #18
    2ffe:	d51c      	bpl.n	303a <ali_light_param_init+0x8a>
    3000:	4e31      	ldr	r6, [pc, #196]	; (30c8 <ali_light_param_init+0x118>)
    3002:	4d32      	ldr	r5, [pc, #200]	; (30cc <ali_light_param_init+0x11c>)
    3004:	0033      	movs	r3, r6
    3006:	332a      	adds	r3, #42	; 0x2a
    3008:	9300      	str	r3, [sp, #0]
    300a:	002a      	movs	r2, r5
    300c:	0028      	movs	r0, r5
    300e:	2330      	movs	r3, #48	; 0x30
    3010:	3225      	adds	r2, #37	; 0x25
    3012:	0029      	movs	r1, r5
    3014:	33ff      	adds	r3, #255	; 0xff
    3016:	3031      	adds	r0, #49	; 0x31
    3018:	f001 fcc8 	bl	49ac <m_print>
    301c:	6823      	ldr	r3, [r4, #0]
    301e:	789f      	ldrb	r7, [r3, #2]
    3020:	f001 f8d0 	bl	41c4 <ali_config_device_type_get>
    3024:	0002      	movs	r2, r0
    3026:	0030      	movs	r0, r6
    3028:	0039      	movs	r1, r7
    302a:	303f      	adds	r0, #63	; 0x3f
    302c:	f001 fcbe 	bl	49ac <m_print>
    3030:	0028      	movs	r0, r5
    3032:	1da9      	adds	r1, r5, #6
    3034:	3070      	adds	r0, #112	; 0x70
    3036:	f001 fcb9 	bl	49ac <m_print>
			bc_m_clear_config();
    303a:	f006 f948 	bl	92ce <bc_m_clear_config>
			memset((uint8_t*)p_ali_light, 0,  ALI_LIGHT_SAVE_LEN);
    303e:	6825      	ldr	r5, [r4, #0]
    3040:	2214      	movs	r2, #20
    3042:	2100      	movs	r1, #0
    3044:	0028      	movs	r0, r5
    3046:	f012 fd01 	bl	15a4c <memset>
			p_ali_light->dType = ali_config_device_type_get();
    304a:	f001 f8bb 	bl	41c4 <ali_config_device_type_get>
    304e:	70a8      	strb	r0, [r5, #2]
			p_ali_light->saveCfgCrc = bc_sys_check_sum((uint8_t*)p_ali_light, ALI_LIGHT_SAVE_LEN-1);
    3050:	6825      	ldr	r5, [r4, #0]
    3052:	2113      	movs	r1, #19
    3054:	0028      	movs	r0, r5
    3056:	f7ff fb19 	bl	268c <bc_sys_check_sum>
			bc_flash_erase(FLASH_ALI_START_ADDRRESS, 1);
    305a:	2101      	movs	r1, #1
		if(p_ali_light->dType != ali_config_device_type_get()){//change device type
			M_PRINTF(L_APP, "device type is changed [%d] to [%d]", p_ali_light->dType, ali_config_device_type_get());
			bc_m_clear_config();
			memset((uint8_t*)p_ali_light, 0,  ALI_LIGHT_SAVE_LEN);
			p_ali_light->dType = ali_config_device_type_get();
			p_ali_light->saveCfgCrc = bc_sys_check_sum((uint8_t*)p_ali_light, ALI_LIGHT_SAVE_LEN-1);
    305c:	74e8      	strb	r0, [r5, #19]
			bc_flash_erase(FLASH_ALI_START_ADDRRESS, 1);
    305e:	2000      	movs	r0, #0
    3060:	f7fe fcc2 	bl	19e8 <bc_flash_erase>
			bc_flash_write(FLASH_ALI_START_ADDRRESS, ALI_LIGHT_SAVE_LEN,(uint8_t*)p_ali_light);
    3064:	6822      	ldr	r2, [r4, #0]
    3066:	2114      	movs	r1, #20
    3068:	2000      	movs	r0, #0
    306a:	f7fe fcfb 	bl	1a64 <bc_flash_write>
		}
	}

	if(p_ali_light->dType == PID_CW){
    306e:	6823      	ldr	r3, [r4, #0]
    3070:	7899      	ldrb	r1, [r3, #2]
    3072:	2900      	cmp	r1, #0
    3074:	d11d      	bne.n	30b2 <ali_light_param_init+0x102>

//light ctrl
static void _cw_init(void)
{
	static uint8_t _init = 0;
	if(_init == 1)
    3076:	7923      	ldrb	r3, [r4, #4]
    3078:	2b01      	cmp	r3, #1
    307a:	d01d      	beq.n	30b8 <ali_light_param_init+0x108>
		return;
	_init = 1;
    307c:	2501      	movs	r5, #1
#ifdef BREATH_CONFIG
	light_cw_t t = {.freq = ALI_FREQUENCY_2K,
    307e:	ae03      	add	r6, sp, #12
    3080:	2214      	movs	r2, #20
    3082:	0030      	movs	r0, r6
static void _cw_init(void)
{
	static uint8_t _init = 0;
	if(_init == 1)
		return;
	_init = 1;
    3084:	7125      	strb	r5, [r4, #4]
#ifdef BREATH_CONFIG
	light_cw_t t = {.freq = ALI_FREQUENCY_2K,
    3086:	f012 fce1 	bl	15a4c <memset>
    308a:	4b11      	ldr	r3, [pc, #68]	; (30d0 <ali_light_param_init+0x120>)
					.ln = 0,
					.on = ALI_CW_ON,
					.tp = ALI_DEFAULT_TP_VAL};
	led_cw_init(&t);
    308c:	0030      	movs	r0, r6
	static uint8_t _init = 0;
	if(_init == 1)
		return;
	_init = 1;
#ifdef BREATH_CONFIG
	light_cw_t t = {.freq = ALI_FREQUENCY_2K,
    308e:	80b3      	strh	r3, [r6, #4]
    3090:	4b10      	ldr	r3, [pc, #64]	; (30d4 <ali_light_param_init+0x124>)
    3092:	7235      	strb	r5, [r6, #8]
    3094:	81f3      	strh	r3, [r6, #14]
					.ln = 0,
					.on = ALI_CW_ON,
					.tp = ALI_DEFAULT_TP_VAL};
	led_cw_init(&t);
    3096:	f7ff f847 	bl	2128 <led_cw_init>
	p_ali_light->breath.mode = BREATH_MODE_L2H;
    309a:	6823      	ldr	r3, [r4, #0]
	p_ali_light->breath.rCnt = 1;
    309c:	2208      	movs	r2, #8
	light_cw_t t = {.freq = ALI_FREQUENCY_2K,
					.ln = 0,
					.on = ALI_CW_ON,
					.tp = ALI_DEFAULT_TP_VAL};
	led_cw_init(&t);
	p_ali_light->breath.mode = BREATH_MODE_L2H;
    309e:	0018      	movs	r0, r3
	p_ali_light->breath.rCnt = 1;
    30a0:	4315      	orrs	r5, r2
	light_cw_t t = {.freq = ALI_FREQUENCY_2K,
					.ln = 0,
					.on = ALI_CW_ON,
					.tp = ALI_DEFAULT_TP_VAL};
	led_cw_init(&t);
	p_ali_light->breath.mode = BREATH_MODE_L2H;
    30a2:	305c      	adds	r0, #92	; 0x5c
	p_ali_light->breath.rCnt = 1;
	p_ali_light->breath.pCnt = REPEAT_COUNTER;
    30a4:	335e      	adds	r3, #94	; 0x5e
    30a6:	3220      	adds	r2, #32
					.ln = 0,
					.on = ALI_CW_ON,
					.tp = ALI_DEFAULT_TP_VAL};
	led_cw_init(&t);
	p_ali_light->breath.mode = BREATH_MODE_L2H;
	p_ali_light->breath.rCnt = 1;
    30a8:	7005      	strb	r5, [r0, #0]
	p_ali_light->breath.pCnt = REPEAT_COUNTER;
    30aa:	801a      	strh	r2, [r3, #0]
	led_cw_set_breath(&p_ali_light->breath);
    30ac:	f7ff f876 	bl	219c <led_cw_set_breath>
    30b0:	e002      	b.n	30b8 <ali_light_param_init+0x108>
	}

	if(p_ali_light->dType == PID_CW){
		_cw_init();
	}else{//PID_LTN
		led_ltn_init(NULL);
    30b2:	2000      	movs	r0, #0
    30b4:	f7ff f9c2 	bl	243c <led_ltn_init>
	}
	return 0;
}
    30b8:	2000      	movs	r0, #0
    30ba:	b009      	add	sp, #36	; 0x24
    30bc:	bdf0      	pop	{r4, r5, r6, r7, pc}
    30be:	46c0      	nop			; (mov r8, r8)
    30c0:	10011008 	.word	0x10011008
    30c4:	10010514 	.word	0x10010514
    30c8:	000201f3 	.word	0x000201f3
    30cc:	000200f3 	.word	0x000200f3
    30d0:	00002ee0 	.word	0x00002ee0
    30d4:	000028a0 	.word	0x000028a0

000030d8 <_ali_vendor_rx_cb>:

static void _ali_vendor_rx_cb(const m_lid_t model_lid, const uint8_t opcode, const uint8_t* data, const uint16_t len)
{
    30d8:	b510      	push	{r4, lr}
	if(model_lid != p_ali_light->model[3].lid){
    30da:	4c07      	ldr	r4, [pc, #28]	; (30f8 <_ali_vendor_rx_cb+0x20>)
    30dc:	6824      	ldr	r4, [r4, #0]
    30de:	3499      	adds	r4, #153	; 0x99
    30e0:	7824      	ldrb	r4, [r4, #0]
    30e2:	4284      	cmp	r4, r0
    30e4:	d107      	bne.n	30f6 <_ali_vendor_rx_cb+0x1e>
		return;
	}
	switch(opcode){
    30e6:	29d5      	cmp	r1, #213	; 0xd5
    30e8:	d105      	bne.n	30f6 <_ali_vendor_rx_cb+0x1e>
	case MM_MSG_ALIS_ATTR_CONFIRMATION:{
		m_printf_hex(L_APP, "ALI VENDOR RECV", data, len);
    30ea:	2080      	movs	r0, #128	; 0x80
    30ec:	4903      	ldr	r1, [pc, #12]	; (30fc <_ali_vendor_rx_cb+0x24>)
    30ee:	0180      	lsls	r0, r0, #6
    30f0:	3163      	adds	r1, #99	; 0x63
    30f2:	f001 fcbb 	bl	4a6c <m_printf_hex>
	}break;
	default:break;
	}
}
    30f6:	bd10      	pop	{r4, pc}
    30f8:	10011008 	.word	0x10011008
    30fc:	000201f3 	.word	0x000201f3

00003100 <ali_light_init>:

uint8_t ali_light_init(mesh_model_t** mdl, uint8_t* mcnt)
{
    3100:	b5f0      	push	{r4, r5, r6, r7, lr}
	M_PRINTF(L_APP, "-------init light---------");
    3102:	4b54      	ldr	r3, [pc, #336]	; (3254 <ali_light_init+0x154>)
	default:break;
	}
}

uint8_t ali_light_init(mesh_model_t** mdl, uint8_t* mcnt)
{
    3104:	b085      	sub	sp, #20
	M_PRINTF(L_APP, "-------init light---------");
    3106:	681b      	ldr	r3, [r3, #0]
	default:break;
	}
}

uint8_t ali_light_init(mesh_model_t** mdl, uint8_t* mcnt)
{
    3108:	0007      	movs	r7, r0
    310a:	9103      	str	r1, [sp, #12]
	M_PRINTF(L_APP, "-------init light---------");
    310c:	049b      	lsls	r3, r3, #18
    310e:	d515      	bpl.n	313c <ali_light_init+0x3c>
    3110:	4b51      	ldr	r3, [pc, #324]	; (3258 <ali_light_init+0x158>)
    3112:	4c52      	ldr	r4, [pc, #328]	; (325c <ali_light_init+0x15c>)
    3114:	3373      	adds	r3, #115	; 0x73
    3116:	9300      	str	r3, [sp, #0]
    3118:	0022      	movs	r2, r4
    311a:	0020      	movs	r0, r4
    311c:	23a8      	movs	r3, #168	; 0xa8
    311e:	0021      	movs	r1, r4
    3120:	3225      	adds	r2, #37	; 0x25
    3122:	005b      	lsls	r3, r3, #1
    3124:	3031      	adds	r0, #49	; 0x31
    3126:	f001 fc41 	bl	49ac <m_print>
    312a:	484d      	ldr	r0, [pc, #308]	; (3260 <ali_light_init+0x160>)
    312c:	3002      	adds	r0, #2
    312e:	f001 fc3d 	bl	49ac <m_print>
    3132:	0020      	movs	r0, r4
    3134:	1da1      	adds	r1, r4, #6
    3136:	3070      	adds	r0, #112	; 0x70
    3138:	f001 fc38 	bl	49ac <m_print>
	p_ali_light = ke_malloc(sizeof(ali_light_t), 0);
    313c:	2100      	movs	r1, #0
    313e:	20c4      	movs	r0, #196	; 0xc4
    3140:	f004 f8ce 	bl	72e0 <ke_malloc>
    3144:	4d47      	ldr	r5, [pc, #284]	; (3264 <ali_light_init+0x164>)
	if(p_ali_light == NULL)
		return 1;
    3146:	2401      	movs	r4, #1
}

uint8_t ali_light_init(mesh_model_t** mdl, uint8_t* mcnt)
{
	M_PRINTF(L_APP, "-------init light---------");
	p_ali_light = ke_malloc(sizeof(ali_light_t), 0);
    3148:	6028      	str	r0, [r5, #0]
	if(p_ali_light == NULL)
    314a:	2800      	cmp	r0, #0
    314c:	d07f      	beq.n	324e <ali_light_init+0x14e>
		return 1;
	
	ali_light_param_init();
    314e:	f7ff ff2f 	bl	2fb0 <ali_light_param_init>
	//ali local quick restore parameter
	if(1 == ali_light_quick_restore_init()){
    3152:	f7ff fe93 	bl	2e7c <ali_light_quick_restore_init>
    3156:	42a0      	cmp	r0, r4
    3158:	d101      	bne.n	315e <ali_light_init+0x5e>
		ali_light_param_init();//reinit
    315a:	f7ff ff29 	bl	2fb0 <ali_light_param_init>
	}
	
	//start timer for clear
	SYS_SetTimer(&p_ali_light->startDelayTimer, (int)ALI_QUICK_START_TIME/10, 
    315e:	21fa      	movs	r1, #250	; 0xfa
    3160:	6828      	ldr	r0, [r5, #0]
    3162:	4b41      	ldr	r3, [pc, #260]	; (3268 <ali_light_init+0x168>)
    3164:	2200      	movs	r2, #0
    3166:	0049      	lsls	r1, r1, #1
    3168:	3014      	adds	r0, #20
    316a:	f7fe fdf1 	bl	1d50 <SYS_SetTimer>
					TIMER_SINGLE, (Timer_Expire_CB)ali_light_quick_restore_timer_cb);

	if(p_ali_light->dType == PID_CW){
    316e:	6828      	ldr	r0, [r5, #0]
    3170:	0001      	movs	r1, r0
    3172:	0003      	movs	r3, r0
    3174:	7882      	ldrb	r2, [r0, #2]
    3176:	31a4      	adds	r1, #164	; 0xa4
    3178:	33a8      	adds	r3, #168	; 0xa8
    317a:	2a00      	cmp	r2, #0
    317c:	d104      	bne.n	3188 <ali_light_init+0x88>
		p_ali_light->oo_ctrl.set = ali_light_cw_set_on_off;
    317e:	4a3b      	ldr	r2, [pc, #236]	; (326c <ali_light_init+0x16c>)
    3180:	600a      	str	r2, [r1, #0]
		p_ali_light->oo_ctrl.get = ali_light_cw_get_on_off;
    3182:	4a3b      	ldr	r2, [pc, #236]	; (3270 <ali_light_init+0x170>)
    3184:	601a      	str	r2, [r3, #0]
    3186:	e003      	b.n	3190 <ali_light_init+0x90>
	}else{//PID_LTN
		p_ali_light->oo_ctrl.set = ali_light_ltn_set_on_off;
    3188:	4a3a      	ldr	r2, [pc, #232]	; (3274 <ali_light_init+0x174>)
    318a:	600a      	str	r2, [r1, #0]
		p_ali_light->oo_ctrl.get = ali_light_ltn_get_on_off;
    318c:	4a3a      	ldr	r2, [pc, #232]	; (3278 <ali_light_init+0x178>)
    318e:	601a      	str	r2, [r3, #0]
	}
	mesh_model_t* tmModel = &p_ali_light->model[p_ali_light->model_cnt++];
    3190:	0002      	movs	r2, r0
    3192:	3260      	adds	r2, #96	; 0x60
    3194:	7813      	ldrb	r3, [r2, #0]
    3196:	1c5c      	adds	r4, r3, #1
	tmModel->offset = 0;//element num
    3198:	3306      	adds	r3, #6
    319a:	011b      	lsls	r3, r3, #4
    319c:	18c0      	adds	r0, r0, r3
    319e:	2300      	movs	r3, #0
		p_ali_light->oo_ctrl.get = ali_light_cw_get_on_off;
	}else{//PID_LTN
		p_ali_light->oo_ctrl.set = ali_light_ltn_set_on_off;
		p_ali_light->oo_ctrl.get = ali_light_ltn_get_on_off;
	}
	mesh_model_t* tmModel = &p_ali_light->model[p_ali_light->model_cnt++];
    31a0:	7014      	strb	r4, [r2, #0]
    31a2:	3004      	adds	r0, #4
	tmModel->offset = 0;//element num
    31a4:	7103      	strb	r3, [r0, #4]
	bc_mm_gens_oo_init(tmModel, &p_ali_light->oo_ctrl);
    31a6:	f002 feb3 	bl	5f10 <bc_mm_gens_oo_init>

	if(p_ali_light->dType == PID_CW){
    31aa:	6829      	ldr	r1, [r5, #0]
    31ac:	000a      	movs	r2, r1
    31ae:	000b      	movs	r3, r1
    31b0:	7888      	ldrb	r0, [r1, #2]
    31b2:	32ac      	adds	r2, #172	; 0xac
    31b4:	33b0      	adds	r3, #176	; 0xb0
    31b6:	2800      	cmp	r0, #0
    31b8:	d104      	bne.n	31c4 <ali_light_init+0xc4>
		p_ali_light->light_ln_ctrl.set = ali_light_cw_set_lightness;
    31ba:	4830      	ldr	r0, [pc, #192]	; (327c <ali_light_init+0x17c>)
    31bc:	6010      	str	r0, [r2, #0]
		p_ali_light->light_ln_ctrl.get = ali_light_cw_get_lightness;
    31be:	4a30      	ldr	r2, [pc, #192]	; (3280 <ali_light_init+0x180>)
    31c0:	601a      	str	r2, [r3, #0]
    31c2:	e003      	b.n	31cc <ali_light_init+0xcc>
	}else{//PID_LTN
		p_ali_light->light_ln_ctrl.set = ali_light_ltn_set_lightness;
    31c4:	482f      	ldr	r0, [pc, #188]	; (3284 <ali_light_init+0x184>)
    31c6:	6010      	str	r0, [r2, #0]
		p_ali_light->light_ln_ctrl.get = ali_light_ltn_get_lightness;
    31c8:	4a2f      	ldr	r2, [pc, #188]	; (3288 <ali_light_init+0x188>)
    31ca:	601a      	str	r2, [r3, #0]
	}
	tmModel = &p_ali_light->model[p_ali_light->model_cnt++];
    31cc:	000b      	movs	r3, r1
	tmModel->offset = 0;//element num
    31ce:	2400      	movs	r4, #0
		p_ali_light->light_ln_ctrl.get = ali_light_cw_get_lightness;
	}else{//PID_LTN
		p_ali_light->light_ln_ctrl.set = ali_light_ltn_set_lightness;
		p_ali_light->light_ln_ctrl.get = ali_light_ltn_get_lightness;
	}
	tmModel = &p_ali_light->model[p_ali_light->model_cnt++];
    31d0:	3360      	adds	r3, #96	; 0x60
    31d2:	7818      	ldrb	r0, [r3, #0]
    31d4:	1c42      	adds	r2, r0, #1
	tmModel->offset = 0;//element num
    31d6:	3006      	adds	r0, #6
    31d8:	0100      	lsls	r0, r0, #4
    31da:	1808      	adds	r0, r1, r0
		p_ali_light->light_ln_ctrl.get = ali_light_cw_get_lightness;
	}else{//PID_LTN
		p_ali_light->light_ln_ctrl.set = ali_light_ltn_set_lightness;
		p_ali_light->light_ln_ctrl.get = ali_light_ltn_get_lightness;
	}
	tmModel = &p_ali_light->model[p_ali_light->model_cnt++];
    31dc:	701a      	strb	r2, [r3, #0]
	tmModel->offset = 0;//element num
	bc_mm_light_ln_init(tmModel, &p_ali_light->light_ln_ctrl);
    31de:	31ac      	adds	r1, #172	; 0xac
	}else{//PID_LTN
		p_ali_light->light_ln_ctrl.set = ali_light_ltn_set_lightness;
		p_ali_light->light_ln_ctrl.get = ali_light_ltn_get_lightness;
	}
	tmModel = &p_ali_light->model[p_ali_light->model_cnt++];
	tmModel->offset = 0;//element num
    31e0:	7204      	strb	r4, [r0, #8]
		p_ali_light->light_ln_ctrl.get = ali_light_cw_get_lightness;
	}else{//PID_LTN
		p_ali_light->light_ln_ctrl.set = ali_light_ltn_set_lightness;
		p_ali_light->light_ln_ctrl.get = ali_light_ltn_get_lightness;
	}
	tmModel = &p_ali_light->model[p_ali_light->model_cnt++];
    31e2:	3004      	adds	r0, #4
	tmModel->offset = 0;//element num
	bc_mm_light_ln_init(tmModel, &p_ali_light->light_ln_ctrl);
    31e4:	f002 ff5e 	bl	60a4 <bc_mm_light_ln_init>

	p_ali_light->light_ctl_ctrl.ctl_set = ali_light_cw_set_temperature;
    31e8:	4d1e      	ldr	r5, [pc, #120]	; (3264 <ali_light_init+0x164>)
    31ea:	4b28      	ldr	r3, [pc, #160]	; (328c <ali_light_init+0x18c>)
    31ec:	6828      	ldr	r0, [r5, #0]
	p_ali_light->light_ctl_ctrl.ctl_get = ali_light_cw_get_temperature;
    31ee:	4a28      	ldr	r2, [pc, #160]	; (3290 <ali_light_init+0x190>)
	}
	tmModel = &p_ali_light->model[p_ali_light->model_cnt++];
	tmModel->offset = 0;//element num
	bc_mm_light_ln_init(tmModel, &p_ali_light->light_ln_ctrl);

	p_ali_light->light_ctl_ctrl.ctl_set = ali_light_cw_set_temperature;
    31f0:	0001      	movs	r1, r0
    31f2:	31b4      	adds	r1, #180	; 0xb4
    31f4:	600b      	str	r3, [r1, #0]
	p_ali_light->light_ctl_ctrl.ctl_get = ali_light_cw_get_temperature;
    31f6:	0003      	movs	r3, r0
    31f8:	33b8      	adds	r3, #184	; 0xb8
    31fa:	601a      	str	r2, [r3, #0]
	p_ali_light->light_ctl_ctrl.ln_set = ali_light_cw_set_lightness;
    31fc:	4a1f      	ldr	r2, [pc, #124]	; (327c <ali_light_init+0x17c>)
    31fe:	605a      	str	r2, [r3, #4]
	p_ali_light->light_ctl_ctrl.ln_get = ali_light_cw_get_lightness;
    3200:	4a1f      	ldr	r2, [pc, #124]	; (3280 <ali_light_init+0x180>)
    3202:	609a      	str	r2, [r3, #8]
	tmModel = &p_ali_light->model[p_ali_light->model_cnt++];
    3204:	0002      	movs	r2, r0
    3206:	3260      	adds	r2, #96	; 0x60
    3208:	7813      	ldrb	r3, [r2, #0]
    320a:	1c5e      	adds	r6, r3, #1
	tmModel->offset = 0;//element num
    320c:	3306      	adds	r3, #6
    320e:	011b      	lsls	r3, r3, #4
    3210:	18c0      	adds	r0, r0, r3

	p_ali_light->light_ctl_ctrl.ctl_set = ali_light_cw_set_temperature;
	p_ali_light->light_ctl_ctrl.ctl_get = ali_light_cw_get_temperature;
	p_ali_light->light_ctl_ctrl.ln_set = ali_light_cw_set_lightness;
	p_ali_light->light_ctl_ctrl.ln_get = ali_light_cw_get_lightness;
	tmModel = &p_ali_light->model[p_ali_light->model_cnt++];
    3212:	7016      	strb	r6, [r2, #0]
    3214:	3004      	adds	r0, #4
	tmModel->offset = 0;//element num
    3216:	7104      	strb	r4, [r0, #4]
	bc_mm_light_ctl_init(tmModel, &p_ali_light->light_ctl_ctrl);
    3218:	f003 f834 	bl	6284 <bc_mm_light_ctl_init>

	tmModel = &p_ali_light->model[p_ali_light->model_cnt++];
    321c:	682a      	ldr	r2, [r5, #0]
    321e:	0011      	movs	r1, r2
    3220:	3160      	adds	r1, #96	; 0x60
    3222:	780b      	ldrb	r3, [r1, #0]
    3224:	1c58      	adds	r0, r3, #1
    3226:	7008      	strb	r0, [r1, #0]
	tmModel->offset = 0;//element num
    3228:	1d98      	adds	r0, r3, #6
    322a:	0100      	lsls	r0, r0, #4
    322c:	1810      	adds	r0, r2, r0
    322e:	7204      	strb	r4, [r0, #8]
	bc_mm_alis_vendor_init(tmModel, _ali_vendor_rx_cb);
    3230:	4918      	ldr	r1, [pc, #96]	; (3294 <ali_light_init+0x194>)
	p_ali_light->light_ctl_ctrl.ln_get = ali_light_cw_get_lightness;
	tmModel = &p_ali_light->model[p_ali_light->model_cnt++];
	tmModel->offset = 0;//element num
	bc_mm_light_ctl_init(tmModel, &p_ali_light->light_ctl_ctrl);

	tmModel = &p_ali_light->model[p_ali_light->model_cnt++];
    3232:	3004      	adds	r0, #4
	tmModel->offset = 0;//element num
	bc_mm_alis_vendor_init(tmModel, _ali_vendor_rx_cb);
    3234:	f002 fd66 	bl	5d04 <bc_mm_alis_vendor_init>
	
	*mdl = p_ali_light->model;
    3238:	682b      	ldr	r3, [r5, #0]
	*mcnt = p_ali_light->model_cnt;

	_ready_to_indicate(true);
    323a:	2001      	movs	r0, #1

	tmModel = &p_ali_light->model[p_ali_light->model_cnt++];
	tmModel->offset = 0;//element num
	bc_mm_alis_vendor_init(tmModel, _ali_vendor_rx_cb);
	
	*mdl = p_ali_light->model;
    323c:	001a      	movs	r2, r3
    323e:	3264      	adds	r2, #100	; 0x64
    3240:	603a      	str	r2, [r7, #0]
	*mcnt = p_ali_light->model_cnt;
    3242:	3360      	adds	r3, #96	; 0x60
    3244:	781b      	ldrb	r3, [r3, #0]
    3246:	9a03      	ldr	r2, [sp, #12]
    3248:	7013      	strb	r3, [r2, #0]

	_ready_to_indicate(true);
    324a:	f7ff fc89 	bl	2b60 <_ready_to_indicate>

#ifdef FOR_ALI_TEST
	ali_light_key_init();
#endif
	return 0;
}
    324e:	0020      	movs	r0, r4
    3250:	b005      	add	sp, #20
    3252:	bdf0      	pop	{r4, r5, r6, r7, pc}
    3254:	10010514 	.word	0x10010514
    3258:	000201f3 	.word	0x000201f3
    325c:	000200f3 	.word	0x000200f3
    3260:	00020273 	.word	0x00020273
    3264:	10011008 	.word	0x10011008
    3268:	00002e11 	.word	0x00002e11
    326c:	00002ba5 	.word	0x00002ba5
    3270:	00002bc5 	.word	0x00002bc5
    3274:	00002c1d 	.word	0x00002c1d
    3278:	00002c25 	.word	0x00002c25
    327c:	00002bcd 	.word	0x00002bcd
    3280:	00002bed 	.word	0x00002bed
    3284:	00002c2d 	.word	0x00002c2d
    3288:	00002c35 	.word	0x00002c35
    328c:	00002bf5 	.word	0x00002bf5
    3290:	00002c15 	.word	0x00002c15
    3294:	000030d9 	.word	0x000030d9

00003298 <ali_light_deinit>:

uint8_t ali_light_deinit(mesh_model_t** mdl)
{
    3298:	b570      	push	{r4, r5, r6, lr}
	bc_mm_alis_vendor_deinit(&p_ali_light->model[--p_ali_light->model_cnt]);
    329a:	4c20      	ldr	r4, [pc, #128]	; (331c <ali_light_deinit+0x84>)
#endif
	return 0;
}

uint8_t ali_light_deinit(mesh_model_t** mdl)
{
    329c:	0005      	movs	r5, r0
	bc_mm_alis_vendor_deinit(&p_ali_light->model[--p_ali_light->model_cnt]);
    329e:	6822      	ldr	r2, [r4, #0]
    32a0:	0011      	movs	r1, r2
    32a2:	3160      	adds	r1, #96	; 0x60
    32a4:	780b      	ldrb	r3, [r1, #0]
    32a6:	3b01      	subs	r3, #1
    32a8:	b2db      	uxtb	r3, r3
    32aa:	1d98      	adds	r0, r3, #6
    32ac:	0100      	lsls	r0, r0, #4
    32ae:	1810      	adds	r0, r2, r0
    32b0:	700b      	strb	r3, [r1, #0]
    32b2:	3004      	adds	r0, #4
    32b4:	f002 fd48 	bl	5d48 <bc_mm_alis_vendor_deinit>
	bc_mm_light_ctl_deinit(&p_ali_light->model[--p_ali_light->model_cnt]);
    32b8:	6822      	ldr	r2, [r4, #0]
    32ba:	0011      	movs	r1, r2
    32bc:	3160      	adds	r1, #96	; 0x60
    32be:	780b      	ldrb	r3, [r1, #0]
    32c0:	3b01      	subs	r3, #1
    32c2:	b2db      	uxtb	r3, r3
    32c4:	1d98      	adds	r0, r3, #6
    32c6:	0100      	lsls	r0, r0, #4
    32c8:	1810      	adds	r0, r2, r0
    32ca:	700b      	strb	r3, [r1, #0]
    32cc:	3004      	adds	r0, #4
    32ce:	f002 fff1 	bl	62b4 <bc_mm_light_ctl_deinit>
	bc_mm_light_ln_deinit(&p_ali_light->model[--p_ali_light->model_cnt]);
    32d2:	6822      	ldr	r2, [r4, #0]
    32d4:	0011      	movs	r1, r2
    32d6:	3160      	adds	r1, #96	; 0x60
    32d8:	780b      	ldrb	r3, [r1, #0]
    32da:	3b01      	subs	r3, #1
    32dc:	b2db      	uxtb	r3, r3
    32de:	1d98      	adds	r0, r3, #6
    32e0:	0100      	lsls	r0, r0, #4
    32e2:	1810      	adds	r0, r2, r0
    32e4:	700b      	strb	r3, [r1, #0]
    32e6:	3004      	adds	r0, #4
    32e8:	f002 fef4 	bl	60d4 <bc_mm_light_ln_deinit>
	bc_mm_gens_oo_deinit(&p_ali_light->model[--p_ali_light->model_cnt]);
    32ec:	6822      	ldr	r2, [r4, #0]
    32ee:	0011      	movs	r1, r2
    32f0:	3160      	adds	r1, #96	; 0x60
    32f2:	780b      	ldrb	r3, [r1, #0]
    32f4:	3b01      	subs	r3, #1
    32f6:	b2db      	uxtb	r3, r3
    32f8:	1d98      	adds	r0, r3, #6
    32fa:	0100      	lsls	r0, r0, #4
    32fc:	1810      	adds	r0, r2, r0
    32fe:	700b      	strb	r3, [r1, #0]
    3300:	3004      	adds	r0, #4
    3302:	f002 fe27 	bl	5f54 <bc_mm_gens_oo_deinit>
	if(p_ali_light){
    3306:	6820      	ldr	r0, [r4, #0]
    3308:	2800      	cmp	r0, #0
    330a:	d003      	beq.n	3314 <ali_light_deinit+0x7c>
		ke_free(p_ali_light);
    330c:	f003 ffec 	bl	72e8 <ke_free>
		p_ali_light = NULL;
    3310:	2300      	movs	r3, #0
    3312:	6023      	str	r3, [r4, #0]
	}
	*mdl = NULL;
    3314:	2000      	movs	r0, #0
    3316:	6028      	str	r0, [r5, #0]
	return 0;
}
    3318:	bd70      	pop	{r4, r5, r6, pc}
    331a:	46c0      	nop			; (mov r8, r8)
    331c:	10011008 	.word	0x10011008

00003320 <ali_socket_bind_timer_cb>:
#include "bc62xx_gpio.h"

static ali_socket_t* p_ali_socket = NULL;

static void ali_socket_bind_timer_cb(void* param)
{
    3320:	b5f0      	push	{r4, r5, r6, r7, lr}
	uint16_t status;
	if(p_ali_socket->bindStatus == 1){
    3322:	4e65      	ldr	r6, [pc, #404]	; (34b8 <ali_socket_bind_timer_cb+0x198>)
#include "bc62xx_gpio.h"

static ali_socket_t* p_ali_socket = NULL;

static void ali_socket_bind_timer_cb(void* param)
{
    3324:	b089      	sub	sp, #36	; 0x24
	uint16_t status;
	if(p_ali_socket->bindStatus == 1){
    3326:	6834      	ldr	r4, [r6, #0]
    3328:	7863      	ldrb	r3, [r4, #1]
    332a:	2b01      	cmp	r3, #1
    332c:	d100      	bne.n	3330 <ali_socket_bind_timer_cb+0x10>
    332e:	e0c1      	b.n	34b4 <ali_socket_bind_timer_cb+0x194>
		return;
	}
	p_ali_socket->bindStatus = 1;
    3330:	2501      	movs	r5, #1

	p_ali_socket->saveCfgCrc = bc_sys_check_sum((uint8_t*)p_ali_socket, ALI_SOCKET_SAVE_LEN-1);
    3332:	2113      	movs	r1, #19
{
	uint16_t status;
	if(p_ali_socket->bindStatus == 1){
		return;
	}
	p_ali_socket->bindStatus = 1;
    3334:	7065      	strb	r5, [r4, #1]

	p_ali_socket->saveCfgCrc = bc_sys_check_sum((uint8_t*)p_ali_socket, ALI_SOCKET_SAVE_LEN-1);
    3336:	0020      	movs	r0, r4
    3338:	f7ff f9a8 	bl	268c <bc_sys_check_sum>
	bc_flash_erase(FLASH_ALI_START_ADDRRESS, 1);
    333c:	0029      	movs	r1, r5
	if(p_ali_socket->bindStatus == 1){
		return;
	}
	p_ali_socket->bindStatus = 1;

	p_ali_socket->saveCfgCrc = bc_sys_check_sum((uint8_t*)p_ali_socket, ALI_SOCKET_SAVE_LEN-1);
    333e:	74e0      	strb	r0, [r4, #19]
	bc_flash_erase(FLASH_ALI_START_ADDRRESS, 1);
    3340:	2000      	movs	r0, #0
    3342:	f7fe fb51 	bl	19e8 <bc_flash_erase>
	bc_flash_write(FLASH_ALI_START_ADDRRESS, ALI_SOCKET_SAVE_LEN,(uint8_t*)p_ali_socket);
    3346:	6832      	ldr	r2, [r6, #0]
    3348:	2114      	movs	r1, #20
    334a:	2000      	movs	r0, #0
    334c:	f7fe fb8a 	bl	1a64 <bc_flash_write>

	//model bind
	m_lid_t app_key_lid = 0;
    3350:	2000      	movs	r0, #0
    3352:	ab02      	add	r3, sp, #8
    3354:	3516      	adds	r5, #22
    3356:	18ed      	adds	r5, r5, r3
	status = bc_m_key_app_find(0, &app_key_lid);
    3358:	0029      	movs	r1, r5
	p_ali_socket->saveCfgCrc = bc_sys_check_sum((uint8_t*)p_ali_socket, ALI_SOCKET_SAVE_LEN-1);
	bc_flash_erase(FLASH_ALI_START_ADDRRESS, 1);
	bc_flash_write(FLASH_ALI_START_ADDRRESS, ALI_SOCKET_SAVE_LEN,(uint8_t*)p_ali_socket);

	//model bind
	m_lid_t app_key_lid = 0;
    335a:	7028      	strb	r0, [r5, #0]
	status = bc_m_key_app_find(0, &app_key_lid);
    335c:	f005 ffd1 	bl	9302 <bc_m_key_app_find>
    3360:	1e04      	subs	r4, r0, #0
	if (status != M_ERR_NO_ERROR){
    3362:	d028      	beq.n	33b6 <ali_socket_bind_timer_cb+0x96>
		M_PRINTF(L_FND, "m_tb_key_app_find error");
    3364:	4b55      	ldr	r3, [pc, #340]	; (34bc <ali_socket_bind_timer_cb+0x19c>)
    3366:	681b      	ldr	r3, [r3, #0]
    3368:	051b      	lsls	r3, r3, #20
    336a:	d400      	bmi.n	336e <ali_socket_bind_timer_cb+0x4e>
    336c:	e0a2      	b.n	34b4 <ali_socket_bind_timer_cb+0x194>
    336e:	4c54      	ldr	r4, [pc, #336]	; (34c0 <ali_socket_bind_timer_cb+0x1a0>)
    3370:	0023      	movs	r3, r4
    3372:	0022      	movs	r2, r4
    3374:	0020      	movs	r0, r4
    3376:	3342      	adds	r3, #66	; 0x42
    3378:	0021      	movs	r1, r4
    337a:	3226      	adds	r2, #38	; 0x26
    337c:	9300      	str	r3, [sp, #0]
    337e:	3033      	adds	r0, #51	; 0x33
    3380:	231c      	movs	r3, #28
    3382:	f001 fb13 	bl	49ac <m_print>
    3386:	0020      	movs	r0, r4
    3388:	305b      	adds	r0, #91	; 0x5b
    338a:	f001 fb0f 	bl	49ac <m_print>
    338e:	0020      	movs	r0, r4
    3390:	1da1      	adds	r1, r4, #6
    3392:	3073      	adds	r0, #115	; 0x73
    3394:	f001 fb0a 	bl	49ac <m_print>
    3398:	e08c      	b.n	34b4 <ali_socket_bind_timer_cb+0x194>
    339a:	0123      	lsls	r3, r4, #4
    339c:	18ff      	adds	r7, r7, r3
		return;
	}
	for(uint8_t i = 0; i < p_ali_socket->model_cnt; ++i){
		mesh_model_t* t = &p_ali_socket->model[i];
		status = bc_m_key_model_bind(app_key_lid, t->lid);
    339e:	3765      	adds	r7, #101	; 0x65
    33a0:	7839      	ldrb	r1, [r7, #0]
    33a2:	7828      	ldrb	r0, [r5, #0]
    33a4:	f005 ffb5 	bl	9312 <bc_m_key_model_bind>
		if (status == M_ERR_NO_ERROR){
    33a8:	2800      	cmp	r0, #0
    33aa:	d102      	bne.n	33b2 <ali_socket_bind_timer_cb+0x92>
			// Inform the Model IO manager
			bc_m_mio_bind(t->lid);
    33ac:	7838      	ldrb	r0, [r7, #0]
    33ae:	f005 ffac 	bl	930a <bc_m_mio_bind>
	status = bc_m_key_app_find(0, &app_key_lid);
	if (status != M_ERR_NO_ERROR){
		M_PRINTF(L_FND, "m_tb_key_app_find error");
		return;
	}
	for(uint8_t i = 0; i < p_ali_socket->model_cnt; ++i){
    33b2:	3401      	adds	r4, #1
    33b4:	b2e4      	uxtb	r4, r4
    33b6:	6837      	ldr	r7, [r6, #0]
    33b8:	003b      	movs	r3, r7
    33ba:	335c      	adds	r3, #92	; 0x5c
    33bc:	781b      	ldrb	r3, [r3, #0]
    33be:	42a3      	cmp	r3, r4
    33c0:	d8eb      	bhi.n	339a <ali_socket_bind_timer_cb+0x7a>
    33c2:	2700      	movs	r7, #0
	}
	
	//model subscription
	// Add address to the subscription list
	//灯的所有model自行绑定组播地址0xC000，0xCFFF。
	for(uint8_t i = 0; i < p_ali_socket->model_cnt; ++i){
    33c4:	6834      	ldr	r4, [r6, #0]
    33c6:	0023      	movs	r3, r4
    33c8:	335c      	adds	r3, #92	; 0x5c
    33ca:	781b      	ldrb	r3, [r3, #0]
    33cc:	429f      	cmp	r7, r3
    33ce:	d20d      	bcs.n	33ec <ali_socket_bind_timer_cb+0xcc>
    33d0:	013b      	lsls	r3, r7, #4
    33d2:	18e4      	adds	r4, r4, r3
		mesh_model_t* t = &p_ali_socket->model[i];
		//status = bc_m_mio_add_subscription(t->lid, 0xF000);
		bc_m_mio_add_subscription(t->lid, SOCKET_GROUP_ADDR1);
    33d4:	3465      	adds	r4, #101	; 0x65
    33d6:	493b      	ldr	r1, [pc, #236]	; (34c4 <ali_socket_bind_timer_cb+0x1a4>)
    33d8:	7820      	ldrb	r0, [r4, #0]
    33da:	f005 ff9e 	bl	931a <bc_m_mio_add_subscription>
	}
	
	//model subscription
	// Add address to the subscription list
	//灯的所有model自行绑定组播地址0xC000，0xCFFF。
	for(uint8_t i = 0; i < p_ali_socket->model_cnt; ++i){
    33de:	3701      	adds	r7, #1
		mesh_model_t* t = &p_ali_socket->model[i];
		//status = bc_m_mio_add_subscription(t->lid, 0xF000);
		bc_m_mio_add_subscription(t->lid, SOCKET_GROUP_ADDR1);
		bc_m_mio_add_subscription(t->lid, SOCKET_GROUP_ADDR2);
    33e0:	7820      	ldrb	r0, [r4, #0]
    33e2:	4939      	ldr	r1, [pc, #228]	; (34c8 <ali_socket_bind_timer_cb+0x1a8>)
    33e4:	f005 ff99 	bl	931a <bc_m_mio_add_subscription>
	}
	
	//model subscription
	// Add address to the subscription list
	//灯的所有model自行绑定组播地址0xC000，0xCFFF。
	for(uint8_t i = 0; i < p_ali_socket->model_cnt; ++i){
    33e8:	b2ff      	uxtb	r7, r7
    33ea:	e7eb      	b.n	33c4 <ali_socket_bind_timer_cb+0xa4>
		bc_m_mio_add_subscription(t->lid, SOCKET_GROUP_ADDR2);
		
	}

	mesh_model_t* t = &p_ali_socket->model[p_ali_socket->model_cnt-1];
	bc_m_mio_add_subscription(t->lid, M_ALI_VENDER_ADDR);
    33ec:	21f0      	movs	r1, #240	; 0xf0
    33ee:	011b      	lsls	r3, r3, #4
    33f0:	18e4      	adds	r4, r4, r3
    33f2:	3455      	adds	r4, #85	; 0x55
    33f4:	0209      	lsls	r1, r1, #8
    33f6:	7820      	ldrb	r0, [r4, #0]
    33f8:	f005 ff8f 	bl	931a <bc_m_mio_add_subscription>

	// Set publication parameters
    status = bc_m_mio_set_publi_param(t->lid, M_ALI_VENDER_ADDR, NULL,
    33fc:	2182      	movs	r1, #130	; 0x82
    33fe:	782b      	ldrb	r3, [r5, #0]
    3400:	7820      	ldrb	r0, [r4, #0]
    3402:	9102      	str	r1, [sp, #8]
    3404:	395a      	subs	r1, #90	; 0x5a
    3406:	9101      	str	r1, [sp, #4]
    3408:	3922      	subs	r1, #34	; 0x22
    340a:	2200      	movs	r2, #0
    340c:	9100      	str	r1, [sp, #0]
    340e:	21f0      	movs	r1, #240	; 0xf0
    3410:	9203      	str	r2, [sp, #12]
    3412:	0209      	lsls	r1, r1, #8
    3414:	f005 ff85 	bl	9322 <bc_m_mio_set_publi_param>
                                      app_key_lid, M_ALI_PUBLISH_TTL, M_ALI_PUBLISH_PERIOD,
                                      M_ALI_PUBLISH_RETX, 0);
	M_PRINTF(L_APP, "status[%x]", status);
    3418:	4d28      	ldr	r5, [pc, #160]	; (34bc <ali_socket_bind_timer_cb+0x19c>)

	mesh_model_t* t = &p_ali_socket->model[p_ali_socket->model_cnt-1];
	bc_m_mio_add_subscription(t->lid, M_ALI_VENDER_ADDR);

	// Set publication parameters
    status = bc_m_mio_set_publi_param(t->lid, M_ALI_VENDER_ADDR, NULL,
    341a:	0006      	movs	r6, r0
                                      app_key_lid, M_ALI_PUBLISH_TTL, M_ALI_PUBLISH_PERIOD,
                                      M_ALI_PUBLISH_RETX, 0);
	M_PRINTF(L_APP, "status[%x]", status);
    341c:	682b      	ldr	r3, [r5, #0]
    341e:	049b      	lsls	r3, r3, #18
    3420:	d515      	bpl.n	344e <ali_socket_bind_timer_cb+0x12e>
    3422:	4c27      	ldr	r4, [pc, #156]	; (34c0 <ali_socket_bind_timer_cb+0x1a0>)
    3424:	0023      	movs	r3, r4
    3426:	0022      	movs	r2, r4
    3428:	0020      	movs	r0, r4
    342a:	3342      	adds	r3, #66	; 0x42
    342c:	3226      	adds	r2, #38	; 0x26
    342e:	9300      	str	r3, [sp, #0]
    3430:	0021      	movs	r1, r4
    3432:	233a      	movs	r3, #58	; 0x3a
    3434:	3033      	adds	r0, #51	; 0x33
    3436:	f001 fab9 	bl	49ac <m_print>
    343a:	0020      	movs	r0, r4
    343c:	0031      	movs	r1, r6
    343e:	3076      	adds	r0, #118	; 0x76
    3440:	f001 fab4 	bl	49ac <m_print>
    3444:	0020      	movs	r0, r4
    3446:	1da1      	adds	r1, r4, #6
    3448:	3073      	adds	r0, #115	; 0x73
    344a:	f001 faaf 	bl	49ac <m_print>


	uint8_t i = 6;
	uint32_t tTime = mesh_timer_get_time();
    344e:	f002 ff6d 	bl	632c <mesh_timer_get_time>
                                      app_key_lid, M_ALI_PUBLISH_TTL, M_ALI_PUBLISH_PERIOD,
                                      M_ALI_PUBLISH_RETX, 0);
	M_PRINTF(L_APP, "status[%x]", status);


	uint8_t i = 6;
    3452:	2606      	movs	r6, #6
	uint32_t tTime = mesh_timer_get_time();
    3454:	9005      	str	r0, [sp, #20]
	do{
		while(mesh_timer_get_time()-tTime < SOCKET_LED_INTERVAL){//delay 1s
    3456:	f002 ff69 	bl	632c <mesh_timer_get_time>
    345a:	9b05      	ldr	r3, [sp, #20]
    345c:	1ac0      	subs	r0, r0, r3
    345e:	23f4      	movs	r3, #244	; 0xf4
    3460:	33ff      	adds	r3, #255	; 0xff
    3462:	4298      	cmp	r0, r3
    3464:	d9f7      	bls.n	3456 <ali_socket_bind_timer_cb+0x136>
			continue;
		}
		tTime = mesh_timer_get_time();
		ali_socket_ind_status_set(i%2);
    3466:	2701      	movs	r7, #1
	uint32_t tTime = mesh_timer_get_time();
	do{
		while(mesh_timer_get_time()-tTime < SOCKET_LED_INTERVAL){//delay 1s
			continue;
		}
		tTime = mesh_timer_get_time();
    3468:	f002 ff60 	bl	632c <mesh_timer_get_time>
		ali_socket_ind_status_set(i%2);
    346c:	4037      	ands	r7, r6
	uint32_t tTime = mesh_timer_get_time();
	do{
		while(mesh_timer_get_time()-tTime < SOCKET_LED_INTERVAL){//delay 1s
			continue;
		}
		tTime = mesh_timer_get_time();
    346e:	9005      	str	r0, [sp, #20]
		ali_socket_ind_status_set(i%2);
    3470:	0038      	movs	r0, r7
    3472:	f000 fa2d 	bl	38d0 <ali_socket_ind_status_set>
		//flash indicator led
		M_PRINTF(L_APP, "led status = %d", i%2);
    3476:	2280      	movs	r2, #128	; 0x80
    3478:	682b      	ldr	r3, [r5, #0]
    347a:	0192      	lsls	r2, r2, #6
    347c:	4213      	tst	r3, r2
    347e:	d015      	beq.n	34ac <ali_socket_bind_timer_cb+0x18c>
    3480:	4c0f      	ldr	r4, [pc, #60]	; (34c0 <ali_socket_bind_timer_cb+0x1a0>)
    3482:	0023      	movs	r3, r4
    3484:	0022      	movs	r2, r4
    3486:	0020      	movs	r0, r4
    3488:	3342      	adds	r3, #66	; 0x42
    348a:	3226      	adds	r2, #38	; 0x26
    348c:	9300      	str	r3, [sp, #0]
    348e:	0021      	movs	r1, r4
    3490:	2346      	movs	r3, #70	; 0x46
    3492:	3033      	adds	r0, #51	; 0x33
    3494:	f001 fa8a 	bl	49ac <m_print>
    3498:	480c      	ldr	r0, [pc, #48]	; (34cc <ali_socket_bind_timer_cb+0x1ac>)
    349a:	0039      	movs	r1, r7
    349c:	3001      	adds	r0, #1
    349e:	f001 fa85 	bl	49ac <m_print>
    34a2:	0020      	movs	r0, r4
    34a4:	1da1      	adds	r1, r4, #6
    34a6:	3073      	adds	r0, #115	; 0x73
    34a8:	f001 fa80 	bl	49ac <m_print>
	}while(i-->0);
    34ac:	1e73      	subs	r3, r6, #1
    34ae:	b2de      	uxtb	r6, r3
    34b0:	2eff      	cmp	r6, #255	; 0xff
    34b2:	d1d0      	bne.n	3456 <ali_socket_bind_timer_cb+0x136>
}
    34b4:	b009      	add	sp, #36	; 0x24
    34b6:	bdf0      	pop	{r4, r5, r6, r7, pc}
    34b8:	10011010 	.word	0x10011010
    34bc:	10010514 	.word	0x10010514
    34c0:	00020290 	.word	0x00020290
    34c4:	0000c002 	.word	0x0000c002
    34c8:	0000cfff 	.word	0x0000cfff
    34cc:	00020310 	.word	0x00020310

000034d0 <ali_socket_btn_get_timer_cb>:

static void ali_socket_btn_get_timer_cb(void* param)
{
    34d0:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	SYS_SetTimer(&p_ali_socket->btnGetTimer, (int)SOCKET_BTN_INTERVAL/10, 
    34d2:	4d1f      	ldr	r5, [pc, #124]	; (3550 <ali_socket_btn_get_timer_cb+0x80>)
    34d4:	4b1f      	ldr	r3, [pc, #124]	; (3554 <ali_socket_btn_get_timer_cb+0x84>)
    34d6:	6828      	ldr	r0, [r5, #0]
    34d8:	2200      	movs	r2, #0
    34da:	2114      	movs	r1, #20
    34dc:	3014      	adds	r0, #20
    34de:	f7fe fc37 	bl	1d50 <SYS_SetTimer>
					TIMER_SINGLE, (Timer_Expire_CB)ali_socket_btn_get_timer_cb);
	uint8_t val;
	//read btn pin level
	val = ali_socket_key_get();
    34e2:	f000 fa97 	bl	3a14 <ali_socket_key_get>
	M_PRINTF(L_APP, "val[%x]", val);
    34e6:	4b1c      	ldr	r3, [pc, #112]	; (3558 <ali_socket_btn_get_timer_cb+0x88>)
{
	SYS_SetTimer(&p_ali_socket->btnGetTimer, (int)SOCKET_BTN_INTERVAL/10, 
					TIMER_SINGLE, (Timer_Expire_CB)ali_socket_btn_get_timer_cb);
	uint8_t val;
	//read btn pin level
	val = ali_socket_key_get();
    34e8:	0006      	movs	r6, r0
	M_PRINTF(L_APP, "val[%x]", val);
    34ea:	681b      	ldr	r3, [r3, #0]
    34ec:	049b      	lsls	r3, r3, #18
    34ee:	d516      	bpl.n	351e <ali_socket_btn_get_timer_cb+0x4e>
    34f0:	4f1a      	ldr	r7, [pc, #104]	; (355c <ali_socket_btn_get_timer_cb+0x8c>)
    34f2:	4c1b      	ldr	r4, [pc, #108]	; (3560 <ali_socket_btn_get_timer_cb+0x90>)
    34f4:	003b      	movs	r3, r7
    34f6:	0022      	movs	r2, r4
    34f8:	0020      	movs	r0, r4
    34fa:	3311      	adds	r3, #17
    34fc:	3226      	adds	r2, #38	; 0x26
    34fe:	9300      	str	r3, [sp, #0]
    3500:	0021      	movs	r1, r4
    3502:	2351      	movs	r3, #81	; 0x51
    3504:	3033      	adds	r0, #51	; 0x33
    3506:	f001 fa51 	bl	49ac <m_print>
    350a:	0038      	movs	r0, r7
    350c:	0031      	movs	r1, r6
    350e:	302d      	adds	r0, #45	; 0x2d
    3510:	f001 fa4c 	bl	49ac <m_print>
    3514:	0020      	movs	r0, r4
    3516:	1da1      	adds	r1, r4, #6
    3518:	3073      	adds	r0, #115	; 0x73
    351a:	f001 fa47 	bl	49ac <m_print>
	if(val == 1){
    351e:	2e01      	cmp	r6, #1
    3520:	d10c      	bne.n	353c <ali_socket_btn_get_timer_cb+0x6c>
		if(p_ali_socket->btnPressedCnt > SOCKET_SWITH_TIME_CNT
    3522:	682b      	ldr	r3, [r5, #0]
    3524:	3304      	adds	r3, #4
    3526:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
    3528:	3b02      	subs	r3, #2
    352a:	2b16      	cmp	r3, #22
    352c:	d801      	bhi.n	3532 <ali_socket_btn_get_timer_cb+0x62>
			&& p_ali_socket->btnPressedCnt < SOCKET_RESET_TIME_CNT){
			ali_socket_elec_relay_reverse();
    352e:	f000 fa49 	bl	39c4 <ali_socket_elec_relay_reverse>
		}
		p_ali_socket->btnPressedCnt = 0;
    3532:	2200      	movs	r2, #0
    3534:	682b      	ldr	r3, [r5, #0]
    3536:	3304      	adds	r3, #4
    3538:	67da      	str	r2, [r3, #124]	; 0x7c
    353a:	e008      	b.n	354e <ali_socket_btn_get_timer_cb+0x7e>
		return ;
	}
	p_ali_socket->btnPressedCnt++;
    353c:	682a      	ldr	r2, [r5, #0]
    353e:	3204      	adds	r2, #4
    3540:	6fd3      	ldr	r3, [r2, #124]	; 0x7c
    3542:	3301      	adds	r3, #1
    3544:	67d3      	str	r3, [r2, #124]	; 0x7c

	//check pressed time greater than SOCKET_RESET_TIME_CNT
	if(p_ali_socket->btnPressedCnt >= SOCKET_RESET_TIME_CNT){
    3546:	2b18      	cmp	r3, #24
    3548:	d901      	bls.n	354e <ali_socket_btn_get_timer_cb+0x7e>
		//do reset function
		ali_socket_factory_reset();
    354a:	f000 f877 	bl	363c <ali_socket_factory_reset>
	}
}
    354e:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
    3550:	10011010 	.word	0x10011010
    3554:	000034d1 	.word	0x000034d1
    3558:	10010514 	.word	0x10010514
    355c:	00020310 	.word	0x00020310
    3560:	00020290 	.word	0x00020290

00003564 <ali_socket_ind_sts_timer_cb>:

static void ali_socket_ind_sts_timer_cb(void* param)
{
    3564:	b537      	push	{r0, r1, r2, r4, r5, lr}
	//reset timer
	SYS_SetTimer(&p_ali_socket->btnGetTimer, M_ALIS_INDICATION_PERIOD/10, 
    3566:	4c11      	ldr	r4, [pc, #68]	; (35ac <ali_socket_ind_sts_timer_cb+0x48>)
    3568:	2200      	movs	r2, #0
    356a:	6820      	ldr	r0, [r4, #0]
    356c:	4910      	ldr	r1, [pc, #64]	; (35b0 <ali_socket_ind_sts_timer_cb+0x4c>)
    356e:	4b11      	ldr	r3, [pc, #68]	; (35b4 <ali_socket_ind_sts_timer_cb+0x50>)
    3570:	3014      	adds	r0, #20
    3572:	f7fe fbed 	bl	1d50 <SYS_SetTimer>
					TIMER_SINGLE, (Timer_Expire_CB)ali_socket_ind_sts_timer_cb);

	//send indicate
	uint8_t data[3];
	int len = 0;
	len += bc_mm_alis_set_onoff_status(&data[0]+len, p_ali_socket->oo_ctrl.get());
    3576:	6823      	ldr	r3, [r4, #0]
    3578:	3388      	adds	r3, #136	; 0x88
    357a:	681b      	ldr	r3, [r3, #0]
    357c:	4798      	blx	r3
    357e:	1e41      	subs	r1, r0, #1
    3580:	4188      	sbcs	r0, r1
    3582:	b2c1      	uxtb	r1, r0
    3584:	a801      	add	r0, sp, #4
    3586:	f002 fa13 	bl	59b0 <bc_mm_alis_set_onoff_status>
    358a:	0005      	movs	r5, r0
	m_printf_hex(L_APP, "ali_socket_ind_sts_timer_cb", data, len);
    358c:	0003      	movs	r3, r0
    358e:	2080      	movs	r0, #128	; 0x80
    3590:	4909      	ldr	r1, [pc, #36]	; (35b8 <ali_socket_ind_sts_timer_cb+0x54>)
    3592:	aa01      	add	r2, sp, #4
    3594:	3135      	adds	r1, #53	; 0x35
    3596:	0180      	lsls	r0, r0, #6
    3598:	f001 fa68 	bl	4a6c <m_printf_hex>
	bc_mm_alis_send_indication(p_ali_socket->model[1].lid, data, len);
    359c:	6823      	ldr	r3, [r4, #0]
    359e:	002a      	movs	r2, r5
    35a0:	3375      	adds	r3, #117	; 0x75
    35a2:	7818      	ldrb	r0, [r3, #0]
    35a4:	a901      	add	r1, sp, #4
    35a6:	f002 fab9 	bl	5b1c <bc_mm_alis_send_indication>
}
    35aa:	bd37      	pop	{r0, r1, r2, r4, r5, pc}
    35ac:	10011010 	.word	0x10011010
    35b0:	00004650 	.word	0x00004650
    35b4:	00003565 	.word	0x00003565
    35b8:	00020310 	.word	0x00020310

000035bc <ali_socket_prov_state_cb>:

void ali_socket_prov_state_cb(uint8_t state)
{
    35bc:	b510      	push	{r4, lr}
	if(state == M_PROV_STARTED){
    35be:	2800      	cmp	r0, #0
    35c0:	d103      	bne.n	35ca <ali_socket_prov_state_cb+0xe>
		//open indicate led
		ali_socket_ind_status_set(1);
    35c2:	3001      	adds	r0, #1
    35c4:	f000 f984 	bl	38d0 <ali_socket_ind_status_set>
    35c8:	e009      	b.n	35de <ali_socket_prov_state_cb+0x22>
		//start 10 minutes timer to switch static adv
		
	}
#ifdef APP_FOR_ALI
	if(state == M_PROV_SUCCEED_APP){
    35ca:	2803      	cmp	r0, #3
    35cc:	d107      	bne.n	35de <ali_socket_prov_state_cb+0x22>
		//flash indicate led 3 times
		
		SYS_SetTimer(&p_ali_socket->bindDelayTimer, (int)500/10, 
    35ce:	4b04      	ldr	r3, [pc, #16]	; (35e0 <ali_socket_prov_state_cb+0x24>)
    35d0:	2200      	movs	r2, #0
    35d2:	6818      	ldr	r0, [r3, #0]
    35d4:	2132      	movs	r1, #50	; 0x32
    35d6:	302c      	adds	r0, #44	; 0x2c
    35d8:	4b02      	ldr	r3, [pc, #8]	; (35e4 <ali_socket_prov_state_cb+0x28>)
    35da:	f7fe fbb9 	bl	1d50 <SYS_SetTimer>
					TIMER_SINGLE, (Timer_Expire_CB)ali_socket_bind_timer_cb);
		return;
	}
#endif 
}
    35de:	bd10      	pop	{r4, pc}
    35e0:	10011010 	.word	0x10011010
    35e4:	00003321 	.word	0x00003321

000035e8 <ali_socket_prov_state_get>:

uint8_t ali_socket_prov_state_get(void)
{
	M_PRINTF(L_APP, "bound satus[%d]", p_ali_socket->bindStatus);
    35e8:	4b10      	ldr	r3, [pc, #64]	; (362c <ali_socket_prov_state_get+0x44>)
	}
#endif 
}

uint8_t ali_socket_prov_state_get(void)
{
    35ea:	b573      	push	{r0, r1, r4, r5, r6, lr}
	M_PRINTF(L_APP, "bound satus[%d]", p_ali_socket->bindStatus);
    35ec:	681b      	ldr	r3, [r3, #0]
    35ee:	4e10      	ldr	r6, [pc, #64]	; (3630 <ali_socket_prov_state_get+0x48>)
    35f0:	049b      	lsls	r3, r3, #18
    35f2:	d517      	bpl.n	3624 <ali_socket_prov_state_get+0x3c>
    35f4:	4d0f      	ldr	r5, [pc, #60]	; (3634 <ali_socket_prov_state_get+0x4c>)
    35f6:	4c10      	ldr	r4, [pc, #64]	; (3638 <ali_socket_prov_state_get+0x50>)
    35f8:	002b      	movs	r3, r5
    35fa:	0022      	movs	r2, r4
    35fc:	0020      	movs	r0, r4
    35fe:	3351      	adds	r3, #81	; 0x51
    3600:	3226      	adds	r2, #38	; 0x26
    3602:	9300      	str	r3, [sp, #0]
    3604:	0021      	movs	r1, r4
    3606:	2386      	movs	r3, #134	; 0x86
    3608:	3033      	adds	r0, #51	; 0x33
    360a:	f001 f9cf 	bl	49ac <m_print>
    360e:	0028      	movs	r0, r5
    3610:	6833      	ldr	r3, [r6, #0]
    3612:	306b      	adds	r0, #107	; 0x6b
    3614:	7859      	ldrb	r1, [r3, #1]
    3616:	f001 f9c9 	bl	49ac <m_print>
    361a:	0020      	movs	r0, r4
    361c:	1da1      	adds	r1, r4, #6
    361e:	3073      	adds	r0, #115	; 0x73
    3620:	f001 f9c4 	bl	49ac <m_print>
	return p_ali_socket->bindStatus;
    3624:	6833      	ldr	r3, [r6, #0]
    3626:	7858      	ldrb	r0, [r3, #1]
}
    3628:	bd76      	pop	{r1, r2, r4, r5, r6, pc}
    362a:	46c0      	nop			; (mov r8, r8)
    362c:	10010514 	.word	0x10010514
    3630:	10011010 	.word	0x10011010
    3634:	00020310 	.word	0x00020310
    3638:	00020290 	.word	0x00020290

0000363c <ali_socket_factory_reset>:

void ali_socket_factory_reset()
{
    363c:	b5f0      	push	{r4, r5, r6, r7, lr}
    363e:	b085      	sub	sp, #20
	bc_m_clear_config();
    3640:	f005 fe45 	bl	92ce <bc_m_clear_config>
	bc_flash_erase(FLASH_ALI_START_ADDRRESS, 1);
    3644:	2101      	movs	r1, #1
    3646:	2000      	movs	r0, #0
    3648:	f7fe f9ce 	bl	19e8 <bc_flash_erase>
	uint8_t i = 10;
	uint32_t t = mesh_timer_get_time();
    364c:	f002 fe6e 	bl	632c <mesh_timer_get_time>

void ali_socket_factory_reset()
{
	bc_m_clear_config();
	bc_flash_erase(FLASH_ALI_START_ADDRRESS, 1);
	uint8_t i = 10;
    3650:	250a      	movs	r5, #10
	uint32_t t = mesh_timer_get_time();
    3652:	0007      	movs	r7, r0
	do{
		while(mesh_timer_get_time()-t < SOCKET_LED_INTERVAL){//delay 1s
    3654:	f002 fe6a 	bl	632c <mesh_timer_get_time>
    3658:	23f4      	movs	r3, #244	; 0xf4
    365a:	33ff      	adds	r3, #255	; 0xff
    365c:	1bc0      	subs	r0, r0, r7
    365e:	4298      	cmp	r0, r3
    3660:	d9f8      	bls.n	3654 <ali_socket_factory_reset+0x18>
			continue;
		}
		t = mesh_timer_get_time();
    3662:	f002 fe63 	bl	632c <mesh_timer_get_time>
		ali_socket_ind_status_set(i%2);
    3666:	2301      	movs	r3, #1
    3668:	402b      	ands	r3, r5
	uint32_t t = mesh_timer_get_time();
	do{
		while(mesh_timer_get_time()-t < SOCKET_LED_INTERVAL){//delay 1s
			continue;
		}
		t = mesh_timer_get_time();
    366a:	0007      	movs	r7, r0
		ali_socket_ind_status_set(i%2);
    366c:	0018      	movs	r0, r3
    366e:	9303      	str	r3, [sp, #12]
    3670:	f000 f92e 	bl	38d0 <ali_socket_ind_status_set>
		//flash indicator led
		M_PRINTF(L_APP, "led status = %d", i%2);
    3674:	2280      	movs	r2, #128	; 0x80
    3676:	4b12      	ldr	r3, [pc, #72]	; (36c0 <ali_socket_factory_reset+0x84>)
    3678:	0192      	lsls	r2, r2, #6
    367a:	681b      	ldr	r3, [r3, #0]
    367c:	4213      	tst	r3, r2
    367e:	d015      	beq.n	36ac <ali_socket_factory_reset+0x70>
    3680:	4e10      	ldr	r6, [pc, #64]	; (36c4 <ali_socket_factory_reset+0x88>)
    3682:	4c11      	ldr	r4, [pc, #68]	; (36c8 <ali_socket_factory_reset+0x8c>)
    3684:	0033      	movs	r3, r6
    3686:	0022      	movs	r2, r4
    3688:	0020      	movs	r0, r4
    368a:	337b      	adds	r3, #123	; 0x7b
    368c:	3226      	adds	r2, #38	; 0x26
    368e:	9300      	str	r3, [sp, #0]
    3690:	0021      	movs	r1, r4
    3692:	2397      	movs	r3, #151	; 0x97
    3694:	3033      	adds	r0, #51	; 0x33
    3696:	f001 f989 	bl	49ac <m_print>
    369a:	9903      	ldr	r1, [sp, #12]
    369c:	1c70      	adds	r0, r6, #1
    369e:	f001 f985 	bl	49ac <m_print>
    36a2:	0020      	movs	r0, r4
    36a4:	1da1      	adds	r1, r4, #6
    36a6:	3073      	adds	r0, #115	; 0x73
    36a8:	f001 f980 	bl	49ac <m_print>
	}while(i-->0);
    36ac:	1e6b      	subs	r3, r5, #1
    36ae:	b2db      	uxtb	r3, r3
    36b0:	2d00      	cmp	r5, #0
    36b2:	d001      	beq.n	36b8 <ali_socket_factory_reset+0x7c>
    36b4:	001d      	movs	r5, r3
    36b6:	e7cd      	b.n	3654 <ali_socket_factory_reset+0x18>
	bc_sys_reset();
    36b8:	f7fe ffe0 	bl	267c <bc_sys_reset>
}
    36bc:	b005      	add	sp, #20
    36be:	bdf0      	pop	{r4, r5, r6, r7, pc}
    36c0:	10010514 	.word	0x10010514
    36c4:	00020310 	.word	0x00020310
    36c8:	00020290 	.word	0x00020290

000036cc <ali_socket_init>:

uint8_t ali_socket_init(mesh_model_t** mdl, uint8_t* mcnt)
{
    36cc:	b5f0      	push	{r4, r5, r6, r7, lr}
    36ce:	b085      	sub	sp, #20
    36d0:	9103      	str	r1, [sp, #12]
    36d2:	0007      	movs	r7, r0
	p_ali_socket = ke_malloc(sizeof(ali_socket_t), 0);
    36d4:	2100      	movs	r1, #0
    36d6:	208c      	movs	r0, #140	; 0x8c
    36d8:	f003 fe02 	bl	72e0 <ke_malloc>
    36dc:	4c60      	ldr	r4, [pc, #384]	; (3860 <ali_socket_init+0x194>)
    36de:	0005      	movs	r5, r0
    36e0:	6020      	str	r0, [r4, #0]
	if(p_ali_socket == NULL)
		return 1;
    36e2:	2001      	movs	r0, #1
}

uint8_t ali_socket_init(mesh_model_t** mdl, uint8_t* mcnt)
{
	p_ali_socket = ke_malloc(sizeof(ali_socket_t), 0);
	if(p_ali_socket == NULL)
    36e4:	2d00      	cmp	r5, #0
    36e6:	d100      	bne.n	36ea <ali_socket_init+0x1e>
    36e8:	e0b7      	b.n	385a <ali_socket_init+0x18e>
		return 1;
	memset(p_ali_socket, 0, sizeof(ali_socket_t));
    36ea:	228c      	movs	r2, #140	; 0x8c
    36ec:	2100      	movs	r1, #0
    36ee:	0028      	movs	r0, r5
    36f0:	f012 f9ac 	bl	15a4c <memset>
	
	//read saved parameter
	bc_flash_read(FLASH_ALI_START_ADDRRESS, ALI_SOCKET_SAVE_LEN,(uint8_t*)p_ali_socket);
    36f4:	002a      	movs	r2, r5
    36f6:	2114      	movs	r1, #20
    36f8:	2000      	movs	r0, #0
    36fa:	f7fe f995 	bl	1a28 <bc_flash_read>
	uint8_t tCrc = bc_sys_check_sum((uint8_t*)p_ali_socket, ALI_SOCKET_SAVE_LEN-1);
    36fe:	2113      	movs	r1, #19
    3700:	6820      	ldr	r0, [r4, #0]
    3702:	f7fe ffc3 	bl	268c <bc_sys_check_sum>
	if(p_ali_socket->saveCfgCrc != tCrc){
    3706:	6825      	ldr	r5, [r4, #0]
    3708:	7ceb      	ldrb	r3, [r5, #19]
    370a:	4283      	cmp	r3, r0
    370c:	d004      	beq.n	3718 <ali_socket_init+0x4c>
		memset((uint8_t*)p_ali_socket, 0, ALI_SOCKET_SAVE_LEN);
    370e:	2214      	movs	r2, #20
    3710:	2100      	movs	r1, #0
    3712:	0028      	movs	r0, r5
    3714:	f012 f99a 	bl	15a4c <memset>
	}

	if(p_ali_socket->dType != ali_config_device_type_get()){//change device type
    3718:	78ad      	ldrb	r5, [r5, #2]
    371a:	f000 fd53 	bl	41c4 <ali_config_device_type_get>
    371e:	4285      	cmp	r5, r0
    3720:	d03a      	beq.n	3798 <ali_socket_init+0xcc>
		M_PRINTF(L_APP, "device type is changed [%d] to [%d]", p_ali_socket->dType, ali_config_device_type_get());
    3722:	4b50      	ldr	r3, [pc, #320]	; (3864 <ali_socket_init+0x198>)
    3724:	681b      	ldr	r3, [r3, #0]
    3726:	049b      	lsls	r3, r3, #18
    3728:	d51c      	bpl.n	3764 <ali_socket_init+0x98>
    372a:	4e4f      	ldr	r6, [pc, #316]	; (3868 <ali_socket_init+0x19c>)
    372c:	4d4f      	ldr	r5, [pc, #316]	; (386c <ali_socket_init+0x1a0>)
    372e:	0033      	movs	r3, r6
    3730:	002a      	movs	r2, r5
    3732:	0028      	movs	r0, r5
    3734:	3314      	adds	r3, #20
    3736:	3226      	adds	r2, #38	; 0x26
    3738:	0029      	movs	r1, r5
    373a:	9300      	str	r3, [sp, #0]
    373c:	3033      	adds	r0, #51	; 0x33
    373e:	23ab      	movs	r3, #171	; 0xab
    3740:	f001 f934 	bl	49ac <m_print>
    3744:	6823      	ldr	r3, [r4, #0]
    3746:	789b      	ldrb	r3, [r3, #2]
    3748:	9302      	str	r3, [sp, #8]
    374a:	f000 fd3b 	bl	41c4 <ali_config_device_type_get>
    374e:	0002      	movs	r2, r0
    3750:	0030      	movs	r0, r6
    3752:	9902      	ldr	r1, [sp, #8]
    3754:	3024      	adds	r0, #36	; 0x24
    3756:	f001 f929 	bl	49ac <m_print>
    375a:	0028      	movs	r0, r5
    375c:	1da9      	adds	r1, r5, #6
    375e:	3073      	adds	r0, #115	; 0x73
    3760:	f001 f924 	bl	49ac <m_print>
		bc_m_clear_config();
    3764:	f005 fdb3 	bl	92ce <bc_m_clear_config>
		memset((uint8_t*)p_ali_socket, 0,  ALI_SOCKET_SAVE_LEN);
    3768:	6825      	ldr	r5, [r4, #0]
    376a:	2214      	movs	r2, #20
    376c:	2100      	movs	r1, #0
    376e:	0028      	movs	r0, r5
    3770:	f012 f96c 	bl	15a4c <memset>
		p_ali_socket->dType = ali_config_device_type_get();
    3774:	f000 fd26 	bl	41c4 <ali_config_device_type_get>
    3778:	70a8      	strb	r0, [r5, #2]
		p_ali_socket->saveCfgCrc = bc_sys_check_sum((uint8_t*)p_ali_socket, ALI_SOCKET_SAVE_LEN-1);
    377a:	6825      	ldr	r5, [r4, #0]
    377c:	2113      	movs	r1, #19
    377e:	0028      	movs	r0, r5
    3780:	f7fe ff84 	bl	268c <bc_sys_check_sum>
		bc_flash_erase(FLASH_ALI_START_ADDRRESS, 1);
    3784:	2101      	movs	r1, #1
	if(p_ali_socket->dType != ali_config_device_type_get()){//change device type
		M_PRINTF(L_APP, "device type is changed [%d] to [%d]", p_ali_socket->dType, ali_config_device_type_get());
		bc_m_clear_config();
		memset((uint8_t*)p_ali_socket, 0,  ALI_SOCKET_SAVE_LEN);
		p_ali_socket->dType = ali_config_device_type_get();
		p_ali_socket->saveCfgCrc = bc_sys_check_sum((uint8_t*)p_ali_socket, ALI_SOCKET_SAVE_LEN-1);
    3786:	74e8      	strb	r0, [r5, #19]
		bc_flash_erase(FLASH_ALI_START_ADDRRESS, 1);
    3788:	2000      	movs	r0, #0
    378a:	f7fe f92d 	bl	19e8 <bc_flash_erase>
		bc_flash_write(FLASH_ALI_START_ADDRRESS, ALI_SOCKET_SAVE_LEN,(uint8_t*)p_ali_socket);
    378e:	6822      	ldr	r2, [r4, #0]
    3790:	2114      	movs	r1, #20
    3792:	2000      	movs	r0, #0
    3794:	f7fe f966 	bl	1a64 <bc_flash_write>
	}
	
	M_PRINTF(L_APP, "p_ali_socket[%p] eRelayS[%p]", p_ali_socket, &p_ali_socket->eRelayS);
    3798:	4b32      	ldr	r3, [pc, #200]	; (3864 <ali_socket_init+0x198>)
    379a:	681b      	ldr	r3, [r3, #0]
    379c:	049b      	lsls	r3, r3, #18
    379e:	d517      	bpl.n	37d0 <ali_socket_init+0x104>
    37a0:	4e31      	ldr	r6, [pc, #196]	; (3868 <ali_socket_init+0x19c>)
    37a2:	4d32      	ldr	r5, [pc, #200]	; (386c <ali_socket_init+0x1a0>)
    37a4:	0033      	movs	r3, r6
    37a6:	002a      	movs	r2, r5
    37a8:	0028      	movs	r0, r5
    37aa:	3314      	adds	r3, #20
    37ac:	3226      	adds	r2, #38	; 0x26
    37ae:	9300      	str	r3, [sp, #0]
    37b0:	0029      	movs	r1, r5
    37b2:	23b4      	movs	r3, #180	; 0xb4
    37b4:	3033      	adds	r0, #51	; 0x33
    37b6:	f001 f8f9 	bl	49ac <m_print>
    37ba:	0030      	movs	r0, r6
    37bc:	6822      	ldr	r2, [r4, #0]
    37be:	3048      	adds	r0, #72	; 0x48
    37c0:	0011      	movs	r1, r2
    37c2:	f001 f8f3 	bl	49ac <m_print>
    37c6:	0028      	movs	r0, r5
    37c8:	1da9      	adds	r1, r5, #6
    37ca:	3073      	adds	r0, #115	; 0x73
    37cc:	f001 f8ee 	bl	49ac <m_print>
	//control socket 
	ali_socket_elec_relay_init();
    37d0:	f000 f90a 	bl	39e8 <ali_socket_elec_relay_init>

	//key init
	ali_socket_key_init();
    37d4:	f000 f916 	bl	3a04 <ali_socket_key_init>
		
	//start timer for clear

	//start timer for button press;
	SYS_SetTimer(&p_ali_socket->btnGetTimer, (int)SOCKET_BTN_INTERVAL/10, 
    37d8:	6820      	ldr	r0, [r4, #0]
    37da:	4b25      	ldr	r3, [pc, #148]	; (3870 <ali_socket_init+0x1a4>)
    37dc:	3014      	adds	r0, #20
    37de:	2200      	movs	r2, #0
    37e0:	2114      	movs	r1, #20
    37e2:	f7fe fab5 	bl	1d50 <SYS_SetTimer>
					TIMER_SINGLE, (Timer_Expire_CB)ali_socket_btn_get_timer_cb);

	//start indicate timer
	if(p_ali_socket->bindStatus){
    37e6:	6825      	ldr	r5, [r4, #0]
    37e8:	786b      	ldrb	r3, [r5, #1]
    37ea:	2b00      	cmp	r3, #0
    37ec:	d00b      	beq.n	3806 <ali_socket_init+0x13a>
		SYS_SetTimer(&p_ali_socket->btnGetTimer, (int)bc_mm_alis_get_random_time()/10, 
    37ee:	f002 fa4f 	bl	5c90 <bc_mm_alis_get_random_time>
    37f2:	210a      	movs	r1, #10
    37f4:	f000 fd7b 	bl	42ee <__aeabi_uidiv>
    37f8:	b281      	uxth	r1, r0
    37fa:	0028      	movs	r0, r5
    37fc:	4b1d      	ldr	r3, [pc, #116]	; (3874 <ali_socket_init+0x1a8>)
    37fe:	3014      	adds	r0, #20
    3800:	2200      	movs	r2, #0
    3802:	f7fe faa5 	bl	1d50 <SYS_SetTimer>
					TIMER_SINGLE, (Timer_Expire_CB)ali_socket_ind_sts_timer_cb);
	}

	p_ali_socket->oo_ctrl.get = ali_socket_elec_relay_get;
    3806:	6820      	ldr	r0, [r4, #0]
    3808:	491b      	ldr	r1, [pc, #108]	; (3878 <ali_socket_init+0x1ac>)
    380a:	0002      	movs	r2, r0
    380c:	0003      	movs	r3, r0
    380e:	3288      	adds	r2, #136	; 0x88
    3810:	6011      	str	r1, [r2, #0]
	p_ali_socket->oo_ctrl.set = ali_socket_elec_relay_set;
    3812:	4a1a      	ldr	r2, [pc, #104]	; (387c <ali_socket_init+0x1b0>)
	if(p_ali_socket->bindStatus){
		SYS_SetTimer(&p_ali_socket->btnGetTimer, (int)bc_mm_alis_get_random_time()/10, 
					TIMER_SINGLE, (Timer_Expire_CB)ali_socket_ind_sts_timer_cb);
	}

	p_ali_socket->oo_ctrl.get = ali_socket_elec_relay_get;
    3814:	3308      	adds	r3, #8
	p_ali_socket->oo_ctrl.set = ali_socket_elec_relay_set;
    3816:	67da      	str	r2, [r3, #124]	; 0x7c
	bc_mm_gens_oo_init(&p_ali_socket->model[p_ali_socket->model_cnt++], &p_ali_socket->oo_ctrl);
    3818:	0002      	movs	r2, r0
    381a:	325c      	adds	r2, #92	; 0x5c
    381c:	7813      	ldrb	r3, [r2, #0]
    381e:	1c59      	adds	r1, r3, #1
    3820:	7011      	strb	r1, [r2, #0]
    3822:	0001      	movs	r1, r0
    3824:	3306      	adds	r3, #6
    3826:	011b      	lsls	r3, r3, #4
    3828:	3184      	adds	r1, #132	; 0x84
    382a:	18c0      	adds	r0, r0, r3
    382c:	f002 fb70 	bl	5f10 <bc_mm_gens_oo_init>
	bc_mm_alis_vendor_init(&p_ali_socket->model[p_ali_socket->model_cnt++], NULL);
    3830:	6822      	ldr	r2, [r4, #0]
    3832:	0011      	movs	r1, r2
    3834:	315c      	adds	r1, #92	; 0x5c
    3836:	780b      	ldrb	r3, [r1, #0]
    3838:	1c58      	adds	r0, r3, #1
    383a:	7008      	strb	r0, [r1, #0]
    383c:	1d98      	adds	r0, r3, #6
    383e:	0100      	lsls	r0, r0, #4
    3840:	1810      	adds	r0, r2, r0
    3842:	2100      	movs	r1, #0
    3844:	f002 fa5e 	bl	5d04 <bc_mm_alis_vendor_init>
	*mdl = p_ali_socket->model;
    3848:	6823      	ldr	r3, [r4, #0]
	*mcnt = p_ali_socket->model_cnt;
	return 0;
    384a:	2000      	movs	r0, #0

	p_ali_socket->oo_ctrl.get = ali_socket_elec_relay_get;
	p_ali_socket->oo_ctrl.set = ali_socket_elec_relay_set;
	bc_mm_gens_oo_init(&p_ali_socket->model[p_ali_socket->model_cnt++], &p_ali_socket->oo_ctrl);
	bc_mm_alis_vendor_init(&p_ali_socket->model[p_ali_socket->model_cnt++], NULL);
	*mdl = p_ali_socket->model;
    384c:	001a      	movs	r2, r3
    384e:	3260      	adds	r2, #96	; 0x60
    3850:	603a      	str	r2, [r7, #0]
	*mcnt = p_ali_socket->model_cnt;
    3852:	335c      	adds	r3, #92	; 0x5c
    3854:	781b      	ldrb	r3, [r3, #0]
    3856:	9a03      	ldr	r2, [sp, #12]
    3858:	7013      	strb	r3, [r2, #0]
	return 0;
}
    385a:	b005      	add	sp, #20
    385c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    385e:	46c0      	nop			; (mov r8, r8)
    3860:	10011010 	.word	0x10011010
    3864:	10010514 	.word	0x10010514
    3868:	00020390 	.word	0x00020390
    386c:	00020290 	.word	0x00020290
    3870:	000034d1 	.word	0x000034d1
    3874:	00003565 	.word	0x00003565
    3878:	000039dd 	.word	0x000039dd
    387c:	00003909 	.word	0x00003909

00003880 <ali_socket_deinit>:

uint8_t ali_socket_deinit(mesh_model_t** mdl)
{
    3880:	b570      	push	{r4, r5, r6, lr}
	bc_mm_alis_vendor_deinit(&p_ali_socket->model[--p_ali_socket->model_cnt]);
    3882:	4c12      	ldr	r4, [pc, #72]	; (38cc <ali_socket_deinit+0x4c>)
	*mcnt = p_ali_socket->model_cnt;
	return 0;
}

uint8_t ali_socket_deinit(mesh_model_t** mdl)
{
    3884:	0005      	movs	r5, r0
	bc_mm_alis_vendor_deinit(&p_ali_socket->model[--p_ali_socket->model_cnt]);
    3886:	6822      	ldr	r2, [r4, #0]
    3888:	0011      	movs	r1, r2
    388a:	315c      	adds	r1, #92	; 0x5c
    388c:	780b      	ldrb	r3, [r1, #0]
    388e:	3b01      	subs	r3, #1
    3890:	b2db      	uxtb	r3, r3
    3892:	1d98      	adds	r0, r3, #6
    3894:	0100      	lsls	r0, r0, #4
    3896:	700b      	strb	r3, [r1, #0]
    3898:	1810      	adds	r0, r2, r0
    389a:	f002 fa55 	bl	5d48 <bc_mm_alis_vendor_deinit>
	bc_mm_gens_oo_deinit(&p_ali_socket->model[--p_ali_socket->model_cnt]);
    389e:	6822      	ldr	r2, [r4, #0]
    38a0:	0011      	movs	r1, r2
    38a2:	315c      	adds	r1, #92	; 0x5c
    38a4:	780b      	ldrb	r3, [r1, #0]
    38a6:	3b01      	subs	r3, #1
    38a8:	b2db      	uxtb	r3, r3
    38aa:	1d98      	adds	r0, r3, #6
    38ac:	0100      	lsls	r0, r0, #4
    38ae:	700b      	strb	r3, [r1, #0]
    38b0:	1810      	adds	r0, r2, r0
    38b2:	f002 fb4f 	bl	5f54 <bc_mm_gens_oo_deinit>
	if(p_ali_socket){
    38b6:	6820      	ldr	r0, [r4, #0]
    38b8:	2800      	cmp	r0, #0
    38ba:	d003      	beq.n	38c4 <ali_socket_deinit+0x44>
		ke_free(p_ali_socket);
    38bc:	f003 fd14 	bl	72e8 <ke_free>
		p_ali_socket = NULL;
    38c0:	2300      	movs	r3, #0
    38c2:	6023      	str	r3, [r4, #0]
	}
	*mdl = NULL;
    38c4:	2000      	movs	r0, #0
    38c6:	6028      	str	r0, [r5, #0]
	return 0;
}
    38c8:	bd70      	pop	{r4, r5, r6, pc}
    38ca:	46c0      	nop			; (mov r8, r8)
    38cc:	10011010 	.word	0x10011010

000038d0 <ali_socket_ind_status_set>:

void ali_socket_ind_status_set(uint8_t on)
{
    38d0:	b510      	push	{r4, lr}
	bc_gpio_set(GPIO_PWM1, on);
    38d2:	1e44      	subs	r4, r0, #1
    38d4:	41a0      	sbcs	r0, r4
    38d6:	b2c4      	uxtb	r4, r0
    38d8:	0021      	movs	r1, r4
    38da:	2006      	movs	r0, #6
    38dc:	f7fe fb32 	bl	1f44 <bc_gpio_set>
	bc_gpio_set(GPIO_PWM5, on);
    38e0:	0021      	movs	r1, r4
    38e2:	2018      	movs	r0, #24
    38e4:	f7fe fb2e 	bl	1f44 <bc_gpio_set>
}
    38e8:	bd10      	pop	{r4, pc}

000038ea <ali_socket_ind_onoff_set>:

void ali_socket_ind_onoff_set(uint8_t on)
{
	bc_gpio_set(GPIO_PWM1, !on);
    38ea:	4241      	negs	r1, r0
    38ec:	4141      	adcs	r1, r0
	bc_gpio_set(GPIO_PWM1, on);
	bc_gpio_set(GPIO_PWM5, on);
}

void ali_socket_ind_onoff_set(uint8_t on)
{
    38ee:	b510      	push	{r4, lr}
    38f0:	0004      	movs	r4, r0
	bc_gpio_set(GPIO_PWM1, !on);
    38f2:	b2c9      	uxtb	r1, r1
    38f4:	2006      	movs	r0, #6
    38f6:	f7fe fb25 	bl	1f44 <bc_gpio_set>
	bc_gpio_set(GPIO_PWM5, on);
    38fa:	1e61      	subs	r1, r4, #1
    38fc:	418c      	sbcs	r4, r1
    38fe:	2018      	movs	r0, #24
    3900:	b2e1      	uxtb	r1, r4
    3902:	f7fe fb1f 	bl	1f44 <bc_gpio_set>
}
    3906:	bd10      	pop	{r4, pc}

00003908 <ali_socket_elec_relay_set>:


void ali_socket_elec_relay_set(uint8_t on)
{
	M_PRINTF(L_APP, "ctrl to [%x]", on);
    3908:	4b28      	ldr	r3, [pc, #160]	; (39ac <ali_socket_elec_relay_set+0xa4>)
	bc_gpio_set(GPIO_PWM5, on);
}


void ali_socket_elec_relay_set(uint8_t on)
{
    390a:	b573      	push	{r0, r1, r4, r5, r6, lr}
	M_PRINTF(L_APP, "ctrl to [%x]", on);
    390c:	681b      	ldr	r3, [r3, #0]
	bc_gpio_set(GPIO_PWM5, on);
}


void ali_socket_elec_relay_set(uint8_t on)
{
    390e:	0006      	movs	r6, r0
	M_PRINTF(L_APP, "ctrl to [%x]", on);
    3910:	049b      	lsls	r3, r3, #18
    3912:	d516      	bpl.n	3942 <ali_socket_elec_relay_set+0x3a>
    3914:	4d26      	ldr	r5, [pc, #152]	; (39b0 <ali_socket_elec_relay_set+0xa8>)
    3916:	4c27      	ldr	r4, [pc, #156]	; (39b4 <ali_socket_elec_relay_set+0xac>)
    3918:	002b      	movs	r3, r5
    391a:	0022      	movs	r2, r4
    391c:	0020      	movs	r0, r4
    391e:	3365      	adds	r3, #101	; 0x65
    3920:	3226      	adds	r2, #38	; 0x26
    3922:	9300      	str	r3, [sp, #0]
    3924:	0021      	movs	r1, r4
    3926:	23eb      	movs	r3, #235	; 0xeb
    3928:	3033      	adds	r0, #51	; 0x33
    392a:	f001 f83f 	bl	49ac <m_print>
    392e:	0028      	movs	r0, r5
    3930:	0031      	movs	r1, r6
    3932:	307f      	adds	r0, #127	; 0x7f
    3934:	f001 f83a 	bl	49ac <m_print>
    3938:	0020      	movs	r0, r4
    393a:	1da1      	adds	r1, r4, #6
    393c:	3073      	adds	r0, #115	; 0x73
    393e:	f001 f835 	bl	49ac <m_print>
	bc_gpio_set(GPIO_PWM2, on);
    3942:	0031      	movs	r1, r6
    3944:	1e4b      	subs	r3, r1, #1
    3946:	4199      	sbcs	r1, r3
    3948:	200e      	movs	r0, #14
    394a:	b2c9      	uxtb	r1, r1
    394c:	f7fe fafa 	bl	1f44 <bc_gpio_set>
	ali_socket_ind_onoff_set(on);
    3950:	0030      	movs	r0, r6
    3952:	f7ff ffca 	bl	38ea <ali_socket_ind_onoff_set>
	
	p_ali_socket->eRelayS = on;
    3956:	4c18      	ldr	r4, [pc, #96]	; (39b8 <ali_socket_elec_relay_set+0xb0>)
    3958:	6825      	ldr	r5, [r4, #0]

	//indicate status
	if(p_ali_socket->bindStatus){
    395a:	786b      	ldrb	r3, [r5, #1]
{
	M_PRINTF(L_APP, "ctrl to [%x]", on);
	bc_gpio_set(GPIO_PWM2, on);
	ali_socket_ind_onoff_set(on);
	
	p_ali_socket->eRelayS = on;
    395c:	702e      	strb	r6, [r5, #0]

	//indicate status
	if(p_ali_socket->bindStatus){
    395e:	2b00      	cmp	r3, #0
    3960:	d00b      	beq.n	397a <ali_socket_elec_relay_set+0x72>

		SYS_SetTimer(&p_ali_socket->btnGetTimer, (int)bc_mm_alis_get_random_time()/10, 
    3962:	f002 f995 	bl	5c90 <bc_mm_alis_get_random_time>
    3966:	210a      	movs	r1, #10
    3968:	f000 fcc1 	bl	42ee <__aeabi_uidiv>
    396c:	b281      	uxth	r1, r0
    396e:	0028      	movs	r0, r5
    3970:	4b12      	ldr	r3, [pc, #72]	; (39bc <ali_socket_elec_relay_set+0xb4>)
    3972:	3014      	adds	r0, #20
    3974:	2200      	movs	r2, #0
    3976:	f7fe f9eb 	bl	1d50 <SYS_SetTimer>
					TIMER_SINGLE, (Timer_Expire_CB)ali_socket_ind_sts_timer_cb);
	}

	//save status
	p_ali_socket->saveCfgCrc = bc_sys_check_sum((uint8_t*)p_ali_socket, ALI_SOCKET_SAVE_LEN-1);
    397a:	6825      	ldr	r5, [r4, #0]
    397c:	2113      	movs	r1, #19
    397e:	0028      	movs	r0, r5
    3980:	f7fe fe84 	bl	268c <bc_sys_check_sum>
    3984:	74e8      	strb	r0, [r5, #19]
	m_printf_hex(L_APP, "ali_socket_elec_relay_set save data", (uint8_t*)p_ali_socket, ALI_SOCKET_SAVE_LEN);
    3986:	2080      	movs	r0, #128	; 0x80
    3988:	490d      	ldr	r1, [pc, #52]	; (39c0 <ali_socket_elec_relay_set+0xb8>)
    398a:	2314      	movs	r3, #20
    398c:	6822      	ldr	r2, [r4, #0]
    398e:	310c      	adds	r1, #12
    3990:	0180      	lsls	r0, r0, #6
    3992:	f001 f86b 	bl	4a6c <m_printf_hex>
	bc_flash_erase(FLASH_ALI_START_ADDRRESS, 1);
    3996:	2101      	movs	r1, #1
    3998:	2000      	movs	r0, #0
    399a:	f7fe f825 	bl	19e8 <bc_flash_erase>
	bc_flash_write(FLASH_ALI_START_ADDRRESS, ALI_SOCKET_SAVE_LEN,(uint8_t*)p_ali_socket);
    399e:	6822      	ldr	r2, [r4, #0]
    39a0:	2114      	movs	r1, #20
    39a2:	2000      	movs	r0, #0
    39a4:	f7fe f85e 	bl	1a64 <bc_flash_write>
}
    39a8:	bd73      	pop	{r0, r1, r4, r5, r6, pc}
    39aa:	46c0      	nop			; (mov r8, r8)
    39ac:	10010514 	.word	0x10010514
    39b0:	00020390 	.word	0x00020390
    39b4:	00020290 	.word	0x00020290
    39b8:	10011010 	.word	0x10011010
    39bc:	00003565 	.word	0x00003565
    39c0:	00020410 	.word	0x00020410

000039c4 <ali_socket_elec_relay_reverse>:
void ali_socket_elec_relay_reverse(void)
{
    39c4:	b510      	push	{r4, lr}
	uint8_t on = p_ali_socket->eRelayS;
    39c6:	4b04      	ldr	r3, [pc, #16]	; (39d8 <ali_socket_elec_relay_reverse+0x14>)
    39c8:	681b      	ldr	r3, [r3, #0]
	on = !on;
    39ca:	7818      	ldrb	r0, [r3, #0]
    39cc:	4243      	negs	r3, r0
    39ce:	4158      	adcs	r0, r3
    39d0:	b2c0      	uxtb	r0, r0
	ali_socket_elec_relay_set(on);
    39d2:	f7ff ff99 	bl	3908 <ali_socket_elec_relay_set>
}
    39d6:	bd10      	pop	{r4, pc}
    39d8:	10011010 	.word	0x10011010

000039dc <ali_socket_elec_relay_get>:

uint8_t ali_socket_elec_relay_get(void)
{
	return p_ali_socket->eRelayS;
    39dc:	4b01      	ldr	r3, [pc, #4]	; (39e4 <ali_socket_elec_relay_get+0x8>)
    39de:	681b      	ldr	r3, [r3, #0]
    39e0:	7818      	ldrb	r0, [r3, #0]
}
    39e2:	4770      	bx	lr
    39e4:	10011010 	.word	0x10011010

000039e8 <ali_socket_elec_relay_init>:
uint8_t ali_socket_elec_relay_init()
{
	
	if(p_ali_socket == NULL)
    39e8:	4b05      	ldr	r3, [pc, #20]	; (3a00 <ali_socket_elec_relay_init+0x18>)
uint8_t ali_socket_elec_relay_get(void)
{
	return p_ali_socket->eRelayS;
}
uint8_t ali_socket_elec_relay_init()
{
    39ea:	b510      	push	{r4, lr}
	
	if(p_ali_socket == NULL)
    39ec:	681b      	ldr	r3, [r3, #0]
		return 2;
    39ee:	2002      	movs	r0, #2
	return p_ali_socket->eRelayS;
}
uint8_t ali_socket_elec_relay_init()
{
	
	if(p_ali_socket == NULL)
    39f0:	2b00      	cmp	r3, #0
    39f2:	d003      	beq.n	39fc <ali_socket_elec_relay_init+0x14>
		return 2;
	ali_socket_elec_relay_set(p_ali_socket->eRelayS);
    39f4:	7818      	ldrb	r0, [r3, #0]
    39f6:	f7ff ff87 	bl	3908 <ali_socket_elec_relay_set>
	return 0;
    39fa:	2000      	movs	r0, #0
}
    39fc:	bd10      	pop	{r4, pc}
    39fe:	46c0      	nop			; (mov r8, r8)
    3a00:	10011010 	.word	0x10011010

00003a04 <ali_socket_key_init>:

void ali_socket_key_init(void)
{
	GPIO_CFG cfg;
	cfg.pin_func = FUNC_INPUT;
	cfg.pin_cfg = GFG_PULLUP;
    3a04:	2340      	movs	r3, #64	; 0x40
	ali_socket_elec_relay_set(p_ali_socket->eRelayS);
	return 0;
}

void ali_socket_key_init(void)
{
    3a06:	b507      	push	{r0, r1, r2, lr}
	GPIO_CFG cfg;
	cfg.pin_func = FUNC_INPUT;
	cfg.pin_cfg = GFG_PULLUP;
	bc_gpio_init(GPIO_PWM4, &cfg);
    3a08:	2017      	movs	r0, #23
}

void ali_socket_key_init(void)
{
	GPIO_CFG cfg;
	cfg.pin_func = FUNC_INPUT;
    3a0a:	a901      	add	r1, sp, #4
	cfg.pin_cfg = GFG_PULLUP;
    3a0c:	700b      	strb	r3, [r1, #0]
	bc_gpio_init(GPIO_PWM4, &cfg);
    3a0e:	f7fe fa6f 	bl	1ef0 <bc_gpio_init>
}
    3a12:	bd07      	pop	{r0, r1, r2, pc}

00003a14 <ali_socket_key_get>:
uint8_t ali_socket_key_get(void)
{
    3a14:	b510      	push	{r4, lr}
	return (uint8_t)bc_gpio_get(GPIO_PWM4);
    3a16:	2017      	movs	r0, #23
    3a18:	f7fe fab6 	bl	1f88 <bc_gpio_get>
}
    3a1c:	bd10      	pop	{r4, pc}
    3a1e:	46c0      	nop			; (mov r8, r8)

00003a20 <_cw_set_on_off>:
static void _cw_init(light_cw_t* t)
{
	return led_cw_init(t);
}
static void _cw_set_on_off(uint8_t on)
{
    3a20:	b510      	push	{r4, lr}
	led_cw_set_on_off(on, NULL);
    3a22:	2100      	movs	r1, #0
    3a24:	f7fe fb58 	bl	20d8 <led_cw_set_on_off>
	_ready_to_indicate(true);
    3a28:	2001      	movs	r0, #1
    3a2a:	f000 f805 	bl	3a38 <_ready_to_indicate>
}
    3a2e:	bd10      	pop	{r4, pc}

00003a30 <_cw_get_on_off>:
static uint8_t _cw_get_on_off(void)
{
    3a30:	b510      	push	{r4, lr}
	return led_cw_get_on_off();
    3a32:	f7fe fb73 	bl	211c <led_cw_get_on_off>
}
    3a36:	bd10      	pop	{r4, pc}

00003a38 <_ready_to_indicate>:

/*********************Hardware Ctrl End**********************/

static void _ready_to_indicate(bool random)
{
	if(pstHeatTable == NULL)
    3a38:	4b0e      	ldr	r3, [pc, #56]	; (3a74 <_ready_to_indicate+0x3c>)
}

/*********************Hardware Ctrl End**********************/

static void _ready_to_indicate(bool random)
{
    3a3a:	b570      	push	{r4, r5, r6, lr}
	if(pstHeatTable == NULL)
    3a3c:	681a      	ldr	r2, [r3, #0]
    3a3e:	001d      	movs	r5, r3
    3a40:	2a00      	cmp	r2, #0
    3a42:	d016      	beq.n	3a72 <_ready_to_indicate+0x3a>
		return;
	
	uint32_t delay_time = M_ALIS_INDICATION_PERIOD;
	
	if(random){
    3a44:	2800      	cmp	r0, #0
    3a46:	d003      	beq.n	3a50 <_ready_to_indicate+0x18>
		delay_time = bc_mm_alis_get_random_time();
    3a48:	f002 f922 	bl	5c90 <bc_mm_alis_get_random_time>
    3a4c:	0004      	movs	r4, r0
    3a4e:	e000      	b.n	3a52 <_ready_to_indicate+0x1a>
static void _ready_to_indicate(bool random)
{
	if(pstHeatTable == NULL)
		return;
	
	uint32_t delay_time = M_ALIS_INDICATION_PERIOD;
    3a50:	4c09      	ldr	r4, [pc, #36]	; (3a78 <_ready_to_indicate+0x40>)
	if(random){
		delay_time = bc_mm_alis_get_random_time();
	}
	
	//if bound
	if(ali_heating_table_prov_state_get()){
    3a52:	f000 f991 	bl	3d78 <ali_heating_table_prov_state_get>
    3a56:	2800      	cmp	r0, #0
    3a58:	d00b      	beq.n	3a72 <_ready_to_indicate+0x3a>
		SYS_SetTimer(&pstHeatTable->periodIndTimer, (int)delay_time/10, 
    3a5a:	210a      	movs	r1, #10
    3a5c:	0020      	movs	r0, r4
    3a5e:	f000 fc1e 	bl	429e <__aeabi_idiv>
    3a62:	682b      	ldr	r3, [r5, #0]
    3a64:	0001      	movs	r1, r0
    3a66:	3344      	adds	r3, #68	; 0x44
    3a68:	0018      	movs	r0, r3
    3a6a:	2200      	movs	r2, #0
    3a6c:	4b03      	ldr	r3, [pc, #12]	; (3a7c <_ready_to_indicate+0x44>)
    3a6e:	f7fe f96f 	bl	1d50 <SYS_SetTimer>
					TIMER_SINGLE, (Timer_Expire_CB)_period_ind_timer_cb);
	}
}
    3a72:	bd70      	pop	{r4, r5, r6, pc}
    3a74:	10011014 	.word	0x10011014
    3a78:	0002bf20 	.word	0x0002bf20
    3a7c:	00003bd1 	.word	0x00003bd1

00003a80 <_bind_timer_cb>:

static void _bind_timer_cb(void* param)
{
    3a80:	b5f0      	push	{r4, r5, r6, r7, lr}
	uint16_t status;

	if(!pstHeatTable->provState){
    3a82:	4e4e      	ldr	r6, [pc, #312]	; (3bbc <_bind_timer_cb+0x13c>)
					TIMER_SINGLE, (Timer_Expire_CB)_period_ind_timer_cb);
	}
}

static void _bind_timer_cb(void* param)
{
    3a84:	b087      	sub	sp, #28
	uint16_t status;

	if(!pstHeatTable->provState){
    3a86:	6834      	ldr	r4, [r6, #0]
    3a88:	7865      	ldrb	r5, [r4, #1]
    3a8a:	2d00      	cmp	r5, #0
    3a8c:	d10f      	bne.n	3aae <_bind_timer_cb+0x2e>
		pstHeatTable->provState = 1;
    3a8e:	2701      	movs	r7, #1
		pstHeatTable->saveCfgCrc = bc_sys_check_sum((uint8_t*)pstHeatTable, ALI_HEATING_TABLE_SAVE_LEN-1);
    3a90:	2113      	movs	r1, #19
static void _bind_timer_cb(void* param)
{
	uint16_t status;

	if(!pstHeatTable->provState){
		pstHeatTable->provState = 1;
    3a92:	7067      	strb	r7, [r4, #1]
		pstHeatTable->saveCfgCrc = bc_sys_check_sum((uint8_t*)pstHeatTable, ALI_HEATING_TABLE_SAVE_LEN-1);
    3a94:	0020      	movs	r0, r4
    3a96:	f7fe fdf9 	bl	268c <bc_sys_check_sum>
		bc_flash_erase(FLASH_ALI_START_ADDRRESS, 1);
    3a9a:	0039      	movs	r1, r7
{
	uint16_t status;

	if(!pstHeatTable->provState){
		pstHeatTable->provState = 1;
		pstHeatTable->saveCfgCrc = bc_sys_check_sum((uint8_t*)pstHeatTable, ALI_HEATING_TABLE_SAVE_LEN-1);
    3a9c:	74e0      	strb	r0, [r4, #19]
		bc_flash_erase(FLASH_ALI_START_ADDRRESS, 1);
    3a9e:	0028      	movs	r0, r5
    3aa0:	f7fd ffa2 	bl	19e8 <bc_flash_erase>
		bc_flash_write(FLASH_ALI_START_ADDRRESS, ALI_HEATING_TABLE_SAVE_LEN,(uint8_t*)pstHeatTable);
    3aa4:	6832      	ldr	r2, [r6, #0]
    3aa6:	2114      	movs	r1, #20
    3aa8:	0028      	movs	r0, r5
    3aaa:	f7fd ffdb 	bl	1a64 <bc_flash_write>
	}
	//model bind
	m_lid_t app_key_lid = 0;
    3aae:	2517      	movs	r5, #23
    3ab0:	2000      	movs	r0, #0
    3ab2:	446d      	add	r5, sp
	status = bc_m_key_app_find(0, &app_key_lid);
    3ab4:	0029      	movs	r1, r5
		pstHeatTable->saveCfgCrc = bc_sys_check_sum((uint8_t*)pstHeatTable, ALI_HEATING_TABLE_SAVE_LEN-1);
		bc_flash_erase(FLASH_ALI_START_ADDRRESS, 1);
		bc_flash_write(FLASH_ALI_START_ADDRRESS, ALI_HEATING_TABLE_SAVE_LEN,(uint8_t*)pstHeatTable);
	}
	//model bind
	m_lid_t app_key_lid = 0;
    3ab6:	7028      	strb	r0, [r5, #0]
	status = bc_m_key_app_find(0, &app_key_lid);
    3ab8:	f005 fc23 	bl	9302 <bc_m_key_app_find>
    3abc:	1e04      	subs	r4, r0, #0
	if (status != M_ERR_NO_ERROR){
    3abe:	d027      	beq.n	3b10 <_bind_timer_cb+0x90>
		M_PRINTF(L_FND, "m_tb_key_app_find error");
    3ac0:	4b3f      	ldr	r3, [pc, #252]	; (3bc0 <_bind_timer_cb+0x140>)
    3ac2:	681b      	ldr	r3, [r3, #0]
    3ac4:	051b      	lsls	r3, r3, #20
    3ac6:	d576      	bpl.n	3bb6 <_bind_timer_cb+0x136>
    3ac8:	4c3e      	ldr	r4, [pc, #248]	; (3bc4 <_bind_timer_cb+0x144>)
    3aca:	0023      	movs	r3, r4
    3acc:	0022      	movs	r2, r4
    3ace:	0020      	movs	r0, r4
    3ad0:	334e      	adds	r3, #78	; 0x4e
    3ad2:	0021      	movs	r1, r4
    3ad4:	322c      	adds	r2, #44	; 0x2c
    3ad6:	9300      	str	r3, [sp, #0]
    3ad8:	303f      	adds	r0, #63	; 0x3f
    3ada:	2346      	movs	r3, #70	; 0x46
    3adc:	f000 ff66 	bl	49ac <m_print>
    3ae0:	0020      	movs	r0, r4
    3ae2:	305d      	adds	r0, #93	; 0x5d
    3ae4:	f000 ff62 	bl	49ac <m_print>
    3ae8:	0020      	movs	r0, r4
    3aea:	1da1      	adds	r1, r4, #6
    3aec:	3075      	adds	r0, #117	; 0x75
    3aee:	f000 ff5d 	bl	49ac <m_print>
    3af2:	e060      	b.n	3bb6 <_bind_timer_cb+0x136>
    3af4:	0123      	lsls	r3, r4, #4
    3af6:	18ff      	adds	r7, r7, r3
		return;
	}
	for(uint8_t i = 0; i < pstHeatTable->model_cnt; ++i){
		mesh_model_t* t = &pstHeatTable->model[i];
		status = bc_m_key_model_bind(app_key_lid, t->lid);
    3af8:	3765      	adds	r7, #101	; 0x65
    3afa:	7839      	ldrb	r1, [r7, #0]
    3afc:	7828      	ldrb	r0, [r5, #0]
    3afe:	f005 fc08 	bl	9312 <bc_m_key_model_bind>
		if (status == M_ERR_NO_ERROR){
    3b02:	2800      	cmp	r0, #0
    3b04:	d102      	bne.n	3b0c <_bind_timer_cb+0x8c>
			// Inform the Model IO manager
			bc_m_mio_bind(t->lid);
    3b06:	7838      	ldrb	r0, [r7, #0]
    3b08:	f005 fbff 	bl	930a <bc_m_mio_bind>
	status = bc_m_key_app_find(0, &app_key_lid);
	if (status != M_ERR_NO_ERROR){
		M_PRINTF(L_FND, "m_tb_key_app_find error");
		return;
	}
	for(uint8_t i = 0; i < pstHeatTable->model_cnt; ++i){
    3b0c:	3401      	adds	r4, #1
    3b0e:	b2e4      	uxtb	r4, r4
    3b10:	6837      	ldr	r7, [r6, #0]
    3b12:	003b      	movs	r3, r7
    3b14:	335e      	adds	r3, #94	; 0x5e
    3b16:	781b      	ldrb	r3, [r3, #0]
    3b18:	42a3      	cmp	r3, r4
    3b1a:	d8eb      	bhi.n	3af4 <_bind_timer_cb+0x74>
    3b1c:	2700      	movs	r7, #0
	}
	
	//model subscription
	// Add address to the subscription list
	//model bond 0xC000，0xCFFF。
	for(uint8_t i = 0; i < pstHeatTable->model_cnt; ++i){
    3b1e:	6834      	ldr	r4, [r6, #0]
    3b20:	0023      	movs	r3, r4
    3b22:	335e      	adds	r3, #94	; 0x5e
    3b24:	781b      	ldrb	r3, [r3, #0]
    3b26:	429f      	cmp	r7, r3
    3b28:	d20d      	bcs.n	3b46 <_bind_timer_cb+0xc6>
    3b2a:	013b      	lsls	r3, r7, #4
    3b2c:	18e4      	adds	r4, r4, r3
		mesh_model_t* t = &pstHeatTable->model[i];
		//status = bc_m_mio_add_subscription(t->lid, 0xF000);
		bc_m_mio_add_subscription(t->lid, ALI_GROUP_ADDRESS_HEAT_TABLE);
    3b2e:	3465      	adds	r4, #101	; 0x65
    3b30:	4925      	ldr	r1, [pc, #148]	; (3bc8 <_bind_timer_cb+0x148>)
    3b32:	7820      	ldrb	r0, [r4, #0]
    3b34:	f005 fbf1 	bl	931a <bc_m_mio_add_subscription>
	}
	
	//model subscription
	// Add address to the subscription list
	//model bond 0xC000，0xCFFF。
	for(uint8_t i = 0; i < pstHeatTable->model_cnt; ++i){
    3b38:	3701      	adds	r7, #1
		mesh_model_t* t = &pstHeatTable->model[i];
		//status = bc_m_mio_add_subscription(t->lid, 0xF000);
		bc_m_mio_add_subscription(t->lid, ALI_GROUP_ADDRESS_HEAT_TABLE);
		bc_m_mio_add_subscription(t->lid, 0xCFFF);
    3b3a:	7820      	ldrb	r0, [r4, #0]
    3b3c:	4923      	ldr	r1, [pc, #140]	; (3bcc <_bind_timer_cb+0x14c>)
    3b3e:	f005 fbec 	bl	931a <bc_m_mio_add_subscription>
	}
	
	//model subscription
	// Add address to the subscription list
	//model bond 0xC000，0xCFFF。
	for(uint8_t i = 0; i < pstHeatTable->model_cnt; ++i){
    3b42:	b2ff      	uxtb	r7, r7
    3b44:	e7eb      	b.n	3b1e <_bind_timer_cb+0x9e>
		bc_m_mio_add_subscription(t->lid, ALI_GROUP_ADDRESS_HEAT_TABLE);
		bc_m_mio_add_subscription(t->lid, 0xCFFF);
		
	}
	mesh_model_t* t = &pstHeatTable->model[pstHeatTable->model_cnt-1];
	bc_m_mio_add_subscription(t->lid, M_ALI_VENDER_ADDR);
    3b46:	21f0      	movs	r1, #240	; 0xf0
    3b48:	011b      	lsls	r3, r3, #4
    3b4a:	18e4      	adds	r4, r4, r3
    3b4c:	3455      	adds	r4, #85	; 0x55
    3b4e:	0209      	lsls	r1, r1, #8
    3b50:	7820      	ldrb	r0, [r4, #0]
    3b52:	f005 fbe2 	bl	931a <bc_m_mio_add_subscription>

	// Set publication parameters
    status = bc_m_mio_set_publi_param(t->lid, M_ALI_VENDER_ADDR, NULL,
    3b56:	2182      	movs	r1, #130	; 0x82
    3b58:	782b      	ldrb	r3, [r5, #0]
    3b5a:	7820      	ldrb	r0, [r4, #0]
    3b5c:	9102      	str	r1, [sp, #8]
    3b5e:	395a      	subs	r1, #90	; 0x5a
    3b60:	9101      	str	r1, [sp, #4]
    3b62:	3922      	subs	r1, #34	; 0x22
    3b64:	2200      	movs	r2, #0
    3b66:	9100      	str	r1, [sp, #0]
    3b68:	21f0      	movs	r1, #240	; 0xf0
    3b6a:	9203      	str	r2, [sp, #12]
    3b6c:	0209      	lsls	r1, r1, #8
    3b6e:	f005 fbd8 	bl	9322 <bc_m_mio_set_publi_param>
                                      app_key_lid, M_ALI_PUBLISH_TTL, M_ALI_PUBLISH_PERIOD,
                                     M_ALI_PUBLISH_RETX, 0);
	M_PRINTF(L_APP, "t->lid[%x] pstHeatTable->model_cnt[%x] status[%x]",t->lid, pstHeatTable->model_cnt, status);
    3b72:	4b13      	ldr	r3, [pc, #76]	; (3bc0 <_bind_timer_cb+0x140>)
	}
	mesh_model_t* t = &pstHeatTable->model[pstHeatTable->model_cnt-1];
	bc_m_mio_add_subscription(t->lid, M_ALI_VENDER_ADDR);

	// Set publication parameters
    status = bc_m_mio_set_publi_param(t->lid, M_ALI_VENDER_ADDR, NULL,
    3b74:	0007      	movs	r7, r0
                                      app_key_lid, M_ALI_PUBLISH_TTL, M_ALI_PUBLISH_PERIOD,
                                     M_ALI_PUBLISH_RETX, 0);
	M_PRINTF(L_APP, "t->lid[%x] pstHeatTable->model_cnt[%x] status[%x]",t->lid, pstHeatTable->model_cnt, status);
    3b76:	681b      	ldr	r3, [r3, #0]
    3b78:	049b      	lsls	r3, r3, #18
    3b7a:	d519      	bpl.n	3bb0 <_bind_timer_cb+0x130>
    3b7c:	4d11      	ldr	r5, [pc, #68]	; (3bc4 <_bind_timer_cb+0x144>)
    3b7e:	002b      	movs	r3, r5
    3b80:	002a      	movs	r2, r5
    3b82:	0028      	movs	r0, r5
    3b84:	334e      	adds	r3, #78	; 0x4e
    3b86:	322c      	adds	r2, #44	; 0x2c
    3b88:	9300      	str	r3, [sp, #0]
    3b8a:	0029      	movs	r1, r5
    3b8c:	2363      	movs	r3, #99	; 0x63
    3b8e:	303f      	adds	r0, #63	; 0x3f
    3b90:	f000 ff0c 	bl	49ac <m_print>
    3b94:	0028      	movs	r0, r5
    3b96:	6833      	ldr	r3, [r6, #0]
    3b98:	7821      	ldrb	r1, [r4, #0]
    3b9a:	335e      	adds	r3, #94	; 0x5e
    3b9c:	781a      	ldrb	r2, [r3, #0]
    3b9e:	3078      	adds	r0, #120	; 0x78
    3ba0:	003b      	movs	r3, r7
    3ba2:	f000 ff03 	bl	49ac <m_print>
    3ba6:	0028      	movs	r0, r5
    3ba8:	1da9      	adds	r1, r5, #6
    3baa:	3075      	adds	r0, #117	; 0x75
    3bac:	f000 fefe 	bl	49ac <m_print>
	
	_ready_to_indicate(true);
    3bb0:	2001      	movs	r0, #1
    3bb2:	f7ff ff41 	bl	3a38 <_ready_to_indicate>
}
    3bb6:	b007      	add	sp, #28
    3bb8:	bdf0      	pop	{r4, r5, r6, r7, pc}
    3bba:	46c0      	nop			; (mov r8, r8)
    3bbc:	10011014 	.word	0x10011014
    3bc0:	10010514 	.word	0x10010514
    3bc4:	00020440 	.word	0x00020440
    3bc8:	0000c1a5 	.word	0x0000c1a5
    3bcc:	0000cfff 	.word	0x0000cfff

00003bd0 <_period_ind_timer_cb>:

static void _period_ind_timer_cb(void* param)
{
    3bd0:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	led_cw_set_on_off(on, NULL);
	_ready_to_indicate(true);
}
static uint8_t _cw_get_on_off(void)
{
	return led_cw_get_on_off();
    3bd2:	f7fe faa3 	bl	211c <led_cw_get_on_off>

static void _period_ind_timer_cb(void* param)
{
	uint8_t data[11];
	int len = 0;
	len += bc_mm_alis_set_onoff_status(&data[0]+len, _cw_get_on_off());
    3bd6:	1e41      	subs	r1, r0, #1
    3bd8:	4188      	sbcs	r0, r1
    3bda:	b2c1      	uxtb	r1, r0
    3bdc:	a801      	add	r0, sp, #4
    3bde:	f001 fee7 	bl	59b0 <bc_mm_alis_set_onoff_status>
    3be2:	0004      	movs	r4, r0
	m_printf_hex(L_APP, "_period_ind_timer_cb", data, len);
    3be4:	0003      	movs	r3, r0
    3be6:	2080      	movs	r0, #128	; 0x80
    3be8:	4909      	ldr	r1, [pc, #36]	; (3c10 <_period_ind_timer_cb+0x40>)
    3bea:	aa01      	add	r2, sp, #4
    3bec:	312a      	adds	r1, #42	; 0x2a
    3bee:	0180      	lsls	r0, r0, #6
    3bf0:	f000 ff3c 	bl	4a6c <m_printf_hex>
	bc_mm_alis_send_indication(pstHeatTable->model[3].lid, data, len);
    3bf4:	4b07      	ldr	r3, [pc, #28]	; (3c14 <_period_ind_timer_cb+0x44>)
    3bf6:	0022      	movs	r2, r4
    3bf8:	681b      	ldr	r3, [r3, #0]
    3bfa:	a901      	add	r1, sp, #4
    3bfc:	3395      	adds	r3, #149	; 0x95
    3bfe:	7818      	ldrb	r0, [r3, #0]
    3c00:	f001 ff8c 	bl	5b1c <bc_mm_alis_send_indication>
	
	_ready_to_indicate(false);
    3c04:	2000      	movs	r0, #0
    3c06:	f7ff ff17 	bl	3a38 <_ready_to_indicate>
	bc_m_ali_save_seq_iv();
    3c0a:	f005 fb70 	bl	92ee <bc_m_ali_save_seq_iv>
}
    3c0e:	bd1f      	pop	{r0, r1, r2, r3, r4, pc}
    3c10:	000204c0 	.word	0x000204c0
    3c14:	10011014 	.word	0x10011014

00003c18 <_quick_restore_timer_cb>:

static void _quick_restore_timer_cb(void *t)
{
	M_PRINTF(L_APP, "");
    3c18:	4b16      	ldr	r3, [pc, #88]	; (3c74 <_quick_restore_timer_cb+0x5c>)
	_ready_to_indicate(false);
	bc_m_ali_save_seq_iv();
}

static void _quick_restore_timer_cb(void *t)
{
    3c1a:	b573      	push	{r0, r1, r4, r5, r6, lr}
	M_PRINTF(L_APP, "");
    3c1c:	681b      	ldr	r3, [r3, #0]
    3c1e:	049b      	lsls	r3, r3, #18
    3c20:	d515      	bpl.n	3c4e <_quick_restore_timer_cb+0x36>
    3c22:	4d15      	ldr	r5, [pc, #84]	; (3c78 <_quick_restore_timer_cb+0x60>)
    3c24:	4c15      	ldr	r4, [pc, #84]	; (3c7c <_quick_restore_timer_cb+0x64>)
    3c26:	002b      	movs	r3, r5
    3c28:	0022      	movs	r2, r4
    3c2a:	0020      	movs	r0, r4
    3c2c:	333f      	adds	r3, #63	; 0x3f
    3c2e:	0021      	movs	r1, r4
    3c30:	322c      	adds	r2, #44	; 0x2c
    3c32:	9300      	str	r3, [sp, #0]
    3c34:	303f      	adds	r0, #63	; 0x3f
    3c36:	2376      	movs	r3, #118	; 0x76
    3c38:	f000 feb8 	bl	49ac <m_print>
    3c3c:	0028      	movs	r0, r5
    3c3e:	3057      	adds	r0, #87	; 0x57
    3c40:	f000 feb4 	bl	49ac <m_print>
    3c44:	0020      	movs	r0, r4
    3c46:	1da1      	adds	r1, r4, #6
    3c48:	3075      	adds	r0, #117	; 0x75
    3c4a:	f000 feaf 	bl	49ac <m_print>
	pstHeatTable->quickTime = 0;
    3c4e:	2400      	movs	r4, #0
    3c50:	4e0b      	ldr	r6, [pc, #44]	; (3c80 <_quick_restore_timer_cb+0x68>)
	pstHeatTable->saveCfgCrc = bc_sys_check_sum((uint8_t*)pstHeatTable, ALI_HEATING_TABLE_SAVE_LEN-1);
    3c52:	2113      	movs	r1, #19
}

static void _quick_restore_timer_cb(void *t)
{
	M_PRINTF(L_APP, "");
	pstHeatTable->quickTime = 0;
    3c54:	6835      	ldr	r5, [r6, #0]
    3c56:	702c      	strb	r4, [r5, #0]
	pstHeatTable->saveCfgCrc = bc_sys_check_sum((uint8_t*)pstHeatTable, ALI_HEATING_TABLE_SAVE_LEN-1);
    3c58:	0028      	movs	r0, r5
    3c5a:	f7fe fd17 	bl	268c <bc_sys_check_sum>
	bc_flash_erase(FLASH_ALI_START_ADDRRESS, 1);
    3c5e:	2101      	movs	r1, #1

static void _quick_restore_timer_cb(void *t)
{
	M_PRINTF(L_APP, "");
	pstHeatTable->quickTime = 0;
	pstHeatTable->saveCfgCrc = bc_sys_check_sum((uint8_t*)pstHeatTable, ALI_HEATING_TABLE_SAVE_LEN-1);
    3c60:	74e8      	strb	r0, [r5, #19]
	bc_flash_erase(FLASH_ALI_START_ADDRRESS, 1);
    3c62:	0020      	movs	r0, r4
    3c64:	f7fd fec0 	bl	19e8 <bc_flash_erase>
	bc_flash_write(FLASH_ALI_START_ADDRRESS, ALI_HEATING_TABLE_SAVE_LEN,(uint8_t*)pstHeatTable);
    3c68:	6832      	ldr	r2, [r6, #0]
    3c6a:	2114      	movs	r1, #20
    3c6c:	0020      	movs	r0, r4
    3c6e:	f7fd fef9 	bl	1a64 <bc_flash_write>
}
    3c72:	bd73      	pop	{r0, r1, r4, r5, r6, pc}
    3c74:	10010514 	.word	0x10010514
    3c78:	000204c0 	.word	0x000204c0
    3c7c:	00020440 	.word	0x00020440
    3c80:	10011014 	.word	0x10011014

00003c84 <_param_init>:
	bc_flash_erase(FLASH_ALI_START_ADDRRESS, 1);	
	return 1;
}

static uint8_t _param_init(void)
{
    3c84:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	memset(pstHeatTable, 0, sizeof(ali_heating_table_t));
    3c86:	4c30      	ldr	r4, [pc, #192]	; (3d48 <_param_init+0xc4>)
    3c88:	22c0      	movs	r2, #192	; 0xc0
    3c8a:	6825      	ldr	r5, [r4, #0]
    3c8c:	2100      	movs	r1, #0
    3c8e:	0028      	movs	r0, r5
    3c90:	f011 fedc 	bl	15a4c <memset>
	//read saved parameter
	bc_flash_read(FLASH_ALI_START_ADDRRESS, ALI_HEATING_TABLE_SAVE_LEN,(uint8_t*)pstHeatTable);
    3c94:	002a      	movs	r2, r5
    3c96:	2114      	movs	r1, #20
    3c98:	2000      	movs	r0, #0
    3c9a:	f7fd fec5 	bl	1a28 <bc_flash_read>
	uint8_t tCrc = bc_sys_check_sum((uint8_t*)pstHeatTable, ALI_HEATING_TABLE_SAVE_LEN-1);
    3c9e:	2113      	movs	r1, #19
    3ca0:	6820      	ldr	r0, [r4, #0]
    3ca2:	f7fe fcf3 	bl	268c <bc_sys_check_sum>
	if(pstHeatTable->saveCfgCrc != tCrc){
    3ca6:	6825      	ldr	r5, [r4, #0]
    3ca8:	7ceb      	ldrb	r3, [r5, #19]
    3caa:	4283      	cmp	r3, r0
    3cac:	d008      	beq.n	3cc0 <_param_init+0x3c>
		memset((uint8_t*)pstHeatTable, 0, ALI_HEATING_TABLE_SAVE_LEN);
    3cae:	2214      	movs	r2, #20
    3cb0:	2100      	movs	r1, #0
    3cb2:	0028      	movs	r0, r5
    3cb4:	f011 feca 	bl	15a4c <memset>
		pstHeatTable->dType = ali_config_device_type_get();
    3cb8:	f000 fa84 	bl	41c4 <ali_config_device_type_get>
    3cbc:	70a8      	strb	r0, [r5, #2]
    3cbe:	e03e      	b.n	3d3e <_param_init+0xba>
	}else{
		if(pstHeatTable->dType != ali_config_device_type_get()){//change device type
    3cc0:	78ad      	ldrb	r5, [r5, #2]
    3cc2:	f000 fa7f 	bl	41c4 <ali_config_device_type_get>
    3cc6:	4285      	cmp	r5, r0
    3cc8:	d039      	beq.n	3d3e <_param_init+0xba>
			M_PRINTF(L_APP, "device type is changed [%d] to [%d]", pstHeatTable->dType, ali_config_device_type_get());
    3cca:	4b20      	ldr	r3, [pc, #128]	; (3d4c <_param_init+0xc8>)
    3ccc:	681b      	ldr	r3, [r3, #0]
    3cce:	049b      	lsls	r3, r3, #18
    3cd0:	d51b      	bpl.n	3d0a <_param_init+0x86>
    3cd2:	4e1f      	ldr	r6, [pc, #124]	; (3d50 <_param_init+0xcc>)
    3cd4:	4d1f      	ldr	r5, [pc, #124]	; (3d54 <_param_init+0xd0>)
    3cd6:	0033      	movs	r3, r6
    3cd8:	002a      	movs	r2, r5
    3cda:	0028      	movs	r0, r5
    3cdc:	3358      	adds	r3, #88	; 0x58
    3cde:	322c      	adds	r2, #44	; 0x2c
    3ce0:	0029      	movs	r1, r5
    3ce2:	9300      	str	r3, [sp, #0]
    3ce4:	303f      	adds	r0, #63	; 0x3f
    3ce6:	23a3      	movs	r3, #163	; 0xa3
    3ce8:	f000 fe60 	bl	49ac <m_print>
    3cec:	6823      	ldr	r3, [r4, #0]
    3cee:	789f      	ldrb	r7, [r3, #2]
    3cf0:	f000 fa68 	bl	41c4 <ali_config_device_type_get>
    3cf4:	0002      	movs	r2, r0
    3cf6:	0030      	movs	r0, r6
    3cf8:	0039      	movs	r1, r7
    3cfa:	3064      	adds	r0, #100	; 0x64
    3cfc:	f000 fe56 	bl	49ac <m_print>
    3d00:	0028      	movs	r0, r5
    3d02:	1da9      	adds	r1, r5, #6
    3d04:	3075      	adds	r0, #117	; 0x75
    3d06:	f000 fe51 	bl	49ac <m_print>
			bc_m_clear_config();
    3d0a:	f005 fae0 	bl	92ce <bc_m_clear_config>
			memset((uint8_t*)pstHeatTable, 0,  ALI_HEATING_TABLE_SAVE_LEN);
    3d0e:	6825      	ldr	r5, [r4, #0]
    3d10:	2214      	movs	r2, #20
    3d12:	2100      	movs	r1, #0
    3d14:	0028      	movs	r0, r5
    3d16:	f011 fe99 	bl	15a4c <memset>
			pstHeatTable->dType = ali_config_device_type_get();
    3d1a:	f000 fa53 	bl	41c4 <ali_config_device_type_get>
    3d1e:	70a8      	strb	r0, [r5, #2]
			pstHeatTable->saveCfgCrc = bc_sys_check_sum((uint8_t*)pstHeatTable, ALI_HEATING_TABLE_SAVE_LEN-1);
    3d20:	6825      	ldr	r5, [r4, #0]
    3d22:	2113      	movs	r1, #19
    3d24:	0028      	movs	r0, r5
    3d26:	f7fe fcb1 	bl	268c <bc_sys_check_sum>
			bc_flash_erase(FLASH_ALI_START_ADDRRESS, 1);
    3d2a:	2101      	movs	r1, #1
		if(pstHeatTable->dType != ali_config_device_type_get()){//change device type
			M_PRINTF(L_APP, "device type is changed [%d] to [%d]", pstHeatTable->dType, ali_config_device_type_get());
			bc_m_clear_config();
			memset((uint8_t*)pstHeatTable, 0,  ALI_HEATING_TABLE_SAVE_LEN);
			pstHeatTable->dType = ali_config_device_type_get();
			pstHeatTable->saveCfgCrc = bc_sys_check_sum((uint8_t*)pstHeatTable, ALI_HEATING_TABLE_SAVE_LEN-1);
    3d2c:	74e8      	strb	r0, [r5, #19]
			bc_flash_erase(FLASH_ALI_START_ADDRRESS, 1);
    3d2e:	2000      	movs	r0, #0
    3d30:	f7fd fe5a 	bl	19e8 <bc_flash_erase>
			bc_flash_write(FLASH_ALI_START_ADDRRESS, ALI_HEATING_TABLE_SAVE_LEN,(uint8_t*)pstHeatTable);
    3d34:	6822      	ldr	r2, [r4, #0]
    3d36:	2114      	movs	r1, #20
    3d38:	2000      	movs	r0, #0
    3d3a:	f7fd fe93 	bl	1a64 <bc_flash_write>
static void _ready_to_indicate(bool random);

/*********************Hardware Ctrl Start**********************/
static void _cw_init(light_cw_t* t)
{
	return led_cw_init(t);
    3d3e:	2000      	movs	r0, #0
    3d40:	f7fe f9f2 	bl	2128 <led_cw_init>
	}

	_cw_init(NULL);

	return 0;
}
    3d44:	2000      	movs	r0, #0
    3d46:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
    3d48:	10011014 	.word	0x10011014
    3d4c:	10010514 	.word	0x10010514
    3d50:	000204c0 	.word	0x000204c0
    3d54:	00020440 	.word	0x00020440

00003d58 <ali_heating_table_prov_state_cb>:

void ali_heating_table_prov_state_cb(uint8_t state)
{
    3d58:	b510      	push	{r4, lr}
#ifdef APP_FOR_ALI
	if(state == M_PROV_SUCCEED_APP){
    3d5a:	2803      	cmp	r0, #3
    3d5c:	d107      	bne.n	3d6e <ali_heating_table_prov_state_cb+0x16>
		SYS_SetTimer(&pstHeatTable->bindDelayTimer, (int)500/10, 
    3d5e:	4b04      	ldr	r3, [pc, #16]	; (3d70 <ali_heating_table_prov_state_cb+0x18>)
    3d60:	2200      	movs	r2, #0
    3d62:	6818      	ldr	r0, [r3, #0]
    3d64:	2132      	movs	r1, #50	; 0x32
    3d66:	302c      	adds	r0, #44	; 0x2c
    3d68:	4b02      	ldr	r3, [pc, #8]	; (3d74 <ali_heating_table_prov_state_cb+0x1c>)
    3d6a:	f7fd fff1 	bl	1d50 <SYS_SetTimer>
					TIMER_SINGLE, (Timer_Expire_CB)_bind_timer_cb);
		return;
	}
#endif 
}
    3d6e:	bd10      	pop	{r4, pc}
    3d70:	10011014 	.word	0x10011014
    3d74:	00003a81 	.word	0x00003a81

00003d78 <ali_heating_table_prov_state_get>:

uint8_t ali_heating_table_prov_state_get(void)
{
	M_PRINTF(L_APP, "bond status[%d]", pstHeatTable->provState);
    3d78:	4b12      	ldr	r3, [pc, #72]	; (3dc4 <ali_heating_table_prov_state_get+0x4c>)
	}
#endif 
}

uint8_t ali_heating_table_prov_state_get(void)
{
    3d7a:	b573      	push	{r0, r1, r4, r5, r6, lr}
	M_PRINTF(L_APP, "bond status[%d]", pstHeatTable->provState);
    3d7c:	681b      	ldr	r3, [r3, #0]
    3d7e:	4e12      	ldr	r6, [pc, #72]	; (3dc8 <ali_heating_table_prov_state_get+0x50>)
    3d80:	049b      	lsls	r3, r3, #18
    3d82:	d517      	bpl.n	3db4 <ali_heating_table_prov_state_get+0x3c>
    3d84:	4d11      	ldr	r5, [pc, #68]	; (3dcc <ali_heating_table_prov_state_get+0x54>)
    3d86:	4c12      	ldr	r4, [pc, #72]	; (3dd0 <ali_heating_table_prov_state_get+0x58>)
    3d88:	002b      	movs	r3, r5
    3d8a:	0022      	movs	r2, r4
    3d8c:	0020      	movs	r0, r4
    3d8e:	3308      	adds	r3, #8
    3d90:	322c      	adds	r2, #44	; 0x2c
    3d92:	9300      	str	r3, [sp, #0]
    3d94:	0021      	movs	r1, r4
    3d96:	23bf      	movs	r3, #191	; 0xbf
    3d98:	303f      	adds	r0, #63	; 0x3f
    3d9a:	f000 fe07 	bl	49ac <m_print>
    3d9e:	0028      	movs	r0, r5
    3da0:	6833      	ldr	r3, [r6, #0]
    3da2:	3029      	adds	r0, #41	; 0x29
    3da4:	7859      	ldrb	r1, [r3, #1]
    3da6:	f000 fe01 	bl	49ac <m_print>
    3daa:	0020      	movs	r0, r4
    3dac:	1da1      	adds	r1, r4, #6
    3dae:	3075      	adds	r0, #117	; 0x75
    3db0:	f000 fdfc 	bl	49ac <m_print>
	return pstHeatTable->provState == 1;
    3db4:	6833      	ldr	r3, [r6, #0]
    3db6:	7858      	ldrb	r0, [r3, #1]
    3db8:	3801      	subs	r0, #1
    3dba:	4242      	negs	r2, r0
    3dbc:	4142      	adcs	r2, r0
    3dbe:	b2d0      	uxtb	r0, r2
}
    3dc0:	bd76      	pop	{r1, r2, r4, r5, r6, pc}
    3dc2:	46c0      	nop			; (mov r8, r8)
    3dc4:	10010514 	.word	0x10010514
    3dc8:	10011014 	.word	0x10011014
    3dcc:	00020540 	.word	0x00020540
    3dd0:	00020440 	.word	0x00020440

00003dd4 <ali_heating_table_factory_reset>:

void ali_heating_table_factory_reset()
{
    3dd4:	b510      	push	{r4, lr}
	bc_m_clear_config();
    3dd6:	f005 fa7a 	bl	92ce <bc_m_clear_config>
	bc_flash_erase(FLASH_ALI_START_ADDRRESS, 1);
    3dda:	2101      	movs	r1, #1
    3ddc:	2000      	movs	r0, #0
    3dde:	f7fd fe03 	bl	19e8 <bc_flash_erase>
	bc_sys_reset();
    3de2:	f7fe fc4b 	bl	267c <bc_sys_reset>
}
    3de6:	bd10      	pop	{r4, pc}

00003de8 <ali_heating_table_init>:

uint8_t ali_heating_table_init(mesh_model_t** mdl, uint8_t* mcnt)
{
    3de8:	b5f0      	push	{r4, r5, r6, r7, lr}
	M_PRINTF(L_APP, "-------init light---------");
    3dea:	4d67      	ldr	r5, [pc, #412]	; (3f88 <ali_heating_table_init+0x1a0>)
	bc_flash_erase(FLASH_ALI_START_ADDRRESS, 1);
	bc_sys_reset();
}

uint8_t ali_heating_table_init(mesh_model_t** mdl, uint8_t* mcnt)
{
    3dec:	b087      	sub	sp, #28
	M_PRINTF(L_APP, "-------init light---------");
    3dee:	682b      	ldr	r3, [r5, #0]
	bc_flash_erase(FLASH_ALI_START_ADDRRESS, 1);
	bc_sys_reset();
}

uint8_t ali_heating_table_init(mesh_model_t** mdl, uint8_t* mcnt)
{
    3df0:	9004      	str	r0, [sp, #16]
    3df2:	9105      	str	r1, [sp, #20]
	M_PRINTF(L_APP, "-------init light---------");
    3df4:	049b      	lsls	r3, r3, #18
    3df6:	d515      	bpl.n	3e24 <ali_heating_table_init+0x3c>
    3df8:	4e64      	ldr	r6, [pc, #400]	; (3f8c <ali_heating_table_init+0x1a4>)
    3dfa:	4c65      	ldr	r4, [pc, #404]	; (3f90 <ali_heating_table_init+0x1a8>)
    3dfc:	0033      	movs	r3, r6
    3dfe:	0022      	movs	r2, r4
    3e00:	0020      	movs	r0, r4
    3e02:	3339      	adds	r3, #57	; 0x39
    3e04:	0021      	movs	r1, r4
    3e06:	322c      	adds	r2, #44	; 0x2c
    3e08:	9300      	str	r3, [sp, #0]
    3e0a:	303f      	adds	r0, #63	; 0x3f
    3e0c:	23cc      	movs	r3, #204	; 0xcc
    3e0e:	f000 fdcd 	bl	49ac <m_print>
    3e12:	0030      	movs	r0, r6
    3e14:	3050      	adds	r0, #80	; 0x50
    3e16:	f000 fdc9 	bl	49ac <m_print>
    3e1a:	0020      	movs	r0, r4
    3e1c:	1da1      	adds	r1, r4, #6
    3e1e:	3075      	adds	r0, #117	; 0x75
    3e20:	f000 fdc4 	bl	49ac <m_print>
	pstHeatTable = ke_malloc(sizeof(ali_heating_table_t), 0);
    3e24:	2100      	movs	r1, #0
    3e26:	20c0      	movs	r0, #192	; 0xc0
    3e28:	f003 fa5a 	bl	72e0 <ke_malloc>
    3e2c:	4c59      	ldr	r4, [pc, #356]	; (3f94 <ali_heating_table_init+0x1ac>)
    3e2e:	0003      	movs	r3, r0
    3e30:	6020      	str	r0, [r4, #0]
	if(pstHeatTable == NULL)
		return 1;
    3e32:	2001      	movs	r0, #1

uint8_t ali_heating_table_init(mesh_model_t** mdl, uint8_t* mcnt)
{
	M_PRINTF(L_APP, "-------init light---------");
	pstHeatTable = ke_malloc(sizeof(ali_heating_table_t), 0);
	if(pstHeatTable == NULL)
    3e34:	2b00      	cmp	r3, #0
    3e36:	d100      	bne.n	3e3a <ali_heating_table_init+0x52>
    3e38:	e0a3      	b.n	3f82 <ali_heating_table_init+0x19a>
		return 1;
	
	_param_init();
    3e3a:	f7ff ff23 	bl	3c84 <_param_init>
	bc_flash_write(FLASH_ALI_START_ADDRRESS, ALI_HEATING_TABLE_SAVE_LEN,(uint8_t*)pstHeatTable);
}

static uint8_t _quick_restore_init(void)
{
	if(pstHeatTable->quickTime++ < ALI_QUICK_START_CNT){//0 1 2 3 4
    3e3e:	6826      	ldr	r6, [r4, #0]
    3e40:	7833      	ldrb	r3, [r6, #0]
    3e42:	1c5a      	adds	r2, r3, #1
    3e44:	7032      	strb	r2, [r6, #0]
    3e46:	2b04      	cmp	r3, #4
    3e48:	d80e      	bhi.n	3e68 <ali_heating_table_init+0x80>
		pstHeatTable->saveCfgCrc = bc_sys_check_sum((uint8_t*)pstHeatTable, ALI_HEATING_TABLE_SAVE_LEN-1);
    3e4a:	2113      	movs	r1, #19
    3e4c:	0030      	movs	r0, r6
    3e4e:	f7fe fc1d 	bl	268c <bc_sys_check_sum>
		bc_flash_erase(FLASH_ALI_START_ADDRRESS, 1);
    3e52:	2101      	movs	r1, #1
}

static uint8_t _quick_restore_init(void)
{
	if(pstHeatTable->quickTime++ < ALI_QUICK_START_CNT){//0 1 2 3 4
		pstHeatTable->saveCfgCrc = bc_sys_check_sum((uint8_t*)pstHeatTable, ALI_HEATING_TABLE_SAVE_LEN-1);
    3e54:	74f0      	strb	r0, [r6, #19]
		bc_flash_erase(FLASH_ALI_START_ADDRRESS, 1);
    3e56:	2000      	movs	r0, #0
    3e58:	f7fd fdc6 	bl	19e8 <bc_flash_erase>
		bc_flash_write(FLASH_ALI_START_ADDRRESS, ALI_HEATING_TABLE_SAVE_LEN,(uint8_t*)pstHeatTable);
    3e5c:	6822      	ldr	r2, [r4, #0]
    3e5e:	2114      	movs	r1, #20
    3e60:	2000      	movs	r0, #0
    3e62:	f7fd fdff 	bl	1a64 <bc_flash_write>
    3e66:	e055      	b.n	3f14 <ali_heating_table_init+0x12c>
		return 0;
	}
	M_PRINTF(L_APP, "");
    3e68:	682b      	ldr	r3, [r5, #0]
    3e6a:	049b      	lsls	r3, r3, #18
    3e6c:	d514      	bpl.n	3e98 <ali_heating_table_init+0xb0>
    3e6e:	4d48      	ldr	r5, [pc, #288]	; (3f90 <ali_heating_table_init+0x1a8>)
    3e70:	4b46      	ldr	r3, [pc, #280]	; (3f8c <ali_heating_table_init+0x1a4>)
    3e72:	002a      	movs	r2, r5
    3e74:	0028      	movs	r0, r5
    3e76:	336b      	adds	r3, #107	; 0x6b
    3e78:	0029      	movs	r1, r5
    3e7a:	322c      	adds	r2, #44	; 0x2c
    3e7c:	9300      	str	r3, [sp, #0]
    3e7e:	303f      	adds	r0, #63	; 0x3f
    3e80:	2385      	movs	r3, #133	; 0x85
    3e82:	f000 fd93 	bl	49ac <m_print>
    3e86:	4844      	ldr	r0, [pc, #272]	; (3f98 <ali_heating_table_init+0x1b0>)
    3e88:	3057      	adds	r0, #87	; 0x57
    3e8a:	f000 fd8f 	bl	49ac <m_print>
    3e8e:	0028      	movs	r0, r5
    3e90:	1da9      	adds	r1, r5, #6
    3e92:	3075      	adds	r0, #117	; 0x75
    3e94:	f000 fd8a 	bl	49ac <m_print>
	//TODO: 1HZ flash 3 timers
	uint8_t i = 6;
	uint32_t t = mesh_timer_get_time();
    3e98:	f002 fa48 	bl	632c <mesh_timer_get_time>
    3e9c:	2506      	movs	r5, #6
    3e9e:	9002      	str	r0, [sp, #8]
	do{
		while(mesh_timer_get_time()-t < ALI_QUICK_BLINK_TIME){//delay 1s
    3ea0:	f002 fa44 	bl	632c <mesh_timer_get_time>
    3ea4:	9b02      	ldr	r3, [sp, #8]
    3ea6:	1ac0      	subs	r0, r0, r3
    3ea8:	4b3c      	ldr	r3, [pc, #240]	; (3f9c <ali_heating_table_init+0x1b4>)
    3eaa:	4298      	cmp	r0, r3
    3eac:	d9f8      	bls.n	3ea0 <ali_heating_table_init+0xb8>
			continue;
		}
		t = mesh_timer_get_time();
    3eae:	f002 fa3d 	bl	632c <mesh_timer_get_time>
		led_cw_set_on_off(i%2,NULL);
    3eb2:	2301      	movs	r3, #1
    3eb4:	402b      	ands	r3, r5
	uint32_t t = mesh_timer_get_time();
	do{
		while(mesh_timer_get_time()-t < ALI_QUICK_BLINK_TIME){//delay 1s
			continue;
		}
		t = mesh_timer_get_time();
    3eb6:	9002      	str	r0, [sp, #8]
		led_cw_set_on_off(i%2,NULL);
    3eb8:	2100      	movs	r1, #0
    3eba:	0018      	movs	r0, r3
    3ebc:	9303      	str	r3, [sp, #12]
    3ebe:	f7fe f90b 	bl	20d8 <led_cw_set_on_off>
		M_PRINTF(L_APP, "led status = %d", i%2);
    3ec2:	2280      	movs	r2, #128	; 0x80
    3ec4:	4b30      	ldr	r3, [pc, #192]	; (3f88 <ali_heating_table_init+0x1a0>)
    3ec6:	0192      	lsls	r2, r2, #6
    3ec8:	681b      	ldr	r3, [r3, #0]
    3eca:	4213      	tst	r3, r2
    3ecc:	d016      	beq.n	3efc <ali_heating_table_init+0x114>
    3ece:	4f2f      	ldr	r7, [pc, #188]	; (3f8c <ali_heating_table_init+0x1a4>)
    3ed0:	4e2f      	ldr	r6, [pc, #188]	; (3f90 <ali_heating_table_init+0x1a8>)
    3ed2:	003b      	movs	r3, r7
    3ed4:	0032      	movs	r2, r6
    3ed6:	0030      	movs	r0, r6
    3ed8:	336b      	adds	r3, #107	; 0x6b
    3eda:	322c      	adds	r2, #44	; 0x2c
    3edc:	9300      	str	r3, [sp, #0]
    3ede:	0031      	movs	r1, r6
    3ee0:	238f      	movs	r3, #143	; 0x8f
    3ee2:	303f      	adds	r0, #63	; 0x3f
    3ee4:	f000 fd62 	bl	49ac <m_print>
    3ee8:	0038      	movs	r0, r7
    3eea:	9903      	ldr	r1, [sp, #12]
    3eec:	307f      	adds	r0, #127	; 0x7f
    3eee:	f000 fd5d 	bl	49ac <m_print>
    3ef2:	0030      	movs	r0, r6
    3ef4:	1db1      	adds	r1, r6, #6
    3ef6:	3075      	adds	r0, #117	; 0x75
    3ef8:	f000 fd58 	bl	49ac <m_print>
    3efc:	3d01      	subs	r5, #1
    3efe:	b2ed      	uxtb	r5, r5
	}while(i-->1);
    3f00:	2d00      	cmp	r5, #0
    3f02:	d1cd      	bne.n	3ea0 <ali_heating_table_init+0xb8>
	//restore flash parameter
	bc_m_clear_config();
    3f04:	f005 f9e3 	bl	92ce <bc_m_clear_config>
	//clear quick count
	bc_flash_erase(FLASH_ALI_START_ADDRRESS, 1);	
    3f08:	2101      	movs	r1, #1
    3f0a:	0028      	movs	r0, r5
    3f0c:	f7fd fd6c 	bl	19e8 <bc_flash_erase>
		return 1;
	
	_param_init();
	//ali local quick restore parameter
	if(1 == _quick_restore_init()){
		_param_init();//reinit
    3f10:	f7ff feb8 	bl	3c84 <_param_init>
	}
	
	//start timer for clear
	SYS_SetTimer(&pstHeatTable->startDelayTimer, (int)ALI_QUICK_START_TIME/10, 
    3f14:	21fa      	movs	r1, #250	; 0xfa
    3f16:	6820      	ldr	r0, [r4, #0]
    3f18:	4b21      	ldr	r3, [pc, #132]	; (3fa0 <ali_heating_table_init+0x1b8>)
    3f1a:	2200      	movs	r2, #0
    3f1c:	0049      	lsls	r1, r1, #1
    3f1e:	3014      	adds	r0, #20
    3f20:	f7fd ff16 	bl	1d50 <SYS_SetTimer>
					TIMER_SINGLE, (Timer_Expire_CB)_quick_restore_timer_cb);

	pstHeatTable->oo_ctrl.set = _cw_set_on_off;
    3f24:	6822      	ldr	r2, [r4, #0]
    3f26:	4b1f      	ldr	r3, [pc, #124]	; (3fa4 <ali_heating_table_init+0x1bc>)
    3f28:	0011      	movs	r1, r2
    3f2a:	31a0      	adds	r1, #160	; 0xa0
    3f2c:	600b      	str	r3, [r1, #0]
	pstHeatTable->oo_ctrl.get = _cw_get_on_off;
    3f2e:	0013      	movs	r3, r2
    3f30:	481d      	ldr	r0, [pc, #116]	; (3fa8 <ali_heating_table_init+0x1c0>)
    3f32:	33a4      	adds	r3, #164	; 0xa4
    3f34:	6018      	str	r0, [r3, #0]
	mesh_model_t* tmModel = &pstHeatTable->model[pstHeatTable->model_cnt++];
    3f36:	0010      	movs	r0, r2
    3f38:	305e      	adds	r0, #94	; 0x5e
    3f3a:	7803      	ldrb	r3, [r0, #0]
    3f3c:	1c5d      	adds	r5, r3, #1
    3f3e:	7005      	strb	r5, [r0, #0]
	tmModel->offset = 0;//element num
    3f40:	2500      	movs	r5, #0
    3f42:	1d98      	adds	r0, r3, #6
    3f44:	0100      	lsls	r0, r0, #4
    3f46:	1810      	adds	r0, r2, r0
    3f48:	7105      	strb	r5, [r0, #4]
	bc_mm_gens_oo_init(tmModel, &pstHeatTable->oo_ctrl);
    3f4a:	f001 ffe1 	bl	5f10 <bc_mm_gens_oo_init>

	tmModel = &pstHeatTable->model[pstHeatTable->model_cnt++];
    3f4e:	6822      	ldr	r2, [r4, #0]
    3f50:	0011      	movs	r1, r2
    3f52:	315e      	adds	r1, #94	; 0x5e
    3f54:	780b      	ldrb	r3, [r1, #0]
    3f56:	1c58      	adds	r0, r3, #1
    3f58:	7008      	strb	r0, [r1, #0]
	tmModel->offset = 0;//element num
    3f5a:	1d98      	adds	r0, r3, #6
    3f5c:	0100      	lsls	r0, r0, #4
    3f5e:	1810      	adds	r0, r2, r0
	bc_mm_alis_vendor_init(tmModel, NULL);
    3f60:	0029      	movs	r1, r5
	mesh_model_t* tmModel = &pstHeatTable->model[pstHeatTable->model_cnt++];
	tmModel->offset = 0;//element num
	bc_mm_gens_oo_init(tmModel, &pstHeatTable->oo_ctrl);

	tmModel = &pstHeatTable->model[pstHeatTable->model_cnt++];
	tmModel->offset = 0;//element num
    3f62:	7105      	strb	r5, [r0, #4]
	bc_mm_alis_vendor_init(tmModel, NULL);
    3f64:	f001 fece 	bl	5d04 <bc_mm_alis_vendor_init>
	
	*mdl = pstHeatTable->model;
    3f68:	6823      	ldr	r3, [r4, #0]
    3f6a:	9904      	ldr	r1, [sp, #16]
    3f6c:	001a      	movs	r2, r3
    3f6e:	3260      	adds	r2, #96	; 0x60
    3f70:	600a      	str	r2, [r1, #0]
	*mcnt = pstHeatTable->model_cnt;
    3f72:	335e      	adds	r3, #94	; 0x5e
    3f74:	781b      	ldrb	r3, [r3, #0]
    3f76:	9a05      	ldr	r2, [sp, #20]

	//if bond
	_ready_to_indicate(true);
    3f78:	2001      	movs	r0, #1
	tmModel = &pstHeatTable->model[pstHeatTable->model_cnt++];
	tmModel->offset = 0;//element num
	bc_mm_alis_vendor_init(tmModel, NULL);
	
	*mdl = pstHeatTable->model;
	*mcnt = pstHeatTable->model_cnt;
    3f7a:	7013      	strb	r3, [r2, #0]

	//if bond
	_ready_to_indicate(true);
    3f7c:	f7ff fd5c 	bl	3a38 <_ready_to_indicate>

//	_key_init();
	return 0;
    3f80:	0028      	movs	r0, r5
}
    3f82:	b007      	add	sp, #28
    3f84:	bdf0      	pop	{r4, r5, r6, r7, pc}
    3f86:	46c0      	nop			; (mov r8, r8)
    3f88:	10010514 	.word	0x10010514
    3f8c:	00020540 	.word	0x00020540
    3f90:	00020440 	.word	0x00020440
    3f94:	10011014 	.word	0x10011014
    3f98:	000204c0 	.word	0x000204c0
    3f9c:	000003e7 	.word	0x000003e7
    3fa0:	00003c19 	.word	0x00003c19
    3fa4:	00003a21 	.word	0x00003a21
    3fa8:	00003a31 	.word	0x00003a31

00003fac <ali_heating_table_deinit>:

uint8_t ali_heating_table_deinit(mesh_model_t** mdl)
{
    3fac:	b570      	push	{r4, r5, r6, lr}
	bc_mm_alis_vendor_deinit(&pstHeatTable->model[--pstHeatTable->model_cnt]);
    3fae:	4c12      	ldr	r4, [pc, #72]	; (3ff8 <ali_heating_table_deinit+0x4c>)
//	_key_init();
	return 0;
}

uint8_t ali_heating_table_deinit(mesh_model_t** mdl)
{
    3fb0:	0005      	movs	r5, r0
	bc_mm_alis_vendor_deinit(&pstHeatTable->model[--pstHeatTable->model_cnt]);
    3fb2:	6822      	ldr	r2, [r4, #0]
    3fb4:	0011      	movs	r1, r2
    3fb6:	315e      	adds	r1, #94	; 0x5e
    3fb8:	780b      	ldrb	r3, [r1, #0]
    3fba:	3b01      	subs	r3, #1
    3fbc:	b2db      	uxtb	r3, r3
    3fbe:	1d98      	adds	r0, r3, #6
    3fc0:	0100      	lsls	r0, r0, #4
    3fc2:	700b      	strb	r3, [r1, #0]
    3fc4:	1810      	adds	r0, r2, r0
    3fc6:	f001 febf 	bl	5d48 <bc_mm_alis_vendor_deinit>
	bc_mm_gens_oo_deinit(&pstHeatTable->model[--pstHeatTable->model_cnt]);
    3fca:	6822      	ldr	r2, [r4, #0]
    3fcc:	0011      	movs	r1, r2
    3fce:	315e      	adds	r1, #94	; 0x5e
    3fd0:	780b      	ldrb	r3, [r1, #0]
    3fd2:	3b01      	subs	r3, #1
    3fd4:	b2db      	uxtb	r3, r3
    3fd6:	1d98      	adds	r0, r3, #6
    3fd8:	0100      	lsls	r0, r0, #4
    3fda:	700b      	strb	r3, [r1, #0]
    3fdc:	1810      	adds	r0, r2, r0
    3fde:	f001 ffb9 	bl	5f54 <bc_mm_gens_oo_deinit>
	if(pstHeatTable){
    3fe2:	6820      	ldr	r0, [r4, #0]
    3fe4:	2800      	cmp	r0, #0
    3fe6:	d003      	beq.n	3ff0 <ali_heating_table_deinit+0x44>
		ke_free(pstHeatTable);
    3fe8:	f003 f97e 	bl	72e8 <ke_free>
		pstHeatTable = NULL;
    3fec:	2300      	movs	r3, #0
    3fee:	6023      	str	r3, [r4, #0]
	}
	*mdl = NULL;
    3ff0:	2000      	movs	r0, #0
    3ff2:	6028      	str	r0, [r5, #0]
	return 0;
}
    3ff4:	bd70      	pop	{r4, r5, r6, pc}
    3ff6:	46c0      	nop			; (mov r8, r8)
    3ff8:	10011014 	.word	0x10011014

00003ffc <ali_config_uuid_read>:


static ali_cfg_t* p_ali_cfg;

bool ali_config_uuid_read(ali_uuid_t *uuid)
{
    3ffc:	b573      	push	{r0, r1, r4, r5, r6, lr}
    3ffe:	0004      	movs	r4, r0
	/** set device uuid */
	uint8_t mac[FLASH_ALI_MAC_ADDR_LEN];
	ali_config_mac_read(mac,0);
    4000:	2100      	movs	r1, #0
    4002:	4668      	mov	r0, sp
    4004:	f000 f8c8 	bl	4198 <ali_config_mac_read>

	memcpy(uuid->mac_addr, mac, FLASH_ALI_MAC_ADDR_LEN);
    4008:	4669      	mov	r1, sp
    400a:	1de0      	adds	r0, r4, #7
    400c:	2206      	movs	r2, #6
    400e:	f011 fcdf 	bl	159d0 <memcpy>
	uuid->cid = ALI_CID;
    4012:	2358      	movs	r3, #88	; 0x58
	uuid->pid.adv_ver = BLE_VER_4_2;
    4014:	220f      	movs	r2, #15
	/** set device uuid */
	uint8_t mac[FLASH_ALI_MAC_ADDR_LEN];
	ali_config_mac_read(mac,0);

	memcpy(uuid->mac_addr, mac, FLASH_ALI_MAC_ADDR_LEN);
	uuid->cid = ALI_CID;
    4016:	2501      	movs	r5, #1
    4018:	425b      	negs	r3, r3
    401a:	7023      	strb	r3, [r4, #0]
	uuid->pid.adv_ver = BLE_VER_4_2;
    401c:	78a3      	ldrb	r3, [r4, #2]
	/** set device uuid */
	uint8_t mac[FLASH_ALI_MAC_ADDR_LEN];
	ali_config_mac_read(mac,0);

	memcpy(uuid->mac_addr, mac, FLASH_ALI_MAC_ADDR_LEN);
	uuid->cid = ALI_CID;
    401e:	7065      	strb	r5, [r4, #1]
	uuid->pid.adv_ver = BLE_VER_4_2;
    4020:	4393      	bics	r3, r2
	uuid->pid.sec = SEC_ONE_DEV_ONE_SECRET;
    4022:	432b      	orrs	r3, r5
	uuid->pid.ota = OTA_UNSUPPORT;
    4024:	1952      	adds	r2, r2, r5
    4026:	4313      	orrs	r3, r2
	uuid->pid.bt_ver = BLE_ADV_VER;
    4028:	320f      	adds	r2, #15
    402a:	4013      	ands	r3, r2
    402c:	3221      	adds	r2, #33	; 0x21
    402e:	4313      	orrs	r3, r2
    4030:	70a3      	strb	r3, [r4, #2]
	uuid->product_id = p_ali_cfg->pid;// PRODUCT ID
    4032:	4b0e      	ldr	r3, [pc, #56]	; (406c <ali_config_uuid_read+0x70>)
    4034:	681e      	ldr	r6, [r3, #0]
    4036:	7872      	ldrb	r2, [r6, #1]
    4038:	7830      	ldrb	r0, [r6, #0]
    403a:	78b3      	ldrb	r3, [r6, #2]
    403c:	0212      	lsls	r2, r2, #8
    403e:	4302      	orrs	r2, r0
    4040:	041b      	lsls	r3, r3, #16
    4042:	4313      	orrs	r3, r2
    4044:	001a      	movs	r2, r3
    4046:	78f3      	ldrb	r3, [r6, #3]

	uuid->feature_flag = (ALI_UUID_VER_2<<1) |BLE_ADV_STATE_UNPROV;
	memset(uuid->rfu, 0, sizeof(uuid->rfu));
    4048:	0020      	movs	r0, r4
	uuid->cid = ALI_CID;
	uuid->pid.adv_ver = BLE_VER_4_2;
	uuid->pid.sec = SEC_ONE_DEV_ONE_SECRET;
	uuid->pid.ota = OTA_UNSUPPORT;
	uuid->pid.bt_ver = BLE_ADV_VER;
	uuid->product_id = p_ali_cfg->pid;// PRODUCT ID
    404a:	061b      	lsls	r3, r3, #24
    404c:	4313      	orrs	r3, r2

	uuid->feature_flag = (ALI_UUID_VER_2<<1) |BLE_ADV_STATE_UNPROV;
    404e:	2202      	movs	r2, #2
	uuid->cid = ALI_CID;
	uuid->pid.adv_ver = BLE_VER_4_2;
	uuid->pid.sec = SEC_ONE_DEV_ONE_SECRET;
	uuid->pid.ota = OTA_UNSUPPORT;
	uuid->pid.bt_ver = BLE_ADV_VER;
	uuid->product_id = p_ali_cfg->pid;// PRODUCT ID
    4050:	0a19      	lsrs	r1, r3, #8
    4052:	70e3      	strb	r3, [r4, #3]
    4054:	7121      	strb	r1, [r4, #4]
    4056:	0c19      	lsrs	r1, r3, #16
    4058:	0e1b      	lsrs	r3, r3, #24
    405a:	7161      	strb	r1, [r4, #5]
    405c:	71a3      	strb	r3, [r4, #6]

	uuid->feature_flag = (ALI_UUID_VER_2<<1) |BLE_ADV_STATE_UNPROV;
    405e:	7362      	strb	r2, [r4, #13]
	memset(uuid->rfu, 0, sizeof(uuid->rfu));
    4060:	2100      	movs	r1, #0
    4062:	300e      	adds	r0, #14
    4064:	f011 fcf2 	bl	15a4c <memset>
	return true;
}
    4068:	0028      	movs	r0, r5
    406a:	bd76      	pop	{r1, r2, r4, r5, r6, pc}
    406c:	10011018 	.word	0x10011018

00004070 <ali_config_static_uuid_read>:

bool ali_config_static_uuid_read(ali_uuid_t *uuid)
{
    4070:	b573      	push	{r0, r1, r4, r5, r6, lr}
    4072:	0004      	movs	r4, r0
	/** set device uuid */
	uint8_t mac[FLASH_ALI_MAC_ADDR_LEN];
	ali_config_mac_read(mac,0);
    4074:	2100      	movs	r1, #0
    4076:	4668      	mov	r0, sp
    4078:	f000 f88e 	bl	4198 <ali_config_mac_read>

	memcpy(uuid->mac_addr, mac, FLASH_ALI_MAC_ADDR_LEN);
    407c:	4669      	mov	r1, sp
    407e:	1de0      	adds	r0, r4, #7
    4080:	2206      	movs	r2, #6
    4082:	f011 fca5 	bl	159d0 <memcpy>
	uuid->cid = ALI_CID;
    4086:	2358      	movs	r3, #88	; 0x58
	uuid->pid.adv_ver = BLE_VER_4_2;
    4088:	220f      	movs	r2, #15
	/** set device uuid */
	uint8_t mac[FLASH_ALI_MAC_ADDR_LEN];
	ali_config_mac_read(mac,0);

	memcpy(uuid->mac_addr, mac, FLASH_ALI_MAC_ADDR_LEN);
	uuid->cid = ALI_CID;
    408a:	2501      	movs	r5, #1
    408c:	425b      	negs	r3, r3
    408e:	7023      	strb	r3, [r4, #0]
	uuid->pid.adv_ver = BLE_VER_4_2;
    4090:	78a3      	ldrb	r3, [r4, #2]
	/** set device uuid */
	uint8_t mac[FLASH_ALI_MAC_ADDR_LEN];
	ali_config_mac_read(mac,0);

	memcpy(uuid->mac_addr, mac, FLASH_ALI_MAC_ADDR_LEN);
	uuid->cid = ALI_CID;
    4092:	7065      	strb	r5, [r4, #1]
	uuid->pid.adv_ver = BLE_VER_4_2;
    4094:	4393      	bics	r3, r2
	uuid->pid.sec = SEC_ONE_DEV_ONE_SECRET;
    4096:	432b      	orrs	r3, r5
	uuid->pid.ota = OTA_UNSUPPORT;
    4098:	1952      	adds	r2, r2, r5
    409a:	4313      	orrs	r3, r2
	uuid->pid.bt_ver = BLE_ADV_VER;
    409c:	320f      	adds	r2, #15
    409e:	4013      	ands	r3, r2
    40a0:	3221      	adds	r2, #33	; 0x21
    40a2:	4313      	orrs	r3, r2
    40a4:	70a3      	strb	r3, [r4, #2]
	uuid->product_id = p_ali_cfg->pid;// PRODUCT ID
    40a6:	4b0f      	ldr	r3, [pc, #60]	; (40e4 <ali_config_static_uuid_read+0x74>)
    40a8:	681e      	ldr	r6, [r3, #0]
    40aa:	7872      	ldrb	r2, [r6, #1]
    40ac:	7830      	ldrb	r0, [r6, #0]
    40ae:	78b3      	ldrb	r3, [r6, #2]
    40b0:	0212      	lsls	r2, r2, #8
    40b2:	4302      	orrs	r2, r0
    40b4:	041b      	lsls	r3, r3, #16
    40b6:	4313      	orrs	r3, r2
    40b8:	001a      	movs	r2, r3
    40ba:	78f3      	ldrb	r3, [r6, #3]

	uuid->feature_flag = (ALI_UUID_VER_2<<1) |BLE_ADV_STATE_STATIC;
	memset(uuid->rfu, 0, sizeof(uuid->rfu));
    40bc:	0020      	movs	r0, r4
	uuid->cid = ALI_CID;
	uuid->pid.adv_ver = BLE_VER_4_2;
	uuid->pid.sec = SEC_ONE_DEV_ONE_SECRET;
	uuid->pid.ota = OTA_UNSUPPORT;
	uuid->pid.bt_ver = BLE_ADV_VER;
	uuid->product_id = p_ali_cfg->pid;// PRODUCT ID
    40be:	061b      	lsls	r3, r3, #24
    40c0:	4313      	orrs	r3, r2
    40c2:	0a19      	lsrs	r1, r3, #8
    40c4:	70e3      	strb	r3, [r4, #3]
    40c6:	7121      	strb	r1, [r4, #4]
    40c8:	0c19      	lsrs	r1, r3, #16
    40ca:	0e1b      	lsrs	r3, r3, #24
    40cc:	71a3      	strb	r3, [r4, #6]

	uuid->feature_flag = (ALI_UUID_VER_2<<1) |BLE_ADV_STATE_STATIC;
    40ce:	2303      	movs	r3, #3
	uuid->cid = ALI_CID;
	uuid->pid.adv_ver = BLE_VER_4_2;
	uuid->pid.sec = SEC_ONE_DEV_ONE_SECRET;
	uuid->pid.ota = OTA_UNSUPPORT;
	uuid->pid.bt_ver = BLE_ADV_VER;
	uuid->product_id = p_ali_cfg->pid;// PRODUCT ID
    40d0:	7161      	strb	r1, [r4, #5]

	uuid->feature_flag = (ALI_UUID_VER_2<<1) |BLE_ADV_STATE_STATIC;
    40d2:	7363      	strb	r3, [r4, #13]
	memset(uuid->rfu, 0, sizeof(uuid->rfu));
    40d4:	2202      	movs	r2, #2
    40d6:	2100      	movs	r1, #0
    40d8:	300e      	adds	r0, #14
    40da:	f011 fcb7 	bl	15a4c <memset>
	return true;
}
    40de:	0028      	movs	r0, r5
    40e0:	bd76      	pop	{r1, r2, r4, r5, r6, pc}
    40e2:	46c0      	nop			; (mov r8, r8)
    40e4:	10011018 	.word	0x10011018

000040e8 <ali_config_auth_val_read>:


bool ali_config_auth_val_read(uint8_t *key)
{
	for(int i = 0; i < FLASH_ALI_SEC_LEN; ++i){
		key[i] = p_ali_cfg->authval[FLASH_ALI_SEC_LEN - 1 - i];
    40e8:	4b0b      	ldr	r3, [pc, #44]	; (4118 <ali_config_auth_val_read+0x30>)
}



bool ali_config_auth_val_read(uint8_t *key)
{
    40ea:	b510      	push	{r4, lr}
	for(int i = 0; i < FLASH_ALI_SEC_LEN; ++i){
		key[i] = p_ali_cfg->authval[FLASH_ALI_SEC_LEN - 1 - i];
    40ec:	681b      	ldr	r3, [r3, #0]
}



bool ali_config_auth_val_read(uint8_t *key)
{
    40ee:	0002      	movs	r2, r0
    40f0:	0019      	movs	r1, r3
    40f2:	0004      	movs	r4, r0
    40f4:	3129      	adds	r1, #41	; 0x29
    40f6:	3319      	adds	r3, #25
	for(int i = 0; i < FLASH_ALI_SEC_LEN; ++i){
		key[i] = p_ali_cfg->authval[FLASH_ALI_SEC_LEN - 1 - i];
    40f8:	7808      	ldrb	r0, [r1, #0]
    40fa:	3901      	subs	r1, #1
    40fc:	7020      	strb	r0, [r4, #0]
    40fe:	3401      	adds	r4, #1



bool ali_config_auth_val_read(uint8_t *key)
{
	for(int i = 0; i < FLASH_ALI_SEC_LEN; ++i){
    4100:	4299      	cmp	r1, r3
    4102:	d1f9      	bne.n	40f8 <ali_config_auth_val_read+0x10>
		key[i] = p_ali_cfg->authval[FLASH_ALI_SEC_LEN - 1 - i];
	}
    m_printf_hex(L_APP, "ali_config_auth_val_read", key, FLASH_ALI_SEC_LEN);
    4104:	2080      	movs	r0, #128	; 0x80
    4106:	4905      	ldr	r1, [pc, #20]	; (411c <ali_config_auth_val_read+0x34>)
    4108:	2310      	movs	r3, #16
    410a:	3109      	adds	r1, #9
    410c:	0180      	lsls	r0, r0, #6
    410e:	f000 fcad 	bl	4a6c <m_printf_hex>
    return true;
}
    4112:	2001      	movs	r0, #1
    4114:	bd10      	pop	{r4, pc}
    4116:	46c0      	nop			; (mov r8, r8)
    4118:	10011018 	.word	0x10011018
    411c:	000205cf 	.word	0x000205cf

00004120 <ali_config_pid_read>:

uint32_t ali_config_pid_read(void)
{
	M_PRINTF(L_APP, "product_id = %d\r\n", p_ali_cfg->pid);
    4120:	4b1a      	ldr	r3, [pc, #104]	; (418c <ali_config_pid_read+0x6c>)
    m_printf_hex(L_APP, "ali_config_auth_val_read", key, FLASH_ALI_SEC_LEN);
    return true;
}

uint32_t ali_config_pid_read(void)
{
    4122:	b573      	push	{r0, r1, r4, r5, r6, lr}
	M_PRINTF(L_APP, "product_id = %d\r\n", p_ali_cfg->pid);
    4124:	681b      	ldr	r3, [r3, #0]
    4126:	4d1a      	ldr	r5, [pc, #104]	; (4190 <ali_config_pid_read+0x70>)
    4128:	049b      	lsls	r3, r3, #18
    412a:	d521      	bpl.n	4170 <ali_config_pid_read+0x50>
    412c:	4c19      	ldr	r4, [pc, #100]	; (4194 <ali_config_pid_read+0x74>)
    412e:	0023      	movs	r3, r4
    4130:	0022      	movs	r2, r4
    4132:	0020      	movs	r0, r4
    4134:	3350      	adds	r3, #80	; 0x50
    4136:	3234      	adds	r2, #52	; 0x34
    4138:	9300      	str	r3, [sp, #0]
    413a:	0021      	movs	r1, r4
    413c:	234c      	movs	r3, #76	; 0x4c
    413e:	3041      	adds	r0, #65	; 0x41
    4140:	f000 fc34 	bl	49ac <m_print>
    4144:	682e      	ldr	r6, [r5, #0]
    4146:	7873      	ldrb	r3, [r6, #1]
    4148:	7830      	ldrb	r0, [r6, #0]
    414a:	78b1      	ldrb	r1, [r6, #2]
    414c:	021b      	lsls	r3, r3, #8
    414e:	4303      	orrs	r3, r0
    4150:	0409      	lsls	r1, r1, #16
    4152:	001a      	movs	r2, r3
    4154:	000b      	movs	r3, r1
    4156:	0020      	movs	r0, r4
    4158:	78f1      	ldrb	r1, [r6, #3]
    415a:	4313      	orrs	r3, r2
    415c:	0609      	lsls	r1, r1, #24
    415e:	4319      	orrs	r1, r3
    4160:	3064      	adds	r0, #100	; 0x64
    4162:	f000 fc23 	bl	49ac <m_print>
    4166:	0020      	movs	r0, r4
    4168:	1da1      	adds	r1, r4, #6
    416a:	3076      	adds	r0, #118	; 0x76
    416c:	f000 fc1e 	bl	49ac <m_print>
   
    return p_ali_cfg->pid;
    4170:	682c      	ldr	r4, [r5, #0]
    4172:	7863      	ldrb	r3, [r4, #1]
    4174:	7821      	ldrb	r1, [r4, #0]
    4176:	78a0      	ldrb	r0, [r4, #2]
    4178:	021b      	lsls	r3, r3, #8
    417a:	430b      	orrs	r3, r1
    417c:	0400      	lsls	r0, r0, #16
    417e:	001a      	movs	r2, r3
    4180:	0003      	movs	r3, r0
    4182:	78e0      	ldrb	r0, [r4, #3]
    4184:	4313      	orrs	r3, r2
    4186:	0600      	lsls	r0, r0, #24
    4188:	4318      	orrs	r0, r3
}
    418a:	bd76      	pop	{r1, r2, r4, r5, r6, pc}
    418c:	10010514 	.word	0x10010514
    4190:	10011018 	.word	0x10011018
    4194:	000205cf 	.word	0x000205cf

00004198 <ali_config_mac_read>:

bool ali_config_mac_read(uint8_t *addr,uint8_t mode) 
{
    4198:	b510      	push	{r4, lr}
    419a:	4b09      	ldr	r3, [pc, #36]	; (41c0 <ali_config_mac_read+0x28>)
    if(mode){
    419c:	2900      	cmp	r1, #0
    419e:	d005      	beq.n	41ac <ali_config_mac_read+0x14>
        memcpy(addr,  p_ali_cfg->mac, FLASH_ALI_MAC_ADDR_LEN);
    41a0:	6819      	ldr	r1, [r3, #0]
    41a2:	2206      	movs	r2, #6
    41a4:	3104      	adds	r1, #4
    41a6:	f011 fc13 	bl	159d0 <memcpy>
    41aa:	e006      	b.n	41ba <ali_config_mac_read+0x22>
    
    }else{
        for(int i = 0; i < FLASH_ALI_MAC_ADDR_LEN; ++i){
            addr[i] =  p_ali_cfg->mac[FLASH_ALI_MAC_ADDR_LEN - 1 - i];
    41ac:	681a      	ldr	r2, [r3, #0]
    41ae:	1a53      	subs	r3, r2, r1
    41b0:	7a5b      	ldrb	r3, [r3, #9]
    41b2:	5443      	strb	r3, [r0, r1]
{
    if(mode){
        memcpy(addr,  p_ali_cfg->mac, FLASH_ALI_MAC_ADDR_LEN);
    
    }else{
        for(int i = 0; i < FLASH_ALI_MAC_ADDR_LEN; ++i){
    41b4:	3101      	adds	r1, #1
    41b6:	2906      	cmp	r1, #6
    41b8:	d1f9      	bne.n	41ae <ali_config_mac_read+0x16>
        }
    }

	//m_printf_hex(L_APP, "ali mac read", addr, FLASH_ALI_MAC_ADDR_LEN);
    return true;
}
    41ba:	2001      	movs	r0, #1
    41bc:	bd10      	pop	{r4, pc}
    41be:	46c0      	nop			; (mov r8, r8)
    41c0:	10011018 	.word	0x10011018

000041c4 <ali_config_device_type_get>:

uint8_t ali_config_device_type_get(void)
{
	return p_ali_cfg->ptype;
    41c4:	4b02      	ldr	r3, [pc, #8]	; (41d0 <ali_config_device_type_get+0xc>)
    41c6:	681b      	ldr	r3, [r3, #0]
    41c8:	332a      	adds	r3, #42	; 0x2a
    41ca:	7818      	ldrb	r0, [r3, #0]
}
    41cc:	4770      	bx	lr
    41ce:	46c0      	nop			; (mov r8, r8)
    41d0:	10011018 	.word	0x10011018

000041d4 <ali_config_data_init>:

bool ali_config_data_init(void)
{
    41d4:	b573      	push	{r0, r1, r4, r5, r6, lr}
	p_ali_cfg = ke_malloc(sizeof(ali_cfg_t), 0);
    41d6:	2100      	movs	r1, #0
    41d8:	202c      	movs	r0, #44	; 0x2c
    41da:	f003 f881 	bl	72e0 <ke_malloc>
    41de:	4d19      	ldr	r5, [pc, #100]	; (4244 <ali_config_data_init+0x70>)
    41e0:	1e02      	subs	r2, r0, #0
    41e2:	6028      	str	r0, [r5, #0]
	if(p_ali_cfg == NULL)
    41e4:	d02d      	beq.n	4242 <ali_config_data_init+0x6e>
		return false;
	mesh_flash_read(FLASH_ALI_DATA_ADDRESS, sizeof(ali_cfg_t), (uint8_t*)p_ali_cfg);
    41e6:	20fa      	movs	r0, #250	; 0xfa
    41e8:	212c      	movs	r1, #44	; 0x2c
    41ea:	02c0      	lsls	r0, r0, #11
    41ec:	f003 fcec 	bl	7bc8 <mesh_flash_read>
	uint8_t crc = bc_sys_check_sum((uint8_t *)p_ali_cfg, sizeof(ali_cfg_t)-1);
    41f0:	212b      	movs	r1, #43	; 0x2b
    41f2:	6828      	ldr	r0, [r5, #0]
    41f4:	f7fe fa4a 	bl	268c <bc_sys_check_sum>
	M_PRINTF(L_APP, "crcc[%x] crcs[%x]", crc, p_ali_cfg->crc);
    41f8:	4b13      	ldr	r3, [pc, #76]	; (4248 <ali_config_data_init+0x74>)
{
	p_ali_cfg = ke_malloc(sizeof(ali_cfg_t), 0);
	if(p_ali_cfg == NULL)
		return false;
	mesh_flash_read(FLASH_ALI_DATA_ADDRESS, sizeof(ali_cfg_t), (uint8_t*)p_ali_cfg);
	uint8_t crc = bc_sys_check_sum((uint8_t *)p_ali_cfg, sizeof(ali_cfg_t)-1);
    41fa:	0006      	movs	r6, r0
	M_PRINTF(L_APP, "crcc[%x] crcs[%x]", crc, p_ali_cfg->crc);
    41fc:	681b      	ldr	r3, [r3, #0]
    41fe:	049b      	lsls	r3, r3, #18
    4200:	d518      	bpl.n	4234 <ali_config_data_init+0x60>
    4202:	4c12      	ldr	r4, [pc, #72]	; (424c <ali_config_data_init+0x78>)
    4204:	0023      	movs	r3, r4
    4206:	0022      	movs	r2, r4
    4208:	0020      	movs	r0, r4
    420a:	3379      	adds	r3, #121	; 0x79
    420c:	3234      	adds	r2, #52	; 0x34
    420e:	9300      	str	r3, [sp, #0]
    4210:	0021      	movs	r1, r4
    4212:	236c      	movs	r3, #108	; 0x6c
    4214:	3041      	adds	r0, #65	; 0x41
    4216:	f000 fbc9 	bl	49ac <m_print>
    421a:	682b      	ldr	r3, [r5, #0]
    421c:	480c      	ldr	r0, [pc, #48]	; (4250 <ali_config_data_init+0x7c>)
    421e:	332b      	adds	r3, #43	; 0x2b
    4220:	0031      	movs	r1, r6
    4222:	781a      	ldrb	r2, [r3, #0]
    4224:	300e      	adds	r0, #14
    4226:	f000 fbc1 	bl	49ac <m_print>
    422a:	0020      	movs	r0, r4
    422c:	1da1      	adds	r1, r4, #6
    422e:	3076      	adds	r0, #118	; 0x76
    4230:	f000 fbbc 	bl	49ac <m_print>
	if(p_ali_cfg->crc != crc){		
    4234:	682b      	ldr	r3, [r5, #0]
    4236:	332b      	adds	r3, #43	; 0x2b
    4238:	7818      	ldrb	r0, [r3, #0]
    423a:	1b80      	subs	r0, r0, r6
    423c:	4242      	negs	r2, r0
    423e:	4142      	adcs	r2, r0
    4240:	b2d0      	uxtb	r0, r2
		return false;
	}
	return true;
}
    4242:	bd76      	pop	{r1, r2, r4, r5, r6, pc}
    4244:	10011018 	.word	0x10011018
    4248:	10010514 	.word	0x10010514
    424c:	000205cf 	.word	0x000205cf
    4250:	0002064f 	.word	0x0002064f

00004254 <Reset_Handler>:
    4254:	490a      	ldr	r1, [pc, #40]	; (4280 <Reset_Handler+0x2c>)
    4256:	4a0b      	ldr	r2, [pc, #44]	; (4284 <Reset_Handler+0x30>)
    4258:	4b0b      	ldr	r3, [pc, #44]	; (4288 <Reset_Handler+0x34>)
    425a:	1a9b      	subs	r3, r3, r2
    425c:	dd03      	ble.n	4266 <Reset_Handler+0x12>
    425e:	3b04      	subs	r3, #4
    4260:	58c8      	ldr	r0, [r1, r3]
    4262:	50d0      	str	r0, [r2, r3]
    4264:	dcfb      	bgt.n	425e <Reset_Handler+0xa>
    4266:	4909      	ldr	r1, [pc, #36]	; (428c <Reset_Handler+0x38>)
    4268:	4a09      	ldr	r2, [pc, #36]	; (4290 <Reset_Handler+0x3c>)
    426a:	2000      	movs	r0, #0
    426c:	1a52      	subs	r2, r2, r1
    426e:	dd02      	ble.n	4276 <Reset_Handler+0x22>
    4270:	3a04      	subs	r2, #4
    4272:	5088      	str	r0, [r1, r2]
    4274:	dcfc      	bgt.n	4270 <Reset_Handler+0x1c>
    4276:	4807      	ldr	r0, [pc, #28]	; (4294 <Reset_Handler+0x40>)
    4278:	4b07      	ldr	r3, [pc, #28]	; (4298 <Reset_Handler+0x44>)
    427a:	f7fb ffb7 	bl	1ec <main>
    427e:	0000      	.short	0x0000
    4280:	000234f0 	.word	0x000234f0
    4284:	10010500 	.word	0x10010500
    4288:	10010f60 	.word	0x10010f60
    428c:	10010f60 	.word	0x10010f60
    4290:	100128ac 	.word	0x100128ac
    4294:	00012345 	.word	0x00012345
    4298:	00001111 	.word	0x00001111

0000429c <DEF_IRQHandler>:
    429c:	e7fe      	b.n	429c <DEF_IRQHandler>

0000429e <__aeabi_idiv>:
    429e:	2800      	cmp	r0, #0
    42a0:	da04      	bge.n	42ac <L_num_pos>
    42a2:	4240      	negs	r0, r0
    42a4:	2900      	cmp	r1, #0
    42a6:	da04      	bge.n	42b2 <L_neg_result>
    42a8:	4249      	negs	r1, r1
    42aa:	e020      	b.n	42ee <__aeabi_uidiv>

000042ac <L_num_pos>:
    42ac:	2900      	cmp	r1, #0
    42ae:	da1e      	bge.n	42ee <__aeabi_uidiv>
    42b0:	4249      	negs	r1, r1

000042b2 <L_neg_result>:
    42b2:	b500      	push	{lr}
    42b4:	f000 f81b 	bl	42ee <__aeabi_uidiv>
    42b8:	4240      	negs	r0, r0
    42ba:	bd00      	pop	{pc}

000042bc <__aeabi_idivmod>:
    42bc:	2800      	cmp	r0, #0
    42be:	da0e      	bge.n	42de <L_num_pos_bis>
    42c0:	4240      	negs	r0, r0
    42c2:	2900      	cmp	r1, #0
    42c4:	da05      	bge.n	42d2 <L_neg_both>
    42c6:	4249      	negs	r1, r1
    42c8:	b500      	push	{lr}
    42ca:	f000 f810 	bl	42ee <__aeabi_uidiv>
    42ce:	4249      	negs	r1, r1
    42d0:	bd00      	pop	{pc}

000042d2 <L_neg_both>:
    42d2:	b500      	push	{lr}
    42d4:	f000 f80b 	bl	42ee <__aeabi_uidiv>
    42d8:	4240      	negs	r0, r0
    42da:	4249      	negs	r1, r1
    42dc:	bd00      	pop	{pc}

000042de <L_num_pos_bis>:
    42de:	2900      	cmp	r1, #0
    42e0:	da05      	bge.n	42ee <__aeabi_uidiv>
    42e2:	4249      	negs	r1, r1
    42e4:	b500      	push	{lr}
    42e6:	f000 f802 	bl	42ee <__aeabi_uidiv>
    42ea:	4240      	negs	r0, r0
    42ec:	bd00      	pop	{pc}

000042ee <__aeabi_uidiv>:
    42ee:	2900      	cmp	r1, #0
    42f0:	d100      	bne.n	42f4 <L_no_div0>
    42f2:	e014      	b.n	431e <__aeabi_idiv0>

000042f4 <L_no_div0>:
    42f4:	2201      	movs	r2, #1
    42f6:	2300      	movs	r3, #0
    42f8:	4288      	cmp	r0, r1
    42fa:	d906      	bls.n	430a <L_sub_loop0>
    42fc:	3100      	adds	r1, #0
    42fe:	d404      	bmi.n	430a <L_sub_loop0>

00004300 <L_denom_shift_loop>:
    4300:	0052      	lsls	r2, r2, #1
    4302:	0049      	lsls	r1, r1, #1
    4304:	d401      	bmi.n	430a <L_sub_loop0>
    4306:	4288      	cmp	r0, r1
    4308:	d8fa      	bhi.n	4300 <L_denom_shift_loop>

0000430a <L_sub_loop0>:
    430a:	4288      	cmp	r0, r1
    430c:	d301      	bcc.n	4312 <L_dont_sub0>
    430e:	1a40      	subs	r0, r0, r1
    4310:	4313      	orrs	r3, r2

00004312 <L_dont_sub0>:
    4312:	0849      	lsrs	r1, r1, #1
    4314:	0852      	lsrs	r2, r2, #1
    4316:	d1f8      	bne.n	430a <L_sub_loop0>
    4318:	4601      	mov	r1, r0
    431a:	4618      	mov	r0, r3
    431c:	4770      	bx	lr

0000431e <__aeabi_idiv0>:
    431e:	e7fe      	b.n	431e <__aeabi_idiv0>

00004320 <co_list_init>:
 * FUNCTION DEFINTIONS
 ****************************************************************************************
 */
void co_list_init(struct co_list *list)
{
    list->first = NULL;
    4320:	2300      	movs	r3, #0
    4322:	6003      	str	r3, [r0, #0]
    list->last = NULL;
    4324:	6043      	str	r3, [r0, #4]
    #if (KE_PROFILING)
    list->cnt = 0;
    list->maxcnt = 0;
    list->mincnt = 0xFFFFFFFF;
    #endif //KE_PROFILING
}
    4326:	4770      	bx	lr

00004328 <co_list_pool_init>:
                       void *pool,
                       size_t elmt_size,
                       uint32_t elmt_cnt,
                       void *default_value,
                       uint8_t list_type)
{
    4328:	b5f0      	push	{r4, r5, r6, r7, lr}
 * FUNCTION DEFINTIONS
 ****************************************************************************************
 */
void co_list_init(struct co_list *list)
{
    list->first = NULL;
    432a:	2500      	movs	r5, #0
                       void *pool,
                       size_t elmt_size,
                       uint32_t elmt_cnt,
                       void *default_value,
                       uint8_t list_type)
{
    432c:	0006      	movs	r6, r0
    432e:	000c      	movs	r4, r1
    4330:	b085      	sub	sp, #20
    4332:	9301      	str	r3, [sp, #4]
    4334:	ab0a      	add	r3, sp, #40	; 0x28
    4336:	0017      	movs	r7, r2
    4338:	cb04      	ldmia	r3!, {r2}
 * FUNCTION DEFINTIONS
 ****************************************************************************************
 */
void co_list_init(struct co_list *list)
{
    list->first = NULL;
    433a:	6005      	str	r5, [r0, #0]
                       void *pool,
                       size_t elmt_size,
                       uint32_t elmt_cnt,
                       void *default_value,
                       uint8_t list_type)
{
    433c:	781b      	ldrb	r3, [r3, #0]
    433e:	9202      	str	r2, [sp, #8]
    4340:	9303      	str	r3, [sp, #12]
 ****************************************************************************************
 */
void co_list_init(struct co_list *list)
{
    list->first = NULL;
    list->last = NULL;
    4342:	6045      	str	r5, [r0, #4]

    // initialize the free list relative to the pool
    co_list_init(list);

    // Add each element of the pool to this list, and init them one by one
    for (i = 0; i < elmt_cnt; i++)
    4344:	9b01      	ldr	r3, [sp, #4]
    4346:	429d      	cmp	r5, r3
    4348:	d023      	beq.n	4392 <co_list_pool_init+0x6a>
    {
        if (default_value)
    434a:	9b02      	ldr	r3, [sp, #8]
    434c:	2b00      	cmp	r3, #0
    434e:	d004      	beq.n	435a <co_list_pool_init+0x32>
        {
            memcpy(pool, default_value, elmt_size);
    4350:	003a      	movs	r2, r7
    4352:	0019      	movs	r1, r3
    4354:	0020      	movs	r0, r4
    4356:	f011 fb3b 	bl	159d0 <memcpy>
        }
        if((i == (elmt_cnt - 1)) && (list_type != POOL_LINKED_LIST))
    435a:	9b01      	ldr	r3, [sp, #4]
    435c:	3b01      	subs	r3, #1
    435e:	429d      	cmp	r5, r3
    4360:	d110      	bne.n	4384 <co_list_pool_init+0x5c>
    4362:	9b03      	ldr	r3, [sp, #12]
    4364:	2b00      	cmp	r3, #0
    4366:	d00d      	beq.n	4384 <co_list_pool_init+0x5c>
        {
            struct co_list_hdr *list_hdr =(struct co_list_hdr *) pool;
            // Sanity check
            ASSERT_ERR(list_hdr != NULL);
    4368:	2c00      	cmp	r4, #0
    436a:	d100      	bne.n	436e <co_list_pool_init+0x46>
    436c:	e7fe      	b.n	436c <co_list_pool_init+0x44>

            // check if list is empty
            if (co_list_is_empty(list))
    436e:	6833      	ldr	r3, [r6, #0]
    4370:	2b00      	cmp	r3, #0
    4372:	d101      	bne.n	4378 <co_list_pool_init+0x50>
            {
                // list empty => pushed element is also head
                list->first = list_hdr;
    4374:	6034      	str	r4, [r6, #0]
    4376:	e001      	b.n	437c <co_list_pool_init+0x54>
            }
            else
            {
                // list not empty => update next of last
                list->last->next = list_hdr;
    4378:	6873      	ldr	r3, [r6, #4]
    437a:	601c      	str	r4, [r3, #0]
            }

            // add element at the end of the list
            list->last = list_hdr;
            list_hdr->next = NULL;
    437c:	2300      	movs	r3, #0
                // list not empty => update next of last
                list->last->next = list_hdr;
            }

            // add element at the end of the list
            list->last = list_hdr;
    437e:	6074      	str	r4, [r6, #4]
            list_hdr->next = NULL;
    4380:	6023      	str	r3, [r4, #0]
        if (default_value)
        {
            memcpy(pool, default_value, elmt_size);
        }
        if((i == (elmt_cnt - 1)) && (list_type != POOL_LINKED_LIST))
        {
    4382:	e003      	b.n	438c <co_list_pool_init+0x64>
            }
            #endif //KE_PROFILING
        }
        else
        {
            co_list_push_back(list, (struct co_list_hdr *) pool);
    4384:	0021      	movs	r1, r4
    4386:	0030      	movs	r0, r6
    4388:	f000 f805 	bl	4396 <co_list_push_back>
        }

        // move to the next pool element
        pool = (void *)((uint8_t *)pool + (uint32_t)elmt_size);
    438c:	19e4      	adds	r4, r4, r7

    // initialize the free list relative to the pool
    co_list_init(list);

    // Add each element of the pool to this list, and init them one by one
    for (i = 0; i < elmt_cnt; i++)
    438e:	3501      	adds	r5, #1
    4390:	e7d8      	b.n	4344 <co_list_pool_init+0x1c>
        }

        // move to the next pool element
        pool = (void *)((uint8_t *)pool + (uint32_t)elmt_size);
    }
}
    4392:	b005      	add	sp, #20
    4394:	bdf0      	pop	{r4, r5, r6, r7, pc}

00004396 <co_list_push_back>:

void co_list_push_back(struct co_list *list,
                       struct co_list_hdr *list_hdr)
{
    // Sanity check
    ASSERT_ERR(list_hdr != NULL);
    4396:	2900      	cmp	r1, #0
    4398:	d100      	bne.n	439c <co_list_push_back+0x6>
    439a:	e7fe      	b.n	439a <co_list_push_back+0x4>
#define ASSERT_WARN(cond, param0, param1) {while(!(cond));}
#endif

__INLINE_S__ void GLOBAL_INT_DISABLE(void )
{
	__asm volatile ("cpsid i" : : : "memory");
    439c:	b672      	cpsid	i
	
	GLOBAL_INT_DISABLE();
    // check if list is empty
    if (co_list_is_empty(list))
    439e:	6803      	ldr	r3, [r0, #0]
    43a0:	2b00      	cmp	r3, #0
    43a2:	d101      	bne.n	43a8 <co_list_push_back+0x12>
    {
        // list empty => pushed element is also head
        list->first = list_hdr;
    43a4:	6001      	str	r1, [r0, #0]
    43a6:	e001      	b.n	43ac <co_list_push_back+0x16>
    }
    else
    {
        // list not empty => update next of last
        list->last->next = list_hdr;
    43a8:	6843      	ldr	r3, [r0, #4]
    43aa:	6019      	str	r1, [r3, #0]
    }

    // add element at the end of the list
    list->last = list_hdr;
    list_hdr->next = NULL;
    43ac:	2300      	movs	r3, #0
        // list not empty => update next of last
        list->last->next = list_hdr;
    }

    // add element at the end of the list
    list->last = list_hdr;
    43ae:	6041      	str	r1, [r0, #4]
    list_hdr->next = NULL;
    43b0:	600b      	str	r3, [r1, #0]
}

__INLINE_S__ void GLOBAL_INT_RESTORE(void)
{
	__asm volatile ("cpsie i" : : : "memory");
    43b2:	b662      	cpsie	i
    if(list->maxcnt < list->cnt)
    {
        list->maxcnt = list->cnt;
    }
    #endif //KE_PROFILING
}
    43b4:	4770      	bx	lr

000043b6 <co_list_push_back_sublist>:

void co_list_push_back_sublist(struct co_list *list, struct co_list_hdr *first_hdr, struct co_list_hdr *last_hdr)
{
    // Sanity check
    ASSERT_ERR(first_hdr != NULL);
    43b6:	2900      	cmp	r1, #0
    43b8:	d100      	bne.n	43bc <co_list_push_back_sublist+0x6>
    43ba:	e7fe      	b.n	43ba <co_list_push_back_sublist+0x4>
    ASSERT_ERR(last_hdr != NULL);
    43bc:	2a00      	cmp	r2, #0
    43be:	d100      	bne.n	43c2 <co_list_push_back_sublist+0xc>
    43c0:	e7fe      	b.n	43c0 <co_list_push_back_sublist+0xa>

    // check if list is empty
    if (co_list_is_empty(list))
    43c2:	6803      	ldr	r3, [r0, #0]
    43c4:	2b00      	cmp	r3, #0
    43c6:	d101      	bne.n	43cc <co_list_push_back_sublist+0x16>
    {
        // list empty => pushed element is also head
        list->first = first_hdr;
    43c8:	6001      	str	r1, [r0, #0]
    43ca:	e001      	b.n	43d0 <co_list_push_back_sublist+0x1a>
    }
    else
    {
        // list not empty => update next of last
        list->last->next = first_hdr;
    43cc:	6843      	ldr	r3, [r0, #4]
    43ce:	6019      	str	r1, [r3, #0]
    }

    // Update last pointer
    list->last = last_hdr;
    last_hdr->next = NULL;
    43d0:	2300      	movs	r3, #0
        // list not empty => update next of last
        list->last->next = first_hdr;
    }

    // Update last pointer
    list->last = last_hdr;
    43d2:	6042      	str	r2, [r0, #4]
    last_hdr->next = NULL;
    43d4:	6013      	str	r3, [r2, #0]

        list->cnt++;
        list->maxcnt = co_max(list->maxcnt, list->cnt);
    }
    #endif //KE_PROFILING
}
    43d6:	4770      	bx	lr

000043d8 <co_list_push_front>:

void co_list_push_front(struct co_list *list,
                        struct co_list_hdr *list_hdr)
{
    // Sanity check
    ASSERT_ERR(list_hdr != NULL);
    43d8:	2900      	cmp	r1, #0
    43da:	d100      	bne.n	43de <co_list_push_front+0x6>
    43dc:	e7fe      	b.n	43dc <co_list_push_front+0x4>
    43de:	6803      	ldr	r3, [r0, #0]

    // check if list is empty
    if (co_list_is_empty(list))
    43e0:	2b00      	cmp	r3, #0
    43e2:	d100      	bne.n	43e6 <co_list_push_front+0xe>
    {
        // list empty => pushed element is also head
        list->last = list_hdr;
    43e4:	6041      	str	r1, [r0, #4]
    }

    // add element at the beginning of the list
    list_hdr->next = list->first;
    43e6:	600b      	str	r3, [r1, #0]
    list->first = list_hdr;
    43e8:	6001      	str	r1, [r0, #0]
    if(list->maxcnt < list->cnt)
    {
        list->maxcnt = list->cnt;
    }
    #endif //KE_PROFILING
}
    43ea:	4770      	bx	lr

000043ec <co_list_pop_front>:
struct co_list_hdr *co_list_pop_front(struct co_list *list)
{
    struct co_list_hdr *element;

    // check if list is empty
    element = list->first;
    43ec:	6803      	ldr	r3, [r0, #0]
    if (element != NULL)
    43ee:	2b00      	cmp	r3, #0
    43f0:	d004      	beq.n	43fc <co_list_pop_front+0x10>
    {

        // The list isn't empty : extract the first element
        list->first = list->first->next;
    43f2:	681a      	ldr	r2, [r3, #0]
    43f4:	6002      	str	r2, [r0, #0]

        if(list->first == NULL)
    43f6:	2a00      	cmp	r2, #0
    43f8:	d100      	bne.n	43fc <co_list_pop_front+0x10>
        {
            list->last = list->first;
    43fa:	6042      	str	r2, [r0, #4]
            list->mincnt = list->cnt;
        }
        #endif //KE_PROFILING
    }
    return element;
}
    43fc:	0018      	movs	r0, r3
    43fe:	4770      	bx	lr

00004400 <co_list_extract>:

bool co_list_extract(struct co_list *list, struct co_list_hdr *list_hdr)
{
    4400:	b530      	push	{r4, r5, lr}
    bool found = false;

    // sanity check
    ASSERT_ERR(list != NULL);
    4402:	2800      	cmp	r0, #0
    4404:	d100      	bne.n	4408 <co_list_extract+0x8>
    4406:	e7fe      	b.n	4406 <co_list_extract+0x6>

    struct co_list_hdr *prev = NULL;
    struct co_list_hdr *curr = list->first;
    4408:	6805      	ldr	r5, [r0, #0]
    bool found = false;

    // sanity check
    ASSERT_ERR(list != NULL);

    struct co_list_hdr *prev = NULL;
    440a:	2200      	movs	r2, #0
    struct co_list_hdr *curr = list->first;
    440c:	002b      	movs	r3, r5

    // Search for the element
    while(curr != NULL)
    440e:	2b00      	cmp	r3, #0
    4410:	d014      	beq.n	443c <co_list_extract+0x3c>
    {
        // Check element
        if(curr == list_hdr)
    4412:	428b      	cmp	r3, r1
    4414:	d007      	beq.n	4426 <co_list_extract+0x26>
            break;
        }

        // Move pointers
        prev = curr;
        ASSERT_INFO(list->first != curr->next, ((uint32_t)curr)>>16, ((uint32_t)curr)&0xFFFF);
    4416:	681c      	ldr	r4, [r3, #0]
    4418:	42a5      	cmp	r5, r4
    441a:	d0fd      	beq.n	4418 <co_list_extract+0x18>
    441c:	001a      	movs	r2, r3
        ASSERT_INFO(curr != curr->next, ((uint32_t)curr)>>16, ((uint32_t)curr)&0xFFFF);
    441e:	42a3      	cmp	r3, r4
    4420:	d0fc      	beq.n	441c <co_list_extract+0x1c>
    4422:	0023      	movs	r3, r4
    4424:	e7f3      	b.n	440e <co_list_extract+0xe>
    4426:	680b      	ldr	r3, [r1, #0]
    }

    if(found)
    {
        // Check if the element is first
        if(prev == NULL)
    4428:	2a00      	cmp	r2, #0
    442a:	d101      	bne.n	4430 <co_list_extract+0x30>
        {
            // Extract element
            list->first = list_hdr->next;
    442c:	6003      	str	r3, [r0, #0]
    442e:	e000      	b.n	4432 <co_list_extract+0x32>
        }
        else
        {
            // Extract element
            prev->next = list_hdr->next;
    4430:	6013      	str	r3, [r2, #0]
        }

        // Check if the element is last
        if(list_hdr == list->last)
    4432:	6844      	ldr	r4, [r0, #4]
    while(curr != NULL)
    {
        // Check element
        if(curr == list_hdr)
        {
            found = true;
    4434:	2301      	movs	r3, #1
            // Extract element
            prev->next = list_hdr->next;
        }

        // Check if the element is last
        if(list_hdr == list->last)
    4436:	42a1      	cmp	r1, r4
    4438:	d100      	bne.n	443c <co_list_extract+0x3c>
        {
            // Update last pointer
            list->last = prev;
    443a:	6042      	str	r2, [r0, #4]
            list->mincnt = list->cnt;
        }
        #endif //KE_PROFILING
    }
    return found;
}
    443c:	0018      	movs	r0, r3
    443e:	bd30      	pop	{r4, r5, pc}

00004440 <co_list_extract_after>:

void co_list_extract_after(struct co_list *list, struct co_list_hdr *elt_ref_hdr, struct co_list_hdr *elt_to_rem_hdr)
{
    // sanity check
    ASSERT_ERR(list != NULL);
    4440:	2800      	cmp	r0, #0
    4442:	d100      	bne.n	4446 <co_list_extract_after+0x6>
    4444:	e7fe      	b.n	4444 <co_list_extract_after+0x4>
    ASSERT_ERR(elt_to_rem_hdr != NULL);
    4446:	2a00      	cmp	r2, #0
    4448:	d100      	bne.n	444c <co_list_extract_after+0xc>
    444a:	e7fe      	b.n	444a <co_list_extract_after+0xa>

    // Check if the element is first
    if(elt_ref_hdr == NULL)
    444c:	2900      	cmp	r1, #0
    444e:	d105      	bne.n	445c <co_list_extract_after+0x1c>
    {
        ASSERT_ERR(elt_to_rem_hdr == list->first);
    4450:	6803      	ldr	r3, [r0, #0]
    4452:	429a      	cmp	r2, r3
    4454:	d1fd      	bne.n	4452 <co_list_extract_after+0x12>

        // The list isn't empty : extract the first element
        list->first = list->first->next;
    4456:	6813      	ldr	r3, [r2, #0]
    4458:	6003      	str	r3, [r0, #0]
    445a:	e004      	b.n	4466 <co_list_extract_after+0x26>
    }
    else
    {
        ASSERT_ERR(elt_to_rem_hdr == elt_ref_hdr->next);
    445c:	680b      	ldr	r3, [r1, #0]
    445e:	429a      	cmp	r2, r3
    4460:	d1fd      	bne.n	445e <co_list_extract_after+0x1e>

        // Extract element
        elt_ref_hdr->next = elt_to_rem_hdr->next;
    4462:	6813      	ldr	r3, [r2, #0]
    4464:	600b      	str	r3, [r1, #0]
    }

    // Check if the element is last
    if(elt_to_rem_hdr == list->last)
    4466:	6843      	ldr	r3, [r0, #4]
    4468:	429a      	cmp	r2, r3
    446a:	d100      	bne.n	446e <co_list_extract_after+0x2e>
    {
        // Update last pointer
        list->last = elt_ref_hdr;
    446c:	6041      	str	r1, [r0, #4]
    if(list->mincnt > list->cnt)
    {
        list->mincnt = list->cnt;
    }
    #endif //KE_PROFILING
}
    446e:	4770      	bx	lr

00004470 <co_list_extract_sublist>:

void co_list_extract_sublist(struct co_list *list, struct co_list_hdr *ref_hdr, struct co_list_hdr *last_hdr)
{
    // sanity check
    ASSERT_ERR(list != NULL);
    4470:	2800      	cmp	r0, #0
    4472:	d100      	bne.n	4476 <co_list_extract_sublist+0x6>
    4474:	e7fe      	b.n	4474 <co_list_extract_sublist+0x4>
    ASSERT_ERR(last_hdr != NULL);
    4476:	2a00      	cmp	r2, #0
    4478:	d100      	bne.n	447c <co_list_extract_sublist+0xc>
    447a:	e7fe      	b.n	447a <co_list_extract_sublist+0xa>
    447c:	6813      	ldr	r3, [r2, #0]

    // Check if the element is first
    if(ref_hdr == NULL)
    447e:	2900      	cmp	r1, #0
    4480:	d101      	bne.n	4486 <co_list_extract_sublist+0x16>
    {
        // Extract the elements
        list->first = last_hdr->next;
    4482:	6003      	str	r3, [r0, #0]
    4484:	e000      	b.n	4488 <co_list_extract_sublist+0x18>
    }
    else
    {
        // Extract the elements
        ref_hdr->next = last_hdr->next;
    4486:	600b      	str	r3, [r1, #0]
    }

    // Check if the element is last
    if(last_hdr == list->last)
    4488:	6843      	ldr	r3, [r0, #4]
    448a:	429a      	cmp	r2, r3
    448c:	d100      	bne.n	4490 <co_list_extract_sublist+0x20>
    {
        // Reference element becomes last
        list->last = ref_hdr;
    448e:	6041      	str	r1, [r0, #4]
    }
}
    4490:	4770      	bx	lr

00004492 <co_list_find>:
    // Go through the list to find the element
    tmp_list_hdr = list->first;

    while ((tmp_list_hdr != list_hdr) && (tmp_list_hdr != NULL))
    {
        tmp_list_hdr = tmp_list_hdr->next;
    4492:	6800      	ldr	r0, [r0, #0]
    struct co_list_hdr *tmp_list_hdr;

    // Go through the list to find the element
    tmp_list_hdr = list->first;

    while ((tmp_list_hdr != list_hdr) && (tmp_list_hdr != NULL))
    4494:	4288      	cmp	r0, r1
    4496:	d002      	beq.n	449e <co_list_find+0xc>
    4498:	2800      	cmp	r0, #0
    449a:	d1fa      	bne.n	4492 <co_list_find>
    449c:	e000      	b.n	44a0 <co_list_find+0xe>
    449e:	0008      	movs	r0, r1
    {
        tmp_list_hdr = tmp_list_hdr->next;
    }

    return (tmp_list_hdr == list_hdr);
    44a0:	1a08      	subs	r0, r1, r0
    44a2:	4241      	negs	r1, r0
    44a4:	4148      	adcs	r0, r1
    44a6:	b2c0      	uxtb	r0, r0
}
    44a8:	4770      	bx	lr

000044aa <co_list_merge>:

void co_list_merge(struct co_list *list1,
                   struct co_list *list2)
{
    44aa:	680b      	ldr	r3, [r1, #0]
    44ac:	b510      	push	{r4, lr}
    // Sanity check: list2 is not supposed to be empty
    ASSERT_ERR(!co_list_is_empty(list2));
    44ae:	2b00      	cmp	r3, #0
    44b0:	d100      	bne.n	44b4 <co_list_merge+0xa>
    44b2:	e7fe      	b.n	44b2 <co_list_merge+0x8>

    // just copy list elements
    if(co_list_is_empty(list1))
    44b4:	6804      	ldr	r4, [r0, #0]
    44b6:	684a      	ldr	r2, [r1, #4]
    44b8:	2c00      	cmp	r4, #0
    44ba:	d102      	bne.n	44c2 <co_list_merge+0x18>
    {
        list1->first = list2->first;
    44bc:	6003      	str	r3, [r0, #0]
        list1->last  = list2->last;
    44be:	6042      	str	r2, [r0, #4]
    44c0:	e002      	b.n	44c8 <co_list_merge+0x1e>
    }
    // merge lists
    else
    {
        // Append list2 to list1
        list1->last->next = list2->first;
    44c2:	6844      	ldr	r4, [r0, #4]
    44c4:	6023      	str	r3, [r4, #0]
        list1->last = list2->last;
    44c6:	6042      	str	r2, [r0, #4]

    }

    // Empty list2
    list2->first = NULL;
    44c8:	2300      	movs	r3, #0
    44ca:	600b      	str	r3, [r1, #0]

    #if (KE_PROFILING)
    list1->cnt += list2->cnt;
    list2->cnt = 0;
    #endif //KE_PROFILING
}
    44cc:	bd10      	pop	{r4, pc}

000044ce <co_list_insert_before>:

void co_list_insert_before(struct co_list *list,
                        struct co_list_hdr *elt_ref_hdr, struct co_list_hdr *elt_to_add_hdr)
{
    44ce:	b510      	push	{r4, lr}
    // Sanity check
    ASSERT_ERR(elt_to_add_hdr != NULL);
    44d0:	2a00      	cmp	r2, #0
    44d2:	d100      	bne.n	44d6 <co_list_insert_before+0x8>
    44d4:	e7fe      	b.n	44d4 <co_list_insert_before+0x6>
    // If no element referenced
    if(elt_ref_hdr == NULL)
    44d6:	2900      	cmp	r1, #0
    44d8:	d103      	bne.n	44e2 <co_list_insert_before+0x14>
    {
        co_list_push_front(list,elt_to_add_hdr);
    44da:	0011      	movs	r1, r2
    44dc:	f7ff ff7c 	bl	43d8 <co_list_push_front>
    44e0:	e00d      	b.n	44fe <co_list_insert_before+0x30>
    }
    else
    {
        struct co_list_hdr *tmp_list_prev_hdr = NULL;
    44e2:	2400      	movs	r4, #0
        struct co_list_hdr *tmp_list_curr_hdr;

        // Go through the list to find the element
        tmp_list_curr_hdr = list->first;
    44e4:	6803      	ldr	r3, [r0, #0]

        while ((tmp_list_curr_hdr != elt_ref_hdr) && (tmp_list_curr_hdr != NULL))
    44e6:	428b      	cmp	r3, r1
    44e8:	d005      	beq.n	44f6 <co_list_insert_before+0x28>
    44ea:	2b00      	cmp	r3, #0
    44ec:	d002      	beq.n	44f4 <co_list_insert_before+0x26>
        {
            // Save previous element
            tmp_list_prev_hdr = tmp_list_curr_hdr;
            // Get the next element of the list
            tmp_list_curr_hdr = tmp_list_curr_hdr->next;
    44ee:	001c      	movs	r4, r3
    44f0:	681b      	ldr	r3, [r3, #0]
    44f2:	e7f8      	b.n	44e6 <co_list_insert_before+0x18>
    44f4:	0019      	movs	r1, r3
        }
        // If only one element is available
        if(tmp_list_prev_hdr == NULL)
    44f6:	2c00      	cmp	r4, #0
    44f8:	d0ef      	beq.n	44da <co_list_insert_before+0xc>
        {
            co_list_push_front(list,elt_to_add_hdr);
        }
        else
        {
            tmp_list_prev_hdr->next = elt_to_add_hdr;
    44fa:	6022      	str	r2, [r4, #0]
            elt_to_add_hdr->next = tmp_list_curr_hdr;
    44fc:	6011      	str	r1, [r2, #0]
                list->maxcnt = list->cnt;
            }
            #endif //KE_PROFILING
        }
    }
}
    44fe:	bd10      	pop	{r4, pc}

00004500 <co_list_insert_after>:

void co_list_insert_after(struct co_list *list,
                        struct co_list_hdr *elt_ref_hdr, struct co_list_hdr *elt_to_add_hdr)
{
    4500:	b510      	push	{r4, lr}
    // Sanity check
    ASSERT_ERR(elt_to_add_hdr != NULL);
    4502:	2a00      	cmp	r2, #0
    4504:	d100      	bne.n	4508 <co_list_insert_after+0x8>
    4506:	e7fe      	b.n	4506 <co_list_insert_after+0x6>
    // If no element referenced
    if(elt_ref_hdr == NULL)
    4508:	2900      	cmp	r1, #0
    450a:	d103      	bne.n	4514 <co_list_insert_after+0x14>
    {
        co_list_push_back(list,elt_to_add_hdr);
    450c:	0011      	movs	r1, r2
    450e:	f7ff ff42 	bl	4396 <co_list_push_back>
    4512:	e00c      	b.n	452e <co_list_insert_after+0x2e>
    else
    {
        struct co_list_hdr *tmp_list_curr_hdr;

        // Go through the list to find the element
        tmp_list_curr_hdr = list->first;
    4514:	6803      	ldr	r3, [r0, #0]

        while ((tmp_list_curr_hdr != elt_ref_hdr) && (tmp_list_curr_hdr != NULL))
    4516:	428b      	cmp	r3, r1
    4518:	d003      	beq.n	4522 <co_list_insert_after+0x22>
    451a:	2b00      	cmp	r3, #0
    451c:	d0f6      	beq.n	450c <co_list_insert_after+0xc>
        {
             // Get the next element of the list
            tmp_list_curr_hdr = tmp_list_curr_hdr->next;
    451e:	681b      	ldr	r3, [r3, #0]
    4520:	e7f9      	b.n	4516 <co_list_insert_after+0x16>
            co_list_push_back(list,elt_to_add_hdr);
        }
        else
        {
            // Check if the found element was the last of the list
            if (!tmp_list_curr_hdr->next)
    4522:	680b      	ldr	r3, [r1, #0]
    4524:	2b00      	cmp	r3, #0
    4526:	d100      	bne.n	452a <co_list_insert_after+0x2a>
            {
                // Update last pointer
                list->last = elt_to_add_hdr;
    4528:	6042      	str	r2, [r0, #4]
            }

            elt_to_add_hdr->next = tmp_list_curr_hdr->next;
    452a:	6013      	str	r3, [r2, #0]
            tmp_list_curr_hdr->next = elt_to_add_hdr;
    452c:	600a      	str	r2, [r1, #0]
                list->maxcnt = list->cnt;
            }
            #endif //KE_PROFILING
        }
    }
}
    452e:	bd10      	pop	{r4, pc}

00004530 <co_list_size>:

uint16_t co_list_size(struct co_list *list)
{
    uint16_t count = 0;
    struct co_list_hdr *tmp_list_hdr = list->first;
    4530:	6803      	ldr	r3, [r0, #0]
    }
}

uint16_t co_list_size(struct co_list *list)
{
    uint16_t count = 0;
    4532:	2000      	movs	r0, #0
    struct co_list_hdr *tmp_list_hdr = list->first;

    // browse list to count number of elements
    while (tmp_list_hdr != NULL)
    4534:	2b00      	cmp	r3, #0
    4536:	d003      	beq.n	4540 <co_list_size+0x10>
    {
        tmp_list_hdr = tmp_list_hdr->next;
        count++;
    4538:	3001      	adds	r0, #1
    struct co_list_hdr *tmp_list_hdr = list->first;

    // browse list to count number of elements
    while (tmp_list_hdr != NULL)
    {
        tmp_list_hdr = tmp_list_hdr->next;
    453a:	681b      	ldr	r3, [r3, #0]
        count++;
    453c:	b280      	uxth	r0, r0
    453e:	e7f9      	b.n	4534 <co_list_size+0x4>
    }

    return count;
}
    4540:	4770      	bx	lr

00004542 <co_util_read_array_size>:
 ****************************************************************************************
 */

/// Extract length of an array from a format string
static uint16_t co_util_read_array_size(char **fmt_cursor)
{
    4542:	b510      	push	{r4, lr}
    4544:	1e02      	subs	r2, r0, #0
    // Read size
    uint16_t size = 0;

    // Sanity check
    ASSERT_ERR(fmt_cursor);
    4546:	d100      	bne.n	454a <co_util_read_array_size+0x8>
    4548:	e7fe      	b.n	4548 <co_util_read_array_size+0x6>

    // Convert unit
    size = (*(*fmt_cursor)++) - '0';
    454a:	6803      	ldr	r3, [r0, #0]
    454c:	1c59      	adds	r1, r3, #1
    454e:	6001      	str	r1, [r0, #0]

    while(((*(*fmt_cursor)) >= '0') && ((*(*fmt_cursor)) <= '9'))
    {
        // Convert tens
        size = 10 * size + ((*(*fmt_cursor)++) - '0');
    4550:	210a      	movs	r1, #10

    // Sanity check
    ASSERT_ERR(fmt_cursor);

    // Convert unit
    size = (*(*fmt_cursor)++) - '0';
    4552:	781b      	ldrb	r3, [r3, #0]
    4554:	3b30      	subs	r3, #48	; 0x30
    4556:	b298      	uxth	r0, r3

    while(((*(*fmt_cursor)) >= '0') && ((*(*fmt_cursor)) <= '9'))
    4558:	6814      	ldr	r4, [r2, #0]
    455a:	7823      	ldrb	r3, [r4, #0]
    455c:	3b30      	subs	r3, #48	; 0x30
    455e:	2b09      	cmp	r3, #9
    4560:	d808      	bhi.n	4574 <co_util_read_array_size+0x32>
    {
        // Convert tens
        size = 10 * size + ((*(*fmt_cursor)++) - '0');
    4562:	0003      	movs	r3, r0
    4564:	1c60      	adds	r0, r4, #1
    4566:	434b      	muls	r3, r1
    4568:	6010      	str	r0, [r2, #0]
    456a:	7820      	ldrb	r0, [r4, #0]
    456c:	3830      	subs	r0, #48	; 0x30
    456e:	1818      	adds	r0, r3, r0
    4570:	b280      	uxth	r0, r0
    4572:	e7f1      	b.n	4558 <co_util_read_array_size+0x16>
    }

    // Return the read size
    return (size);
}
    4574:	bd10      	pop	{r4, pc}

00004576 <co_bdaddr_compare>:
    }
}
#endif //(BC_DEBUG || DISPLAY_SUPPORT)

bool co_bdaddr_compare(struct bd_addr const *bd_address1, struct bd_addr const *bd_address2)
{
    4576:	2300      	movs	r3, #0
    4578:	b510      	push	{r4, lr}

    for (uint8_t idx=0; idx < BD_ADDR_LEN; idx++)
    {
        /// checks if the addresses are similar
        if (bd_address1->addr[idx] != bd_address2->addr[idx])
    457a:	5cc4      	ldrb	r4, [r0, r3]
    457c:	5cca      	ldrb	r2, [r1, r3]
    457e:	4294      	cmp	r4, r2
    4580:	d104      	bne.n	458c <co_bdaddr_compare+0x16>
    4582:	3301      	adds	r3, #1
#endif //(BC_DEBUG || DISPLAY_SUPPORT)

bool co_bdaddr_compare(struct bd_addr const *bd_address1, struct bd_addr const *bd_address2)
{

    for (uint8_t idx=0; idx < BD_ADDR_LEN; idx++)
    4584:	2b06      	cmp	r3, #6
    4586:	d1f8      	bne.n	457a <co_bdaddr_compare+0x4>
        if (bd_address1->addr[idx] != bd_address2->addr[idx])
        {
           return (false);
        }
    }
    return (true);
    4588:	2001      	movs	r0, #1
    458a:	e000      	b.n	458e <co_bdaddr_compare+0x18>
    for (uint8_t idx=0; idx < BD_ADDR_LEN; idx++)
    {
        /// checks if the addresses are similar
        if (bd_address1->addr[idx] != bd_address2->addr[idx])
        {
           return (false);
    458c:	2000      	movs	r0, #0
        }
    }
    return (true);
}
    458e:	bd10      	pop	{r4, pc}

00004590 <co_util_pack>:
    return nb_good_channels;
}
#endif //BT_EMB_PRESENT

uint8_t co_util_pack(uint8_t* out, uint8_t* in, uint16_t* out_len, uint16_t in_len, const char* format)
{
    4590:	b5f0      	push	{r4, r5, r6, r7, lr}
    4592:	b08b      	sub	sp, #44	; 0x2c
    4594:	9207      	str	r2, [sp, #28]
    4596:	9a10      	ldr	r2, [sp, #64]	; 0x40
    uint8_t status = CO_UTIL_PACK_OK;
    uint8_t* p_in = in;
    uint8_t* p_out = out;
    uint8_t* p_in_end = in + in_len;
    4598:	18cb      	adds	r3, r1, r3
    return nb_good_channels;
}
#endif //BT_EMB_PRESENT

uint8_t co_util_pack(uint8_t* out, uint8_t* in, uint16_t* out_len, uint16_t in_len, const char* format)
{
    459a:	9006      	str	r0, [sp, #24]
    459c:	1e0e      	subs	r6, r1, #0
    uint8_t status = CO_UTIL_PACK_OK;
    uint8_t* p_in = in;
    uint8_t* p_out = out;
    uint8_t* p_in_end = in + in_len;
    459e:	9305      	str	r3, [sp, #20]
    char* cursor = (char*) format;
    45a0:	9209      	str	r2, [sp, #36]	; 0x24
    bool b_copy = (in != NULL) && (out != NULL);
    45a2:	9103      	str	r1, [sp, #12]
    45a4:	d003      	beq.n	45ae <co_util_pack+0x1e>
    45a6:	0001      	movs	r1, r0
    45a8:	1e4b      	subs	r3, r1, #1
    45aa:	4199      	sbcs	r1, r3
    45ac:	9103      	str	r1, [sp, #12]

    ASSERT_ERR(format != NULL);
    45ae:	2a00      	cmp	r2, #0
    45b0:	d100      	bne.n	45b4 <co_util_pack+0x24>
    45b2:	e7fe      	b.n	45b2 <co_util_pack+0x22>
    bool b_lsb = true;
    bool big_number = false;
    uint16_t nb = 1;

    // Check if forced to little endian
    if(*cursor == '<')
    45b4:	7813      	ldrb	r3, [r2, #0]
    45b6:	2b3c      	cmp	r3, #60	; 0x3c
    45b8:	d103      	bne.n	45c2 <co_util_pack+0x32>
    {
        b_lsb = true;
        cursor++;
    45ba:	3201      	adds	r2, #1
    45bc:	9209      	str	r2, [sp, #36]	; 0x24
    uint16_t nb = 1;

    // Check if forced to little endian
    if(*cursor == '<')
    {
        b_lsb = true;
    45be:	3b3b      	subs	r3, #59	; 0x3b
    45c0:	e006      	b.n	45d0 <co_util_pack+0x40>
    char* cursor = (char*) format;
    bool b_copy = (in != NULL) && (out != NULL);

    ASSERT_ERR(format != NULL);

    bool b_lsb = true;
    45c2:	2101      	movs	r1, #1
    45c4:	9102      	str	r1, [sp, #8]
    if(*cursor == '<')
    {
        b_lsb = true;
        cursor++;
    }
    else if(*cursor == '>')
    45c6:	2b3e      	cmp	r3, #62	; 0x3e
    45c8:	d103      	bne.n	45d2 <co_util_pack+0x42>
    {
        b_lsb = false;
    45ca:	2300      	movs	r3, #0
        cursor++;
    45cc:	1852      	adds	r2, r2, r1
    45ce:	9209      	str	r2, [sp, #36]	; 0x24
        b_lsb = true;
        cursor++;
    }
    else if(*cursor == '>')
    {
        b_lsb = false;
    45d0:	9302      	str	r3, [sp, #8]
                if(b_copy)
                {
                    // Check if enough space in input buffer to read
                    if(((uint8_t *)(short_word + 1)) > p_in_end)
                    {
                        status = CO_UTIL_PACK_IN_BUF_OVFLW;
    45d2:	2300      	movs	r3, #0
    45d4:	2501      	movs	r5, #1
    45d6:	9c06      	ldr	r4, [sp, #24]
    45d8:	9304      	str	r3, [sp, #16]
                if(b_copy)
                {
                    // Check if enough space in input buffer to read
                    if(((uint8_t *)(long_word + 1)) > p_in_end)
                    {
                        status = CO_UTIL_PACK_IN_BUF_OVFLW;
    45da:	9301      	str	r3, [sp, #4]
    {
        b_lsb = false;
        cursor++;
    }

    while((*cursor != '\0') && (status == CO_UTIL_PACK_OK))
    45dc:	9b09      	ldr	r3, [sp, #36]	; 0x24
    45de:	781b      	ldrb	r3, [r3, #0]
    45e0:	2b00      	cmp	r3, #0
    45e2:	d100      	bne.n	45e6 <co_util_pack+0x56>
    45e4:	e0bc      	b.n	4760 <co_util_pack+0x1d0>
    45e6:	9a01      	ldr	r2, [sp, #4]
    45e8:	2a00      	cmp	r2, #0
    45ea:	d000      	beq.n	45ee <co_util_pack+0x5e>
    45ec:	e0bf      	b.n	476e <co_util_pack+0x1de>
    {
        char data_type;

        // Check if the new field is an array (starting with a number)
        if((*cursor >= '0') && (*cursor <= '9'))
    45ee:	3b30      	subs	r3, #48	; 0x30
    45f0:	2b09      	cmp	r3, #9
    45f2:	d803      	bhi.n	45fc <co_util_pack+0x6c>
        {
            nb = co_util_read_array_size(&cursor);
    45f4:	a809      	add	r0, sp, #36	; 0x24
    45f6:	f7ff ffa4 	bl	4542 <co_util_read_array_size>
    45fa:	0005      	movs	r5, r0
        }

        data_type = *cursor++;
    45fc:	9b09      	ldr	r3, [sp, #36]	; 0x24
    45fe:	1c5a      	adds	r2, r3, #1
    4600:	9209      	str	r2, [sp, #36]	; 0x24
    4602:	781f      	ldrb	r7, [r3, #0]

        // Parse the format string
        switch (data_type)
    4604:	2f48      	cmp	r7, #72	; 0x48
    4606:	d038      	beq.n	467a <co_util_pack+0xea>
    4608:	d807      	bhi.n	461a <co_util_pack+0x8a>
    460a:	2f44      	cmp	r7, #68	; 0x44
    460c:	d061      	beq.n	46d2 <co_util_pack+0x142>
    460e:	2f47      	cmp	r7, #71	; 0x47
    4610:	d00a      	beq.n	4628 <co_util_pack+0x98>
    4612:	2f42      	cmp	r7, #66	; 0x42
    4614:	d000      	beq.n	4618 <co_util_pack+0x88>
    4616:	e09c      	b.n	4752 <co_util_pack+0x1c2>
    4618:	e008      	b.n	462c <co_util_pack+0x9c>
    461a:	2f4e      	cmp	r7, #78	; 0x4e
    461c:	d02d      	beq.n	467a <co_util_pack+0xea>
    461e:	2f6e      	cmp	r7, #110	; 0x6e
    4620:	d004      	beq.n	462c <co_util_pack+0x9c>
    4622:	2f4c      	cmp	r7, #76	; 0x4c
    4624:	d07c      	beq.n	4720 <co_util_pack+0x190>
    4626:	e094      	b.n	4752 <co_util_pack+0x1c2>
        {
            case ('G'): // Big Number
            {
                big_number = true;
    4628:	2301      	movs	r3, #1
    462a:	9304      	str	r3, [sp, #16]
            } // No break
            case ('n'): // table size over 1 byte
            case ('B'): // Byte
            {
                if(b_copy)
    462c:	9b03      	ldr	r3, [sp, #12]
    462e:	2b00      	cmp	r3, #0
    4630:	d01b      	beq.n	466a <co_util_pack+0xda>
                {
                    // Check if enough space in input buffer to read
                    if((p_in + nb) > p_in_end)
    4632:	9a05      	ldr	r2, [sp, #20]
    4634:	1973      	adds	r3, r6, r5
    4636:	429a      	cmp	r2, r3
    4638:	d200      	bcs.n	463c <co_util_pack+0xac>
    463a:	e08f      	b.n	475c <co_util_pack+0x1cc>
                        status = CO_UTIL_PACK_IN_BUF_OVFLW;
                        break;
                    }

                    // Copy bytes
                    if(!big_number || (b_lsb == CPU_LE))
    463c:	9b04      	ldr	r3, [sp, #16]
    463e:	2b00      	cmp	r3, #0
    4640:	d005      	beq.n	464e <co_util_pack+0xbe>
    4642:	9b02      	ldr	r3, [sp, #8]
    4644:	2b00      	cmp	r3, #0
    4646:	d102      	bne.n	464e <co_util_pack+0xbe>
    4648:	002b      	movs	r3, r5
    464a:	0022      	movs	r2, r4
    464c:	e005      	b.n	465a <co_util_pack+0xca>
                    {
                        memcpy(p_out, p_in, nb);
    464e:	002a      	movs	r2, r5
    4650:	0031      	movs	r1, r6
    4652:	0020      	movs	r0, r4
    4654:	f011 f9bc 	bl	159d0 <memcpy>
    4658:	e007      	b.n	466a <co_util_pack+0xda>
 * @param[in] len       number of bytes to swap
 ****************************************************************************************
 */
__INLINE_S__ void co_bswap(uint8_t* p_val_out, const uint8_t* p_val_in, uint16_t len)
{
    while (len > 0)
    465a:	2b00      	cmp	r3, #0
    465c:	d005      	beq.n	466a <co_util_pack+0xda>
    {
        len--;
    465e:	3b01      	subs	r3, #1
    4660:	b29b      	uxth	r3, r3
        *p_val_out = p_val_in[len];
    4662:	5cf1      	ldrb	r1, [r6, r3]
    4664:	7011      	strb	r1, [r2, #0]
        p_val_out++;
    4666:	3201      	adds	r2, #1
    4668:	e7f7      	b.n	465a <co_util_pack+0xca>
                        co_bswap(p_out, p_in, nb);
                    }
                }

                // Move pointers
                p_out += nb;
    466a:	1964      	adds	r4, r4, r5
                p_in += nb;
    466c:	1976      	adds	r6, r6, r5

                // Re-initialize table size for next loop
                nb = 1;
    466e:	2501      	movs	r5, #1
                if(data_type == 'n')
    4670:	2f6e      	cmp	r7, #110	; 0x6e
    4672:	d170      	bne.n	4756 <co_util_pack+0x1c6>
                {
                    // The current byte represents the size of the following table
                    nb = *(p_in - 1);
    4674:	1e73      	subs	r3, r6, #1
    4676:	781d      	ldrb	r5, [r3, #0]
    4678:	e06d      	b.n	4756 <co_util_pack+0x1c6>

            case ('N'): // table size over 2 bytes
            case ('H'): // Short Word
            {
                // Align data buffer to a 16-bits address
                uint16_t *short_word = (uint16_t *)CO_ALIGN2_HI((uint32_t)p_in);
    467a:	2301      	movs	r3, #1
    467c:	1c72      	adds	r2, r6, #1
    467e:	439a      	bics	r2, r3

                if(b_copy)
    4680:	9b03      	ldr	r3, [sp, #12]
    4682:	2b00      	cmp	r3, #0
    4684:	d018      	beq.n	46b8 <co_util_pack+0x128>
                {
                    // Check if enough space in input buffer to read
                    if(((uint8_t *)(short_word + 1)) > p_in_end)
    4686:	9905      	ldr	r1, [sp, #20]
    4688:	1c93      	adds	r3, r2, #2
    468a:	4299      	cmp	r1, r3
    468c:	d366      	bcc.n	475c <co_util_pack+0x1cc>
                        status = CO_UTIL_PACK_IN_BUF_OVFLW;
                        break;
                    }

                    // Copy data
                    if(b_lsb)
    468e:	9902      	ldr	r1, [sp, #8]
    4690:	8813      	ldrh	r3, [r2, #0]
    4692:	2900      	cmp	r1, #0
    4694:	d006      	beq.n	46a4 <co_util_pack+0x114>
 */
__INLINE_S__ void co_write16p(void const *ptr16, uint16_t value)
{
    uint8_t *ptr=(uint8_t*)ptr16;

    *ptr++ = value&0xff;
    4696:	7023      	strb	r3, [r4, #0]
    *ptr = (value&0xff00)>>8;
    4698:	0a1b      	lsrs	r3, r3, #8
    469a:	7063      	strb	r3, [r4, #1]
                    {
                        co_write16p(p_out, co_htons(*short_word));
                    }
                }

                if(data_type == 'N')
    469c:	2f4e      	cmp	r7, #78	; 0x4e
    469e:	d115      	bne.n	46cc <co_util_pack+0x13c>
                {
                    // The current word represents the size of the following table
                    nb = b_lsb ? co_htobs(*short_word) : co_htons(*short_word);
    46a0:	8815      	ldrh	r5, [r2, #0]
    46a2:	e013      	b.n	46cc <co_util_pack+0x13c>
 * @return The 16 bit swapped value.
 ****************************************************************************************
 */
__INLINE_S__ uint16_t co_bswap16(uint16_t val16)
{
    return ((val16<<8)&0xFF00) | ((val16>>8)&0xFF);
    46a4:	0219      	lsls	r1, r3, #8
    46a6:	0a1b      	lsrs	r3, r3, #8
    46a8:	430b      	orrs	r3, r1
    46aa:	b21b      	sxth	r3, r3
 */
__INLINE_S__ void co_write16p(void const *ptr16, uint16_t value)
{
    uint8_t *ptr=(uint8_t*)ptr16;

    *ptr++ = value&0xff;
    46ac:	7023      	strb	r3, [r4, #0]
    *ptr = (value&0xff00)>>8;
    46ae:	0a1b      	lsrs	r3, r3, #8
    46b0:	7063      	strb	r3, [r4, #1]
                    {
                        co_write16p(p_out, co_htons(*short_word));
                    }
                }

                if(data_type == 'N')
    46b2:	2f4e      	cmp	r7, #78	; 0x4e
    46b4:	d10a      	bne.n	46cc <co_util_pack+0x13c>
    46b6:	e004      	b.n	46c2 <co_util_pack+0x132>
    46b8:	2f4e      	cmp	r7, #78	; 0x4e
    46ba:	d107      	bne.n	46cc <co_util_pack+0x13c>
                {
                    // The current word represents the size of the following table
                    nb = b_lsb ? co_htobs(*short_word) : co_htons(*short_word);
    46bc:	9b02      	ldr	r3, [sp, #8]
    46be:	2b00      	cmp	r3, #0
    46c0:	d1ee      	bne.n	46a0 <co_util_pack+0x110>
    46c2:	8813      	ldrh	r3, [r2, #0]
    46c4:	021d      	lsls	r5, r3, #8
    46c6:	0a1b      	lsrs	r3, r3, #8
    46c8:	432b      	orrs	r3, r5
    46ca:	b29d      	uxth	r5, r3
                }

                // Move pointers
                p_in = (uint8_t *)(short_word + 1);
    46cc:	1c96      	adds	r6, r2, #2
                p_out += 2;
    46ce:	3402      	adds	r4, #2
            }
            break;
    46d0:	e784      	b.n	45dc <co_util_pack+0x4c>

            case ('D'): // 24 bits integer
            {
                // Align data buffer to a 32-bits address
                uint32_t *long_word = (uint32_t *)CO_ALIGN4_HI((uint32_t)p_in);
    46d2:	2303      	movs	r3, #3
    46d4:	1cf0      	adds	r0, r6, #3
    46d6:	4398      	bics	r0, r3

                if(b_copy)
    46d8:	9b03      	ldr	r3, [sp, #12]
    46da:	2b00      	cmp	r3, #0
    46dc:	d01d      	beq.n	471a <co_util_pack+0x18a>
                {
                    // Check if enough space in input buffer to read
                    if(((uint8_t *)(long_word + 1)) > p_in_end)
    46de:	9a05      	ldr	r2, [sp, #20]
    46e0:	1d03      	adds	r3, r0, #4
    46e2:	429a      	cmp	r2, r3
    46e4:	d33a      	bcc.n	475c <co_util_pack+0x1cc>
                        status = CO_UTIL_PACK_IN_BUF_OVFLW;
                        break;
                    }

                    // Copy data
                    if(b_lsb)
    46e6:	9b02      	ldr	r3, [sp, #8]
    46e8:	6802      	ldr	r2, [r0, #0]
    46ea:	2b00      	cmp	r3, #0
    46ec:	d005      	beq.n	46fa <co_util_pack+0x16a>
__INLINE_S__ void co_write24p(void const *ptr24, uint32_t value)
{
    uint8_t *ptr=(uint8_t*)ptr24;

    *ptr++ = (uint8_t)(value&0xff);
    *ptr++ = (uint8_t)((value&0xff00)>>8);
    46ee:	0a13      	lsrs	r3, r2, #8
 */
__INLINE_S__ void co_write24p(void const *ptr24, uint32_t value)
{
    uint8_t *ptr=(uint8_t*)ptr24;

    *ptr++ = (uint8_t)(value&0xff);
    46f0:	7022      	strb	r2, [r4, #0]
    *ptr++ = (uint8_t)((value&0xff00)>>8);
    *ptr++ = (uint8_t)((value&0xff0000)>>16);
    46f2:	0c12      	lsrs	r2, r2, #16
__INLINE_S__ void co_write24p(void const *ptr24, uint32_t value)
{
    uint8_t *ptr=(uint8_t*)ptr24;

    *ptr++ = (uint8_t)(value&0xff);
    *ptr++ = (uint8_t)((value&0xff00)>>8);
    46f4:	7063      	strb	r3, [r4, #1]
    *ptr++ = (uint8_t)((value&0xff0000)>>16);
    46f6:	70a2      	strb	r2, [r4, #2]
    46f8:	e00f      	b.n	471a <co_util_pack+0x18a>
 * @return The 24 bit swapped value.
 ****************************************************************************************
 */
__INLINE_S__ uint32_t co_bswap24(uint32_t val24)
{
    return ((val24<<16)&0xFF0000) | ((val24)&0xFF00) | ((val24>>16)&0xFF);
    46fa:	23ff      	movs	r3, #255	; 0xff
    46fc:	0411      	lsls	r1, r2, #16
    46fe:	041b      	lsls	r3, r3, #16
    4700:	400b      	ands	r3, r1
    4702:	0c11      	lsrs	r1, r2, #16
    4704:	b2c9      	uxtb	r1, r1
    4706:	430b      	orrs	r3, r1
    4708:	21ff      	movs	r1, #255	; 0xff
    470a:	0209      	lsls	r1, r1, #8
    470c:	400a      	ands	r2, r1
    470e:	4313      	orrs	r3, r2
__INLINE_S__ void co_write24p(void const *ptr24, uint32_t value)
{
    uint8_t *ptr=(uint8_t*)ptr24;

    *ptr++ = (uint8_t)(value&0xff);
    *ptr++ = (uint8_t)((value&0xff00)>>8);
    4710:	0a1a      	lsrs	r2, r3, #8
 */
__INLINE_S__ void co_write24p(void const *ptr24, uint32_t value)
{
    uint8_t *ptr=(uint8_t*)ptr24;

    *ptr++ = (uint8_t)(value&0xff);
    4712:	7023      	strb	r3, [r4, #0]
    *ptr++ = (uint8_t)((value&0xff00)>>8);
    *ptr++ = (uint8_t)((value&0xff0000)>>16);
    4714:	0c1b      	lsrs	r3, r3, #16
__INLINE_S__ void co_write24p(void const *ptr24, uint32_t value)
{
    uint8_t *ptr=(uint8_t*)ptr24;

    *ptr++ = (uint8_t)(value&0xff);
    *ptr++ = (uint8_t)((value&0xff00)>>8);
    4716:	7062      	strb	r2, [r4, #1]
    *ptr++ = (uint8_t)((value&0xff0000)>>16);
    4718:	70a3      	strb	r3, [r4, #2]
                        co_write24p(p_out, co_hton24(*long_word));
                    }
                }

                // Move pointers
                p_in = (uint8_t *)(long_word + 1);
    471a:	1d06      	adds	r6, r0, #4
                p_out += 3;
    471c:	3403      	adds	r4, #3
            }
            break;
    471e:	e75d      	b.n	45dc <co_util_pack+0x4c>

            case ('L'): // Long Word
            {
                // Align data buffer to a 32-bits address
                uint32_t *long_word = (uint32_t *)CO_ALIGN4_HI((uint32_t)p_in);
    4720:	2303      	movs	r3, #3
    4722:	1cf2      	adds	r2, r6, #3
    4724:	439a      	bics	r2, r3

                if(b_copy)
    4726:	9b03      	ldr	r3, [sp, #12]
    4728:	2b00      	cmp	r3, #0
    472a:	d00f      	beq.n	474c <co_util_pack+0x1bc>
                {
                    // Check if enough space in input buffer to read
                    if(((uint8_t *)(long_word + 1)) > p_in_end)
    472c:	9905      	ldr	r1, [sp, #20]
    472e:	1d13      	adds	r3, r2, #4
    4730:	4299      	cmp	r1, r3
    4732:	d313      	bcc.n	475c <co_util_pack+0x1cc>
                        status = CO_UTIL_PACK_IN_BUF_OVFLW;
                        break;
                    }

                    // Copy data
                    if(b_lsb)
    4734:	9902      	ldr	r1, [sp, #8]
    4736:	6813      	ldr	r3, [r2, #0]
    4738:	2900      	cmp	r1, #0
    473a:	d100      	bne.n	473e <co_util_pack+0x1ae>
    473c:	ba1b      	rev	r3, r3
__INLINE_S__ void co_write32p(void const *ptr32, uint32_t value)
{
    uint8_t *ptr=(uint8_t*)ptr32;

    *ptr++ = (uint8_t)(value&0xff);
    *ptr++ = (uint8_t)((value&0xff00)>>8);
    473e:	0a19      	lsrs	r1, r3, #8
 */
__INLINE_S__ void co_write32p(void const *ptr32, uint32_t value)
{
    uint8_t *ptr=(uint8_t*)ptr32;

    *ptr++ = (uint8_t)(value&0xff);
    4740:	7023      	strb	r3, [r4, #0]
    *ptr++ = (uint8_t)((value&0xff00)>>8);
    4742:	7061      	strb	r1, [r4, #1]
    *ptr++ = (uint8_t)((value&0xff0000)>>16);
    4744:	0c19      	lsrs	r1, r3, #16
    *ptr = (uint8_t)((value&0xff000000)>>24);
    4746:	0e1b      	lsrs	r3, r3, #24
{
    uint8_t *ptr=(uint8_t*)ptr32;

    *ptr++ = (uint8_t)(value&0xff);
    *ptr++ = (uint8_t)((value&0xff00)>>8);
    *ptr++ = (uint8_t)((value&0xff0000)>>16);
    4748:	70a1      	strb	r1, [r4, #2]
    *ptr = (uint8_t)((value&0xff000000)>>24);
    474a:	70e3      	strb	r3, [r4, #3]
                        co_write32p(p_out, co_htonl(*long_word));
                    }
                }

                // Move pointers
                p_in = (uint8_t *)(long_word + 1);
    474c:	1d16      	adds	r6, r2, #4
                p_out += 4;
    474e:	3404      	adds	r4, #4
            }
            break;
    4750:	e744      	b.n	45dc <co_util_pack+0x4c>

            default:
            {
                // data format error
                status = CO_UTIL_PACK_WRONG_FORMAT;
    4752:	2303      	movs	r3, #3
    4754:	e741      	b.n	45da <co_util_pack+0x4a>
                {
                    // The current byte represents the size of the following table
                    nb = *(p_in - 1);
                }

                big_number = false;
    4756:	2300      	movs	r3, #0
    4758:	9304      	str	r3, [sp, #16]
    475a:	e73f      	b.n	45dc <co_util_pack+0x4c>
                if(b_copy)
                {
                    // Check if enough space in input buffer to read
                    if(((uint8_t *)(long_word + 1)) > p_in_end)
                    {
                        status = CO_UTIL_PACK_IN_BUF_OVFLW;
    475c:	2301      	movs	r3, #1
    475e:	e73c      	b.n	45da <co_util_pack+0x4a>
            }
            break;
        }
    }

    if(status == CO_UTIL_PACK_OK)
    4760:	9b01      	ldr	r3, [sp, #4]
    4762:	2b00      	cmp	r3, #0
    4764:	d103      	bne.n	476e <co_util_pack+0x1de>
    {
        *out_len = (uint16_t)(p_out - out);
    4766:	9b06      	ldr	r3, [sp, #24]
    4768:	1ae4      	subs	r4, r4, r3
    476a:	9b07      	ldr	r3, [sp, #28]
    476c:	801c      	strh	r4, [r3, #0]
    }

    return (status);
}
    476e:	9801      	ldr	r0, [sp, #4]
    4770:	b00b      	add	sp, #44	; 0x2c
    4772:	bdf0      	pop	{r4, r5, r6, r7, pc}

00004774 <co_util_unpack>:

uint8_t co_util_unpack(uint8_t* out, uint8_t* in, uint16_t* out_len, uint16_t in_len, const char* format)
{
    4774:	b5f0      	push	{r4, r5, r6, r7, lr}
    4776:	b08b      	sub	sp, #44	; 0x2c
    4778:	9207      	str	r2, [sp, #28]
    uint8_t status = CO_UTIL_PACK_OK;
    uint8_t* p_in = in;
    uint8_t* p_out = out;
    uint8_t* p_in_end = in + in_len;
    477a:	18cb      	adds	r3, r1, r3
    477c:	9304      	str	r3, [sp, #16]
    uint8_t* p_out_end = out + *out_len;
    477e:	9b07      	ldr	r3, [sp, #28]

    return (status);
}

uint8_t co_util_unpack(uint8_t* out, uint8_t* in, uint16_t* out_len, uint16_t in_len, const char* format)
{
    4780:	9a10      	ldr	r2, [sp, #64]	; 0x40
    uint8_t status = CO_UTIL_PACK_OK;
    uint8_t* p_in = in;
    uint8_t* p_out = out;
    uint8_t* p_in_end = in + in_len;
    uint8_t* p_out_end = out + *out_len;
    4782:	881b      	ldrh	r3, [r3, #0]

    return (status);
}

uint8_t co_util_unpack(uint8_t* out, uint8_t* in, uint16_t* out_len, uint16_t in_len, const char* format)
{
    4784:	9005      	str	r0, [sp, #20]
    uint8_t status = CO_UTIL_PACK_OK;
    uint8_t* p_in = in;
    uint8_t* p_out = out;
    uint8_t* p_in_end = in + in_len;
    uint8_t* p_out_end = out + *out_len;
    4786:	18c3      	adds	r3, r0, r3

    return (status);
}

uint8_t co_util_unpack(uint8_t* out, uint8_t* in, uint16_t* out_len, uint16_t in_len, const char* format)
{
    4788:	000c      	movs	r4, r1
    uint8_t status = CO_UTIL_PACK_OK;
    uint8_t* p_in = in;
    uint8_t* p_out = out;
    uint8_t* p_in_end = in + in_len;
    uint8_t* p_out_end = out + *out_len;
    478a:	9306      	str	r3, [sp, #24]
    char* cursor = (char*) format;
    478c:	9209      	str	r2, [sp, #36]	; 0x24
    bool b_copy = ((out != NULL) && (in != NULL));
    478e:	9003      	str	r0, [sp, #12]
    4790:	2800      	cmp	r0, #0
    4792:	d003      	beq.n	479c <co_util_unpack+0x28>
    4794:	0021      	movs	r1, r4
    4796:	1e4b      	subs	r3, r1, #1
    4798:	4199      	sbcs	r1, r3
    479a:	9103      	str	r1, [sp, #12]
    bool b_lsb = true;
    bool big_number = false;
    uint16_t nb = 1;

    // Check if forced to little endian
    if(*cursor == '<')
    479c:	7813      	ldrb	r3, [r2, #0]
    479e:	2b3c      	cmp	r3, #60	; 0x3c
    47a0:	d103      	bne.n	47aa <co_util_unpack+0x36>
    {
        b_lsb = true;
        cursor++;
    47a2:	3201      	adds	r2, #1
    47a4:	9209      	str	r2, [sp, #36]	; 0x24
    uint16_t nb = 1;

    // Check if forced to little endian
    if(*cursor == '<')
    {
        b_lsb = true;
    47a6:	3b3b      	subs	r3, #59	; 0x3b
    47a8:	e006      	b.n	47b8 <co_util_unpack+0x44>
    uint8_t* p_in_end = in + in_len;
    uint8_t* p_out_end = out + *out_len;
    char* cursor = (char*) format;
    bool b_copy = ((out != NULL) && (in != NULL));

    bool b_lsb = true;
    47aa:	2101      	movs	r1, #1
    47ac:	9101      	str	r1, [sp, #4]
    if(*cursor == '<')
    {
        b_lsb = true;
        cursor++;
    }
    else if(*cursor == '>')
    47ae:	2b3e      	cmp	r3, #62	; 0x3e
    47b0:	d103      	bne.n	47ba <co_util_unpack+0x46>
    {
        b_lsb = false;
    47b2:	2300      	movs	r3, #0
        cursor++;
    47b4:	1852      	adds	r2, r2, r1
    47b6:	9209      	str	r2, [sp, #36]	; 0x24
        b_lsb = true;
        cursor++;
    }
    else if(*cursor == '>')
    {
        b_lsb = false;
    47b8:	9301      	str	r3, [sp, #4]
                {
                    // The current byte represents the size of the following table
                    nb = *(p_in - 1);
                }

                big_number = false;
    47ba:	2300      	movs	r3, #0
    47bc:	2501      	movs	r5, #1
    47be:	9e05      	ldr	r6, [sp, #20]
    47c0:	9302      	str	r3, [sp, #8]
                    }

                    // Check if enough space in out buffer to write
                    if(((uint8_t *)(long_word + 1)) > p_out_end)
                    {
                        status = CO_UTIL_PACK_OUT_BUF_OVFLW;
    47c2:	9300      	str	r3, [sp, #0]
        cursor++;
    }

    ASSERT_ERR(format != NULL);

    while((*cursor != '\0') && (status == CO_UTIL_PACK_OK))
    47c4:	9b09      	ldr	r3, [sp, #36]	; 0x24
    47c6:	781b      	ldrb	r3, [r3, #0]
    47c8:	2b00      	cmp	r3, #0
    47ca:	d106      	bne.n	47da <co_util_unpack+0x66>
            break;
        }
    }

    // Check a potential mismatch between the theoretical (measured) input length and the given input length
    if(p_in > p_in_end)
    47cc:	9b04      	ldr	r3, [sp, #16]
    47ce:	429c      	cmp	r4, r3
    47d0:	d800      	bhi.n	47d4 <co_util_unpack+0x60>
    47d2:	e0e3      	b.n	499c <co_util_unpack+0x228>
    {
        status = CO_UTIL_PACK_IN_BUF_OVFLW;
    47d4:	2301      	movs	r3, #1
    47d6:	9300      	str	r3, [sp, #0]
    47d8:	e0e0      	b.n	499c <co_util_unpack+0x228>
        cursor++;
    }

    ASSERT_ERR(format != NULL);

    while((*cursor != '\0') && (status == CO_UTIL_PACK_OK))
    47da:	9a00      	ldr	r2, [sp, #0]
    47dc:	2a00      	cmp	r2, #0
    47de:	d1f5      	bne.n	47cc <co_util_unpack+0x58>
    {
        char data_type;

        // Check if the new field is a fixed size array (starting with a number)
        if((*cursor >= '0') && (*cursor <= '9'))
    47e0:	3b30      	subs	r3, #48	; 0x30
    47e2:	2b09      	cmp	r3, #9
    47e4:	d803      	bhi.n	47ee <co_util_unpack+0x7a>
        {
            nb = co_util_read_array_size(&cursor);
    47e6:	a809      	add	r0, sp, #36	; 0x24
    47e8:	f7ff feab 	bl	4542 <co_util_read_array_size>
    47ec:	0005      	movs	r5, r0
        }

        data_type = *cursor++;
    47ee:	9b09      	ldr	r3, [sp, #36]	; 0x24
    47f0:	1c5a      	adds	r2, r3, #1
    47f2:	9209      	str	r2, [sp, #36]	; 0x24
    47f4:	781f      	ldrb	r7, [r3, #0]

        // Parse the format string
        switch (data_type)
    47f6:	2f48      	cmp	r7, #72	; 0x48
    47f8:	d03f      	beq.n	487a <co_util_unpack+0x106>
    47fa:	d807      	bhi.n	480c <co_util_unpack+0x98>
    47fc:	2f44      	cmp	r7, #68	; 0x44
    47fe:	d071      	beq.n	48e4 <co_util_unpack+0x170>
    4800:	2f47      	cmp	r7, #71	; 0x47
    4802:	d00b      	beq.n	481c <co_util_unpack+0xa8>
    4804:	2f42      	cmp	r7, #66	; 0x42
    4806:	d000      	beq.n	480a <co_util_unpack+0x96>
    4808:	e0bf      	b.n	498a <co_util_unpack+0x216>
    480a:	e009      	b.n	4820 <co_util_unpack+0xac>
    480c:	2f4e      	cmp	r7, #78	; 0x4e
    480e:	d034      	beq.n	487a <co_util_unpack+0x106>
    4810:	2f6e      	cmp	r7, #110	; 0x6e
    4812:	d005      	beq.n	4820 <co_util_unpack+0xac>
    4814:	2f4c      	cmp	r7, #76	; 0x4c
    4816:	d100      	bne.n	481a <co_util_unpack+0xa6>
    4818:	e08e      	b.n	4938 <co_util_unpack+0x1c4>
    481a:	e0b6      	b.n	498a <co_util_unpack+0x216>
        {
            case ('G'): // Big Number
            {
                big_number = true;
    481c:	2301      	movs	r3, #1
    481e:	9302      	str	r3, [sp, #8]
            } // No break
            case ('n'): // table size over 1 byte
            case ('B'): // Byte
            {
                if(b_copy)
    4820:	9b03      	ldr	r3, [sp, #12]
    4822:	2b00      	cmp	r3, #0
    4824:	d020      	beq.n	4868 <co_util_unpack+0xf4>
                {
                    // Check if enough space in input buffer to read
                    if((p_in + nb) > p_in_end)
    4826:	9a04      	ldr	r2, [sp, #16]
    4828:	1963      	adds	r3, r4, r5
    482a:	429a      	cmp	r2, r3
    482c:	d200      	bcs.n	4830 <co_util_unpack+0xbc>
    482e:	e0b1      	b.n	4994 <co_util_unpack+0x220>
                        status = CO_UTIL_PACK_IN_BUF_OVFLW;
                        break;
                    }

                    // Check if enough space in out buffer to write
                    if((p_out + nb) > p_out_end)
    4830:	9a06      	ldr	r2, [sp, #24]
    4832:	1973      	adds	r3, r6, r5
    4834:	429a      	cmp	r2, r3
    4836:	d200      	bcs.n	483a <co_util_unpack+0xc6>
    4838:	e0ae      	b.n	4998 <co_util_unpack+0x224>
                        status = CO_UTIL_PACK_OUT_BUF_OVFLW;
                        break;
                    }

                    // Copy bytes
                    if(!big_number || (b_lsb == CPU_LE))
    483a:	9b02      	ldr	r3, [sp, #8]
    483c:	2b00      	cmp	r3, #0
    483e:	d005      	beq.n	484c <co_util_unpack+0xd8>
    4840:	9b01      	ldr	r3, [sp, #4]
    4842:	2b00      	cmp	r3, #0
    4844:	d102      	bne.n	484c <co_util_unpack+0xd8>
    4846:	002b      	movs	r3, r5
    4848:	0032      	movs	r2, r6
    484a:	e005      	b.n	4858 <co_util_unpack+0xe4>
                    {
                        memcpy(p_out, p_in, nb);
    484c:	002a      	movs	r2, r5
    484e:	0021      	movs	r1, r4
    4850:	0030      	movs	r0, r6
    4852:	f011 f8bd 	bl	159d0 <memcpy>
    4856:	e007      	b.n	4868 <co_util_unpack+0xf4>
 * @param[in] len       number of bytes to swap
 ****************************************************************************************
 */
__INLINE_S__ void co_bswap(uint8_t* p_val_out, const uint8_t* p_val_in, uint16_t len)
{
    while (len > 0)
    4858:	2b00      	cmp	r3, #0
    485a:	d005      	beq.n	4868 <co_util_unpack+0xf4>
    {
        len--;
    485c:	3b01      	subs	r3, #1
    485e:	b29b      	uxth	r3, r3
        *p_val_out = p_val_in[len];
    4860:	5ce1      	ldrb	r1, [r4, r3]
    4862:	7011      	strb	r1, [r2, #0]
        p_val_out++;
    4864:	3201      	adds	r2, #1
    4866:	e7f7      	b.n	4858 <co_util_unpack+0xe4>
                        co_bswap(p_out, p_in, nb);
                    }
                }

                // Move pointers
                p_out += nb;
    4868:	1976      	adds	r6, r6, r5
                p_in += nb;
    486a:	1964      	adds	r4, r4, r5

                // Re-initialize table size for next loop
                nb = 1;
    486c:	2501      	movs	r5, #1
                if(data_type == 'n')
    486e:	2f6e      	cmp	r7, #110	; 0x6e
    4870:	d000      	beq.n	4874 <co_util_unpack+0x100>
    4872:	e08c      	b.n	498e <co_util_unpack+0x21a>
                {
                    // The current byte represents the size of the following table
                    nb = *(p_in - 1);
    4874:	1e63      	subs	r3, r4, #1
    4876:	781d      	ldrb	r5, [r3, #0]
    4878:	e089      	b.n	498e <co_util_unpack+0x21a>

            case ('N'): // table size over 2 bytes
            case ('H'): // Short Word
            {
                // Align data buffer to a 16-bits address
                uint16_t *short_word = (uint16_t *)CO_ALIGN2_HI((uint32_t)p_out);
    487a:	2301      	movs	r3, #1
    487c:	1c71      	adds	r1, r6, #1
    487e:	4399      	bics	r1, r3

                if(b_copy)
    4880:	9b03      	ldr	r3, [sp, #12]
    4882:	2b00      	cmp	r3, #0
    4884:	d01e      	beq.n	48c4 <co_util_unpack+0x150>
                {
                    // Check if enough space in input buffer to read
                    if((p_in + 2) > p_in_end)
    4886:	9a04      	ldr	r2, [sp, #16]
    4888:	1ca3      	adds	r3, r4, #2
    488a:	429a      	cmp	r2, r3
    488c:	d200      	bcs.n	4890 <co_util_unpack+0x11c>
    488e:	e081      	b.n	4994 <co_util_unpack+0x220>
                        status = CO_UTIL_PACK_IN_BUF_OVFLW;
                        break;
                    }

                    // Check if enough space in out buffer to write
                    if(((uint8_t *)(short_word + 1)) > p_out_end)
    4890:	9a06      	ldr	r2, [sp, #24]
    4892:	1c8b      	adds	r3, r1, #2
    4894:	429a      	cmp	r2, r3
    4896:	d37f      	bcc.n	4998 <co_util_unpack+0x224>
    4898:	7862      	ldrb	r2, [r4, #1]
    489a:	7823      	ldrb	r3, [r4, #0]
                        status = CO_UTIL_PACK_OUT_BUF_OVFLW;
                        break;
                    }

                    // Copy data
                    if(b_lsb)
    489c:	9801      	ldr	r0, [sp, #4]
                    {
                        *short_word = co_btohs(co_read16p(p_in));
    489e:	0212      	lsls	r2, r2, #8
    48a0:	4313      	orrs	r3, r2
                        status = CO_UTIL_PACK_OUT_BUF_OVFLW;
                        break;
                    }

                    // Copy data
                    if(b_lsb)
    48a2:	2800      	cmp	r0, #0
    48a4:	d007      	beq.n	48b6 <co_util_unpack+0x142>
                    {
                        *short_word = co_btohs(co_read16p(p_in));
    48a6:	800b      	strh	r3, [r1, #0]
                    {
                        *short_word = co_ntohs(co_read16p(p_in));
                    }
                }

                if(data_type == 'N')
    48a8:	2f4e      	cmp	r7, #78	; 0x4e
    48aa:	d118      	bne.n	48de <co_util_unpack+0x16a>
 * @return The 16 bits value.
 ****************************************************************************************
 */
__INLINE_S__ uint16_t co_read16p(void const *ptr16)
{
    uint16_t value = ((uint8_t *)ptr16)[0] | ((uint8_t *)ptr16)[1] << 8;
    48ac:	7865      	ldrb	r5, [r4, #1]
    48ae:	7823      	ldrb	r3, [r4, #0]
    48b0:	022d      	lsls	r5, r5, #8
    48b2:	431d      	orrs	r5, r3
    48b4:	e013      	b.n	48de <co_util_unpack+0x16a>
                    {
                        *short_word = co_btohs(co_read16p(p_in));
                    }
                    else
                    {
                        *short_word = co_ntohs(co_read16p(p_in));
    48b6:	0a1a      	lsrs	r2, r3, #8
    48b8:	021b      	lsls	r3, r3, #8
    48ba:	4313      	orrs	r3, r2
    48bc:	800b      	strh	r3, [r1, #0]
                    }
                }

                if(data_type == 'N')
    48be:	2f4e      	cmp	r7, #78	; 0x4e
    48c0:	d10d      	bne.n	48de <co_util_unpack+0x16a>
    48c2:	e004      	b.n	48ce <co_util_unpack+0x15a>
    48c4:	2f4e      	cmp	r7, #78	; 0x4e
    48c6:	d10a      	bne.n	48de <co_util_unpack+0x16a>
                {
                    nb = b_lsb ? co_btohs(co_read16p(p_in)) : co_ntohs(co_read16p(p_in));
    48c8:	9b01      	ldr	r3, [sp, #4]
    48ca:	2b00      	cmp	r3, #0
    48cc:	d1ee      	bne.n	48ac <co_util_unpack+0x138>
    48ce:	7863      	ldrb	r3, [r4, #1]
    48d0:	7825      	ldrb	r5, [r4, #0]
    48d2:	021b      	lsls	r3, r3, #8
    48d4:	432b      	orrs	r3, r5
 * @return The 16 bit swapped value.
 ****************************************************************************************
 */
__INLINE_S__ uint16_t co_bswap16(uint16_t val16)
{
    return ((val16<<8)&0xFF00) | ((val16>>8)&0xFF);
    48d6:	021d      	lsls	r5, r3, #8
    48d8:	0a1b      	lsrs	r3, r3, #8
    48da:	432b      	orrs	r3, r5
    48dc:	b29d      	uxth	r5, r3
                }

                // Move pointers
                p_out = (uint8_t *)(short_word + 1);
    48de:	1c8e      	adds	r6, r1, #2
                p_in += 2;
    48e0:	3402      	adds	r4, #2
            }
            break;
    48e2:	e76f      	b.n	47c4 <co_util_unpack+0x50>

            case ('D'): // 24 bits integer
            {
                // Align data buffer to a 32-bits address
                uint32_t *long_word = (uint32_t *)CO_ALIGN4_HI((uint32_t)p_out);
    48e4:	2303      	movs	r3, #3
    48e6:	1cf0      	adds	r0, r6, #3
    48e8:	4398      	bics	r0, r3

                if(b_copy)
    48ea:	9b03      	ldr	r3, [sp, #12]
    48ec:	2b00      	cmp	r3, #0
    48ee:	d020      	beq.n	4932 <co_util_unpack+0x1be>
                {
                    // Check if enough space in input buffer to read
                    if((p_in + 3) > p_in_end)
    48f0:	9a04      	ldr	r2, [sp, #16]
    48f2:	1ce3      	adds	r3, r4, #3
    48f4:	429a      	cmp	r2, r3
    48f6:	d34d      	bcc.n	4994 <co_util_unpack+0x220>
                        status = CO_UTIL_PACK_IN_BUF_OVFLW;
                        break;
                    }

                    // Check if enough space in out buffer to write
                    if(((uint8_t *)(long_word + 1)) > p_out_end)
    48f8:	9a06      	ldr	r2, [sp, #24]
    48fa:	1d03      	adds	r3, r0, #4
    48fc:	429a      	cmp	r2, r3
    48fe:	d34b      	bcc.n	4998 <co_util_unpack+0x224>
    4900:	7861      	ldrb	r1, [r4, #1]
    4902:	7823      	ldrb	r3, [r4, #0]
                        status = CO_UTIL_PACK_OUT_BUF_OVFLW;
                        break;
                    }

                    // Copy data
                    if(b_lsb)
    4904:	9e01      	ldr	r6, [sp, #4]
                    {
                        *long_word = co_btoh24(co_read24p(p_in));
    4906:	0209      	lsls	r1, r1, #8
    4908:	78a2      	ldrb	r2, [r4, #2]
    490a:	4319      	orrs	r1, r3
                        status = CO_UTIL_PACK_OUT_BUF_OVFLW;
                        break;
                    }

                    // Copy data
                    if(b_lsb)
    490c:	2e00      	cmp	r6, #0
    490e:	d003      	beq.n	4918 <co_util_unpack+0x1a4>
                    {
                        *long_word = co_btoh24(co_read24p(p_in));
    4910:	0412      	lsls	r2, r2, #16
    4912:	4311      	orrs	r1, r2
    4914:	6001      	str	r1, [r0, #0]
    4916:	e00c      	b.n	4932 <co_util_unpack+0x1be>
__INLINE_S__ uint32_t co_read24p(void const *ptr24)
{
    uint16_t addr_l, addr_h;
    addr_l = co_read16p(ptr24);
    addr_h = *((uint8_t *)ptr24 + 2) & 0x00FF;
    return ((uint32_t)addr_l | (uint32_t)addr_h << 16);
    4918:	0413      	lsls	r3, r2, #16
    491a:	430b      	orrs	r3, r1
                    }
                    else
                    {
                        *long_word = co_ntoh24(co_read24p(p_in));
    491c:	21ff      	movs	r1, #255	; 0xff
    491e:	0209      	lsls	r1, r1, #8
    4920:	0c1a      	lsrs	r2, r3, #16
    4922:	4019      	ands	r1, r3
    4924:	4311      	orrs	r1, r2
    4926:	22ff      	movs	r2, #255	; 0xff
    4928:	041b      	lsls	r3, r3, #16
    492a:	0412      	lsls	r2, r2, #16
    492c:	4013      	ands	r3, r2
    492e:	430b      	orrs	r3, r1
    4930:	6003      	str	r3, [r0, #0]
                    }
                }

                // Move pointers
                p_out = (uint8_t *)(long_word + 1);
    4932:	1d06      	adds	r6, r0, #4
                p_in += 3;
    4934:	3403      	adds	r4, #3
            }
            break;
    4936:	e745      	b.n	47c4 <co_util_unpack+0x50>

            case ('L'): // Long Word
            {
                // Align data buffer to a 32-bits address
                uint32_t *long_word = (uint32_t *)CO_ALIGN4_HI((uint32_t)p_out);
    4938:	2303      	movs	r3, #3
    493a:	1cf2      	adds	r2, r6, #3
    493c:	439a      	bics	r2, r3

                if(b_copy)
    493e:	9b03      	ldr	r3, [sp, #12]
    4940:	2b00      	cmp	r3, #0
    4942:	d01f      	beq.n	4984 <co_util_unpack+0x210>
                {
                    // Check if enough space in input buffer to read
                    if((p_in + 4) > p_in_end)
    4944:	9904      	ldr	r1, [sp, #16]
    4946:	1d23      	adds	r3, r4, #4
    4948:	4299      	cmp	r1, r3
    494a:	d323      	bcc.n	4994 <co_util_unpack+0x220>
                        status = CO_UTIL_PACK_IN_BUF_OVFLW;
                        break;
                    }

                    // Check if enough space in out buffer to write
                    if(((uint8_t *)(long_word + 1)) > p_out_end)
    494c:	9906      	ldr	r1, [sp, #24]
    494e:	1d13      	adds	r3, r2, #4
    4950:	4299      	cmp	r1, r3
    4952:	d321      	bcc.n	4998 <co_util_unpack+0x224>
                        status = CO_UTIL_PACK_OUT_BUF_OVFLW;
                        break;
                    }

                    // Copy data
                    if(b_lsb)
    4954:	9801      	ldr	r0, [sp, #4]
    4956:	7863      	ldrb	r3, [r4, #1]
    4958:	7826      	ldrb	r6, [r4, #0]
    495a:	78a7      	ldrb	r7, [r4, #2]
    495c:	78e1      	ldrb	r1, [r4, #3]
    495e:	2800      	cmp	r0, #0
    4960:	d007      	beq.n	4972 <co_util_unpack+0x1fe>
                    {
                        *long_word = co_btohl(co_read32p(p_in));
    4962:	0208      	lsls	r0, r1, #8
    4964:	4338      	orrs	r0, r7
    4966:	021b      	lsls	r3, r3, #8
    4968:	0400      	lsls	r0, r0, #16
    496a:	4333      	orrs	r3, r6
    496c:	4318      	orrs	r0, r3
    496e:	6010      	str	r0, [r2, #0]
    4970:	e008      	b.n	4984 <co_util_unpack+0x210>
    4972:	0208      	lsls	r0, r1, #8
    4974:	0219      	lsls	r1, r3, #8
    4976:	0033      	movs	r3, r6
    4978:	4338      	orrs	r0, r7
    497a:	0400      	lsls	r0, r0, #16
    497c:	430b      	orrs	r3, r1
    497e:	4303      	orrs	r3, r0
    4980:	ba1b      	rev	r3, r3
                    }
                    else
                    {
                        *long_word = co_ntohl(co_read32p(p_in));
    4982:	6013      	str	r3, [r2, #0]
                    }
                }

                // Move pointers
                p_out = (uint8_t *)(long_word + 1);
    4984:	1d16      	adds	r6, r2, #4
                p_in += 4;
    4986:	3404      	adds	r4, #4
            }
            break;
    4988:	e71c      	b.n	47c4 <co_util_unpack+0x50>

            default:
            {
                // data format error
                status = CO_UTIL_PACK_WRONG_FORMAT;
    498a:	2303      	movs	r3, #3
    498c:	e719      	b.n	47c2 <co_util_unpack+0x4e>
                {
                    // The current byte represents the size of the following table
                    nb = *(p_in - 1);
                }

                big_number = false;
    498e:	2300      	movs	r3, #0
    4990:	9302      	str	r3, [sp, #8]
    4992:	e717      	b.n	47c4 <co_util_unpack+0x50>
                if(b_copy)
                {
                    // Check if enough space in input buffer to read
                    if((p_in + 4) > p_in_end)
                    {
                        status = CO_UTIL_PACK_IN_BUF_OVFLW;
    4994:	2301      	movs	r3, #1
    4996:	e714      	b.n	47c2 <co_util_unpack+0x4e>
                    }

                    // Check if enough space in out buffer to write
                    if(((uint8_t *)(long_word + 1)) > p_out_end)
                    {
                        status = CO_UTIL_PACK_OUT_BUF_OVFLW;
    4998:	2302      	movs	r3, #2
    499a:	e712      	b.n	47c2 <co_util_unpack+0x4e>
    {
        status = CO_UTIL_PACK_IN_BUF_OVFLW;
    }

    // Return the total size needed for unpacked parameters
    *out_len = (uint16_t)(p_out - out);
    499c:	9b05      	ldr	r3, [sp, #20]

    return (status);
}
    499e:	9800      	ldr	r0, [sp, #0]
    {
        status = CO_UTIL_PACK_IN_BUF_OVFLW;
    }

    // Return the total size needed for unpacked parameters
    *out_len = (uint16_t)(p_out - out);
    49a0:	1af6      	subs	r6, r6, r3
    49a2:	9b07      	ldr	r3, [sp, #28]
    49a4:	801e      	strh	r6, [r3, #0]

    return (status);
}
    49a6:	b00b      	add	sp, #44	; 0x2c
    49a8:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

000049ac <m_print>:
//int m_printf(const char *fmt, ...)
#define BUF_LEN 256
static char buf[BUF_LEN];

int m_print(const char *fmt, ...)
{
    49ac:	b40f      	push	{r0, r1, r2, r3}
    49ae:	b573      	push	{r0, r1, r4, r5, r6, lr}
    49b0:	ab06      	add	r3, sp, #24
    49b2:	cb04      	ldmia	r3!, {r2}
#define ASSERT_WARN(cond, param0, param1) {while(!(cond));}
#endif

__INLINE_S__ void GLOBAL_INT_DISABLE(void )
{
	__asm volatile ("cpsid i" : : : "memory");
    49b4:	b672      	cpsid	i
	
	va_list arg;
	GLOBAL_INT_DISABLE();
	va_start(arg,fmt);//实际上可以理解为(char *)&fmt+4指向了第一个参数，（char *)&fmt+8指向了第二个参数
	/*4是参数fmt所占堆栈中的大小 typedef char * va_list*/
	n = vsnprintf(buf, BUF_LEN-1, fmt, arg);
    49b6:	4e0d      	ldr	r6, [pc, #52]	; (49ec <m_print+0x40>)
    49b8:	21ff      	movs	r1, #255	; 0xff
    49ba:	0030      	movs	r0, r6
{
	int i = 0, n;
	
	va_list arg;
	GLOBAL_INT_DISABLE();
	va_start(arg,fmt);//实际上可以理解为(char *)&fmt+4指向了第一个参数，（char *)&fmt+8指向了第二个参数
    49bc:	9301      	str	r3, [sp, #4]
	/*4是参数fmt所占堆栈中的大小 typedef char * va_list*/
	n = vsnprintf(buf, BUF_LEN-1, fmt, arg);
    49be:	f012 fdef 	bl	175a0 <vsnprintf>
}

__INLINE_S__ void GLOBAL_INT_RESTORE(void)
{
	__asm volatile ("cpsie i" : : : "memory");
    49c2:	b662      	cpsie	i
    49c4:	0004      	movs	r4, r0
    49c6:	28ff      	cmp	r0, #255	; 0xff
    49c8:	dd00      	ble.n	49cc <m_print+0x20>
    49ca:	24ff      	movs	r4, #255	; 0xff
	GLOBAL_INT_RESTORE();
	if(n >= BUF_LEN)
		n = BUF_LEN - 1;
	buf[n] = 0;
    49cc:	2500      	movs	r5, #0
    49ce:	5535      	strb	r5, [r6, r4]
	
	while(buf[i] && (i < n)){
    49d0:	5d70      	ldrb	r0, [r6, r5]
    49d2:	2800      	cmp	r0, #0
    49d4:	d005      	beq.n	49e2 <m_print+0x36>
    49d6:	42a5      	cmp	r5, r4
    49d8:	da03      	bge.n	49e2 <m_print+0x36>
		UART_PutChar(buf[i]);
    49da:	f7fc fff9 	bl	19d0 <UART_PutChar>
		i++;
    49de:	3501      	adds	r5, #1
    49e0:	e7f6      	b.n	49d0 <m_print+0x24>
	}
	va_end(arg);
	
 	return n;
}
    49e2:	0020      	movs	r0, r4
    49e4:	bc76      	pop	{r1, r2, r4, r5, r6}
    49e6:	bc08      	pop	{r3}
    49e8:	b004      	add	sp, #16
    49ea:	4718      	bx	r3
    49ec:	1001101c 	.word	0x1001101c

000049f0 <m_printf>:

int m_printf(uint32_t lev,const char *fmt, ...)
{
    49f0:	b40e      	push	{r1, r2, r3}
	if(!(lev & L_LEV))
    49f2:	4b1c      	ldr	r3, [pc, #112]	; (4a64 <m_printf+0x74>)
	
 	return n;
}

int m_printf(uint32_t lev,const char *fmt, ...)
{
    49f4:	b577      	push	{r0, r1, r2, r4, r5, r6, lr}
	if(!(lev & L_LEV))
    49f6:	681b      	ldr	r3, [r3, #0]
    49f8:	4203      	tst	r3, r0
    49fa:	d02d      	beq.n	4a58 <m_printf+0x68>
		return 0;
	
	//print start log
	for(int i = 0; i < sizeof(lgs)-1; ++i){
		UART_PutChar(lgs[i]);
    49fc:	205b      	movs	r0, #91	; 0x5b
    49fe:	f7fc ffe7 	bl	19d0 <UART_PutChar>
    4a02:	204d      	movs	r0, #77	; 0x4d
    4a04:	f7fc ffe4 	bl	19d0 <UART_PutChar>
    4a08:	204c      	movs	r0, #76	; 0x4c
    4a0a:	f7fc ffe1 	bl	19d0 <UART_PutChar>
    4a0e:	2047      	movs	r0, #71	; 0x47
    4a10:	f7fc ffde 	bl	19d0 <UART_PutChar>
    4a14:	205d      	movs	r0, #93	; 0x5d
    4a16:	f7fc ffdb 	bl	19d0 <UART_PutChar>
#define ASSERT_WARN(cond, param0, param1) {while(!(cond));}
#endif

__INLINE_S__ void GLOBAL_INT_DISABLE(void )
{
	__asm volatile ("cpsid i" : : : "memory");
    4a1a:	b672      	cpsid	i
	int i = 0, n;
	va_list arg;
	GLOBAL_INT_DISABLE();
	va_start(arg,fmt);//实际上可以理解为(char *)&fmt+4指向了第一个参数，（char *)&fmt+8指向了第二个参数
	/*4是参数fmt所占堆栈中的大小 typedef char * va_list*/
	n = vsnprintf(buf, sizeof(buf)-1, fmt, arg);
    4a1c:	4e12      	ldr	r6, [pc, #72]	; (4a68 <m_printf+0x78>)
	}
	
	int i = 0, n;
	va_list arg;
	GLOBAL_INT_DISABLE();
	va_start(arg,fmt);//实际上可以理解为(char *)&fmt+4指向了第一个参数，（char *)&fmt+8指向了第二个参数
    4a1e:	ab08      	add	r3, sp, #32
	/*4是参数fmt所占堆栈中的大小 typedef char * va_list*/
	n = vsnprintf(buf, sizeof(buf)-1, fmt, arg);
    4a20:	9a07      	ldr	r2, [sp, #28]
    4a22:	21ff      	movs	r1, #255	; 0xff
    4a24:	0030      	movs	r0, r6
	}
	
	int i = 0, n;
	va_list arg;
	GLOBAL_INT_DISABLE();
	va_start(arg,fmt);//实际上可以理解为(char *)&fmt+4指向了第一个参数，（char *)&fmt+8指向了第二个参数
    4a26:	9301      	str	r3, [sp, #4]
	/*4是参数fmt所占堆栈中的大小 typedef char * va_list*/
	n = vsnprintf(buf, sizeof(buf)-1, fmt, arg);
    4a28:	f012 fdba 	bl	175a0 <vsnprintf>
}

__INLINE_S__ void GLOBAL_INT_RESTORE(void)
{
	__asm volatile ("cpsie i" : : : "memory");
    4a2c:	b662      	cpsie	i
    4a2e:	0005      	movs	r5, r0
    4a30:	28ff      	cmp	r0, #255	; 0xff
    4a32:	dd00      	ble.n	4a36 <m_printf+0x46>
    4a34:	25ff      	movs	r5, #255	; 0xff
	GLOBAL_INT_RESTORE();
	if(n >= BUF_LEN)
		n = BUF_LEN - 1;
	buf[n] = 0;
    4a36:	2400      	movs	r4, #0
    4a38:	5574      	strb	r4, [r6, r5]
	
	while(buf[i] && (i < n)){
    4a3a:	5d30      	ldrb	r0, [r6, r4]
    4a3c:	2800      	cmp	r0, #0
    4a3e:	d005      	beq.n	4a4c <m_printf+0x5c>
    4a40:	42ac      	cmp	r4, r5
    4a42:	da03      	bge.n	4a4c <m_printf+0x5c>
		UART_PutChar(buf[i]);
    4a44:	f7fc ffc4 	bl	19d0 <UART_PutChar>
		i++;
    4a48:	3401      	adds	r4, #1
    4a4a:	e7f6      	b.n	4a3a <m_printf+0x4a>
	}
	va_end(arg);
	
	//print end log
	for(int i = 0; i < sizeof(lge)-1; ++i){
		UART_PutChar(lge[i]);
    4a4c:	200d      	movs	r0, #13
    4a4e:	f7fc ffbf 	bl	19d0 <UART_PutChar>
    4a52:	200a      	movs	r0, #10
    4a54:	f7fc ffbc 	bl	19d0 <UART_PutChar>
	}
 	return 0;
}
    4a58:	2000      	movs	r0, #0
    4a5a:	bc7e      	pop	{r1, r2, r3, r4, r5, r6}
    4a5c:	bc08      	pop	{r3}
    4a5e:	b003      	add	sp, #12
    4a60:	4718      	bx	r3
    4a62:	46c0      	nop			; (mov r8, r8)
    4a64:	10010514 	.word	0x10010514
    4a68:	1001101c 	.word	0x1001101c

00004a6c <m_printf_hex>:

int m_printf_hex(uint32_t lev, const char* str, const uint8_t* data, int len)
{
    4a6c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    4a6e:	001d      	movs	r5, r3
	if(!(lev & L_LEV))
    4a70:	4b28      	ldr	r3, [pc, #160]	; (4b14 <m_printf_hex+0xa8>)
	}
 	return 0;
}

int m_printf_hex(uint32_t lev, const char* str, const uint8_t* data, int len)
{
    4a72:	000e      	movs	r6, r1
	if(!(lev & L_LEV))
    4a74:	681b      	ldr	r3, [r3, #0]
	}
 	return 0;
}

int m_printf_hex(uint32_t lev, const char* str, const uint8_t* data, int len)
{
    4a76:	9201      	str	r2, [sp, #4]
	if(!(lev & L_LEV))
    4a78:	4203      	tst	r3, r0
    4a7a:	d048      	beq.n	4b0e <m_printf_hex+0xa2>
		return 0;
	if(data == NULL || len == 0){
    4a7c:	2a00      	cmp	r2, #0
    4a7e:	d046      	beq.n	4b0e <m_printf_hex+0xa2>
    4a80:	2d00      	cmp	r5, #0
    4a82:	d044      	beq.n	4b0e <m_printf_hex+0xa2>
		return 0;
	}
	//print start log
	for(int i = 0; i < sizeof(lgs)-1; ++i){
		UART_PutChar(lgs[i]);
    4a84:	205b      	movs	r0, #91	; 0x5b
    4a86:	f7fc ffa3 	bl	19d0 <UART_PutChar>
    4a8a:	204d      	movs	r0, #77	; 0x4d
    4a8c:	f7fc ffa0 	bl	19d0 <UART_PutChar>
    4a90:	204c      	movs	r0, #76	; 0x4c
    4a92:	f7fc ff9d 	bl	19d0 <UART_PutChar>
    4a96:	2047      	movs	r0, #71	; 0x47
    4a98:	f7fc ff9a 	bl	19d0 <UART_PutChar>
    4a9c:	205d      	movs	r0, #93	; 0x5d
    4a9e:	f7fc ff97 	bl	19d0 <UART_PutChar>
	}
	int sl = strlen(str);
    4aa2:	0030      	movs	r0, r6
    4aa4:	f011 f8b4 	bl	15c10 <strlen>
	for(int i = 0; i < sl; ++i){
    4aa8:	0034      	movs	r4, r6
	}
	//print start log
	for(int i = 0; i < sizeof(lgs)-1; ++i){
		UART_PutChar(lgs[i]);
	}
	int sl = strlen(str);
    4aaa:	0007      	movs	r7, r0
	for(int i = 0; i < sl; ++i){
    4aac:	1ba3      	subs	r3, r4, r6
    4aae:	429f      	cmp	r7, r3
    4ab0:	dd04      	ble.n	4abc <m_printf_hex+0x50>
		UART_PutChar(str[i]);
    4ab2:	7820      	ldrb	r0, [r4, #0]
    4ab4:	f7fc ff8c 	bl	19d0 <UART_PutChar>
    4ab8:	3401      	adds	r4, #1
    4aba:	e7f7      	b.n	4aac <m_printf_hex+0x40>
	}
	m_print("[len=%d]\r\n",len);
    4abc:	4c16      	ldr	r4, [pc, #88]	; (4b18 <m_printf_hex+0xac>)
    4abe:	0029      	movs	r1, r5
    4ac0:	0020      	movs	r0, r4
	int l = 0;
	do{
		m_print("0x%02X,",data[l++]);
		(l%16)?:m_print("\r\n");
    4ac2:	2710      	movs	r7, #16
	}
	int sl = strlen(str);
	for(int i = 0; i < sl; ++i){
		UART_PutChar(str[i]);
	}
	m_print("[len=%d]\r\n",len);
    4ac4:	3009      	adds	r0, #9
    4ac6:	f7ff ff71 	bl	49ac <m_print>
	int l = 0;
    4aca:	2600      	movs	r6, #0
	do{
		m_print("0x%02X,",data[l++]);
		(l%16)?:m_print("\r\n");
    4acc:	427f      	negs	r7, r7
		UART_PutChar(str[i]);
	}
	m_print("[len=%d]\r\n",len);
	int l = 0;
	do{
		m_print("0x%02X,",data[l++]);
    4ace:	0020      	movs	r0, r4
    4ad0:	3601      	adds	r6, #1
    4ad2:	9a01      	ldr	r2, [sp, #4]
    4ad4:	1e73      	subs	r3, r6, #1
    4ad6:	5cd1      	ldrb	r1, [r2, r3]
    4ad8:	3014      	adds	r0, #20
    4ada:	f7ff ff67 	bl	49ac <m_print>
		(l%16)?:m_print("\r\n");
    4ade:	4b0f      	ldr	r3, [pc, #60]	; (4b1c <m_printf_hex+0xb0>)
    4ae0:	4033      	ands	r3, r6
    4ae2:	d502      	bpl.n	4aea <m_printf_hex+0x7e>
    4ae4:	3b01      	subs	r3, #1
    4ae6:	433b      	orrs	r3, r7
    4ae8:	3301      	adds	r3, #1
    4aea:	2b00      	cmp	r3, #0
    4aec:	d103      	bne.n	4af6 <m_printf_hex+0x8a>
    4aee:	0020      	movs	r0, r4
    4af0:	301c      	adds	r0, #28
    4af2:	f7ff ff5b 	bl	49ac <m_print>
	}while(len!=l);
    4af6:	42b5      	cmp	r5, r6
    4af8:	d1e9      	bne.n	4ace <m_printf_hex+0x62>
	m_print("\r\n");
    4afa:	0020      	movs	r0, r4
    4afc:	301c      	adds	r0, #28
    4afe:	f7ff ff55 	bl	49ac <m_print>
	//print end log
	for(int i = 0; i < sizeof(lge)-1; ++i){
		UART_PutChar(lge[i]);
    4b02:	200d      	movs	r0, #13
    4b04:	f7fc ff64 	bl	19d0 <UART_PutChar>
    4b08:	200a      	movs	r0, #10
    4b0a:	f7fc ff61 	bl	19d0 <UART_PutChar>
	}
	return 0;
}
    4b0e:	2000      	movs	r0, #0
    4b10:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
    4b12:	46c0      	nop			; (mov r8, r8)
    4b14:	10010514 	.word	0x10010514
    4b18:	000206b2 	.word	0x000206b2
    4b1c:	8000000f 	.word	0x8000000f

00004b20 <m_set_log_lev>:

void m_set_log_lev(uint8_t l)
{
	switch (l){
    4b20:	3830      	subs	r0, #48	; 0x30
	}
	return 0;
}

void m_set_log_lev(uint8_t l)
{
    4b22:	b500      	push	{lr}
    4b24:	4b0c      	ldr	r3, [pc, #48]	; (4b58 <m_set_log_lev+0x38>)
	switch (l){
    4b26:	2803      	cmp	r0, #3
    4b28:	d811      	bhi.n	4b4e <m_set_log_lev+0x2e>
    4b2a:	f019 f913 	bl	1dd54 <__gnu_thumb1_case_uqi>
    4b2e:	0502      	.short	0x0502
    4b30:	0c08      	.short	0x0c08
		case '0':
			L_LEV = 0;
    4b32:	2200      	movs	r2, #0
    4b34:	601a      	str	r2, [r3, #0]
			break;
    4b36:	e00d      	b.n	4b54 <m_set_log_lev+0x34>
		case '1':
			L_LEV = 0xfffff;
    4b38:	4a08      	ldr	r2, [pc, #32]	; (4b5c <m_set_log_lev+0x3c>)
    4b3a:	601a      	str	r2, [r3, #0]
			break;
    4b3c:	e00a      	b.n	4b54 <m_set_log_lev+0x34>
		case '2':
			L_LEV = L_APP;
    4b3e:	2280      	movs	r2, #128	; 0x80
    4b40:	0192      	lsls	r2, r2, #6
    4b42:	601a      	str	r2, [r3, #0]
			break;
    4b44:	e006      	b.n	4b54 <m_set_log_lev+0x34>
		case '3'://for relay
			L_LEV = L_AL|L_BEAR|L_NET|L_LTARNS|L_UTARNS;
    4b46:	2256      	movs	r2, #86	; 0x56
    4b48:	32ff      	adds	r2, #255	; 0xff
    4b4a:	601a      	str	r2, [r3, #0]
			break;
    4b4c:	e002      	b.n	4b54 <m_set_log_lev+0x34>
		default:
			L_LEV = L_MODEL|L_FND|L_APP|L_ACCESS;
    4b4e:	22f0      	movs	r2, #240	; 0xf0
    4b50:	0192      	lsls	r2, r2, #6
    4b52:	601a      	str	r2, [r3, #0]
		break;
	}
}
    4b54:	bd00      	pop	{pc}
    4b56:	46c0      	nop			; (mov r8, r8)
    4b58:	10010514 	.word	0x10010514
    4b5c:	000fffff 	.word	0x000fffff

00004b60 <m_log_disable>:
void m_log_disable(void)
{
	L_LEV = 0;
    4b60:	2200      	movs	r2, #0
    4b62:	4b01      	ldr	r3, [pc, #4]	; (4b68 <m_log_disable+0x8>)
    4b64:	601a      	str	r2, [r3, #0]
}
    4b66:	4770      	bx	lr
    4b68:	10010514 	.word	0x10010514

00004b6c <m_log_enable>:

void m_log_enable(void)
{
	L_LEV = L_APP;
    4b6c:	2280      	movs	r2, #128	; 0x80
    4b6e:	4b02      	ldr	r3, [pc, #8]	; (4b78 <m_log_enable+0xc>)
    4b70:	0192      	lsls	r2, r2, #6
    4b72:	601a      	str	r2, [r3, #0]
}
    4b74:	4770      	bx	lr
    4b76:	46c0      	nop			; (mov r8, r8)
    4b78:	10010514 	.word	0x10010514

00004b7c <m_al_adv_send>:
 * @return Error status
 ****************************************************************************************
 */
__STATIC uint16_t m_al_adv_send(m_lid_t bearer_lid, uint16_t interval, uint8_t nb_tx,
                                uint16_t adv_len, const uint8_t *p_data)
{
    4b7c:	b5f0      	push	{r4, r5, r6, r7, lr}
    4b7e:	001d      	movs	r5, r3
	M_PRINTF(L_AL,"");
    4b80:	4b22      	ldr	r3, [pc, #136]	; (4c0c <m_al_adv_send+0x90>)
 * @return Error status
 ****************************************************************************************
 */
__STATIC uint16_t m_al_adv_send(m_lid_t bearer_lid, uint16_t interval, uint8_t nb_tx,
                                uint16_t adv_len, const uint8_t *p_data)
{
    4b82:	b085      	sub	sp, #20
	M_PRINTF(L_AL,"");
    4b84:	681b      	ldr	r3, [r3, #0]
 * @return Error status
 ****************************************************************************************
 */
__STATIC uint16_t m_al_adv_send(m_lid_t bearer_lid, uint16_t interval, uint8_t nb_tx,
                                uint16_t adv_len, const uint8_t *p_data)
{
    4b86:	9003      	str	r0, [sp, #12]
    4b88:	9102      	str	r1, [sp, #8]
    4b8a:	0017      	movs	r7, r2
	M_PRINTF(L_AL,"");
    4b8c:	07db      	lsls	r3, r3, #31
    4b8e:	d514      	bpl.n	4bba <m_al_adv_send+0x3e>
    4b90:	4c1f      	ldr	r4, [pc, #124]	; (4c10 <m_al_adv_send+0x94>)
    4b92:	0023      	movs	r3, r4
    4b94:	0022      	movs	r2, r4
    4b96:	0020      	movs	r0, r4
    4b98:	3345      	adds	r3, #69	; 0x45
    4b9a:	0021      	movs	r1, r4
    4b9c:	322b      	adds	r2, #43	; 0x2b
    4b9e:	9300      	str	r3, [sp, #0]
    4ba0:	3036      	adds	r0, #54	; 0x36
    4ba2:	23ec      	movs	r3, #236	; 0xec
    4ba4:	f7ff ff02 	bl	49ac <m_print>
    4ba8:	0020      	movs	r0, r4
    4baa:	3053      	adds	r0, #83	; 0x53
    4bac:	f7ff fefe 	bl	49ac <m_print>
    4bb0:	0020      	movs	r0, r4
    4bb2:	1da1      	adds	r1, r4, #6
    4bb4:	3054      	adds	r0, #84	; 0x54
    4bb6:	f7ff fef9 	bl	49ac <m_print>
    uint16_t status = M_ERR_COMMAND_DISALLOWED;
    m_al_adv_env_t * p_env = &(p_m_al_env->adv);

    if(adv_len > ADV_DATA_LEN)
    4bba:	2d1f      	cmp	r5, #31
    4bbc:	d821      	bhi.n	4c02 <m_al_adv_send+0x86>
__STATIC uint16_t m_al_adv_send(m_lid_t bearer_lid, uint16_t interval, uint8_t nb_tx,
                                uint16_t adv_len, const uint8_t *p_data)
{
	M_PRINTF(L_AL,"");
    uint16_t status = M_ERR_COMMAND_DISALLOWED;
    m_al_adv_env_t * p_env = &(p_m_al_env->adv);
    4bbe:	4e15      	ldr	r6, [pc, #84]	; (4c14 <m_al_adv_send+0x98>)
        if((p_env->state == M_AL_ADV_STOPPED) && (p_env->interval != interval))
        {
            p_env->state = M_AL_ADV_RELOAD;
        }
#endif
        p_env->bearer_lid = bearer_lid;
    4bc0:	466a      	mov	r2, sp
__STATIC uint16_t m_al_adv_send(m_lid_t bearer_lid, uint16_t interval, uint8_t nb_tx,
                                uint16_t adv_len, const uint8_t *p_data)
{
	M_PRINTF(L_AL,"");
    uint16_t status = M_ERR_COMMAND_DISALLOWED;
    m_al_adv_env_t * p_env = &(p_m_al_env->adv);
    4bc2:	6833      	ldr	r3, [r6, #0]
        if((p_env->state == M_AL_ADV_STOPPED) && (p_env->interval != interval))
        {
            p_env->state = M_AL_ADV_RELOAD;
        }
#endif
        p_env->bearer_lid = bearer_lid;
    4bc4:	7b12      	ldrb	r2, [r2, #12]
    4bc6:	001c      	movs	r4, r3
    4bc8:	3428      	adds	r4, #40	; 0x28
    4bca:	72e2      	strb	r2, [r4, #11]
        p_env->interval   = interval;
    4bcc:	466a      	mov	r2, sp
    4bce:	8912      	ldrh	r2, [r2, #8]
        p_env->data_len   = adv_len;
#if 0
        // update advertising activity state
        m_al_adv_continue(M_ERR_NO_ERROR);
#endif
		mesh_adv_data_send(interval, nb_tx, adv_len, p_data);
    4bd0:	9802      	ldr	r0, [sp, #8]
        {
            p_env->state = M_AL_ADV_RELOAD;
        }
#endif
        p_env->bearer_lid = bearer_lid;
        p_env->interval   = interval;
    4bd2:	85da      	strh	r2, [r3, #46]	; 0x2e
        p_env->nb_tx      = nb_tx;
        p_env->p_data     = p_data;
    4bd4:	9a0a      	ldr	r2, [sp, #40]	; 0x28
            p_env->state = M_AL_ADV_RELOAD;
        }
#endif
        p_env->bearer_lid = bearer_lid;
        p_env->interval   = interval;
        p_env->nb_tx      = nb_tx;
    4bd6:	7227      	strb	r7, [r4, #8]
        p_env->data_len   = adv_len;
#if 0
        // update advertising activity state
        m_al_adv_continue(M_ERR_NO_ERROR);
#endif
		mesh_adv_data_send(interval, nb_tx, adv_len, p_data);
    4bd8:	0039      	movs	r1, r7
        }
#endif
        p_env->bearer_lid = bearer_lid;
        p_env->interval   = interval;
        p_env->nb_tx      = nb_tx;
        p_env->p_data     = p_data;
    4bda:	629a      	str	r2, [r3, #40]	; 0x28
        p_env->data_len   = adv_len;
    4bdc:	859d      	strh	r5, [r3, #44]	; 0x2c
#if 0
        // update advertising activity state
        m_al_adv_continue(M_ERR_NO_ERROR);
#endif
		mesh_adv_data_send(interval, nb_tx, adv_len, p_data);
    4bde:	0013      	movs	r3, r2
    4be0:	002a      	movs	r2, r5
    4be2:	f002 fcd3 	bl	758c <mesh_adv_data_send>
#ifndef BLE_NBLOCK
        status = M_ERR_NO_ERROR;
#endif
		// Inform requester that advertising transmission is over
		if(p_env->bearer_lid != M_INVALID_LID)
    4be6:	7ae0      	ldrb	r0, [r4, #11]
    4be8:	28ff      	cmp	r0, #255	; 0xff
    4bea:	d008      	beq.n	4bfe <m_al_adv_send+0x82>
		{
		    // Keep in mind on which bearer the packet has been transmitted
		    uint8_t bearer_lid = p_env->bearer_lid;

		    p_env->bearer_lid = M_INVALID_LID;
    4bec:	23ff      	movs	r3, #255	; 0xff
    4bee:	72e3      	strb	r3, [r4, #11]

		    if(p_m_al_env->p_adv_cb != NULL)
    4bf0:	6833      	ldr	r3, [r6, #0]
    4bf2:	685b      	ldr	r3, [r3, #4]
    4bf4:	2b00      	cmp	r3, #0
    4bf6:	d002      	beq.n	4bfe <m_al_adv_send+0x82>
		    {
		        p_m_al_env->p_adv_cb->sent_cb(bearer_lid, status);
    4bf8:	68db      	ldr	r3, [r3, #12]
    4bfa:	2100      	movs	r1, #0
    4bfc:	4798      	blx	r3
        status = M_ERR_NO_ERROR;
#endif
#if 0
    }
#endif
    return (status);
    4bfe:	2000      	movs	r0, #0
    4c00:	e001      	b.n	4c06 <m_al_adv_send+0x8a>
    m_al_adv_env_t * p_env = &(p_m_al_env->adv);

    if(adv_len > ADV_DATA_LEN)
    {
         status = M_ERR_INVALID_PARAM;
		 return (status);
    4c02:	20c1      	movs	r0, #193	; 0xc1
    4c04:	0040      	lsls	r0, r0, #1
#endif
#if 0
    }
#endif
    return (status);
}
    4c06:	b005      	add	sp, #20
    4c08:	bdf0      	pop	{r4, r5, r6, r7, pc}
    4c0a:	46c0      	nop			; (mov r8, r8)
    4c0c:	10010514 	.word	0x10010514
    4c10:	000206d4 	.word	0x000206d4
    4c14:	10012850 	.word	0x10012850

00004c18 <m_al_adv_init>:
 ****************************************************************************************
 */

void m_al_adv_init(bool reset)
{
    if (!reset)
    4c18:	2800      	cmp	r0, #0
    4c1a:	d105      	bne.n	4c28 <m_al_adv_init+0x10>
    {
        m_al_adv_env_t * p_env = &(p_m_al_env->adv);

        p_env->state           = M_AL_ADV_OFF;
        p_env->bearer_lid      = M_INVALID_LID;
    4c1c:	22ff      	movs	r2, #255	; 0xff

void m_al_adv_init(bool reset)
{
    if (!reset)
    {
        m_al_adv_env_t * p_env = &(p_m_al_env->adv);
    4c1e:	4b03      	ldr	r3, [pc, #12]	; (4c2c <m_al_adv_init+0x14>)
    4c20:	681b      	ldr	r3, [r3, #0]

        p_env->state           = M_AL_ADV_OFF;
    4c22:	3328      	adds	r3, #40	; 0x28
    4c24:	7258      	strb	r0, [r3, #9]
        p_env->bearer_lid      = M_INVALID_LID;
    4c26:	72da      	strb	r2, [r3, #11]
        //p_env->act_id          = GAP_INVALID_CONIDX;
    }
}
    4c28:	4770      	bx	lr
    4c2a:	46c0      	nop			; (mov r8, r8)
    4c2c:	10012850 	.word	0x10012850

00004c30 <m_al_djob_evt_handler>:
 ****************************************************************************************
 * @brief handler of kernel event to immediately start a delayed job
 ****************************************************************************************
 */
__STATIC void m_al_djob_evt_handler(void)
{
    4c30:	b510      	push	{r4, lr}
	//M_PRINTF(L_AL,"");

    // clear event
    ke_event_clear(KE_EVENT_BLE_MESH_DJOB);
    4c32:	2000      	movs	r0, #0
    4c34:	f002 fc06 	bl	7444 <ke_event_clear>

    if(p_m_al_env != NULL)
    4c38:	4b0a      	ldr	r3, [pc, #40]	; (4c64 <m_al_djob_evt_handler+0x34>)
    4c3a:	6818      	ldr	r0, [r3, #0]
    4c3c:	001c      	movs	r4, r3
    4c3e:	2800      	cmp	r0, #0
    4c40:	d00e      	beq.n	4c60 <m_al_djob_evt_handler+0x30>
    {
        m_al_djob_t* p_djob = (m_al_djob_t*) co_list_pop_front(&(p_m_al_env->djob.job_queue));
    4c42:	303c      	adds	r0, #60	; 0x3c
    4c44:	f7ff fbd2 	bl	43ec <co_list_pop_front>

        if(p_djob != NULL)
    4c48:	2800      	cmp	r0, #0
    4c4a:	d002      	beq.n	4c52 <m_al_djob_evt_handler+0x22>
        {
			//M_PRINTF(L_AL,"p_djob->cb = %p", p_djob->cb);
            p_djob->cb(p_djob->p_env);
    4c4c:	6883      	ldr	r3, [r0, #8]
    4c4e:	6840      	ldr	r0, [r0, #4]
    4c50:	4798      	blx	r3
    4c52:	6823      	ldr	r3, [r4, #0]
        }

        // check if another job must be executed
        if(!co_list_is_empty(&(p_m_al_env->djob.job_queue)))
    4c54:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
    4c56:	2b00      	cmp	r3, #0
    4c58:	d002      	beq.n	4c60 <m_al_djob_evt_handler+0x30>
        {
            ke_event_set(KE_EVENT_BLE_MESH_DJOB);
    4c5a:	2000      	movs	r0, #0
    4c5c:	f002 fbe4 	bl	7428 <ke_event_set>
        }
    }
}
    4c60:	bd10      	pop	{r4, pc}
    4c62:	46c0      	nop			; (mov r8, r8)
    4c64:	10012850 	.word	0x10012850

00004c68 <m_al_djob_init>:
 * GLOBAL FUNCTIONS
 ****************************************************************************************
 */

void m_al_djob_init(bool reset)
{
    4c68:	b510      	push	{r4, lr}
    4c6a:	1e04      	subs	r4, r0, #0
    if (!reset)
    4c6c:	d108      	bne.n	4c80 <m_al_djob_init+0x18>
    {
        co_list_init(&(p_m_al_env->djob.job_queue));
    4c6e:	4b05      	ldr	r3, [pc, #20]	; (4c84 <m_al_djob_init+0x1c>)
    4c70:	6818      	ldr	r0, [r3, #0]
    4c72:	303c      	adds	r0, #60	; 0x3c
    4c74:	f7ff fb54 	bl	4320 <co_list_init>

        // Register BLE delayed job kernel event
        ke_event_callback_set(KE_EVENT_BLE_MESH_DJOB, &m_al_djob_evt_handler);
    4c78:	4903      	ldr	r1, [pc, #12]	; (4c88 <m_al_djob_init+0x20>)
    4c7a:	0020      	movs	r0, r4
    4c7c:	f002 fb4a 	bl	7314 <ke_event_callback_set>
    }
}
    4c80:	bd10      	pop	{r4, pc}
    4c82:	46c0      	nop			; (mov r8, r8)
    4c84:	10012850 	.word	0x10012850
    4c88:	00004c31 	.word	0x00004c31

00004c8c <m_al_djob_reg>:

void m_al_djob_reg(m_al_djob_t* p_djob)
{
    4c8c:	4b07      	ldr	r3, [pc, #28]	; (4cac <m_al_djob_reg+0x20>)
    4c8e:	b570      	push	{r4, r5, r6, lr}
    4c90:	681a      	ldr	r2, [r3, #0]
    4c92:	0005      	movs	r5, r0
	//M_PRINTF(L_AL,"");
    // Set event only if no job present in queue
    if(co_list_is_empty(&(p_m_al_env->djob.job_queue)))
    4c94:	6bd0      	ldr	r0, [r2, #60]	; 0x3c
    4c96:	001c      	movs	r4, r3
    4c98:	2800      	cmp	r0, #0
    4c9a:	d101      	bne.n	4ca0 <m_al_djob_reg+0x14>
    {
        ke_event_set(KE_EVENT_BLE_MESH_DJOB);
    4c9c:	f002 fbc4 	bl	7428 <ke_event_set>
    }

    // put element at end of the list
    co_list_push_back(&(p_m_al_env->djob.job_queue), &(p_djob->hdr));
    4ca0:	6820      	ldr	r0, [r4, #0]
    4ca2:	0029      	movs	r1, r5
    4ca4:	303c      	adds	r0, #60	; 0x3c
    4ca6:	f7ff fb76 	bl	4396 <co_list_push_back>
}
    4caa:	bd70      	pop	{r4, r5, r6, pc}
    4cac:	10012850 	.word	0x10012850

00004cb0 <m_al_scan_init>:
 ****************************************************************************************
 */

void m_al_scan_init(bool reset)
{
    if (!reset)
    4cb0:	2800      	cmp	r0, #0
    4cb2:	d105      	bne.n	4cc0 <m_al_scan_init+0x10>
    {
        m_al_scan_env_t * p_env = &(p_m_al_env->scan);

        p_env->state      = M_AL_SCAN_OFF;
        p_env->bearer_lid = M_INVALID_LID;
    4cb4:	22ff      	movs	r2, #255	; 0xff

void m_al_scan_init(bool reset)
{
    if (!reset)
    {
        m_al_scan_env_t * p_env = &(p_m_al_env->scan);
    4cb6:	4b03      	ldr	r3, [pc, #12]	; (4cc4 <m_al_scan_init+0x14>)
    4cb8:	681b      	ldr	r3, [r3, #0]

        p_env->state      = M_AL_SCAN_OFF;
    4cba:	3334      	adds	r3, #52	; 0x34
    4cbc:	7098      	strb	r0, [r3, #2]
        p_env->bearer_lid = M_INVALID_LID;
    4cbe:	711a      	strb	r2, [r3, #4]
        //p_env->act_id     = GAP_INVALID_CONIDX;
    }
}
    4cc0:	4770      	bx	lr
    4cc2:	46c0      	nop			; (mov r8, r8)
    4cc4:	10012850 	.word	0x10012850

00004cc8 <m_al_scan_start>:

uint16_t m_al_scan_start(m_lid_t bearer_lid, uint16_t interval, const m_al_adv_cb_t* p_cb_evts)
{
    4cc8:	b570      	push	{r4, r5, r6, lr}
    uint16_t status =  M_ERR_COMMAND_DISALLOWED;
    m_al_scan_env_t * p_env = &(p_m_al_env->scan);
    4cca:	4e10      	ldr	r6, [pc, #64]	; (4d0c <m_al_scan_start+0x44>)
    4ccc:	6833      	ldr	r3, [r6, #0]

    if(   ((p_env->bearer_lid == M_INVALID_LID) || (p_env->bearer_lid == bearer_lid))
    4cce:	001c      	movs	r4, r3
    4cd0:	3434      	adds	r4, #52	; 0x34
    4cd2:	7925      	ldrb	r5, [r4, #4]
    4cd4:	2dff      	cmp	r5, #255	; 0xff
    4cd6:	d001      	beq.n	4cdc <m_al_scan_start+0x14>
    4cd8:	4285      	cmp	r5, r0
    4cda:	d114      	bne.n	4d06 <m_al_scan_start+0x3e>
       && ((p_env->state == M_AL_SCAN_OFF)))
    4cdc:	78a5      	ldrb	r5, [r4, #2]
    4cde:	2d00      	cmp	r5, #0
    4ce0:	d111      	bne.n	4d06 <m_al_scan_start+0x3e>
    {
        p_m_al_env->p_adv_cb  = p_cb_evts;
    4ce2:	605a      	str	r2, [r3, #4]
        p_env->interval       = interval;
    4ce4:	8699      	strh	r1, [r3, #52]	; 0x34
        p_env->bearer_lid     = bearer_lid;
    4ce6:	7120      	strb	r0, [r4, #4]
#if 0
        // update scanning activity state
        m_al_scan_start_continue(M_ERR_NO_ERROR);
#endif
			
		mesh_adv_scan_start(interval);
    4ce8:	0008      	movs	r0, r1
    4cea:	f002 fd8f 	bl	780c <mesh_adv_scan_start>
		p_env->state = M_AL_SCAN_STARTED;
    4cee:	2302      	movs	r3, #2
        status = M_ERR_NO_ERROR;
		// Inform the bearer layer that the scan has been started - or an error occurs
		if (p_env->bearer_lid != M_INVALID_LID)
    4cf0:	7920      	ldrb	r0, [r4, #4]
        // update scanning activity state
        m_al_scan_start_continue(M_ERR_NO_ERROR);
#endif
			
		mesh_adv_scan_start(interval);
		p_env->state = M_AL_SCAN_STARTED;
    4cf2:	70a3      	strb	r3, [r4, #2]
        status = M_ERR_NO_ERROR;
    4cf4:	002c      	movs	r4, r5
		// Inform the bearer layer that the scan has been started - or an error occurs
		if (p_env->bearer_lid != M_INVALID_LID)
    4cf6:	28ff      	cmp	r0, #255	; 0xff
    4cf8:	d006      	beq.n	4d08 <m_al_scan_start+0x40>
		{
			p_m_al_env->p_adv_cb->start_cb(p_env->bearer_lid, status);
    4cfa:	6833      	ldr	r3, [r6, #0]
    4cfc:	0029      	movs	r1, r5
    4cfe:	685b      	ldr	r3, [r3, #4]
    4d00:	681b      	ldr	r3, [r3, #0]
    4d02:	4798      	blx	r3
    4d04:	e000      	b.n	4d08 <m_al_scan_start+0x40>
    }
}

uint16_t m_al_scan_start(m_lid_t bearer_lid, uint16_t interval, const m_al_adv_cb_t* p_cb_evts)
{
    uint16_t status =  M_ERR_COMMAND_DISALLOWED;
    4d06:	4c02      	ldr	r4, [pc, #8]	; (4d10 <m_al_scan_start+0x48>)
			p_m_al_env->p_adv_cb->start_cb(p_env->bearer_lid, status);
		}
    }

    return (status);
}
    4d08:	0020      	movs	r0, r4
    4d0a:	bd70      	pop	{r4, r5, r6, pc}
    4d0c:	10012850 	.word	0x10012850
    4d10:	00000282 	.word	0x00000282

00004d14 <m_al_scan_stop>:

uint16_t m_al_scan_stop(m_lid_t bearer_lid)
{
    4d14:	b570      	push	{r4, r5, r6, lr}
    uint16_t status =  M_ERR_COMMAND_DISALLOWED;
    m_al_scan_env_t * p_env = &(p_m_al_env->scan);
    4d16:	4e0c      	ldr	r6, [pc, #48]	; (4d48 <m_al_scan_stop+0x34>)
	//M_PRINTF(L_AL, "bearer_lid[%x] state[%x]", bearer_lid, p_env->state);
    if(p_env->state == M_AL_SCAN_STARTED)
    4d18:	6834      	ldr	r4, [r6, #0]
    4d1a:	3434      	adds	r4, #52	; 0x34
    4d1c:	78a3      	ldrb	r3, [r4, #2]
    4d1e:	2b02      	cmp	r3, #2
    4d20:	d10e      	bne.n	4d40 <m_al_scan_stop+0x2c>
    {
        p_env->state      = M_AL_SCAN_OFF;//M_AL_SCAN_STOPPING;
    4d22:	2500      	movs	r5, #0
    4d24:	70a5      	strb	r5, [r4, #2]
#if 0
        // update scanning activity state
        m_al_scan_stop_continue(M_ERR_NO_ERROR);
#endif
		mesh_adv_scan_stop();
    4d26:	f002 fdbb 	bl	78a0 <mesh_adv_scan_stop>
		// Inform the bearer layer that the scan has been started - or an error occurs
		if (p_env->bearer_lid != M_INVALID_LID)
    4d2a:	7920      	ldrb	r0, [r4, #4]
    4d2c:	28ff      	cmp	r0, #255	; 0xff
    4d2e:	d008      	beq.n	4d42 <m_al_scan_stop+0x2e>
		{
			p_m_al_env->p_adv_cb->stop_cb(p_env->bearer_lid, status);
    4d30:	6833      	ldr	r3, [r6, #0]
    4d32:	4906      	ldr	r1, [pc, #24]	; (4d4c <m_al_scan_stop+0x38>)
    4d34:	685b      	ldr	r3, [r3, #4]
    4d36:	685b      	ldr	r3, [r3, #4]
    4d38:	4798      	blx	r3
			p_env->bearer_lid    = M_INVALID_LID;
    4d3a:	23ff      	movs	r3, #255	; 0xff
    4d3c:	7123      	strb	r3, [r4, #4]
    4d3e:	e000      	b.n	4d42 <m_al_scan_stop+0x2e>
    return (status);
}

uint16_t m_al_scan_stop(m_lid_t bearer_lid)
{
    uint16_t status =  M_ERR_COMMAND_DISALLOWED;
    4d40:	4d02      	ldr	r5, [pc, #8]	; (4d4c <m_al_scan_stop+0x38>)
		
        status = M_ERR_NO_ERROR;
    }

    return (status);
}
    4d42:	0028      	movs	r0, r5
    4d44:	bd70      	pop	{r4, r5, r6, pc}
    4d46:	46c0      	nop			; (mov r8, r8)
    4d48:	10012850 	.word	0x10012850
    4d4c:	00000282 	.word	0x00000282

00004d50 <gapm_ext_adv_report_ind_handler>:
 * @brief Handler of advertising report received
 ****************************************************************************************
 */
int gapm_ext_adv_report_ind_handler(ke_msg_id_t const msg_id, struct gapm_ext_adv_report_ind* p_param,
                                    ke_task_id_t const dest_id, ke_task_id_t const src_id)
{
    4d50:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    m_al_scan_env_t * p_env = &(p_m_al_env->scan);
    4d52:	4f11      	ldr	r7, [pc, #68]	; (4d98 <gapm_ext_adv_report_ind_handler+0x48>)
 * @brief Handler of advertising report received
 ****************************************************************************************
 */
int gapm_ext_adv_report_ind_handler(ke_msg_id_t const msg_id, struct gapm_ext_adv_report_ind* p_param,
                                    ke_task_id_t const dest_id, ke_task_id_t const src_id)
{
    4d54:	000c      	movs	r4, r1
    m_al_scan_env_t * p_env = &(p_m_al_env->scan);
    4d56:	683b      	ldr	r3, [r7, #0]
    4d58:	001d      	movs	r5, r3
    4d5a:	3534      	adds	r5, #52	; 0x34
	
    // All report filtered except ADV_NONCONN_UNDIR
    #if 1
    if(   (p_env != NULL) && (p_param->info == ADV_NONCONN_IND )//(GAPM_REPORT_TYPE_ADV_LEG | GAPM_REPORT_INFO_COMPLETE_BIT))
    4d5c:	2d00      	cmp	r5, #0
    4d5e:	d019      	beq.n	4d94 <gapm_ext_adv_report_ind_handler+0x44>
    4d60:	780a      	ldrb	r2, [r1, #0]
    4d62:	2a02      	cmp	r2, #2
    4d64:	d116      	bne.n	4d94 <gapm_ext_adv_report_ind_handler+0x44>
       // Device is in reception mode
       && (p_env->bearer_lid != M_INVALID_LID) && (p_m_al_env->p_adv_cb != NULL))
    4d66:	792a      	ldrb	r2, [r5, #4]
    4d68:	2aff      	cmp	r2, #255	; 0xff
    4d6a:	d013      	beq.n	4d94 <gapm_ext_adv_report_ind_handler+0x44>
    4d6c:	685b      	ldr	r3, [r3, #4]
    4d6e:	2b00      	cmp	r3, #0
    4d70:	d010      	beq.n	4d94 <gapm_ext_adv_report_ind_handler+0x44>
    {
		m_printf_hex(L_AL, "recv adv data", p_param->data, p_param->length);
    4d72:	1d0e      	adds	r6, r1, #4
    4d74:	884b      	ldrh	r3, [r1, #2]
    4d76:	0032      	movs	r2, r6
    4d78:	4908      	ldr	r1, [pc, #32]	; (4d9c <gapm_ext_adv_report_ind_handler+0x4c>)
    4d7a:	2001      	movs	r0, #1
    4d7c:	f7ff fe76 	bl	4a6c <m_printf_hex>
        // inform about proper reception of an advertising packet
        p_m_al_env->p_adv_cb->rx_cb(p_env->bearer_lid, M_ERR_NO_ERROR, (int8_t)p_param->rssi, p_param->length, p_param->data);
    4d80:	2201      	movs	r2, #1
    4d82:	6839      	ldr	r1, [r7, #0]
    4d84:	78a3      	ldrb	r3, [r4, #2]
    4d86:	6849      	ldr	r1, [r1, #4]
    4d88:	56a2      	ldrsb	r2, [r4, r2]
    4d8a:	7928      	ldrb	r0, [r5, #4]
    4d8c:	9600      	str	r6, [sp, #0]
    4d8e:	688c      	ldr	r4, [r1, #8]
    4d90:	2100      	movs	r1, #0
    4d92:	47a0      	blx	r4
    }
	#endif
    return (KE_MSG_CONSUMED);
}
    4d94:	2000      	movs	r0, #0
    4d96:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
    4d98:	10012850 	.word	0x10012850
    4d9c:	0002072b 	.word	0x0002072b

00004da0 <m_al_sec_aes_result_cb>:
 * @param[in] aes_res      16 bytes block result
 * @param[in] src_info     Information provided by requester
 ****************************************************************************************
 */
__STATIC void m_al_sec_aes_result_cb(uint8_t status, const uint8_t* aes_res, uint32_t src_info)
{
    4da0:	b510      	push	{r4, lr}
    m_al_sec_aes_res_cb res_cb = (m_al_sec_aes_res_cb)src_info;

    // execute proper result callback
    res_cb(aes_res);
    4da2:	0008      	movs	r0, r1
    4da4:	4790      	blx	r2
}
    4da6:	bd10      	pop	{r4, pc}

00004da8 <m_al_sec_ccm_result_cb>:
 *                       In case of MIC error output message is considered invalid
 * @param[in] src_info     Information provided by requester
 ****************************************************************************************
 */
__STATIC void m_al_sec_ccm_result_cb(bool mic_error, uint32_t src_info)
{
    4da8:	b510      	push	{r4, lr}
    m_al_sec_aes_ccm_cb res_cb = (m_al_sec_aes_ccm_cb)src_info;

    // execute proper result callback
    res_cb(mic_error);
    4daa:	4788      	blx	r1
}
    4dac:	bd10      	pop	{r4, pc}

00004dae <gapm_use_enc_block_ind_handler>:
    // Let AES block handle AES result
    #if 0
    aes_result_handler(CO_ERROR_NO_ERROR, p_param->result);
	#endif
    return (KE_MSG_CONSUMED);
}
    4dae:	2000      	movs	r0, #0
    4db0:	4770      	bx	lr

00004db2 <m_al_sec_init>:

void m_al_sec_init(bool reset)
{
    mesh_sec_aes_init(reset);

    p_m_al_env->sec.cb_pub_key = NULL;
    4db2:	2200      	movs	r2, #0
    4db4:	4b02      	ldr	r3, [pc, #8]	; (4dc0 <m_al_sec_init+0xe>)
    4db6:	681b      	ldr	r3, [r3, #0]
    4db8:	609a      	str	r2, [r3, #8]
    p_m_al_env->sec.cb_dh_key  = NULL;
    4dba:	60da      	str	r2, [r3, #12]
}
    4dbc:	4770      	bx	lr
    4dbe:	46c0      	nop			; (mov r8, r8)
    4dc0:	10012850 	.word	0x10012850

00004dc4 <m_al_sec_aes_req>:
    // Set operand_2 value
    memcpy(&enc_cmd->operand_2[0], val, GAP_KEY_LEN);

    ke_msg_send(enc_cmd);
#endif
}
    4dc4:	4770      	bx	lr

00004dc6 <m_al_sec_aes>:

void m_al_sec_aes(const uint8_t* p_key, const uint8_t *p_val, m_al_sec_aes_res_cb res_cb)
{
    4dc6:	b5f0      	push	{r4, r5, r6, r7, lr}
								bool copy, mesh_aes_func_result_cb res_cb, uint32_t src_info)
{
	uint8_t aes_res[16];
	uint8_t tk[16];
	uint8_t tv[16];
	m_printf_hex(L_AL, "aes key", key, 16);
    4dc8:	4c22      	ldr	r4, [pc, #136]	; (4e54 <m_al_sec_aes+0x8e>)
    4dca:	000e      	movs	r6, r1
    4dcc:	0021      	movs	r1, r4
    4dce:	b08d      	sub	sp, #52	; 0x34
    4dd0:	3109      	adds	r1, #9
    4dd2:	2310      	movs	r3, #16
    4dd4:	0007      	movs	r7, r0
    4dd6:	0015      	movs	r5, r2
    4dd8:	0002      	movs	r2, r0
    4dda:	2001      	movs	r0, #1
    4ddc:	f7ff fe46 	bl	4a6c <m_printf_hex>
	m_printf_hex(L_AL, "aes val", val, 16);
    4de0:	0021      	movs	r1, r4
    4de2:	2310      	movs	r3, #16
    4de4:	3111      	adds	r1, #17
    4de6:	0032      	movs	r2, r6
    4de8:	2001      	movs	r0, #1
    4dea:	f7ff fe3f 	bl	4a6c <m_printf_hex>
	
	for(int i = 0; i < 16; ++i){
    4dee:	2300      	movs	r3, #0
		tk[i] = key[15-i];
    4df0:	a804      	add	r0, sp, #16
    4df2:	1afa      	subs	r2, r7, r3
    4df4:	7bd2      	ldrb	r2, [r2, #15]
    4df6:	541a      	strb	r2, [r3, r0]
	uint8_t tk[16];
	uint8_t tv[16];
	m_printf_hex(L_AL, "aes key", key, 16);
	m_printf_hex(L_AL, "aes val", val, 16);
	
	for(int i = 0; i < 16; ++i){
    4df8:	3301      	adds	r3, #1
    4dfa:	2b10      	cmp	r3, #16
    4dfc:	d1f9      	bne.n	4df2 <m_al_sec_aes+0x2c>
    4dfe:	2300      	movs	r3, #0
		tk[i] = key[15-i];
	}
	for(int i = 0; i < 16; ++i){
		tv[i] = val[15-i];
    4e00:	1af2      	subs	r2, r6, r3
    4e02:	7bd2      	ldrb	r2, [r2, #15]
    4e04:	a908      	add	r1, sp, #32
    4e06:	545a      	strb	r2, [r3, r1]
	m_printf_hex(L_AL, "aes val", val, 16);
	
	for(int i = 0; i < 16; ++i){
		tk[i] = key[15-i];
	}
	for(int i = 0; i < 16; ++i){
    4e08:	3301      	adds	r3, #1
    4e0a:	2b10      	cmp	r3, #16
    4e0c:	d1f8      	bne.n	4e00 <m_al_sec_aes+0x3a>
		tv[i] = val[15-i];
	}
	
	mesh_aes_encrypt((const uint8_t*)tk, (const uint8_t *)tv, aes_res);
    4e0e:	466a      	mov	r2, sp
    4e10:	f002 ffe4 	bl	7ddc <mesh_aes_encrypt>
    4e14:	220f      	movs	r2, #15
	
	for(int i = 0; i < 8; ++i){
    4e16:	2300      	movs	r3, #0
    4e18:	446a      	add	r2, sp
		aes_res[i] ^= aes_res[15-i];
    4e1a:	4669      	mov	r1, sp
    4e1c:	5cc8      	ldrb	r0, [r1, r3]
    4e1e:	7811      	ldrb	r1, [r2, #0]
    4e20:	3a01      	subs	r2, #1
    4e22:	4041      	eors	r1, r0
    4e24:	4668      	mov	r0, sp
    4e26:	54c1      	strb	r1, [r0, r3]
		aes_res[15-i] ^= aes_res[i];
    4e28:	7850      	ldrb	r0, [r2, #1]
    4e2a:	4041      	eors	r1, r0
		aes_res[i] ^= aes_res[15-i];
    4e2c:	4668      	mov	r0, sp
	
	mesh_aes_encrypt((const uint8_t*)tk, (const uint8_t *)tv, aes_res);
	
	for(int i = 0; i < 8; ++i){
		aes_res[i] ^= aes_res[15-i];
		aes_res[15-i] ^= aes_res[i];
    4e2e:	7051      	strb	r1, [r2, #1]
		aes_res[i] ^= aes_res[15-i];
    4e30:	5cc0      	ldrb	r0, [r0, r3]
    4e32:	4041      	eors	r1, r0
    4e34:	4668      	mov	r0, sp
    4e36:	54c1      	strb	r1, [r0, r3]
		tv[i] = val[15-i];
	}
	
	mesh_aes_encrypt((const uint8_t*)tk, (const uint8_t *)tv, aes_res);
	
	for(int i = 0; i < 8; ++i){
    4e38:	3301      	adds	r3, #1
    4e3a:	2b08      	cmp	r3, #8
    4e3c:	d1ed      	bne.n	4e1a <m_al_sec_aes+0x54>
		aes_res[i] ^= aes_res[15-i];
		aes_res[15-i] ^= aes_res[i];
		aes_res[i] ^= aes_res[15-i];
	}
	m_printf_hex(L_AL, "aes res", aes_res, 16);
    4e3e:	0021      	movs	r1, r4
    4e40:	3308      	adds	r3, #8
    4e42:	3119      	adds	r1, #25
    4e44:	466a      	mov	r2, sp
    4e46:	2001      	movs	r0, #1
    4e48:	f7ff fe10 	bl	4a6c <m_printf_hex>
__STATIC void m_al_sec_aes_result_cb(uint8_t status, const uint8_t* aes_res, uint32_t src_info)
{
    m_al_sec_aes_res_cb res_cb = (m_al_sec_aes_res_cb)src_info;

    // execute proper result callback
    res_cb(aes_res);
    4e4c:	4668      	mov	r0, sp
    4e4e:	47a8      	blx	r5

void m_al_sec_aes(const uint8_t* p_key, const uint8_t *p_val, m_al_sec_aes_res_cb res_cb)
{
    // use AES encrypt function
    mesh_sec_aes_encrypt(p_key, p_val, false, m_al_sec_aes_result_cb, (uint32_t) res_cb);
}
    4e50:	b00d      	add	sp, #52	; 0x34
    4e52:	bdf0      	pop	{r4, r5, r6, r7, pc}
    4e54:	00020739 	.word	0x00020739

00004e58 <m_al_sec_rand>:

void m_al_sec_rand(m_al_sec_aes_res_cb res_cb)
{
    4e58:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    4e5a:	0004      	movs	r4, r0
 */
__INLINE_S__ void mesh_sec_aes_rand(mesh_aes_func_result_cb res_cb, uint32_t src_info)
{
	uint8_t aes_res[16];//M_KEY_LEN
	extern void mesh_aes_rand(uint8_t* randbuf,uint8_t randlen);
	mesh_aes_rand(aes_res, sizeof(aes_res));
    4e5c:	2110      	movs	r1, #16
    4e5e:	4668      	mov	r0, sp
    4e60:	f002 ffe4 	bl	7e2c <mesh_aes_rand>
	m_printf_hex(L_AL, "aes rand res", aes_res, sizeof(aes_res));
    4e64:	4904      	ldr	r1, [pc, #16]	; (4e78 <m_al_sec_rand+0x20>)
    4e66:	2310      	movs	r3, #16
    4e68:	466a      	mov	r2, sp
    4e6a:	3121      	adds	r1, #33	; 0x21
    4e6c:	2001      	movs	r0, #1
    4e6e:	f7ff fdfd 	bl	4a6c <m_printf_hex>
__STATIC void m_al_sec_aes_result_cb(uint8_t status, const uint8_t* aes_res, uint32_t src_info)
{
    m_al_sec_aes_res_cb res_cb = (m_al_sec_aes_res_cb)src_info;

    // execute proper result callback
    res_cb(aes_res);
    4e72:	4668      	mov	r0, sp
    4e74:	47a0      	blx	r4

void m_al_sec_rand(m_al_sec_aes_res_cb res_cb)
{
    // use AES rand function
    mesh_sec_aes_rand(m_al_sec_aes_result_cb, (uint32_t) res_cb);
}
    4e76:	bd1f      	pop	{r0, r1, r2, r3, r4, pc}
    4e78:	00020739 	.word	0x00020739

00004e7c <m_al_sec_aes_cmac>:

void m_al_sec_aes_cmac(const uint8_t* p_key, const uint8_t* p_message, uint16_t message_len, m_al_sec_aes_res_cb res_cb)
{
    4e7c:	b5f0      	push	{r4, r5, r6, r7, lr}
    4e7e:	b089      	sub	sp, #36	; 0x24
    4e80:	0007      	movs	r7, r0
    4e82:	9102      	str	r1, [sp, #8]
			  mesh_aes_func_result_cb res_cb, uint32_t src_info);
__INLINE_S__ void mesh_sec_aes_cmac(const uint8_t* key, const uint8_t* message, uint16_t message_len,
              mesh_aes_func_result_cb res_cb, uint32_t src_info)
{
	uint8_t tk[16];
	uint8_t* tm = ke_malloc(message_len, 0);
    4e84:	0010      	movs	r0, r2
    4e86:	2100      	movs	r1, #0
    4e88:	0014      	movs	r4, r2
    4e8a:	9303      	str	r3, [sp, #12]
    4e8c:	f002 fa28 	bl	72e0 <ke_malloc>
	
    m_printf_hex(L_AL, "cmac key val", key, 16);   
    4e90:	4d16      	ldr	r5, [pc, #88]	; (4eec <m_al_sec_aes_cmac+0x70>)
    4e92:	2310      	movs	r3, #16
    4e94:	0029      	movs	r1, r5
    4e96:	003a      	movs	r2, r7
    4e98:	312e      	adds	r1, #46	; 0x2e
			  mesh_aes_func_result_cb res_cb, uint32_t src_info);
__INLINE_S__ void mesh_sec_aes_cmac(const uint8_t* key, const uint8_t* message, uint16_t message_len,
              mesh_aes_func_result_cb res_cb, uint32_t src_info)
{
	uint8_t tk[16];
	uint8_t* tm = ke_malloc(message_len, 0);
    4e9a:	0006      	movs	r6, r0
	
    m_printf_hex(L_AL, "cmac key val", key, 16);   
    4e9c:	2001      	movs	r0, #1
    4e9e:	f7ff fde5 	bl	4a6c <m_printf_hex>
	m_printf_hex(L_AL, "cmac message val", message, message_len);  
    4ea2:	0029      	movs	r1, r5
    4ea4:	0023      	movs	r3, r4
    4ea6:	313b      	adds	r1, #59	; 0x3b
    4ea8:	9a02      	ldr	r2, [sp, #8]
    4eaa:	2001      	movs	r0, #1
    4eac:	f7ff fdde 	bl	4a6c <m_printf_hex>

	for(int i = 0; i < 16; ++i){
    4eb0:	2300      	movs	r3, #0
		tk[i] = key[15-i];
    4eb2:	a804      	add	r0, sp, #16
    4eb4:	1afa      	subs	r2, r7, r3
    4eb6:	7bd2      	ldrb	r2, [r2, #15]
    4eb8:	541a      	strb	r2, [r3, r0]
	uint8_t* tm = ke_malloc(message_len, 0);
	
    m_printf_hex(L_AL, "cmac key val", key, 16);   
	m_printf_hex(L_AL, "cmac message val", message, message_len);  

	for(int i = 0; i < 16; ++i){
    4eba:	3301      	adds	r3, #1
    4ebc:	2b10      	cmp	r3, #16
    4ebe:	d1f9      	bne.n	4eb4 <m_al_sec_aes_cmac+0x38>
    4ec0:	2300      	movs	r3, #0
		tk[i] = key[15-i];
	}
	for(int i = 0; i < message_len; ++i){
    4ec2:	429c      	cmp	r4, r3
    4ec4:	dd06      	ble.n	4ed4 <m_al_sec_aes_cmac+0x58>
    4ec6:	1ae2      	subs	r2, r4, r3
		tm[i] = message[message_len-1-i];
    4ec8:	9902      	ldr	r1, [sp, #8]
    4eca:	3a01      	subs	r2, #1
    4ecc:	5c8a      	ldrb	r2, [r1, r2]
    4ece:	54f2      	strb	r2, [r6, r3]
	m_printf_hex(L_AL, "cmac message val", message, message_len);  

	for(int i = 0; i < 16; ++i){
		tk[i] = key[15-i];
	}
	for(int i = 0; i < message_len; ++i){
    4ed0:	3301      	adds	r3, #1
    4ed2:	e7f6      	b.n	4ec2 <m_al_sec_aes_cmac+0x46>
		tm[i] = message[message_len-1-i];
	}
	mesh_aes_cmac((const uint8_t*)tk,  (const uint8_t*)tm, message_len, res_cb, src_info);
    4ed4:	9b03      	ldr	r3, [sp, #12]
    4ed6:	0022      	movs	r2, r4
    4ed8:	9300      	str	r3, [sp, #0]
    4eda:	0031      	movs	r1, r6
    4edc:	4b04      	ldr	r3, [pc, #16]	; (4ef0 <m_al_sec_aes_cmac+0x74>)
    4ede:	f003 f884 	bl	7fea <mesh_aes_cmac>
	ke_free(tm);
    4ee2:	0030      	movs	r0, r6
    4ee4:	f002 fa00 	bl	72e8 <ke_free>
    // use AES CMAC function
    mesh_sec_aes_cmac(p_key, p_message, message_len, m_al_sec_aes_result_cb, (uint32_t) res_cb);
}
    4ee8:	b009      	add	sp, #36	; 0x24
    4eea:	bdf0      	pop	{r4, r5, r6, r7, pc}
    4eec:	00020739 	.word	0x00020739
    4ef0:	00004da1 	.word	0x00004da1

00004ef4 <m_al_sec_aes_s1>:

void m_al_sec_aes_s1(const uint8_t* p_message, uint8_t message_len, m_al_sec_aes_res_cb res_cb)
{
    4ef4:	b5f0      	push	{r4, r5, r6, r7, lr}
    4ef6:	000d      	movs	r5, r1
    4ef8:	b087      	sub	sp, #28
    4efa:	0007      	movs	r7, r0
    4efc:	9201      	str	r2, [sp, #4]
extern void mesh_aes_s1(const uint8_t* message, uint8_t message_len, uint8_t* aes_res);

__INLINE_S__ void mesh_sec_aes_s1(const uint8_t* message, uint8_t message_len, 
						mesh_aes_func_result_cb res_cb, uint32_t src_info)
{
	uint8_t aes_res[16] = {0};
    4efe:	2100      	movs	r1, #0
    4f00:	2210      	movs	r2, #16
    4f02:	a802      	add	r0, sp, #8
    4f04:	f010 fda2 	bl	15a4c <memset>
	uint8_t* tm = ke_malloc(message_len, 0);
    4f08:	2100      	movs	r1, #0
    4f0a:	0028      	movs	r0, r5
    4f0c:	f002 f9e8 	bl	72e0 <ke_malloc>
	m_printf_hex(L_AL, "s1 message", message, message_len);
    4f10:	4c1d      	ldr	r4, [pc, #116]	; (4f88 <m_al_sec_aes_s1+0x94>)
    4f12:	002b      	movs	r3, r5
    4f14:	0021      	movs	r1, r4

__INLINE_S__ void mesh_sec_aes_s1(const uint8_t* message, uint8_t message_len, 
						mesh_aes_func_result_cb res_cb, uint32_t src_info)
{
	uint8_t aes_res[16] = {0};
	uint8_t* tm = ke_malloc(message_len, 0);
    4f16:	0006      	movs	r6, r0
	m_printf_hex(L_AL, "s1 message", message, message_len);
    4f18:	314c      	adds	r1, #76	; 0x4c
    4f1a:	003a      	movs	r2, r7
    4f1c:	2001      	movs	r0, #1
    4f1e:	f7ff fda5 	bl	4a6c <m_printf_hex>
	
	for(int i = 0; i < message_len; ++i){
    4f22:	2300      	movs	r3, #0
    4f24:	429d      	cmp	r5, r3
    4f26:	dd05      	ble.n	4f34 <m_al_sec_aes_s1+0x40>
    4f28:	1aea      	subs	r2, r5, r3
		tm[i] = message[message_len-1-i];
    4f2a:	3a01      	subs	r2, #1
    4f2c:	5cba      	ldrb	r2, [r7, r2]
    4f2e:	54f2      	strb	r2, [r6, r3]
{
	uint8_t aes_res[16] = {0};
	uint8_t* tm = ke_malloc(message_len, 0);
	m_printf_hex(L_AL, "s1 message", message, message_len);
	
	for(int i = 0; i < message_len; ++i){
    4f30:	3301      	adds	r3, #1
    4f32:	e7f7      	b.n	4f24 <m_al_sec_aes_s1+0x30>
		tm[i] = message[message_len-1-i];
	}
	mesh_aes_s1((const uint8_t*)tm, message_len, aes_res);
    4f34:	aa02      	add	r2, sp, #8
    4f36:	0029      	movs	r1, r5
    4f38:	0030      	movs	r0, r6
    4f3a:	f003 f8bf 	bl	80bc <mesh_aes_s1>

	ke_free(tm);
    4f3e:	0030      	movs	r0, r6
    4f40:	f002 f9d2 	bl	72e8 <ke_free>
    4f44:	220f      	movs	r2, #15
    4f46:	ab02      	add	r3, sp, #8
    4f48:	18d2      	adds	r2, r2, r3

	for(int i = 0; i < 8; ++i){
    4f4a:	2300      	movs	r3, #0
		aes_res[i] ^= aes_res[15-i];
    4f4c:	a902      	add	r1, sp, #8
    4f4e:	5cc8      	ldrb	r0, [r1, r3]
    4f50:	7811      	ldrb	r1, [r2, #0]
    4f52:	3a01      	subs	r2, #1
    4f54:	4041      	eors	r1, r0
    4f56:	a802      	add	r0, sp, #8
    4f58:	54c1      	strb	r1, [r0, r3]
		aes_res[15-i] ^= aes_res[i];
    4f5a:	7850      	ldrb	r0, [r2, #1]
    4f5c:	4041      	eors	r1, r0
    4f5e:	7051      	strb	r1, [r2, #1]
		aes_res[i] ^= aes_res[15-i];
    4f60:	a802      	add	r0, sp, #8
    4f62:	5cc0      	ldrb	r0, [r0, r3]
    4f64:	4041      	eors	r1, r0
    4f66:	a802      	add	r0, sp, #8
    4f68:	54c1      	strb	r1, [r0, r3]
	}
	mesh_aes_s1((const uint8_t*)tm, message_len, aes_res);

	ke_free(tm);

	for(int i = 0; i < 8; ++i){
    4f6a:	3301      	adds	r3, #1
    4f6c:	2b08      	cmp	r3, #8
    4f6e:	d1ed      	bne.n	4f4c <m_al_sec_aes_s1+0x58>
		aes_res[i] ^= aes_res[15-i];
		aes_res[15-i] ^= aes_res[i];
		aes_res[i] ^= aes_res[15-i];
	}
	m_printf_hex(L_AL, "s1 res", aes_res, 16);
    4f70:	0021      	movs	r1, r4
    4f72:	0002      	movs	r2, r0
    4f74:	3157      	adds	r1, #87	; 0x57
    4f76:	3308      	adds	r3, #8
    4f78:	2001      	movs	r0, #1
    4f7a:	f7ff fd77 	bl	4a6c <m_printf_hex>
__STATIC void m_al_sec_aes_result_cb(uint8_t status, const uint8_t* aes_res, uint32_t src_info)
{
    m_al_sec_aes_res_cb res_cb = (m_al_sec_aes_res_cb)src_info;

    // execute proper result callback
    res_cb(aes_res);
    4f7e:	a802      	add	r0, sp, #8
    4f80:	9b01      	ldr	r3, [sp, #4]
    4f82:	4798      	blx	r3

void m_al_sec_aes_s1(const uint8_t* p_message, uint8_t message_len, m_al_sec_aes_res_cb res_cb)
{
    // use AES S1 function
    mesh_sec_aes_s1(p_message, message_len, m_al_sec_aes_result_cb, (uint32_t) res_cb);
}
    4f84:	b007      	add	sp, #28
    4f86:	bdf0      	pop	{r4, r5, r6, r7, pc}
    4f88:	00020739 	.word	0x00020739

00004f8c <m_al_sec_aes_k1>:

void m_al_sec_aes_k1(const uint8_t* p_salt, const uint8_t* p_n, uint8_t n_len, const uint8_t* p_p, uint8_t p_len,
                     m_al_sec_aes_res_cb res_cb)
{
    4f8c:	b5f0      	push	{r4, r5, r6, r7, lr}
    4f8e:	b091      	sub	sp, #68	; 0x44
    4f90:	9004      	str	r0, [sp, #16]
    4f92:	9105      	str	r1, [sp, #20]
__INLINE_S__ void mesh_sec_aes_k1(const uint8_t* salt,  const uint8_t* n, uint8_t n_len, const uint8_t* p, uint8_t p_len,
		  mesh_aes_func_result_cb res_cb, uint32_t src_info)
{
	uint8_t aes_res[16];
	uint8_t ts[16];
	uint8_t* tn = ke_malloc(n_len,0);
    4f94:	0010      	movs	r0, r2
    4f96:	9306      	str	r3, [sp, #24]
    4f98:	2100      	movs	r1, #0
    4f9a:	ab16      	add	r3, sp, #88	; 0x58
    4f9c:	781e      	ldrb	r6, [r3, #0]
    4f9e:	0015      	movs	r5, r2
    4fa0:	f002 f99e 	bl	72e0 <ke_malloc>
	uint8_t* tp = ke_malloc(p_len,0);
    4fa4:	2100      	movs	r1, #0
__INLINE_S__ void mesh_sec_aes_k1(const uint8_t* salt,  const uint8_t* n, uint8_t n_len, const uint8_t* p, uint8_t p_len,
		  mesh_aes_func_result_cb res_cb, uint32_t src_info)
{
	uint8_t aes_res[16];
	uint8_t ts[16];
	uint8_t* tn = ke_malloc(n_len,0);
    4fa6:	0007      	movs	r7, r0
	uint8_t* tp = ke_malloc(p_len,0);
    4fa8:	0030      	movs	r0, r6
    4faa:	f002 f999 	bl	72e0 <ke_malloc>
	m_printf_hex(L_AL, "k1 salt", salt, 16);
    4fae:	4c31      	ldr	r4, [pc, #196]	; (5074 <m_al_sec_aes_k1+0xe8>)
		  mesh_aes_func_result_cb res_cb, uint32_t src_info)
{
	uint8_t aes_res[16];
	uint8_t ts[16];
	uint8_t* tn = ke_malloc(n_len,0);
	uint8_t* tp = ke_malloc(p_len,0);
    4fb0:	9003      	str	r0, [sp, #12]
	m_printf_hex(L_AL, "k1 salt", salt, 16);
    4fb2:	0021      	movs	r1, r4
    4fb4:	2310      	movs	r3, #16
    4fb6:	315e      	adds	r1, #94	; 0x5e
    4fb8:	9a04      	ldr	r2, [sp, #16]
    4fba:	2001      	movs	r0, #1
    4fbc:	f7ff fd56 	bl	4a6c <m_printf_hex>
	m_printf_hex(L_AL, "k1 n", n, n_len);
    4fc0:	0021      	movs	r1, r4
    4fc2:	002b      	movs	r3, r5
    4fc4:	3166      	adds	r1, #102	; 0x66
    4fc6:	9a05      	ldr	r2, [sp, #20]
    4fc8:	2001      	movs	r0, #1
    4fca:	f7ff fd4f 	bl	4a6c <m_printf_hex>
	m_printf_hex(L_AL, "k1 p", p, p_len);
    4fce:	0021      	movs	r1, r4
    4fd0:	0033      	movs	r3, r6
    4fd2:	316b      	adds	r1, #107	; 0x6b
    4fd4:	9a06      	ldr	r2, [sp, #24]
    4fd6:	2001      	movs	r0, #1
    4fd8:	f7ff fd48 	bl	4a6c <m_printf_hex>
	for(int i = 0; i < 16; ++i){
    4fdc:	2300      	movs	r3, #0
    4fde:	9407      	str	r4, [sp, #28]
		ts[i] = salt[15-i];
    4fe0:	a80c      	add	r0, sp, #48	; 0x30
    4fe2:	9a04      	ldr	r2, [sp, #16]
    4fe4:	1ad2      	subs	r2, r2, r3
    4fe6:	7bd2      	ldrb	r2, [r2, #15]
    4fe8:	541a      	strb	r2, [r3, r0]
	uint8_t* tn = ke_malloc(n_len,0);
	uint8_t* tp = ke_malloc(p_len,0);
	m_printf_hex(L_AL, "k1 salt", salt, 16);
	m_printf_hex(L_AL, "k1 n", n, n_len);
	m_printf_hex(L_AL, "k1 p", p, p_len);
	for(int i = 0; i < 16; ++i){
    4fea:	3301      	adds	r3, #1
    4fec:	2b10      	cmp	r3, #16
    4fee:	d1f8      	bne.n	4fe2 <m_al_sec_aes_k1+0x56>
    4ff0:	2300      	movs	r3, #0
		ts[i] = salt[15-i];
	}
	for(int i = 0; i < n_len; ++i){
    4ff2:	429d      	cmp	r5, r3
    4ff4:	dd06      	ble.n	5004 <m_al_sec_aes_k1+0x78>
    4ff6:	1aea      	subs	r2, r5, r3
		tn[i] = n[n_len-1-i];
    4ff8:	9905      	ldr	r1, [sp, #20]
    4ffa:	3a01      	subs	r2, #1
    4ffc:	5c8a      	ldrb	r2, [r1, r2]
    4ffe:	54fa      	strb	r2, [r7, r3]
	m_printf_hex(L_AL, "k1 n", n, n_len);
	m_printf_hex(L_AL, "k1 p", p, p_len);
	for(int i = 0; i < 16; ++i){
		ts[i] = salt[15-i];
	}
	for(int i = 0; i < n_len; ++i){
    5000:	3301      	adds	r3, #1
    5002:	e7f6      	b.n	4ff2 <m_al_sec_aes_k1+0x66>
    5004:	2300      	movs	r3, #0
		tn[i] = n[n_len-1-i];
	}
	for(int i = 0; i < p_len; ++i){
    5006:	429e      	cmp	r6, r3
    5008:	dd07      	ble.n	501a <m_al_sec_aes_k1+0x8e>
    500a:	1af2      	subs	r2, r6, r3
		tp[i] = p[p_len-1-i];
    500c:	9906      	ldr	r1, [sp, #24]
    500e:	3a01      	subs	r2, #1
    5010:	5c8a      	ldrb	r2, [r1, r2]
    5012:	9903      	ldr	r1, [sp, #12]
    5014:	54ca      	strb	r2, [r1, r3]
		ts[i] = salt[15-i];
	}
	for(int i = 0; i < n_len; ++i){
		tn[i] = n[n_len-1-i];
	}
	for(int i = 0; i < p_len; ++i){
    5016:	3301      	adds	r3, #1
    5018:	e7f5      	b.n	5006 <m_al_sec_aes_k1+0x7a>
		tp[i] = p[p_len-1-i];
	}
	
	mesh_aes_k1((const uint8_t*)ts, (const uint8_t*)tn, n_len, (const uint8_t*)tp, p_len, aes_res);
    501a:	ac08      	add	r4, sp, #32
    501c:	9b03      	ldr	r3, [sp, #12]
    501e:	002a      	movs	r2, r5
    5020:	0039      	movs	r1, r7
    5022:	9401      	str	r4, [sp, #4]
    5024:	9600      	str	r6, [sp, #0]
    5026:	f003 f855 	bl	80d4 <mesh_aes_k1>
	
	ke_free(tn);
    502a:	0038      	movs	r0, r7
    502c:	f002 f95c 	bl	72e8 <ke_free>
	ke_free(tp);
    5030:	9803      	ldr	r0, [sp, #12]
    5032:	f002 f959 	bl	72e8 <ke_free>
    5036:	2217      	movs	r2, #23
    5038:	ab06      	add	r3, sp, #24
    503a:	18d2      	adds	r2, r2, r3
	
	for(int i = 0; i < 8; ++i){
    503c:	2300      	movs	r3, #0
		aes_res[i] ^= aes_res[15-i];
    503e:	5ce0      	ldrb	r0, [r4, r3]
    5040:	7811      	ldrb	r1, [r2, #0]
    5042:	3a01      	subs	r2, #1
    5044:	4041      	eors	r1, r0
    5046:	54e1      	strb	r1, [r4, r3]
		aes_res[15-i] ^= aes_res[i];
    5048:	7850      	ldrb	r0, [r2, #1]
    504a:	4041      	eors	r1, r0
    504c:	7051      	strb	r1, [r2, #1]
		aes_res[i] ^= aes_res[15-i];
    504e:	5ce0      	ldrb	r0, [r4, r3]
    5050:	4041      	eors	r1, r0
    5052:	54e1      	strb	r1, [r4, r3]
	mesh_aes_k1((const uint8_t*)ts, (const uint8_t*)tn, n_len, (const uint8_t*)tp, p_len, aes_res);
	
	ke_free(tn);
	ke_free(tp);
	
	for(int i = 0; i < 8; ++i){
    5054:	3301      	adds	r3, #1
    5056:	2b08      	cmp	r3, #8
    5058:	d1f1      	bne.n	503e <m_al_sec_aes_k1+0xb2>
		aes_res[i] ^= aes_res[15-i];
		aes_res[15-i] ^= aes_res[i];
		aes_res[i] ^= aes_res[15-i];
	}
	m_printf_hex(L_AL, "k1 res", aes_res, 16);
    505a:	9907      	ldr	r1, [sp, #28]
    505c:	0022      	movs	r2, r4
    505e:	3170      	adds	r1, #112	; 0x70
    5060:	3308      	adds	r3, #8
    5062:	2001      	movs	r0, #1
    5064:	f7ff fd02 	bl	4a6c <m_printf_hex>
__STATIC void m_al_sec_aes_result_cb(uint8_t status, const uint8_t* aes_res, uint32_t src_info)
{
    m_al_sec_aes_res_cb res_cb = (m_al_sec_aes_res_cb)src_info;

    // execute proper result callback
    res_cb(aes_res);
    5068:	0020      	movs	r0, r4
    506a:	9b17      	ldr	r3, [sp, #92]	; 0x5c
    506c:	4798      	blx	r3
void m_al_sec_aes_k1(const uint8_t* p_salt, const uint8_t* p_n, uint8_t n_len, const uint8_t* p_p, uint8_t p_len,
                     m_al_sec_aes_res_cb res_cb)
{
    // use AES K1 function
    mesh_sec_aes_k1(p_salt, p_n, n_len, p_p, p_len, m_al_sec_aes_result_cb, (uint32_t) res_cb);
}
    506e:	b011      	add	sp, #68	; 0x44
    5070:	bdf0      	pop	{r4, r5, r6, r7, pc}
    5072:	46c0      	nop			; (mov r8, r8)
    5074:	00020739 	.word	0x00020739

00005078 <m_al_sec_aes_k2>:

void m_al_sec_aes_k2(const uint8_t* p_n, const uint8_t* p_p, uint8_t p_len, m_al_sec_aes_res_cb res_cb)
{
    5078:	b5f0      	push	{r4, r5, r6, r7, lr}
    507a:	0015      	movs	r5, r2
    507c:	b093      	sub	sp, #76	; 0x4c
						uint8_t* aes_res);

__INLINE_S__ void mesh_sec_aes_k2(const uint8_t* n, const uint8_t* p, uint8_t p_len, 
						mesh_aes_func_result_cb res_cb, uint32_t src_info)
{
	uint8_t aes_res[33] = {0};
    507e:	ac09      	add	r4, sp, #36	; 0x24
    5080:	2221      	movs	r2, #33	; 0x21
    5082:	9001      	str	r0, [sp, #4]
    5084:	9102      	str	r1, [sp, #8]
    5086:	0020      	movs	r0, r4
    5088:	2100      	movs	r1, #0
    508a:	9303      	str	r3, [sp, #12]
    508c:	f010 fcde 	bl	15a4c <memset>
	uint8_t tn[16];
	uint8_t* tp = ke_malloc(p_len,0);
    5090:	2100      	movs	r1, #0
    5092:	0028      	movs	r0, r5
    5094:	f002 f924 	bl	72e0 <ke_malloc>
	m_printf_hex(L_AL, "k2 n", n, 16);
    5098:	4e23      	ldr	r6, [pc, #140]	; (5128 <m_al_sec_aes_k2+0xb0>)
    509a:	2310      	movs	r3, #16
    509c:	0031      	movs	r1, r6
    509e:	9a01      	ldr	r2, [sp, #4]
    50a0:	3177      	adds	r1, #119	; 0x77
__INLINE_S__ void mesh_sec_aes_k2(const uint8_t* n, const uint8_t* p, uint8_t p_len, 
						mesh_aes_func_result_cb res_cb, uint32_t src_info)
{
	uint8_t aes_res[33] = {0};
	uint8_t tn[16];
	uint8_t* tp = ke_malloc(p_len,0);
    50a2:	0007      	movs	r7, r0
	m_printf_hex(L_AL, "k2 n", n, 16);
    50a4:	2001      	movs	r0, #1
    50a6:	f7ff fce1 	bl	4a6c <m_printf_hex>
	m_printf_hex(L_AL, "k2 p", p, p_len);
    50aa:	0031      	movs	r1, r6
    50ac:	002b      	movs	r3, r5
    50ae:	317c      	adds	r1, #124	; 0x7c
    50b0:	9a02      	ldr	r2, [sp, #8]
    50b2:	2001      	movs	r0, #1
    50b4:	f7ff fcda 	bl	4a6c <m_printf_hex>
	for(int i = 0; i < 16; ++i){
    50b8:	2300      	movs	r3, #0
		tn[i] = n[15-i];
    50ba:	a805      	add	r0, sp, #20
    50bc:	9a01      	ldr	r2, [sp, #4]
    50be:	1ad2      	subs	r2, r2, r3
    50c0:	7bd2      	ldrb	r2, [r2, #15]
    50c2:	541a      	strb	r2, [r3, r0]
	uint8_t aes_res[33] = {0};
	uint8_t tn[16];
	uint8_t* tp = ke_malloc(p_len,0);
	m_printf_hex(L_AL, "k2 n", n, 16);
	m_printf_hex(L_AL, "k2 p", p, p_len);
	for(int i = 0; i < 16; ++i){
    50c4:	3301      	adds	r3, #1
    50c6:	2b10      	cmp	r3, #16
    50c8:	d1f8      	bne.n	50bc <m_al_sec_aes_k2+0x44>
    50ca:	2300      	movs	r3, #0
		tn[i] = n[15-i];
	}
	for(int i = 0; i < p_len; ++i){
    50cc:	429d      	cmp	r5, r3
    50ce:	dd06      	ble.n	50de <m_al_sec_aes_k2+0x66>
    50d0:	1aea      	subs	r2, r5, r3
		tp[i] = p[p_len-1-i];
    50d2:	9902      	ldr	r1, [sp, #8]
    50d4:	3a01      	subs	r2, #1
    50d6:	5c8a      	ldrb	r2, [r1, r2]
    50d8:	54fa      	strb	r2, [r7, r3]
	m_printf_hex(L_AL, "k2 n", n, 16);
	m_printf_hex(L_AL, "k2 p", p, p_len);
	for(int i = 0; i < 16; ++i){
		tn[i] = n[15-i];
	}
	for(int i = 0; i < p_len; ++i){
    50da:	3301      	adds	r3, #1
    50dc:	e7f6      	b.n	50cc <m_al_sec_aes_k2+0x54>
		tp[i] = p[p_len-1-i];
	}

	mesh_aes_k2((const uint8_t*)tn, (const uint8_t*)tp, p_len, aes_res);
    50de:	0023      	movs	r3, r4
    50e0:	002a      	movs	r2, r5
    50e2:	0039      	movs	r1, r7
    50e4:	f003 f813 	bl	810e <mesh_aes_k2>

	ke_free(tp);
    50e8:	0038      	movs	r0, r7
    50ea:	f002 f8fd 	bl	72e8 <ke_free>

	for(int i = 0; i < sizeof(aes_res)/2; ++i){
    50ee:	2300      	movs	r3, #0
    50f0:	aa11      	add	r2, sp, #68	; 0x44
		aes_res[i] ^= aes_res[32-i];
    50f2:	5ce0      	ldrb	r0, [r4, r3]
    50f4:	7811      	ldrb	r1, [r2, #0]
    50f6:	3a01      	subs	r2, #1
    50f8:	4041      	eors	r1, r0
    50fa:	54e1      	strb	r1, [r4, r3]
		aes_res[32-i] ^= aes_res[i];
    50fc:	7850      	ldrb	r0, [r2, #1]
    50fe:	4041      	eors	r1, r0
    5100:	7051      	strb	r1, [r2, #1]
		aes_res[i] ^= aes_res[32-i];
    5102:	5ce0      	ldrb	r0, [r4, r3]
    5104:	4041      	eors	r1, r0
    5106:	54e1      	strb	r1, [r4, r3]

	mesh_aes_k2((const uint8_t*)tn, (const uint8_t*)tp, p_len, aes_res);

	ke_free(tp);

	for(int i = 0; i < sizeof(aes_res)/2; ++i){
    5108:	3301      	adds	r3, #1
    510a:	2b10      	cmp	r3, #16
    510c:	d1f1      	bne.n	50f2 <m_al_sec_aes_k2+0x7a>
		aes_res[i] ^= aes_res[32-i];
		aes_res[32-i] ^= aes_res[i];
		aes_res[i] ^= aes_res[32-i];
	}
	
	m_printf_hex(L_AL, "k2 res", aes_res, 33);
    510e:	4907      	ldr	r1, [pc, #28]	; (512c <m_al_sec_aes_k2+0xb4>)
    5110:	0022      	movs	r2, r4
    5112:	3101      	adds	r1, #1
    5114:	3311      	adds	r3, #17
    5116:	2001      	movs	r0, #1
    5118:	f7ff fca8 	bl	4a6c <m_printf_hex>
__STATIC void m_al_sec_aes_result_cb(uint8_t status, const uint8_t* aes_res, uint32_t src_info)
{
    m_al_sec_aes_res_cb res_cb = (m_al_sec_aes_res_cb)src_info;

    // execute proper result callback
    res_cb(aes_res);
    511c:	0020      	movs	r0, r4
    511e:	9b03      	ldr	r3, [sp, #12]
    5120:	4798      	blx	r3

void m_al_sec_aes_k2(const uint8_t* p_n, const uint8_t* p_p, uint8_t p_len, m_al_sec_aes_res_cb res_cb)
{
    // use AES K2 function
    mesh_sec_aes_k2(p_n, p_p, p_len, m_al_sec_aes_result_cb, (uint32_t) res_cb);
}
    5122:	b013      	add	sp, #76	; 0x4c
    5124:	bdf0      	pop	{r4, r5, r6, r7, pc}
    5126:	46c0      	nop			; (mov r8, r8)
    5128:	00020739 	.word	0x00020739
    512c:	000207b9 	.word	0x000207b9

00005130 <m_al_sec_aes_k3>:

void m_al_sec_aes_k3(const uint8_t* p_n, m_al_sec_aes_res_cb res_cb)
{
    5130:	b570      	push	{r4, r5, r6, lr}
    5132:	b086      	sub	sp, #24
    5134:	0006      	movs	r6, r0
****************************************************************************************
*/
extern void mesh_aes_k3(const uint8_t* n, uint8_t* aes_res);
__INLINE_S__ void mesh_sec_aes_k3(const uint8_t* n, mesh_aes_func_result_cb res_cb, uint32_t src_info)
{
	uint8_t aes_res[8] = {0};
    5136:	2208      	movs	r2, #8
    5138:	000d      	movs	r5, r1
    513a:	4668      	mov	r0, sp
    513c:	2100      	movs	r1, #0
    513e:	f010 fc85 	bl	15a4c <memset>
	uint8_t tn[16];
	m_printf_hex(L_AL, "k3 n", n, 16);
    5142:	4c19      	ldr	r4, [pc, #100]	; (51a8 <m_al_sec_aes_k3+0x78>)
    5144:	2310      	movs	r3, #16
    5146:	0021      	movs	r1, r4
    5148:	0032      	movs	r2, r6
    514a:	3108      	adds	r1, #8
    514c:	2001      	movs	r0, #1
    514e:	f7ff fc8d 	bl	4a6c <m_printf_hex>
	
	for(int i = 0; i < 16; ++i){
    5152:	2300      	movs	r3, #0
		tn[i] = n[15-i];
    5154:	1af2      	subs	r2, r6, r3
    5156:	7bd2      	ldrb	r2, [r2, #15]
    5158:	a802      	add	r0, sp, #8
    515a:	541a      	strb	r2, [r3, r0]
{
	uint8_t aes_res[8] = {0};
	uint8_t tn[16];
	m_printf_hex(L_AL, "k3 n", n, 16);
	
	for(int i = 0; i < 16; ++i){
    515c:	3301      	adds	r3, #1
    515e:	2b10      	cmp	r3, #16
    5160:	d1f8      	bne.n	5154 <m_al_sec_aes_k3+0x24>
		tn[i] = n[15-i];
	}

	mesh_aes_k3((const uint8_t*)tn, aes_res);
    5162:	4669      	mov	r1, sp
    5164:	f003 f86c 	bl	8240 <mesh_aes_k3>
    5168:	466b      	mov	r3, sp
    516a:	1dda      	adds	r2, r3, #7
	
	for(int i = 0; i < 4; ++i){
    516c:	2300      	movs	r3, #0
		aes_res[i] ^= aes_res[7-i];
    516e:	4669      	mov	r1, sp
    5170:	5cc8      	ldrb	r0, [r1, r3]
    5172:	7811      	ldrb	r1, [r2, #0]
    5174:	3a01      	subs	r2, #1
    5176:	4041      	eors	r1, r0
    5178:	4668      	mov	r0, sp
    517a:	54c1      	strb	r1, [r0, r3]
		aes_res[7-i] ^= aes_res[i];
    517c:	7850      	ldrb	r0, [r2, #1]
    517e:	4041      	eors	r1, r0
		aes_res[i] ^= aes_res[7-i];
    5180:	4668      	mov	r0, sp

	mesh_aes_k3((const uint8_t*)tn, aes_res);
	
	for(int i = 0; i < 4; ++i){
		aes_res[i] ^= aes_res[7-i];
		aes_res[7-i] ^= aes_res[i];
    5182:	7051      	strb	r1, [r2, #1]
		aes_res[i] ^= aes_res[7-i];
    5184:	5cc0      	ldrb	r0, [r0, r3]
    5186:	4041      	eors	r1, r0
    5188:	4668      	mov	r0, sp
    518a:	54c1      	strb	r1, [r0, r3]
		tn[i] = n[15-i];
	}

	mesh_aes_k3((const uint8_t*)tn, aes_res);
	
	for(int i = 0; i < 4; ++i){
    518c:	3301      	adds	r3, #1
    518e:	2b04      	cmp	r3, #4
    5190:	d1ed      	bne.n	516e <m_al_sec_aes_k3+0x3e>
		aes_res[i] ^= aes_res[7-i];
		aes_res[7-i] ^= aes_res[i];
		aes_res[i] ^= aes_res[7-i];
	}
	
	m_printf_hex(L_AL, "k3 res", aes_res, sizeof(aes_res));
    5192:	0021      	movs	r1, r4
    5194:	3304      	adds	r3, #4
    5196:	310d      	adds	r1, #13
    5198:	466a      	mov	r2, sp
    519a:	2001      	movs	r0, #1
    519c:	f7ff fc66 	bl	4a6c <m_printf_hex>
__STATIC void m_al_sec_aes_result_cb(uint8_t status, const uint8_t* aes_res, uint32_t src_info)
{
    m_al_sec_aes_res_cb res_cb = (m_al_sec_aes_res_cb)src_info;

    // execute proper result callback
    res_cb(aes_res);
    51a0:	4668      	mov	r0, sp
    51a2:	47a8      	blx	r5

void m_al_sec_aes_k3(const uint8_t* p_n, m_al_sec_aes_res_cb res_cb)
{
    // use AES K3 function
    mesh_sec_aes_k3(p_n, m_al_sec_aes_result_cb, (uint32_t) res_cb);
}
    51a4:	b006      	add	sp, #24
    51a6:	bd70      	pop	{r4, r5, r6, pc}
    51a8:	000207b9 	.word	0x000207b9

000051ac <m_al_sec_aes_k4>:

void m_al_sec_aes_k4(const uint8_t* p_n, m_al_sec_aes_res_cb res_cb)
{
    51ac:	b5f0      	push	{r4, r5, r6, r7, lr}
extern void mesh_aes_k4(const uint8_t* n, uint8_t* aes_res);
__INLINE_S__ void mesh_sec_aes_k4(const uint8_t* n, mesh_aes_func_result_cb res_cb, uint32_t src_info)
{
	uint8_t aes_res[1] = {0};
	uint8_t tn[16];
	m_printf_hex(L_AL, "k4 n", n, 16);
    51ae:	4d12      	ldr	r5, [pc, #72]	; (51f8 <m_al_sec_aes_k4+0x4c>)
    51b0:	b089      	sub	sp, #36	; 0x24
    51b2:	9101      	str	r1, [sp, #4]
    51b4:	0029      	movs	r1, r5
****************************************************************************************
*/
extern void mesh_aes_k4(const uint8_t* n, uint8_t* aes_res);
__INLINE_S__ void mesh_sec_aes_k4(const uint8_t* n, mesh_aes_func_result_cb res_cb, uint32_t src_info)
{
	uint8_t aes_res[1] = {0};
    51b6:	2400      	movs	r4, #0
    51b8:	0007      	movs	r7, r0
    51ba:	ae03      	add	r6, sp, #12
	uint8_t tn[16];
	m_printf_hex(L_AL, "k4 n", n, 16);
    51bc:	0002      	movs	r2, r0
    51be:	3114      	adds	r1, #20
    51c0:	2310      	movs	r3, #16
    51c2:	2001      	movs	r0, #1
****************************************************************************************
*/
extern void mesh_aes_k4(const uint8_t* n, uint8_t* aes_res);
__INLINE_S__ void mesh_sec_aes_k4(const uint8_t* n, mesh_aes_func_result_cb res_cb, uint32_t src_info)
{
	uint8_t aes_res[1] = {0};
    51c4:	7034      	strb	r4, [r6, #0]
	uint8_t tn[16];
	m_printf_hex(L_AL, "k4 n", n, 16);
    51c6:	f7ff fc51 	bl	4a6c <m_printf_hex>
	
	for(int i = 0; i < 16; ++i){
		tn[i] = n[15-i];
    51ca:	1b3b      	subs	r3, r7, r4
    51cc:	7bdb      	ldrb	r3, [r3, #15]
    51ce:	a804      	add	r0, sp, #16
    51d0:	5423      	strb	r3, [r4, r0]
{
	uint8_t aes_res[1] = {0};
	uint8_t tn[16];
	m_printf_hex(L_AL, "k4 n", n, 16);
	
	for(int i = 0; i < 16; ++i){
    51d2:	3401      	adds	r4, #1
    51d4:	2c10      	cmp	r4, #16
    51d6:	d1f8      	bne.n	51ca <m_al_sec_aes_k4+0x1e>
		tn[i] = n[15-i];
	}
	
	mesh_aes_k4((const uint8_t*)tn, aes_res);
    51d8:	0031      	movs	r1, r6
    51da:	f003 f859 	bl	8290 <mesh_aes_k4>
	m_printf_hex(L_AL, "k4 res", aes_res, sizeof(aes_res));
    51de:	2301      	movs	r3, #1
    51e0:	0029      	movs	r1, r5
    51e2:	0032      	movs	r2, r6
    51e4:	3119      	adds	r1, #25
    51e6:	0018      	movs	r0, r3
    51e8:	f7ff fc40 	bl	4a6c <m_printf_hex>
__STATIC void m_al_sec_aes_result_cb(uint8_t status, const uint8_t* aes_res, uint32_t src_info)
{
    m_al_sec_aes_res_cb res_cb = (m_al_sec_aes_res_cb)src_info;

    // execute proper result callback
    res_cb(aes_res);
    51ec:	0030      	movs	r0, r6
    51ee:	9b01      	ldr	r3, [sp, #4]
    51f0:	4798      	blx	r3

void m_al_sec_aes_k4(const uint8_t* p_n, m_al_sec_aes_res_cb res_cb)
{
    // use AES K4 function
    mesh_sec_aes_k4(p_n, m_al_sec_aes_result_cb, (uint32_t) res_cb);
}
    51f2:	b009      	add	sp, #36	; 0x24
    51f4:	bdf0      	pop	{r4, r5, r6, r7, pc}
    51f6:	46c0      	nop			; (mov r8, r8)
    51f8:	000207b9 	.word	0x000207b9

000051fc <m_al_sec_aes_ccm>:

void m_al_sec_aes_ccm(const uint8_t* p_key, const uint8_t* p_nonce, const uint8_t* p_in_message,
                      uint8_t* p_out_message, uint16_t message_len, uint8_t mic_len, bool cipher,
                      const uint8_t* p_add_auth_data, uint8_t add_auth_data_len, m_al_sec_aes_ccm_cb res_cb)
{
    51fc:	b5f0      	push	{r4, r5, r6, r7, lr}
__INLINE_S__ void mesh_sec_aes_ccm(const uint8_t* key, const uint8_t* nonce, const uint8_t* in_message,
		   uint8_t* out_message, uint16_t message_len, uint8_t mic_len, bool cipher,
		   const uint8_t* add_auth_data, uint8_t add_auth_data_len, mesh_aes_ccm_func_result_cb res_cb, uint32_t src_info)
{
	uint8_t tk[16];
	m_printf_hex(L_AL, "ccm key", key, 16);
    51fe:	4c43      	ldr	r4, [pc, #268]	; (530c <m_al_sec_aes_ccm+0x110>)
    5200:	000d      	movs	r5, r1
    5202:	0021      	movs	r1, r4
    5204:	b093      	sub	sp, #76	; 0x4c
    5206:	930d      	str	r3, [sp, #52]	; 0x34
    5208:	ab18      	add	r3, sp, #96	; 0x60
    520a:	881b      	ldrh	r3, [r3, #0]
    520c:	9008      	str	r0, [sp, #32]
    520e:	9309      	str	r3, [sp, #36]	; 0x24
    5210:	ab19      	add	r3, sp, #100	; 0x64
    5212:	781b      	ldrb	r3, [r3, #0]
    5214:	0016      	movs	r6, r2
    5216:	930a      	str	r3, [sp, #40]	; 0x28
    5218:	ab1a      	add	r3, sp, #104	; 0x68
    521a:	781b      	ldrb	r3, [r3, #0]
    521c:	0002      	movs	r2, r0
    521e:	930b      	str	r3, [sp, #44]	; 0x2c
    5220:	ab1c      	add	r3, sp, #112	; 0x70
    5222:	781b      	ldrb	r3, [r3, #0]
    5224:	3120      	adds	r1, #32
    5226:	930c      	str	r3, [sp, #48]	; 0x30
    5228:	2001      	movs	r0, #1
    522a:	2310      	movs	r3, #16
    522c:	f7ff fc1e 	bl	4a6c <m_printf_hex>
	m_printf_hex(L_AL, "ccm nonce",nonce, 13);
    5230:	0021      	movs	r1, r4
    5232:	230d      	movs	r3, #13
    5234:	3128      	adds	r1, #40	; 0x28
    5236:	002a      	movs	r2, r5
    5238:	2001      	movs	r0, #1
    523a:	f7ff fc17 	bl	4a6c <m_printf_hex>
	m_printf_hex(L_AL, "ccm in message",in_message, message_len);
    523e:	0021      	movs	r1, r4
    5240:	9b09      	ldr	r3, [sp, #36]	; 0x24
    5242:	3132      	adds	r1, #50	; 0x32
    5244:	0032      	movs	r2, r6
    5246:	2001      	movs	r0, #1
    5248:	f7ff fc10 	bl	4a6c <m_printf_hex>
	M_PRINTF(L_AL, "ccm mic_len = %d", mic_len);
    524c:	4b30      	ldr	r3, [pc, #192]	; (5310 <m_al_sec_aes_ccm+0x114>)
    524e:	681b      	ldr	r3, [r3, #0]
    5250:	07db      	lsls	r3, r3, #31
    5252:	d516      	bpl.n	5282 <m_al_sec_aes_ccm+0x86>
    5254:	0023      	movs	r3, r4
    5256:	336d      	adds	r3, #109	; 0x6d
    5258:	9300      	str	r3, [sp, #0]
    525a:	0022      	movs	r2, r4
    525c:	0020      	movs	r0, r4
    525e:	23a4      	movs	r3, #164	; 0xa4
    5260:	4f2c      	ldr	r7, [pc, #176]	; (5314 <m_al_sec_aes_ccm+0x118>)
    5262:	3254      	adds	r2, #84	; 0x54
    5264:	33ff      	adds	r3, #255	; 0xff
    5266:	0039      	movs	r1, r7
    5268:	305e      	adds	r0, #94	; 0x5e
    526a:	f7ff fb9f 	bl	49ac <m_print>
    526e:	0020      	movs	r0, r4
    5270:	990a      	ldr	r1, [sp, #40]	; 0x28
    5272:	307e      	adds	r0, #126	; 0x7e
    5274:	f7ff fb9a 	bl	49ac <m_print>
    5278:	4827      	ldr	r0, [pc, #156]	; (5318 <m_al_sec_aes_ccm+0x11c>)
    527a:	1db9      	adds	r1, r7, #6
    527c:	300f      	adds	r0, #15
    527e:	f7ff fb95 	bl	49ac <m_print>
	M_PRINTF(L_AL, "ccm cipher = %d", cipher);
    5282:	4b23      	ldr	r3, [pc, #140]	; (5310 <m_al_sec_aes_ccm+0x114>)
    5284:	681b      	ldr	r3, [r3, #0]
    5286:	07db      	lsls	r3, r3, #31
    5288:	d517      	bpl.n	52ba <m_al_sec_aes_ccm+0xbe>
    528a:	4b20      	ldr	r3, [pc, #128]	; (530c <m_al_sec_aes_ccm+0x110>)
    528c:	4f21      	ldr	r7, [pc, #132]	; (5314 <m_al_sec_aes_ccm+0x118>)
    528e:	001a      	movs	r2, r3
    5290:	0018      	movs	r0, r3
    5292:	336d      	adds	r3, #109	; 0x6d
    5294:	9300      	str	r3, [sp, #0]
    5296:	23d2      	movs	r3, #210	; 0xd2
    5298:	3254      	adds	r2, #84	; 0x54
    529a:	005b      	lsls	r3, r3, #1
    529c:	0039      	movs	r1, r7
    529e:	305e      	adds	r0, #94	; 0x5e
    52a0:	f7ff fb84 	bl	49ac <m_print>
    52a4:	4c1c      	ldr	r4, [pc, #112]	; (5318 <m_al_sec_aes_ccm+0x11c>)
    52a6:	990b      	ldr	r1, [sp, #44]	; 0x2c
    52a8:	0020      	movs	r0, r4
    52aa:	3012      	adds	r0, #18
    52ac:	f7ff fb7e 	bl	49ac <m_print>
    52b0:	0020      	movs	r0, r4
    52b2:	1db9      	adds	r1, r7, #6
    52b4:	300f      	adds	r0, #15
    52b6:	f7ff fb79 	bl	49ac <m_print>
	if(add_auth_data)
    52ba:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
    52bc:	2b00      	cmp	r3, #0
    52be:	d006      	beq.n	52ce <m_al_sec_aes_ccm+0xd2>
		m_printf_hex(L_AL, "ccm auth data",add_auth_data, add_auth_data_len);
    52c0:	4915      	ldr	r1, [pc, #84]	; (5318 <m_al_sec_aes_ccm+0x11c>)
    52c2:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    52c4:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
    52c6:	3122      	adds	r1, #34	; 0x22
    52c8:	2001      	movs	r0, #1
    52ca:	f7ff fbcf 	bl	4a6c <m_printf_hex>
    52ce:	2300      	movs	r3, #0
	for(int i = 0; i < 16; ++i){
		tk[i] = key[15-i];
    52d0:	9a08      	ldr	r2, [sp, #32]
    52d2:	a80e      	add	r0, sp, #56	; 0x38
    52d4:	1ad2      	subs	r2, r2, r3
    52d6:	7bd2      	ldrb	r2, [r2, #15]
    52d8:	541a      	strb	r2, [r3, r0]
	m_printf_hex(L_AL, "ccm in message",in_message, message_len);
	M_PRINTF(L_AL, "ccm mic_len = %d", mic_len);
	M_PRINTF(L_AL, "ccm cipher = %d", cipher);
	if(add_auth_data)
		m_printf_hex(L_AL, "ccm auth data",add_auth_data, add_auth_data_len);
	for(int i = 0; i < 16; ++i){
    52da:	3301      	adds	r3, #1
    52dc:	2b10      	cmp	r3, #16
    52de:	d1f7      	bne.n	52d0 <m_al_sec_aes_ccm+0xd4>
		tk[i] = key[15-i];
	}
	mesh_aes_ccm((const uint8_t*)tk, nonce, in_message,
    52e0:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    52e2:	0032      	movs	r2, r6
    52e4:	9306      	str	r3, [sp, #24]
    52e6:	4b0d      	ldr	r3, [pc, #52]	; (531c <m_al_sec_aes_ccm+0x120>)
    52e8:	0029      	movs	r1, r5
    52ea:	9305      	str	r3, [sp, #20]
    52ec:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    52ee:	9304      	str	r3, [sp, #16]
    52f0:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
    52f2:	9303      	str	r3, [sp, #12]
    52f4:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    52f6:	9302      	str	r3, [sp, #8]
    52f8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    52fa:	9301      	str	r3, [sp, #4]
    52fc:	9b09      	ldr	r3, [sp, #36]	; 0x24
    52fe:	9300      	str	r3, [sp, #0]
    5300:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    5302:	f002 ffed 	bl	82e0 <mesh_aes_ccm>
    // use AES CCM function
    mesh_sec_aes_ccm(p_key, p_nonce, p_in_message, p_out_message, message_len, mic_len, cipher,
            p_add_auth_data, add_auth_data_len, m_al_sec_ccm_result_cb, (uint32_t) res_cb);
}
    5306:	b013      	add	sp, #76	; 0x4c
    5308:	bdf0      	pop	{r4, r5, r6, r7, pc}
    530a:	46c0      	nop			; (mov r8, r8)
    530c:	000207b9 	.word	0x000207b9
    5310:	10010514 	.word	0x10010514
    5314:	00020739 	.word	0x00020739
    5318:	00020839 	.word	0x00020839
    531c:	00004da9 	.word	0x00004da9

00005320 <m_al_pub_key_res_cb>:
#ifndef  SEC_NBLOCK
void m_al_pub_key_res_cb(uint16_t status, const uint8_t* p_pub_key_x, const uint8_t* p_pub_key_y)
{
    5320:	b570      	push	{r4, r5, r6, lr}
	if(p_m_al_env != NULL){
    5322:	4b0d      	ldr	r3, [pc, #52]	; (5358 <m_al_pub_key_res_cb+0x38>)
    mesh_sec_aes_ccm(p_key, p_nonce, p_in_message, p_out_message, message_len, mic_len, cipher,
            p_add_auth_data, add_auth_data_len, m_al_sec_ccm_result_cb, (uint32_t) res_cb);
}
#ifndef  SEC_NBLOCK
void m_al_pub_key_res_cb(uint16_t status, const uint8_t* p_pub_key_x, const uint8_t* p_pub_key_y)
{
    5324:	b090      	sub	sp, #64	; 0x40
	if(p_m_al_env != NULL){
    5326:	681b      	ldr	r3, [r3, #0]
    mesh_sec_aes_ccm(p_key, p_nonce, p_in_message, p_out_message, message_len, mic_len, cipher,
            p_add_auth_data, add_auth_data_len, m_al_sec_ccm_result_cb, (uint32_t) res_cb);
}
#ifndef  SEC_NBLOCK
void m_al_pub_key_res_cb(uint16_t status, const uint8_t* p_pub_key_x, const uint8_t* p_pub_key_y)
{
    5328:	0016      	movs	r6, r2
	if(p_m_al_env != NULL){
    532a:	2b00      	cmp	r3, #0
    532c:	d011      	beq.n	5352 <m_al_pub_key_res_cb+0x32>
        m_al_sec_pub_key_res_cb res_cb = p_m_al_env->sec.cb_pub_key;
        p_m_al_env->sec.cb_pub_key     = NULL;
    532e:	2500      	movs	r5, #0
}
#ifndef  SEC_NBLOCK
void m_al_pub_key_res_cb(uint16_t status, const uint8_t* p_pub_key_x, const uint8_t* p_pub_key_y)
{
	if(p_m_al_env != NULL){
        m_al_sec_pub_key_res_cb res_cb = p_m_al_env->sec.cb_pub_key;
    5330:	689c      	ldr	r4, [r3, #8]
        p_m_al_env->sec.cb_pub_key     = NULL;
    5332:	609d      	str	r5, [r3, #8]
        if(res_cb != NULL){
    5334:	42ac      	cmp	r4, r5
    5336:	d00c      	beq.n	5352 <m_al_pub_key_res_cb+0x32>
            //res_cb(M_ERR_NO_ERROR, p_param->pub_key_x, p_param->pub_key_y);
            mesh_pub_key_ind skey;
			memcpy(&skey.pub_key_x, p_pub_key_x,  32);
    5338:	2220      	movs	r2, #32
    533a:	4668      	mov	r0, sp
    533c:	f010 fb48 	bl	159d0 <memcpy>
			memcpy(&skey.pub_key_y, p_pub_key_y, 32);
    5340:	2220      	movs	r2, #32
    5342:	0031      	movs	r1, r6
    5344:	a808      	add	r0, sp, #32
    5346:	f010 fb43 	bl	159d0 <memcpy>
			
            res_cb(M_ERR_NO_ERROR, skey.pub_key_x, skey.pub_key_y);
    534a:	aa08      	add	r2, sp, #32
    534c:	4669      	mov	r1, sp
    534e:	0028      	movs	r0, r5
    5350:	47a0      	blx	r4
        }
    }
}
    5352:	b010      	add	sp, #64	; 0x40
    5354:	bd70      	pop	{r4, r5, r6, pc}
    5356:	46c0      	nop			; (mov r8, r8)
    5358:	10012850 	.word	0x10012850

0000535c <m_al_sec_pub_key_read>:
#endif
void m_al_sec_pub_key_read(bool renew, m_al_sec_pub_key_res_cb res_cb)
{
	M_PRINTF(L_AL,"");
    535c:	4b16      	ldr	r3, [pc, #88]	; (53b8 <m_al_sec_pub_key_read+0x5c>)
        }
    }
}
#endif
void m_al_sec_pub_key_read(bool renew, m_al_sec_pub_key_res_cb res_cb)
{
    535e:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	M_PRINTF(L_AL,"");
    5360:	681b      	ldr	r3, [r3, #0]
        }
    }
}
#endif
void m_al_sec_pub_key_read(bool renew, m_al_sec_pub_key_res_cb res_cb)
{
    5362:	0006      	movs	r6, r0
    5364:	000d      	movs	r5, r1
	M_PRINTF(L_AL,"");
    5366:	07db      	lsls	r3, r3, #31
    5368:	d516      	bpl.n	5398 <m_al_sec_pub_key_read+0x3c>
    536a:	4c14      	ldr	r4, [pc, #80]	; (53bc <m_al_sec_pub_key_read+0x60>)
    536c:	4f14      	ldr	r7, [pc, #80]	; (53c0 <m_al_sec_pub_key_read+0x64>)
    536e:	0023      	movs	r3, r4
    5370:	334e      	adds	r3, #78	; 0x4e
    5372:	9300      	str	r3, [sp, #0]
    5374:	0022      	movs	r2, r4
    5376:	239d      	movs	r3, #157	; 0x9d
    5378:	4812      	ldr	r0, [pc, #72]	; (53c4 <m_al_sec_pub_key_read+0x68>)
    537a:	0039      	movs	r1, r7
    537c:	3243      	adds	r2, #67	; 0x43
    537e:	005b      	lsls	r3, r3, #1
    5380:	305e      	adds	r0, #94	; 0x5e
    5382:	f7ff fb13 	bl	49ac <m_print>
    5386:	0020      	movs	r0, r4
    5388:	3064      	adds	r0, #100	; 0x64
    538a:	f7ff fb0f 	bl	49ac <m_print>
    538e:	0020      	movs	r0, r4
    5390:	1db9      	adds	r1, r7, #6
    5392:	300f      	adds	r0, #15
    5394:	f7ff fb0a 	bl	49ac <m_print>
    if(p_m_al_env->sec.cb_dh_key  == NULL)
    5398:	4b0b      	ldr	r3, [pc, #44]	; (53c8 <m_al_sec_pub_key_read+0x6c>)
    539a:	681b      	ldr	r3, [r3, #0]
    539c:	68da      	ldr	r2, [r3, #12]
    539e:	2a00      	cmp	r2, #0
    53a0:	d105      	bne.n	53ae <m_al_sec_pub_key_read+0x52>
    {
#ifndef  SEC_NBLOCK
        p_m_al_env->sec.cb_pub_key = res_cb;
    53a2:	609d      	str	r5, [r3, #8]
*/
extern void mesh_pub_key_read(bool renew, mesh_sec_pub_key_res_cb res_cb);

__INLINE_S__ void mesh_sec_pub_key_read(bool renew, mesh_sec_pub_key_res_cb res_cb)
{
	mesh_pub_key_read(renew, res_cb);
    53a4:	4909      	ldr	r1, [pc, #36]	; (53cc <m_al_sec_pub_key_read+0x70>)
    53a6:	0030      	movs	r0, r6
    53a8:	f003 fa7c 	bl	88a4 <mesh_pub_key_read>
    53ac:	e003      	b.n	53b6 <m_al_sec_pub_key_read+0x5a>
	    }
#endif
    }
    else
    {
        res_cb(M_ERR_COMMAND_DISALLOWED, NULL, NULL);
    53ae:	2200      	movs	r2, #0
    53b0:	4807      	ldr	r0, [pc, #28]	; (53d0 <m_al_sec_pub_key_read+0x74>)
    53b2:	0011      	movs	r1, r2
    53b4:	47a8      	blx	r5
    }
}
    53b6:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
    53b8:	10010514 	.word	0x10010514
    53bc:	00020839 	.word	0x00020839
    53c0:	00020739 	.word	0x00020739
    53c4:	000207b9 	.word	0x000207b9
    53c8:	10012850 	.word	0x10012850
    53cc:	00005321 	.word	0x00005321
    53d0:	00000282 	.word	0x00000282

000053d4 <m_al_ecdh_secret_res_cb>:

#ifndef  SEC_NBLOCK
void m_al_ecdh_secret_res_cb(uint16_t status, const uint8_t* p_ecdh_secret)
{
    53d4:	b530      	push	{r4, r5, lr}
	if(p_m_al_env != NULL){
    53d6:	4b09      	ldr	r3, [pc, #36]	; (53fc <m_al_ecdh_secret_res_cb+0x28>)
    }
}

#ifndef  SEC_NBLOCK
void m_al_ecdh_secret_res_cb(uint16_t status, const uint8_t* p_ecdh_secret)
{
    53d8:	b089      	sub	sp, #36	; 0x24
	if(p_m_al_env != NULL){
    53da:	681b      	ldr	r3, [r3, #0]
    53dc:	2b00      	cmp	r3, #0
    53de:	d00b      	beq.n	53f8 <m_al_ecdh_secret_res_cb+0x24>
		m_al_sec_ecdh_secret_res_cb res_cb = p_m_al_env->sec.cb_dh_key;
		p_m_al_env->sec.cb_dh_key          = NULL;
    53e0:	2500      	movs	r5, #0

#ifndef  SEC_NBLOCK
void m_al_ecdh_secret_res_cb(uint16_t status, const uint8_t* p_ecdh_secret)
{
	if(p_m_al_env != NULL){
		m_al_sec_ecdh_secret_res_cb res_cb = p_m_al_env->sec.cb_dh_key;
    53e2:	68dc      	ldr	r4, [r3, #12]
		p_m_al_env->sec.cb_dh_key          = NULL;
    53e4:	60dd      	str	r5, [r3, #12]
		if(res_cb != NULL){
    53e6:	42ac      	cmp	r4, r5
    53e8:	d006      	beq.n	53f8 <m_al_ecdh_secret_res_cb+0x24>
			/// Result (32 bytes)
			mesh_gen_dh_key_ind skey;
			memcpy(&skey.result, p_ecdh_secret, GAP_P256_KEY_LEN);
    53ea:	2220      	movs	r2, #32
    53ec:	4668      	mov	r0, sp
    53ee:	f010 faef 	bl	159d0 <memcpy>
			res_cb(M_ERR_NO_ERROR, skey.result);
    53f2:	4669      	mov	r1, sp
    53f4:	0028      	movs	r0, r5
    53f6:	47a0      	blx	r4
		}
	}
}
    53f8:	b009      	add	sp, #36	; 0x24
    53fa:	bd30      	pop	{r4, r5, pc}
    53fc:	10012850 	.word	0x10012850

00005400 <m_al_sec_ecdh_secret>:
#endif
void m_al_sec_ecdh_secret(const uint8_t* p_pub_key_x, const uint8_t* p_pub_key_y, m_al_sec_ecdh_secret_res_cb res_cb)
{

    if(p_m_al_env->sec.cb_dh_key  == NULL)
    5400:	4b07      	ldr	r3, [pc, #28]	; (5420 <m_al_sec_ecdh_secret+0x20>)
		}
	}
}
#endif
void m_al_sec_ecdh_secret(const uint8_t* p_pub_key_x, const uint8_t* p_pub_key_y, m_al_sec_ecdh_secret_res_cb res_cb)
{
    5402:	b510      	push	{r4, lr}

    if(p_m_al_env->sec.cb_dh_key  == NULL)
    5404:	681b      	ldr	r3, [r3, #0]
    5406:	68dc      	ldr	r4, [r3, #12]
    5408:	2c00      	cmp	r4, #0
    540a:	d104      	bne.n	5416 <m_al_sec_ecdh_secret+0x16>
    {
#ifndef  SEC_NBLOCK
		p_m_al_env->sec.cb_dh_key = res_cb;
    540c:	60da      	str	r2, [r3, #12]
 ****************************************************************************************
 */
__INLINE_S__ void mesh_sec_ecdh_secret(const uint8_t* p_pub_key_x, const uint8_t* p_pub_key_y, mesh_sec_ecdh_secret_res_cb res_cb)
{
	extern void mesh_ecdh_secret(const uint8_t* p_pub_key_x, const uint8_t* p_pub_key_y, mesh_sec_ecdh_secret_res_cb res_cb);
	mesh_ecdh_secret(p_pub_key_x, p_pub_key_y, res_cb);
    540e:	4a05      	ldr	r2, [pc, #20]	; (5424 <m_al_sec_ecdh_secret+0x24>)
    5410:	f003 faa0 	bl	8954 <mesh_ecdh_secret>
    5414:	e002      	b.n	541c <m_al_sec_ecdh_secret+0x1c>
	    }
#endif
    }
    else
    {
        res_cb(M_ERR_COMMAND_DISALLOWED, NULL);
    5416:	2100      	movs	r1, #0
    5418:	4803      	ldr	r0, [pc, #12]	; (5428 <m_al_sec_ecdh_secret+0x28>)
    541a:	4790      	blx	r2
    }
}
    541c:	bd10      	pop	{r4, pc}
    541e:	46c0      	nop			; (mov r8, r8)
    5420:	10012850 	.word	0x10012850
    5424:	000053d5 	.word	0x000053d5
    5428:	00000282 	.word	0x00000282

0000542c <m_al_init>:
 * @return status code to know if profile initialization succeed or not.
 ****************************************************************************************
 */
uint8_t m_al_init(struct prf_task_env* env, uint16_t* start_hdl, uint16_t app_task,
                           uint8_t sec_lvl, m_cfg_t* p_cfg)
{
    542c:	b573      	push	{r0, r1, r4, r5, r6, lr}
    542e:	0006      	movs	r6, r0
    uint8_t status = GAP_ERR_NO_ERROR;
    m_al_env_t* p_al_env;

    // Retrieve size of environment variable required for following mesh layers
    uint16_t al_env_size    = CO_ALIGN4_HI(sizeof(m_al_env_t));
    uint16_t mesh_env_size  = CO_ALIGN4_HI(m_api_get_env_size(p_cfg));
    5430:	9806      	ldr	r0, [sp, #24]
    5432:	f003 fd41 	bl	8eb8 <m_api_get_env_size>

    // Allocate memory environment
    p_al_env = (m_al_env_t*) ke_malloc(al_env_size + mesh_env_size, KE_MEM_ATT_DB);
    5436:	2303      	movs	r3, #3
    5438:	3003      	adds	r0, #3
    543a:	4398      	bics	r0, r3
    543c:	b280      	uxth	r0, r0
    543e:	3048      	adds	r0, #72	; 0x48
    5440:	2101      	movs	r1, #1
    5442:	f001 ff4d 	bl	72e0 <ke_malloc>
	M_PRINTF(L_AL,"p_al_env = %p", p_al_env);
    5446:	4b23      	ldr	r3, [pc, #140]	; (54d4 <m_al_init+0xa8>)
    // Retrieve size of environment variable required for following mesh layers
    uint16_t al_env_size    = CO_ALIGN4_HI(sizeof(m_al_env_t));
    uint16_t mesh_env_size  = CO_ALIGN4_HI(m_api_get_env_size(p_cfg));

    // Allocate memory environment
    p_al_env = (m_al_env_t*) ke_malloc(al_env_size + mesh_env_size, KE_MEM_ATT_DB);
    5448:	0004      	movs	r4, r0
	M_PRINTF(L_AL,"p_al_env = %p", p_al_env);
    544a:	681b      	ldr	r3, [r3, #0]
    544c:	07db      	lsls	r3, r3, #31
    544e:	d515      	bpl.n	547c <m_al_init+0x50>
    5450:	4d21      	ldr	r5, [pc, #132]	; (54d8 <m_al_init+0xac>)
    5452:	002b      	movs	r3, r5
    5454:	002a      	movs	r2, r5
    5456:	0028      	movs	r0, r5
    5458:	3352      	adds	r3, #82	; 0x52
    545a:	3237      	adds	r2, #55	; 0x37
    545c:	9300      	str	r3, [sp, #0]
    545e:	0029      	movs	r1, r5
    5460:	23ce      	movs	r3, #206	; 0xce
    5462:	3043      	adds	r0, #67	; 0x43
    5464:	f7ff faa2 	bl	49ac <m_print>
    5468:	0028      	movs	r0, r5
    546a:	0021      	movs	r1, r4
    546c:	305c      	adds	r0, #92	; 0x5c
    546e:	f7ff fa9d 	bl	49ac <m_print>
    5472:	0028      	movs	r0, r5
    5474:	1da9      	adds	r1, r5, #6
    5476:	306a      	adds	r0, #106	; 0x6a
    5478:	f7ff fa98 	bl	49ac <m_print>
    547c:	4b17      	ldr	r3, [pc, #92]	; (54dc <m_al_init+0xb0>)
    if(p_al_env != NULL)
    {
        p_m_al_env = p_al_env;
    547e:	601c      	str	r4, [r3, #0]
    uint16_t mesh_env_size  = CO_ALIGN4_HI(m_api_get_env_size(p_cfg));

    // Allocate memory environment
    p_al_env = (m_al_env_t*) ke_malloc(al_env_size + mesh_env_size, KE_MEM_ATT_DB);
	M_PRINTF(L_AL,"p_al_env = %p", p_al_env);
    if(p_al_env != NULL)
    5480:	2c00      	cmp	r4, #0
    5482:	d021      	beq.n	54c8 <m_al_init+0x9c>
        // allocate DISS required environment variable
        env->env = (prf_env_t*) p_al_env;

        // initialize environment variable
        //env->id                     = MESH_MSG_MAX;//TASK_ID_MESH;
        env->desc.idx_max           = M_AL_IDX_MAX;
    5484:	2301      	movs	r3, #1
    5486:	8133      	strh	r3, [r6, #8]
        env->desc.state             = p_al_env->state;
    5488:	0023      	movs	r3, r4
    548a:	3344      	adds	r3, #68	; 0x44
    548c:	6073      	str	r3, [r6, #4]
        env->desc.msg_handler_tab   = m_al_msg_handler_tab;
    548e:	4b12      	ldr	r3, [pc, #72]	; (54d8 <m_al_init+0xac>)
        env->desc.msg_cnt           = ARRAY_LEN(m_al_msg_handler_tab);

        // First initialization of all mesh layer modules
        m_al_sec_init(false);
    5490:	2000      	movs	r0, #0

        // initialize environment variable
        //env->id                     = MESH_MSG_MAX;//TASK_ID_MESH;
        env->desc.idx_max           = M_AL_IDX_MAX;
        env->desc.state             = p_al_env->state;
        env->desc.msg_handler_tab   = m_al_msg_handler_tab;
    5492:	330c      	adds	r3, #12
    5494:	6033      	str	r3, [r6, #0]
        env->desc.msg_cnt           = ARRAY_LEN(m_al_msg_handler_tab);
    5496:	2303      	movs	r3, #3
    if(status == GAP_ERR_NO_ERROR)
    {
        uint8_t* p_env_cursor = ((uint8_t*) p_al_env) + al_env_size;

        // allocate DISS required environment variable
        env->env = (prf_env_t*) p_al_env;
    5498:	60f4      	str	r4, [r6, #12]
        // initialize environment variable
        //env->id                     = MESH_MSG_MAX;//TASK_ID_MESH;
        env->desc.idx_max           = M_AL_IDX_MAX;
        env->desc.state             = p_al_env->state;
        env->desc.msg_handler_tab   = m_al_msg_handler_tab;
        env->desc.msg_cnt           = ARRAY_LEN(m_al_msg_handler_tab);
    549a:	8173      	strh	r3, [r6, #10]

        // First initialization of all mesh layer modules
        m_al_sec_init(false);
    549c:	f7ff fc89 	bl	4db2 <m_al_sec_init>
        m_al_timer_init(false);
    54a0:	2000      	movs	r0, #0
    54a2:	f000 f8b7 	bl	5614 <m_al_timer_init>
        m_al_djob_init(false);
    54a6:	2000      	movs	r0, #0
    54a8:	f7ff fbde 	bl	4c68 <m_al_djob_init>
        m_al_adv_init(false);
    54ac:	2000      	movs	r0, #0
    54ae:	f7ff fbb3 	bl	4c18 <m_al_adv_init>
        m_al_scan_init(false);
    54b2:	2000      	movs	r0, #0
    54b4:	f7ff fbfc 	bl	4cb0 <m_al_scan_init>
        m_api_init(false, (void*)p_env_cursor, p_cfg);
    54b8:	0021      	movs	r1, r4
    54ba:	9a06      	ldr	r2, [sp, #24]
    54bc:	3148      	adds	r1, #72	; 0x48
    54be:	2000      	movs	r0, #0
    54c0:	f003 fd26 	bl	8f10 <m_api_init>
 ****************************************************************************************
 */
uint8_t m_al_init(struct prf_task_env* env, uint16_t* start_hdl, uint16_t app_task,
                           uint8_t sec_lvl, m_cfg_t* p_cfg)
{
    uint8_t status = GAP_ERR_NO_ERROR;
    54c4:	2000      	movs	r0, #0
    54c6:	e003      	b.n	54d0 <m_al_init+0xa4>
    }
    // An error occurs, clean-up
    else
    {
        p_m_al_env = NULL;
        ke_free(p_al_env);
    54c8:	0020      	movs	r0, r4
    54ca:	f001 ff0d 	bl	72e8 <ke_free>
        status = m_al_con_init(false, start_hdl, env->task, sec_lvl, p_cfg->features);
        #endif // (BLE_MESH_GATT_BEARER)
    }
    else
    {
        status = GAP_ERR_INSUFF_RESOURCES;
    54ce:	204b      	movs	r0, #75	; 0x4b
        ke_free(p_al_env);
		p_al_env = NULL;
    }

    return (status);
}
    54d0:	bd76      	pop	{r1, r2, r4, r5, r6, pc}
    54d2:	46c0      	nop			; (mov r8, r8)
    54d4:	10010514 	.word	0x10010514
    54d8:	000208a0 	.word	0x000208a0
    54dc:	10012850 	.word	0x10012850

000054e0 <m_al_destroy>:
 *
 * @param[in|out]    env        Allocated environment data.
 ****************************************************************************************
 */
void m_al_destroy(struct prf_task_env* env)
{
    54e0:	b510      	push	{r4, lr}
    54e2:	0004      	movs	r4, r0
    // Reset the Mesh layer modules
    #if (BLE_MESH_GATT_BEARER)
    m_al_con_init(true, NULL, 0, 0, 0);
    #endif // (BLE_MESH_GATT_BEARER)
    m_al_sec_init(true);
    54e4:	2001      	movs	r0, #1
    54e6:	f7ff fc64 	bl	4db2 <m_al_sec_init>
    m_al_timer_init(true);
    54ea:	2001      	movs	r0, #1
    54ec:	f000 f892 	bl	5614 <m_al_timer_init>
    m_al_djob_init(true);
    54f0:	2001      	movs	r0, #1
    54f2:	f7ff fbb9 	bl	4c68 <m_al_djob_init>
    //m_al_activity_init(true);
    m_al_adv_init(true);
    54f6:	2001      	movs	r0, #1
    54f8:	f7ff fb8e 	bl	4c18 <m_al_adv_init>
    m_al_scan_init(true);
    54fc:	2001      	movs	r0, #1
    54fe:	f7ff fbd7 	bl	4cb0 <m_al_scan_init>
    m_api_init(true, NULL, NULL);
    5502:	2200      	movs	r2, #0
    5504:	2001      	movs	r0, #1
    5506:	0011      	movs	r1, r2
    5508:	f003 fd02 	bl	8f10 <m_api_init>

    // Free environment
    ke_free(env->env);
    550c:	68e0      	ldr	r0, [r4, #12]
    550e:	f001 feeb 	bl	72e8 <ke_free>
	env->env = NULL;
    5512:	2300      	movs	r3, #0
    p_m_al_env = NULL;
    5514:	4a01      	ldr	r2, [pc, #4]	; (551c <m_al_destroy+0x3c>)
    m_al_scan_init(true);
    m_api_init(true, NULL, NULL);

    // Free environment
    ke_free(env->env);
	env->env = NULL;
    5516:	60e3      	str	r3, [r4, #12]
    p_m_al_env = NULL;
    5518:	6013      	str	r3, [r2, #0]
}
    551a:	bd10      	pop	{r4, pc}
    551c:	10012850 	.word	0x10012850

00005520 <m_al_create>:
{
    #if (BLE_MESH_GATT_BEARER)
    // Inform that connection is created
    m_al_con_create(conidx);
    #endif // (BLE_MESH_GATT_BEARER)
}
    5520:	4770      	bx	lr

00005522 <m_al_cleanup>:
{
    #if (BLE_MESH_GATT_BEARER)
    // Inform that connection is closed
    m_al_con_cleanup(conidx, reason);
    #endif // (BLE_MESH_GATT_BEARER)
}
    5522:	4770      	bx	lr

00005524 <m_al_int_message_handler>:
 *
 * @return Status of message after execution of the handler (@see enum m_al_msg_status)
 ****************************************************************************************
 */
uint8_t m_al_int_message_handler(uint16_t msg_id, uint16_t src_id, const void *p_param)
{
    5524:	b573      	push	{r0, r1, r4, r5, r6, lr}
    5526:	0005      	movs	r5, r0
    5528:	000e      	movs	r6, r1
    uint8_t msg_status = M_AL_MSG_FREE;

    // Mesh Timer Expiration Indication
    if(msg_id == MESH_TIMER_IND)
    552a:	28ce      	cmp	r0, #206	; 0xce
    552c:	d01c      	beq.n	5568 <m_al_int_message_handler+0x44>
    }
    #endif //(BLE_MESH_GATT_BEARER)
    // Unknown message
    else
    {
    	M_PRINTF(L_AL, "msg_id[%x] src_id[%x]", msg_id, src_id);
    552e:	4b10      	ldr	r3, [pc, #64]	; (5570 <m_al_int_message_handler+0x4c>)
    5530:	681b      	ldr	r3, [r3, #0]
    5532:	07db      	lsls	r3, r3, #31
    5534:	d517      	bpl.n	5566 <m_al_int_message_handler+0x42>
    5536:	4c0f      	ldr	r4, [pc, #60]	; (5574 <m_al_int_message_handler+0x50>)
    5538:	0023      	movs	r3, r4
    553a:	336d      	adds	r3, #109	; 0x6d
    553c:	9300      	str	r3, [sp, #0]
    553e:	0022      	movs	r2, r4
    5540:	0020      	movs	r0, r4
    5542:	235a      	movs	r3, #90	; 0x5a
    5544:	3237      	adds	r2, #55	; 0x37
    5546:	33ff      	adds	r3, #255	; 0xff
    5548:	0021      	movs	r1, r4
    554a:	3043      	adds	r0, #67	; 0x43
    554c:	f7ff fa2e 	bl	49ac <m_print>
    5550:	4809      	ldr	r0, [pc, #36]	; (5578 <m_al_int_message_handler+0x54>)
    5552:	0029      	movs	r1, r5
    5554:	0032      	movs	r2, r6
    5556:	3006      	adds	r0, #6
    5558:	f7ff fa28 	bl	49ac <m_print>
    555c:	0020      	movs	r0, r4
    555e:	1da1      	adds	r1, r4, #6
    5560:	306a      	adds	r0, #106	; 0x6a
    5562:	f7ff fa23 	bl	49ac <m_print>
    5566:	e7fe      	b.n	5566 <m_al_int_message_handler+0x42>
    uint8_t msg_status = M_AL_MSG_FREE;

    // Mesh Timer Expiration Indication
    if(msg_id == MESH_TIMER_IND)
    {
        mesh_timer_ind_handler();
    5568:	f000 f8da 	bl	5720 <mesh_timer_ind_handler>
    	M_PRINTF(L_AL, "msg_id[%x] src_id[%x]", msg_id, src_id);
        ASSERT_WARN(0, msg_id, src_id);
    }

    return (msg_status);
}
    556c:	2000      	movs	r0, #0
    556e:	bd76      	pop	{r1, r2, r4, r5, r6, pc}
    5570:	10010514 	.word	0x10010514
    5574:	000208a0 	.word	0x000208a0
    5578:	00020920 	.word	0x00020920

0000557c <ke_msg_default_handler>:
 * @return If the message was consumed or not.
 ****************************************************************************************
 */
__STATIC int ke_msg_default_handler(ke_msg_id_t const msg_id, const void* p_param,
                                    ke_task_id_t const dest_id, ke_task_id_t const src_id)
{
    557c:	000a      	movs	r2, r1
    557e:	b510      	push	{r4, lr}
    5580:	0019      	movs	r1, r3
    if (TASK_IDX_GET(msg_id) == MESH_MSG_MAX)//TASK_ID_MESH)
    {
    #endif
        // Check if the message is an internal message
        #if 1
        if (msg_id >= MESH_FIRST_INT_MSG)
    5582:	28cd      	cmp	r0, #205	; 0xcd
    5584:	d902      	bls.n	558c <ke_msg_default_handler+0x10>
        {
            // Handle it locally
            func_ret = m_al_int_message_handler((uint16_t)msg_id, (uint16_t)src_id, p_param);
    5586:	f7ff ffcd 	bl	5524 <m_al_int_message_handler>
    558a:	e001      	b.n	5590 <ke_msg_default_handler+0x14>
        else
		#endif
		if (msg_id < MESH_FIRST_INT_MSG)
        {
            // Let m_api module to handle it.
            func_ret = m_api_message_handler((uint16_t)msg_id, (uint16_t)src_id, p_param);
    558c:	f003 fc6c 	bl	8e68 <m_api_message_handler>
            ASSERT_INFO(0, msg_id, src_id);
        }
    }
	#endif
    // Update message status from abstraction layer to the kernel values
    switch(func_ret)
    5590:	2800      	cmp	r0, #0
    5592:	d002      	beq.n	559a <ke_msg_default_handler+0x1e>
    5594:	2801      	cmp	r0, #1
    5596:	d000      	beq.n	559a <ke_msg_default_handler+0x1e>
    5598:	e7fe      	b.n	5598 <ke_msg_default_handler+0x1c>
        // drop message - not possible to save it for later
        default:               { msg_status = KE_MSG_CONSUMED; ASSERT_INFO(0, msg_id, src_id); } break;
    }

    return (msg_status);
}
    559a:	bd10      	pop	{r4, pc}

0000559c <m_al_msg_alloc>:
{
   return &m_al_itf;
}
#endif
void* m_al_msg_alloc(uint16_t msg_id, uint16_t param_len)
{
    559c:	b570      	push	{r4, r5, r6, lr}
    559e:	0005      	movs	r5, r0
    // rewrite kernel malloc to prevent having the default memset
    struct ke_msg *p_ke_msg = (struct ke_msg*) ke_malloc(sizeof(struct ke_msg) + param_len, KE_MEM_KE_MSG);
    55a0:	0008      	movs	r0, r1
{
   return &m_al_itf;
}
#endif
void* m_al_msg_alloc(uint16_t msg_id, uint16_t param_len)
{
    55a2:	000c      	movs	r4, r1
    // rewrite kernel malloc to prevent having the default memset
    struct ke_msg *p_ke_msg = (struct ke_msg*) ke_malloc(sizeof(struct ke_msg) + param_len, KE_MEM_KE_MSG);
    55a4:	300c      	adds	r0, #12
    55a6:	2102      	movs	r1, #2
    55a8:	f001 fe9a 	bl	72e0 <ke_malloc>
    void *p_msg = NULL;

    ASSERT_ERR(p_ke_msg != NULL);
    55ac:	2800      	cmp	r0, #0
    55ae:	d100      	bne.n	55b2 <m_al_msg_alloc+0x16>
    55b0:	e7fe      	b.n	55b0 <m_al_msg_alloc+0x14>

    // partially fill the header
    p_ke_msg->hdr.next  = KE_MSG_NOT_IN_QUEUE;
    55b2:	2301      	movs	r3, #1
    55b4:	425b      	negs	r3, r3
    p_ke_msg->id        = msg_id;
    55b6:	8085      	strh	r5, [r0, #4]
    void *p_msg = NULL;

    ASSERT_ERR(p_ke_msg != NULL);

    // partially fill the header
    p_ke_msg->hdr.next  = KE_MSG_NOT_IN_QUEUE;
    55b8:	6003      	str	r3, [r0, #0]
    p_ke_msg->id        = msg_id;
    p_ke_msg->param_len = param_len;
    55ba:	8144      	strh	r4, [r0, #10]

    // retrieve message parameters
    p_msg = ke_msg2param(p_ke_msg);

    return (p_msg);
    55bc:	300c      	adds	r0, #12
}
    55be:	bd70      	pop	{r4, r5, r6, pc}

000055c0 <m_al_msg_free>:

void m_al_msg_free(const void* p_msg)
{
    55c0:	b510      	push	{r4, lr}
    // Directly free the message
    ke_msg_free(ke_param2msg(p_msg));
    55c2:	380c      	subs	r0, #12
    55c4:	f001 ff2c 	bl	7420 <ke_msg_free>
}
    55c8:	bd10      	pop	{r4, pc}

000055ca <m_al_msg_send>:

    return (prf_src_task_get(&(mal_env->prf_env), 0));
}
#endif
void m_al_msg_send(const void* p_msg)
{
    55ca:	b510      	push	{r4, lr}
    // retrieve kernel message properties
    struct ke_msg* p_ke_msg = ke_param2msg(p_msg);
    p_ke_msg->src_id        = 0;//m_al_local_id_get();
    p_ke_msg->dest_id       = dst_id;
#endif
    ke_msg_send(p_msg);
    55cc:	f001 ff1a 	bl	7404 <ke_msg_send>
}
    55d0:	bd10      	pop	{r4, pc}

000055d2 <m_al_malloc>:
    return p_ke_msg->src_id;
}
#endif

void* m_al_malloc(uint16_t size)
{
    55d2:	b510      	push	{r4, lr}
    return ke_malloc(size, KE_MEM_ATT_DB);
    55d4:	2101      	movs	r1, #1
    55d6:	f001 fe83 	bl	72e0 <ke_malloc>
}
    55da:	bd10      	pop	{r4, pc}

000055dc <m_al_free>:

void m_al_free(void* p_ptr)
{
    55dc:	b510      	push	{r4, lr}
    ke_free(p_ptr);
    55de:	f001 fe83 	bl	72e8 <ke_free>
}
    55e2:	bd10      	pop	{r4, pc}

000055e4 <m_al_timer_update_clock>:
 * @brief Update clock information
 ****************************************************************************************
 */
__STATIC void m_al_timer_update_clock(void)
{
    m_al_timer_env_t* p_env = &(p_m_al_env->timer);
    55e4:	4b0a      	ldr	r3, [pc, #40]	; (5610 <m_al_timer_update_clock+0x2c>)
 ****************************************************************************************
 * @brief Update clock information
 ****************************************************************************************
 */
__STATIC void m_al_timer_update_clock(void)
{
    55e6:	b510      	push	{r4, lr}
    m_al_timer_env_t* p_env = &(p_m_al_env->timer);
    55e8:	681c      	ldr	r4, [r3, #0]
    // Get current local time (10 ms unit)
    uint32_t cur_time_loc = ke_time();
    55ea:	f000 feba 	bl	6362 <ke_time>
    uint32_t upd_time_loc = (cur_time_loc - p_env->last_time_loc) & M_AL_TIMER_LOCAL_MAX;
    // Keep clock value
    uint32_t old_clock_ms = p_env->clock_ms;

    // Update clock value (1 ms unit)
    p_env->clock_ms += M_AL_TIMER_LOC_TO_MS(upd_time_loc);
    55ee:	220a      	movs	r2, #10
    55f0:	6923      	ldr	r3, [r4, #16]
    // Get current local time (10 ms unit)
    uint32_t cur_time_loc = ke_time();
    // Time (10 ms unit) since last clock update
    uint32_t upd_time_loc = (cur_time_loc - p_env->last_time_loc) & M_AL_TIMER_LOCAL_MAX;
    // Keep clock value
    uint32_t old_clock_ms = p_env->clock_ms;
    55f2:	6961      	ldr	r1, [r4, #20]

    // Update clock value (1 ms unit)
    p_env->clock_ms += M_AL_TIMER_LOC_TO_MS(upd_time_loc);
    55f4:	1ac3      	subs	r3, r0, r3
    55f6:	025b      	lsls	r3, r3, #9
    55f8:	0a5b      	lsrs	r3, r3, #9
    55fa:	4353      	muls	r3, r2
    55fc:	185b      	adds	r3, r3, r1
    55fe:	6163      	str	r3, [r4, #20]

    // Check if clock value has wrapped
    if (p_env->clock_ms < old_clock_ms)
    5600:	4299      	cmp	r1, r3
    5602:	d902      	bls.n	560a <m_al_timer_update_clock+0x26>
    {
        p_env->nb_wrap++;
    5604:	8b23      	ldrh	r3, [r4, #24]
    5606:	3301      	adds	r3, #1
    5608:	8323      	strh	r3, [r4, #24]
    }

    p_env->last_time_loc = cur_time_loc;
    560a:	6120      	str	r0, [r4, #16]
}
    560c:	bd10      	pop	{r4, pc}
    560e:	46c0      	nop			; (mov r8, r8)
    5610:	10012850 	.word	0x10012850

00005614 <m_al_timer_init>:
 * GLOBAL FUNCTIONS
 ****************************************************************************************
 */

void m_al_timer_init(bool reset)
{
    5614:	b570      	push	{r4, r5, r6, lr}
    5616:	1e05      	subs	r5, r0, #0
    if (!reset)
    5618:	d106      	bne.n	5628 <m_al_timer_init+0x14>
    {
        // Get environment for Timer Abstraction Layer
        m_al_timer_env_t* p_env = &(p_m_al_env->timer);
    561a:	4b04      	ldr	r3, [pc, #16]	; (562c <m_al_timer_init+0x18>)
    561c:	681c      	ldr	r4, [r3, #0]

        // Read current local time (10 ms unit)
        p_env->last_time_loc = ke_time();
    561e:	f000 fea0 	bl	6362 <ke_time>

        // Initialize clock information
        p_env->clock_ms = 0;
    5622:	6165      	str	r5, [r4, #20]
    {
        // Get environment for Timer Abstraction Layer
        m_al_timer_env_t* p_env = &(p_m_al_env->timer);

        // Read current local time (10 ms unit)
        p_env->last_time_loc = ke_time();
    5624:	6120      	str	r0, [r4, #16]

        // Initialize clock information
        p_env->clock_ms = 0;
        p_env->nb_wrap = 0;
    5626:	8325      	strh	r5, [r4, #24]
    }
}
    5628:	bd70      	pop	{r4, r5, r6, pc}
    562a:	46c0      	nop			; (mov r8, r8)
    562c:	10012850 	.word	0x10012850

00005630 <m_al_timer_get_time_ms>:

bool m_al_timer_get_time_ms(uint32_t *p_time_ms, uint16_t *p_nb_wrap, uint32_t delay_ms)
{
    5630:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    5632:	0006      	movs	r6, r0
    5634:	000c      	movs	r4, r1
    5636:	0017      	movs	r7, r2
    m_al_timer_env_t* p_env = &(p_m_al_env->timer);
    // Indicate if delay is valid
    bool is_valid = false;
    5638:	2000      	movs	r0, #0

    if (delay_ms > M_AL_TIMER_MARGIN_MS)
    563a:	2a0a      	cmp	r2, #10
    563c:	d90e      	bls.n	565c <m_al_timer_get_time_ms+0x2c>
    }
}

bool m_al_timer_get_time_ms(uint32_t *p_time_ms, uint16_t *p_nb_wrap, uint32_t delay_ms)
{
    m_al_timer_env_t* p_env = &(p_m_al_env->timer);
    563e:	4b08      	ldr	r3, [pc, #32]	; (5660 <m_al_timer_get_time_ms+0x30>)
    5640:	681d      	ldr	r5, [r3, #0]
    bool is_valid = false;

    if (delay_ms > M_AL_TIMER_MARGIN_MS)
    {
        // Update clock information
        m_al_timer_update_clock();
    5642:	f7ff ffcf 	bl	55e4 <m_al_timer_update_clock>

        // Return update clock information
        *p_time_ms = (p_env->clock_ms + delay_ms);
    5646:	696b      	ldr	r3, [r5, #20]
        if (*p_time_ms < p_env->clock_ms)
        {
            (*p_nb_wrap)++;
        }

        is_valid = true;
    5648:	2001      	movs	r0, #1
    {
        // Update clock information
        m_al_timer_update_clock();

        // Return update clock information
        *p_time_ms = (p_env->clock_ms + delay_ms);
    564a:	18fa      	adds	r2, r7, r3
    564c:	6032      	str	r2, [r6, #0]
        *p_nb_wrap = p_env->nb_wrap;
    564e:	8b2b      	ldrh	r3, [r5, #24]

        if (*p_time_ms < p_env->clock_ms)
    5650:	6969      	ldr	r1, [r5, #20]
        // Update clock information
        m_al_timer_update_clock();

        // Return update clock information
        *p_time_ms = (p_env->clock_ms + delay_ms);
        *p_nb_wrap = p_env->nb_wrap;
    5652:	8023      	strh	r3, [r4, #0]

        if (*p_time_ms < p_env->clock_ms)
    5654:	428a      	cmp	r2, r1
    5656:	d201      	bcs.n	565c <m_al_timer_get_time_ms+0x2c>
        {
            (*p_nb_wrap)++;
    5658:	181b      	adds	r3, r3, r0
    565a:	8023      	strh	r3, [r4, #0]

        is_valid = true;
    }

    return (is_valid);
}
    565c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    565e:	46c0      	nop			; (mov r8, r8)
    5660:	10012850 	.word	0x10012850

00005664 <m_al_timer_get_delay>:

uint16_t m_al_timer_get_delay(uint32_t time_ms, uint16_t nb_wrap, uint32_t *p_delay_ms)
{
    5664:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    m_al_timer_env_t* p_env = &(p_m_al_env->timer);
    5666:	4b14      	ldr	r3, [pc, #80]	; (56b8 <m_al_timer_get_delay+0x54>)

    return (is_valid);
}

uint16_t m_al_timer_get_delay(uint32_t time_ms, uint16_t nb_wrap, uint32_t *p_delay_ms)
{
    5668:	0005      	movs	r5, r0
    m_al_timer_env_t* p_env = &(p_m_al_env->timer);
    566a:	681e      	ldr	r6, [r3, #0]

    return (is_valid);
}

uint16_t m_al_timer_get_delay(uint32_t time_ms, uint16_t nb_wrap, uint32_t *p_delay_ms)
{
    566c:	000f      	movs	r7, r1
    566e:	0014      	movs	r4, r2
    m_al_timer_env_t* p_env = &(p_m_al_env->timer);
    // Status - Consider that provided time value in the past
    uint16_t status = M_ERR_TIME_PAST;

    // Update clock information
    m_al_timer_update_clock();
    5670:	f7ff ffb8 	bl	55e4 <m_al_timer_update_clock>
	//M_PRINTF(L_AL,"timer clock_ms=%d nb_wrap = %d", time_ms, nb_wrap);
	//M_PRINTF(L_AL,"current clock_ms=%d nb_wrap = %d", p_env->clock_ms, p_env->nb_wrap);

    // Compute the delay if possible, if not return why it is not possible
    if (nb_wrap == p_env->nb_wrap)
    5674:	8b33      	ldrh	r3, [r6, #24]
    5676:	42bb      	cmp	r3, r7
    5678:	d107      	bne.n	568a <m_al_timer_get_delay+0x26>
    {
        if (time_ms >= (p_env->clock_ms + M_AL_TIMER_MARGIN_MS))
    567a:	6970      	ldr	r0, [r6, #20]
    567c:	0003      	movs	r3, r0
    567e:	330a      	adds	r3, #10
    5680:	42ab      	cmp	r3, r5
    5682:	d813      	bhi.n	56ac <m_al_timer_get_delay+0x48>
        {
            *p_delay_ms = (time_ms - p_env->clock_ms);
    5684:	1a28      	subs	r0, r5, r0
    5686:	6020      	str	r0, [r4, #0]
    5688:	e00a      	b.n	56a0 <m_al_timer_get_delay+0x3c>
            status = M_ERR_NO_ERROR;
        }
    }
    else if (nb_wrap > p_env->nb_wrap)
    568a:	42bb      	cmp	r3, r7
    568c:	d20e      	bcs.n	56ac <m_al_timer_get_delay+0x48>
    {
        // Consider now that provided time value is too far in the future
        status = M_ERR_INVALID_PARAM;

        if (nb_wrap == (p_env->nb_wrap + 1))
    568e:	3301      	adds	r3, #1
    5690:	429f      	cmp	r7, r3
    5692:	d10d      	bne.n	56b0 <m_al_timer_get_delay+0x4c>
        {
            if (p_env->clock_ms >= time_ms)
    5694:	6970      	ldr	r0, [r6, #20]
    5696:	4285      	cmp	r5, r0
    5698:	d80a      	bhi.n	56b0 <m_al_timer_get_delay+0x4c>
            {
                *p_delay_ms = (p_env->clock_ms - time_ms) + 0xFFFFFFFF;
    569a:	3801      	subs	r0, #1
    569c:	1b40      	subs	r0, r0, r5
    569e:	6020      	str	r0, [r4, #0]

    if (status == M_ERR_NO_ERROR)
    {
        // If delay value in milliseconds has been computed, check it is not too high to be used
        // by the local timer
        if (M_AL_TIMER_MS_TO_LOC(*p_delay_ms) > M_AL_TIMER_LOCAL_MAX)
    56a0:	4b06      	ldr	r3, [pc, #24]	; (56bc <m_al_timer_get_delay+0x58>)
    56a2:	6822      	ldr	r2, [r4, #0]
    56a4:	2000      	movs	r0, #0
    56a6:	429a      	cmp	r2, r3
    56a8:	d802      	bhi.n	56b0 <m_al_timer_get_delay+0x4c>
    56aa:	e003      	b.n	56b4 <m_al_timer_get_delay+0x50>

uint16_t m_al_timer_get_delay(uint32_t time_ms, uint16_t nb_wrap, uint32_t *p_delay_ms)
{
    m_al_timer_env_t* p_env = &(p_m_al_env->timer);
    // Status - Consider that provided time value in the past
    uint16_t status = M_ERR_TIME_PAST;
    56ac:	4804      	ldr	r0, [pc, #16]	; (56c0 <m_al_timer_get_delay+0x5c>)
    56ae:	e001      	b.n	56b4 <m_al_timer_get_delay+0x50>
        }
    }
    else if (nb_wrap > p_env->nb_wrap)
    {
        // Consider now that provided time value is too far in the future
        status = M_ERR_INVALID_PARAM;
    56b0:	20c1      	movs	r0, #193	; 0xc1
    56b2:	0040      	lsls	r0, r0, #1
        }
    }
	//M_PRINTF(L_AL,"status=%d p_delay_ms = %d", status, *p_delay_ms);
    // Return status
    return (status);
}
    56b4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    56b6:	46c0      	nop			; (mov r8, r8)
    56b8:	10012850 	.word	0x10012850
    56bc:	04ffffff 	.word	0x04ffffff
    56c0:	00000582 	.word	0x00000582

000056c4 <m_al_timer_set>:

void m_al_timer_set(uint32_t delay_ms)
{
    56c4:	b510      	push	{r4, lr}
    // Set the kernel timer
    ke_timer_set(MESH_TIMER_IND, p_m_al_env->prf_env.prf_task,
    56c6:	210a      	movs	r1, #10
    56c8:	f7fe fe11 	bl	42ee <__aeabi_uidiv>
    56cc:	4b03      	ldr	r3, [pc, #12]	; (56dc <m_al_timer_set+0x18>)
    56ce:	0002      	movs	r2, r0
    56d0:	681b      	ldr	r3, [r3, #0]
    56d2:	20ce      	movs	r0, #206	; 0xce
    56d4:	8859      	ldrh	r1, [r3, #2]
    56d6:	f000 fe3b 	bl	6350 <ke_timer_set>
                 M_AL_TIMER_MS_TO_LOC(delay_ms));
}
    56da:	bd10      	pop	{r4, pc}
    56dc:	10012850 	.word	0x10012850

000056e0 <m_al_timer_clear>:

void m_al_timer_clear(void)
{
    56e0:	b510      	push	{r4, lr}
    // Clear kernel timer
    ke_timer_clear(MESH_TIMER_IND, p_m_al_env->prf_env.prf_task);
    56e2:	4b03      	ldr	r3, [pc, #12]	; (56f0 <m_al_timer_clear+0x10>)
    56e4:	20ce      	movs	r0, #206	; 0xce
    56e6:	681b      	ldr	r3, [r3, #0]
    56e8:	8859      	ldrh	r1, [r3, #2]
    56ea:	f000 fe23 	bl	6334 <ke_timer_clear>
}
    56ee:	bd10      	pop	{r4, pc}
    56f0:	10012850 	.word	0x10012850

000056f4 <m_al_timer_set_clock>:

void m_al_timer_set_clock(uint32_t clock_ms, uint16_t nb_wrap)
{
    m_al_timer_env_t *p_env = &(p_m_al_env->timer);
    56f4:	4b02      	ldr	r3, [pc, #8]	; (5700 <m_al_timer_set_clock+0xc>)
    56f6:	681b      	ldr	r3, [r3, #0]

    // Store provided clock
    p_env->clock_ms = clock_ms;
    56f8:	6158      	str	r0, [r3, #20]
    p_env->nb_wrap = nb_wrap;
    56fa:	8319      	strh	r1, [r3, #24]
}
    56fc:	4770      	bx	lr
    56fe:	46c0      	nop			; (mov r8, r8)
    5700:	10012850 	.word	0x10012850

00005704 <m_al_timer_get_clock>:

void m_al_timer_get_clock(uint32_t *p_clock_ms, uint16_t *p_nb_wrap)
{
    5704:	b570      	push	{r4, r5, r6, lr}
    5706:	0006      	movs	r6, r0
    5708:	000d      	movs	r5, r1
    m_al_timer_env_t* p_env = &(p_m_al_env->timer);
    570a:	4b04      	ldr	r3, [pc, #16]	; (571c <m_al_timer_get_clock+0x18>)
    570c:	681c      	ldr	r4, [r3, #0]
    // Update clock information
    m_al_timer_update_clock();
    570e:	f7ff ff69 	bl	55e4 <m_al_timer_update_clock>

    // Return current clock
    *p_clock_ms = p_env->clock_ms;
    5712:	6963      	ldr	r3, [r4, #20]
    5714:	6033      	str	r3, [r6, #0]
    *p_nb_wrap = p_env->nb_wrap;
    5716:	8b23      	ldrh	r3, [r4, #24]
    5718:	802b      	strh	r3, [r5, #0]
}
    571a:	bd70      	pop	{r4, r5, r6, pc}
    571c:	10012850 	.word	0x10012850

00005720 <mesh_timer_ind_handler>:
 *
 * @return M_AL_MSG_FREE so that the message can be freed.
 ****************************************************************************************
 */
void mesh_timer_ind_handler(void)
{
    5720:	b510      	push	{r4, lr}
    // Inform the timer manager that the programmed timer has expired
    m_tb_timer_expired();
    5722:	f00f fe3d 	bl	153a0 <m_tb_timer_expired>
}
    5726:	bd10      	pop	{r4, pc}

00005728 <bc_mm_com_get_tx_hdl>:
static uint8_t uiModelCnt = 0;
uint8_t emmTid = 0;

uint8_t bc_mm_com_get_tx_hdl(void)
{
	return mm_tx_hdl;
    5728:	4b01      	ldr	r3, [pc, #4]	; (5730 <bc_mm_com_get_tx_hdl+0x8>)
    572a:	7818      	ldrb	r0, [r3, #0]
}
    572c:	4770      	bx	lr
    572e:	46c0      	nop			; (mov r8, r8)
    5730:	1001111c 	.word	0x1001111c

00005734 <_models_rx_cb>:
 * @param[in] not_relayed True if message have been received by an immediate peer; False, it can have been relayed
 ****************************************************************************************
 */
__STATIC void _models_rx_cb(m_lid_t model_lid, uint32_t opcode, m_api_buf_t* p_buf, m_lid_t  app_key_lid, uint16_t src,
                                    int8_t rssi, bool not_relayed)
{
    5734:	b5f0      	push	{r4, r5, r6, r7, lr}
    5736:	b089      	sub	sp, #36	; 0x24
    5738:	9304      	str	r3, [sp, #16]
    573a:	ab0e      	add	r3, sp, #56	; 0x38
    573c:	881b      	ldrh	r3, [r3, #0]
    573e:	0007      	movs	r7, r0
    5740:	9305      	str	r3, [sp, #20]
    5742:	ab0f      	add	r3, sp, #60	; 0x3c
    5744:	781b      	ldrb	r3, [r3, #0]
    5746:	9102      	str	r1, [sp, #8]
    5748:	b25b      	sxtb	r3, r3
    574a:	9306      	str	r3, [sp, #24]
    574c:	ab10      	add	r3, sp, #64	; 0x40
    574e:	781b      	ldrb	r3, [r3, #0]
    5750:	0014      	movs	r4, r2
    5752:	9307      	str	r3, [sp, #28]
	M_PRINTF(L_APP, "model_lid[%d] opcode[0x%x]", model_lid, opcode);
    5754:	4b2b      	ldr	r3, [pc, #172]	; (5804 <_models_rx_cb+0xd0>)
    5756:	681b      	ldr	r3, [r3, #0]
    5758:	049b      	lsls	r3, r3, #18
    575a:	d516      	bpl.n	578a <_models_rx_cb+0x56>
    575c:	4d2a      	ldr	r5, [pc, #168]	; (5808 <_models_rx_cb+0xd4>)
    575e:	002b      	movs	r3, r5
    5760:	002a      	movs	r2, r5
    5762:	0028      	movs	r0, r5
    5764:	333a      	adds	r3, #58	; 0x3a
    5766:	3222      	adds	r2, #34	; 0x22
    5768:	9300      	str	r3, [sp, #0]
    576a:	0029      	movs	r1, r5
    576c:	2320      	movs	r3, #32
    576e:	302b      	adds	r0, #43	; 0x2b
    5770:	f7ff f91c 	bl	49ac <m_print>
    5774:	0028      	movs	r0, r5
    5776:	0039      	movs	r1, r7
    5778:	3048      	adds	r0, #72	; 0x48
    577a:	9a02      	ldr	r2, [sp, #8]
    577c:	f7ff f916 	bl	49ac <m_print>
    5780:	0028      	movs	r0, r5
    5782:	1da9      	adds	r1, r5, #6
    5784:	3063      	adds	r0, #99	; 0x63
    5786:	f7ff f911 	bl	49ac <m_print>
	for(int i = 0; i < uiModelCnt; ++i){
    578a:	2200      	movs	r2, #0
    578c:	4b1f      	ldr	r3, [pc, #124]	; (580c <_models_rx_cb+0xd8>)
    578e:	7a19      	ldrb	r1, [r3, #8]
    5790:	685b      	ldr	r3, [r3, #4]
    5792:	428a      	cmp	r2, r1
    5794:	da34      	bge.n	5800 <_models_rx_cb+0xcc>
		mesh_model_t* t = &pstModel_t[i];
    5796:	001e      	movs	r6, r3
    5798:	3310      	adds	r3, #16
		if(t->lid != model_lid)
    579a:	0018      	movs	r0, r3
    579c:	380b      	subs	r0, #11
    579e:	7800      	ldrb	r0, [r0, #0]
    57a0:	42b8      	cmp	r0, r7
    57a2:	d001      	beq.n	57a8 <_models_rx_cb+0x74>
 */
__STATIC void _models_rx_cb(m_lid_t model_lid, uint32_t opcode, m_api_buf_t* p_buf, m_lid_t  app_key_lid, uint16_t src,
                                    int8_t rssi, bool not_relayed)
{
	M_PRINTF(L_APP, "model_lid[%d] opcode[0x%x]", model_lid, opcode);
	for(int i = 0; i < uiModelCnt; ++i){
    57a4:	3201      	adds	r2, #1
    57a6:	e7f4      	b.n	5792 <_models_rx_cb+0x5e>
		mesh_model_t* t = &pstModel_t[i];
		if(t->lid != model_lid)
			continue;
		if(t->msg_deal_cb != NULL){
    57a8:	68f3      	ldr	r3, [r6, #12]
    57aa:	2b00      	cmp	r3, #0
    57ac:	d028      	beq.n	5800 <_models_rx_cb+0xcc>
			// Retrieve buffer info
			uint16_t len     = bc_m_buf_data_len_get(p_buf);
    57ae:	0020      	movs	r0, r4
    57b0:	f003 fb0b 	bl	8dca <bc_m_buf_data_len_get>
    57b4:	0005      	movs	r5, r0
			uint8_t* p_data  = bc_m_buf_data_get(p_buf);
    57b6:	0020      	movs	r0, r4
    57b8:	f003 fb01 	bl	8dbe <bc_m_buf_data_get>
    57bc:	9003      	str	r0, [sp, #12]
			// Allocate message
			m_api_model_msg_ind_t *p_msg = ke_malloc(sizeof(m_api_model_msg_ind_t)+len, 0);
    57be:	0028      	movs	r0, r5
    57c0:	2100      	movs	r1, #0
    57c2:	300c      	adds	r0, #12
    57c4:	f001 fd8c 	bl	72e0 <ke_malloc>

			// Fill the message
			p_msg->model_lid   = model_lid;
			p_msg->app_key_lid = app_key_lid;
    57c8:	466b      	mov	r3, sp
    57ca:	7c1b      	ldrb	r3, [r3, #16]
		if(t->msg_deal_cb != NULL){
			// Retrieve buffer info
			uint16_t len     = bc_m_buf_data_len_get(p_buf);
			uint8_t* p_data  = bc_m_buf_data_get(p_buf);
			// Allocate message
			m_api_model_msg_ind_t *p_msg = ke_malloc(sizeof(m_api_model_msg_ind_t)+len, 0);
    57cc:	0004      	movs	r4, r0

			// Fill the message
			p_msg->model_lid   = model_lid;
			p_msg->app_key_lid = app_key_lid;
    57ce:	7043      	strb	r3, [r0, #1]
			p_msg->rssi        = rssi;
    57d0:	466b      	mov	r3, sp
    57d2:	7e1b      	ldrb	r3, [r3, #24]
			uint8_t* p_data  = bc_m_buf_data_get(p_buf);
			// Allocate message
			m_api_model_msg_ind_t *p_msg = ke_malloc(sizeof(m_api_model_msg_ind_t)+len, 0);

			// Fill the message
			p_msg->model_lid   = model_lid;
    57d4:	7007      	strb	r7, [r0, #0]
			p_msg->app_key_lid = app_key_lid;
			p_msg->rssi        = rssi;
    57d6:	7083      	strb	r3, [r0, #2]
			p_msg->not_relayed = not_relayed;
    57d8:	466b      	mov	r3, sp
    57da:	7f1b      	ldrb	r3, [r3, #28]
			p_msg->opcode      = opcode;
			p_msg->src         = src;
			p_msg->msg_len     = len;
    57dc:	8145      	strh	r5, [r0, #10]

			// Fill the message
			p_msg->model_lid   = model_lid;
			p_msg->app_key_lid = app_key_lid;
			p_msg->rssi        = rssi;
			p_msg->not_relayed = not_relayed;
    57de:	70c3      	strb	r3, [r0, #3]
			p_msg->opcode      = opcode;
    57e0:	9b02      	ldr	r3, [sp, #8]
			p_msg->src         = src;
			p_msg->msg_len     = len;
			memcpy(p_msg->msg, p_data, len);
    57e2:	002a      	movs	r2, r5
			// Fill the message
			p_msg->model_lid   = model_lid;
			p_msg->app_key_lid = app_key_lid;
			p_msg->rssi        = rssi;
			p_msg->not_relayed = not_relayed;
			p_msg->opcode      = opcode;
    57e4:	6043      	str	r3, [r0, #4]
			p_msg->src         = src;
    57e6:	466b      	mov	r3, sp
    57e8:	8a9b      	ldrh	r3, [r3, #20]
			p_msg->msg_len     = len;
			memcpy(p_msg->msg, p_data, len);
    57ea:	9903      	ldr	r1, [sp, #12]
			p_msg->model_lid   = model_lid;
			p_msg->app_key_lid = app_key_lid;
			p_msg->rssi        = rssi;
			p_msg->not_relayed = not_relayed;
			p_msg->opcode      = opcode;
			p_msg->src         = src;
    57ec:	8103      	strh	r3, [r0, #8]
			p_msg->msg_len     = len;
			memcpy(p_msg->msg, p_data, len);
    57ee:	300c      	adds	r0, #12
    57f0:	f010 f8ee 	bl	159d0 <memcpy>
			t->msg_deal_cb(p_msg);
    57f4:	0020      	movs	r0, r4
    57f6:	68f3      	ldr	r3, [r6, #12]
    57f8:	4798      	blx	r3
			ke_free(p_msg);
    57fa:	0020      	movs	r0, r4
    57fc:	f001 fd74 	bl	72e8 <ke_free>
		}
		break;
	}
}
    5800:	b009      	add	sp, #36	; 0x24
    5802:	bdf0      	pop	{r4, r5, r6, r7, pc}
    5804:	10010514 	.word	0x10010514
    5808:	0002093c 	.word	0x0002093c
    580c:	1001111c 	.word	0x1001111c

00005810 <_models_opcode_check_cb>:
 * @param[in] model_lid Model Local Identifier
 * @param[in] opcode    Operation code to check
 ****************************************************************************************
 */
__STATIC void _models_opcode_check_cb(m_lid_t model_lid, uint32_t opcode)
{
    5810:	b570      	push	{r4, r5, r6, lr}
	//M_PRINTF(L_APP, "model_lid[%x] opcode[0x%x]", model_lid, opcode);
	
	uint16_t status = M_ERR_NOT_SUPPORTED;
	for(int i = 0; i < uiModelCnt; ++i){
    5812:	2200      	movs	r2, #0
 * @param[in] model_lid Model Local Identifier
 * @param[in] opcode    Operation code to check
 ****************************************************************************************
 */
__STATIC void _models_opcode_check_cb(m_lid_t model_lid, uint32_t opcode)
{
    5814:	0004      	movs	r4, r0
	//M_PRINTF(L_APP, "model_lid[%x] opcode[0x%x]", model_lid, opcode);
	
	uint16_t status = M_ERR_NOT_SUPPORTED;
	for(int i = 0; i < uiModelCnt; ++i){
    5816:	4b0e      	ldr	r3, [pc, #56]	; (5850 <_models_opcode_check_cb+0x40>)
 * @param[in] model_lid Model Local Identifier
 * @param[in] opcode    Operation code to check
 ****************************************************************************************
 */
__STATIC void _models_opcode_check_cb(m_lid_t model_lid, uint32_t opcode)
{
    5818:	000d      	movs	r5, r1
	//M_PRINTF(L_APP, "model_lid[%x] opcode[0x%x]", model_lid, opcode);
	
	uint16_t status = M_ERR_NOT_SUPPORTED;
	for(int i = 0; i < uiModelCnt; ++i){
    581a:	7a19      	ldrb	r1, [r3, #8]
    581c:	685b      	ldr	r3, [r3, #4]
    581e:	428a      	cmp	r2, r1
    5820:	da0f      	bge.n	5842 <_models_opcode_check_cb+0x32>
		mesh_model_t* t = &pstModel_t[i];
    5822:	0018      	movs	r0, r3
    5824:	3310      	adds	r3, #16
		if(t->lid != model_lid)
    5826:	001e      	movs	r6, r3
    5828:	3e0b      	subs	r6, #11
    582a:	7836      	ldrb	r6, [r6, #0]
    582c:	42a6      	cmp	r6, r4
    582e:	d001      	beq.n	5834 <_models_opcode_check_cb+0x24>
__STATIC void _models_opcode_check_cb(m_lid_t model_lid, uint32_t opcode)
{
	//M_PRINTF(L_APP, "model_lid[%x] opcode[0x%x]", model_lid, opcode);
	
	uint16_t status = M_ERR_NOT_SUPPORTED;
	for(int i = 0; i < uiModelCnt; ++i){
    5830:	3201      	adds	r2, #1
    5832:	e7f4      	b.n	581e <_models_opcode_check_cb+0xe>
		mesh_model_t* t = &pstModel_t[i];
		if(t->lid != model_lid)
			continue;
		if(t->op_check_cb){
    5834:	6883      	ldr	r3, [r0, #8]
    5836:	2b00      	cmp	r3, #0
    5838:	d003      	beq.n	5842 <_models_opcode_check_cb+0x32>
			status = t->op_check_cb(opcode);
    583a:	0028      	movs	r0, r5
    583c:	4798      	blx	r3
    583e:	b282      	uxth	r2, r0
    5840:	e001      	b.n	5846 <_models_opcode_check_cb+0x36>
 */
__STATIC void _models_opcode_check_cb(m_lid_t model_lid, uint32_t opcode)
{
	//M_PRINTF(L_APP, "model_lid[%x] opcode[0x%x]", model_lid, opcode);
	
	uint16_t status = M_ERR_NOT_SUPPORTED;
    5842:	22a8      	movs	r2, #168	; 0xa8
    5844:	0112      	lsls	r2, r2, #4
			status = t->op_check_cb(opcode);
		}
		break;
	}
	//M_PRINTF(L_APP, "status[0x%x]", status);
	bc_m_model_opcode_status(model_lid, opcode, status);
    5846:	0029      	movs	r1, r5
    5848:	0020      	movs	r0, r4
    584a:	f003 fadb 	bl	8e04 <bc_m_model_opcode_status>
}
    584e:	bd70      	pop	{r4, r5, r6, pc}
    5850:	1001111c 	.word	0x1001111c

00005854 <_models_sent_cb>:
 * @param[in] status    Transmission status.
 ****************************************************************************************
 */
__STATIC void _models_sent_cb(m_lid_t model_lid, uint8_t tx_hdl, m_api_buf_t* p_buf, uint16_t status)
{
	M_PRINTF(L_APP, "model_lid[%x] tx_hdl[0x%x]", model_lid, tx_hdl);
    5854:	4b11      	ldr	r3, [pc, #68]	; (589c <_models_sent_cb+0x48>)
 * @param[in] p_buf     Pointer to the buffer containing the transmitted PDU. - Buffer must be released by model.
 * @param[in] status    Transmission status.
 ****************************************************************************************
 */
__STATIC void _models_sent_cb(m_lid_t model_lid, uint8_t tx_hdl, m_api_buf_t* p_buf, uint16_t status)
{
    5856:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	M_PRINTF(L_APP, "model_lid[%x] tx_hdl[0x%x]", model_lid, tx_hdl);
    5858:	681b      	ldr	r3, [r3, #0]
 * @param[in] p_buf     Pointer to the buffer containing the transmitted PDU. - Buffer must be released by model.
 * @param[in] status    Transmission status.
 ****************************************************************************************
 */
__STATIC void _models_sent_cb(m_lid_t model_lid, uint8_t tx_hdl, m_api_buf_t* p_buf, uint16_t status)
{
    585a:	0006      	movs	r6, r0
    585c:	000f      	movs	r7, r1
    585e:	0015      	movs	r5, r2
	M_PRINTF(L_APP, "model_lid[%x] tx_hdl[0x%x]", model_lid, tx_hdl);
    5860:	049b      	lsls	r3, r3, #18
    5862:	d516      	bpl.n	5892 <_models_sent_cb+0x3e>
    5864:	4c0e      	ldr	r4, [pc, #56]	; (58a0 <_models_sent_cb+0x4c>)
    5866:	0023      	movs	r3, r4
    5868:	0022      	movs	r2, r4
    586a:	0020      	movs	r0, r4
    586c:	3366      	adds	r3, #102	; 0x66
    586e:	3222      	adds	r2, #34	; 0x22
    5870:	9300      	str	r3, [sp, #0]
    5872:	0021      	movs	r1, r4
    5874:	2364      	movs	r3, #100	; 0x64
    5876:	302b      	adds	r0, #43	; 0x2b
    5878:	f7ff f898 	bl	49ac <m_print>
    587c:	0020      	movs	r0, r4
    587e:	0031      	movs	r1, r6
    5880:	3076      	adds	r0, #118	; 0x76
    5882:	003a      	movs	r2, r7
    5884:	f7ff f892 	bl	49ac <m_print>
    5888:	0020      	movs	r0, r4
    588a:	1da1      	adds	r1, r4, #6
    588c:	3063      	adds	r0, #99	; 0x63
    588e:	f7ff f88d 	bl	49ac <m_print>
	// release buffer
	bc_m_buf_release(p_buf);
    5892:	0028      	movs	r0, r5
    5894:	f003 fa8f 	bl	8db6 <bc_m_buf_release>
}
    5898:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
    589a:	46c0      	nop			; (mov r8, r8)
    589c:	10010514 	.word	0x10010514
    58a0:	0002093c 	.word	0x0002093c

000058a4 <_models_publish_period_cb>:
 * @param[in] opcode    Operation code to check
 ****************************************************************************************
 */
__STATIC void _models_publish_period_cb(m_lid_t model_lid, uint32_t period_ms)
{
	M_PRINTF(L_APP, "lid[%x] period_ms[%x]", model_lid, period_ms);
    58a4:	4b0f      	ldr	r3, [pc, #60]	; (58e4 <_models_publish_period_cb+0x40>)
 * @param[in] model_lid Model Local Identifier
 * @param[in] opcode    Operation code to check
 ****************************************************************************************
 */
__STATIC void _models_publish_period_cb(m_lid_t model_lid, uint32_t period_ms)
{
    58a6:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	M_PRINTF(L_APP, "lid[%x] period_ms[%x]", model_lid, period_ms);
    58a8:	681b      	ldr	r3, [r3, #0]
 * @param[in] model_lid Model Local Identifier
 * @param[in] opcode    Operation code to check
 ****************************************************************************************
 */
__STATIC void _models_publish_period_cb(m_lid_t model_lid, uint32_t period_ms)
{
    58aa:	0006      	movs	r6, r0
    58ac:	000f      	movs	r7, r1
	M_PRINTF(L_APP, "lid[%x] period_ms[%x]", model_lid, period_ms);
    58ae:	049b      	lsls	r3, r3, #18
    58b0:	d517      	bpl.n	58e2 <_models_publish_period_cb+0x3e>
    58b2:	4d0d      	ldr	r5, [pc, #52]	; (58e8 <_models_publish_period_cb+0x44>)
    58b4:	4c0d      	ldr	r4, [pc, #52]	; (58ec <_models_publish_period_cb+0x48>)
    58b6:	002b      	movs	r3, r5
    58b8:	0022      	movs	r2, r4
    58ba:	0020      	movs	r0, r4
    58bc:	3311      	adds	r3, #17
    58be:	3222      	adds	r2, #34	; 0x22
    58c0:	9300      	str	r3, [sp, #0]
    58c2:	0021      	movs	r1, r4
    58c4:	2375      	movs	r3, #117	; 0x75
    58c6:	302b      	adds	r0, #43	; 0x2b
    58c8:	f7ff f870 	bl	49ac <m_print>
    58cc:	0028      	movs	r0, r5
    58ce:	0031      	movs	r1, r6
    58d0:	302b      	adds	r0, #43	; 0x2b
    58d2:	003a      	movs	r2, r7
    58d4:	f7ff f86a 	bl	49ac <m_print>
    58d8:	0020      	movs	r0, r4
    58da:	1da1      	adds	r1, r4, #6
    58dc:	3063      	adds	r0, #99	; 0x63
    58de:	f7ff f865 	bl	49ac <m_print>
}
    58e2:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
    58e4:	10010514 	.word	0x10010514
    58e8:	000209bc 	.word	0x000209bc
    58ec:	0002093c 	.word	0x0002093c

000058f0 <bc_mm_register_models>:
	.cb_opcode_check   = _models_opcode_check_cb,
	.cb_publish_period = _models_publish_period_cb,
};

uint8_t bc_mm_register_models(mesh_model_t* model_t, uint8_t cnt)
{
    58f0:	b5f0      	push	{r4, r5, r6, r7, lr}
	if(pstModel_t != NULL || uiModelCnt != 0
    58f2:	4b27      	ldr	r3, [pc, #156]	; (5990 <bc_mm_register_models+0xa0>)
	.cb_opcode_check   = _models_opcode_check_cb,
	.cb_publish_period = _models_publish_period_cb,
};

uint8_t bc_mm_register_models(mesh_model_t* model_t, uint8_t cnt)
{
    58f4:	b085      	sub	sp, #20
	if(pstModel_t != NULL || uiModelCnt != 0
    58f6:	685a      	ldr	r2, [r3, #4]
    58f8:	2a00      	cmp	r2, #0
    58fa:	d001      	beq.n	5900 <bc_mm_register_models+0x10>
		|| model_t == NULL || cnt == 0)
		return 1;
    58fc:	2701      	movs	r7, #1
    58fe:	e043      	b.n	5988 <bc_mm_register_models+0x98>
	.cb_publish_period = _models_publish_period_cb,
};

uint8_t bc_mm_register_models(mesh_model_t* model_t, uint8_t cnt)
{
	if(pstModel_t != NULL || uiModelCnt != 0
    5900:	7a1f      	ldrb	r7, [r3, #8]
    5902:	2f00      	cmp	r7, #0
    5904:	d1fa      	bne.n	58fc <bc_mm_register_models+0xc>
		|| model_t == NULL || cnt == 0)
    5906:	2800      	cmp	r0, #0
    5908:	d0f8      	beq.n	58fc <bc_mm_register_models+0xc>
    590a:	2900      	cmp	r1, #0
    590c:	d0f6      	beq.n	58fc <bc_mm_register_models+0xc>
		return 1;
	
	pstModel_t = model_t;
	uiModelCnt = cnt;
	
	for(uint8_t i = 0; i < uiModelCnt; ++i){
    590e:	003e      	movs	r6, r7
{
	if(pstModel_t != NULL || uiModelCnt != 0
		|| model_t == NULL || cnt == 0)
		return 1;
	
	pstModel_t = model_t;
    5910:	6058      	str	r0, [r3, #4]
	uiModelCnt = cnt;
    5912:	7219      	strb	r1, [r3, #8]
	
	for(uint8_t i = 0; i < uiModelCnt; ++i){
    5914:	4a1e      	ldr	r2, [pc, #120]	; (5990 <bc_mm_register_models+0xa0>)
    5916:	7a13      	ldrb	r3, [r2, #8]
    5918:	42b3      	cmp	r3, r6
    591a:	d935      	bls.n	5988 <bc_mm_register_models+0x98>
		mesh_model_t* t = &pstModel_t[i];
    591c:	6854      	ldr	r4, [r2, #4]
    591e:	0133      	lsls	r3, r6, #4
    5920:	18e4      	adds	r4, r4, r3
		uint16_t status = bc_m_register_model(t->id, t->offset, t->vendor,
    5922:	79a2      	ldrb	r2, [r4, #6]
    5924:	4b1b      	ldr	r3, [pc, #108]	; (5994 <bc_mm_register_models+0xa4>)
    5926:	1e51      	subs	r1, r2, #1
    5928:	418a      	sbcs	r2, r1
										&_models_cb, &t->lid);
    592a:	1d60      	adds	r0, r4, #5
	pstModel_t = model_t;
	uiModelCnt = cnt;
	
	for(uint8_t i = 0; i < uiModelCnt; ++i){
		mesh_model_t* t = &pstModel_t[i];
		uint16_t status = bc_m_register_model(t->id, t->offset, t->vendor,
    592c:	7921      	ldrb	r1, [r4, #4]
    592e:	9000      	str	r0, [sp, #0]
    5930:	3344      	adds	r3, #68	; 0x44
    5932:	b2d2      	uxtb	r2, r2
    5934:	6820      	ldr	r0, [r4, #0]
    5936:	f003 fa69 	bl	8e0c <bc_m_register_model>
										&_models_cb, &t->lid);
		M_PRINTF(L_APP, "ID[%x] OFF[%x] VEN[%x] LID[%x]", t->id, t->offset, t->vendor, t->lid);
    593a:	2280      	movs	r2, #128	; 0x80
    593c:	4b16      	ldr	r3, [pc, #88]	; (5998 <bc_mm_register_models+0xa8>)
    593e:	0192      	lsls	r2, r2, #6
    5940:	681b      	ldr	r3, [r3, #0]
	pstModel_t = model_t;
	uiModelCnt = cnt;
	
	for(uint8_t i = 0; i < uiModelCnt; ++i){
		mesh_model_t* t = &pstModel_t[i];
		uint16_t status = bc_m_register_model(t->id, t->offset, t->vendor,
    5942:	9003      	str	r0, [sp, #12]
										&_models_cb, &t->lid);
		M_PRINTF(L_APP, "ID[%x] OFF[%x] VEN[%x] LID[%x]", t->id, t->offset, t->vendor, t->lid);
    5944:	4213      	tst	r3, r2
    5946:	d019      	beq.n	597c <bc_mm_register_models+0x8c>
    5948:	4d14      	ldr	r5, [pc, #80]	; (599c <bc_mm_register_models+0xac>)
    594a:	4b12      	ldr	r3, [pc, #72]	; (5994 <bc_mm_register_models+0xa4>)
    594c:	002a      	movs	r2, r5
    594e:	0028      	movs	r0, r5
    5950:	3354      	adds	r3, #84	; 0x54
    5952:	3222      	adds	r2, #34	; 0x22
    5954:	9300      	str	r3, [sp, #0]
    5956:	0029      	movs	r1, r5
    5958:	238d      	movs	r3, #141	; 0x8d
    595a:	302b      	adds	r0, #43	; 0x2b
    595c:	f7ff f826 	bl	49ac <m_print>
    5960:	7961      	ldrb	r1, [r4, #5]
    5962:	480c      	ldr	r0, [pc, #48]	; (5994 <bc_mm_register_models+0xa4>)
    5964:	79a3      	ldrb	r3, [r4, #6]
    5966:	7922      	ldrb	r2, [r4, #4]
    5968:	9100      	str	r1, [sp, #0]
    596a:	6821      	ldr	r1, [r4, #0]
    596c:	306a      	adds	r0, #106	; 0x6a
    596e:	f7ff f81d 	bl	49ac <m_print>
    5972:	0028      	movs	r0, r5
    5974:	1da9      	adds	r1, r5, #6
    5976:	3063      	adds	r0, #99	; 0x63
    5978:	f7ff f818 	bl	49ac <m_print>
		if(status != M_ERR_NO_ERROR){
    597c:	9b03      	ldr	r3, [sp, #12]
    597e:	2b00      	cmp	r3, #0
    5980:	d1bc      	bne.n	58fc <bc_mm_register_models+0xc>
		return 1;
	
	pstModel_t = model_t;
	uiModelCnt = cnt;
	
	for(uint8_t i = 0; i < uiModelCnt; ++i){
    5982:	3601      	adds	r6, #1
    5984:	b2f6      	uxtb	r6, r6
    5986:	e7c5      	b.n	5914 <bc_mm_register_models+0x24>
		if(status != M_ERR_NO_ERROR){
			return 1;
		}
	}
	return 0;
}
    5988:	0038      	movs	r0, r7
    598a:	b005      	add	sp, #20
    598c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    598e:	46c0      	nop			; (mov r8, r8)
    5990:	1001111c 	.word	0x1001111c
    5994:	000209bc 	.word	0x000209bc
    5998:	10010514 	.word	0x10010514
    599c:	0002093c 	.word	0x0002093c

000059a0 <bc_mm_cancel_models>:
uint8_t bc_mm_cancel_models(void)
{
	pstModel_t = NULL;
    59a0:	2000      	movs	r0, #0
    59a2:	4b02      	ldr	r3, [pc, #8]	; (59ac <bc_mm_cancel_models+0xc>)
    59a4:	6058      	str	r0, [r3, #4]
	uiModelCnt = 0;
    59a6:	7218      	strb	r0, [r3, #8]
	return 0;
}
    59a8:	4770      	bx	lr
    59aa:	46c0      	nop			; (mov r8, r8)
    59ac:	1001111c 	.word	0x1001111c

000059b0 <bc_mm_alis_set_onoff_status>:

//m_tb_timer_t mm_alis_timer;//delay timer
//static uint8_t tid = 0;

uint8_t bc_mm_alis_set_onoff_status(uint8_t* data, bool on)
{
    59b0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	m_printf_hex(L_APP, "1", data, 3);
    59b2:	4d0d      	ldr	r5, [pc, #52]	; (59e8 <bc_mm_alis_set_onoff_status+0x38>)
    59b4:	2680      	movs	r6, #128	; 0x80

//m_tb_timer_t mm_alis_timer;//delay timer
//static uint8_t tid = 0;

uint8_t bc_mm_alis_set_onoff_status(uint8_t* data, bool on)
{
    59b6:	000f      	movs	r7, r1
	m_printf_hex(L_APP, "1", data, 3);
    59b8:	0029      	movs	r1, r5
    59ba:	01b6      	lsls	r6, r6, #6

//m_tb_timer_t mm_alis_timer;//delay timer
//static uint8_t tid = 0;

uint8_t bc_mm_alis_set_onoff_status(uint8_t* data, bool on)
{
    59bc:	0004      	movs	r4, r0
	m_printf_hex(L_APP, "1", data, 3);
    59be:	0002      	movs	r2, r0
    59c0:	3109      	adds	r1, #9
    59c2:	0030      	movs	r0, r6
    59c4:	2303      	movs	r3, #3
    59c6:	f7ff f851 	bl	4a6c <m_printf_hex>
	data[0] = M_ATTR_ONOFF&0xff;
    59ca:	2300      	movs	r3, #0
	data[1] = (M_ATTR_ONOFF>>8)&0xff;
	data[2] = on;
	m_printf_hex(L_APP, "2", data, 3);
    59cc:	0029      	movs	r1, r5
//static uint8_t tid = 0;

uint8_t bc_mm_alis_set_onoff_status(uint8_t* data, bool on)
{
	m_printf_hex(L_APP, "1", data, 3);
	data[0] = M_ATTR_ONOFF&0xff;
    59ce:	7023      	strb	r3, [r4, #0]
	data[1] = (M_ATTR_ONOFF>>8)&0xff;
    59d0:	3301      	adds	r3, #1
    59d2:	7063      	strb	r3, [r4, #1]
	data[2] = on;
    59d4:	70a7      	strb	r7, [r4, #2]
	m_printf_hex(L_APP, "2", data, 3);
    59d6:	0030      	movs	r0, r6
    59d8:	310b      	adds	r1, #11
    59da:	3302      	adds	r3, #2
    59dc:	0022      	movs	r2, r4
    59de:	f7ff f845 	bl	4a6c <m_printf_hex>
	return 3;
}
    59e2:	2003      	movs	r0, #3
    59e4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    59e6:	46c0      	nop			; (mov r8, r8)
    59e8:	00020a45 	.word	0x00020a45

000059ec <bc_mm_alis_set_ltn_status>:

uint8_t bc_mm_alis_set_ltn_status(uint8_t* data, uint16_t ltn)
{
    59ec:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	m_printf_hex(L_APP, "1", data, 4);
    59ee:	4d0e      	ldr	r5, [pc, #56]	; (5a28 <bc_mm_alis_set_ltn_status+0x3c>)
    59f0:	2680      	movs	r6, #128	; 0x80
	m_printf_hex(L_APP, "2", data, 3);
	return 3;
}

uint8_t bc_mm_alis_set_ltn_status(uint8_t* data, uint16_t ltn)
{
    59f2:	000f      	movs	r7, r1
	m_printf_hex(L_APP, "1", data, 4);
    59f4:	0029      	movs	r1, r5
    59f6:	01b6      	lsls	r6, r6, #6
	m_printf_hex(L_APP, "2", data, 3);
	return 3;
}

uint8_t bc_mm_alis_set_ltn_status(uint8_t* data, uint16_t ltn)
{
    59f8:	0004      	movs	r4, r0
	m_printf_hex(L_APP, "1", data, 4);
    59fa:	0002      	movs	r2, r0
    59fc:	3109      	adds	r1, #9
    59fe:	0030      	movs	r0, r6
    5a00:	2304      	movs	r3, #4
    5a02:	f7ff f833 	bl	4a6c <m_printf_hex>
	data[0] = M_ATTR_LTN&0xff;
    5a06:	2321      	movs	r3, #33	; 0x21
	data[1] = (M_ATTR_LTN>>8);
	data[2] = ltn&0xff;
	data[3] = ltn>>8;
	m_printf_hex(L_APP, "2", data, 4);
    5a08:	0029      	movs	r1, r5
}

uint8_t bc_mm_alis_set_ltn_status(uint8_t* data, uint16_t ltn)
{
	m_printf_hex(L_APP, "1", data, 4);
	data[0] = M_ATTR_LTN&0xff;
    5a0a:	7023      	strb	r3, [r4, #0]
	data[1] = (M_ATTR_LTN>>8);
	data[2] = ltn&0xff;
    5a0c:	70a7      	strb	r7, [r4, #2]

uint8_t bc_mm_alis_set_ltn_status(uint8_t* data, uint16_t ltn)
{
	m_printf_hex(L_APP, "1", data, 4);
	data[0] = M_ATTR_LTN&0xff;
	data[1] = (M_ATTR_LTN>>8);
    5a0e:	3b20      	subs	r3, #32
	data[2] = ltn&0xff;
	data[3] = ltn>>8;
    5a10:	0a3f      	lsrs	r7, r7, #8

uint8_t bc_mm_alis_set_ltn_status(uint8_t* data, uint16_t ltn)
{
	m_printf_hex(L_APP, "1", data, 4);
	data[0] = M_ATTR_LTN&0xff;
	data[1] = (M_ATTR_LTN>>8);
    5a12:	7063      	strb	r3, [r4, #1]
	data[2] = ltn&0xff;
	data[3] = ltn>>8;
    5a14:	70e7      	strb	r7, [r4, #3]
	m_printf_hex(L_APP, "2", data, 4);
    5a16:	0030      	movs	r0, r6
    5a18:	310b      	adds	r1, #11
    5a1a:	3303      	adds	r3, #3
    5a1c:	0022      	movs	r2, r4
    5a1e:	f7ff f825 	bl	4a6c <m_printf_hex>
	return 4;
}
    5a22:	2004      	movs	r0, #4
    5a24:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    5a26:	46c0      	nop			; (mov r8, r8)
    5a28:	00020a45 	.word	0x00020a45

00005a2c <bc_mm_alis_set_tmp_status>:

uint8_t bc_mm_alis_set_tmp_status(uint8_t* data, uint16_t tmp)
{
    5a2c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	m_printf_hex(L_APP, "1", data, 4);
    5a2e:	4d0e      	ldr	r5, [pc, #56]	; (5a68 <bc_mm_alis_set_tmp_status+0x3c>)
    5a30:	2680      	movs	r6, #128	; 0x80
	m_printf_hex(L_APP, "2", data, 4);
	return 4;
}

uint8_t bc_mm_alis_set_tmp_status(uint8_t* data, uint16_t tmp)
{
    5a32:	000f      	movs	r7, r1
	m_printf_hex(L_APP, "1", data, 4);
    5a34:	0029      	movs	r1, r5
    5a36:	01b6      	lsls	r6, r6, #6
	m_printf_hex(L_APP, "2", data, 4);
	return 4;
}

uint8_t bc_mm_alis_set_tmp_status(uint8_t* data, uint16_t tmp)
{
    5a38:	0004      	movs	r4, r0
	m_printf_hex(L_APP, "1", data, 4);
    5a3a:	0002      	movs	r2, r0
    5a3c:	3109      	adds	r1, #9
    5a3e:	0030      	movs	r0, r6
    5a40:	2304      	movs	r3, #4
    5a42:	f7ff f813 	bl	4a6c <m_printf_hex>
	data[0] = M_ATTR_TEMP&0xff;
    5a46:	2322      	movs	r3, #34	; 0x22
	data[1] = (M_ATTR_TEMP>>8);
	data[2] = tmp&0xff;
	data[3] = tmp>>8;
	m_printf_hex(L_APP, "2", data, 4);
    5a48:	0029      	movs	r1, r5
}

uint8_t bc_mm_alis_set_tmp_status(uint8_t* data, uint16_t tmp)
{
	m_printf_hex(L_APP, "1", data, 4);
	data[0] = M_ATTR_TEMP&0xff;
    5a4a:	7023      	strb	r3, [r4, #0]
	data[1] = (M_ATTR_TEMP>>8);
	data[2] = tmp&0xff;
    5a4c:	70a7      	strb	r7, [r4, #2]

uint8_t bc_mm_alis_set_tmp_status(uint8_t* data, uint16_t tmp)
{
	m_printf_hex(L_APP, "1", data, 4);
	data[0] = M_ATTR_TEMP&0xff;
	data[1] = (M_ATTR_TEMP>>8);
    5a4e:	3b21      	subs	r3, #33	; 0x21
	data[2] = tmp&0xff;
	data[3] = tmp>>8;
    5a50:	0a3f      	lsrs	r7, r7, #8

uint8_t bc_mm_alis_set_tmp_status(uint8_t* data, uint16_t tmp)
{
	m_printf_hex(L_APP, "1", data, 4);
	data[0] = M_ATTR_TEMP&0xff;
	data[1] = (M_ATTR_TEMP>>8);
    5a52:	7063      	strb	r3, [r4, #1]
	data[2] = tmp&0xff;
	data[3] = tmp>>8;
    5a54:	70e7      	strb	r7, [r4, #3]
	m_printf_hex(L_APP, "2", data, 4);
    5a56:	0030      	movs	r0, r6
    5a58:	310b      	adds	r1, #11
    5a5a:	3303      	adds	r3, #3
    5a5c:	0022      	movs	r2, r4
    5a5e:	f7ff f805 	bl	4a6c <m_printf_hex>
	return 4;
}
    5a62:	2004      	movs	r0, #4
    5a64:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    5a66:	46c0      	nop			; (mov r8, r8)
    5a68:	00020a45 	.word	0x00020a45

00005a6c <bc_mm_alis_opcode_check>:


static uint32_t bc_mm_alis_opcode_check(uint32_t op)
{
	M_PRINTF(L_MODEL, "op[%x]", op);
    5a6c:	4b14      	ldr	r3, [pc, #80]	; (5ac0 <bc_mm_alis_opcode_check+0x54>)
	return 4;
}


static uint32_t bc_mm_alis_opcode_check(uint32_t op)
{
    5a6e:	b537      	push	{r0, r1, r2, r4, r5, lr}
	M_PRINTF(L_MODEL, "op[%x]", op);
    5a70:	681b      	ldr	r3, [r3, #0]
	return 4;
}


static uint32_t bc_mm_alis_opcode_check(uint32_t op)
{
    5a72:	0005      	movs	r5, r0
	M_PRINTF(L_MODEL, "op[%x]", op);
    5a74:	04db      	lsls	r3, r3, #19
    5a76:	d515      	bpl.n	5aa4 <bc_mm_alis_opcode_check+0x38>
    5a78:	4c12      	ldr	r4, [pc, #72]	; (5ac4 <bc_mm_alis_opcode_check+0x58>)
    5a7a:	0023      	movs	r3, r4
    5a7c:	0022      	movs	r2, r4
    5a7e:	0020      	movs	r0, r4
    5a80:	334b      	adds	r3, #75	; 0x4b
    5a82:	3232      	adds	r2, #50	; 0x32
    5a84:	9300      	str	r3, [sp, #0]
    5a86:	0021      	movs	r1, r4
    5a88:	2339      	movs	r3, #57	; 0x39
    5a8a:	303c      	adds	r0, #60	; 0x3c
    5a8c:	f7fe ff8e 	bl	49ac <m_print>
    5a90:	0020      	movs	r0, r4
    5a92:	0029      	movs	r1, r5
    5a94:	3063      	adds	r0, #99	; 0x63
    5a96:	f7fe ff89 	bl	49ac <m_print>
    5a9a:	0020      	movs	r0, r4
    5a9c:	1da1      	adds	r1, r4, #6
    5a9e:	306a      	adds	r0, #106	; 0x6a
    5aa0:	f7fe ff84 	bl	49ac <m_print>
	if((op>>8) != ALI_COMPANY_ID)
    5aa4:	22d4      	movs	r2, #212	; 0xd4
    5aa6:	0a2b      	lsrs	r3, r5, #8
    5aa8:	0052      	lsls	r2, r2, #1
		return 1;
    5aaa:	2001      	movs	r0, #1


static uint32_t bc_mm_alis_opcode_check(uint32_t op)
{
	M_PRINTF(L_MODEL, "op[%x]", op);
	if((op>>8) != ALI_COMPANY_ID)
    5aac:	4293      	cmp	r3, r2
    5aae:	d105      	bne.n	5abc <bc_mm_alis_opcode_check+0x50>
		return 1;
    5ab0:	3531      	adds	r5, #49	; 0x31
    5ab2:	3005      	adds	r0, #5
    5ab4:	b2ed      	uxtb	r5, r5
    5ab6:	42a8      	cmp	r0, r5
    5ab8:	41ad      	sbcs	r5, r5
    5aba:	4268      	negs	r0, r5
	if((MM_MSG_ALIS_ATTR_GET <= o && o <= MM_MSG_ALIS_ATTR_CONFIRMATION)
		||(o == MM_MSG_ALIS_ATTR_TRANSPARENT)){
		return 0;
	}
	return 1;
}
    5abc:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
    5abe:	46c0      	nop			; (mov r8, r8)
    5ac0:	10010514 	.word	0x10010514
    5ac4:	00020a45 	.word	0x00020a45

00005ac8 <bc_mm_recv_alis_msg>:

static void bc_mm_recv_alis_msg(m_api_model_msg_ind_t const *ind)
{
    5ac8:	b570      	push	{r4, r5, r6, lr}
	alis_model_t* model_t = NULL;
	m_printf_hex(L_MODEL, "alis_m_model_recv_alis_msg", ind->msg, ind->msg_len);
    5aca:	0005      	movs	r5, r0
    5acc:	8943      	ldrh	r3, [r0, #10]
	}
	return 1;
}

static void bc_mm_recv_alis_msg(m_api_model_msg_ind_t const *ind)
{
    5ace:	0004      	movs	r4, r0
	alis_model_t* model_t = NULL;
	m_printf_hex(L_MODEL, "alis_m_model_recv_alis_msg", ind->msg, ind->msg_len);
    5ad0:	2080      	movs	r0, #128	; 0x80
    5ad2:	4910      	ldr	r1, [pc, #64]	; (5b14 <bc_mm_recv_alis_msg+0x4c>)
    5ad4:	350c      	adds	r5, #12
    5ad6:	002a      	movs	r2, r5
    5ad8:	316d      	adds	r1, #109	; 0x6d
    5ada:	0140      	lsls	r0, r0, #5
    5adc:	f7fe ffc6 	bl	4a6c <m_printf_hex>
    5ae0:	2300      	movs	r3, #0
	return 1;
}

static void bc_mm_recv_alis_msg(m_api_model_msg_ind_t const *ind)
{
	alis_model_t* model_t = NULL;
    5ae2:	001a      	movs	r2, r3
	m_printf_hex(L_MODEL, "alis_m_model_recv_alis_msg", ind->msg, ind->msg_len);

	for(int i = 0; i < MAX_ELEMENTS_NUM; ++i){
		if(_alis_t[i].mm_alis_t != NULL && _alis_t[i].mm_alis_t->lid == ind->model_lid){
    5ae4:	490c      	ldr	r1, [pc, #48]	; (5b18 <bc_mm_recv_alis_msg+0x50>)
    5ae6:	5858      	ldr	r0, [r3, r1]
    5ae8:	2800      	cmp	r0, #0
    5aea:	d004      	beq.n	5af6 <bc_mm_recv_alis_msg+0x2e>
    5aec:	7946      	ldrb	r6, [r0, #5]
    5aee:	7820      	ldrb	r0, [r4, #0]
    5af0:	4286      	cmp	r6, r0
    5af2:	d100      	bne.n	5af6 <bc_mm_recv_alis_msg+0x2e>
    5af4:	18ca      	adds	r2, r1, r3
    5af6:	3330      	adds	r3, #48	; 0x30
static void bc_mm_recv_alis_msg(m_api_model_msg_ind_t const *ind)
{
	alis_model_t* model_t = NULL;
	m_printf_hex(L_MODEL, "alis_m_model_recv_alis_msg", ind->msg, ind->msg_len);

	for(int i = 0; i < MAX_ELEMENTS_NUM; ++i){
    5af8:	2bc0      	cmp	r3, #192	; 0xc0
    5afa:	d1f4      	bne.n	5ae6 <bc_mm_recv_alis_msg+0x1e>
		if(_alis_t[i].mm_alis_t != NULL && _alis_t[i].mm_alis_t->lid == ind->model_lid){
			model_t = &_alis_t[i];
		}
	} 
	if(model_t == NULL)
    5afc:	2a00      	cmp	r2, #0
    5afe:	d007      	beq.n	5b10 <bc_mm_recv_alis_msg+0x48>
		return ;
	
	if(model_t->ali_vendors_rx_cb == NULL)
    5b00:	6ad6      	ldr	r6, [r2, #44]	; 0x2c
    5b02:	2e00      	cmp	r6, #0
    5b04:	d004      	beq.n	5b10 <bc_mm_recv_alis_msg+0x48>
		return;
	model_t->ali_vendors_rx_cb(ind->model_lid, ind->opcode&0xff, ind->msg, ind->msg_len);
    5b06:	8963      	ldrh	r3, [r4, #10]
    5b08:	7921      	ldrb	r1, [r4, #4]
    5b0a:	7820      	ldrb	r0, [r4, #0]
    5b0c:	002a      	movs	r2, r5
    5b0e:	47b0      	blx	r6
}
    5b10:	bd70      	pop	{r4, r5, r6, pc}
    5b12:	46c0      	nop			; (mov r8, r8)
    5b14:	00020a45 	.word	0x00020a45
    5b18:	10011128 	.word	0x10011128

00005b1c <bc_mm_alis_send_indication>:

int  bc_mm_alis_send_indication(m_lid_t model_lid, uint8_t* data, int len)
{	
    5b1c:	2300      	movs	r3, #0
    5b1e:	b5f0      	push	{r4, r5, r6, r7, lr}
    5b20:	0016      	movs	r6, r2
	uint16_t sts;
	uint32_t opcode = (ALI_COMPANY_ID<<8) + MM_MSG_ALIS_ATTR_INDICATION;
	m_api_buf_t* p_buf;
	mesh_model_t* model_t = NULL;
    5b22:	001d      	movs	r5, r3
		return;
	model_t->ali_vendors_rx_cb(ind->model_lid, ind->opcode&0xff, ind->msg, ind->msg_len);
}

int  bc_mm_alis_send_indication(m_lid_t model_lid, uint8_t* data, int len)
{	
    5b24:	000f      	movs	r7, r1
	uint32_t opcode = (ALI_COMPANY_ID<<8) + MM_MSG_ALIS_ATTR_INDICATION;
	m_api_buf_t* p_buf;
	mesh_model_t* model_t = NULL;

	for(int i = 0; i < MAX_ELEMENTS_NUM; ++i){
		if(_alis_t[i].mm_alis_t != NULL && _alis_t[i].mm_alis_t->lid == model_lid){
    5b26:	4927      	ldr	r1, [pc, #156]	; (5bc4 <bc_mm_alis_send_indication+0xa8>)
		return;
	model_t->ali_vendors_rx_cb(ind->model_lid, ind->opcode&0xff, ind->msg, ind->msg_len);
}

int  bc_mm_alis_send_indication(m_lid_t model_lid, uint8_t* data, int len)
{	
    5b28:	b085      	sub	sp, #20
	uint32_t opcode = (ALI_COMPANY_ID<<8) + MM_MSG_ALIS_ATTR_INDICATION;
	m_api_buf_t* p_buf;
	mesh_model_t* model_t = NULL;

	for(int i = 0; i < MAX_ELEMENTS_NUM; ++i){
		if(_alis_t[i].mm_alis_t != NULL && _alis_t[i].mm_alis_t->lid == model_lid){
    5b2a:	585a      	ldr	r2, [r3, r1]
    5b2c:	2a00      	cmp	r2, #0
    5b2e:	d003      	beq.n	5b38 <bc_mm_alis_send_indication+0x1c>
    5b30:	7954      	ldrb	r4, [r2, #5]
    5b32:	4284      	cmp	r4, r0
    5b34:	d100      	bne.n	5b38 <bc_mm_alis_send_indication+0x1c>
    5b36:	0015      	movs	r5, r2
    5b38:	3330      	adds	r3, #48	; 0x30
	uint16_t sts;
	uint32_t opcode = (ALI_COMPANY_ID<<8) + MM_MSG_ALIS_ATTR_INDICATION;
	m_api_buf_t* p_buf;
	mesh_model_t* model_t = NULL;

	for(int i = 0; i < MAX_ELEMENTS_NUM; ++i){
    5b3a:	2bc0      	cmp	r3, #192	; 0xc0
    5b3c:	d1f5      	bne.n	5b2a <bc_mm_alis_send_indication+0xe>
		if(_alis_t[i].mm_alis_t != NULL && _alis_t[i].mm_alis_t->lid == model_lid){
			model_t = _alis_t[i].mm_alis_t;
		}
	}
	if(model_t == NULL){
		return 1;
    5b3e:	2401      	movs	r4, #1
	for(int i = 0; i < MAX_ELEMENTS_NUM; ++i){
		if(_alis_t[i].mm_alis_t != NULL && _alis_t[i].mm_alis_t->lid == model_lid){
			model_t = _alis_t[i].mm_alis_t;
		}
	}
	if(model_t == NULL){
    5b40:	2d00      	cmp	r5, #0
    5b42:	d03b      	beq.n	5bbc <bc_mm_alis_send_indication+0xa0>
		return 1;
	}
	// allocate a buffer for message
	sts = bc_m_buf_alloc(&p_buf, len+1);
    5b44:	1931      	adds	r1, r6, r4
    5b46:	b289      	uxth	r1, r1
    5b48:	a803      	add	r0, sp, #12
    5b4a:	f003 f92d 	bl	8da8 <bc_m_buf_alloc>

	uint8_t* tData = bc_m_buf_data_get(p_buf);
    5b4e:	9803      	ldr	r0, [sp, #12]
    5b50:	f003 f935 	bl	8dbe <bc_m_buf_data_get>
	tData[0] = 0;//tid;
    5b54:	2400      	movs	r4, #0
	memcpy(&tData[1], data, len);
    5b56:	0032      	movs	r2, r6
    5b58:	0039      	movs	r1, r7
	}
	// allocate a buffer for message
	sts = bc_m_buf_alloc(&p_buf, len+1);

	uint8_t* tData = bc_m_buf_data_get(p_buf);
	tData[0] = 0;//tid;
    5b5a:	7004      	strb	r4, [r0, #0]
	memcpy(&tData[1], data, len);
    5b5c:	3001      	adds	r0, #1
    5b5e:	f00f ff37 	bl	159d0 <memcpy>
	//0xD4,0xA8,0x01,0x00,0x00,0x01,0x00,
	sts =  bc_m_model_publish(model_t->lid, opcode, bc_mm_com_get_tx_hdl(), p_buf, 0);
    5b62:	796e      	ldrb	r6, [r5, #5]
    5b64:	f7ff fde0 	bl	5728 <bc_mm_com_get_tx_hdl>
    5b68:	9b03      	ldr	r3, [sp, #12]
    5b6a:	0002      	movs	r2, r0
    5b6c:	9400      	str	r4, [sp, #0]
    5b6e:	0030      	movs	r0, r6
    5b70:	4915      	ldr	r1, [pc, #84]	; (5bc8 <bc_mm_alis_send_indication+0xac>)
    5b72:	f003 f92e 	bl	8dd2 <bc_m_model_publish>
	M_PRINTF(L_APP, "mm_alis_t->lid[%x] sts[%x]", model_t->lid, sts);
    5b76:	4b15      	ldr	r3, [pc, #84]	; (5bcc <bc_mm_alis_send_indication+0xb0>)

	uint8_t* tData = bc_m_buf_data_get(p_buf);
	tData[0] = 0;//tid;
	memcpy(&tData[1], data, len);
	//0xD4,0xA8,0x01,0x00,0x00,0x01,0x00,
	sts =  bc_m_model_publish(model_t->lid, opcode, bc_mm_com_get_tx_hdl(), p_buf, 0);
    5b78:	0006      	movs	r6, r0
	M_PRINTF(L_APP, "mm_alis_t->lid[%x] sts[%x]", model_t->lid, sts);
    5b7a:	681b      	ldr	r3, [r3, #0]
    5b7c:	049b      	lsls	r3, r3, #18
    5b7e:	d517      	bpl.n	5bb0 <bc_mm_alis_send_indication+0x94>
    5b80:	4f13      	ldr	r7, [pc, #76]	; (5bd0 <bc_mm_alis_send_indication+0xb4>)
    5b82:	4c14      	ldr	r4, [pc, #80]	; (5bd4 <bc_mm_alis_send_indication+0xb8>)
    5b84:	003b      	movs	r3, r7
    5b86:	0022      	movs	r2, r4
    5b88:	0020      	movs	r0, r4
    5b8a:	3308      	adds	r3, #8
    5b8c:	3232      	adds	r2, #50	; 0x32
    5b8e:	9300      	str	r3, [sp, #0]
    5b90:	0021      	movs	r1, r4
    5b92:	236d      	movs	r3, #109	; 0x6d
    5b94:	303c      	adds	r0, #60	; 0x3c
    5b96:	f7fe ff09 	bl	49ac <m_print>
    5b9a:	0038      	movs	r0, r7
    5b9c:	7969      	ldrb	r1, [r5, #5]
    5b9e:	3023      	adds	r0, #35	; 0x23
    5ba0:	0032      	movs	r2, r6
    5ba2:	f7fe ff03 	bl	49ac <m_print>
    5ba6:	0020      	movs	r0, r4
    5ba8:	1da1      	adds	r1, r4, #6
    5baa:	306a      	adds	r0, #106	; 0x6a
    5bac:	f7fe fefe 	bl	49ac <m_print>
	if(sts != M_ERR_NO_ERROR){
		bc_m_buf_release(p_buf);
	}
	return 0;
    5bb0:	2400      	movs	r4, #0
	tData[0] = 0;//tid;
	memcpy(&tData[1], data, len);
	//0xD4,0xA8,0x01,0x00,0x00,0x01,0x00,
	sts =  bc_m_model_publish(model_t->lid, opcode, bc_mm_com_get_tx_hdl(), p_buf, 0);
	M_PRINTF(L_APP, "mm_alis_t->lid[%x] sts[%x]", model_t->lid, sts);
	if(sts != M_ERR_NO_ERROR){
    5bb2:	42a6      	cmp	r6, r4
    5bb4:	d002      	beq.n	5bbc <bc_mm_alis_send_indication+0xa0>
		bc_m_buf_release(p_buf);
    5bb6:	9803      	ldr	r0, [sp, #12]
    5bb8:	f003 f8fd 	bl	8db6 <bc_m_buf_release>
	}
	return 0;
}
    5bbc:	0020      	movs	r0, r4
    5bbe:	b005      	add	sp, #20
    5bc0:	bdf0      	pop	{r4, r5, r6, r7, pc}
    5bc2:	46c0      	nop			; (mov r8, r8)
    5bc4:	10011128 	.word	0x10011128
    5bc8:	0001a8d4 	.word	0x0001a8d4
    5bcc:	10010514 	.word	0x10010514
    5bd0:	00020ac5 	.word	0x00020ac5
    5bd4:	00020a45 	.word	0x00020a45

00005bd8 <bc_mm_ali_vendor_send>:
int  bc_mm_ali_vendor_send(m_lid_t model_lid, uint8_t opcode, uint8_t* data, uint16_t len)
{	
    5bd8:	b5f0      	push	{r4, r5, r6, r7, lr}
    5bda:	001e      	movs	r6, r3
	uint16_t sts;
	uint32_t _uiOpcode = (ALI_COMPANY_ID<<8) + opcode;
    5bdc:	23d4      	movs	r3, #212	; 0xd4
    5bde:	025b      	lsls	r3, r3, #9
    5be0:	18cb      	adds	r3, r1, r3
		bc_m_buf_release(p_buf);
	}
	return 0;
}
int  bc_mm_ali_vendor_send(m_lid_t model_lid, uint8_t opcode, uint8_t* data, uint16_t len)
{	
    5be2:	b087      	sub	sp, #28
	uint16_t sts;
	uint32_t _uiOpcode = (ALI_COMPANY_ID<<8) + opcode;
    5be4:	9303      	str	r3, [sp, #12]
    5be6:	2300      	movs	r3, #0
		bc_m_buf_release(p_buf);
	}
	return 0;
}
int  bc_mm_ali_vendor_send(m_lid_t model_lid, uint8_t opcode, uint8_t* data, uint16_t len)
{	
    5be8:	0017      	movs	r7, r2
	uint16_t sts;
	uint32_t _uiOpcode = (ALI_COMPANY_ID<<8) + opcode;
	m_api_buf_t* p_buf;
	mesh_model_t* model_t = NULL;
    5bea:	001c      	movs	r4, r3

	for(int i = 0; i < MAX_ELEMENTS_NUM; ++i){
		if(_alis_t[i].mm_alis_t != NULL && _alis_t[i].mm_alis_t->lid == model_lid){
    5bec:	4924      	ldr	r1, [pc, #144]	; (5c80 <bc_mm_ali_vendor_send+0xa8>)
    5bee:	585a      	ldr	r2, [r3, r1]
    5bf0:	2a00      	cmp	r2, #0
    5bf2:	d003      	beq.n	5bfc <bc_mm_ali_vendor_send+0x24>
    5bf4:	7955      	ldrb	r5, [r2, #5]
    5bf6:	4285      	cmp	r5, r0
    5bf8:	d100      	bne.n	5bfc <bc_mm_ali_vendor_send+0x24>
    5bfa:	0014      	movs	r4, r2
    5bfc:	3330      	adds	r3, #48	; 0x30
	uint16_t sts;
	uint32_t _uiOpcode = (ALI_COMPANY_ID<<8) + opcode;
	m_api_buf_t* p_buf;
	mesh_model_t* model_t = NULL;

	for(int i = 0; i < MAX_ELEMENTS_NUM; ++i){
    5bfe:	2bc0      	cmp	r3, #192	; 0xc0
    5c00:	d1f5      	bne.n	5bee <bc_mm_ali_vendor_send+0x16>
		if(_alis_t[i].mm_alis_t != NULL && _alis_t[i].mm_alis_t->lid == model_lid){
			model_t = _alis_t[i].mm_alis_t;
		}
	}
	if(model_t == NULL){
		return 1;
    5c02:	2501      	movs	r5, #1
	for(int i = 0; i < MAX_ELEMENTS_NUM; ++i){
		if(_alis_t[i].mm_alis_t != NULL && _alis_t[i].mm_alis_t->lid == model_lid){
			model_t = _alis_t[i].mm_alis_t;
		}
	}
	if(model_t == NULL){
    5c04:	2c00      	cmp	r4, #0
    5c06:	d038      	beq.n	5c7a <bc_mm_ali_vendor_send+0xa2>
		return 1;
	}
	// allocate a buffer for message
	sts = bc_m_buf_alloc(&p_buf, len);
    5c08:	0031      	movs	r1, r6
    5c0a:	a805      	add	r0, sp, #20
    5c0c:	f003 f8cc 	bl	8da8 <bc_m_buf_alloc>

	uint8_t* tData = bc_m_buf_data_get(p_buf);
    5c10:	9805      	ldr	r0, [sp, #20]
    5c12:	f003 f8d4 	bl	8dbe <bc_m_buf_data_get>
	memcpy(tData, data, len);
    5c16:	0032      	movs	r2, r6
    5c18:	0039      	movs	r1, r7
    5c1a:	f00f fed9 	bl	159d0 <memcpy>

	sts =  bc_m_model_publish(model_t->lid, _uiOpcode, bc_mm_com_get_tx_hdl(), p_buf, 0);
    5c1e:	7965      	ldrb	r5, [r4, #5]
    5c20:	f7ff fd82 	bl	5728 <bc_mm_com_get_tx_hdl>
    5c24:	2300      	movs	r3, #0
    5c26:	0002      	movs	r2, r0
    5c28:	9300      	str	r3, [sp, #0]
    5c2a:	9903      	ldr	r1, [sp, #12]
    5c2c:	9b05      	ldr	r3, [sp, #20]
    5c2e:	0028      	movs	r0, r5
    5c30:	f003 f8cf 	bl	8dd2 <bc_m_model_publish>
	M_PRINTF(L_APP, "mm_alis_t->lid[%x] sts[%x]", model_t->lid, sts);
    5c34:	4b13      	ldr	r3, [pc, #76]	; (5c84 <bc_mm_ali_vendor_send+0xac>)
	sts = bc_m_buf_alloc(&p_buf, len);

	uint8_t* tData = bc_m_buf_data_get(p_buf);
	memcpy(tData, data, len);

	sts =  bc_m_model_publish(model_t->lid, _uiOpcode, bc_mm_com_get_tx_hdl(), p_buf, 0);
    5c36:	0006      	movs	r6, r0
	M_PRINTF(L_APP, "mm_alis_t->lid[%x] sts[%x]", model_t->lid, sts);
    5c38:	681b      	ldr	r3, [r3, #0]
    5c3a:	049b      	lsls	r3, r3, #18
    5c3c:	d517      	bpl.n	5c6e <bc_mm_ali_vendor_send+0x96>
    5c3e:	4f12      	ldr	r7, [pc, #72]	; (5c88 <bc_mm_ali_vendor_send+0xb0>)
    5c40:	4d12      	ldr	r5, [pc, #72]	; (5c8c <bc_mm_ali_vendor_send+0xb4>)
    5c42:	003b      	movs	r3, r7
    5c44:	002a      	movs	r2, r5
    5c46:	0028      	movs	r0, r5
    5c48:	333e      	adds	r3, #62	; 0x3e
    5c4a:	3232      	adds	r2, #50	; 0x32
    5c4c:	9300      	str	r3, [sp, #0]
    5c4e:	0029      	movs	r1, r5
    5c50:	2389      	movs	r3, #137	; 0x89
    5c52:	303c      	adds	r0, #60	; 0x3c
    5c54:	f7fe feaa 	bl	49ac <m_print>
    5c58:	0038      	movs	r0, r7
    5c5a:	7961      	ldrb	r1, [r4, #5]
    5c5c:	3023      	adds	r0, #35	; 0x23
    5c5e:	0032      	movs	r2, r6
    5c60:	f7fe fea4 	bl	49ac <m_print>
    5c64:	0028      	movs	r0, r5
    5c66:	1da9      	adds	r1, r5, #6
    5c68:	306a      	adds	r0, #106	; 0x6a
    5c6a:	f7fe fe9f 	bl	49ac <m_print>
	if(sts != M_ERR_NO_ERROR){
		bc_m_buf_release(p_buf);
	}
	return 0;
    5c6e:	2500      	movs	r5, #0
	uint8_t* tData = bc_m_buf_data_get(p_buf);
	memcpy(tData, data, len);

	sts =  bc_m_model_publish(model_t->lid, _uiOpcode, bc_mm_com_get_tx_hdl(), p_buf, 0);
	M_PRINTF(L_APP, "mm_alis_t->lid[%x] sts[%x]", model_t->lid, sts);
	if(sts != M_ERR_NO_ERROR){
    5c70:	42ae      	cmp	r6, r5
    5c72:	d002      	beq.n	5c7a <bc_mm_ali_vendor_send+0xa2>
		bc_m_buf_release(p_buf);
    5c74:	9805      	ldr	r0, [sp, #20]
    5c76:	f003 f89e 	bl	8db6 <bc_m_buf_release>
	}
	return 0;
}
    5c7a:	0028      	movs	r0, r5
    5c7c:	b007      	add	sp, #28
    5c7e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    5c80:	10011128 	.word	0x10011128
    5c84:	10010514 	.word	0x10010514
    5c88:	00020ac5 	.word	0x00020ac5
    5c8c:	00020a45 	.word	0x00020a45

00005c90 <bc_mm_alis_get_random_time>:

uint16_t bc_mm_alis_get_random_time(void)
{
    5c90:	b573      	push	{r0, r1, r4, r5, r6, lr}
	srand(mesh_timer_get_time());
    5c92:	f000 fb4b 	bl	632c <mesh_timer_get_time>
    5c96:	f00f ff85 	bl	15ba4 <srand>
	//[1024,5*1024]ms
	uint16_t t = (rand()%4096)+1024;
    5c9a:	f00f ff8d 	bl	15bb8 <rand>
    5c9e:	4b14      	ldr	r3, [pc, #80]	; (5cf0 <bc_mm_alis_get_random_time+0x60>)
    5ca0:	4018      	ands	r0, r3
    5ca2:	d503      	bpl.n	5cac <bc_mm_alis_get_random_time+0x1c>
    5ca4:	4b13      	ldr	r3, [pc, #76]	; (5cf4 <bc_mm_alis_get_random_time+0x64>)
    5ca6:	3801      	subs	r0, #1
    5ca8:	4318      	orrs	r0, r3
    5caa:	3001      	adds	r0, #1
    5cac:	2380      	movs	r3, #128	; 0x80
    5cae:	00db      	lsls	r3, r3, #3
    5cb0:	18c0      	adds	r0, r0, r3
	M_PRINTF(L_APP, "t[%x]", t);
    5cb2:	4b11      	ldr	r3, [pc, #68]	; (5cf8 <bc_mm_alis_get_random_time+0x68>)

uint16_t bc_mm_alis_get_random_time(void)
{
	srand(mesh_timer_get_time());
	//[1024,5*1024]ms
	uint16_t t = (rand()%4096)+1024;
    5cb4:	b284      	uxth	r4, r0
	M_PRINTF(L_APP, "t[%x]", t);
    5cb6:	681b      	ldr	r3, [r3, #0]
    5cb8:	049b      	lsls	r3, r3, #18
    5cba:	d516      	bpl.n	5cea <bc_mm_alis_get_random_time+0x5a>
    5cbc:	4e0f      	ldr	r6, [pc, #60]	; (5cfc <bc_mm_alis_get_random_time+0x6c>)
    5cbe:	4d10      	ldr	r5, [pc, #64]	; (5d00 <bc_mm_alis_get_random_time+0x70>)
    5cc0:	0033      	movs	r3, r6
    5cc2:	002a      	movs	r2, r5
    5cc4:	0028      	movs	r0, r5
    5cc6:	3354      	adds	r3, #84	; 0x54
    5cc8:	3232      	adds	r2, #50	; 0x32
    5cca:	9300      	str	r3, [sp, #0]
    5ccc:	0029      	movs	r1, r5
    5cce:	2395      	movs	r3, #149	; 0x95
    5cd0:	303c      	adds	r0, #60	; 0x3c
    5cd2:	f7fe fe6b 	bl	49ac <m_print>
    5cd6:	0030      	movs	r0, r6
    5cd8:	0021      	movs	r1, r4
    5cda:	306f      	adds	r0, #111	; 0x6f
    5cdc:	f7fe fe66 	bl	49ac <m_print>
    5ce0:	0028      	movs	r0, r5
    5ce2:	1da9      	adds	r1, r5, #6
    5ce4:	306a      	adds	r0, #106	; 0x6a
    5ce6:	f7fe fe61 	bl	49ac <m_print>
	return t;
}
    5cea:	0020      	movs	r0, r4
    5cec:	bd76      	pop	{r1, r2, r4, r5, r6, pc}
    5cee:	46c0      	nop			; (mov r8, r8)
    5cf0:	80000fff 	.word	0x80000fff
    5cf4:	fffff000 	.word	0xfffff000
    5cf8:	10010514 	.word	0x10010514
    5cfc:	00020ac5 	.word	0x00020ac5
    5d00:	00020a45 	.word	0x00020a45

00005d04 <bc_mm_alis_vendor_init>:

int bc_mm_alis_vendor_init(mesh_model_t* mdl, bc_mm_ali_vendor_rx_cb rc_cb)
{
    5d04:	0003      	movs	r3, r0
    5d06:	b530      	push	{r4, r5, lr}
	//memset(mdl, 0, sizeof(mesh_model_t));
	if(mdl == NULL || mdl->offset >= MAX_ELEMENTS_NUM){//param check
		return 1;
    5d08:	2001      	movs	r0, #1
}

int bc_mm_alis_vendor_init(mesh_model_t* mdl, bc_mm_ali_vendor_rx_cb rc_cb)
{
	//memset(mdl, 0, sizeof(mesh_model_t));
	if(mdl == NULL || mdl->offset >= MAX_ELEMENTS_NUM){//param check
    5d0a:	2b00      	cmp	r3, #0
    5d0c:	d015      	beq.n	5d3a <bc_mm_alis_vendor_init+0x36>
    5d0e:	791a      	ldrb	r2, [r3, #4]
    5d10:	2a03      	cmp	r2, #3
    5d12:	d812      	bhi.n	5d3a <bc_mm_alis_vendor_init+0x36>
		return 1;
	}

	if(_alis_t[mdl->offset].mm_alis_t != NULL){//not init status check
    5d14:	2430      	movs	r4, #48	; 0x30
    5d16:	4362      	muls	r2, r4
    5d18:	4d08      	ldr	r5, [pc, #32]	; (5d3c <bc_mm_alis_vendor_init+0x38>)
    5d1a:	5954      	ldr	r4, [r2, r5]
    5d1c:	2c00      	cmp	r4, #0
    5d1e:	d10c      	bne.n	5d3a <bc_mm_alis_vendor_init+0x36>
		return 1;
	}
	_alis_t[mdl->offset].mm_alis_t = mdl;
    5d20:	5153      	str	r3, [r2, r5]
	_alis_t[mdl->offset].ali_vendors_rx_cb = rc_cb;
    5d22:	18aa      	adds	r2, r5, r2
    5d24:	62d1      	str	r1, [r2, #44]	; 0x2c

	mdl->vendor = 1;
	mdl->lid = 0;
	
	mdl->id = M_ALIS_MODEL_SID;   //vendor model
    5d26:	22d4      	movs	r2, #212	; 0xd4
		return 1;
	}
	_alis_t[mdl->offset].mm_alis_t = mdl;
	_alis_t[mdl->offset].ali_vendors_rx_cb = rc_cb;

	mdl->vendor = 1;
    5d28:	7198      	strb	r0, [r3, #6]
	
	mdl->id = M_ALIS_MODEL_SID;   //vendor model
    mdl->op_check_cb = bc_mm_alis_opcode_check;
    mdl->msg_deal_cb = bc_mm_recv_alis_msg;

	return 0;
    5d2a:	0020      	movs	r0, r4
	_alis_t[mdl->offset].ali_vendors_rx_cb = rc_cb;

	mdl->vendor = 1;
	mdl->lid = 0;
	
	mdl->id = M_ALIS_MODEL_SID;   //vendor model
    5d2c:	0452      	lsls	r2, r2, #17
    5d2e:	601a      	str	r2, [r3, #0]
    mdl->op_check_cb = bc_mm_alis_opcode_check;
    5d30:	4a03      	ldr	r2, [pc, #12]	; (5d40 <bc_mm_alis_vendor_init+0x3c>)
	}
	_alis_t[mdl->offset].mm_alis_t = mdl;
	_alis_t[mdl->offset].ali_vendors_rx_cb = rc_cb;

	mdl->vendor = 1;
	mdl->lid = 0;
    5d32:	715c      	strb	r4, [r3, #5]
	
	mdl->id = M_ALIS_MODEL_SID;   //vendor model
    mdl->op_check_cb = bc_mm_alis_opcode_check;
    5d34:	609a      	str	r2, [r3, #8]
    mdl->msg_deal_cb = bc_mm_recv_alis_msg;
    5d36:	4a03      	ldr	r2, [pc, #12]	; (5d44 <bc_mm_alis_vendor_init+0x40>)
    5d38:	60da      	str	r2, [r3, #12]

	return 0;
}
    5d3a:	bd30      	pop	{r4, r5, pc}
    5d3c:	10011128 	.word	0x10011128
    5d40:	00005a6d 	.word	0x00005a6d
    5d44:	00005ac9 	.word	0x00005ac9

00005d48 <bc_mm_alis_vendor_deinit>:
int bc_mm_alis_vendor_deinit(mesh_model_t* mdl)
{
	if(mdl != NULL || mdl->offset >= MAX_ELEMENTS_NUM){//param check
    5d48:	2800      	cmp	r0, #0
    5d4a:	d101      	bne.n	5d50 <bc_mm_alis_vendor_deinit+0x8>
    5d4c:	7903      	ldrb	r3, [r0, #4]
    5d4e:	deff      	udf	#255	; 0xff
		return 1;
	}

	_alis_t[mdl->offset].mm_alis_t = NULL;
	return 0;
}
    5d50:	2001      	movs	r0, #1
    5d52:	4770      	bx	lr

00005d54 <bc_mm_gen_onoff_opcode_check>:

static gens_oo_s _gens_oo_s[MAX_ELEMENTS_NUM];

static uint32_t bc_mm_gen_onoff_opcode_check(uint32_t op)
{
	M_PRINTF(L_APP, "opcode = %08x", op);
    5d54:	4b11      	ldr	r3, [pc, #68]	; (5d9c <bc_mm_gen_onoff_opcode_check+0x48>)
}gens_oo_s;

static gens_oo_s _gens_oo_s[MAX_ELEMENTS_NUM];

static uint32_t bc_mm_gen_onoff_opcode_check(uint32_t op)
{
    5d56:	b537      	push	{r0, r1, r2, r4, r5, lr}
	M_PRINTF(L_APP, "opcode = %08x", op);
    5d58:	681b      	ldr	r3, [r3, #0]
}gens_oo_s;

static gens_oo_s _gens_oo_s[MAX_ELEMENTS_NUM];

static uint32_t bc_mm_gen_onoff_opcode_check(uint32_t op)
{
    5d5a:	0005      	movs	r5, r0
	M_PRINTF(L_APP, "opcode = %08x", op);
    5d5c:	049b      	lsls	r3, r3, #18
    5d5e:	d511      	bpl.n	5d84 <bc_mm_gen_onoff_opcode_check+0x30>
    5d60:	4c0f      	ldr	r4, [pc, #60]	; (5da0 <bc_mm_gen_onoff_opcode_check+0x4c>)
    5d62:	4a10      	ldr	r2, [pc, #64]	; (5da4 <bc_mm_gen_onoff_opcode_check+0x50>)
    5d64:	1da3      	adds	r3, r4, #6
    5d66:	9300      	str	r3, [sp, #0]
    5d68:	0021      	movs	r1, r4
    5d6a:	230e      	movs	r3, #14
    5d6c:	480e      	ldr	r0, [pc, #56]	; (5da8 <bc_mm_gen_onoff_opcode_check+0x54>)
    5d6e:	f7fe fe1d 	bl	49ac <m_print>
    5d72:	0029      	movs	r1, r5
    5d74:	480d      	ldr	r0, [pc, #52]	; (5dac <bc_mm_gen_onoff_opcode_check+0x58>)
    5d76:	f7fe fe19 	bl	49ac <m_print>
    5d7a:	0021      	movs	r1, r4
    5d7c:	480c      	ldr	r0, [pc, #48]	; (5db0 <bc_mm_gen_onoff_opcode_check+0x5c>)
    5d7e:	3123      	adds	r1, #35	; 0x23
    5d80:	f7fe fe14 	bl	49ac <m_print>
	if((op == MM_MSG_GEN_OO_SET)
    5d84:	4b0b      	ldr	r3, [pc, #44]	; (5db4 <bc_mm_gen_onoff_opcode_check+0x60>)
		|| (op == MM_MSG_GEN_OO_GET)
		||(op == MM_MSG_GEN_OO_SET_UNACK)){
		return 0;
    5d86:	2000      	movs	r0, #0
static gens_oo_s _gens_oo_s[MAX_ELEMENTS_NUM];

static uint32_t bc_mm_gen_onoff_opcode_check(uint32_t op)
{
	M_PRINTF(L_APP, "opcode = %08x", op);
	if((op == MM_MSG_GEN_OO_SET)
    5d88:	429d      	cmp	r5, r3
    5d8a:	d005      	beq.n	5d98 <bc_mm_gen_onoff_opcode_check+0x44>
		|| (op == MM_MSG_GEN_OO_GET)
		||(op == MM_MSG_GEN_OO_SET_UNACK)){
		return 0;
    5d8c:	480a      	ldr	r0, [pc, #40]	; (5db8 <bc_mm_gen_onoff_opcode_check+0x64>)
    5d8e:	4028      	ands	r0, r5
    5d90:	3883      	subs	r0, #131	; 0x83
    5d92:	38ff      	subs	r0, #255	; 0xff
    5d94:	1e43      	subs	r3, r0, #1
    5d96:	4198      	sbcs	r0, r3
	}
	return 1;
}
    5d98:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
    5d9a:	46c0      	nop			; (mov r8, r8)
    5d9c:	10010514 	.word	0x10010514
    5da0:	00020b3a 	.word	0x00020b3a
    5da4:	00020b9b 	.word	0x00020b9b
    5da8:	00020bab 	.word	0x00020bab
    5dac:	00020bba 	.word	0x00020bba
    5db0:	00020bc8 	.word	0x00020bc8
    5db4:	00000282 	.word	0x00000282
    5db8:	fffffdff 	.word	0xfffffdff

00005dbc <bc_mm_recv_gen_onoff_msg>:

static void bc_mm_recv_gen_onoff_msg(m_api_model_msg_ind_t const *ind)
{
    5dbc:	b5f0      	push	{r4, r5, r6, r7, lr}
	gens_oo_s* gens_s = NULL;
	
	M_PRINTF(L_APP, "opcode = 0x%08x ind->model_lid = %x", ind->opcode, ind->model_lid);
    5dbe:	4b47      	ldr	r3, [pc, #284]	; (5edc <bc_mm_recv_gen_onoff_msg+0x120>)
	}
	return 1;
}

static void bc_mm_recv_gen_onoff_msg(m_api_model_msg_ind_t const *ind)
{
    5dc0:	b089      	sub	sp, #36	; 0x24
	gens_oo_s* gens_s = NULL;
	
	M_PRINTF(L_APP, "opcode = 0x%08x ind->model_lid = %x", ind->opcode, ind->model_lid);
    5dc2:	681a      	ldr	r2, [r3, #0]
	}
	return 1;
}

static void bc_mm_recv_gen_onoff_msg(m_api_model_msg_ind_t const *ind)
{
    5dc4:	0004      	movs	r4, r0
    5dc6:	9305      	str	r3, [sp, #20]
	gens_oo_s* gens_s = NULL;
	
	M_PRINTF(L_APP, "opcode = 0x%08x ind->model_lid = %x", ind->opcode, ind->model_lid);
    5dc8:	0493      	lsls	r3, r2, #18
    5dca:	d513      	bpl.n	5df4 <bc_mm_recv_gen_onoff_msg+0x38>
    5dcc:	4d44      	ldr	r5, [pc, #272]	; (5ee0 <bc_mm_recv_gen_onoff_msg+0x124>)
    5dce:	4a45      	ldr	r2, [pc, #276]	; (5ee4 <bc_mm_recv_gen_onoff_msg+0x128>)
    5dd0:	002b      	movs	r3, r5
    5dd2:	3326      	adds	r3, #38	; 0x26
    5dd4:	9300      	str	r3, [sp, #0]
    5dd6:	0029      	movs	r1, r5
    5dd8:	231b      	movs	r3, #27
    5dda:	4843      	ldr	r0, [pc, #268]	; (5ee8 <bc_mm_recv_gen_onoff_msg+0x12c>)
    5ddc:	f7fe fde6 	bl	49ac <m_print>
    5de0:	6861      	ldr	r1, [r4, #4]
    5de2:	7822      	ldrb	r2, [r4, #0]
    5de4:	4841      	ldr	r0, [pc, #260]	; (5eec <bc_mm_recv_gen_onoff_msg+0x130>)
    5de6:	f7fe fde1 	bl	49ac <m_print>
    5dea:	0029      	movs	r1, r5
    5dec:	4840      	ldr	r0, [pc, #256]	; (5ef0 <bc_mm_recv_gen_onoff_msg+0x134>)
    5dee:	3123      	adds	r1, #35	; 0x23
    5df0:	f7fe fddc 	bl	49ac <m_print>
	}
	return 1;
}

static void bc_mm_recv_gen_onoff_msg(m_api_model_msg_ind_t const *ind)
{
    5df4:	2300      	movs	r3, #0
	gens_oo_s* gens_s = NULL;
    5df6:	001d      	movs	r5, r3
	
	M_PRINTF(L_APP, "opcode = 0x%08x ind->model_lid = %x", ind->opcode, ind->model_lid);
	for(int i = 0; i < MAX_ELEMENTS_NUM; ++i){
		if(_gens_oo_s[i].bc_mm_gens_t != NULL &&
    5df8:	4a3e      	ldr	r2, [pc, #248]	; (5ef4 <bc_mm_recv_gen_onoff_msg+0x138>)
    5dfa:	5899      	ldr	r1, [r3, r2]
    5dfc:	2900      	cmp	r1, #0
    5dfe:	d004      	beq.n	5e0a <bc_mm_recv_gen_onoff_msg+0x4e>
    5e00:	7948      	ldrb	r0, [r1, #5]
    5e02:	7821      	ldrb	r1, [r4, #0]
    5e04:	4288      	cmp	r0, r1
    5e06:	d100      	bne.n	5e0a <bc_mm_recv_gen_onoff_msg+0x4e>
    5e08:	18d5      	adds	r5, r2, r3
    5e0a:	3308      	adds	r3, #8
static void bc_mm_recv_gen_onoff_msg(m_api_model_msg_ind_t const *ind)
{
	gens_oo_s* gens_s = NULL;
	
	M_PRINTF(L_APP, "opcode = 0x%08x ind->model_lid = %x", ind->opcode, ind->model_lid);
	for(int i = 0; i < MAX_ELEMENTS_NUM; ++i){
    5e0c:	2b20      	cmp	r3, #32
    5e0e:	d1f4      	bne.n	5dfa <bc_mm_recv_gen_onoff_msg+0x3e>
		if(_gens_oo_s[i].bc_mm_gens_t != NULL &&
			_gens_oo_s[i].bc_mm_gens_t->lid == ind->model_lid){
			gens_s = &_gens_oo_s[i];
		}
	}
	if(gens_s == NULL)
    5e10:	2d00      	cmp	r5, #0
    5e12:	d061      	beq.n	5ed8 <bc_mm_recv_gen_onoff_msg+0x11c>
		return;

	switch(ind->opcode){
    5e14:	6863      	ldr	r3, [r4, #4]
    5e16:	4a38      	ldr	r2, [pc, #224]	; (5ef8 <bc_mm_recv_gen_onoff_msg+0x13c>)
    5e18:	4e38      	ldr	r6, [pc, #224]	; (5efc <bc_mm_recv_gen_onoff_msg+0x140>)
    5e1a:	4293      	cmp	r3, r2
    5e1c:	d006      	beq.n	5e2c <bc_mm_recv_gen_onoff_msg+0x70>
    5e1e:	42b3      	cmp	r3, r6
    5e20:	d004      	beq.n	5e2c <bc_mm_recv_gen_onoff_msg+0x70>
    5e22:	3a01      	subs	r2, #1
    5e24:	3aff      	subs	r2, #255	; 0xff
    5e26:	4293      	cmp	r3, r2
    5e28:	d156      	bne.n	5ed8 <bc_mm_recv_gen_onoff_msg+0x11c>
    5e2a:	e014      	b.n	5e56 <bc_mm_recv_gen_onoff_msg+0x9a>
	case MM_MSG_GEN_OO_SET:
	case MM_MSG_GEN_OO_SET_UNACK:{
		m_printf_hex(L_APP, "bc_mm_recv_gen_onoff_msg", ind->msg, ind->msg_len);
    5e2c:	0022      	movs	r2, r4
    5e2e:	2080      	movs	r0, #128	; 0x80
    5e30:	8963      	ldrh	r3, [r4, #10]
    5e32:	320c      	adds	r2, #12
    5e34:	4932      	ldr	r1, [pc, #200]	; (5f00 <bc_mm_recv_gen_onoff_msg+0x144>)
    5e36:	0180      	lsls	r0, r0, #6
    5e38:	f7fe fe18 	bl	4a6c <m_printf_hex>
		gen_oo_set_t *onoff_set = (gen_oo_set_t *)ind->msg;
		if(emmTid != onoff_set->tid){
    5e3c:	4b31      	ldr	r3, [pc, #196]	; (5f04 <bc_mm_recv_gen_onoff_msg+0x148>)
    5e3e:	7b62      	ldrb	r2, [r4, #13]
    5e40:	7819      	ldrb	r1, [r3, #0]
    5e42:	4291      	cmp	r1, r2
    5e44:	d004      	beq.n	5e50 <bc_mm_recv_gen_onoff_msg+0x94>
			emmTid = onoff_set->tid;
    5e46:	701a      	strb	r2, [r3, #0]
			gens_s->oo_ctrl->set(onoff_set->onoff);
    5e48:	686b      	ldr	r3, [r5, #4]
    5e4a:	7b20      	ldrb	r0, [r4, #12]
    5e4c:	681b      	ldr	r3, [r3, #0]
    5e4e:	4798      	blx	r3
		}
		
		if(ind->opcode == MM_MSG_GEN_OO_SET_UNACK){//needn't ack
    5e50:	6863      	ldr	r3, [r4, #4]
    5e52:	42b3      	cmp	r3, r6
    5e54:	d040      	beq.n	5ed8 <bc_mm_recv_gen_onoff_msg+0x11c>
		}
	}
	case MM_MSG_GEN_OO_GET:{
		m_api_buf_t* p_buf;
		// allocate a buffer for message
		uint16_t sts = bc_m_buf_alloc(&p_buf, sizeof(gen_oo_status_t));
    5e56:	2103      	movs	r1, #3
    5e58:	a807      	add	r0, sp, #28
    5e5a:	f002 ffa5 	bl	8da8 <bc_m_buf_alloc>
    5e5e:	0006      	movs	r6, r0
		gen_oo_status_t* pstOoSts = (gen_oo_status_t*)bc_m_buf_data_get(p_buf);
    5e60:	9807      	ldr	r0, [sp, #28]
    5e62:	f002 ffac 	bl	8dbe <bc_m_buf_data_get>
		//send status
		pstOoSts->present_onoff = gens_s->oo_ctrl->get();
    5e66:	686b      	ldr	r3, [r5, #4]
	}
	case MM_MSG_GEN_OO_GET:{
		m_api_buf_t* p_buf;
		// allocate a buffer for message
		uint16_t sts = bc_m_buf_alloc(&p_buf, sizeof(gen_oo_status_t));
		gen_oo_status_t* pstOoSts = (gen_oo_status_t*)bc_m_buf_data_get(p_buf);
    5e68:	0007      	movs	r7, r0
		//send status
		pstOoSts->present_onoff = gens_s->oo_ctrl->get();
    5e6a:	685b      	ldr	r3, [r3, #4]
    5e6c:	4798      	blx	r3
    5e6e:	7038      	strb	r0, [r7, #0]
		pstOoSts->target_onoff = gens_s->oo_ctrl->get();
    5e70:	686b      	ldr	r3, [r5, #4]
    5e72:	685b      	ldr	r3, [r3, #4]
    5e74:	4798      	blx	r3
		pstOoSts->remain = 0;
    5e76:	2300      	movs	r3, #0
		// allocate a buffer for message
		uint16_t sts = bc_m_buf_alloc(&p_buf, sizeof(gen_oo_status_t));
		gen_oo_status_t* pstOoSts = (gen_oo_status_t*)bc_m_buf_data_get(p_buf);
		//send status
		pstOoSts->present_onoff = gens_s->oo_ctrl->get();
		pstOoSts->target_onoff = gens_s->oo_ctrl->get();
    5e78:	7078      	strb	r0, [r7, #1]
		pstOoSts->remain = 0;
    5e7a:	70bb      	strb	r3, [r7, #2]

		if(sts == M_ERR_NO_ERROR){
    5e7c:	429e      	cmp	r6, r3
    5e7e:	d12b      	bne.n	5ed8 <bc_mm_recv_gen_onoff_msg+0x11c>
			// request message response to be send
			sts = bc_m_model_rsp_send(ind->model_lid, MM_MSG_GEN_OO_STATUS, 
    5e80:	7825      	ldrb	r5, [r4, #0]
    5e82:	f7ff fc51 	bl	5728 <bc_mm_com_get_tx_hdl>
    5e86:	9603      	str	r6, [sp, #12]
    5e88:	9602      	str	r6, [sp, #8]
    5e8a:	8923      	ldrh	r3, [r4, #8]
    5e8c:	0002      	movs	r2, r0
    5e8e:	9301      	str	r3, [sp, #4]
    5e90:	7863      	ldrb	r3, [r4, #1]
    5e92:	0028      	movs	r0, r5
    5e94:	9300      	str	r3, [sp, #0]
    5e96:	491c      	ldr	r1, [pc, #112]	; (5f08 <bc_mm_recv_gen_onoff_msg+0x14c>)
    5e98:	9b07      	ldr	r3, [sp, #28]
    5e9a:	f002 ffa1 	bl	8de0 <bc_m_model_rsp_send>
										bc_mm_com_get_tx_hdl(), p_buf,
										ind->app_key_lid, ind->src, 0, 0);
			M_PRINTF(L_AL, "sts[%x]", sts);
    5e9e:	9b05      	ldr	r3, [sp, #20]
		pstOoSts->target_onoff = gens_s->oo_ctrl->get();
		pstOoSts->remain = 0;

		if(sts == M_ERR_NO_ERROR){
			// request message response to be send
			sts = bc_m_model_rsp_send(ind->model_lid, MM_MSG_GEN_OO_STATUS, 
    5ea0:	0005      	movs	r5, r0
										bc_mm_com_get_tx_hdl(), p_buf,
										ind->app_key_lid, ind->src, 0, 0);
			M_PRINTF(L_AL, "sts[%x]", sts);
    5ea2:	681b      	ldr	r3, [r3, #0]
    5ea4:	07db      	lsls	r3, r3, #31
    5ea6:	d512      	bpl.n	5ece <bc_mm_recv_gen_onoff_msg+0x112>
    5ea8:	4c0d      	ldr	r4, [pc, #52]	; (5ee0 <bc_mm_recv_gen_onoff_msg+0x124>)
    5eaa:	4a0e      	ldr	r2, [pc, #56]	; (5ee4 <bc_mm_recv_gen_onoff_msg+0x128>)
    5eac:	0023      	movs	r3, r4
    5eae:	3326      	adds	r3, #38	; 0x26
    5eb0:	9300      	str	r3, [sp, #0]
    5eb2:	0021      	movs	r1, r4
    5eb4:	2342      	movs	r3, #66	; 0x42
    5eb6:	480c      	ldr	r0, [pc, #48]	; (5ee8 <bc_mm_recv_gen_onoff_msg+0x12c>)
    5eb8:	f7fe fd78 	bl	49ac <m_print>
    5ebc:	0029      	movs	r1, r5
    5ebe:	4813      	ldr	r0, [pc, #76]	; (5f0c <bc_mm_recv_gen_onoff_msg+0x150>)
    5ec0:	f7fe fd74 	bl	49ac <m_print>
    5ec4:	0021      	movs	r1, r4
    5ec6:	480a      	ldr	r0, [pc, #40]	; (5ef0 <bc_mm_recv_gen_onoff_msg+0x134>)
    5ec8:	3123      	adds	r1, #35	; 0x23
    5eca:	f7fe fd6f 	bl	49ac <m_print>
			// an error occurs, release the buffer
			if(sts != M_ERR_NO_ERROR){
    5ece:	2d00      	cmp	r5, #0
    5ed0:	d002      	beq.n	5ed8 <bc_mm_recv_gen_onoff_msg+0x11c>
				bc_m_buf_release(p_buf);
    5ed2:	9807      	ldr	r0, [sp, #28]
    5ed4:	f002 ff6f 	bl	8db6 <bc_m_buf_release>
			}
		}
	}break;
	default:{return ;}break;
	}
}
    5ed8:	b009      	add	sp, #36	; 0x24
    5eda:	bdf0      	pop	{r4, r5, r6, r7, pc}
    5edc:	10010514 	.word	0x10010514
    5ee0:	00020b3a 	.word	0x00020b3a
    5ee4:	00020b9b 	.word	0x00020b9b
    5ee8:	00020bab 	.word	0x00020bab
    5eec:	00020bcb 	.word	0x00020bcb
    5ef0:	00020bc8 	.word	0x00020bc8
    5ef4:	100111e8 	.word	0x100111e8
    5ef8:	00000282 	.word	0x00000282
    5efc:	00000382 	.word	0x00000382
    5f00:	00020bef 	.word	0x00020bef
    5f04:	10011125 	.word	0x10011125
    5f08:	00000482 	.word	0x00000482
    5f0c:	00020c08 	.word	0x00020c08

00005f10 <bc_mm_gens_oo_init>:

int bc_mm_gens_oo_init(mesh_model_t* mdl, onff_ctrl_t* ctrl)
{
    5f10:	0003      	movs	r3, r0
    5f12:	b530      	push	{r4, r5, lr}
	//memset(mdl, 0, sizeof(mesh_model_t));
	if(mdl == NULL || mdl->offset >= MAX_ELEMENTS_NUM){//param check
		return 1;
    5f14:	2001      	movs	r0, #1
}

int bc_mm_gens_oo_init(mesh_model_t* mdl, onff_ctrl_t* ctrl)
{
	//memset(mdl, 0, sizeof(mesh_model_t));
	if(mdl == NULL || mdl->offset >= MAX_ELEMENTS_NUM){//param check
    5f16:	2b00      	cmp	r3, #0
    5f18:	d014      	beq.n	5f44 <bc_mm_gens_oo_init+0x34>
    5f1a:	791a      	ldrb	r2, [r3, #4]
    5f1c:	2a03      	cmp	r2, #3
    5f1e:	d811      	bhi.n	5f44 <bc_mm_gens_oo_init+0x34>
		return 1;
	}

	if(_gens_oo_s[mdl->offset].bc_mm_gens_t != NULL){//not init status check
    5f20:	4d09      	ldr	r5, [pc, #36]	; (5f48 <bc_mm_gens_oo_init+0x38>)
    5f22:	00d2      	lsls	r2, r2, #3
    5f24:	5954      	ldr	r4, [r2, r5]
    5f26:	2c00      	cmp	r4, #0
    5f28:	d10c      	bne.n	5f44 <bc_mm_gens_oo_init+0x34>
		return 1;
	}
	_gens_oo_s[mdl->offset].bc_mm_gens_t = mdl;
    5f2a:	5153      	str	r3, [r2, r5]
	_gens_oo_s[mdl->offset].oo_ctrl = ctrl;
    5f2c:	18aa      	adds	r2, r5, r2
    5f2e:	6051      	str	r1, [r2, #4]
	

	mdl->vendor = 0;
	mdl->lid = 0;
	
	mdl->id = MM_ID_GENS_OO;   //Generic OnOff
    5f30:	2280      	movs	r2, #128	; 0x80
    mdl->op_check_cb = bc_mm_gen_onoff_opcode_check;//
    mdl->msg_deal_cb = bc_mm_recv_gen_onoff_msg;//
    
	return 0;
    5f32:	0020      	movs	r0, r4
	

	mdl->vendor = 0;
	mdl->lid = 0;
	
	mdl->id = MM_ID_GENS_OO;   //Generic OnOff
    5f34:	0152      	lsls	r2, r2, #5
    5f36:	601a      	str	r2, [r3, #0]
    mdl->op_check_cb = bc_mm_gen_onoff_opcode_check;//
    5f38:	4a04      	ldr	r2, [pc, #16]	; (5f4c <bc_mm_gens_oo_init+0x3c>)
	}
	_gens_oo_s[mdl->offset].bc_mm_gens_t = mdl;
	_gens_oo_s[mdl->offset].oo_ctrl = ctrl;
	

	mdl->vendor = 0;
    5f3a:	719c      	strb	r4, [r3, #6]
	mdl->lid = 0;
	
	mdl->id = MM_ID_GENS_OO;   //Generic OnOff
    mdl->op_check_cb = bc_mm_gen_onoff_opcode_check;//
    5f3c:	609a      	str	r2, [r3, #8]
    mdl->msg_deal_cb = bc_mm_recv_gen_onoff_msg;//
    5f3e:	4a04      	ldr	r2, [pc, #16]	; (5f50 <bc_mm_gens_oo_init+0x40>)
	_gens_oo_s[mdl->offset].bc_mm_gens_t = mdl;
	_gens_oo_s[mdl->offset].oo_ctrl = ctrl;
	

	mdl->vendor = 0;
	mdl->lid = 0;
    5f40:	715c      	strb	r4, [r3, #5]
	
	mdl->id = MM_ID_GENS_OO;   //Generic OnOff
    mdl->op_check_cb = bc_mm_gen_onoff_opcode_check;//
    mdl->msg_deal_cb = bc_mm_recv_gen_onoff_msg;//
    5f42:	60da      	str	r2, [r3, #12]
    
	return 0;
}
    5f44:	bd30      	pop	{r4, r5, pc}
    5f46:	46c0      	nop			; (mov r8, r8)
    5f48:	100111e8 	.word	0x100111e8
    5f4c:	00005d55 	.word	0x00005d55
    5f50:	00005dbd 	.word	0x00005dbd

00005f54 <bc_mm_gens_oo_deinit>:
int bc_mm_gens_oo_deinit(mesh_model_t* mdl)
{
	if(mdl != NULL || mdl->offset >= MAX_ELEMENTS_NUM){//param check
    5f54:	2800      	cmp	r0, #0
    5f56:	d101      	bne.n	5f5c <bc_mm_gens_oo_deinit+0x8>
    5f58:	7903      	ldrb	r3, [r0, #4]
    5f5a:	deff      	udf	#255	; 0xff
	}

	_gens_oo_s[mdl->offset].bc_mm_gens_t = NULL;
	_gens_oo_s[mdl->offset].oo_ctrl = NULL;
	return 1;
}
    5f5c:	2001      	movs	r0, #1
    5f5e:	4770      	bx	lr

00005f60 <bc_mm_lightness_opcode_check>:
static light_ln_ctrl_t* p_light_ln_ctrl;


static uint32_t bc_mm_lightness_opcode_check(uint32_t op)
{
	M_PRINTF(L_APP, "opcode = %08x", op);
    5f60:	4b13      	ldr	r3, [pc, #76]	; (5fb0 <bc_mm_lightness_opcode_check+0x50>)
mesh_model_t* bc_mm_light_ln_t;
static light_ln_ctrl_t* p_light_ln_ctrl;


static uint32_t bc_mm_lightness_opcode_check(uint32_t op)
{
    5f62:	b537      	push	{r0, r1, r2, r4, r5, lr}
	M_PRINTF(L_APP, "opcode = %08x", op);
    5f64:	681b      	ldr	r3, [r3, #0]
mesh_model_t* bc_mm_light_ln_t;
static light_ln_ctrl_t* p_light_ln_ctrl;


static uint32_t bc_mm_lightness_opcode_check(uint32_t op)
{
    5f66:	0005      	movs	r5, r0
	M_PRINTF(L_APP, "opcode = %08x", op);
    5f68:	049b      	lsls	r3, r3, #18
    5f6a:	d515      	bpl.n	5f98 <bc_mm_lightness_opcode_check+0x38>
    5f6c:	4c11      	ldr	r4, [pc, #68]	; (5fb4 <bc_mm_lightness_opcode_check+0x54>)
    5f6e:	0023      	movs	r3, r4
    5f70:	0022      	movs	r2, r4
    5f72:	0020      	movs	r0, r4
    5f74:	3350      	adds	r3, #80	; 0x50
    5f76:	322f      	adds	r2, #47	; 0x2f
    5f78:	9300      	str	r3, [sp, #0]
    5f7a:	0021      	movs	r1, r4
    5f7c:	230c      	movs	r3, #12
    5f7e:	3041      	adds	r0, #65	; 0x41
    5f80:	f7fe fd14 	bl	49ac <m_print>
    5f84:	0020      	movs	r0, r4
    5f86:	0029      	movs	r1, r5
    5f88:	306d      	adds	r0, #109	; 0x6d
    5f8a:	f7fe fd0f 	bl	49ac <m_print>
    5f8e:	0020      	movs	r0, r4
    5f90:	1da1      	adds	r1, r4, #6
    5f92:	307b      	adds	r0, #123	; 0x7b
    5f94:	f7fe fd0a 	bl	49ac <m_print>
	if((op == MM_MSG_LIGHT_LN_SET)
    5f98:	4b07      	ldr	r3, [pc, #28]	; (5fb8 <bc_mm_lightness_opcode_check+0x58>)
    5f9a:	4a08      	ldr	r2, [pc, #32]	; (5fbc <bc_mm_lightness_opcode_check+0x5c>)
    5f9c:	402b      	ands	r3, r5
		|| (op == MM_MSG_LIGHT_LN_GET)
		|| (op == MM_MSG_LIGHT_LN_SET_UNACK)){
		return 0;
    5f9e:	2000      	movs	r0, #0


static uint32_t bc_mm_lightness_opcode_check(uint32_t op)
{
	M_PRINTF(L_APP, "opcode = %08x", op);
	if((op == MM_MSG_LIGHT_LN_SET)
    5fa0:	4293      	cmp	r3, r2
    5fa2:	d004      	beq.n	5fae <bc_mm_lightness_opcode_check+0x4e>
		|| (op == MM_MSG_LIGHT_LN_GET)
		|| (op == MM_MSG_LIGHT_LN_SET_UNACK)){
		return 0;
    5fa4:	4b06      	ldr	r3, [pc, #24]	; (5fc0 <bc_mm_lightness_opcode_check+0x60>)
    5fa6:	18ed      	adds	r5, r5, r3
    5fa8:	0028      	movs	r0, r5
    5faa:	1e43      	subs	r3, r0, #1
    5fac:	4198      	sbcs	r0, r3
	}
	return 1;
}
    5fae:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
    5fb0:	10010514 	.word	0x10010514
    5fb4:	00020c10 	.word	0x00020c10
    5fb8:	fffffeff 	.word	0xfffffeff
    5fbc:	00004c82 	.word	0x00004c82
    5fc0:	ffffb47e 	.word	0xffffb47e

00005fc4 <bc_mm_recv_lightness_msg>:

static void bc_mm_recv_lightness_msg(m_api_model_msg_ind_t const *ind)
{
    5fc4:	b5f0      	push	{r4, r5, r6, r7, lr}
	uint16_t sts;
    light_ln_set_t *lightness_set;
 
    lightness_set = (light_ln_set_t *)ind->msg;
    M_PRINTF(L_APP, "level[%x] TID[%x]", lightness_set->level, lightness_set->tid);
    5fc6:	4b30      	ldr	r3, [pc, #192]	; (6088 <bc_mm_recv_lightness_msg+0xc4>)
	}
	return 1;
}

static void bc_mm_recv_lightness_msg(m_api_model_msg_ind_t const *ind)
{
    5fc8:	b087      	sub	sp, #28
	uint16_t sts;
    light_ln_set_t *lightness_set;
 
    lightness_set = (light_ln_set_t *)ind->msg;
    M_PRINTF(L_APP, "level[%x] TID[%x]", lightness_set->level, lightness_set->tid);
    5fca:	681b      	ldr	r3, [r3, #0]
	}
	return 1;
}

static void bc_mm_recv_lightness_msg(m_api_model_msg_ind_t const *ind)
{
    5fcc:	0004      	movs	r4, r0
	uint16_t sts;
    light_ln_set_t *lightness_set;
 
    lightness_set = (light_ln_set_t *)ind->msg;
    M_PRINTF(L_APP, "level[%x] TID[%x]", lightness_set->level, lightness_set->tid);
    5fce:	049b      	lsls	r3, r3, #18
    5fd0:	d519      	bpl.n	6006 <bc_mm_recv_lightness_msg+0x42>
    5fd2:	4d2e      	ldr	r5, [pc, #184]	; (608c <bc_mm_recv_lightness_msg+0xc8>)
    5fd4:	002b      	movs	r3, r5
    5fd6:	002a      	movs	r2, r5
    5fd8:	0028      	movs	r0, r5
    5fda:	337e      	adds	r3, #126	; 0x7e
    5fdc:	322f      	adds	r2, #47	; 0x2f
    5fde:	9300      	str	r3, [sp, #0]
    5fe0:	0029      	movs	r1, r5
    5fe2:	231b      	movs	r3, #27
    5fe4:	3041      	adds	r0, #65	; 0x41
    5fe6:	f7fe fce1 	bl	49ac <m_print>
    5fea:	7b61      	ldrb	r1, [r4, #13]
    5fec:	7b23      	ldrb	r3, [r4, #12]
    5fee:	4828      	ldr	r0, [pc, #160]	; (6090 <bc_mm_recv_lightness_msg+0xcc>)
    5ff0:	0209      	lsls	r1, r1, #8
    5ff2:	4319      	orrs	r1, r3
    5ff4:	7ba2      	ldrb	r2, [r4, #14]
    5ff6:	3017      	adds	r0, #23
    5ff8:	f7fe fcd8 	bl	49ac <m_print>
    5ffc:	0028      	movs	r0, r5
    5ffe:	1da9      	adds	r1, r5, #6
    6000:	307b      	adds	r0, #123	; 0x7b
    6002:	f7fe fcd3 	bl	49ac <m_print>
	if(lightness_set->tid != emmTid){
    6006:	4b23      	ldr	r3, [pc, #140]	; (6094 <bc_mm_recv_lightness_msg+0xd0>)
    6008:	7ba2      	ldrb	r2, [r4, #14]
    600a:	7819      	ldrb	r1, [r3, #0]
    600c:	4291      	cmp	r1, r2
    600e:	d008      	beq.n	6022 <bc_mm_recv_lightness_msg+0x5e>
		emmTid = lightness_set->tid;
		p_light_ln_ctrl->set(lightness_set->level);
    6010:	7b60      	ldrb	r0, [r4, #13]
    light_ln_set_t *lightness_set;
 
    lightness_set = (light_ln_set_t *)ind->msg;
    M_PRINTF(L_APP, "level[%x] TID[%x]", lightness_set->level, lightness_set->tid);
	if(lightness_set->tid != emmTid){
		emmTid = lightness_set->tid;
    6012:	701a      	strb	r2, [r3, #0]
		p_light_ln_ctrl->set(lightness_set->level);
    6014:	7b23      	ldrb	r3, [r4, #12]
    6016:	0200      	lsls	r0, r0, #8
    6018:	4318      	orrs	r0, r3
    601a:	4b1f      	ldr	r3, [pc, #124]	; (6098 <bc_mm_recv_lightness_msg+0xd4>)
    601c:	681b      	ldr	r3, [r3, #0]
    601e:	681b      	ldr	r3, [r3, #0]
    6020:	4798      	blx	r3
	}
	if(ind->opcode != MM_MSG_LIGHT_LN_SET)
    6022:	4b1e      	ldr	r3, [pc, #120]	; (609c <bc_mm_recv_lightness_msg+0xd8>)
    6024:	6862      	ldr	r2, [r4, #4]
    6026:	429a      	cmp	r2, r3
    6028:	d12c      	bne.n	6084 <bc_mm_recv_lightness_msg+0xc0>
		return;
	light_ln_status_t tmp;
	tmp.current_level = p_light_ln_ctrl->get();//app_led_get_level(0);
    602a:	4d1b      	ldr	r5, [pc, #108]	; (6098 <bc_mm_recv_lightness_msg+0xd4>)
    602c:	682b      	ldr	r3, [r5, #0]
    602e:	685b      	ldr	r3, [r3, #4]
    6030:	4798      	blx	r3
	tmp.target_level = p_light_ln_ctrl->get();//app_led_get_level(0);
    6032:	682b      	ldr	r3, [r5, #0]
		p_light_ln_ctrl->set(lightness_set->level);
	}
	if(ind->opcode != MM_MSG_LIGHT_LN_SET)
		return;
	light_ln_status_t tmp;
	tmp.current_level = p_light_ln_ctrl->get();//app_led_get_level(0);
    6034:	0007      	movs	r7, r0
	tmp.target_level = p_light_ln_ctrl->get();//app_led_get_level(0);
    6036:	685b      	ldr	r3, [r3, #4]
    6038:	4798      	blx	r3
	tmp.remain = 0;
	m_api_buf_t* p_buf;

	// allocate a buffer for message
	sts = bc_m_buf_alloc(&p_buf, sizeof(tmp));
    603a:	2105      	movs	r1, #5
	}
	if(ind->opcode != MM_MSG_LIGHT_LN_SET)
		return;
	light_ln_status_t tmp;
	tmp.current_level = p_light_ln_ctrl->get();//app_led_get_level(0);
	tmp.target_level = p_light_ln_ctrl->get();//app_led_get_level(0);
    603c:	0006      	movs	r6, r0
	tmp.remain = 0;
	m_api_buf_t* p_buf;

	// allocate a buffer for message
	sts = bc_m_buf_alloc(&p_buf, sizeof(tmp));
    603e:	a805      	add	r0, sp, #20
    6040:	f002 feb2 	bl	8da8 <bc_m_buf_alloc>
    6044:	1e05      	subs	r5, r0, #0

	if(sts == M_ERR_NO_ERROR){
    6046:	d11d      	bne.n	6084 <bc_mm_recv_lightness_msg+0xc0>
		// copy message into the buffer
		memcpy(bc_m_buf_data_get(p_buf), &tmp, sizeof(tmp));
    6048:	9805      	ldr	r0, [sp, #20]
    604a:	f002 feb8 	bl	8dbe <bc_m_buf_data_get>
    604e:	7007      	strb	r7, [r0, #0]
    6050:	7086      	strb	r6, [r0, #2]
    6052:	0a3f      	lsrs	r7, r7, #8
    6054:	0a36      	lsrs	r6, r6, #8
    6056:	7047      	strb	r7, [r0, #1]
    6058:	70c6      	strb	r6, [r0, #3]
    605a:	7105      	strb	r5, [r0, #4]

		// request message response to be send
		sts = bc_m_model_rsp_send(ind->model_lid, MM_MSG_LIGHT_LN_STATUS, bc_mm_com_get_tx_hdl(), p_buf,
    605c:	7826      	ldrb	r6, [r4, #0]
    605e:	f7ff fb63 	bl	5728 <bc_mm_com_get_tx_hdl>
    6062:	8923      	ldrh	r3, [r4, #8]
    6064:	0002      	movs	r2, r0
    6066:	9301      	str	r3, [sp, #4]
    6068:	7863      	ldrb	r3, [r4, #1]
    606a:	9503      	str	r5, [sp, #12]
    606c:	9300      	str	r3, [sp, #0]
    606e:	9502      	str	r5, [sp, #8]
    6070:	9b05      	ldr	r3, [sp, #20]
    6072:	490b      	ldr	r1, [pc, #44]	; (60a0 <bc_mm_recv_lightness_msg+0xdc>)
    6074:	0030      	movs	r0, r6
    6076:	f002 feb3 	bl	8de0 <bc_m_model_rsp_send>
						ind->app_key_lid, ind->src, 0, 0);

		// an error occurs, release the buffer
		if(sts != M_ERR_NO_ERROR){
    607a:	2800      	cmp	r0, #0
    607c:	d002      	beq.n	6084 <bc_mm_recv_lightness_msg+0xc0>
			bc_m_buf_release(p_buf);
    607e:	9805      	ldr	r0, [sp, #20]
    6080:	f002 fe99 	bl	8db6 <bc_m_buf_release>
		}
	}

    //app_mesh_user_data_update(app_led_get_onoffstate(0), lightness_set->level, app_led_get_ctl_lightness(0), app_led_get_ctl_temperature(0),app_led_get_hsl(0));
}
    6084:	b007      	add	sp, #28
    6086:	bdf0      	pop	{r4, r5, r6, r7, pc}
    6088:	10010514 	.word	0x10010514
    608c:	00020c10 	.word	0x00020c10
    6090:	00020c90 	.word	0x00020c90
    6094:	10011125 	.word	0x10011125
    6098:	10011208 	.word	0x10011208
    609c:	00004c82 	.word	0x00004c82
    60a0:	00004e82 	.word	0x00004e82

000060a4 <bc_mm_light_ln_init>:

void bc_mm_light_ln_init(mesh_model_t* mdl, light_ln_ctrl_t* ctrl)
{
	//memset(mdl, 0, sizeof(mesh_model_t));
	mdl->vendor = 0;
    60a4:	2300      	movs	r3, #0
    60a6:	7183      	strb	r3, [r0, #6]
	mdl->lid = 0;
    60a8:	7143      	strb	r3, [r0, #5]
	mdl->id = MM_ID_LIGHTS_LN;   //lightness
    60aa:	2398      	movs	r3, #152	; 0x98
    60ac:	015b      	lsls	r3, r3, #5
    60ae:	6003      	str	r3, [r0, #0]
	mdl->op_check_cb = bc_mm_lightness_opcode_check;
    60b0:	4b04      	ldr	r3, [pc, #16]	; (60c4 <bc_mm_light_ln_init+0x20>)
    60b2:	6083      	str	r3, [r0, #8]
	mdl->msg_deal_cb = bc_mm_recv_lightness_msg;
    60b4:	4b04      	ldr	r3, [pc, #16]	; (60c8 <bc_mm_light_ln_init+0x24>)
    60b6:	60c3      	str	r3, [r0, #12]
	
	bc_mm_light_ln_t = mdl;
    60b8:	4b04      	ldr	r3, [pc, #16]	; (60cc <bc_mm_light_ln_init+0x28>)
    60ba:	6018      	str	r0, [r3, #0]
	p_light_ln_ctrl = ctrl;
    60bc:	4b04      	ldr	r3, [pc, #16]	; (60d0 <bc_mm_light_ln_init+0x2c>)
    60be:	6019      	str	r1, [r3, #0]
}
    60c0:	4770      	bx	lr
    60c2:	46c0      	nop			; (mov r8, r8)
    60c4:	00005f61 	.word	0x00005f61
    60c8:	00005fc5 	.word	0x00005fc5
    60cc:	10012854 	.word	0x10012854
    60d0:	10011208 	.word	0x10011208

000060d4 <bc_mm_light_ln_deinit>:
void bc_mm_light_ln_deinit(mesh_model_t* mdl)
{
	bc_mm_light_ln_t = NULL;
    60d4:	2200      	movs	r2, #0
    60d6:	4b01      	ldr	r3, [pc, #4]	; (60dc <bc_mm_light_ln_deinit+0x8>)
    60d8:	601a      	str	r2, [r3, #0]
}
    60da:	4770      	bx	lr
    60dc:	10012854 	.word	0x10012854

000060e0 <bc_mm_ctl_opcode_check>:
light_ctl_ctrl_t* p_light_ctl_ctrl;


static uint32_t bc_mm_ctl_opcode_check(uint32_t op)
{
	M_PRINTF(L_APP, "opcode = %08x", op);
    60e0:	4b13      	ldr	r3, [pc, #76]	; (6130 <bc_mm_ctl_opcode_check+0x50>)

light_ctl_ctrl_t* p_light_ctl_ctrl;


static uint32_t bc_mm_ctl_opcode_check(uint32_t op)
{
    60e2:	b537      	push	{r0, r1, r2, r4, r5, lr}
	M_PRINTF(L_APP, "opcode = %08x", op);
    60e4:	681b      	ldr	r3, [r3, #0]

light_ctl_ctrl_t* p_light_ctl_ctrl;


static uint32_t bc_mm_ctl_opcode_check(uint32_t op)
{
    60e6:	0005      	movs	r5, r0
	M_PRINTF(L_APP, "opcode = %08x", op);
    60e8:	049b      	lsls	r3, r3, #18
    60ea:	d515      	bpl.n	6118 <bc_mm_ctl_opcode_check+0x38>
    60ec:	4c11      	ldr	r4, [pc, #68]	; (6134 <bc_mm_ctl_opcode_check+0x54>)
    60ee:	0023      	movs	r3, r4
    60f0:	0022      	movs	r2, r4
    60f2:	0020      	movs	r0, r4
    60f4:	3351      	adds	r3, #81	; 0x51
    60f6:	322f      	adds	r2, #47	; 0x2f
    60f8:	9300      	str	r3, [sp, #0]
    60fa:	0021      	movs	r1, r4
    60fc:	230d      	movs	r3, #13
    60fe:	3042      	adds	r0, #66	; 0x42
    6100:	f7fe fc54 	bl	49ac <m_print>
    6104:	0020      	movs	r0, r4
    6106:	0029      	movs	r1, r5
    6108:	3068      	adds	r0, #104	; 0x68
    610a:	f7fe fc4f 	bl	49ac <m_print>
    610e:	0020      	movs	r0, r4
    6110:	1da1      	adds	r1, r4, #6
    6112:	3076      	adds	r0, #118	; 0x76
    6114:	f7fe fc4a 	bl	49ac <m_print>
	if((op == MM_MSG_LIGHT_CTL_SET)
    6118:	4b07      	ldr	r3, [pc, #28]	; (6138 <bc_mm_ctl_opcode_check+0x58>)
		|| (op == MM_MSG_LIGHT_CTL_GET)
		|| (op == MM_MSG_LIGHT_CTL_SET_UNACK)){
		return 0;
    611a:	2000      	movs	r0, #0


static uint32_t bc_mm_ctl_opcode_check(uint32_t op)
{
	M_PRINTF(L_APP, "opcode = %08x", op);
	if((op == MM_MSG_LIGHT_CTL_SET)
    611c:	429d      	cmp	r5, r3
    611e:	d005      	beq.n	612c <bc_mm_ctl_opcode_check+0x4c>
		|| (op == MM_MSG_LIGHT_CTL_GET)
		|| (op == MM_MSG_LIGHT_CTL_SET_UNACK)){
		return 0;
    6120:	4806      	ldr	r0, [pc, #24]	; (613c <bc_mm_ctl_opcode_check+0x5c>)
    6122:	4b07      	ldr	r3, [pc, #28]	; (6140 <bc_mm_ctl_opcode_check+0x60>)
    6124:	4028      	ands	r0, r5
    6126:	18c0      	adds	r0, r0, r3
    6128:	1e43      	subs	r3, r0, #1
    612a:	4198      	sbcs	r0, r3
	}
	return 1;
}
    612c:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
    612e:	46c0      	nop			; (mov r8, r8)
    6130:	10010514 	.word	0x10010514
    6134:	00020cb9 	.word	0x00020cb9
    6138:	00005e82 	.word	0x00005e82
    613c:	fffffdff 	.word	0xfffffdff
    6140:	ffffa27e 	.word	0xffffa27e

00006144 <bc_mm_recv_ctl_msg>:

static void bc_mm_recv_ctl_msg(m_api_model_msg_ind_t const *ind)
{
    6144:	b5f0      	push	{r4, r5, r6, r7, lr}
	uint16_t sts;
    light_ctl_set_t *ctl_set;
    
	ctl_set = (light_ctl_set_t *)ind->msg;
	M_PRINTF(L_APP, "temperature:[%x] tid[%x]",ctl_set->temperature, ctl_set->tid);
    6146:	4b48      	ldr	r3, [pc, #288]	; (6268 <bc_mm_recv_ctl_msg+0x124>)
	}
	return 1;
}

static void bc_mm_recv_ctl_msg(m_api_model_msg_ind_t const *ind)
{
    6148:	b089      	sub	sp, #36	; 0x24
	uint16_t sts;
    light_ctl_set_t *ctl_set;
    
	ctl_set = (light_ctl_set_t *)ind->msg;
	M_PRINTF(L_APP, "temperature:[%x] tid[%x]",ctl_set->temperature, ctl_set->tid);
    614a:	681b      	ldr	r3, [r3, #0]
	}
	return 1;
}

static void bc_mm_recv_ctl_msg(m_api_model_msg_ind_t const *ind)
{
    614c:	0004      	movs	r4, r0
	uint16_t sts;
    light_ctl_set_t *ctl_set;
    
	ctl_set = (light_ctl_set_t *)ind->msg;
	M_PRINTF(L_APP, "temperature:[%x] tid[%x]",ctl_set->temperature, ctl_set->tid);
    614e:	049b      	lsls	r3, r3, #18
    6150:	d519      	bpl.n	6186 <bc_mm_recv_ctl_msg+0x42>
    6152:	4d46      	ldr	r5, [pc, #280]	; (626c <bc_mm_recv_ctl_msg+0x128>)
    6154:	002b      	movs	r3, r5
    6156:	002a      	movs	r2, r5
    6158:	0028      	movs	r0, r5
    615a:	3379      	adds	r3, #121	; 0x79
    615c:	322f      	adds	r2, #47	; 0x2f
    615e:	9300      	str	r3, [sp, #0]
    6160:	0029      	movs	r1, r5
    6162:	231c      	movs	r3, #28
    6164:	3042      	adds	r0, #66	; 0x42
    6166:	f7fe fc21 	bl	49ac <m_print>
    616a:	7be1      	ldrb	r1, [r4, #15]
    616c:	7ba3      	ldrb	r3, [r4, #14]
    616e:	4840      	ldr	r0, [pc, #256]	; (6270 <bc_mm_recv_ctl_msg+0x12c>)
    6170:	0209      	lsls	r1, r1, #8
    6172:	4319      	orrs	r1, r3
    6174:	7ca2      	ldrb	r2, [r4, #18]
    6176:	300c      	adds	r0, #12
    6178:	f7fe fc18 	bl	49ac <m_print>
    617c:	0028      	movs	r0, r5
    617e:	1da9      	adds	r1, r5, #6
    6180:	3076      	adds	r0, #118	; 0x76
    6182:	f7fe fc13 	bl	49ac <m_print>
	if(emmTid != ctl_set->tid){
    6186:	4b3b      	ldr	r3, [pc, #236]	; (6274 <bc_mm_recv_ctl_msg+0x130>)
    6188:	7ca2      	ldrb	r2, [r4, #18]
    618a:	7819      	ldrb	r1, [r3, #0]
    618c:	4291      	cmp	r1, r2
    618e:	d008      	beq.n	61a2 <bc_mm_recv_ctl_msg+0x5e>
		emmTid = ctl_set->tid;
    6190:	701a      	strb	r2, [r3, #0]
		p_light_ctl_ctrl->ctl_set(ctl_set->temperature);
    6192:	7be0      	ldrb	r0, [r4, #15]
    6194:	7ba3      	ldrb	r3, [r4, #14]
    6196:	0200      	lsls	r0, r0, #8
    6198:	4318      	orrs	r0, r3
    619a:	4b37      	ldr	r3, [pc, #220]	; (6278 <bc_mm_recv_ctl_msg+0x134>)
    619c:	681b      	ldr	r3, [r3, #0]
    619e:	681b      	ldr	r3, [r3, #0]
    61a0:	4798      	blx	r3
	}
	if(ind->opcode != MM_MSG_LIGHT_CTL_SET)
    61a2:	4b36      	ldr	r3, [pc, #216]	; (627c <bc_mm_recv_ctl_msg+0x138>)
    61a4:	6862      	ldr	r2, [r4, #4]
    61a6:	429a      	cmp	r2, r3
    61a8:	d15b      	bne.n	6262 <bc_mm_recv_ctl_msg+0x11e>
		return;
	light_stl_status_t tmp;
	tmp.current_lightness = p_light_ctl_ctrl->ln_get();
    61aa:	4d33      	ldr	r5, [pc, #204]	; (6278 <bc_mm_recv_ctl_msg+0x134>)
    61ac:	682b      	ldr	r3, [r5, #0]
    61ae:	68db      	ldr	r3, [r3, #12]
    61b0:	4798      	blx	r3
	tmp.current_temperature = p_light_ctl_ctrl->ctl_get();
    61b2:	682b      	ldr	r3, [r5, #0]
		p_light_ctl_ctrl->ctl_set(ctl_set->temperature);
	}
	if(ind->opcode != MM_MSG_LIGHT_CTL_SET)
		return;
	light_stl_status_t tmp;
	tmp.current_lightness = p_light_ctl_ctrl->ln_get();
    61b4:	0007      	movs	r7, r0
	tmp.current_temperature = p_light_ctl_ctrl->ctl_get();
    61b6:	685b      	ldr	r3, [r3, #4]
    61b8:	4798      	blx	r3
	tmp.target_lightness = p_light_ctl_ctrl->ln_get();
    61ba:	682b      	ldr	r3, [r5, #0]
	}
	if(ind->opcode != MM_MSG_LIGHT_CTL_SET)
		return;
	light_stl_status_t tmp;
	tmp.current_lightness = p_light_ctl_ctrl->ln_get();
	tmp.current_temperature = p_light_ctl_ctrl->ctl_get();
    61bc:	0006      	movs	r6, r0
	tmp.target_lightness = p_light_ctl_ctrl->ln_get();
    61be:	68db      	ldr	r3, [r3, #12]
    61c0:	4798      	blx	r3
	tmp.target_temperature = p_light_ctl_ctrl->ctl_get();
    61c2:	682b      	ldr	r3, [r5, #0]
	if(ind->opcode != MM_MSG_LIGHT_CTL_SET)
		return;
	light_stl_status_t tmp;
	tmp.current_lightness = p_light_ctl_ctrl->ln_get();
	tmp.current_temperature = p_light_ctl_ctrl->ctl_get();
	tmp.target_lightness = p_light_ctl_ctrl->ln_get();
    61c4:	9004      	str	r0, [sp, #16]
	tmp.target_temperature = p_light_ctl_ctrl->ctl_get();
    61c6:	685b      	ldr	r3, [r3, #4]
    61c8:	4798      	blx	r3
	tmp.remain = 0;
	m_api_buf_t* p_buf;

	// allocate a buffer for message
	sts = bc_m_buf_alloc(&p_buf, sizeof(tmp));
    61ca:	2109      	movs	r1, #9
		return;
	light_stl_status_t tmp;
	tmp.current_lightness = p_light_ctl_ctrl->ln_get();
	tmp.current_temperature = p_light_ctl_ctrl->ctl_get();
	tmp.target_lightness = p_light_ctl_ctrl->ln_get();
	tmp.target_temperature = p_light_ctl_ctrl->ctl_get();
    61cc:	9005      	str	r0, [sp, #20]
	tmp.remain = 0;
	m_api_buf_t* p_buf;

	// allocate a buffer for message
	sts = bc_m_buf_alloc(&p_buf, sizeof(tmp));
    61ce:	a807      	add	r0, sp, #28
    61d0:	f002 fdea 	bl	8da8 <bc_m_buf_alloc>
    61d4:	1e05      	subs	r5, r0, #0

	if(sts == M_ERR_NO_ERROR){
    61d6:	d144      	bne.n	6262 <bc_mm_recv_ctl_msg+0x11e>
		// copy message into the buffer
		memcpy(bc_m_buf_data_get(p_buf), &tmp, sizeof(tmp));
    61d8:	9807      	ldr	r0, [sp, #28]
    61da:	f002 fdf0 	bl	8dbe <bc_m_buf_data_get>
    61de:	466b      	mov	r3, sp
    61e0:	7c1b      	ldrb	r3, [r3, #16]
    61e2:	7007      	strb	r7, [r0, #0]
    61e4:	7103      	strb	r3, [r0, #4]
    61e6:	9b04      	ldr	r3, [sp, #16]
    61e8:	7086      	strb	r6, [r0, #2]
    61ea:	0a1b      	lsrs	r3, r3, #8
    61ec:	7143      	strb	r3, [r0, #5]
    61ee:	466b      	mov	r3, sp
    61f0:	7d1b      	ldrb	r3, [r3, #20]
    61f2:	0a36      	lsrs	r6, r6, #8
    61f4:	7183      	strb	r3, [r0, #6]
    61f6:	9b05      	ldr	r3, [sp, #20]
    61f8:	0a3f      	lsrs	r7, r7, #8
    61fa:	0a1b      	lsrs	r3, r3, #8
    61fc:	71c3      	strb	r3, [r0, #7]
    61fe:	7205      	strb	r5, [r0, #8]
    6200:	7047      	strb	r7, [r0, #1]
    6202:	70c6      	strb	r6, [r0, #3]

		// request message response to be send
		sts = bc_m_model_rsp_send(ind->model_lid, MM_MSG_LIGHT_CTL_STATUS, bc_mm_com_get_tx_hdl(), p_buf,
    6204:	7826      	ldrb	r6, [r4, #0]
    6206:	f7ff fa8f 	bl	5728 <bc_mm_com_get_tx_hdl>
    620a:	9503      	str	r5, [sp, #12]
    620c:	9502      	str	r5, [sp, #8]
    620e:	8923      	ldrh	r3, [r4, #8]
    6210:	0002      	movs	r2, r0
    6212:	9301      	str	r3, [sp, #4]
    6214:	7863      	ldrb	r3, [r4, #1]
    6216:	491a      	ldr	r1, [pc, #104]	; (6280 <bc_mm_recv_ctl_msg+0x13c>)
    6218:	9300      	str	r3, [sp, #0]
    621a:	0030      	movs	r0, r6
    621c:	9b07      	ldr	r3, [sp, #28]
    621e:	f002 fddf 	bl	8de0 <bc_m_model_rsp_send>
						ind->app_key_lid, ind->src, 0, 0);
		M_PRINTF(L_AL, "sts[%x]", sts);
    6222:	4b11      	ldr	r3, [pc, #68]	; (6268 <bc_mm_recv_ctl_msg+0x124>)
	if(sts == M_ERR_NO_ERROR){
		// copy message into the buffer
		memcpy(bc_m_buf_data_get(p_buf), &tmp, sizeof(tmp));

		// request message response to be send
		sts = bc_m_model_rsp_send(ind->model_lid, MM_MSG_LIGHT_CTL_STATUS, bc_mm_com_get_tx_hdl(), p_buf,
    6224:	0005      	movs	r5, r0
						ind->app_key_lid, ind->src, 0, 0);
		M_PRINTF(L_AL, "sts[%x]", sts);
    6226:	681b      	ldr	r3, [r3, #0]
    6228:	07db      	lsls	r3, r3, #31
    622a:	d515      	bpl.n	6258 <bc_mm_recv_ctl_msg+0x114>
    622c:	4c0f      	ldr	r4, [pc, #60]	; (626c <bc_mm_recv_ctl_msg+0x128>)
    622e:	0023      	movs	r3, r4
    6230:	0022      	movs	r2, r4
    6232:	0020      	movs	r0, r4
    6234:	3379      	adds	r3, #121	; 0x79
    6236:	322f      	adds	r2, #47	; 0x2f
    6238:	9300      	str	r3, [sp, #0]
    623a:	0021      	movs	r1, r4
    623c:	2335      	movs	r3, #53	; 0x35
    623e:	3042      	adds	r0, #66	; 0x42
    6240:	f7fe fbb4 	bl	49ac <m_print>
    6244:	480a      	ldr	r0, [pc, #40]	; (6270 <bc_mm_recv_ctl_msg+0x12c>)
    6246:	0029      	movs	r1, r5
    6248:	3025      	adds	r0, #37	; 0x25
    624a:	f7fe fbaf 	bl	49ac <m_print>
    624e:	0020      	movs	r0, r4
    6250:	1da1      	adds	r1, r4, #6
    6252:	3076      	adds	r0, #118	; 0x76
    6254:	f7fe fbaa 	bl	49ac <m_print>
		// an error occurs, release the buffer
		if(sts != M_ERR_NO_ERROR){
    6258:	2d00      	cmp	r5, #0
    625a:	d002      	beq.n	6262 <bc_mm_recv_ctl_msg+0x11e>
			bc_m_buf_release(p_buf);
    625c:	9807      	ldr	r0, [sp, #28]
    625e:	f002 fdaa 	bl	8db6 <bc_m_buf_release>
		}
	}
    //app_mesh_user_data_update(app_led_get_onoffstate(0), app_led_get_level(0), ctl_set->lightness, ctl_set->temperature,app_led_get_hsl(0));
}
    6262:	b009      	add	sp, #36	; 0x24
    6264:	bdf0      	pop	{r4, r5, r6, r7, pc}
    6266:	46c0      	nop			; (mov r8, r8)
    6268:	10010514 	.word	0x10010514
    626c:	00020cb9 	.word	0x00020cb9
    6270:	00020d39 	.word	0x00020d39
    6274:	10011125 	.word	0x10011125
    6278:	10012858 	.word	0x10012858
    627c:	00005e82 	.word	0x00005e82
    6280:	00006082 	.word	0x00006082

00006284 <bc_mm_light_ctl_init>:

void bc_mm_light_ctl_init(mesh_model_t* mdl, light_ctl_ctrl_t* ctrl)
{
	//memset(mdl, 0, sizeof(mesh_model_t));
	mdl->vendor = 0;
    6284:	2300      	movs	r3, #0
    6286:	7183      	strb	r3, [r0, #6]
	mdl->lid = 0;
    6288:	7143      	strb	r3, [r0, #5]
	
	mdl->id = MM_ID_LIGHTS_CTL;   //lightness
    628a:	4b05      	ldr	r3, [pc, #20]	; (62a0 <bc_mm_light_ctl_init+0x1c>)
    628c:	6003      	str	r3, [r0, #0]
	mdl->op_check_cb = bc_mm_ctl_opcode_check;
    628e:	4b05      	ldr	r3, [pc, #20]	; (62a4 <bc_mm_light_ctl_init+0x20>)
    6290:	6083      	str	r3, [r0, #8]
	mdl->msg_deal_cb = bc_mm_recv_ctl_msg;
    6292:	4b05      	ldr	r3, [pc, #20]	; (62a8 <bc_mm_light_ctl_init+0x24>)
    6294:	60c3      	str	r3, [r0, #12]
	bc_mm_light_ctl_t = mdl;
    6296:	4b05      	ldr	r3, [pc, #20]	; (62ac <bc_mm_light_ctl_init+0x28>)
    6298:	6018      	str	r0, [r3, #0]
	p_light_ctl_ctrl = ctrl;
    629a:	4b05      	ldr	r3, [pc, #20]	; (62b0 <bc_mm_light_ctl_init+0x2c>)
    629c:	6019      	str	r1, [r3, #0]
}
    629e:	4770      	bx	lr
    62a0:	00001303 	.word	0x00001303
    62a4:	000060e1 	.word	0x000060e1
    62a8:	00006145 	.word	0x00006145
    62ac:	1001285c 	.word	0x1001285c
    62b0:	10012858 	.word	0x10012858

000062b4 <bc_mm_light_ctl_deinit>:
void bc_mm_light_ctl_deinit(mesh_model_t* mdl)
{
	bc_mm_light_ctl_t = NULL;
    62b4:	2200      	movs	r2, #0
    62b6:	4b01      	ldr	r3, [pc, #4]	; (62bc <bc_mm_light_ctl_deinit+0x8>)
    62b8:	601a      	str	r2, [r3, #0]
}
    62ba:	4770      	bx	lr
    62bc:	1001285c 	.word	0x1001285c

000062c0 <mesh_timer_call_back>:
void mesh_timer_call_back(int param)
{
	//M_PRINTF(L_AL,"");
	int i = 0;
	for(i = 0; i < MAX_NB_TIMER; ++i){
		if(param == (int)&sys_timer[i]){
    62c0:	4b08      	ldr	r3, [pc, #32]	; (62e4 <mesh_timer_call_back+0x24>)

static SYS_TIMER_TYPE sys_timer[MAX_NB_TIMER]; 


void mesh_timer_call_back(int param)
{
    62c2:	b510      	push	{r4, lr}
	//M_PRINTF(L_AL,"");
	int i = 0;
	for(i = 0; i < MAX_NB_TIMER; ++i){
		if(param == (int)&sys_timer[i]){
    62c4:	4283      	cmp	r3, r0
    62c6:	d004      	beq.n	62d2 <mesh_timer_call_back+0x12>
    62c8:	3318      	adds	r3, #24
    62ca:	4298      	cmp	r0, r3
    62cc:	d109      	bne.n	62e2 <mesh_timer_call_back+0x22>

void mesh_timer_call_back(int param)
{
	//M_PRINTF(L_AL,"");
	int i = 0;
	for(i = 0; i < MAX_NB_TIMER; ++i){
    62ce:	2001      	movs	r0, #1
    62d0:	e000      	b.n	62d4 <mesh_timer_call_back+0x14>
    62d2:	2000      	movs	r0, #0
		if(param == (int)&sys_timer[i]){
			// Allocate message
		    void *p_ind = M_AL_MSG_ALLOC_DEFAULT(MESH_TIMER_IND+i);
    62d4:	30ce      	adds	r0, #206	; 0xce
    62d6:	2100      	movs	r1, #0
    62d8:	b280      	uxth	r0, r0
    62da:	f7ff f95f 	bl	559c <m_al_msg_alloc>
		    // Send the message
		    m_al_msg_send(p_ind);
    62de:	f7ff f974 	bl	55ca <m_al_msg_send>
		
			break;
		}
	}
	
}
    62e2:	bd10      	pop	{r4, pc}
    62e4:	1001120c 	.word	0x1001120c

000062e8 <mesh_timer_init>:

uint8_t mesh_timer_init(void)
{
    62e8:	b510      	push	{r4, lr}
	//M_PRINTF(L_AL,"");
	SYS_TimerInit();
    62ea:	f7fb fd0a 	bl	1d02 <SYS_TimerInit>
	return 0;
}
    62ee:	2000      	movs	r0, #0
    62f0:	bd10      	pop	{r4, pc}

000062f2 <mesh_timer_clear>:

void mesh_timer_clear(uint16_t type)
{
	//M_PRINTF(L_AL,"t = %d", type);
	//bool a = 
	SYS_ReleaseTimer(&sys_timer[type]);
    62f2:	2318      	movs	r3, #24
	SYS_TimerInit();
	return 0;
}

void mesh_timer_clear(uint16_t type)
{
    62f4:	b510      	push	{r4, lr}
	//M_PRINTF(L_AL,"t = %d", type);
	//bool a = 
	SYS_ReleaseTimer(&sys_timer[type]);
    62f6:	4358      	muls	r0, r3
    62f8:	4b02      	ldr	r3, [pc, #8]	; (6304 <mesh_timer_clear+0x12>)
    62fa:	1818      	adds	r0, r3, r0
    62fc:	f7fb fda6 	bl	1e4c <SYS_ReleaseTimer>
	//M_PRINTF(L_AL,"type = %d ,a = %d", type, a);
}
    6300:	bd10      	pop	{r4, pc}
    6302:	46c0      	nop			; (mov r8, r8)
    6304:	1001120c 	.word	0x1001120c

00006308 <mesh_timer_set>:

void mesh_timer_set(uint16_t type, uint32_t delay)
{
	//M_PRINTF(L_AL,"t = %d d = %d", type, delay);
	SYS_SetTimer(&sys_timer[type], (int)delay, TIMER_SINGLE, mesh_timer_call_back);
    6308:	2318      	movs	r3, #24
	SYS_ReleaseTimer(&sys_timer[type]);
	//M_PRINTF(L_AL,"type = %d ,a = %d", type, a);
}

void mesh_timer_set(uint16_t type, uint32_t delay)
{
    630a:	b510      	push	{r4, lr}
	//M_PRINTF(L_AL,"t = %d d = %d", type, delay);
	SYS_SetTimer(&sys_timer[type], (int)delay, TIMER_SINGLE, mesh_timer_call_back);
    630c:	4358      	muls	r0, r3
    630e:	4b03      	ldr	r3, [pc, #12]	; (631c <mesh_timer_set+0x14>)
    6310:	2200      	movs	r2, #0
    6312:	1818      	adds	r0, r3, r0
    6314:	4b02      	ldr	r3, [pc, #8]	; (6320 <mesh_timer_set+0x18>)
    6316:	f7fb fd1b 	bl	1d50 <SYS_SetTimer>
}
    631a:	bd10      	pop	{r4, pc}
    631c:	1001120c 	.word	0x1001120c
    6320:	000062c1 	.word	0x000062c1

00006324 <mesh_timer_polling>:

void mesh_timer_polling()
{
    6324:	b510      	push	{r4, lr}
	//M_PRINTF(L_AL,"");
	SYS_timerPolling();
    6326:	f7fb fd66 	bl	1df6 <SYS_timerPolling>
}
    632a:	bd10      	pop	{r4, pc}

0000632c <mesh_timer_get_time>:

uint32_t mesh_timer_get_time(void)
{
    632c:	b510      	push	{r4, lr}
	return systick_get_ms();
    632e:	f7fc f947 	bl	25c0 <systick_get_ms>
}
    6332:	bd10      	pop	{r4, pc}

00006334 <ke_timer_clear>:

void ke_timer_clear(uint16_t type, uint32_t delay) 
{
    6334:	b510      	push	{r4, lr}
	//M_PRINTF(L_AL,"t = %d d = %d", type, delay);
	if(type-MESH_TIMER_IND < MAX_NB_TIMER)
    6336:	28cf      	cmp	r0, #207	; 0xcf
    6338:	dc07      	bgt.n	634a <ke_timer_clear+0x16>

void mesh_timer_clear(uint16_t type)
{
	//M_PRINTF(L_AL,"t = %d", type);
	//bool a = 
	SYS_ReleaseTimer(&sys_timer[type]);
    633a:	2318      	movs	r3, #24
    633c:	38ce      	subs	r0, #206	; 0xce
    633e:	b280      	uxth	r0, r0
    6340:	4358      	muls	r0, r3
    6342:	4b02      	ldr	r3, [pc, #8]	; (634c <ke_timer_clear+0x18>)
    6344:	1818      	adds	r0, r3, r0
    6346:	f7fb fd81 	bl	1e4c <SYS_ReleaseTimer>
void ke_timer_clear(uint16_t type, uint32_t delay) 
{
	//M_PRINTF(L_AL,"t = %d d = %d", type, delay);
	if(type-MESH_TIMER_IND < MAX_NB_TIMER)
	mesh_timer_clear(type-MESH_TIMER_IND);
}
    634a:	bd10      	pop	{r4, pc}
    634c:	1001120c 	.word	0x1001120c

00006350 <ke_timer_set>:

void ke_timer_set(uint16_t type, uint16_t taskid, uint32_t delay)
{
    6350:	b510      	push	{r4, lr}
	//M_PRINTF(L_AL,"type = %d taskid = 5d", type-MESH_TIMER_IND, taskid);
	if(type-MESH_TIMER_IND < MAX_NB_TIMER)
    6352:	28cf      	cmp	r0, #207	; 0xcf
    6354:	dc04      	bgt.n	6360 <ke_timer_set+0x10>
	mesh_timer_set(type-MESH_TIMER_IND, delay);
    6356:	38ce      	subs	r0, #206	; 0xce
    6358:	b280      	uxth	r0, r0
    635a:	0011      	movs	r1, r2
    635c:	f7ff ffd4 	bl	6308 <mesh_timer_set>
} 
    6360:	bd10      	pop	{r4, pc}

00006362 <ke_time>:

uint32_t ke_time(void)
{
    6362:	b510      	push	{r4, lr}
	uint32_t t = systick_get_ms()/10;
    6364:	f7fc f92c 	bl	25c0 <systick_get_ms>
	//M_PRINTF(L_AL,"t = %d", t);
	return t;//unit: 10ms
    6368:	210a      	movs	r1, #10
    636a:	f7fd ffc0 	bl	42ee <__aeabi_uidiv>
}
    636e:	bd10      	pop	{r4, pc}

00006370 <get_random_number>:


static bool get_random_number(uint8_t* randbuf)
{
	uint8_t randlen = 32;
	HREAD(mem_random_len) = randlen;
    6370:	2220      	movs	r2, #32
static uint64_t curve_n[NUM_ECC_DIGITS] = CURVE_N_32;
static uint64_t curve_b[NUM_ECC_DIGITS] = CURVE_B_32;


static bool get_random_number(uint8_t* randbuf)
{
    6372:	b510      	push	{r4, lr}
	uint8_t randlen = 32;
	HREAD(mem_random_len) = randlen;
    6374:	4b07      	ldr	r3, [pc, #28]	; (6394 <get_random_number+0x24>)
    6376:	701a      	strb	r2, [r3, #0]
	START_RAND();
    6378:	4b07      	ldr	r3, [pc, #28]	; (6398 <get_random_number+0x28>)
    637a:	3a1c      	subs	r2, #28
    637c:	7819      	ldrb	r1, [r3, #0]
    637e:	4311      	orrs	r1, r2
    6380:	7019      	strb	r1, [r3, #0]
	while((HREAD(mem_aes_state_map) >> 2)&1); 	//wait aes done
    6382:	7819      	ldrb	r1, [r3, #0]
    6384:	4211      	tst	r1, r2
    6386:	d1fc      	bne.n	6382 <get_random_number+0x12>
	memcpy(randbuf,(unsigned char*)reg_map(mem_random_buff),randlen);
    6388:	2220      	movs	r2, #32
    638a:	4904      	ldr	r1, [pc, #16]	; (639c <get_random_number+0x2c>)
    638c:	f00f fb20 	bl	159d0 <memcpy>

	return 1;
}
    6390:	2001      	movs	r0, #1
    6392:	bd10      	pop	{r4, pc}
    6394:	10004d0b 	.word	0x10004d0b
    6398:	10000bb4 	.word	0x10000bb4
    639c:	10004d0c 	.word	0x10004d0c

000063a0 <vli_clear>:

static void vli_clear(uint64_t *vli)
{
    63a0:	0003      	movs	r3, r0
    63a2:	b530      	push	{r4, r5, lr}
	int i;

	for (i = 0; i < NUM_ECC_DIGITS; i++)
		vli[i] = 0;
    63a4:	2400      	movs	r4, #0
    63a6:	2500      	movs	r5, #0
    63a8:	3320      	adds	r3, #32
    63aa:	c030      	stmia	r0!, {r4, r5}

static void vli_clear(uint64_t *vli)
{
	int i;

	for (i = 0; i < NUM_ECC_DIGITS; i++)
    63ac:	4298      	cmp	r0, r3
    63ae:	d1fc      	bne.n	63aa <vli_clear+0xa>
		vli[i] = 0;
}
    63b0:	bd30      	pop	{r4, r5, pc}

000063b2 <vli_is_zero>:

/* Returns true if vli == 0, false otherwise. */
static bool vli_is_zero(const uint64_t *vli)
{
    63b2:	0002      	movs	r2, r0
    63b4:	3220      	adds	r2, #32
	int i;

	for (i = 0; i < NUM_ECC_DIGITS; i++) {
		if (vli[i])
    63b6:	6803      	ldr	r3, [r0, #0]
    63b8:	6841      	ldr	r1, [r0, #4]
    63ba:	430b      	orrs	r3, r1
    63bc:	d104      	bne.n	63c8 <vli_is_zero+0x16>
    63be:	3008      	adds	r0, #8
/* Returns true if vli == 0, false otherwise. */
static bool vli_is_zero(const uint64_t *vli)
{
	int i;

	for (i = 0; i < NUM_ECC_DIGITS; i++) {
    63c0:	4290      	cmp	r0, r2
    63c2:	d1f8      	bne.n	63b6 <vli_is_zero+0x4>
		if (vli[i])
			return false;
	}

	return true;
    63c4:	2001      	movs	r0, #1
    63c6:	e000      	b.n	63ca <vli_is_zero+0x18>
{
	int i;

	for (i = 0; i < NUM_ECC_DIGITS; i++) {
		if (vli[i])
			return false;
    63c8:	2000      	movs	r0, #0
	}

	return true;
}
    63ca:	4770      	bx	lr

000063cc <vli_num_bits>:

	/* Search from the end until we find a non-zero digit.
	 * We do it in reverse because we expect that most digits will
	 * be nonzero.
	 */
	for (i = NUM_ECC_DIGITS - 1; i >= 0 && vli[i] == 0; i--);
    63cc:	2303      	movs	r3, #3
	return (i + 1);
}

/* Counts the number of bits required for vli. */
static unsigned int vli_num_bits(const uint64_t *vli)
{
    63ce:	b510      	push	{r4, lr}

	/* Search from the end until we find a non-zero digit.
	 * We do it in reverse because we expect that most digits will
	 * be nonzero.
	 */
	for (i = NUM_ECC_DIGITS - 1; i >= 0 && vli[i] == 0; i--);
    63d0:	00da      	lsls	r2, r3, #3
    63d2:	1882      	adds	r2, r0, r2
    63d4:	6811      	ldr	r1, [r2, #0]
    63d6:	6852      	ldr	r2, [r2, #4]
    63d8:	4311      	orrs	r1, r2
    63da:	d102      	bne.n	63e2 <vli_num_bits+0x16>
    63dc:	3b01      	subs	r3, #1
    63de:	d2f7      	bcs.n	63d0 <vli_num_bits+0x4>
    63e0:	e015      	b.n	640e <vli_num_bits+0x42>

	return (i + 1);
    63e2:	1c5a      	adds	r2, r3, #1
{
	unsigned int i, num_digits;
	uint64_t digit;

	num_digits = vli_num_digits(vli);
	if (num_digits == 0)
    63e4:	2a00      	cmp	r2, #0
    63e6:	d012      	beq.n	640e <vli_num_bits+0x42>
		return 0;

	digit = vli[num_digits - 1];
    63e8:	00db      	lsls	r3, r3, #3
    63ea:	18c0      	adds	r0, r0, r3
	for (i = 0; digit; i++)
    63ec:	2300      	movs	r3, #0

	num_digits = vli_num_digits(vli);
	if (num_digits == 0)
		return 0;

	digit = vli[num_digits - 1];
    63ee:	6801      	ldr	r1, [r0, #0]
    63f0:	6840      	ldr	r0, [r0, #4]
	for (i = 0; digit; i++)
    63f2:	000c      	movs	r4, r1
    63f4:	4304      	orrs	r4, r0
    63f6:	d005      	beq.n	6404 <vli_num_bits+0x38>
		digit >>= 1;
    63f8:	07c4      	lsls	r4, r0, #31
    63fa:	0849      	lsrs	r1, r1, #1
    63fc:	4321      	orrs	r1, r4
    63fe:	0840      	lsrs	r0, r0, #1
	num_digits = vli_num_digits(vli);
	if (num_digits == 0)
		return 0;

	digit = vli[num_digits - 1];
	for (i = 0; digit; i++)
    6400:	3301      	adds	r3, #1
    6402:	e7f6      	b.n	63f2 <vli_num_bits+0x26>
		digit >>= 1;

	return ((num_digits - 1) * 64 + i);
    6404:	4903      	ldr	r1, [pc, #12]	; (6414 <vli_num_bits+0x48>)
    6406:	1850      	adds	r0, r2, r1
    6408:	0180      	lsls	r0, r0, #6
    640a:	18c0      	adds	r0, r0, r3
    640c:	e000      	b.n	6410 <vli_num_bits+0x44>
	unsigned int i, num_digits;
	uint64_t digit;

	num_digits = vli_num_digits(vli);
	if (num_digits == 0)
		return 0;
    640e:	2000      	movs	r0, #0
	digit = vli[num_digits - 1];
	for (i = 0; digit; i++)
		digit >>= 1;

	return ((num_digits - 1) * 64 + i);
}
    6410:	bd10      	pop	{r4, pc}
    6412:	46c0      	nop			; (mov r8, r8)
    6414:	03ffffff 	.word	0x03ffffff

00006418 <vli_set>:

/* Sets dest = src. */
static void vli_set(uint64_t *dest, const uint64_t *src)
{
    6418:	2300      	movs	r3, #0
    641a:	b530      	push	{r4, r5, lr}
	int i;

	for (i = 0; i < NUM_ECC_DIGITS; i++)
		dest[i] = src[i];
    641c:	18ca      	adds	r2, r1, r3
    641e:	6814      	ldr	r4, [r2, #0]
    6420:	6855      	ldr	r5, [r2, #4]
    6422:	18c2      	adds	r2, r0, r3
    6424:	3308      	adds	r3, #8
    6426:	6014      	str	r4, [r2, #0]
    6428:	6055      	str	r5, [r2, #4]
/* Sets dest = src. */
static void vli_set(uint64_t *dest, const uint64_t *src)
{
	int i;

	for (i = 0; i < NUM_ECC_DIGITS; i++)
    642a:	2b20      	cmp	r3, #32
    642c:	d1f6      	bne.n	641c <vli_set+0x4>
		dest[i] = src[i];
}
    642e:	bd30      	pop	{r4, r5, pc}

00006430 <vli_cmp>:

/* Returns sign of left - right. */
static int vli_cmp(const uint64_t *left, const uint64_t *right)
{
    6430:	0003      	movs	r3, r0
    6432:	b570      	push	{r4, r5, r6, lr}
    6434:	3318      	adds	r3, #24
    6436:	3118      	adds	r1, #24
    6438:	3808      	subs	r0, #8
    int i;

    for (i = NUM_ECC_DIGITS - 1; i >= 0; i--) {
	    if (left[i] > right[i])
    643a:	685a      	ldr	r2, [r3, #4]
    643c:	684c      	ldr	r4, [r1, #4]
    643e:	681d      	ldr	r5, [r3, #0]
    6440:	680e      	ldr	r6, [r1, #0]
    6442:	42a2      	cmp	r2, r4
    6444:	d80d      	bhi.n	6462 <vli_cmp+0x32>
    6446:	d101      	bne.n	644c <vli_cmp+0x1c>
    6448:	42b5      	cmp	r5, r6
    644a:	d80a      	bhi.n	6462 <vli_cmp+0x32>
		    return 1;
	    else if (left[i] < right[i])
    644c:	4294      	cmp	r4, r2
    644e:	d80a      	bhi.n	6466 <vli_cmp+0x36>
    6450:	d101      	bne.n	6456 <vli_cmp+0x26>
    6452:	42ae      	cmp	r6, r5
    6454:	d807      	bhi.n	6466 <vli_cmp+0x36>
    6456:	3b08      	subs	r3, #8
    6458:	3908      	subs	r1, #8
/* Returns sign of left - right. */
static int vli_cmp(const uint64_t *left, const uint64_t *right)
{
    int i;

    for (i = NUM_ECC_DIGITS - 1; i >= 0; i--) {
    645a:	4283      	cmp	r3, r0
    645c:	d1ed      	bne.n	643a <vli_cmp+0xa>
		    return 1;
	    else if (left[i] < right[i])
		    return -1;
    }

    return 0;
    645e:	2000      	movs	r0, #0
    6460:	e003      	b.n	646a <vli_cmp+0x3a>
{
    int i;

    for (i = NUM_ECC_DIGITS - 1; i >= 0; i--) {
	    if (left[i] > right[i])
		    return 1;
    6462:	2001      	movs	r0, #1
    6464:	e001      	b.n	646a <vli_cmp+0x3a>
	    else if (left[i] < right[i])
		    return -1;
    6466:	2001      	movs	r0, #1
    6468:	4240      	negs	r0, r0
    }

    return 0;
}
    646a:	bd70      	pop	{r4, r5, r6, pc}

0000646c <vli_rshift1>:
static void vli_rshift1(uint64_t *vli)
{
	uint64_t *end = vli;
	uint64_t carry = 0;

	vli += NUM_ECC_DIGITS;
    646c:	0003      	movs	r3, r0

/* Computes vli = vli >> 1. */
static void vli_rshift1(uint64_t *vli)
{
	uint64_t *end = vli;
	uint64_t carry = 0;
    646e:	2200      	movs	r2, #0
	return carry;
}

/* Computes vli = vli >> 1. */
static void vli_rshift1(uint64_t *vli)
{
    6470:	b570      	push	{r4, r5, r6, lr}
	uint64_t *end = vli;
	uint64_t carry = 0;

	vli += NUM_ECC_DIGITS;
    6472:	3320      	adds	r3, #32
    6474:	3808      	subs	r0, #8

	while (vli-- > end) {
    6476:	3b08      	subs	r3, #8
    6478:	4283      	cmp	r3, r0
    647a:	d00a      	beq.n	6492 <vli_rshift1+0x26>
		uint64_t temp = *vli;
    647c:	681d      	ldr	r5, [r3, #0]
    647e:	6859      	ldr	r1, [r3, #4]
		*vli = (temp >> 1) | carry;
    6480:	086c      	lsrs	r4, r5, #1
    6482:	07ce      	lsls	r6, r1, #31
    6484:	0849      	lsrs	r1, r1, #1
    6486:	430a      	orrs	r2, r1
    6488:	4334      	orrs	r4, r6
    648a:	605a      	str	r2, [r3, #4]
    648c:	601c      	str	r4, [r3, #0]
		carry = temp << 63;
    648e:	07ea      	lsls	r2, r5, #31
    6490:	e7f1      	b.n	6476 <vli_rshift1+0xa>
	}
}
    6492:	bd70      	pop	{r4, r5, r6, pc}

00006494 <vli_add>:

/* Computes result = left + right, returning carry. Can modify in place. */
static uint64_t vli_add(uint64_t *result, const uint64_t *left,
							const uint64_t *right)
{
    6494:	b5f0      	push	{r4, r5, r6, r7, lr}
    6496:	b085      	sub	sp, #20
    6498:	9001      	str	r0, [sp, #4]
    649a:	9102      	str	r1, [sp, #8]
    649c:	2400      	movs	r4, #0
	uint64_t carry = 0;
    649e:	2000      	movs	r0, #0
    64a0:	2100      	movs	r1, #0
}

/* Computes result = left + right, returning carry. Can modify in place. */
static uint64_t vli_add(uint64_t *result, const uint64_t *left,
							const uint64_t *right)
{
    64a2:	9203      	str	r2, [sp, #12]
	int i;

	for (i = 0; i < NUM_ECC_DIGITS; i++) {
		uint64_t sum;

		sum = left[i] + right[i] + carry;
    64a4:	9b02      	ldr	r3, [sp, #8]
    64a6:	191b      	adds	r3, r3, r4
    64a8:	681d      	ldr	r5, [r3, #0]
    64aa:	685e      	ldr	r6, [r3, #4]
    64ac:	9b03      	ldr	r3, [sp, #12]
    64ae:	191b      	adds	r3, r3, r4
    64b0:	681a      	ldr	r2, [r3, #0]
    64b2:	685b      	ldr	r3, [r3, #4]
    64b4:	1952      	adds	r2, r2, r5
    64b6:	4173      	adcs	r3, r6
    64b8:	1812      	adds	r2, r2, r0
    64ba:	414b      	adcs	r3, r1
		if (sum != left[i])
    64bc:	4295      	cmp	r5, r2
    64be:	d101      	bne.n	64c4 <vli_add+0x30>
    64c0:	429e      	cmp	r6, r3
    64c2:	d00c      	beq.n	64de <vli_add+0x4a>
			carry = (sum < left[i]);
    64c4:	2101      	movs	r1, #1
    64c6:	2700      	movs	r7, #0
    64c8:	468c      	mov	ip, r1
    64ca:	429e      	cmp	r6, r3
    64cc:	d805      	bhi.n	64da <vli_add+0x46>
    64ce:	d101      	bne.n	64d4 <vli_add+0x40>
    64d0:	4295      	cmp	r5, r2
    64d2:	d802      	bhi.n	64da <vli_add+0x46>
    64d4:	2100      	movs	r1, #0
    64d6:	468c      	mov	ip, r1
    64d8:	000f      	movs	r7, r1
    64da:	4660      	mov	r0, ip
    64dc:	0039      	movs	r1, r7

		result[i] = sum;
    64de:	9d01      	ldr	r5, [sp, #4]
    64e0:	192f      	adds	r7, r5, r4
    64e2:	3408      	adds	r4, #8
    64e4:	603a      	str	r2, [r7, #0]
    64e6:	607b      	str	r3, [r7, #4]
							const uint64_t *right)
{
	uint64_t carry = 0;
	int i;

	for (i = 0; i < NUM_ECC_DIGITS; i++) {
    64e8:	2c20      	cmp	r4, #32
    64ea:	d1db      	bne.n	64a4 <vli_add+0x10>

		result[i] = sum;
	}

	return carry;
}
    64ec:	b005      	add	sp, #20
    64ee:	bdf0      	pop	{r4, r5, r6, r7, pc}

000064f0 <vli_sub>:

/* Computes result = left - right, returning borrow. Can modify in place. */
static uint64_t vli_sub(uint64_t *result, const uint64_t *left,
							const uint64_t *right)
{
    64f0:	b5f0      	push	{r4, r5, r6, r7, lr}
    64f2:	b087      	sub	sp, #28
    64f4:	9205      	str	r2, [sp, #20]
	uint64_t borrow = 0;
    64f6:	2300      	movs	r3, #0
    64f8:	2200      	movs	r2, #0
}

/* Computes result = left - right, returning borrow. Can modify in place. */
static uint64_t vli_sub(uint64_t *result, const uint64_t *left,
							const uint64_t *right)
{
    64fa:	2400      	movs	r4, #0
	uint64_t borrow = 0;
    64fc:	9200      	str	r2, [sp, #0]
    64fe:	9301      	str	r3, [sp, #4]
}

/* Computes result = left - right, returning borrow. Can modify in place. */
static uint64_t vli_sub(uint64_t *result, const uint64_t *left,
							const uint64_t *right)
{
    6500:	9003      	str	r0, [sp, #12]
    6502:	9104      	str	r1, [sp, #16]
	int i;

	for (i = 0; i < NUM_ECC_DIGITS; i++) {
		uint64_t diff;

		diff = left[i] - right[i] - borrow;
    6504:	9b04      	ldr	r3, [sp, #16]
    6506:	191b      	adds	r3, r3, r4
    6508:	681d      	ldr	r5, [r3, #0]
    650a:	685e      	ldr	r6, [r3, #4]
    650c:	0028      	movs	r0, r5
    650e:	0031      	movs	r1, r6
    6510:	9b05      	ldr	r3, [sp, #20]
    6512:	191b      	adds	r3, r3, r4
    6514:	681a      	ldr	r2, [r3, #0]
    6516:	685b      	ldr	r3, [r3, #4]
    6518:	1a80      	subs	r0, r0, r2
    651a:	4199      	sbcs	r1, r3
    651c:	0002      	movs	r2, r0
    651e:	000b      	movs	r3, r1
    6520:	9800      	ldr	r0, [sp, #0]
    6522:	9901      	ldr	r1, [sp, #4]
    6524:	1a12      	subs	r2, r2, r0
    6526:	418b      	sbcs	r3, r1
		if (diff != left[i])
    6528:	4295      	cmp	r5, r2
    652a:	d101      	bne.n	6530 <vli_sub+0x40>
    652c:	429e      	cmp	r6, r3
    652e:	d00d      	beq.n	654c <vli_sub+0x5c>
			borrow = (diff > left[i]);
    6530:	2101      	movs	r1, #1
    6532:	2700      	movs	r7, #0
    6534:	468c      	mov	ip, r1
    6536:	42b3      	cmp	r3, r6
    6538:	d805      	bhi.n	6546 <vli_sub+0x56>
    653a:	d101      	bne.n	6540 <vli_sub+0x50>
    653c:	42aa      	cmp	r2, r5
    653e:	d802      	bhi.n	6546 <vli_sub+0x56>
    6540:	2100      	movs	r1, #0
    6542:	468c      	mov	ip, r1
    6544:	000f      	movs	r7, r1
    6546:	4661      	mov	r1, ip
    6548:	9701      	str	r7, [sp, #4]
    654a:	9100      	str	r1, [sp, #0]

		result[i] = diff;
    654c:	9903      	ldr	r1, [sp, #12]
    654e:	190f      	adds	r7, r1, r4
    6550:	3408      	adds	r4, #8
    6552:	603a      	str	r2, [r7, #0]
    6554:	607b      	str	r3, [r7, #4]
							const uint64_t *right)
{
	uint64_t borrow = 0;
	int i;

	for (i = 0; i < NUM_ECC_DIGITS; i++) {
    6556:	2c20      	cmp	r4, #32
    6558:	d1d4      	bne.n	6504 <vli_sub+0x14>

		result[i] = diff;
	}

	return borrow;
}
    655a:	9800      	ldr	r0, [sp, #0]
    655c:	9901      	ldr	r1, [sp, #4]
    655e:	b007      	add	sp, #28
    6560:	bdf0      	pop	{r4, r5, r6, r7, pc}

00006562 <vli_mmod_fast>:
}

/* Computes result = product % curve_p
   from http://www.nsa.gov/ia/_files/nist-routines.pdf */
static void vli_mmod_fast(uint64_t *result, const uint64_t *product)
{
    6562:	b5f0      	push	{r4, r5, r6, r7, lr}
    6564:	b08d      	sub	sp, #52	; 0x34
    6566:	000c      	movs	r4, r1
    6568:	0005      	movs	r5, r0
	uint64_t tmp[NUM_ECC_DIGITS];
	int carry;

	/* t */
	vli_set(result, product);
    656a:	f7ff ff55 	bl	6418 <vli_set>

	/* s1 */
	tmp[0] = 0;
    656e:	2200      	movs	r2, #0
    6570:	2300      	movs	r3, #0
	tmp[1] = product[5] & 0xffffffff00000000ull;
    6572:	2700      	movs	r7, #0

	/* t */
	vli_set(result, product);

	/* s1 */
	tmp[0] = 0;
    6574:	9204      	str	r2, [sp, #16]
    6576:	9305      	str	r3, [sp, #20]
	tmp[1] = product[5] & 0xffffffff00000000ull;
    6578:	6ae3      	ldr	r3, [r4, #44]	; 0x2c

	/* t */
	vli_set(result, product);

	/* s1 */
	tmp[0] = 0;
    657a:	ae04      	add	r6, sp, #16
	tmp[1] = product[5] & 0xffffffff00000000ull;
    657c:	60f3      	str	r3, [r6, #12]
	tmp[2] = product[6];
    657e:	6b22      	ldr	r2, [r4, #48]	; 0x30
    6580:	6b63      	ldr	r3, [r4, #52]	; 0x34
    6582:	6132      	str	r2, [r6, #16]
    6584:	6173      	str	r3, [r6, #20]
	tmp[3] = product[7];
    6586:	6ba2      	ldr	r2, [r4, #56]	; 0x38
    6588:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    658a:	61b2      	str	r2, [r6, #24]
    658c:	61f3      	str	r3, [r6, #28]
	/* t */
	vli_set(result, product);

	/* s1 */
	tmp[0] = 0;
	tmp[1] = product[5] & 0xffffffff00000000ull;
    658e:	60b7      	str	r7, [r6, #8]
 * (if result == in). 0 < shift < 64.
 */
static uint64_t vli_lshift(uint64_t *result, const uint64_t *in,
							unsigned int shift)
{
	uint64_t carry = 0;
    6590:	9700      	str	r7, [sp, #0]
    6592:	19f3      	adds	r3, r6, r7
    6594:	469c      	mov	ip, r3
	int i;

	for (i = 0; i < NUM_ECC_DIGITS; i++) {
		uint64_t temp = in[i];
    6596:	681a      	ldr	r2, [r3, #0]
    6598:	685b      	ldr	r3, [r3, #4]

		result[i] = (temp << shift) | carry;
    659a:	0019      	movs	r1, r3
    659c:	0010      	movs	r0, r2
    659e:	1880      	adds	r0, r0, r2
    65a0:	4159      	adcs	r1, r3
    65a2:	9002      	str	r0, [sp, #8]
    65a4:	9103      	str	r1, [sp, #12]
    65a6:	9802      	ldr	r0, [sp, #8]
    65a8:	9900      	ldr	r1, [sp, #0]
		carry = temp >> (64 - shift);
    65aa:	0fdb      	lsrs	r3, r3, #31
	int i;

	for (i = 0; i < NUM_ECC_DIGITS; i++) {
		uint64_t temp = in[i];

		result[i] = (temp << shift) | carry;
    65ac:	4308      	orrs	r0, r1
    65ae:	4661      	mov	r1, ip
    65b0:	6008      	str	r0, [r1, #0]
    65b2:	9803      	ldr	r0, [sp, #12]
    65b4:	3708      	adds	r7, #8
    65b6:	6048      	str	r0, [r1, #4]
		carry = temp >> (64 - shift);
    65b8:	9300      	str	r3, [sp, #0]
							unsigned int shift)
{
	uint64_t carry = 0;
	int i;

	for (i = 0; i < NUM_ECC_DIGITS; i++) {
    65ba:	2f20      	cmp	r7, #32
    65bc:	d1e9      	bne.n	6592 <vli_mmod_fast+0x30>
	tmp[0] = 0;
	tmp[1] = product[5] & 0xffffffff00000000ull;
	tmp[2] = product[6];
	tmp[3] = product[7];
	carry = vli_lshift(tmp, tmp, 1);
	carry += vli_add(result, result, tmp);
    65be:	0032      	movs	r2, r6
    65c0:	0029      	movs	r1, r5
    65c2:	0028      	movs	r0, r5
    65c4:	f7ff ff66 	bl	6494 <vli_add>
    65c8:	9b00      	ldr	r3, [sp, #0]
    65ca:	18c3      	adds	r3, r0, r3
    65cc:	9302      	str	r3, [sp, #8]

	/* s2 */
	tmp[1] = product[6] << 32;
    65ce:	6b23      	ldr	r3, [r4, #48]	; 0x30
    65d0:	60f3      	str	r3, [r6, #12]
    65d2:	2300      	movs	r3, #0
    65d4:	60b3      	str	r3, [r6, #8]
	tmp[2] = (product[6] >> 32) | (product[7] << 32);
    65d6:	6b63      	ldr	r3, [r4, #52]	; 0x34
    65d8:	6133      	str	r3, [r6, #16]
    65da:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    65dc:	6173      	str	r3, [r6, #20]
	tmp[3] = product[7] >> 32;
    65de:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    65e0:	61b3      	str	r3, [r6, #24]
    65e2:	2300      	movs	r3, #0
    65e4:	0019      	movs	r1, r3
 * (if result == in). 0 < shift < 64.
 */
static uint64_t vli_lshift(uint64_t *result, const uint64_t *in,
							unsigned int shift)
{
	uint64_t carry = 0;
    65e6:	0018      	movs	r0, r3
	carry += vli_add(result, result, tmp);

	/* s2 */
	tmp[1] = product[6] << 32;
	tmp[2] = (product[6] >> 32) | (product[7] << 32);
	tmp[3] = product[7] >> 32;
    65e8:	61f3      	str	r3, [r6, #28]
    65ea:	468c      	mov	ip, r1
    65ec:	ab04      	add	r3, sp, #16
    65ee:	449c      	add	ip, r3
{
	uint64_t carry = 0;
	int i;

	for (i = 0; i < NUM_ECC_DIGITS; i++) {
		uint64_t temp = in[i];
    65f0:	4663      	mov	r3, ip
    65f2:	681a      	ldr	r2, [r3, #0]
    65f4:	685b      	ldr	r3, [r3, #4]

		result[i] = (temp << shift) | carry;
    65f6:	0016      	movs	r6, r2
    65f8:	001f      	movs	r7, r3
    65fa:	18b6      	adds	r6, r6, r2
    65fc:	415f      	adcs	r7, r3
    65fe:	9600      	str	r6, [sp, #0]
    6600:	9701      	str	r7, [sp, #4]
    6602:	9e00      	ldr	r6, [sp, #0]
    6604:	3108      	adds	r1, #8
    6606:	4330      	orrs	r0, r6
    6608:	4666      	mov	r6, ip
    660a:	6030      	str	r0, [r6, #0]
    660c:	4660      	mov	r0, ip
    660e:	9e01      	ldr	r6, [sp, #4]
    6610:	6046      	str	r6, [r0, #4]
		carry = temp >> (64 - shift);
    6612:	0fd8      	lsrs	r0, r3, #31
    6614:	2600      	movs	r6, #0
							unsigned int shift)
{
	uint64_t carry = 0;
	int i;

	for (i = 0; i < NUM_ECC_DIGITS; i++) {
    6616:	2920      	cmp	r1, #32
    6618:	d1e7      	bne.n	65ea <vli_mmod_fast+0x88>

	/* s2 */
	tmp[1] = product[6] << 32;
	tmp[2] = (product[6] >> 32) | (product[7] << 32);
	tmp[3] = product[7] >> 32;
	carry += vli_lshift(tmp, tmp, 1);
    661a:	9b02      	ldr	r3, [sp, #8]
	carry += vli_add(result, result, tmp);
    661c:	aa04      	add	r2, sp, #16

	/* s2 */
	tmp[1] = product[6] << 32;
	tmp[2] = (product[6] >> 32) | (product[7] << 32);
	tmp[3] = product[7] >> 32;
	carry += vli_lshift(tmp, tmp, 1);
    661e:	181f      	adds	r7, r3, r0
	carry += vli_add(result, result, tmp);
    6620:	0029      	movs	r1, r5
    6622:	0028      	movs	r0, r5
    6624:	f7ff ff36 	bl	6494 <vli_add>

	/* s3 */
	tmp[0] = product[4];
    6628:	6a22      	ldr	r2, [r4, #32]
    662a:	6a63      	ldr	r3, [r4, #36]	; 0x24
    662c:	9204      	str	r2, [sp, #16]
    662e:	9305      	str	r3, [sp, #20]
	tmp[1] = product[5] & 0xffffffff;
    6630:	6aa3      	ldr	r3, [r4, #40]	; 0x28
	tmp[2] = 0;
    6632:	2200      	movs	r2, #0
	carry += vli_lshift(tmp, tmp, 1);
	carry += vli_add(result, result, tmp);

	/* s3 */
	tmp[0] = product[4];
	tmp[1] = product[5] & 0xffffffff;
    6634:	9306      	str	r3, [sp, #24]
	tmp[2] = 0;
    6636:	2300      	movs	r3, #0
	/* s2 */
	tmp[1] = product[6] << 32;
	tmp[2] = (product[6] >> 32) | (product[7] << 32);
	tmp[3] = product[7] >> 32;
	carry += vli_lshift(tmp, tmp, 1);
	carry += vli_add(result, result, tmp);
    6638:	183f      	adds	r7, r7, r0

	/* s3 */
	tmp[0] = product[4];
	tmp[1] = product[5] & 0xffffffff;
	tmp[2] = 0;
    663a:	9208      	str	r2, [sp, #32]
    663c:	9309      	str	r3, [sp, #36]	; 0x24
	tmp[3] = product[7];
    663e:	6ba2      	ldr	r2, [r4, #56]	; 0x38
    6640:	6be3      	ldr	r3, [r4, #60]	; 0x3c
	carry += vli_add(result, result, tmp);
    6642:	0029      	movs	r1, r5

	/* s3 */
	tmp[0] = product[4];
	tmp[1] = product[5] & 0xffffffff;
	tmp[2] = 0;
	tmp[3] = product[7];
    6644:	920a      	str	r2, [sp, #40]	; 0x28
    6646:	930b      	str	r3, [sp, #44]	; 0x2c
	carry += vli_add(result, result, tmp);
    6648:	0028      	movs	r0, r5
    664a:	aa04      	add	r2, sp, #16
	carry += vli_lshift(tmp, tmp, 1);
	carry += vli_add(result, result, tmp);

	/* s3 */
	tmp[0] = product[4];
	tmp[1] = product[5] & 0xffffffff;
    664c:	9607      	str	r6, [sp, #28]
	tmp[2] = 0;
	tmp[3] = product[7];
	carry += vli_add(result, result, tmp);
    664e:	f7ff ff21 	bl	6494 <vli_add>

	/* s4 */
	tmp[0] = (product[4] >> 32) | (product[5] << 32);
    6652:	6a63      	ldr	r3, [r4, #36]	; 0x24
	tmp[1] = (product[5] >> 32) | (product[6] & 0xffffffff00000000ull);
    6654:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
	tmp[2] = 0;
	tmp[3] = product[7];
	carry += vli_add(result, result, tmp);

	/* s4 */
	tmp[0] = (product[4] >> 32) | (product[5] << 32);
    6656:	9304      	str	r3, [sp, #16]
    6658:	6aa3      	ldr	r3, [r4, #40]	; 0x28
	/* s3 */
	tmp[0] = product[4];
	tmp[1] = product[5] & 0xffffffff;
	tmp[2] = 0;
	tmp[3] = product[7];
	carry += vli_add(result, result, tmp);
    665a:	183f      	adds	r7, r7, r0

	/* s4 */
	tmp[0] = (product[4] >> 32) | (product[5] << 32);
    665c:	9305      	str	r3, [sp, #20]
	tmp[1] = (product[5] >> 32) | (product[6] & 0xffffffff00000000ull);
    665e:	6b63      	ldr	r3, [r4, #52]	; 0x34
    6660:	9206      	str	r2, [sp, #24]
    6662:	9307      	str	r3, [sp, #28]
	tmp[2] = product[7];
	tmp[3] = (product[6] >> 32) | (product[4] << 32);
    6664:	930a      	str	r3, [sp, #40]	; 0x28
    6666:	6a23      	ldr	r3, [r4, #32]
	carry += vli_add(result, result, tmp);

	/* s4 */
	tmp[0] = (product[4] >> 32) | (product[5] << 32);
	tmp[1] = (product[5] >> 32) | (product[6] & 0xffffffff00000000ull);
	tmp[2] = product[7];
    6668:	6ba1      	ldr	r1, [r4, #56]	; 0x38
    666a:	6be2      	ldr	r2, [r4, #60]	; 0x3c
	tmp[3] = (product[6] >> 32) | (product[4] << 32);
	carry += vli_add(result, result, tmp);
    666c:	0028      	movs	r0, r5
	carry += vli_add(result, result, tmp);

	/* s4 */
	tmp[0] = (product[4] >> 32) | (product[5] << 32);
	tmp[1] = (product[5] >> 32) | (product[6] & 0xffffffff00000000ull);
	tmp[2] = product[7];
    666e:	9108      	str	r1, [sp, #32]
    6670:	9209      	str	r2, [sp, #36]	; 0x24
	tmp[3] = (product[6] >> 32) | (product[4] << 32);
	carry += vli_add(result, result, tmp);
    6672:	aa04      	add	r2, sp, #16
    6674:	0029      	movs	r1, r5

	/* s4 */
	tmp[0] = (product[4] >> 32) | (product[5] << 32);
	tmp[1] = (product[5] >> 32) | (product[6] & 0xffffffff00000000ull);
	tmp[2] = product[7];
	tmp[3] = (product[6] >> 32) | (product[4] << 32);
    6676:	930b      	str	r3, [sp, #44]	; 0x2c
	carry += vli_add(result, result, tmp);
    6678:	f7ff ff0c 	bl	6494 <vli_add>

	/* d1 */
	tmp[0] = (product[5] >> 32) | (product[6] << 32);
    667c:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
	tmp[1] = (product[6] >> 32);
	tmp[2] = 0;
    667e:	2200      	movs	r2, #0
	tmp[2] = product[7];
	tmp[3] = (product[6] >> 32) | (product[4] << 32);
	carry += vli_add(result, result, tmp);

	/* d1 */
	tmp[0] = (product[5] >> 32) | (product[6] << 32);
    6680:	9304      	str	r3, [sp, #16]
    6682:	6b23      	ldr	r3, [r4, #48]	; 0x30
	/* s4 */
	tmp[0] = (product[4] >> 32) | (product[5] << 32);
	tmp[1] = (product[5] >> 32) | (product[6] & 0xffffffff00000000ull);
	tmp[2] = product[7];
	tmp[3] = (product[6] >> 32) | (product[4] << 32);
	carry += vli_add(result, result, tmp);
    6684:	183f      	adds	r7, r7, r0

	/* d1 */
	tmp[0] = (product[5] >> 32) | (product[6] << 32);
    6686:	9305      	str	r3, [sp, #20]
	tmp[1] = (product[6] >> 32);
    6688:	6b63      	ldr	r3, [r4, #52]	; 0x34
	tmp[2] = 0;
	tmp[3] = (product[4] & 0xffffffff) | (product[5] << 32);
	carry -= vli_sub(result, result, tmp);
    668a:	0029      	movs	r1, r5
	tmp[3] = (product[6] >> 32) | (product[4] << 32);
	carry += vli_add(result, result, tmp);

	/* d1 */
	tmp[0] = (product[5] >> 32) | (product[6] << 32);
	tmp[1] = (product[6] >> 32);
    668c:	9306      	str	r3, [sp, #24]
	tmp[2] = 0;
    668e:	2300      	movs	r3, #0
    6690:	9208      	str	r2, [sp, #32]
    6692:	9309      	str	r3, [sp, #36]	; 0x24
	tmp[3] = (product[4] & 0xffffffff) | (product[5] << 32);
    6694:	6a23      	ldr	r3, [r4, #32]
	carry -= vli_sub(result, result, tmp);
    6696:	aa04      	add	r2, sp, #16

	/* d1 */
	tmp[0] = (product[5] >> 32) | (product[6] << 32);
	tmp[1] = (product[6] >> 32);
	tmp[2] = 0;
	tmp[3] = (product[4] & 0xffffffff) | (product[5] << 32);
    6698:	930a      	str	r3, [sp, #40]	; 0x28
    669a:	6aa3      	ldr	r3, [r4, #40]	; 0x28
	carry -= vli_sub(result, result, tmp);
    669c:	0028      	movs	r0, r5

	/* d1 */
	tmp[0] = (product[5] >> 32) | (product[6] << 32);
	tmp[1] = (product[6] >> 32);
	tmp[2] = 0;
	tmp[3] = (product[4] & 0xffffffff) | (product[5] << 32);
    669e:	930b      	str	r3, [sp, #44]	; 0x2c
	tmp[3] = (product[6] >> 32) | (product[4] << 32);
	carry += vli_add(result, result, tmp);

	/* d1 */
	tmp[0] = (product[5] >> 32) | (product[6] << 32);
	tmp[1] = (product[6] >> 32);
    66a0:	9607      	str	r6, [sp, #28]
	tmp[2] = 0;
	tmp[3] = (product[4] & 0xffffffff) | (product[5] << 32);
	carry -= vli_sub(result, result, tmp);
    66a2:	f7ff ff25 	bl	64f0 <vli_sub>

	/* d2 */
	tmp[0] = product[6];
    66a6:	6b22      	ldr	r2, [r4, #48]	; 0x30
    66a8:	6b63      	ldr	r3, [r4, #52]	; 0x34
    66aa:	9204      	str	r2, [sp, #16]
    66ac:	9305      	str	r3, [sp, #20]
	tmp[1] = product[7];
    66ae:	6ba2      	ldr	r2, [r4, #56]	; 0x38
    66b0:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    66b2:	9206      	str	r2, [sp, #24]
    66b4:	9307      	str	r3, [sp, #28]
	tmp[2] = 0;
    66b6:	2200      	movs	r2, #0
    66b8:	2300      	movs	r3, #0
    66ba:	9208      	str	r2, [sp, #32]
    66bc:	9309      	str	r3, [sp, #36]	; 0x24
	tmp[3] = (product[4] >> 32) | (product[5] & 0xffffffff00000000ull);
    66be:	6a63      	ldr	r3, [r4, #36]	; 0x24
	/* d1 */
	tmp[0] = (product[5] >> 32) | (product[6] << 32);
	tmp[1] = (product[6] >> 32);
	tmp[2] = 0;
	tmp[3] = (product[4] & 0xffffffff) | (product[5] << 32);
	carry -= vli_sub(result, result, tmp);
    66c0:	1a3f      	subs	r7, r7, r0

	/* d2 */
	tmp[0] = product[6];
	tmp[1] = product[7];
	tmp[2] = 0;
	tmp[3] = (product[4] >> 32) | (product[5] & 0xffffffff00000000ull);
    66c2:	930a      	str	r3, [sp, #40]	; 0x28
    66c4:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
	carry -= vli_sub(result, result, tmp);
    66c6:	aa04      	add	r2, sp, #16
    66c8:	0029      	movs	r1, r5
    66ca:	0028      	movs	r0, r5

	/* d2 */
	tmp[0] = product[6];
	tmp[1] = product[7];
	tmp[2] = 0;
	tmp[3] = (product[4] >> 32) | (product[5] & 0xffffffff00000000ull);
    66cc:	930b      	str	r3, [sp, #44]	; 0x2c
	carry -= vli_sub(result, result, tmp);
    66ce:	f7ff ff0f 	bl	64f0 <vli_sub>

	/* d3 */
	tmp[0] = (product[6] >> 32) | (product[7] << 32);
    66d2:	6b63      	ldr	r3, [r4, #52]	; 0x34
	/* d2 */
	tmp[0] = product[6];
	tmp[1] = product[7];
	tmp[2] = 0;
	tmp[3] = (product[4] >> 32) | (product[5] & 0xffffffff00000000ull);
	carry -= vli_sub(result, result, tmp);
    66d4:	1a3f      	subs	r7, r7, r0

	/* d3 */
	tmp[0] = (product[6] >> 32) | (product[7] << 32);
    66d6:	9304      	str	r3, [sp, #16]
    66d8:	6ba3      	ldr	r3, [r4, #56]	; 0x38
	tmp[1] = (product[7] >> 32) | (product[4] << 32);
	tmp[2] = (product[4] >> 32) | (product[5] << 32);
	tmp[3] = (product[6] << 32);
	carry -= vli_sub(result, result, tmp);
    66da:	aa04      	add	r2, sp, #16
	tmp[2] = 0;
	tmp[3] = (product[4] >> 32) | (product[5] & 0xffffffff00000000ull);
	carry -= vli_sub(result, result, tmp);

	/* d3 */
	tmp[0] = (product[6] >> 32) | (product[7] << 32);
    66dc:	9305      	str	r3, [sp, #20]
	tmp[1] = (product[7] >> 32) | (product[4] << 32);
    66de:	6be3      	ldr	r3, [r4, #60]	; 0x3c
	tmp[2] = (product[4] >> 32) | (product[5] << 32);
	tmp[3] = (product[6] << 32);
	carry -= vli_sub(result, result, tmp);
    66e0:	0029      	movs	r1, r5
	tmp[3] = (product[4] >> 32) | (product[5] & 0xffffffff00000000ull);
	carry -= vli_sub(result, result, tmp);

	/* d3 */
	tmp[0] = (product[6] >> 32) | (product[7] << 32);
	tmp[1] = (product[7] >> 32) | (product[4] << 32);
    66e2:	9306      	str	r3, [sp, #24]
    66e4:	6a23      	ldr	r3, [r4, #32]
	tmp[2] = (product[4] >> 32) | (product[5] << 32);
	tmp[3] = (product[6] << 32);
	carry -= vli_sub(result, result, tmp);
    66e6:	0028      	movs	r0, r5
	tmp[3] = (product[4] >> 32) | (product[5] & 0xffffffff00000000ull);
	carry -= vli_sub(result, result, tmp);

	/* d3 */
	tmp[0] = (product[6] >> 32) | (product[7] << 32);
	tmp[1] = (product[7] >> 32) | (product[4] << 32);
    66e8:	9307      	str	r3, [sp, #28]
	tmp[2] = (product[4] >> 32) | (product[5] << 32);
    66ea:	6a63      	ldr	r3, [r4, #36]	; 0x24
	tmp[3] = (product[6] << 32);
    66ec:	960a      	str	r6, [sp, #40]	; 0x28
	carry -= vli_sub(result, result, tmp);

	/* d3 */
	tmp[0] = (product[6] >> 32) | (product[7] << 32);
	tmp[1] = (product[7] >> 32) | (product[4] << 32);
	tmp[2] = (product[4] >> 32) | (product[5] << 32);
    66ee:	9308      	str	r3, [sp, #32]
    66f0:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    66f2:	9309      	str	r3, [sp, #36]	; 0x24
	tmp[3] = (product[6] << 32);
    66f4:	6b23      	ldr	r3, [r4, #48]	; 0x30
    66f6:	930b      	str	r3, [sp, #44]	; 0x2c
	carry -= vli_sub(result, result, tmp);
    66f8:	f7ff fefa 	bl	64f0 <vli_sub>

	/* d4 */
	tmp[0] = product[7];
    66fc:	6ba2      	ldr	r2, [r4, #56]	; 0x38
    66fe:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    6700:	9204      	str	r2, [sp, #16]
    6702:	9305      	str	r3, [sp, #20]
	tmp[1] = product[4] & 0xffffffff00000000ull;
    6704:	6a63      	ldr	r3, [r4, #36]	; 0x24
	/* d3 */
	tmp[0] = (product[6] >> 32) | (product[7] << 32);
	tmp[1] = (product[7] >> 32) | (product[4] << 32);
	tmp[2] = (product[4] >> 32) | (product[5] << 32);
	tmp[3] = (product[6] << 32);
	carry -= vli_sub(result, result, tmp);
    6706:	1a3f      	subs	r7, r7, r0

	/* d4 */
	tmp[0] = product[7];
	tmp[1] = product[4] & 0xffffffff00000000ull;
    6708:	9307      	str	r3, [sp, #28]
	tmp[2] = product[5];
    670a:	6aa2      	ldr	r2, [r4, #40]	; 0x28
    670c:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    670e:	9208      	str	r2, [sp, #32]
    6710:	9309      	str	r3, [sp, #36]	; 0x24
	tmp[3] = product[6] & 0xffffffff00000000ull;
    6712:	6b63      	ldr	r3, [r4, #52]	; 0x34
	carry -= vli_sub(result, result, tmp);
    6714:	aa04      	add	r2, sp, #16
    6716:	0029      	movs	r1, r5
    6718:	0028      	movs	r0, r5
	tmp[3] = (product[6] << 32);
	carry -= vli_sub(result, result, tmp);

	/* d4 */
	tmp[0] = product[7];
	tmp[1] = product[4] & 0xffffffff00000000ull;
    671a:	9606      	str	r6, [sp, #24]
	tmp[2] = product[5];
	tmp[3] = product[6] & 0xffffffff00000000ull;
    671c:	960a      	str	r6, [sp, #40]	; 0x28
    671e:	9300      	str	r3, [sp, #0]
    6720:	930b      	str	r3, [sp, #44]	; 0x2c
	carry -= vli_sub(result, result, tmp);
    6722:	f7ff fee5 	bl	64f0 <vli_sub>
    6726:	4c0e      	ldr	r4, [pc, #56]	; (6760 <vli_mmod_fast+0x1fe>)
    6728:	1a3f      	subs	r7, r7, r0

	if (carry < 0) {
    672a:	42b7      	cmp	r7, r6
    672c:	da13      	bge.n	6756 <vli_mmod_fast+0x1f4>
		do {
			carry += vli_add(result, result, curve_p);
    672e:	0022      	movs	r2, r4
    6730:	0029      	movs	r1, r5
    6732:	0028      	movs	r0, r5
    6734:	f7ff feae 	bl	6494 <vli_add>
		} while (carry < 0);
    6738:	183f      	adds	r7, r7, r0
    673a:	d4f8      	bmi.n	672e <vli_mmod_fast+0x1cc>
    673c:	e00e      	b.n	675c <vli_mmod_fast+0x1fa>
	} else {
		while (carry || vli_cmp(curve_p, result) != 1)
    673e:	0029      	movs	r1, r5
    6740:	0020      	movs	r0, r4
    6742:	f7ff fe75 	bl	6430 <vli_cmp>
    6746:	2801      	cmp	r0, #1
    6748:	d008      	beq.n	675c <vli_mmod_fast+0x1fa>
			carry -= vli_sub(result, result, curve_p);
    674a:	0022      	movs	r2, r4
    674c:	0029      	movs	r1, r5
    674e:	0028      	movs	r0, r5
    6750:	f7ff fece 	bl	64f0 <vli_sub>
    6754:	1a3f      	subs	r7, r7, r0
	if (carry < 0) {
		do {
			carry += vli_add(result, result, curve_p);
		} while (carry < 0);
	} else {
		while (carry || vli_cmp(curve_p, result) != 1)
    6756:	2f00      	cmp	r7, #0
    6758:	d0f1      	beq.n	673e <vli_mmod_fast+0x1dc>
    675a:	e7f6      	b.n	674a <vli_mmod_fast+0x1e8>
			carry -= vli_sub(result, result, curve_p);
	}
}
    675c:	b00d      	add	sp, #52	; 0x34
    675e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    6760:	10010518 	.word	0x10010518

00006764 <vli_mod_mult_fast>:

/* Computes result = (left * right) % curve_p. */
static void vli_mod_mult_fast(uint64_t *result, const uint64_t *left,
							const uint64_t *right)
{
    6764:	b5f0      	push	{r4, r5, r6, r7, lr}
}

static void vli_mult(uint64_t *result, const uint64_t *left,
							const uint64_t *right)
{
	uint128_t r01 = { 0, 0 };
    6766:	2400      	movs	r4, #0
    6768:	2500      	movs	r5, #0
	unsigned int i, k;

	/* Compute each digit of result in sequence, maintaining the
	 * carries.
	 */
	for (k = 0; k < NUM_ECC_DIGITS * 2 - 1; k++) {
    676a:	2300      	movs	r3, #0
}

/* Computes result = (left * right) % curve_p. */
static void vli_mod_mult_fast(uint64_t *result, const uint64_t *left,
							const uint64_t *right)
{
    676c:	b0a9      	sub	sp, #164	; 0xa4
}

static void vli_mult(uint64_t *result, const uint64_t *left,
							const uint64_t *right)
{
	uint128_t r01 = { 0, 0 };
    676e:	9404      	str	r4, [sp, #16]
    6770:	9505      	str	r5, [sp, #20]
}

/* Computes result = (left * right) % curve_p. */
static void vli_mod_mult_fast(uint64_t *result, const uint64_t *left,
							const uint64_t *right)
{
    6772:	9013      	str	r0, [sp, #76]	; 0x4c
    6774:	9114      	str	r1, [sp, #80]	; 0x50
    6776:	9215      	str	r2, [sp, #84]	; 0x54
	unsigned int i, k;

	/* Compute each digit of result in sequence, maintaining the
	 * carries.
	 */
	for (k = 0; k < NUM_ECC_DIGITS * 2 - 1; k++) {
    6778:	9306      	str	r3, [sp, #24]
		unsigned int min;

		if (k < NUM_ECC_DIGITS)
			min = 0;
    677a:	9301      	str	r3, [sp, #4]
    677c:	9b01      	ldr	r3, [sp, #4]
    677e:	9a14      	ldr	r2, [sp, #80]	; 0x50
    6780:	00db      	lsls	r3, r3, #3
    6782:	18d3      	adds	r3, r2, r3
    6784:	9307      	str	r3, [sp, #28]
    6786:	9b06      	ldr	r3, [sp, #24]
    6788:	2200      	movs	r2, #0
    678a:	00db      	lsls	r3, r3, #3
    678c:	9310      	str	r3, [sp, #64]	; 0x40
    678e:	2300      	movs	r3, #0
    6790:	9402      	str	r4, [sp, #8]
    6792:	9503      	str	r5, [sp, #12]
    6794:	9c04      	ldr	r4, [sp, #16]
    6796:	9d05      	ldr	r5, [sp, #20]
    6798:	9204      	str	r2, [sp, #16]
    679a:	9305      	str	r3, [sp, #20]
		else
			min = (k + 1) - NUM_ECC_DIGITS;

		for (i = min; i <= k && i < NUM_ECC_DIGITS; i++) {
    679c:	9b06      	ldr	r3, [sp, #24]
    679e:	9a01      	ldr	r2, [sp, #4]
    67a0:	4293      	cmp	r3, r2
    67a2:	d214      	bcs.n	67ce <vli_mod_mult_fast+0x6a>

			r01 = add_128_128(r01, product);
			r2 += (r01.m_high < product.m_high);
		}

		result[k] = r01.m_low;
    67a4:	9b10      	ldr	r3, [sp, #64]	; 0x40
    67a6:	aa18      	add	r2, sp, #96	; 0x60
    67a8:	189b      	adds	r3, r3, r2
    67aa:	9902      	ldr	r1, [sp, #8]
    67ac:	9a03      	ldr	r2, [sp, #12]
    67ae:	6019      	str	r1, [r3, #0]
    67b0:	605a      	str	r2, [r3, #4]
	unsigned int i, k;

	/* Compute each digit of result in sequence, maintaining the
	 * carries.
	 */
	for (k = 0; k < NUM_ECC_DIGITS * 2 - 1; k++) {
    67b2:	9b06      	ldr	r3, [sp, #24]
    67b4:	3301      	adds	r3, #1
    67b6:	2b07      	cmp	r3, #7
    67b8:	d100      	bne.n	67bc <vli_mod_mult_fast+0x58>
    67ba:	e089      	b.n	68d0 <vli_mod_mult_fast+0x16c>
		unsigned int min;

		if (k < NUM_ECC_DIGITS)
			min = 0;
    67bc:	2200      	movs	r2, #0
    67be:	9201      	str	r2, [sp, #4]
	 * carries.
	 */
	for (k = 0; k < NUM_ECC_DIGITS * 2 - 1; k++) {
		unsigned int min;

		if (k < NUM_ECC_DIGITS)
    67c0:	2b03      	cmp	r3, #3
    67c2:	d902      	bls.n	67ca <vli_mod_mult_fast+0x66>
			min = 0;
		else
			min = (k + 1) - NUM_ECC_DIGITS;
    67c4:	9a06      	ldr	r2, [sp, #24]
    67c6:	3a02      	subs	r2, #2
    67c8:	9201      	str	r2, [sp, #4]
	 */
	for (k = 0; k < NUM_ECC_DIGITS * 2 - 1; k++) {
		unsigned int min;

		if (k < NUM_ECC_DIGITS)
			min = 0;
    67ca:	9306      	str	r3, [sp, #24]
    67cc:	e7d6      	b.n	677c <vli_mod_mult_fast+0x18>
		else
			min = (k + 1) - NUM_ECC_DIGITS;

		for (i = min; i <= k && i < NUM_ECC_DIGITS; i++) {
    67ce:	9b01      	ldr	r3, [sp, #4]
    67d0:	2b04      	cmp	r3, #4
    67d2:	d0e7      	beq.n	67a4 <vli_mod_mult_fast+0x40>
			uint128_t product;

			product = mul_64_64(left[i], right[k - i]);
    67d4:	9b07      	ldr	r3, [sp, #28]
    67d6:	9a10      	ldr	r2, [sp, #64]	; 0x40
    67d8:	681f      	ldr	r7, [r3, #0]
    67da:	685b      	ldr	r3, [r3, #4]
{
	uint64_t a0 = left & 0xffffffffull;
	uint64_t a1 = left >> 32;
	uint64_t b0 = right & 0xffffffffull;
	uint64_t b1 = right >> 32;
	uint64_t m0 = a0 * b0;
    67dc:	0038      	movs	r0, r7
			min = (k + 1) - NUM_ECC_DIGITS;

		for (i = min; i <= k && i < NUM_ECC_DIGITS; i++) {
			uint128_t product;

			product = mul_64_64(left[i], right[k - i]);
    67de:	9311      	str	r3, [sp, #68]	; 0x44
    67e0:	9b01      	ldr	r3, [sp, #4]
    67e2:	00db      	lsls	r3, r3, #3
    67e4:	1ad3      	subs	r3, r2, r3
    67e6:	9a15      	ldr	r2, [sp, #84]	; 0x54
    67e8:	18d3      	adds	r3, r2, r3
    67ea:	681a      	ldr	r2, [r3, #0]
    67ec:	685e      	ldr	r6, [r3, #4]
{
	uint64_t a0 = left & 0xffffffffull;
	uint64_t a1 = left >> 32;
	uint64_t b0 = right & 0xffffffffull;
	uint64_t b1 = right >> 32;
	uint64_t m0 = a0 * b0;
    67ee:	2300      	movs	r3, #0
    67f0:	0019      	movs	r1, r3
			min = (k + 1) - NUM_ECC_DIGITS;

		for (i = min; i <= k && i < NUM_ECC_DIGITS; i++) {
			uint128_t product;

			product = mul_64_64(left[i], right[k - i]);
    67f2:	9212      	str	r2, [sp, #72]	; 0x48
{
	uint64_t a0 = left & 0xffffffffull;
	uint64_t a1 = left >> 32;
	uint64_t b0 = right & 0xffffffffull;
	uint64_t b1 = right >> 32;
	uint64_t m0 = a0 * b0;
    67f4:	f017 fb6a 	bl	1decc <__aeabi_lmul>
	uint64_t m1 = a0 * b1;
    67f8:	2300      	movs	r3, #0
    67fa:	0032      	movs	r2, r6
{
	uint64_t a0 = left & 0xffffffffull;
	uint64_t a1 = left >> 32;
	uint64_t b0 = right & 0xffffffffull;
	uint64_t b1 = right >> 32;
	uint64_t m0 = a0 * b0;
    67fc:	9016      	str	r0, [sp, #88]	; 0x58
    67fe:	9117      	str	r1, [sp, #92]	; 0x5c
	uint64_t m1 = a0 * b1;
    6800:	0038      	movs	r0, r7
    6802:	0019      	movs	r1, r3
    6804:	f017 fb62 	bl	1decc <__aeabi_lmul>
	uint64_t m2 = a1 * b0;
	uint64_t m3 = a1 * b1;
    6808:	2300      	movs	r3, #0
	uint64_t a0 = left & 0xffffffffull;
	uint64_t a1 = left >> 32;
	uint64_t b0 = right & 0xffffffffull;
	uint64_t b1 = right >> 32;
	uint64_t m0 = a0 * b0;
	uint64_t m1 = a0 * b1;
    680a:	9008      	str	r0, [sp, #32]
    680c:	9109      	str	r1, [sp, #36]	; 0x24
	uint64_t m2 = a1 * b0;
	uint64_t m3 = a1 * b1;
    680e:	0032      	movs	r2, r6
    6810:	0019      	movs	r1, r3
    6812:	9811      	ldr	r0, [sp, #68]	; 0x44
    6814:	f017 fb5a 	bl	1decc <__aeabi_lmul>
    6818:	2300      	movs	r3, #0
    681a:	9a12      	ldr	r2, [sp, #72]	; 0x48
    681c:	0006      	movs	r6, r0
    681e:	000f      	movs	r7, r1
    6820:	9811      	ldr	r0, [sp, #68]	; 0x44
    6822:	0019      	movs	r1, r3
    6824:	f017 fb52 	bl	1decc <__aeabi_lmul>
    6828:	9a08      	ldr	r2, [sp, #32]
    682a:	9b09      	ldr	r3, [sp, #36]	; 0x24
    682c:	1880      	adds	r0, r0, r2
    682e:	4159      	adcs	r1, r3
	uint128_t result;

	m2 += (m0 >> 32);
	m2 += m1;
    6830:	9b17      	ldr	r3, [sp, #92]	; 0x5c
    6832:	930a      	str	r3, [sp, #40]	; 0x28
    6834:	2300      	movs	r3, #0
    6836:	930b      	str	r3, [sp, #44]	; 0x2c
    6838:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    683a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    683c:	1880      	adds	r0, r0, r2
    683e:	4159      	adcs	r1, r3

	/* Overflow */
	if (m2 < m1)
    6840:	9b09      	ldr	r3, [sp, #36]	; 0x24
    6842:	428b      	cmp	r3, r1
    6844:	d803      	bhi.n	684e <vli_mod_mult_fast+0xea>
    6846:	d106      	bne.n	6856 <vli_mod_mult_fast+0xf2>
    6848:	9b08      	ldr	r3, [sp, #32]
    684a:	4283      	cmp	r3, r0
    684c:	d903      	bls.n	6856 <vli_mod_mult_fast+0xf2>
		m3 += 0x100000000ull;
    684e:	2200      	movs	r2, #0
    6850:	2301      	movs	r3, #1
    6852:	18b6      	adds	r6, r6, r2
    6854:	415f      	adcs	r7, r3

	result.m_low = (m0 & 0xffffffffull) | (m2 << 32);
	result.m_high = m3 + (m2 >> 32);
    6856:	2300      	movs	r3, #0
    6858:	910c      	str	r1, [sp, #48]	; 0x30
    685a:	930d      	str	r3, [sp, #52]	; 0x34
    685c:	9a0c      	ldr	r2, [sp, #48]	; 0x30
    685e:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    6860:	18b6      	adds	r6, r6, r2
    6862:	415f      	adcs	r7, r3

static uint128_t add_128_128(uint128_t a, uint128_t b)
{
	uint128_t result;

	result.m_low = a.m_low + b.m_low;
    6864:	9b16      	ldr	r3, [sp, #88]	; 0x58
    6866:	900f      	str	r0, [sp, #60]	; 0x3c
    6868:	930e      	str	r3, [sp, #56]	; 0x38
    686a:	980e      	ldr	r0, [sp, #56]	; 0x38
    686c:	990f      	ldr	r1, [sp, #60]	; 0x3c
    686e:	9a02      	ldr	r2, [sp, #8]
    6870:	9b03      	ldr	r3, [sp, #12]
    6872:	1880      	adds	r0, r0, r2
    6874:	4159      	adcs	r1, r3
    6876:	2300      	movs	r3, #0
    6878:	2201      	movs	r2, #1
    687a:	9208      	str	r2, [sp, #32]
    687c:	9309      	str	r3, [sp, #36]	; 0x24
    687e:	9b03      	ldr	r3, [sp, #12]
    6880:	428b      	cmp	r3, r1
    6882:	d807      	bhi.n	6894 <vli_mod_mult_fast+0x130>
    6884:	d102      	bne.n	688c <vli_mod_mult_fast+0x128>
    6886:	9b02      	ldr	r3, [sp, #8]
    6888:	4283      	cmp	r3, r0
    688a:	d803      	bhi.n	6894 <vli_mod_mult_fast+0x130>
    688c:	2200      	movs	r2, #0
    688e:	2300      	movs	r3, #0
    6890:	9208      	str	r2, [sp, #32]
    6892:	9309      	str	r3, [sp, #36]	; 0x24
    6894:	9a08      	ldr	r2, [sp, #32]
    6896:	9b09      	ldr	r3, [sp, #36]	; 0x24
    6898:	1992      	adds	r2, r2, r6
    689a:	417b      	adcs	r3, r7
	result.m_high = a.m_high + b.m_high + (result.m_low < a.m_low);
    689c:	18a4      	adds	r4, r4, r2
    689e:	415d      	adcs	r5, r3
			uint128_t product;

			product = mul_64_64(left[i], right[k - i]);

			r01 = add_128_128(r01, product);
			r2 += (r01.m_high < product.m_high);
    68a0:	2201      	movs	r2, #1
    68a2:	2300      	movs	r3, #0
    68a4:	42af      	cmp	r7, r5
    68a6:	d804      	bhi.n	68b2 <vli_mod_mult_fast+0x14e>
    68a8:	d101      	bne.n	68ae <vli_mod_mult_fast+0x14a>
    68aa:	42a6      	cmp	r6, r4
    68ac:	d801      	bhi.n	68b2 <vli_mod_mult_fast+0x14e>
    68ae:	2200      	movs	r2, #0
    68b0:	2300      	movs	r3, #0
    68b2:	9e04      	ldr	r6, [sp, #16]
    68b4:	9f05      	ldr	r7, [sp, #20]
    68b6:	18b6      	adds	r6, r6, r2
    68b8:	415f      	adcs	r7, r3
		if (k < NUM_ECC_DIGITS)
			min = 0;
		else
			min = (k + 1) - NUM_ECC_DIGITS;

		for (i = min; i <= k && i < NUM_ECC_DIGITS; i++) {
    68ba:	9b01      	ldr	r3, [sp, #4]
			uint128_t product;

			product = mul_64_64(left[i], right[k - i]);

			r01 = add_128_128(r01, product);
			r2 += (r01.m_high < product.m_high);
    68bc:	9604      	str	r6, [sp, #16]
    68be:	9705      	str	r7, [sp, #20]
		if (k < NUM_ECC_DIGITS)
			min = 0;
		else
			min = (k + 1) - NUM_ECC_DIGITS;

		for (i = min; i <= k && i < NUM_ECC_DIGITS; i++) {
    68c0:	3301      	adds	r3, #1
    68c2:	9301      	str	r3, [sp, #4]
    68c4:	9b07      	ldr	r3, [sp, #28]
	uint128_t result;

	result.m_low = a.m_low + b.m_low;
	result.m_high = a.m_high + b.m_high + (result.m_low < a.m_low);

	return result;
    68c6:	9002      	str	r0, [sp, #8]
    68c8:	9103      	str	r1, [sp, #12]
    68ca:	3308      	adds	r3, #8
    68cc:	9307      	str	r3, [sp, #28]
    68ce:	e765      	b.n	679c <vli_mod_mult_fast+0x38>
							const uint64_t *right)
{
	uint64_t product[2 * NUM_ECC_DIGITS];

	vli_mult(product, left, right);
	vli_mmod_fast(result, product);
    68d0:	a918      	add	r1, sp, #96	; 0x60
    68d2:	9813      	ldr	r0, [sp, #76]	; 0x4c
		r01.m_low = r01.m_high;
		r01.m_high = r2;
		r2 = 0;
	}

	result[NUM_ECC_DIGITS * 2 - 1] = r01.m_low;
    68d4:	9426      	str	r4, [sp, #152]	; 0x98
    68d6:	9527      	str	r5, [sp, #156]	; 0x9c
							const uint64_t *right)
{
	uint64_t product[2 * NUM_ECC_DIGITS];

	vli_mult(product, left, right);
	vli_mmod_fast(result, product);
    68d8:	f7ff fe43 	bl	6562 <vli_mmod_fast>
}
    68dc:	b029      	add	sp, #164	; 0xa4
    68de:	bdf0      	pop	{r4, r5, r6, r7, pc}

000068e0 <vli_mod_square_fast>:

/* Computes result = left^2 % curve_p. */
static void vli_mod_square_fast(uint64_t *result, const uint64_t *left)
{
    68e0:	b5f0      	push	{r4, r5, r6, r7, lr}
	result[NUM_ECC_DIGITS * 2 - 1] = r01.m_low;
}

static void vli_square(uint64_t *result, const uint64_t *left)
{
	uint128_t r01 = { 0, 0 };
    68e2:	2400      	movs	r4, #0
    68e4:	2500      	movs	r5, #0
	uint64_t r2 = 0;
	int i, k;

	for (k = 0; k < NUM_ECC_DIGITS * 2 - 1; k++) {
    68e6:	2300      	movs	r3, #0
	vli_mmod_fast(result, product);
}

/* Computes result = left^2 % curve_p. */
static void vli_mod_square_fast(uint64_t *result, const uint64_t *left)
{
    68e8:	b0a9      	sub	sp, #164	; 0xa4
	result[NUM_ECC_DIGITS * 2 - 1] = r01.m_low;
}

static void vli_square(uint64_t *result, const uint64_t *left)
{
	uint128_t r01 = { 0, 0 };
    68ea:	9400      	str	r4, [sp, #0]
    68ec:	9501      	str	r5, [sp, #4]
	vli_mmod_fast(result, product);
}

/* Computes result = left^2 % curve_p. */
static void vli_mod_square_fast(uint64_t *result, const uint64_t *left)
{
    68ee:	9015      	str	r0, [sp, #84]	; 0x54
    68f0:	9112      	str	r1, [sp, #72]	; 0x48
{
	uint128_t r01 = { 0, 0 };
	uint64_t r2 = 0;
	int i, k;

	for (k = 0; k < NUM_ECC_DIGITS * 2 - 1; k++) {
    68f2:	9303      	str	r3, [sp, #12]
		if (k < NUM_ECC_DIGITS)
			min = 0;
		else
			min = (k + 1) - NUM_ECC_DIGITS;

		for (i = min; i <= k && i <= k - i; i++) {
    68f4:	9308      	str	r3, [sp, #32]
    68f6:	9a08      	ldr	r2, [sp, #32]
    68f8:	9b03      	ldr	r3, [sp, #12]
    68fa:	1a9b      	subs	r3, r3, r2
    68fc:	9309      	str	r3, [sp, #36]	; 0x24
    68fe:	9a00      	ldr	r2, [sp, #0]
    6900:	9b01      	ldr	r3, [sp, #4]
    6902:	9400      	str	r4, [sp, #0]
    6904:	9501      	str	r5, [sp, #4]
    6906:	2400      	movs	r4, #0
    6908:	2500      	movs	r5, #0
    690a:	9204      	str	r2, [sp, #16]
    690c:	9305      	str	r3, [sp, #20]
    690e:	9b08      	ldr	r3, [sp, #32]
    6910:	9a03      	ldr	r2, [sp, #12]
    6912:	4293      	cmp	r3, r2
    6914:	dd17      	ble.n	6946 <vli_mod_square_fast+0x66>

			r01 = add_128_128(r01, product);
			r2 += (r01.m_high < product.m_high);
		}

		result[k] = r01.m_low;
    6916:	9b03      	ldr	r3, [sp, #12]
    6918:	aa18      	add	r2, sp, #96	; 0x60
    691a:	00db      	lsls	r3, r3, #3
    691c:	189b      	adds	r3, r3, r2
    691e:	9904      	ldr	r1, [sp, #16]
    6920:	9a05      	ldr	r2, [sp, #20]
    6922:	6019      	str	r1, [r3, #0]
    6924:	605a      	str	r2, [r3, #4]
{
	uint128_t r01 = { 0, 0 };
	uint64_t r2 = 0;
	int i, k;

	for (k = 0; k < NUM_ECC_DIGITS * 2 - 1; k++) {
    6926:	9b03      	ldr	r3, [sp, #12]
    6928:	3301      	adds	r3, #1
    692a:	9303      	str	r3, [sp, #12]
    692c:	2b07      	cmp	r3, #7
    692e:	d100      	bne.n	6932 <vli_mod_square_fast+0x52>
    6930:	e0a9      	b.n	6a86 <vli_mod_square_fast+0x1a6>
		unsigned int min;

		if (k < NUM_ECC_DIGITS)
    6932:	9a03      	ldr	r2, [sp, #12]
			min = 0;
    6934:	2300      	movs	r3, #0
	int i, k;

	for (k = 0; k < NUM_ECC_DIGITS * 2 - 1; k++) {
		unsigned int min;

		if (k < NUM_ECC_DIGITS)
    6936:	2a03      	cmp	r2, #3
    6938:	dd01      	ble.n	693e <vli_mod_square_fast+0x5e>
    693a:	0013      	movs	r3, r2
    693c:	3b03      	subs	r3, #3
    693e:	9a12      	ldr	r2, [sp, #72]	; 0x48
    6940:	3208      	adds	r2, #8
    6942:	9212      	str	r2, [sp, #72]	; 0x48
    6944:	e7d6      	b.n	68f4 <vli_mod_square_fast+0x14>
			min = 0;
		else
			min = (k + 1) - NUM_ECC_DIGITS;

		for (i = min; i <= k && i <= k - i; i++) {
    6946:	9b08      	ldr	r3, [sp, #32]
    6948:	9a09      	ldr	r2, [sp, #36]	; 0x24
    694a:	4293      	cmp	r3, r2
    694c:	dce3      	bgt.n	6916 <vli_mod_square_fast+0x36>
			uint128_t product;

			product = mul_64_64(left[i], left[k - i]);
    694e:	9b09      	ldr	r3, [sp, #36]	; 0x24
    6950:	9a12      	ldr	r2, [sp, #72]	; 0x48
    6952:	00db      	lsls	r3, r3, #3
    6954:	1ad3      	subs	r3, r2, r3
    6956:	681f      	ldr	r7, [r3, #0]
    6958:	685b      	ldr	r3, [r3, #4]
{
	uint64_t a0 = left & 0xffffffffull;
	uint64_t a1 = left >> 32;
	uint64_t b0 = right & 0xffffffffull;
	uint64_t b1 = right >> 32;
	uint64_t m0 = a0 * b0;
    695a:	0038      	movs	r0, r7
			min = (k + 1) - NUM_ECC_DIGITS;

		for (i = min; i <= k && i <= k - i; i++) {
			uint128_t product;

			product = mul_64_64(left[i], left[k - i]);
    695c:	9313      	str	r3, [sp, #76]	; 0x4c
    695e:	9b08      	ldr	r3, [sp, #32]
    6960:	00db      	lsls	r3, r3, #3
    6962:	1ad3      	subs	r3, r2, r3
    6964:	681a      	ldr	r2, [r3, #0]
    6966:	685e      	ldr	r6, [r3, #4]
{
	uint64_t a0 = left & 0xffffffffull;
	uint64_t a1 = left >> 32;
	uint64_t b0 = right & 0xffffffffull;
	uint64_t b1 = right >> 32;
	uint64_t m0 = a0 * b0;
    6968:	2300      	movs	r3, #0
    696a:	0019      	movs	r1, r3
			min = (k + 1) - NUM_ECC_DIGITS;

		for (i = min; i <= k && i <= k - i; i++) {
			uint128_t product;

			product = mul_64_64(left[i], left[k - i]);
    696c:	9214      	str	r2, [sp, #80]	; 0x50
{
	uint64_t a0 = left & 0xffffffffull;
	uint64_t a1 = left >> 32;
	uint64_t b0 = right & 0xffffffffull;
	uint64_t b1 = right >> 32;
	uint64_t m0 = a0 * b0;
    696e:	f017 faad 	bl	1decc <__aeabi_lmul>
	uint64_t m1 = a0 * b1;
    6972:	2300      	movs	r3, #0
    6974:	0032      	movs	r2, r6
{
	uint64_t a0 = left & 0xffffffffull;
	uint64_t a1 = left >> 32;
	uint64_t b0 = right & 0xffffffffull;
	uint64_t b1 = right >> 32;
	uint64_t m0 = a0 * b0;
    6976:	9016      	str	r0, [sp, #88]	; 0x58
    6978:	9117      	str	r1, [sp, #92]	; 0x5c
	uint64_t m1 = a0 * b1;
    697a:	0038      	movs	r0, r7
    697c:	0019      	movs	r1, r3
    697e:	f017 faa5 	bl	1decc <__aeabi_lmul>
	uint64_t m2 = a1 * b0;
	uint64_t m3 = a1 * b1;
    6982:	2300      	movs	r3, #0
	uint64_t a0 = left & 0xffffffffull;
	uint64_t a1 = left >> 32;
	uint64_t b0 = right & 0xffffffffull;
	uint64_t b1 = right >> 32;
	uint64_t m0 = a0 * b0;
	uint64_t m1 = a0 * b1;
    6984:	900a      	str	r0, [sp, #40]	; 0x28
    6986:	910b      	str	r1, [sp, #44]	; 0x2c
	uint64_t m2 = a1 * b0;
	uint64_t m3 = a1 * b1;
    6988:	0032      	movs	r2, r6
    698a:	0019      	movs	r1, r3
    698c:	9813      	ldr	r0, [sp, #76]	; 0x4c
    698e:	f017 fa9d 	bl	1decc <__aeabi_lmul>
    6992:	2300      	movs	r3, #0
    6994:	9a14      	ldr	r2, [sp, #80]	; 0x50
    6996:	0006      	movs	r6, r0
    6998:	000f      	movs	r7, r1
    699a:	9813      	ldr	r0, [sp, #76]	; 0x4c
    699c:	0019      	movs	r1, r3
    699e:	f017 fa95 	bl	1decc <__aeabi_lmul>
    69a2:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    69a4:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    69a6:	1880      	adds	r0, r0, r2
    69a8:	4159      	adcs	r1, r3
	uint128_t result;

	m2 += (m0 >> 32);
	m2 += m1;
    69aa:	9b17      	ldr	r3, [sp, #92]	; 0x5c
    69ac:	930e      	str	r3, [sp, #56]	; 0x38
    69ae:	2300      	movs	r3, #0
    69b0:	930f      	str	r3, [sp, #60]	; 0x3c
    69b2:	9a0e      	ldr	r2, [sp, #56]	; 0x38
    69b4:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    69b6:	1880      	adds	r0, r0, r2
    69b8:	4159      	adcs	r1, r3

	/* Overflow */
	if (m2 < m1)
    69ba:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    69bc:	428b      	cmp	r3, r1
    69be:	d803      	bhi.n	69c8 <vli_mod_square_fast+0xe8>
    69c0:	d106      	bne.n	69d0 <vli_mod_square_fast+0xf0>
    69c2:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    69c4:	4283      	cmp	r3, r0
    69c6:	d903      	bls.n	69d0 <vli_mod_square_fast+0xf0>
		m3 += 0x100000000ull;
    69c8:	2200      	movs	r2, #0
    69ca:	2301      	movs	r3, #1
    69cc:	18b6      	adds	r6, r6, r2
    69ce:	415f      	adcs	r7, r3

	result.m_low = (m0 & 0xffffffffull) | (m2 << 32);
    69d0:	9b16      	ldr	r3, [sp, #88]	; 0x58
	result.m_high = m3 + (m2 >> 32);
    69d2:	910c      	str	r1, [sp, #48]	; 0x30

	/* Overflow */
	if (m2 < m1)
		m3 += 0x100000000ull;

	result.m_low = (m0 & 0xffffffffull) | (m2 << 32);
    69d4:	9306      	str	r3, [sp, #24]
	result.m_high = m3 + (m2 >> 32);
    69d6:	2300      	movs	r3, #0
    69d8:	930d      	str	r3, [sp, #52]	; 0x34
    69da:	9a0c      	ldr	r2, [sp, #48]	; 0x30
    69dc:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    69de:	18b6      	adds	r6, r6, r2
    69e0:	415f      	adcs	r7, r3
		for (i = min; i <= k && i <= k - i; i++) {
			uint128_t product;

			product = mul_64_64(left[i], left[k - i]);

			if (i < k - i) {
    69e2:	9b08      	ldr	r3, [sp, #32]
    69e4:	9a09      	ldr	r2, [sp, #36]	; 0x24

	/* Overflow */
	if (m2 < m1)
		m3 += 0x100000000ull;

	result.m_low = (m0 & 0xffffffffull) | (m2 << 32);
    69e6:	9007      	str	r0, [sp, #28]
		for (i = min; i <= k && i <= k - i; i++) {
			uint128_t product;

			product = mul_64_64(left[i], left[k - i]);

			if (i < k - i) {
    69e8:	4293      	cmp	r3, r2
    69ea:	da17      	bge.n	6a1c <vli_mod_square_fast+0x13c>
				r2 += product.m_high >> 63;
    69ec:	0ffb      	lsrs	r3, r7, #31
    69ee:	9310      	str	r3, [sp, #64]	; 0x40
    69f0:	2300      	movs	r3, #0
    69f2:	9311      	str	r3, [sp, #68]	; 0x44
    69f4:	9a10      	ldr	r2, [sp, #64]	; 0x40
    69f6:	9b11      	ldr	r3, [sp, #68]	; 0x44
    69f8:	18a4      	adds	r4, r4, r2
    69fa:	415d      	adcs	r5, r3
				product.m_high = (product.m_high << 1) |
    69fc:	0032      	movs	r2, r6
    69fe:	003b      	movs	r3, r7
    6a00:	1992      	adds	r2, r2, r6
    6a02:	417b      	adcs	r3, r7
    6a04:	0fc1      	lsrs	r1, r0, #31
    6a06:	4311      	orrs	r1, r2
    6a08:	000e      	movs	r6, r1
    6a0a:	001f      	movs	r7, r3
							(product.m_low >> 63);
				product.m_low <<= 1;
    6a0c:	9a06      	ldr	r2, [sp, #24]
    6a0e:	9b07      	ldr	r3, [sp, #28]
    6a10:	0010      	movs	r0, r2
    6a12:	0019      	movs	r1, r3
    6a14:	1812      	adds	r2, r2, r0
    6a16:	414b      	adcs	r3, r1
    6a18:	9206      	str	r2, [sp, #24]
    6a1a:	9307      	str	r3, [sp, #28]

static uint128_t add_128_128(uint128_t a, uint128_t b)
{
	uint128_t result;

	result.m_low = a.m_low + b.m_low;
    6a1c:	9a06      	ldr	r2, [sp, #24]
    6a1e:	9b07      	ldr	r3, [sp, #28]
    6a20:	9804      	ldr	r0, [sp, #16]
    6a22:	9905      	ldr	r1, [sp, #20]
    6a24:	1880      	adds	r0, r0, r2
    6a26:	4159      	adcs	r1, r3
    6a28:	900a      	str	r0, [sp, #40]	; 0x28
    6a2a:	910b      	str	r1, [sp, #44]	; 0x2c
    6a2c:	980b      	ldr	r0, [sp, #44]	; 0x2c
    6a2e:	9905      	ldr	r1, [sp, #20]
    6a30:	2201      	movs	r2, #1
    6a32:	2300      	movs	r3, #0
    6a34:	4281      	cmp	r1, r0
    6a36:	d806      	bhi.n	6a46 <vli_mod_square_fast+0x166>
    6a38:	d103      	bne.n	6a42 <vli_mod_square_fast+0x162>
    6a3a:	9904      	ldr	r1, [sp, #16]
    6a3c:	980a      	ldr	r0, [sp, #40]	; 0x28
    6a3e:	4281      	cmp	r1, r0
    6a40:	d801      	bhi.n	6a46 <vli_mod_square_fast+0x166>
    6a42:	2200      	movs	r2, #0
    6a44:	2300      	movs	r3, #0
	result.m_high = a.m_high + b.m_high + (result.m_low < a.m_low);
    6a46:	9800      	ldr	r0, [sp, #0]
    6a48:	9901      	ldr	r1, [sp, #4]
    6a4a:	1992      	adds	r2, r2, r6
    6a4c:	417b      	adcs	r3, r7
    6a4e:	1880      	adds	r0, r0, r2
    6a50:	4159      	adcs	r1, r3
    6a52:	9000      	str	r0, [sp, #0]
    6a54:	9101      	str	r1, [sp, #4]
							(product.m_low >> 63);
				product.m_low <<= 1;
			}

			r01 = add_128_128(r01, product);
			r2 += (r01.m_high < product.m_high);
    6a56:	9901      	ldr	r1, [sp, #4]
    6a58:	2201      	movs	r2, #1
    6a5a:	2300      	movs	r3, #0
    6a5c:	428f      	cmp	r7, r1
    6a5e:	d805      	bhi.n	6a6c <vli_mod_square_fast+0x18c>
    6a60:	d102      	bne.n	6a68 <vli_mod_square_fast+0x188>
    6a62:	9900      	ldr	r1, [sp, #0]
    6a64:	428e      	cmp	r6, r1
    6a66:	d801      	bhi.n	6a6c <vli_mod_square_fast+0x18c>
    6a68:	2200      	movs	r2, #0
    6a6a:	2300      	movs	r3, #0
    6a6c:	18a4      	adds	r4, r4, r2
    6a6e:	415d      	adcs	r5, r3
		if (k < NUM_ECC_DIGITS)
			min = 0;
		else
			min = (k + 1) - NUM_ECC_DIGITS;

		for (i = min; i <= k && i <= k - i; i++) {
    6a70:	9b08      	ldr	r3, [sp, #32]
    6a72:	3301      	adds	r3, #1
    6a74:	9308      	str	r3, [sp, #32]
    6a76:	9b09      	ldr	r3, [sp, #36]	; 0x24
    6a78:	3b01      	subs	r3, #1
    6a7a:	9309      	str	r3, [sp, #36]	; 0x24
	uint128_t result;

	result.m_low = a.m_low + b.m_low;
	result.m_high = a.m_high + b.m_high + (result.m_low < a.m_low);

	return result;
    6a7c:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    6a7e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    6a80:	9204      	str	r2, [sp, #16]
    6a82:	9305      	str	r3, [sp, #20]
    6a84:	e743      	b.n	690e <vli_mod_square_fast+0x2e>
static void vli_mod_square_fast(uint64_t *result, const uint64_t *left)
{
	uint64_t product[2 * NUM_ECC_DIGITS];

	vli_square(product, left);
	vli_mmod_fast(result, product);
    6a86:	a918      	add	r1, sp, #96	; 0x60
    6a88:	9815      	ldr	r0, [sp, #84]	; 0x54
		r01.m_low = r01.m_high;
		r01.m_high = r2;
		r2 = 0;
	}

	result[NUM_ECC_DIGITS * 2 - 1] = r01.m_low;
    6a8a:	9b00      	ldr	r3, [sp, #0]
    6a8c:	9c01      	ldr	r4, [sp, #4]
    6a8e:	9326      	str	r3, [sp, #152]	; 0x98
    6a90:	9427      	str	r4, [sp, #156]	; 0x9c
static void vli_mod_square_fast(uint64_t *result, const uint64_t *left)
{
	uint64_t product[2 * NUM_ECC_DIGITS];

	vli_square(product, left);
	vli_mmod_fast(result, product);
    6a92:	f7ff fd66 	bl	6562 <vli_mmod_fast>
}
    6a96:	b029      	add	sp, #164	; 0xa4
    6a98:	bdf0      	pop	{r4, r5, r6, r7, pc}

00006a9a <ecc_point_is_zero>:

/* ------ Point operations ------ */

/* Returns true if p_point is the point at infinity, false otherwise. */
static bool ecc_point_is_zero(const struct ecc_point *point)
{
    6a9a:	b510      	push	{r4, lr}
    6a9c:	0004      	movs	r4, r0
	return (vli_is_zero(point->x) && vli_is_zero(point->y));
    6a9e:	f7ff fc88 	bl	63b2 <vli_is_zero>
    6aa2:	0003      	movs	r3, r0
    6aa4:	2000      	movs	r0, #0
    6aa6:	4283      	cmp	r3, r0
    6aa8:	d003      	beq.n	6ab2 <ecc_point_is_zero+0x18>
    6aaa:	0020      	movs	r0, r4
    6aac:	3020      	adds	r0, #32
    6aae:	f7ff fc80 	bl	63b2 <vli_is_zero>
    6ab2:	2301      	movs	r3, #1
    6ab4:	4018      	ands	r0, r3
}
    6ab6:	bd10      	pop	{r4, pc}

00006ab8 <apply_z>:
	vli_set(y1, t4);
}

/* Modify (x1, y1) => (x1 * z^2, y1 * z^3) */
static void apply_z(uint64_t *x1, uint64_t *y1, uint64_t *z)
{
    6ab8:	b570      	push	{r4, r5, r6, lr}
    6aba:	0006      	movs	r6, r0
    6abc:	0015      	movs	r5, r2
    6abe:	000c      	movs	r4, r1
    6ac0:	b088      	sub	sp, #32
	uint64_t t1[NUM_ECC_DIGITS];

	vli_mod_square_fast(t1, z);    /* z^2 */
    6ac2:	0011      	movs	r1, r2
    6ac4:	4668      	mov	r0, sp
    6ac6:	f7ff ff0b 	bl	68e0 <vli_mod_square_fast>
	vli_mod_mult_fast(x1, x1, t1); /* x1 * z^2 */
    6aca:	466a      	mov	r2, sp
    6acc:	0031      	movs	r1, r6
    6ace:	0030      	movs	r0, r6
    6ad0:	f7ff fe48 	bl	6764 <vli_mod_mult_fast>
	vli_mod_mult_fast(t1, t1, z);  /* z^3 */
    6ad4:	002a      	movs	r2, r5
    6ad6:	4669      	mov	r1, sp
    6ad8:	4668      	mov	r0, sp
    6ada:	f7ff fe43 	bl	6764 <vli_mod_mult_fast>
	vli_mod_mult_fast(y1, y1, t1); /* y1 * z^3 */
    6ade:	466a      	mov	r2, sp
    6ae0:	0021      	movs	r1, r4
    6ae2:	0020      	movs	r0, r4
    6ae4:	f7ff fe3e 	bl	6764 <vli_mod_mult_fast>
}
    6ae8:	b008      	add	sp, #32
    6aea:	bd70      	pop	{r4, r5, r6, pc}

00006aec <xycz_add>:
/* Input P = (x1, y1, Z), Q = (x2, y2, Z)
 * Output P' = (x1', y1', Z3), P + Q = (x3, y3, Z3)
 * or P => P', Q => P + Q
 */
static void xycz_add(uint64_t *x1, uint64_t *y1, uint64_t *x2, uint64_t *y2)
{
    6aec:	b5f0      	push	{r4, r5, r6, r7, lr}
    6aee:	0014      	movs	r4, r2
    6af0:	0006      	movs	r6, r0
    6af2:	001d      	movs	r5, r3
    6af4:	000f      	movs	r7, r1
    6af6:	b089      	sub	sp, #36	; 0x24
	/* t1 = X1, t2 = Y1, t3 = X2, t4 = Y2 */
	uint64_t t5[NUM_ECC_DIGITS];

	vli_mod_sub(t5, x2, x1, curve_p); /* t5 = x2 - x1 */
    6af8:	0002      	movs	r2, r0
    6afa:	0021      	movs	r1, r4
    6afc:	4668      	mov	r0, sp
    6afe:	f000 fbcb 	bl	7298 <vli_mod_sub.constprop.1>
	vli_mod_square_fast(t5, t5);      /* t5 = (x2 - x1)^2 = A */
    6b02:	4669      	mov	r1, sp
    6b04:	4668      	mov	r0, sp
    6b06:	f7ff feeb 	bl	68e0 <vli_mod_square_fast>
	vli_mod_mult_fast(x1, x1, t5);    /* t1 = x1*A = B */
    6b0a:	466a      	mov	r2, sp
    6b0c:	0031      	movs	r1, r6
    6b0e:	0030      	movs	r0, r6
    6b10:	f7ff fe28 	bl	6764 <vli_mod_mult_fast>
	vli_mod_mult_fast(x2, x2, t5);    /* t3 = x2*A = C */
    6b14:	466a      	mov	r2, sp
    6b16:	0021      	movs	r1, r4
    6b18:	0020      	movs	r0, r4
    6b1a:	f7ff fe23 	bl	6764 <vli_mod_mult_fast>
	vli_mod_sub(y2, y2, y1, curve_p); /* t4 = y2 - y1 */
    6b1e:	003a      	movs	r2, r7
    6b20:	0029      	movs	r1, r5
    6b22:	0028      	movs	r0, r5
    6b24:	f000 fbb8 	bl	7298 <vli_mod_sub.constprop.1>
	vli_mod_square_fast(t5, y2);      /* t5 = (y2 - y1)^2 = D */
    6b28:	0029      	movs	r1, r5
    6b2a:	4668      	mov	r0, sp
    6b2c:	f7ff fed8 	bl	68e0 <vli_mod_square_fast>

	vli_mod_sub(t5, t5, x1, curve_p); /* t5 = D - B */
    6b30:	0032      	movs	r2, r6
    6b32:	4669      	mov	r1, sp
    6b34:	4668      	mov	r0, sp
    6b36:	f000 fbaf 	bl	7298 <vli_mod_sub.constprop.1>
	vli_mod_sub(t5, t5, x2, curve_p); /* t5 = D - B - C = x3 */
    6b3a:	0022      	movs	r2, r4
    6b3c:	4669      	mov	r1, sp
    6b3e:	4668      	mov	r0, sp
    6b40:	f000 fbaa 	bl	7298 <vli_mod_sub.constprop.1>
	vli_mod_sub(x2, x2, x1, curve_p); /* t3 = C - B */
    6b44:	0032      	movs	r2, r6
    6b46:	0021      	movs	r1, r4
    6b48:	0020      	movs	r0, r4
    6b4a:	f000 fba5 	bl	7298 <vli_mod_sub.constprop.1>
	vli_mod_mult_fast(y1, y1, x2);    /* t2 = y1*(C - B) */
    6b4e:	0022      	movs	r2, r4
    6b50:	0039      	movs	r1, r7
    6b52:	0038      	movs	r0, r7
    6b54:	f7ff fe06 	bl	6764 <vli_mod_mult_fast>
	vli_mod_sub(x2, x1, t5, curve_p); /* t3 = B - x3 */
    6b58:	466a      	mov	r2, sp
    6b5a:	0031      	movs	r1, r6
    6b5c:	0020      	movs	r0, r4
    6b5e:	f000 fb9b 	bl	7298 <vli_mod_sub.constprop.1>
	vli_mod_mult_fast(y2, y2, x2);    /* t4 = (y2 - y1)*(B - x3) */
    6b62:	0022      	movs	r2, r4
    6b64:	0029      	movs	r1, r5
    6b66:	0028      	movs	r0, r5
    6b68:	f7ff fdfc 	bl	6764 <vli_mod_mult_fast>
	vli_mod_sub(y2, y2, y1, curve_p); /* t4 = y3 */
    6b6c:	003a      	movs	r2, r7
    6b6e:	0029      	movs	r1, r5
    6b70:	0028      	movs	r0, r5
    6b72:	f000 fb91 	bl	7298 <vli_mod_sub.constprop.1>

	vli_set(x2, t5);
    6b76:	4669      	mov	r1, sp
    6b78:	0020      	movs	r0, r4
    6b7a:	f7ff fc4d 	bl	6418 <vli_set>
}
    6b7e:	b009      	add	sp, #36	; 0x24
    6b80:	bdf0      	pop	{r4, r5, r6, r7, pc}

00006b82 <xycz_add_c>:
/* Input P = (x1, y1, Z), Q = (x2, y2, Z)
 * Output P + Q = (x3, y3, Z3), P - Q = (x3', y3', Z3)
 * or P => P - Q, Q => P + Q
 */
static void xycz_add_c(uint64_t *x1, uint64_t *y1, uint64_t *x2, uint64_t *y2)
{
    6b82:	b5f0      	push	{r4, r5, r6, r7, lr}
    6b84:	0014      	movs	r4, r2
    6b86:	0005      	movs	r5, r0
    6b88:	001e      	movs	r6, r3
    6b8a:	000f      	movs	r7, r1
    6b8c:	b099      	sub	sp, #100	; 0x64
	/* t1 = X1, t2 = Y1, t3 = X2, t4 = Y2 */
	uint64_t t5[NUM_ECC_DIGITS];
	uint64_t t6[NUM_ECC_DIGITS];
	uint64_t t7[NUM_ECC_DIGITS];

	vli_mod_sub(t5, x2, x1, curve_p); /* t5 = x2 - x1 */
    6b8e:	0002      	movs	r2, r0
    6b90:	0021      	movs	r1, r4
    6b92:	4668      	mov	r0, sp
    6b94:	f000 fb80 	bl	7298 <vli_mod_sub.constprop.1>
	vli_mod_square_fast(t5, t5);      /* t5 = (x2 - x1)^2 = A */
    6b98:	4669      	mov	r1, sp
    6b9a:	4668      	mov	r0, sp
    6b9c:	f7ff fea0 	bl	68e0 <vli_mod_square_fast>
	vli_mod_mult_fast(x1, x1, t5);    /* t1 = x1*A = B */
    6ba0:	466a      	mov	r2, sp
    6ba2:	0029      	movs	r1, r5
    6ba4:	0028      	movs	r0, r5
    6ba6:	f7ff fddd 	bl	6764 <vli_mod_mult_fast>
	vli_mod_mult_fast(x2, x2, t5);    /* t3 = x2*A = C */
    6baa:	466a      	mov	r2, sp
    6bac:	0021      	movs	r1, r4
    6bae:	0020      	movs	r0, r4
    6bb0:	f7ff fdd8 	bl	6764 <vli_mod_mult_fast>
	vli_mod_add(t5, y2, y1, curve_p); /* t4 = y2 + y1 */
    6bb4:	003a      	movs	r2, r7
    6bb6:	0031      	movs	r1, r6
    6bb8:	4668      	mov	r0, sp
    6bba:	f000 fb7b 	bl	72b4 <vli_mod_add.constprop.2>
	vli_mod_sub(y2, y2, y1, curve_p); /* t4 = y2 - y1 */
    6bbe:	003a      	movs	r2, r7
    6bc0:	0031      	movs	r1, r6
    6bc2:	0030      	movs	r0, r6
    6bc4:	f000 fb68 	bl	7298 <vli_mod_sub.constprop.1>

	vli_mod_sub(t6, x2, x1, curve_p); /* t6 = C - B */
    6bc8:	002a      	movs	r2, r5
    6bca:	0021      	movs	r1, r4
    6bcc:	a808      	add	r0, sp, #32
    6bce:	f000 fb63 	bl	7298 <vli_mod_sub.constprop.1>
	vli_mod_mult_fast(y1, y1, t6);    /* t2 = y1 * (C - B) */
    6bd2:	aa08      	add	r2, sp, #32
    6bd4:	0039      	movs	r1, r7
    6bd6:	0038      	movs	r0, r7
    6bd8:	f7ff fdc4 	bl	6764 <vli_mod_mult_fast>
	vli_mod_add(t6, x1, x2, curve_p); /* t6 = B + C */
    6bdc:	0022      	movs	r2, r4
    6bde:	0029      	movs	r1, r5
    6be0:	a808      	add	r0, sp, #32
    6be2:	f000 fb67 	bl	72b4 <vli_mod_add.constprop.2>
	vli_mod_square_fast(x2, y2);      /* t3 = (y2 - y1)^2 */
    6be6:	0031      	movs	r1, r6
    6be8:	0020      	movs	r0, r4
    6bea:	f7ff fe79 	bl	68e0 <vli_mod_square_fast>
	vli_mod_sub(x2, x2, t6, curve_p); /* t3 = x3 */
    6bee:	aa08      	add	r2, sp, #32
    6bf0:	0021      	movs	r1, r4
    6bf2:	0020      	movs	r0, r4
    6bf4:	f000 fb50 	bl	7298 <vli_mod_sub.constprop.1>

	vli_mod_sub(t7, x1, x2, curve_p); /* t7 = B - x3 */
    6bf8:	0022      	movs	r2, r4
    6bfa:	0029      	movs	r1, r5
    6bfc:	a810      	add	r0, sp, #64	; 0x40
    6bfe:	f000 fb4b 	bl	7298 <vli_mod_sub.constprop.1>
	vli_mod_mult_fast(y2, y2, t7);    /* t4 = (y2 - y1)*(B - x3) */
    6c02:	aa10      	add	r2, sp, #64	; 0x40
    6c04:	0031      	movs	r1, r6
    6c06:	0030      	movs	r0, r6
    6c08:	f7ff fdac 	bl	6764 <vli_mod_mult_fast>
	vli_mod_sub(y2, y2, y1, curve_p); /* t4 = y3 */
    6c0c:	003a      	movs	r2, r7
    6c0e:	0031      	movs	r1, r6
    6c10:	0030      	movs	r0, r6
    6c12:	f000 fb41 	bl	7298 <vli_mod_sub.constprop.1>

	vli_mod_square_fast(t7, t5);      /* t7 = (y2 + y1)^2 = F */
    6c16:	4669      	mov	r1, sp
    6c18:	a810      	add	r0, sp, #64	; 0x40
    6c1a:	f7ff fe61 	bl	68e0 <vli_mod_square_fast>
	vli_mod_sub(t7, t7, t6, curve_p); /* t7 = x3' */
    6c1e:	a910      	add	r1, sp, #64	; 0x40
    6c20:	aa08      	add	r2, sp, #32
    6c22:	0008      	movs	r0, r1
    6c24:	f000 fb38 	bl	7298 <vli_mod_sub.constprop.1>
	vli_mod_sub(t6, t7, x1, curve_p); /* t6 = x3' - B */
    6c28:	002a      	movs	r2, r5
    6c2a:	a910      	add	r1, sp, #64	; 0x40
    6c2c:	a808      	add	r0, sp, #32
    6c2e:	f000 fb33 	bl	7298 <vli_mod_sub.constprop.1>
	vli_mod_mult_fast(t6, t6, t5);    /* t6 = (y2 + y1)*(x3' - B) */
    6c32:	a908      	add	r1, sp, #32
    6c34:	466a      	mov	r2, sp
    6c36:	0008      	movs	r0, r1
    6c38:	f7ff fd94 	bl	6764 <vli_mod_mult_fast>
	vli_mod_sub(y1, t6, y1, curve_p); /* t2 = y3' */
    6c3c:	003a      	movs	r2, r7
    6c3e:	a908      	add	r1, sp, #32
    6c40:	0038      	movs	r0, r7
    6c42:	f000 fb29 	bl	7298 <vli_mod_sub.constprop.1>

	vli_set(x1, t7);
    6c46:	a910      	add	r1, sp, #64	; 0x40
    6c48:	0028      	movs	r0, r5
    6c4a:	f7ff fbe5 	bl	6418 <vli_set>
}
    6c4e:	b019      	add	sp, #100	; 0x64
    6c50:	bdf0      	pop	{r4, r5, r6, r7, pc}

00006c52 <ecc_point_mult>:

static void ecc_point_mult(struct ecc_point *result,
				const struct ecc_point *point,
				uint64_t *scalar, uint64_t *initial_z,
				int num_bits)
{
    6c52:	b5f0      	push	{r4, r5, r6, r7, lr}
    6c54:	b0d1      	sub	sp, #324	; 0x144
    6c56:	9007      	str	r0, [sp, #28]
	uint64_t rx[2][NUM_ECC_DIGITS];
	uint64_t ry[2][NUM_ECC_DIGITS];
	uint64_t z[NUM_ECC_DIGITS];
	int i, nb;

	vli_set(rx[1], point->x);
    6c58:	a838      	add	r0, sp, #224	; 0xe0

static void ecc_point_mult(struct ecc_point *result,
				const struct ecc_point *point,
				uint64_t *scalar, uint64_t *initial_z,
				int num_bits)
{
    6c5a:	0017      	movs	r7, r2
    6c5c:	9103      	str	r1, [sp, #12]
    6c5e:	001c      	movs	r4, r3
	uint64_t rx[2][NUM_ECC_DIGITS];
	uint64_t ry[2][NUM_ECC_DIGITS];
	uint64_t z[NUM_ECC_DIGITS];
	int i, nb;

	vli_set(rx[1], point->x);
    6c60:	f7ff fbda 	bl	6418 <vli_set>
	vli_set(ry[1], point->y);
    6c64:	9b03      	ldr	r3, [sp, #12]
    6c66:	a848      	add	r0, sp, #288	; 0x120
    6c68:	3320      	adds	r3, #32
    6c6a:	0019      	movs	r1, r3
    6c6c:	9304      	str	r3, [sp, #16]
    6c6e:	f7ff fbd3 	bl	6418 <vli_set>
static void xycz_initial_double(uint64_t *x1, uint64_t *y1, uint64_t *x2,
					uint64_t *y2, uint64_t *p_initial_z)
{
	uint64_t z[NUM_ECC_DIGITS];

	vli_set(x2, x1);
    6c72:	a938      	add	r1, sp, #224	; 0xe0
    6c74:	a830      	add	r0, sp, #192	; 0xc0
    6c76:	f7ff fbcf 	bl	6418 <vli_set>
	vli_set(y2, y1);
    6c7a:	a948      	add	r1, sp, #288	; 0x120
    6c7c:	a840      	add	r0, sp, #256	; 0x100
    6c7e:	f7ff fbcb 	bl	6418 <vli_set>

	vli_clear(z);
    6c82:	a818      	add	r0, sp, #96	; 0x60
    6c84:	f7ff fb8c 	bl	63a0 <vli_clear>
	z[0] = 1;
    6c88:	2201      	movs	r2, #1
    6c8a:	2300      	movs	r3, #0
    6c8c:	9218      	str	r2, [sp, #96]	; 0x60
    6c8e:	9319      	str	r3, [sp, #100]	; 0x64

	if (p_initial_z)
    6c90:	2c00      	cmp	r4, #0
    6c92:	d003      	beq.n	6c9c <ecc_point_mult+0x4a>
		vli_set(z, p_initial_z);
    6c94:	0021      	movs	r1, r4
    6c96:	a818      	add	r0, sp, #96	; 0x60
    6c98:	f7ff fbbe 	bl	6418 <vli_set>

	apply_z(x1, y1, z);
    6c9c:	a838      	add	r0, sp, #224	; 0xe0
    6c9e:	aa18      	add	r2, sp, #96	; 0x60
    6ca0:	a948      	add	r1, sp, #288	; 0x120
    6ca2:	f7ff ff09 	bl	6ab8 <apply_z>
{
	/* t1 = x, t2 = y, t3 = z */
	uint64_t t4[NUM_ECC_DIGITS];
	uint64_t t5[NUM_ECC_DIGITS];

	if (vli_is_zero(z1))
    6ca6:	a818      	add	r0, sp, #96	; 0x60
    6ca8:	f7ff fb83 	bl	63b2 <vli_is_zero>
    6cac:	2800      	cmp	r0, #0
    6cae:	d170      	bne.n	6d92 <ecc_point_mult+0x140>
		return;

	vli_mod_square_fast(t4, y1);   /* t4 = y1^2 */
    6cb0:	a948      	add	r1, sp, #288	; 0x120
    6cb2:	a820      	add	r0, sp, #128	; 0x80
    6cb4:	f7ff fe14 	bl	68e0 <vli_mod_square_fast>
	vli_mod_mult_fast(t5, x1, t4); /* t5 = x1*y1^2 = A */
    6cb8:	aa20      	add	r2, sp, #128	; 0x80
    6cba:	a938      	add	r1, sp, #224	; 0xe0
    6cbc:	a828      	add	r0, sp, #160	; 0xa0
    6cbe:	f7ff fd51 	bl	6764 <vli_mod_mult_fast>
	vli_mod_square_fast(t4, t4);   /* t4 = y1^4 */
    6cc2:	a920      	add	r1, sp, #128	; 0x80
    6cc4:	0008      	movs	r0, r1
    6cc6:	f7ff fe0b 	bl	68e0 <vli_mod_square_fast>
	vli_mod_mult_fast(y1, y1, z1); /* t2 = y1*z1 = z3 */
    6cca:	a948      	add	r1, sp, #288	; 0x120
    6ccc:	aa18      	add	r2, sp, #96	; 0x60
    6cce:	0008      	movs	r0, r1
    6cd0:	f7ff fd48 	bl	6764 <vli_mod_mult_fast>
	vli_mod_square_fast(z1, z1);   /* t3 = z1^2 */
    6cd4:	a918      	add	r1, sp, #96	; 0x60
    6cd6:	0008      	movs	r0, r1
    6cd8:	f7ff fe02 	bl	68e0 <vli_mod_square_fast>

	vli_mod_add(x1, x1, z1, curve_p); /* t1 = x1 + z1^2 */
    6cdc:	a938      	add	r1, sp, #224	; 0xe0
    6cde:	0008      	movs	r0, r1
    6ce0:	aa18      	add	r2, sp, #96	; 0x60
    6ce2:	f000 fae7 	bl	72b4 <vli_mod_add.constprop.2>
	vli_mod_add(z1, z1, z1, curve_p); /* t3 = 2*z1^2 */
    6ce6:	aa18      	add	r2, sp, #96	; 0x60
    6ce8:	0011      	movs	r1, r2
    6cea:	0010      	movs	r0, r2
    6cec:	f000 fae2 	bl	72b4 <vli_mod_add.constprop.2>
	vli_mod_sub(z1, x1, z1, curve_p); /* t3 = x1 - z1^2 */
    6cf0:	aa18      	add	r2, sp, #96	; 0x60
    6cf2:	0010      	movs	r0, r2
    6cf4:	a938      	add	r1, sp, #224	; 0xe0
    6cf6:	f000 facf 	bl	7298 <vli_mod_sub.constprop.1>
	vli_mod_mult_fast(x1, x1, z1);    /* t1 = x1^2 - z1^4 */
    6cfa:	a938      	add	r1, sp, #224	; 0xe0
    6cfc:	0008      	movs	r0, r1
    6cfe:	aa18      	add	r2, sp, #96	; 0x60
    6d00:	f7ff fd30 	bl	6764 <vli_mod_mult_fast>

	vli_mod_add(z1, x1, x1, curve_p); /* t3 = 2*(x1^2 - z1^4) */
    6d04:	aa38      	add	r2, sp, #224	; 0xe0
    6d06:	0011      	movs	r1, r2
    6d08:	a818      	add	r0, sp, #96	; 0x60
    6d0a:	f000 fad3 	bl	72b4 <vli_mod_add.constprop.2>
	vli_mod_add(x1, x1, z1, curve_p); /* t1 = 3*(x1^2 - z1^4) */
    6d0e:	a938      	add	r1, sp, #224	; 0xe0
    6d10:	aa18      	add	r2, sp, #96	; 0x60
    6d12:	0008      	movs	r0, r1
    6d14:	f000 face 	bl	72b4 <vli_mod_add.constprop.2>
	if (vli_test_bit(x1, 0)) {
    6d18:	9b38      	ldr	r3, [sp, #224]	; 0xe0
    6d1a:	07db      	lsls	r3, r3, #31
    6d1c:	d50d      	bpl.n	6d3a <ecc_point_mult+0xe8>
		uint64_t carry = vli_add(x1, x1, curve_p);
    6d1e:	a938      	add	r1, sp, #224	; 0xe0
    6d20:	4aa7      	ldr	r2, [pc, #668]	; (6fc0 <ecc_point_mult+0x36e>)
    6d22:	0008      	movs	r0, r1
    6d24:	f7ff fbb6 	bl	6494 <vli_add>
    6d28:	0004      	movs	r4, r0
		vli_rshift1(x1);
    6d2a:	a838      	add	r0, sp, #224	; 0xe0
    6d2c:	f7ff fb9e 	bl	646c <vli_rshift1>
		x1[NUM_ECC_DIGITS - 1] |= carry << 63;
    6d30:	9b3f      	ldr	r3, [sp, #252]	; 0xfc
    6d32:	07e4      	lsls	r4, r4, #31
    6d34:	431c      	orrs	r4, r3
    6d36:	943f      	str	r4, [sp, #252]	; 0xfc
    6d38:	e002      	b.n	6d40 <ecc_point_mult+0xee>
	} else {
		vli_rshift1(x1);
    6d3a:	a838      	add	r0, sp, #224	; 0xe0
    6d3c:	f7ff fb96 	bl	646c <vli_rshift1>
	}
	/* t1 = 3/2*(x1^2 - z1^4) = B */

	vli_mod_square_fast(z1, x1);      /* t3 = B^2 */
    6d40:	a938      	add	r1, sp, #224	; 0xe0
    6d42:	a818      	add	r0, sp, #96	; 0x60
    6d44:	f7ff fdcc 	bl	68e0 <vli_mod_square_fast>
	vli_mod_sub(z1, z1, t5, curve_p); /* t3 = B^2 - A */
    6d48:	a918      	add	r1, sp, #96	; 0x60
    6d4a:	0008      	movs	r0, r1
    6d4c:	aa28      	add	r2, sp, #160	; 0xa0
    6d4e:	f000 faa3 	bl	7298 <vli_mod_sub.constprop.1>
	vli_mod_sub(z1, z1, t5, curve_p); /* t3 = B^2 - 2A = x3 */
    6d52:	a918      	add	r1, sp, #96	; 0x60
    6d54:	0008      	movs	r0, r1
    6d56:	aa28      	add	r2, sp, #160	; 0xa0
    6d58:	f000 fa9e 	bl	7298 <vli_mod_sub.constprop.1>
	vli_mod_sub(t5, t5, z1, curve_p); /* t5 = A - x3 */
    6d5c:	a928      	add	r1, sp, #160	; 0xa0
    6d5e:	0008      	movs	r0, r1
    6d60:	aa18      	add	r2, sp, #96	; 0x60
    6d62:	f000 fa99 	bl	7298 <vli_mod_sub.constprop.1>
	vli_mod_mult_fast(x1, x1, t5);    /* t1 = B * (A - x3) */
    6d66:	a938      	add	r1, sp, #224	; 0xe0
    6d68:	0008      	movs	r0, r1
    6d6a:	aa28      	add	r2, sp, #160	; 0xa0
    6d6c:	f7ff fcfa 	bl	6764 <vli_mod_mult_fast>
	vli_mod_sub(t4, x1, t4, curve_p); /* t4 = B * (A - x3) - y1^4 = y3 */
    6d70:	aa20      	add	r2, sp, #128	; 0x80
    6d72:	0010      	movs	r0, r2
    6d74:	a938      	add	r1, sp, #224	; 0xe0
    6d76:	f000 fa8f 	bl	7298 <vli_mod_sub.constprop.1>

	vli_set(x1, z1);
    6d7a:	a918      	add	r1, sp, #96	; 0x60
    6d7c:	a838      	add	r0, sp, #224	; 0xe0
    6d7e:	f7ff fb4b 	bl	6418 <vli_set>
	vli_set(z1, y1);
    6d82:	a948      	add	r1, sp, #288	; 0x120
    6d84:	a818      	add	r0, sp, #96	; 0x60
    6d86:	f7ff fb47 	bl	6418 <vli_set>
	vli_set(y1, t4);
    6d8a:	a920      	add	r1, sp, #128	; 0x80
    6d8c:	a848      	add	r0, sp, #288	; 0x120
    6d8e:	f7ff fb43 	bl	6418 <vli_set>

	apply_z(x1, y1, z);

	ecc_point_double_jacobian(x1, y1, z);

	apply_z(x2, y2, z);
    6d92:	aa18      	add	r2, sp, #96	; 0x60
    6d94:	a940      	add	r1, sp, #256	; 0x100
    6d96:	a830      	add	r0, sp, #192	; 0xc0
    6d98:	f7ff fe8e 	bl	6ab8 <apply_z>
	vli_set(rx[1], point->x);
	vli_set(ry[1], point->y);

	xycz_initial_double(rx[1], ry[1], rx[0], ry[0], initial_z);

	for (i = num_bits - 2; i > 0; i--) {
    6d9c:	9b56      	ldr	r3, [sp, #344]	; 0x158
    6d9e:	1e9e      	subs	r6, r3, #2
    6da0:	2e00      	cmp	r6, #0
    6da2:	dd2b      	ble.n	6dfc <ecc_point_mult+0x1aa>
		nb = !vli_test_bit(scalar, i);
    6da4:	223f      	movs	r2, #63	; 0x3f
    6da6:	2001      	movs	r0, #1
    6da8:	4032      	ands	r2, r6
    6daa:	2100      	movs	r1, #0
    6dac:	f016 ffe6 	bl	1dd7c <__aeabi_llsl>
}

/* Returns nonzero if bit bit of vli is set. */
static uint64_t vli_test_bit(const uint64_t *vli, unsigned int bit)
{
	return (vli[bit / 64] & ((uint64_t) 1 << (bit % 64)));
    6db0:	09b5      	lsrs	r5, r6, #6
    6db2:	00ed      	lsls	r5, r5, #3
    6db4:	197d      	adds	r5, r7, r5
	vli_set(ry[1], point->y);

	xycz_initial_double(rx[1], ry[1], rx[0], ry[0], initial_z);

	for (i = num_bits - 2; i > 0; i--) {
		nb = !vli_test_bit(scalar, i);
    6db6:	686b      	ldr	r3, [r5, #4]
    6db8:	682c      	ldr	r4, [r5, #0]
    6dba:	4019      	ands	r1, r3
    6dbc:	4004      	ands	r4, r0
    6dbe:	430c      	orrs	r4, r1
    6dc0:	4262      	negs	r2, r4
    6dc2:	4162      	adcs	r2, r4
		xycz_add_c(rx[1 - nb], ry[1 - nb], rx[nb], ry[nb]);
    6dc4:	2301      	movs	r3, #1
    6dc6:	1a9d      	subs	r5, r3, r2
    6dc8:	016d      	lsls	r5, r5, #5
    6dca:	ab30      	add	r3, sp, #192	; 0xc0
    6dcc:	195b      	adds	r3, r3, r5
    6dce:	9301      	str	r3, [sp, #4]
    6dd0:	ab40      	add	r3, sp, #256	; 0x100
    6dd2:	195d      	adds	r5, r3, r5
    6dd4:	0154      	lsls	r4, r2, #5
    6dd6:	ab30      	add	r3, sp, #192	; 0xc0
    6dd8:	191b      	adds	r3, r3, r4
    6dda:	9302      	str	r3, [sp, #8]
    6ddc:	ab40      	add	r3, sp, #256	; 0x100
    6dde:	191c      	adds	r4, r3, r4
    6de0:	0023      	movs	r3, r4
    6de2:	9a02      	ldr	r2, [sp, #8]
    6de4:	0029      	movs	r1, r5
    6de6:	9801      	ldr	r0, [sp, #4]
    6de8:	f7ff fecb 	bl	6b82 <xycz_add_c>
		xycz_add(rx[nb], ry[nb], rx[1 - nb], ry[1 - nb]);
    6dec:	002b      	movs	r3, r5
    6dee:	9a01      	ldr	r2, [sp, #4]
    6df0:	0021      	movs	r1, r4
    6df2:	9802      	ldr	r0, [sp, #8]
    6df4:	f7ff fe7a 	bl	6aec <xycz_add>
	vli_set(rx[1], point->x);
	vli_set(ry[1], point->y);

	xycz_initial_double(rx[1], ry[1], rx[0], ry[0], initial_z);

	for (i = num_bits - 2; i > 0; i--) {
    6df8:	3e01      	subs	r6, #1
    6dfa:	e7d1      	b.n	6da0 <ecc_point_mult+0x14e>
		nb = !vli_test_bit(scalar, i);
		xycz_add_c(rx[1 - nb], ry[1 - nb], rx[nb], ry[nb]);
		xycz_add(rx[nb], ry[nb], rx[1 - nb], ry[1 - nb]);
	}

	nb = !vli_test_bit(scalar, 0);
    6dfc:	2401      	movs	r4, #1
    6dfe:	0022      	movs	r2, r4
    6e00:	683b      	ldr	r3, [r7, #0]
	xycz_add_c(rx[1 - nb], ry[1 - nb], rx[nb], ry[nb]);
    6e02:	a930      	add	r1, sp, #192	; 0xc0
		nb = !vli_test_bit(scalar, i);
		xycz_add_c(rx[1 - nb], ry[1 - nb], rx[nb], ry[nb]);
		xycz_add(rx[nb], ry[nb], rx[1 - nb], ry[1 - nb]);
	}

	nb = !vli_test_bit(scalar, 0);
    6e04:	439a      	bics	r2, r3
    6e06:	0013      	movs	r3, r2
	xycz_add_c(rx[1 - nb], ry[1 - nb], rx[nb], ry[nb]);
    6e08:	1aa2      	subs	r2, r4, r2
    6e0a:	0152      	lsls	r2, r2, #5
    6e0c:	1889      	adds	r1, r1, r2
    6e0e:	9101      	str	r1, [sp, #4]
    6e10:	a940      	add	r1, sp, #256	; 0x100
    6e12:	188a      	adds	r2, r1, r2
    6e14:	9202      	str	r2, [sp, #8]
    6e16:	015b      	lsls	r3, r3, #5
    6e18:	aa30      	add	r2, sp, #192	; 0xc0
    6e1a:	18d2      	adds	r2, r2, r3
    6e1c:	9205      	str	r2, [sp, #20]
    6e1e:	18cb      	adds	r3, r1, r3
    6e20:	9a05      	ldr	r2, [sp, #20]
    6e22:	9902      	ldr	r1, [sp, #8]
    6e24:	9801      	ldr	r0, [sp, #4]
    6e26:	9306      	str	r3, [sp, #24]
    6e28:	f7ff feab 	bl	6b82 <xycz_add_c>

	/* Find final 1/Z value. */
	vli_mod_sub(z, rx[1], rx[0], curve_p); /* X1 - X0 */
    6e2c:	aa30      	add	r2, sp, #192	; 0xc0
    6e2e:	a938      	add	r1, sp, #224	; 0xe0
    6e30:	a808      	add	r0, sp, #32
    6e32:	f000 fa31 	bl	7298 <vli_mod_sub.constprop.1>
	vli_mod_mult_fast(z, z, ry[1 - nb]); /* Yb * (X1 - X0) */
    6e36:	a908      	add	r1, sp, #32
    6e38:	0008      	movs	r0, r1
    6e3a:	9a02      	ldr	r2, [sp, #8]
    6e3c:	f7ff fc92 	bl	6764 <vli_mod_mult_fast>
	vli_mod_mult_fast(z, z, point->x);   /* xP * Yb * (X1 - X0) */
    6e40:	a908      	add	r1, sp, #32
    6e42:	0008      	movs	r0, r1
    6e44:	9a03      	ldr	r2, [sp, #12]
    6e46:	f7ff fc8d 	bl	6764 <vli_mod_mult_fast>
	uint64_t a[NUM_ECC_DIGITS], b[NUM_ECC_DIGITS];
	uint64_t u[NUM_ECC_DIGITS], v[NUM_ECC_DIGITS];
	uint64_t carry;
	int cmp_result;

	if (vli_is_zero(input)) {
    6e4a:	a808      	add	r0, sp, #32
    6e4c:	f7ff fab1 	bl	63b2 <vli_is_zero>
    6e50:	2800      	cmp	r0, #0
    6e52:	d003      	beq.n	6e5c <ecc_point_mult+0x20a>
		vli_clear(result);
    6e54:	a808      	add	r0, sp, #32
    6e56:	f7ff faa3 	bl	63a0 <vli_clear>
    6e5a:	e090      	b.n	6f7e <ecc_point_mult+0x32c>
		return;
	}

	vli_set(a, input);
    6e5c:	a908      	add	r1, sp, #32
    6e5e:	a810      	add	r0, sp, #64	; 0x40
    6e60:	f7ff fada 	bl	6418 <vli_set>
	vli_set(b, mod);
    6e64:	4956      	ldr	r1, [pc, #344]	; (6fc0 <ecc_point_mult+0x36e>)
    6e66:	a818      	add	r0, sp, #96	; 0x60
    6e68:	f7ff fad6 	bl	6418 <vli_set>
	vli_clear(u);
    6e6c:	a820      	add	r0, sp, #128	; 0x80
    6e6e:	f7ff fa97 	bl	63a0 <vli_clear>
	u[0] = 1;
    6e72:	2201      	movs	r2, #1
    6e74:	2300      	movs	r3, #0
	vli_clear(v);
    6e76:	a828      	add	r0, sp, #160	; 0xa0
			if (!EVEN(v))
				carry = vli_add(v, v, mod);

			vli_rshift1(v);
			if (carry)
				v[NUM_ECC_DIGITS - 1] |= 0x8000000000000000ull;
    6e78:	2680      	movs	r6, #128	; 0x80
	}

	vli_set(a, input);
	vli_set(b, mod);
	vli_clear(u);
	u[0] = 1;
    6e7a:	9220      	str	r2, [sp, #128]	; 0x80
    6e7c:	9321      	str	r3, [sp, #132]	; 0x84
	vli_clear(v);
    6e7e:	f7ff fa8f 	bl	63a0 <vli_clear>
			if (!EVEN(v))
				carry = vli_add(v, v, mod);

			vli_rshift1(v);
			if (carry)
				v[NUM_ECC_DIGITS - 1] |= 0x8000000000000000ull;
    6e82:	0636      	lsls	r6, r6, #24
	vli_set(b, mod);
	vli_clear(u);
	u[0] = 1;
	vli_clear(v);

	while ((cmp_result = vli_cmp(a, b)) != 0) {
    6e84:	a918      	add	r1, sp, #96	; 0x60
    6e86:	a810      	add	r0, sp, #64	; 0x40
    6e88:	f7ff fad2 	bl	6430 <vli_cmp>
    6e8c:	2800      	cmp	r0, #0
    6e8e:	d072      	beq.n	6f76 <ecc_point_mult+0x324>
		carry = 0;

		if (EVEN(a)) {
    6e90:	9b10      	ldr	r3, [sp, #64]	; 0x40
    6e92:	4223      	tst	r3, r4
    6e94:	d106      	bne.n	6ea4 <ecc_point_mult+0x252>
			vli_rshift1(a);
    6e96:	a810      	add	r0, sp, #64	; 0x40
    6e98:	f7ff fae8 	bl	646c <vli_rshift1>

			if (!EVEN(u))
    6e9c:	9d20      	ldr	r5, [sp, #128]	; 0x80
    6e9e:	4025      	ands	r5, r4
    6ea0:	d030      	beq.n	6f04 <ecc_point_mult+0x2b2>
    6ea2:	e027      	b.n	6ef4 <ecc_point_mult+0x2a2>
				carry = vli_add(u, u, mod);

			vli_rshift1(u);
			if (carry)
				u[NUM_ECC_DIGITS - 1] |= 0x8000000000000000ull;
		} else if (EVEN(b)) {
    6ea4:	9b18      	ldr	r3, [sp, #96]	; 0x60
    6ea6:	9303      	str	r3, [sp, #12]
    6ea8:	4223      	tst	r3, r4
    6eaa:	d106      	bne.n	6eba <ecc_point_mult+0x268>
			vli_rshift1(b);
    6eac:	a818      	add	r0, sp, #96	; 0x60
    6eae:	f7ff fadd 	bl	646c <vli_rshift1>

			if (!EVEN(v))
    6eb2:	9d28      	ldr	r5, [sp, #160]	; 0xa0
    6eb4:	4025      	ands	r5, r4
    6eb6:	d053      	beq.n	6f60 <ecc_point_mult+0x30e>
    6eb8:	e04a      	b.n	6f50 <ecc_point_mult+0x2fe>
				carry = vli_add(v, v, mod);

			vli_rshift1(v);
			if (carry)
				v[NUM_ECC_DIGITS - 1] |= 0x8000000000000000ull;
		} else if (cmp_result > 0) {
    6eba:	2800      	cmp	r0, #0
    6ebc:	dd2d      	ble.n	6f1a <ecc_point_mult+0x2c8>
			vli_sub(a, a, b);
    6ebe:	a910      	add	r1, sp, #64	; 0x40
    6ec0:	aa18      	add	r2, sp, #96	; 0x60
    6ec2:	0008      	movs	r0, r1
    6ec4:	f7ff fb14 	bl	64f0 <vli_sub>
			vli_rshift1(a);
    6ec8:	a810      	add	r0, sp, #64	; 0x40
    6eca:	f7ff facf 	bl	646c <vli_rshift1>

			if (vli_cmp(u, v) < 0)
    6ece:	a928      	add	r1, sp, #160	; 0xa0
    6ed0:	a820      	add	r0, sp, #128	; 0x80
    6ed2:	f7ff faad 	bl	6430 <vli_cmp>
    6ed6:	2800      	cmp	r0, #0
    6ed8:	da04      	bge.n	6ee4 <ecc_point_mult+0x292>
				vli_add(u, u, mod);
    6eda:	a920      	add	r1, sp, #128	; 0x80
    6edc:	4a38      	ldr	r2, [pc, #224]	; (6fc0 <ecc_point_mult+0x36e>)
    6ede:	0008      	movs	r0, r1
    6ee0:	f7ff fad8 	bl	6494 <vli_add>

			vli_sub(u, u, v);
    6ee4:	a920      	add	r1, sp, #128	; 0x80
    6ee6:	aa28      	add	r2, sp, #160	; 0xa0
    6ee8:	0008      	movs	r0, r1
    6eea:	f7ff fb01 	bl	64f0 <vli_sub>
			if (!EVEN(u))
    6eee:	9d20      	ldr	r5, [sp, #128]	; 0x80
    6ef0:	4025      	ands	r5, r4
    6ef2:	d007      	beq.n	6f04 <ecc_point_mult+0x2b2>
				carry = vli_add(u, u, mod);
    6ef4:	a920      	add	r1, sp, #128	; 0x80
    6ef6:	4a32      	ldr	r2, [pc, #200]	; (6fc0 <ecc_point_mult+0x36e>)
    6ef8:	0008      	movs	r0, r1
    6efa:	f7ff facb 	bl	6494 <vli_add>
    6efe:	0005      	movs	r5, r0
    6f00:	000f      	movs	r7, r1
    6f02:	e000      	b.n	6f06 <ecc_point_mult+0x2b4>
	vli_clear(u);
	u[0] = 1;
	vli_clear(v);

	while ((cmp_result = vli_cmp(a, b)) != 0) {
		carry = 0;
    6f04:	002f      	movs	r7, r5

			vli_sub(u, u, v);
			if (!EVEN(u))
				carry = vli_add(u, u, mod);

			vli_rshift1(u);
    6f06:	a820      	add	r0, sp, #128	; 0x80
    6f08:	f7ff fab0 	bl	646c <vli_rshift1>
			if (carry)
    6f0c:	433d      	orrs	r5, r7
    6f0e:	d0b9      	beq.n	6e84 <ecc_point_mult+0x232>
				u[NUM_ECC_DIGITS - 1] |= 0x8000000000000000ull;
    6f10:	9b27      	ldr	r3, [sp, #156]	; 0x9c
    6f12:	9303      	str	r3, [sp, #12]
    6f14:	4333      	orrs	r3, r6
    6f16:	9327      	str	r3, [sp, #156]	; 0x9c
    6f18:	e7b4      	b.n	6e84 <ecc_point_mult+0x232>
		} else {
			vli_sub(b, b, a);
    6f1a:	a918      	add	r1, sp, #96	; 0x60
    6f1c:	aa10      	add	r2, sp, #64	; 0x40
    6f1e:	0008      	movs	r0, r1
    6f20:	f7ff fae6 	bl	64f0 <vli_sub>
			vli_rshift1(b);
    6f24:	a818      	add	r0, sp, #96	; 0x60
    6f26:	f7ff faa1 	bl	646c <vli_rshift1>

			if (vli_cmp(v, u) < 0)
    6f2a:	a920      	add	r1, sp, #128	; 0x80
    6f2c:	a828      	add	r0, sp, #160	; 0xa0
    6f2e:	f7ff fa7f 	bl	6430 <vli_cmp>
    6f32:	2800      	cmp	r0, #0
    6f34:	da04      	bge.n	6f40 <ecc_point_mult+0x2ee>
				vli_add(v, v, mod);
    6f36:	a928      	add	r1, sp, #160	; 0xa0
    6f38:	4a21      	ldr	r2, [pc, #132]	; (6fc0 <ecc_point_mult+0x36e>)
    6f3a:	0008      	movs	r0, r1
    6f3c:	f7ff faaa 	bl	6494 <vli_add>

			vli_sub(v, v, u);
    6f40:	a928      	add	r1, sp, #160	; 0xa0
    6f42:	aa20      	add	r2, sp, #128	; 0x80
    6f44:	0008      	movs	r0, r1
    6f46:	f7ff fad3 	bl	64f0 <vli_sub>
			if (!EVEN(v))
    6f4a:	9d28      	ldr	r5, [sp, #160]	; 0xa0
    6f4c:	4025      	ands	r5, r4
    6f4e:	d007      	beq.n	6f60 <ecc_point_mult+0x30e>
				carry = vli_add(v, v, mod);
    6f50:	a928      	add	r1, sp, #160	; 0xa0
    6f52:	4a1b      	ldr	r2, [pc, #108]	; (6fc0 <ecc_point_mult+0x36e>)
    6f54:	0008      	movs	r0, r1
    6f56:	f7ff fa9d 	bl	6494 <vli_add>
    6f5a:	0005      	movs	r5, r0
    6f5c:	000f      	movs	r7, r1
    6f5e:	e000      	b.n	6f62 <ecc_point_mult+0x310>
	vli_clear(u);
	u[0] = 1;
	vli_clear(v);

	while ((cmp_result = vli_cmp(a, b)) != 0) {
		carry = 0;
    6f60:	002f      	movs	r7, r5

			vli_sub(v, v, u);
			if (!EVEN(v))
				carry = vli_add(v, v, mod);

			vli_rshift1(v);
    6f62:	a828      	add	r0, sp, #160	; 0xa0
    6f64:	f7ff fa82 	bl	646c <vli_rshift1>
			if (carry)
    6f68:	433d      	orrs	r5, r7
    6f6a:	d08b      	beq.n	6e84 <ecc_point_mult+0x232>
				v[NUM_ECC_DIGITS - 1] |= 0x8000000000000000ull;
    6f6c:	9b2f      	ldr	r3, [sp, #188]	; 0xbc
    6f6e:	9303      	str	r3, [sp, #12]
    6f70:	4333      	orrs	r3, r6
    6f72:	932f      	str	r3, [sp, #188]	; 0xbc
    6f74:	e786      	b.n	6e84 <ecc_point_mult+0x232>
		}
	}

	vli_set(result, u);
    6f76:	a920      	add	r1, sp, #128	; 0x80
    6f78:	a808      	add	r0, sp, #32
    6f7a:	f7ff fa4d 	bl	6418 <vli_set>
	/* Find final 1/Z value. */
	vli_mod_sub(z, rx[1], rx[0], curve_p); /* X1 - X0 */
	vli_mod_mult_fast(z, z, ry[1 - nb]); /* Yb * (X1 - X0) */
	vli_mod_mult_fast(z, z, point->x);   /* xP * Yb * (X1 - X0) */
	vli_mod_inv(z, z, curve_p);          /* 1 / (xP * Yb * (X1 - X0)) */
	vli_mod_mult_fast(z, z, point->y);   /* yP / (xP * Yb * (X1 - X0)) */
    6f7e:	a908      	add	r1, sp, #32
    6f80:	9a04      	ldr	r2, [sp, #16]
    6f82:	0008      	movs	r0, r1
    6f84:	f7ff fbee 	bl	6764 <vli_mod_mult_fast>
	vli_mod_mult_fast(z, z, rx[1 - nb]); /* Xb * yP / (xP * Yb * (X1 - X0)) */
    6f88:	a908      	add	r1, sp, #32
    6f8a:	9a01      	ldr	r2, [sp, #4]
    6f8c:	0008      	movs	r0, r1
    6f8e:	f7ff fbe9 	bl	6764 <vli_mod_mult_fast>
	/* End 1/Z calculation */

	xycz_add(rx[nb], ry[nb], rx[1 - nb], ry[1 - nb]);
    6f92:	9b02      	ldr	r3, [sp, #8]
    6f94:	9a01      	ldr	r2, [sp, #4]
    6f96:	9906      	ldr	r1, [sp, #24]
    6f98:	9805      	ldr	r0, [sp, #20]
    6f9a:	f7ff fda7 	bl	6aec <xycz_add>

	apply_z(rx[0], ry[0], z);
    6f9e:	aa08      	add	r2, sp, #32
    6fa0:	a940      	add	r1, sp, #256	; 0x100
    6fa2:	a830      	add	r0, sp, #192	; 0xc0
    6fa4:	f7ff fd88 	bl	6ab8 <apply_z>

	vli_set(result->x, rx[0]);
    6fa8:	a930      	add	r1, sp, #192	; 0xc0
    6faa:	9807      	ldr	r0, [sp, #28]
    6fac:	f7ff fa34 	bl	6418 <vli_set>
	vli_set(result->y, ry[0]);
    6fb0:	9807      	ldr	r0, [sp, #28]
    6fb2:	a940      	add	r1, sp, #256	; 0x100
    6fb4:	3020      	adds	r0, #32
    6fb6:	f7ff fa2f 	bl	6418 <vli_set>
}
    6fba:	b051      	add	sp, #324	; 0x144
    6fbc:	bdf0      	pop	{r4, r5, r6, r7, pc}
    6fbe:	46c0      	nop			; (mov r8, r8)
    6fc0:	10010518 	.word	0x10010518

00006fc4 <ecc_valid_point>:

static bool ecc_valid_point(const struct ecc_point *point)
{
    6fc4:	b5f0      	push	{r4, r5, r6, r7, lr}
    6fc6:	b099      	sub	sp, #100	; 0x64
    6fc8:	0005      	movs	r5, r0
	uint64_t tmp1[NUM_ECC_DIGITS];
	uint64_t tmp2[NUM_ECC_DIGITS];
	uint64_t _3[NUM_ECC_DIGITS] = { 3 };	/* -a = 3 */
    6fca:	2220      	movs	r2, #32
    6fcc:	2100      	movs	r1, #0
    6fce:	a810      	add	r0, sp, #64	; 0x40
    6fd0:	f00e fd3c 	bl	15a4c <memset>
    6fd4:	2203      	movs	r2, #3
    6fd6:	2300      	movs	r3, #0

	/* The point at infinity is invalid. */
	if (ecc_point_is_zero(point))
    6fd8:	0028      	movs	r0, r5

static bool ecc_valid_point(const struct ecc_point *point)
{
	uint64_t tmp1[NUM_ECC_DIGITS];
	uint64_t tmp2[NUM_ECC_DIGITS];
	uint64_t _3[NUM_ECC_DIGITS] = { 3 };	/* -a = 3 */
    6fda:	9210      	str	r2, [sp, #64]	; 0x40
    6fdc:	9311      	str	r3, [sp, #68]	; 0x44

	/* The point at infinity is invalid. */
	if (ecc_point_is_zero(point))
    6fde:	f7ff fd5c 	bl	6a9a <ecc_point_is_zero>
    6fe2:	1e04      	subs	r4, r0, #0
    6fe4:	d13b      	bne.n	705e <ecc_valid_point+0x9a>
		return false;
	
	/* x and y must be smaller than p. */
	if (vli_cmp(curve_p, point->x) != 1 ||
    6fe6:	4f20      	ldr	r7, [pc, #128]	; (7068 <ecc_valid_point+0xa4>)
    6fe8:	0029      	movs	r1, r5
    6fea:	0038      	movs	r0, r7
    6fec:	f7ff fa20 	bl	6430 <vli_cmp>
    6ff0:	2801      	cmp	r0, #1
    6ff2:	d135      	bne.n	7060 <ecc_valid_point+0x9c>
			vli_cmp(curve_p, point->y) != 1)
    6ff4:	002e      	movs	r6, r5
    6ff6:	3620      	adds	r6, #32
    6ff8:	0031      	movs	r1, r6
    6ffa:	0038      	movs	r0, r7
    6ffc:	f7ff fa18 	bl	6430 <vli_cmp>
	/* The point at infinity is invalid. */
	if (ecc_point_is_zero(point))
		return false;
	
	/* x and y must be smaller than p. */
	if (vli_cmp(curve_p, point->x) != 1 ||
    7000:	2801      	cmp	r0, #1
    7002:	d12d      	bne.n	7060 <ecc_valid_point+0x9c>
			vli_cmp(curve_p, point->y) != 1)
		return false;

	/* Computes result = y^2. */
	vli_mod_square_fast(tmp1, point->y);
    7004:	0031      	movs	r1, r6
    7006:	4668      	mov	r0, sp
    7008:	f7ff fc6a 	bl	68e0 <vli_mod_square_fast>

	/* Computes result = x^3 + ax + b. result must not overlap x. */
	vli_mod_square_fast(tmp2, point->x);		/* r = x^2 */
    700c:	0029      	movs	r1, r5
    700e:	a808      	add	r0, sp, #32
    7010:	f7ff fc66 	bl	68e0 <vli_mod_square_fast>
	vli_mod_sub(tmp2, tmp2, _3, curve_p);		/* r = x^2 - 3 */
    7014:	a908      	add	r1, sp, #32
    7016:	0008      	movs	r0, r1
    7018:	aa10      	add	r2, sp, #64	; 0x40
    701a:	f000 f93d 	bl	7298 <vli_mod_sub.constprop.1>
	vli_mod_mult_fast(tmp2, tmp2, point->x);	/* r = x^3 - 3x */
    701e:	a908      	add	r1, sp, #32
    7020:	0008      	movs	r0, r1
    7022:	002a      	movs	r2, r5
    7024:	f7ff fb9e 	bl	6764 <vli_mod_mult_fast>
	vli_mod_add(tmp2, tmp2, curve_b, curve_p);	/* r = x^3 - 3x + b */
    7028:	a908      	add	r1, sp, #32
    702a:	0008      	movs	r0, r1
    702c:	4a0f      	ldr	r2, [pc, #60]	; (706c <ecc_valid_point+0xa8>)
    702e:	f000 f941 	bl	72b4 <vli_mod_add.constprop.2>

/* Constant-time comparison function - secure way to compare long integers */
/* Returns one if left == right, zero otherwise. */
static bool vli_equal(const uint64_t *left, const uint64_t *right)
{
	uint64_t diff = 0;
    7032:	0023      	movs	r3, r4
	int i;

	for (i = NUM_ECC_DIGITS - 1; i >= 0; --i)
    7034:	2103      	movs	r1, #3
    7036:	00ca      	lsls	r2, r1, #3
		diff |= (left[i] ^ right[i]);
    7038:	0015      	movs	r5, r2
    703a:	a808      	add	r0, sp, #32
    703c:	1882      	adds	r2, r0, r2
    703e:	446d      	add	r5, sp
    7040:	6828      	ldr	r0, [r5, #0]
    7042:	6816      	ldr	r6, [r2, #0]
    7044:	686d      	ldr	r5, [r5, #4]
    7046:	6852      	ldr	r2, [r2, #4]
    7048:	4070      	eors	r0, r6
    704a:	406a      	eors	r2, r5
    704c:	4304      	orrs	r4, r0
    704e:	4313      	orrs	r3, r2
static bool vli_equal(const uint64_t *left, const uint64_t *right)
{
	uint64_t diff = 0;
	int i;

	for (i = NUM_ECC_DIGITS - 1; i >= 0; --i)
    7050:	3901      	subs	r1, #1
    7052:	d2f0      	bcs.n	7036 <ecc_valid_point+0x72>
		diff |= (left[i] ^ right[i]);

	return (diff == 0);
    7054:	4323      	orrs	r3, r4
    7056:	425c      	negs	r4, r3
    7058:	415c      	adcs	r4, r3
    705a:	b2e4      	uxtb	r4, r4
	vli_mod_sub(tmp2, tmp2, _3, curve_p);		/* r = x^2 - 3 */
	vli_mod_mult_fast(tmp2, tmp2, point->x);	/* r = x^3 - 3x */
	vli_mod_add(tmp2, tmp2, curve_b, curve_p);	/* r = x^3 - 3x + b */

	/* Make sure that y^2 == x^3 + ax + b */
	return vli_equal(tmp1, tmp2);
    705c:	e000      	b.n	7060 <ecc_valid_point+0x9c>
	uint64_t tmp2[NUM_ECC_DIGITS];
	uint64_t _3[NUM_ECC_DIGITS] = { 3 };	/* -a = 3 */

	/* The point at infinity is invalid. */
	if (ecc_point_is_zero(point))
		return false;
    705e:	2400      	movs	r4, #0
	vli_mod_mult_fast(tmp2, tmp2, point->x);	/* r = x^3 - 3x */
	vli_mod_add(tmp2, tmp2, curve_b, curve_p);	/* r = x^3 - 3x + b */

	/* Make sure that y^2 == x^3 + ax + b */
	return vli_equal(tmp1, tmp2);
}
    7060:	0020      	movs	r0, r4
    7062:	b019      	add	sp, #100	; 0x64
    7064:	bdf0      	pop	{r4, r5, r6, r7, pc}
    7066:	46c0      	nop			; (mov r8, r8)
    7068:	10010518 	.word	0x10010518
    706c:	10010598 	.word	0x10010598

00007070 <ecc_bytes2native>:

/* Little endian byte-array to native conversion */
static void ecc_bytes2native(const uint8_t bytes[ECC_BYTES],
						uint64_t native[NUM_ECC_DIGITS])
{
    7070:	0003      	movs	r3, r0
    7072:	b5f0      	push	{r4, r5, r6, r7, lr}
    7074:	3318      	adds	r3, #24
    7076:	3118      	adds	r1, #24
    7078:	3808      	subs	r0, #8
					((uint64_t) digit[1] << 8) |
					((uint64_t) digit[2] << 16) |
					((uint64_t) digit[3] << 24) |
					((uint64_t) digit[4] << 32) |
					((uint64_t) digit[5] << 40) |
					((uint64_t) digit[6] << 48) |
    707a:	785a      	ldrb	r2, [r3, #1]
    707c:	781d      	ldrb	r5, [r3, #0]
    707e:	789f      	ldrb	r7, [r3, #2]
    7080:	0212      	lsls	r2, r2, #8
    7082:	432a      	orrs	r2, r5
    7084:	043f      	lsls	r7, r7, #16
    7086:	0014      	movs	r4, r2
    7088:	003a      	movs	r2, r7
    708a:	78df      	ldrb	r7, [r3, #3]
    708c:	4322      	orrs	r2, r4
    708e:	063f      	lsls	r7, r7, #24
    7090:	795c      	ldrb	r4, [r3, #5]
    7092:	791e      	ldrb	r6, [r3, #4]
    7094:	4317      	orrs	r7, r2
    7096:	799a      	ldrb	r2, [r3, #6]
    7098:	0224      	lsls	r4, r4, #8
    709a:	4334      	orrs	r4, r6
    709c:	0412      	lsls	r2, r2, #16
    709e:	4322      	orrs	r2, r4
    70a0:	0014      	movs	r4, r2
    70a2:	79da      	ldrb	r2, [r3, #7]
    70a4:	3b08      	subs	r3, #8
    70a6:	0612      	lsls	r2, r2, #24
    70a8:	4322      	orrs	r2, r4
	int i;

	for (i = 0; i < NUM_ECC_DIGITS; i++) {
		const uint8_t *digit = bytes + 8 * (NUM_ECC_DIGITS - 1 - i);

		native[NUM_ECC_DIGITS - 1 - i] =
    70aa:	600f      	str	r7, [r1, #0]
    70ac:	604a      	str	r2, [r1, #4]
    70ae:	3908      	subs	r1, #8
static void ecc_bytes2native(const uint8_t bytes[ECC_BYTES],
						uint64_t native[NUM_ECC_DIGITS])
{
	int i;

	for (i = 0; i < NUM_ECC_DIGITS; i++) {
    70b0:	4283      	cmp	r3, r0
    70b2:	d1e2      	bne.n	707a <ecc_bytes2native+0xa>
					((uint64_t) digit[4] << 32) |
					((uint64_t) digit[5] << 40) |
					((uint64_t) digit[6] << 48) |
					((uint64_t) digit[7] << 56);
	}
}
    70b4:	bdf0      	pop	{r4, r5, r6, r7, pc}

000070b6 <ecc_native2bytes>:

/* Native to little endian byte-array conversion */
static void ecc_native2bytes(const uint64_t native[NUM_ECC_DIGITS],
						uint8_t bytes[ECC_BYTES])
{
    70b6:	0003      	movs	r3, r0
    70b8:	3118      	adds	r1, #24
    70ba:	3318      	adds	r3, #24
    70bc:	3808      	subs	r0, #8
	int i;

	for (i = 0; i < NUM_ECC_DIGITS; i++) {
		uint8_t *digit = bytes + 8 * (NUM_ECC_DIGITS - 1 - i);

		digit[0] = native[NUM_ECC_DIGITS - 1 - i] >> 0;
    70be:	781a      	ldrb	r2, [r3, #0]
    70c0:	3b08      	subs	r3, #8
    70c2:	700a      	strb	r2, [r1, #0]
		digit[1] = native[NUM_ECC_DIGITS - 1 - i] >> 8;
    70c4:	689a      	ldr	r2, [r3, #8]
    70c6:	3908      	subs	r1, #8
    70c8:	0a12      	lsrs	r2, r2, #8
    70ca:	724a      	strb	r2, [r1, #9]
		digit[2] = native[NUM_ECC_DIGITS - 1 - i] >> 16;
    70cc:	689a      	ldr	r2, [r3, #8]
    70ce:	0c12      	lsrs	r2, r2, #16
    70d0:	728a      	strb	r2, [r1, #10]
		digit[3] = native[NUM_ECC_DIGITS - 1 - i] >> 24;
    70d2:	689a      	ldr	r2, [r3, #8]
    70d4:	0e12      	lsrs	r2, r2, #24
    70d6:	72ca      	strb	r2, [r1, #11]
		digit[4] = native[NUM_ECC_DIGITS - 1 - i] >> 32;
    70d8:	7b1a      	ldrb	r2, [r3, #12]
    70da:	730a      	strb	r2, [r1, #12]
		digit[5] = native[NUM_ECC_DIGITS - 1 - i] >> 40;
    70dc:	68da      	ldr	r2, [r3, #12]
    70de:	0a12      	lsrs	r2, r2, #8
    70e0:	734a      	strb	r2, [r1, #13]
		digit[6] = native[NUM_ECC_DIGITS - 1 - i] >> 48;
    70e2:	68da      	ldr	r2, [r3, #12]
    70e4:	0c12      	lsrs	r2, r2, #16
    70e6:	738a      	strb	r2, [r1, #14]
		digit[7] = native[NUM_ECC_DIGITS - 1 - i] >> 56;
    70e8:	68da      	ldr	r2, [r3, #12]
    70ea:	0e12      	lsrs	r2, r2, #24
    70ec:	73ca      	strb	r2, [r1, #15]
static void ecc_native2bytes(const uint64_t native[NUM_ECC_DIGITS],
						uint8_t bytes[ECC_BYTES])
{
	int i;

	for (i = 0; i < NUM_ECC_DIGITS; i++) {
    70ee:	4283      	cmp	r3, r0
    70f0:	d1e5      	bne.n	70be <ecc_native2bytes+0x8>
		digit[4] = native[NUM_ECC_DIGITS - 1 - i] >> 32;
		digit[5] = native[NUM_ECC_DIGITS - 1 - i] >> 40;
		digit[6] = native[NUM_ECC_DIGITS - 1 - i] >> 48;
		digit[7] = native[NUM_ECC_DIGITS - 1 - i] >> 56;
	}
}
    70f2:	4770      	bx	lr

000070f4 <ecc_make_public_key>:

bool ecc_make_public_key(const uint8_t private_key[32], uint8_t public_key[64])
{
    70f4:	b5f0      	push	{r4, r5, r6, r7, lr}
    70f6:	b09b      	sub	sp, #108	; 0x6c
    70f8:	000d      	movs	r5, r1
	struct ecc_point pk;
	uint64_t priv[NUM_ECC_DIGITS];

	ecc_bytes2native(private_key, priv);
    70fa:	a902      	add	r1, sp, #8
    70fc:	f7ff ffb8 	bl	7070 <ecc_bytes2native>

	if (vli_is_zero(priv))
    7100:	a802      	add	r0, sp, #8
    7102:	f7ff f956 	bl	63b2 <vli_is_zero>
    7106:	1e07      	subs	r7, r0, #0
    7108:	d001      	beq.n	710e <ecc_make_public_key+0x1a>
		return false;
    710a:	2000      	movs	r0, #0
    710c:	e022      	b.n	7154 <ecc_make_public_key+0x60>

	/* Make sure the private key is in the range [1, n-1]. */
	if (vli_cmp(curve_n, priv) != 1)
    710e:	4e12      	ldr	r6, [pc, #72]	; (7158 <ecc_make_public_key+0x64>)
    7110:	a902      	add	r1, sp, #8
    7112:	0030      	movs	r0, r6
    7114:	3060      	adds	r0, #96	; 0x60
    7116:	f7ff f98b 	bl	6430 <vli_cmp>
    711a:	0004      	movs	r4, r0
    711c:	2801      	cmp	r0, #1
    711e:	d1f4      	bne.n	710a <ecc_make_public_key+0x16>
		return false;

	ecc_point_mult(&pk, &curve_g, priv, NULL, vli_num_bits(priv));
    7120:	a802      	add	r0, sp, #8
    7122:	f7ff f953 	bl	63cc <vli_num_bits>
    7126:	0031      	movs	r1, r6
    7128:	9000      	str	r0, [sp, #0]
    712a:	3120      	adds	r1, #32
    712c:	a80a      	add	r0, sp, #40	; 0x28
    712e:	003b      	movs	r3, r7
    7130:	aa02      	add	r2, sp, #8
    7132:	f7ff fd8e 	bl	6c52 <ecc_point_mult>

	if (ecc_point_is_zero(&pk))
    7136:	a80a      	add	r0, sp, #40	; 0x28
    7138:	f7ff fcaf 	bl	6a9a <ecc_point_is_zero>
    713c:	2800      	cmp	r0, #0
    713e:	d1e4      	bne.n	710a <ecc_make_public_key+0x16>
		return false;

	ecc_native2bytes(pk.x, public_key);
    7140:	0029      	movs	r1, r5
    7142:	a80a      	add	r0, sp, #40	; 0x28
    7144:	f7ff ffb7 	bl	70b6 <ecc_native2bytes>
	ecc_native2bytes(pk.y, &public_key[32]);
    7148:	0029      	movs	r1, r5
    714a:	a812      	add	r0, sp, #72	; 0x48
    714c:	3120      	adds	r1, #32
    714e:	f7ff ffb2 	bl	70b6 <ecc_native2bytes>

	return true;
    7152:	0020      	movs	r0, r4
}
    7154:	b01b      	add	sp, #108	; 0x6c
    7156:	bdf0      	pop	{r4, r5, r6, r7, pc}
    7158:	10010518 	.word	0x10010518

0000715c <ecc_make_key>:

bool ecc_make_key(uint8_t public_key[64], uint8_t private_key[32])
{
    715c:	b570      	push	{r4, r5, r6, lr}
    715e:	0006      	movs	r6, r0
    7160:	000d      	movs	r5, r1
    7162:	2410      	movs	r4, #16
    7164:	b088      	sub	sp, #32
	uint64_t priv[NUM_ECC_DIGITS];
	unsigned int tries = 0;
	bool result = false;

	for (tries = 0; !result && tries < MAX_TRIES; tries++) {
		if (!get_random_number((uint8_t*)priv))
    7166:	4668      	mov	r0, sp
    7168:	f7ff f902 	bl	6370 <get_random_number>
    716c:	2800      	cmp	r0, #0
    716e:	d009      	beq.n	7184 <ecc_make_key+0x28>
			continue;

		ecc_native2bytes(priv, private_key);
    7170:	0029      	movs	r1, r5
    7172:	4668      	mov	r0, sp
    7174:	f7ff ff9f 	bl	70b6 <ecc_native2bytes>

		result = ecc_make_public_key(private_key, public_key);
    7178:	0031      	movs	r1, r6
    717a:	0028      	movs	r0, r5
    717c:	f7ff ffba 	bl	70f4 <ecc_make_public_key>
{
	uint64_t priv[NUM_ECC_DIGITS];
	unsigned int tries = 0;
	bool result = false;

	for (tries = 0; !result && tries < MAX_TRIES; tries++) {
    7180:	2800      	cmp	r0, #0
    7182:	d103      	bne.n	718c <ecc_make_key+0x30>
    7184:	3c01      	subs	r4, #1
    7186:	2c00      	cmp	r4, #0
    7188:	d1ed      	bne.n	7166 <ecc_make_key+0xa>
    718a:	0020      	movs	r0, r4

		result = ecc_make_public_key(private_key, public_key);
	}

	return result;
}
    718c:	b008      	add	sp, #32
    718e:	bd70      	pop	{r4, r5, r6, pc}

00007190 <ecc_valid_public_key>:

bool ecc_valid_public_key(const uint8_t public_key[64])
{
    7190:	b510      	push	{r4, lr}
    7192:	0004      	movs	r4, r0
    7194:	b090      	sub	sp, #64	; 0x40
	struct ecc_point pk;

	ecc_bytes2native(public_key, pk.x);
    7196:	4669      	mov	r1, sp
    7198:	f7ff ff6a 	bl	7070 <ecc_bytes2native>
	ecc_bytes2native(&public_key[32], pk.y);
    719c:	0020      	movs	r0, r4
    719e:	a908      	add	r1, sp, #32
    71a0:	3020      	adds	r0, #32
    71a2:	f7ff ff65 	bl	7070 <ecc_bytes2native>

	return ecc_valid_point(&pk);
    71a6:	4668      	mov	r0, sp
    71a8:	f7ff ff0c 	bl	6fc4 <ecc_valid_point>
}
    71ac:	b010      	add	sp, #64	; 0x40
    71ae:	bd10      	pop	{r4, pc}

000071b0 <ecdh_shared_secret>:

bool ecdh_shared_secret(const uint8_t public_key[64],
				const uint8_t private_key[32],
				uint8_t secret[32])
{
    71b0:	b5f0      	push	{r4, r5, r6, r7, lr}
	uint64_t priv[NUM_ECC_DIGITS];
	uint64_t rand[NUM_ECC_DIGITS];
	uint8_t  in_rand[32];
	struct ecc_point product, pk;

	M_PRINTF(L_AL,"ecdh_shared_secret. \n");
    71b2:	4d35      	ldr	r5, [pc, #212]	; (7288 <ecdh_shared_secret+0xd8>)
}

bool ecdh_shared_secret(const uint8_t public_key[64],
				const uint8_t private_key[32],
				uint8_t secret[32])
{
    71b4:	b0bd      	sub	sp, #244	; 0xf4
	uint64_t priv[NUM_ECC_DIGITS];
	uint64_t rand[NUM_ECC_DIGITS];
	uint8_t  in_rand[32];
	struct ecc_point product, pk;

	M_PRINTF(L_AL,"ecdh_shared_secret. \n");
    71b6:	682b      	ldr	r3, [r5, #0]
}

bool ecdh_shared_secret(const uint8_t public_key[64],
				const uint8_t private_key[32],
				uint8_t secret[32])
{
    71b8:	0006      	movs	r6, r0
    71ba:	000f      	movs	r7, r1
    71bc:	9203      	str	r2, [sp, #12]
	uint64_t priv[NUM_ECC_DIGITS];
	uint64_t rand[NUM_ECC_DIGITS];
	uint8_t  in_rand[32];
	struct ecc_point product, pk;

	M_PRINTF(L_AL,"ecdh_shared_secret. \n");
    71be:	07db      	lsls	r3, r3, #31
    71c0:	d514      	bpl.n	71ec <ecdh_shared_secret+0x3c>
    71c2:	4c32      	ldr	r4, [pc, #200]	; (728c <ecdh_shared_secret+0xdc>)
    71c4:	0023      	movs	r3, r4
    71c6:	0022      	movs	r2, r4
    71c8:	0020      	movs	r0, r4
    71ca:	3331      	adds	r3, #49	; 0x31
    71cc:	0021      	movs	r1, r4
    71ce:	321c      	adds	r2, #28
    71d0:	9300      	str	r3, [sp, #0]
    71d2:	3022      	adds	r0, #34	; 0x22
    71d4:	4b2e      	ldr	r3, [pc, #184]	; (7290 <ecdh_shared_secret+0xe0>)
    71d6:	f7fd fbe9 	bl	49ac <m_print>
    71da:	0020      	movs	r0, r4
    71dc:	3044      	adds	r0, #68	; 0x44
    71de:	f7fd fbe5 	bl	49ac <m_print>
    71e2:	0020      	movs	r0, r4
    71e4:	1da1      	adds	r1, r4, #6
    71e6:	305a      	adds	r0, #90	; 0x5a
    71e8:	f7fd fbe0 	bl	49ac <m_print>
	
	if (!get_random_number(in_rand))
    71ec:	a814      	add	r0, sp, #80	; 0x50
    71ee:	f7ff f8bf 	bl	6370 <get_random_number>
    71f2:	2800      	cmp	r0, #0
    71f4:	d101      	bne.n	71fa <ecdh_shared_secret+0x4a>
		return false;
    71f6:	2400      	movs	r4, #0
    71f8:	e042      	b.n	7280 <ecdh_shared_secret+0xd0>
		
	ecc_bytes2native(in_rand, rand);
    71fa:	a90c      	add	r1, sp, #48	; 0x30
    71fc:	a814      	add	r0, sp, #80	; 0x50
    71fe:	f7ff ff37 	bl	7070 <ecc_bytes2native>

	ecc_bytes2native(public_key, pk.x);
    7202:	a92c      	add	r1, sp, #176	; 0xb0
    7204:	0030      	movs	r0, r6
    7206:	f7ff ff33 	bl	7070 <ecc_bytes2native>
	ecc_bytes2native(&public_key[32], pk.y);
    720a:	0030      	movs	r0, r6
    720c:	a934      	add	r1, sp, #208	; 0xd0
    720e:	3020      	adds	r0, #32
    7210:	f7ff ff2e 	bl	7070 <ecc_bytes2native>

	if (!ecc_valid_point(&pk))
    7214:	a82c      	add	r0, sp, #176	; 0xb0
    7216:	f7ff fed5 	bl	6fc4 <ecc_valid_point>
    721a:	1e04      	subs	r4, r0, #0
    721c:	d118      	bne.n	7250 <ecdh_shared_secret+0xa0>
	{
		M_PRINTF(L_AL,"ecc_valid_point failed. \n");
    721e:	682b      	ldr	r3, [r5, #0]
    7220:	07db      	lsls	r3, r3, #31
    7222:	d5e8      	bpl.n	71f6 <ecdh_shared_secret+0x46>
    7224:	4d19      	ldr	r5, [pc, #100]	; (728c <ecdh_shared_secret+0xdc>)
    7226:	002b      	movs	r3, r5
    7228:	002a      	movs	r2, r5
    722a:	0028      	movs	r0, r5
    722c:	3331      	adds	r3, #49	; 0x31
    722e:	0029      	movs	r1, r5
    7230:	321c      	adds	r2, #28
    7232:	9300      	str	r3, [sp, #0]
    7234:	3022      	adds	r0, #34	; 0x22
    7236:	4b17      	ldr	r3, [pc, #92]	; (7294 <ecdh_shared_secret+0xe4>)
    7238:	f7fd fbb8 	bl	49ac <m_print>
    723c:	0028      	movs	r0, r5
    723e:	305d      	adds	r0, #93	; 0x5d
    7240:	f7fd fbb4 	bl	49ac <m_print>
    7244:	0028      	movs	r0, r5
    7246:	1da9      	adds	r1, r5, #6
    7248:	305a      	adds	r0, #90	; 0x5a
    724a:	f7fd fbaf 	bl	49ac <m_print>
    724e:	e017      	b.n	7280 <ecdh_shared_secret+0xd0>
		return false;
	}

	ecc_bytes2native(private_key, priv);
    7250:	a904      	add	r1, sp, #16
    7252:	0038      	movs	r0, r7
    7254:	f7ff ff0c 	bl	7070 <ecc_bytes2native>

	ecc_point_mult(&product, &pk, priv, rand, vli_num_bits(priv));
    7258:	a804      	add	r0, sp, #16
    725a:	f7ff f8b7 	bl	63cc <vli_num_bits>
    725e:	ab0c      	add	r3, sp, #48	; 0x30
    7260:	aa04      	add	r2, sp, #16
    7262:	9000      	str	r0, [sp, #0]
    7264:	a92c      	add	r1, sp, #176	; 0xb0
    7266:	a81c      	add	r0, sp, #112	; 0x70
    7268:	f7ff fcf3 	bl	6c52 <ecc_point_mult>

	ecc_native2bytes(product.x, secret);
    726c:	9903      	ldr	r1, [sp, #12]
    726e:	a81c      	add	r0, sp, #112	; 0x70
    7270:	f7ff ff21 	bl	70b6 <ecc_native2bytes>

	return !ecc_point_is_zero(&product);
    7274:	a81c      	add	r0, sp, #112	; 0x70
    7276:	2401      	movs	r4, #1
    7278:	f7ff fc0f 	bl	6a9a <ecc_point_is_zero>
    727c:	4060      	eors	r0, r4
    727e:	b2c4      	uxtb	r4, r0
}
    7280:	0020      	movs	r0, r4
    7282:	b03d      	add	sp, #244	; 0xf4
    7284:	bdf0      	pop	{r4, r5, r6, r7, pc}
    7286:	46c0      	nop			; (mov r8, r8)
    7288:	10010514 	.word	0x10010514
    728c:	00020d6f 	.word	0x00020d6f
    7290:	0000036a 	.word	0x0000036a
    7294:	00000376 	.word	0x00000376

00007298 <vli_mod_sub.constprop.1>:
}

/* Computes result = (left - right) % mod.
 * Assumes that left < mod and right < mod, result != mod.
 */
static void vli_mod_sub(uint64_t *result, const uint64_t *left,
    7298:	b510      	push	{r4, lr}
    729a:	0004      	movs	r4, r0
				const uint64_t *right, const uint64_t *mod)
{
	uint64_t borrow = vli_sub(result, left, right);
    729c:	f7ff f928 	bl	64f0 <vli_sub>

	/* In this case, p_result == -diff == (max int) - diff.
	 * Since -x % d == d - x, we can get the correct result from
	 * result + mod (with overflow).
	 */
	if (borrow)
    72a0:	4301      	orrs	r1, r0
    72a2:	d004      	beq.n	72ae <vli_mod_sub.constprop.1+0x16>
		vli_add(result, result, mod);
    72a4:	4a02      	ldr	r2, [pc, #8]	; (72b0 <vli_mod_sub.constprop.1+0x18>)
    72a6:	0021      	movs	r1, r4
    72a8:	0020      	movs	r0, r4
    72aa:	f7ff f8f3 	bl	6494 <vli_add>
}
    72ae:	bd10      	pop	{r4, pc}
    72b0:	10010518 	.word	0x10010518

000072b4 <vli_mod_add.constprop.2>:
}

/* Computes result = (left + right) % mod.
 * Assumes that left < mod and right < mod, result != mod.
 */
static void vli_mod_add(uint64_t *result, const uint64_t *left,
    72b4:	b570      	push	{r4, r5, r6, lr}
    72b6:	0004      	movs	r4, r0
				const uint64_t *right, const uint64_t *mod)
{
	uint64_t carry;

	carry = vli_add(result, left, right);
    72b8:	f7ff f8ec 	bl	6494 <vli_add>
    72bc:	4d07      	ldr	r5, [pc, #28]	; (72dc <vli_mod_add.constprop.2+0x28>)

	/* result > mod (result = mod + remainder), so subtract mod to
	 * get remainder.
	 */
	if (carry || vli_cmp(result, mod) >= 0)
    72be:	4301      	orrs	r1, r0
    72c0:	d105      	bne.n	72ce <vli_mod_add.constprop.2+0x1a>
    72c2:	0029      	movs	r1, r5
    72c4:	0020      	movs	r0, r4
    72c6:	f7ff f8b3 	bl	6430 <vli_cmp>
    72ca:	2800      	cmp	r0, #0
    72cc:	db04      	blt.n	72d8 <vli_mod_add.constprop.2+0x24>
		vli_sub(result, result, mod);
    72ce:	002a      	movs	r2, r5
    72d0:	0021      	movs	r1, r4
    72d2:	0020      	movs	r0, r4
    72d4:	f7ff f90c 	bl	64f0 <vli_sub>
}
    72d8:	bd70      	pop	{r4, r5, r6, pc}
    72da:	46c0      	nop			; (mov r8, r8)
    72dc:	10010518 	.word	0x10010518

000072e0 <ke_malloc>:
extern void *pvPortMalloc( size_t xWantedSize );
extern size_t xPortGetFreeHeapSize( void );
extern void vPortFree( void *pv );

void *ke_malloc(uint32_t size, uint8_t type)
{
    72e0:	b510      	push	{r4, lr}
	void *tmp = pvPortMalloc(size);
    72e2:	f001 fbbf 	bl	8a64 <pvPortMalloc>
	//M_PRINTF(L_AL, "memAdd[%p] free[%d] size[%d]", tmp, xPortGetFreeHeapSize(), size);
	return tmp;
}
    72e6:	bd10      	pop	{r4, pc}

000072e8 <ke_free>:


void ke_free(void* mem_ptr)
{
    72e8:	b510      	push	{r4, lr}
	ASSERT_ERR(mem_ptr);
    72ea:	2800      	cmp	r0, #0
    72ec:	d100      	bne.n	72f0 <ke_free+0x8>
    72ee:	e7fe      	b.n	72ee <ke_free+0x6>
	//M_PRINTF(L_AL, "memAdd[%p]", mem_ptr);
	vPortFree(mem_ptr);//free(mem_ptr);
    72f0:	f001 fc2e 	bl	8b50 <vPortFree>
}
    72f4:	bd10      	pop	{r4, pc}

000072f6 <ke_event_init>:


event_schedule_t ke_event_env;

void ke_event_init(void)
{
    72f6:	b510      	push	{r4, lr}
    memset(&ke_event_env, 0, sizeof(ke_event_env));
    72f8:	4c04      	ldr	r4, [pc, #16]	; (730c <ke_event_init+0x16>)
    72fa:	2218      	movs	r2, #24
    72fc:	2100      	movs	r1, #0
    72fe:	0020      	movs	r0, r4
    7300:	f00e fba4 	bl	15a4c <memset>
	ASSERT_INFO((event_type < KE_EVENT_MAX) && (p_callback != NULL), event_type, p_callback);

	if(event_type < KE_EVENT_MAX)
	{
		// Store callback
		ke_event_env.callback[event_type] = p_callback;
    7304:	4b02      	ldr	r3, [pc, #8]	; (7310 <ke_event_init+0x1a>)
    7306:	6123      	str	r3, [r4, #16]
void ke_event_init(void)
{
    memset(&ke_event_env, 0, sizeof(ke_event_env));

	ke_event_callback_set(KE_EVENT_KE_MESSAGE, &ke_task_schedule);
}
    7308:	bd10      	pop	{r4, pc}
    730a:	46c0      	nop			; (mov r8, r8)
    730c:	10012860 	.word	0x10012860
    7310:	00007365 	.word	0x00007365

00007314 <ke_event_callback_set>:

uint8_t ke_event_callback_set(uint8_t event_type, void (*p_callback)(void))
{
	uint8_t status = KE_EVENT_CAPA_EXCEEDED;
	
	ASSERT_INFO((event_type < KE_EVENT_MAX) && (p_callback != NULL), event_type, p_callback);
    7314:	2802      	cmp	r0, #2
    7316:	d8fd      	bhi.n	7314 <ke_event_callback_set>
    7318:	2900      	cmp	r1, #0
    731a:	d0fb      	beq.n	7314 <ke_event_callback_set>

	if(event_type < KE_EVENT_MAX)
	{
		// Store callback
		ke_event_env.callback[event_type] = p_callback;
    731c:	4b03      	ldr	r3, [pc, #12]	; (732c <ke_event_callback_set+0x18>)
    731e:	3002      	adds	r0, #2
    7320:	0080      	lsls	r0, r0, #2
    7322:	1818      	adds	r0, r3, r0
    7324:	6041      	str	r1, [r0, #4]
		status = KE_EVENT_OK;
	}

	return (status);

}
    7326:	2000      	movs	r0, #0
    7328:	4770      	bx	lr
    732a:	46c0      	nop			; (mov r8, r8)
    732c:	10012860 	.word	0x10012860

00007330 <ke_event_schedule>:


void ke_event_schedule(void)
{
    7330:	b570      	push	{r4, r5, r6, lr}
    uint32_t field = ke_event_env.event_field;

    while (field) // Compiler is assumed to optimize with loop inversion
    {
        // Find highest priority event set
        hdl = 32 - (uint8_t) co_clz(field) - 1;
    7332:	251f      	movs	r5, #31
void ke_event_schedule(void)
{
    uint8_t hdl;

    // Get the volatile value
    uint32_t field = ke_event_env.event_field;
    7334:	4c0a      	ldr	r4, [pc, #40]	; (7360 <ke_event_schedule+0x30>)
    7336:	68a0      	ldr	r0, [r4, #8]

    while (field) // Compiler is assumed to optimize with loop inversion
    7338:	2800      	cmp	r0, #0
    733a:	d00f      	beq.n	735c <ke_event_schedule+0x2c>
 ****************************************************************************************
 */
__INLINE_S__ uint32_t co_clz(uint32_t val)
{
    #if defined(__arm__)
    return __builtin_clz(val);
    733c:	f016 fd68 	bl	1de10 <__clzsi2>
    {
        // Find highest priority event set
        hdl = 32 - (uint8_t) co_clz(field) - 1;
    7340:	1a28      	subs	r0, r5, r0
    7342:	b2c0      	uxtb	r0, r0

        // Sanity check
        ASSERT_INFO(hdl < KE_EVENT_MAX, hdl, field);
    7344:	2802      	cmp	r0, #2
    7346:	d8fd      	bhi.n	7344 <ke_event_schedule+0x14>

        if(ke_event_env.callback[hdl] != NULL)
    7348:	3002      	adds	r0, #2
    734a:	0080      	lsls	r0, r0, #2
    734c:	1820      	adds	r0, r4, r0
    734e:	6843      	ldr	r3, [r0, #4]
    7350:	2b00      	cmp	r3, #0
    7352:	d002      	beq.n	735a <ke_event_schedule+0x2a>
        {
            // Execute corresponding handler
            (ke_event_env.callback[hdl])();
    7354:	4798      	blx	r3
        {
            ASSERT_ERR(0);
        }

        // Update the volatile value
        field = ke_event_env.event_field;
    7356:	68a0      	ldr	r0, [r4, #8]
    7358:	e7ee      	b.n	7338 <ke_event_schedule+0x8>
    735a:	e7fe      	b.n	735a <ke_event_schedule+0x2a>
    }
}
    735c:	bd70      	pop	{r4, r5, r6, pc}
    735e:	46c0      	nop			; (mov r8, r8)
    7360:	10012860 	.word	0x10012860

00007364 <ke_task_schedule>:


static void ke_task_schedule(void)
{
    7364:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
#define ASSERT_WARN(cond, param0, param1) {while(!(cond));}
#endif

__INLINE_S__ void GLOBAL_INT_DISABLE(void )
{
	__asm volatile ("cpsid i" : : : "memory");
    7366:	b672      	cpsid	i
    {
        int msg_status;
        struct ke_msg *msg;
        // Get a message from the queue
        GLOBAL_INT_DISABLE();
        msg = (struct ke_msg*) co_list_pop_front(&ke_event_env.queue_sent);
    7368:	4d23      	ldr	r5, [pc, #140]	; (73f8 <ke_task_schedule+0x94>)
    736a:	0028      	movs	r0, r5
    736c:	f7fd f83e 	bl	43ec <co_list_pop_front>
        msg->hdr.next = KE_MSG_NOT_IN_QUEUE;
    7370:	2301      	movs	r3, #1
    7372:	425b      	negs	r3, r3
    {
        int msg_status;
        struct ke_msg *msg;
        // Get a message from the queue
        GLOBAL_INT_DISABLE();
        msg = (struct ke_msg*) co_list_pop_front(&ke_event_env.queue_sent);
    7374:	0004      	movs	r4, r0
        msg->hdr.next = KE_MSG_NOT_IN_QUEUE;
    7376:	6003      	str	r3, [r0, #0]
}

__INLINE_S__ void GLOBAL_INT_RESTORE(void)
{
	__asm volatile ("cpsie i" : : : "memory");
    7378:	b662      	cpsie	i
	//M_PRINTF(L_AL, "");
    ke_msg_func_t func = NULL;
#if (BLE_MESH)
    struct ke_task_desc const * p_task_desc = NULL;
	
	p_task_desc = &task_info->desc;
    737a:	4b20      	ldr	r3, [pc, #128]	; (73fc <ke_task_schedule+0x98>)
    737c:	681a      	ldr	r2, [r3, #0]
    // inactive task have no instance, drop message automatically for inactive tasks
    if(p_task_desc->idx_max != 0)
    737e:	8913      	ldrh	r3, [r2, #8]
    7380:	2b00      	cmp	r3, #0
    7382:	d01e      	beq.n	73c2 <ke_task_schedule+0x5e>
    {
        // Search the message handler in the table
        if (p_task_desc->msg_handler_tab)
    7384:	6811      	ldr	r1, [r2, #0]
    7386:	2900      	cmp	r1, #0
    7388:	d01b      	beq.n	73c2 <ke_task_schedule+0x5e>
        {
            func = ke_handler_search(msg_id, p_task_desc->msg_handler_tab, p_task_desc->msg_cnt);
    738a:	8952      	ldrh	r2, [r2, #10]
	//M_PRINTF(L_AL, "msg_id=%d", msg_id);
    // Get the message handler function by parsing the message table
    for (int i = (msg_cnt-1); 0 <= i; --i)
    {
        if ((msg_handler_tab[i].id == msg_id)
                || (msg_handler_tab[i].id == MESH_MSG_DEFAULT_HANDLER))
    738c:	4f1c      	ldr	r7, [pc, #112]	; (7400 <ke_task_schedule+0x9c>)
    738e:	1e53      	subs	r3, r2, #1
    7390:	00db      	lsls	r3, r3, #3
    7392:	18cb      	adds	r3, r1, r3
    7394:	00d1      	lsls	r1, r2, #3
    7396:	424e      	negs	r6, r1
        GLOBAL_INT_RESTORE();
        if (msg == NULL) break;

        // Retrieve a pointer to the task instance data
        //M_PRINTF(L_AL, "msg->id=%d, msg->dest_id=%d", msg->id, msg->dest_id);
        ke_msg_func_t func = ke_task_handler_get(msg->id, msg->dest_id);
    7398:	8880      	ldrh	r0, [r0, #4]
    739a:	9601      	str	r6, [sp, #4]
 */
static ke_msg_func_t ke_handler_search(ke_msg_id_t const msg_id, struct ke_msg_handler const *msg_handler_tab, uint16_t msg_cnt)
{
	//M_PRINTF(L_AL, "msg_id=%d", msg_id);
    // Get the message handler function by parsing the message table
    for (int i = (msg_cnt-1); 0 <= i; --i)
    739c:	2a00      	cmp	r2, #0
    739e:	d010      	beq.n	73c2 <ke_task_schedule+0x5e>
    {
        if ((msg_handler_tab[i].id == msg_id)
    73a0:	9e01      	ldr	r6, [sp, #4]
    73a2:	469c      	mov	ip, r3
    73a4:	199e      	adds	r6, r3, r6
    73a6:	5a76      	ldrh	r6, [r6, r1]
    73a8:	42b0      	cmp	r0, r6
    73aa:	d104      	bne.n	73b6 <ke_task_schedule+0x52>
                || (msg_handler_tab[i].id == MESH_MSG_DEFAULT_HANDLER))
        {
            // If handler is NULL, message should not have been received in this state
            ASSERT_ERR(msg_handler_tab[i].func);
    73ac:	4663      	mov	r3, ip
    73ae:	685e      	ldr	r6, [r3, #4]
    73b0:	2e00      	cmp	r6, #0
    73b2:	d005      	beq.n	73c0 <ke_task_schedule+0x5c>
    73b4:	e006      	b.n	73c4 <ke_task_schedule+0x60>
    73b6:	3a01      	subs	r2, #1
    73b8:	3b08      	subs	r3, #8
	//M_PRINTF(L_AL, "msg_id=%d", msg_id);
    // Get the message handler function by parsing the message table
    for (int i = (msg_cnt-1); 0 <= i; --i)
    {
        if ((msg_handler_tab[i].id == msg_id)
                || (msg_handler_tab[i].id == MESH_MSG_DEFAULT_HANDLER))
    73ba:	42be      	cmp	r6, r7
    73bc:	d1ee      	bne.n	739c <ke_task_schedule+0x38>
    73be:	e7f5      	b.n	73ac <ke_task_schedule+0x48>
    73c0:	e7fe      	b.n	73c0 <ke_task_schedule+0x5c>
    73c2:	e7fe      	b.n	73c2 <ke_task_schedule+0x5e>
        ASSERT_WARN(func != NULL, msg->id, msg->dest_id);

        // Call the message handler
        if (func != NULL)
        {
            msg_status = func(msg->id, ke_msg2param(msg), msg->dest_id, msg->src_id);
    73c4:	0021      	movs	r1, r4
    73c6:	8923      	ldrh	r3, [r4, #8]
    73c8:	88e2      	ldrh	r2, [r4, #6]
    73ca:	310c      	adds	r1, #12
    73cc:	47b0      	blx	r6
        else
        {
            msg_status = KE_MSG_CONSUMED;
        }

        switch (msg_status)
    73ce:	2800      	cmp	r0, #0
    73d0:	d003      	beq.n	73da <ke_task_schedule+0x76>
    73d2:	db06      	blt.n	73e2 <ke_task_schedule+0x7e>
    73d4:	2802      	cmp	r0, #2
    73d6:	dd05      	ble.n	73e4 <ke_task_schedule+0x80>
    73d8:	e003      	b.n	73e2 <ke_task_schedule+0x7e>
}


void ke_msg_free(struct ke_msg const *msg)
{
    ke_free( (void*) msg);
    73da:	0020      	movs	r0, r4
    73dc:	f7ff ff84 	bl	72e8 <ke_free>
    73e0:	e000      	b.n	73e4 <ke_task_schedule+0x80>
    73e2:	e7fe      	b.n	73e2 <ke_task_schedule+0x7e>
#define ASSERT_WARN(cond, param0, param1) {while(!(cond));}
#endif

__INLINE_S__ void GLOBAL_INT_DISABLE(void )
{
	__asm volatile ("cpsid i" : : : "memory");
    73e4:	b672      	cpsid	i
        } // switch case
    } while(0);

    // Verify if we can clear the event bit
    GLOBAL_INT_DISABLE();
    if (co_list_is_empty(&ke_event_env.queue_sent))
    73e6:	682b      	ldr	r3, [r5, #0]
    73e8:	2b00      	cmp	r3, #0
    73ea:	d102      	bne.n	73f2 <ke_task_schedule+0x8e>
        ke_event_clear(KE_EVENT_KE_MESSAGE);
    73ec:	2001      	movs	r0, #1
    73ee:	f000 f829 	bl	7444 <ke_event_clear>
}

__INLINE_S__ void GLOBAL_INT_RESTORE(void)
{
	__asm volatile ("cpsie i" : : : "memory");
    73f2:	b662      	cpsie	i
    GLOBAL_INT_RESTORE();
}
    73f4:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
    73f6:	46c0      	nop			; (mov r8, r8)
    73f8:	10012860 	.word	0x10012860
    73fc:	1001289c 	.word	0x1001289c
    7400:	0000ffff 	.word	0x0000ffff

00007404 <ke_msg_send>:
    // If we execute this line of code, it means that we did not find the handler
    return NULL;
}

void ke_msg_send(void const *param_ptr)
{
    7404:	b510      	push	{r4, lr}
#define ASSERT_WARN(cond, param0, param1) {while(!(cond));}
#endif

__INLINE_S__ void GLOBAL_INT_DISABLE(void )
{
	__asm volatile ("cpsid i" : : : "memory");
    7406:	b672      	cpsid	i
    struct ke_msg * msg = ke_param2msg(param_ptr);
    // Enqueue the message. Protect against IRQs as messages can be sent from IRQ
    GLOBAL_INT_DISABLE();
    co_list_push_back(&ke_event_env.queue_sent, (struct co_list_hdr*)msg);
    7408:	0001      	movs	r1, r0
    740a:	4804      	ldr	r0, [pc, #16]	; (741c <ke_msg_send+0x18>)
    740c:	390c      	subs	r1, #12
    740e:	f7fc ffc2 	bl	4396 <co_list_push_back>
}

__INLINE_S__ void GLOBAL_INT_RESTORE(void)
{
	__asm volatile ("cpsie i" : : : "memory");
    7412:	b662      	cpsie	i

    //Trace sent kernel message
    //TRC_REQ_KE_MSG_SEND(msg);

    // trigger the event
    ke_event_set(KE_EVENT_KE_MESSAGE);
    7414:	2001      	movs	r0, #1
    7416:	f000 f807 	bl	7428 <ke_event_set>
}
    741a:	bd10      	pop	{r4, pc}
    741c:	10012860 	.word	0x10012860

00007420 <ke_msg_free>:


void ke_msg_free(struct ke_msg const *msg)
{
    7420:	b510      	push	{r4, lr}
    ke_free( (void*) msg);
    7422:	f7ff ff61 	bl	72e8 <ke_free>
}
    7426:	bd10      	pop	{r4, pc}

00007428 <ke_event_set>:


void ke_event_set(uint8_t event_type)
{
    ASSERT_INFO((event_type < KE_EVENT_MAX), event_type, 0);
    7428:	2802      	cmp	r0, #2
    742a:	d8fd      	bhi.n	7428 <ke_event_set>
#define ASSERT_WARN(cond, param0, param1) {while(!(cond));}
#endif

__INLINE_S__ void GLOBAL_INT_DISABLE(void )
{
	__asm volatile ("cpsid i" : : : "memory");
    742c:	b672      	cpsid	i

    GLOBAL_INT_DISABLE();

    if(event_type < KE_EVENT_MAX){
        // Set the event in the bit field
        ke_event_env.event_field |= (1 << event_type);
    742e:	2301      	movs	r3, #1
    7430:	4083      	lsls	r3, r0
    7432:	4a03      	ldr	r2, [pc, #12]	; (7440 <ke_event_set+0x18>)
    7434:	6891      	ldr	r1, [r2, #8]
    7436:	430b      	orrs	r3, r1
    7438:	6093      	str	r3, [r2, #8]
}

__INLINE_S__ void GLOBAL_INT_RESTORE(void)
{
	__asm volatile ("cpsie i" : : : "memory");
    743a:	b662      	cpsie	i
    }

    GLOBAL_INT_RESTORE();
}
    743c:	4770      	bx	lr
    743e:	46c0      	nop			; (mov r8, r8)
    7440:	10012860 	.word	0x10012860

00007444 <ke_event_clear>:

void ke_event_clear(uint8_t event_type)
{
    ASSERT_INFO((event_type < KE_EVENT_MAX), event_type, 0);
    7444:	2802      	cmp	r0, #2
    7446:	d8fd      	bhi.n	7444 <ke_event_clear>
#define ASSERT_WARN(cond, param0, param1) {while(!(cond));}
#endif

__INLINE_S__ void GLOBAL_INT_DISABLE(void )
{
	__asm volatile ("cpsid i" : : : "memory");
    7448:	b672      	cpsid	i

    GLOBAL_INT_DISABLE();

    if(event_type < KE_EVENT_MAX){
        // Set the event in the bit field
        ke_event_env.event_field &= ~(1 << event_type);
    744a:	2301      	movs	r3, #1
    744c:	4083      	lsls	r3, r0
    744e:	4a03      	ldr	r2, [pc, #12]	; (745c <ke_event_clear+0x18>)
    7450:	6891      	ldr	r1, [r2, #8]
    7452:	4399      	bics	r1, r3
    7454:	6091      	str	r1, [r2, #8]
}

__INLINE_S__ void GLOBAL_INT_RESTORE(void)
{
	__asm volatile ("cpsie i" : : : "memory");
    7456:	b662      	cpsie	i
    }

    GLOBAL_INT_RESTORE();
}
    7458:	4770      	bx	lr
    745a:	46c0      	nop			; (mov r8, r8)
    745c:	10012860 	.word	0x10012860

00007460 <hw_delay>:

#define BW(addr)			(int)*(addr) << 24 | (int)*(addr + 1) << 16 | (int)*(addr + 2) << 8 | *(addr + 3)

static inline void hw_delay() 
{
	__asm__ __volatile__("nop");
    7460:	46c0      	nop			; (mov r8, r8)
	__asm__ __volatile__("nop");
    7462:	46c0      	nop			; (mov r8, r8)
	__asm__ __volatile__("nop");
    7464:	46c0      	nop			; (mov r8, r8)
	__asm__ __volatile__("nop");
    7466:	46c0      	nop			; (mov r8, r8)
	__asm__ __volatile__("nop");
    7468:	46c0      	nop			; (mov r8, r8)
}
    746a:	4770      	bx	lr

0000746c <mesh_ble_start>:
 * return
 * [0]ble stack start success, [1]staet failed
 ****************************************************************************************
 */
uint32_t mesh_ble_start(mesh_ble_event_callback cb)
{
    746c:	b537      	push	{r0, r1, r2, r4, r5, lr}
    746e:	0005      	movs	r5, r0
	memset(&con_adv_t, 0, sizeof(con_adv_t)); 
    7470:	2222      	movs	r2, #34	; 0x22
    7472:	2100      	movs	r1, #0
    7474:	480f      	ldr	r0, [pc, #60]	; (74b4 <mesh_ble_start+0x48>)
    7476:	f00e fae9 	bl	15a4c <memset>
	M_PRINTF(L_AL, "");
    747a:	4b0f      	ldr	r3, [pc, #60]	; (74b8 <mesh_ble_start+0x4c>)
    747c:	681b      	ldr	r3, [r3, #0]
    747e:	07db      	lsls	r3, r3, #31
    7480:	d514      	bpl.n	74ac <mesh_ble_start+0x40>
    7482:	4c0e      	ldr	r4, [pc, #56]	; (74bc <mesh_ble_start+0x50>)
    7484:	0023      	movs	r3, r4
    7486:	0022      	movs	r2, r4
    7488:	0020      	movs	r0, r4
    748a:	3335      	adds	r3, #53	; 0x35
    748c:	0021      	movs	r1, r4
    748e:	321c      	adds	r2, #28
    7490:	9300      	str	r3, [sp, #0]
    7492:	3026      	adds	r0, #38	; 0x26
    7494:	2330      	movs	r3, #48	; 0x30
    7496:	f7fd fa89 	bl	49ac <m_print>
    749a:	0020      	movs	r0, r4
    749c:	3044      	adds	r0, #68	; 0x44
    749e:	f7fd fa85 	bl	49ac <m_print>
    74a2:	0020      	movs	r0, r4
    74a4:	1da1      	adds	r1, r4, #6
    74a6:	3045      	adds	r0, #69	; 0x45
    74a8:	f7fd fa80 	bl	49ac <m_print>
	//mesh_adv_scan_start(100);

	bleCb = cb;
    74ac:	4b04      	ldr	r3, [pc, #16]	; (74c0 <mesh_ble_start+0x54>)
	return 0;
}
    74ae:	2000      	movs	r0, #0
{
	memset(&con_adv_t, 0, sizeof(con_adv_t)); 
	M_PRINTF(L_AL, "");
	//mesh_adv_scan_start(100);

	bleCb = cb;
    74b0:	601d      	str	r5, [r3, #0]
	return 0;
}
    74b2:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
    74b4:	10012878 	.word	0x10012878
    74b8:	10010514 	.word	0x10010514
    74bc:	00020def 	.word	0x00020def
    74c0:	1001123c 	.word	0x1001123c

000074c4 <mesh_ble_process>:
 ****************************************************************************************
 * @brief process ble event
 ****************************************************************************************
 */
void mesh_ble_process(void)
{
    74c4:	b510      	push	{r4, lr}
	//M_PRINTF(L_AL, "");
	IPC_DealSingleStep();
    74c6:	f7f9 fba9 	bl	c1c <IPC_DealSingleStep>
	//HCI_RecvProcess();
}
    74ca:	bd10      	pop	{r4, pc}

000074cc <mesh_ble_stop>:
 * @brief stop ble stack and unset event callback function
 ****************************************************************************************
 */
void mesh_ble_stop()
{
	M_PRINTF(L_AL, "");
    74cc:	4b0d      	ldr	r3, [pc, #52]	; (7504 <mesh_ble_stop+0x38>)
 ****************************************************************************************
 * @brief stop ble stack and unset event callback function
 ****************************************************************************************
 */
void mesh_ble_stop()
{
    74ce:	b513      	push	{r0, r1, r4, lr}
	M_PRINTF(L_AL, "");
    74d0:	681b      	ldr	r3, [r3, #0]
    74d2:	07db      	lsls	r3, r3, #31
    74d4:	d514      	bpl.n	7500 <mesh_ble_stop+0x34>
    74d6:	4c0c      	ldr	r4, [pc, #48]	; (7508 <mesh_ble_stop+0x3c>)
    74d8:	0023      	movs	r3, r4
    74da:	0022      	movs	r2, r4
    74dc:	0020      	movs	r0, r4
    74de:	3348      	adds	r3, #72	; 0x48
    74e0:	0021      	movs	r1, r4
    74e2:	321c      	adds	r2, #28
    74e4:	9300      	str	r3, [sp, #0]
    74e6:	3026      	adds	r0, #38	; 0x26
    74e8:	234b      	movs	r3, #75	; 0x4b
    74ea:	f7fd fa5f 	bl	49ac <m_print>
    74ee:	0020      	movs	r0, r4
    74f0:	3044      	adds	r0, #68	; 0x44
    74f2:	f7fd fa5b 	bl	49ac <m_print>
    74f6:	0020      	movs	r0, r4
    74f8:	1da1      	adds	r1, r4, #6
    74fa:	3045      	adds	r0, #69	; 0x45
    74fc:	f7fd fa56 	bl	49ac <m_print>
}
    7500:	bd13      	pop	{r0, r1, r4, pc}
    7502:	46c0      	nop			; (mov r8, r8)
    7504:	10010514 	.word	0x10010514
    7508:	00020def 	.word	0x00020def

0000750c <mesh_ble_event_set>:

uint32_t mesh_ble_event_set(MESH_BLE_EVENT ev, void* param)
{
	if(bleCb == NULL)
    750c:	4b04      	ldr	r3, [pc, #16]	; (7520 <mesh_ble_event_set+0x14>)
{
	M_PRINTF(L_AL, "");
}

uint32_t mesh_ble_event_set(MESH_BLE_EVENT ev, void* param)
{
    750e:	b510      	push	{r4, lr}
	if(bleCb == NULL)
    7510:	681b      	ldr	r3, [r3, #0]
		return 0;
    7512:	1e1a      	subs	r2, r3, #0
	M_PRINTF(L_AL, "");
}

uint32_t mesh_ble_event_set(MESH_BLE_EVENT ev, void* param)
{
	if(bleCb == NULL)
    7514:	d001      	beq.n	751a <mesh_ble_event_set+0xe>
		return 0;
	return bleCb(ev, param);
    7516:	4798      	blx	r3
    7518:	0002      	movs	r2, r0
}
    751a:	0010      	movs	r0, r2
    751c:	bd10      	pop	{r4, pc}
    751e:	46c0      	nop			; (mov r8, r8)
    7520:	1001123c 	.word	0x1001123c

00007524 <adv_close_cb>:
 ****************************************************************************************
 * @brief start non-connectable and non-scannable undirected advertising events
 ****************************************************************************************
 */
void adv_close_cb(int params)
{
    7524:	b570      	push	{r4, r5, r6, lr}
	if(!stAdvSave.enable){
    7526:	4c11      	ldr	r4, [pc, #68]	; (756c <adv_close_cb+0x48>)
    7528:	7925      	ldrb	r5, [r4, #4]
    752a:	2d00      	cmp	r5, #0
    752c:	d107      	bne.n	753e <adv_close_cb+0x1a>
		m_printf(L_AL, "close nonconnect adv");
    752e:	4910      	ldr	r1, [pc, #64]	; (7570 <adv_close_cb+0x4c>)
    7530:	2001      	movs	r0, #1
    7532:	3156      	adds	r1, #86	; 0x56
    7534:	f7fd fa5c 	bl	49f0 <m_printf>
		HWRITE(mem_le_adv_enable, 0x00);
    7538:	4b0e      	ldr	r3, [pc, #56]	; (7574 <adv_close_cb+0x50>)
    753a:	701d      	strb	r5, [r3, #0]
    753c:	e014      	b.n	7568 <adv_close_cb+0x44>
		return;
	}
	HWRITE(mem_le_adv_type, stAdvSave.advType);
    753e:	7962      	ldrb	r2, [r4, #5]
    7540:	4b0d      	ldr	r3, [pc, #52]	; (7578 <adv_close_cb+0x54>)
    7542:	701a      	strb	r2, [r3, #0]
	HW_REG_16BIT(reg_map(mem_le_adv_interval_max), stAdvSave.itl);	
    7544:	88e5      	ldrh	r5, [r4, #6]
#define OS_EXIT_CRITICAL() __enable_irq() 


static inline void HW_REG_16BIT(uint32_t reg, uint16_t word)
{
    HW_REG_8BIT(reg, word & 0x00FF);
    7546:	4b0d      	ldr	r3, [pc, #52]	; (757c <adv_close_cb+0x58>)
    7548:	b2ea      	uxtb	r2, r5
    754a:	701a      	strb	r2, [r3, #0]
    hw_delay();
    754c:	f7ff ff88 	bl	7460 <hw_delay>
    HW_REG_8BIT(reg + 1,(word >> 8));
    7550:	4b0b      	ldr	r3, [pc, #44]	; (7580 <adv_close_cb+0x5c>)
    7552:	0a2d      	lsrs	r5, r5, #8
    7554:	701d      	strb	r5, [r3, #0]
	memcpy((unsigned char*)reg_map(mem_le_adv_data),stAdvSave.data,stAdvSave.len);
    7556:	3408      	adds	r4, #8
    7558:	7fe2      	ldrb	r2, [r4, #31]
    755a:	0021      	movs	r1, r4
    755c:	4809      	ldr	r0, [pc, #36]	; (7584 <adv_close_cb+0x60>)
    755e:	f00e fa37 	bl	159d0 <memcpy>
	HWRITE(mem_le_adv_data_len,stAdvSave.len);
    7562:	7fe2      	ldrb	r2, [r4, #31]
    7564:	4b08      	ldr	r3, [pc, #32]	; (7588 <adv_close_cb+0x64>)
    7566:	701a      	strb	r2, [r3, #0]
}
    7568:	bd70      	pop	{r4, r5, r6, pc}
    756a:	46c0      	nop			; (mov r8, r8)
    756c:	1001123c 	.word	0x1001123c
    7570:	00020def 	.word	0x00020def
    7574:	100043b1 	.word	0x100043b1
    7578:	100044ee 	.word	0x100044ee
    757c:	100044ec 	.word	0x100044ec
    7580:	100044ed 	.word	0x100044ed
    7584:	100043b3 	.word	0x100043b3
    7588:	100043b2 	.word	0x100043b2

0000758c <mesh_adv_data_send>:

void mesh_adv_data_send(uint16_t itl, uint8_t nb, uint16_t len, const uint8_t* data)
{
    758c:	b5f0      	push	{r4, r5, r6, r7, lr}
    758e:	0016      	movs	r6, r2
    7590:	b085      	sub	sp, #20
	if(HREAD(mem_le_adv_enable)){
    7592:	4a31      	ldr	r2, [pc, #196]	; (7658 <mesh_adv_data_send+0xcc>)
	memcpy((unsigned char*)reg_map(mem_le_adv_data),stAdvSave.data,stAdvSave.len);
	HWRITE(mem_le_adv_data_len,stAdvSave.len);
}

void mesh_adv_data_send(uint16_t itl, uint8_t nb, uint16_t len, const uint8_t* data)
{
    7594:	9102      	str	r1, [sp, #8]
    7596:	001f      	movs	r7, r3
	if(HREAD(mem_le_adv_enable)){
    7598:	7813      	ldrb	r3, [r2, #0]
	memcpy((unsigned char*)reg_map(mem_le_adv_data),stAdvSave.data,stAdvSave.len);
	HWRITE(mem_le_adv_data_len,stAdvSave.len);
}

void mesh_adv_data_send(uint16_t itl, uint8_t nb, uint16_t len, const uint8_t* data)
{
    759a:	0005      	movs	r5, r0
	if(HREAD(mem_le_adv_enable)){
    759c:	b2db      	uxtb	r3, r3
    759e:	9203      	str	r2, [sp, #12]
    75a0:	482e      	ldr	r0, [pc, #184]	; (765c <mesh_adv_data_send+0xd0>)
    75a2:	2b00      	cmp	r3, #0
    75a4:	d010      	beq.n	75c8 <mesh_adv_data_send+0x3c>
		stAdvSave.enable = 1;
    75a6:	2301      	movs	r3, #1
    75a8:	7103      	strb	r3, [r0, #4]
		stAdvSave.advType = HREAD(mem_le_adv_type);
    75aa:	4b2d      	ldr	r3, [pc, #180]	; (7660 <mesh_adv_data_send+0xd4>)
		stAdvSave.itl = HREAD(mem_le_adv_interval_max);
		stAdvSave.len = HREAD(mem_le_adv_data_len);
		memcpy(stAdvSave.data, (unsigned char*)reg_map(mem_le_adv_data), stAdvSave.len);
    75ac:	492d      	ldr	r1, [pc, #180]	; (7664 <mesh_adv_data_send+0xd8>)

void mesh_adv_data_send(uint16_t itl, uint8_t nb, uint16_t len, const uint8_t* data)
{
	if(HREAD(mem_le_adv_enable)){
		stAdvSave.enable = 1;
		stAdvSave.advType = HREAD(mem_le_adv_type);
    75ae:	781b      	ldrb	r3, [r3, #0]
    75b0:	7143      	strb	r3, [r0, #5]
		stAdvSave.itl = HREAD(mem_le_adv_interval_max);
    75b2:	4b2d      	ldr	r3, [pc, #180]	; (7668 <mesh_adv_data_send+0xdc>)
    75b4:	781b      	ldrb	r3, [r3, #0]
    75b6:	80c3      	strh	r3, [r0, #6]
		stAdvSave.len = HREAD(mem_le_adv_data_len);
    75b8:	4b2c      	ldr	r3, [pc, #176]	; (766c <mesh_adv_data_send+0xe0>)
    75ba:	3008      	adds	r0, #8
    75bc:	781a      	ldrb	r2, [r3, #0]
    75be:	b2d2      	uxtb	r2, r2
    75c0:	77c2      	strb	r2, [r0, #31]
		memcpy(stAdvSave.data, (unsigned char*)reg_map(mem_le_adv_data), stAdvSave.len);
    75c2:	f00e fa05 	bl	159d0 <memcpy>
    75c6:	e000      	b.n	75ca <mesh_adv_data_send+0x3e>
	}
	else{
		stAdvSave.enable = 0;
    75c8:	7103      	strb	r3, [r0, #4]
	}
	M_PRINTF(L_AL, "itl[%d] nb[%d]", itl, nb);
    75ca:	4b29      	ldr	r3, [pc, #164]	; (7670 <mesh_adv_data_send+0xe4>)
    75cc:	681b      	ldr	r3, [r3, #0]
    75ce:	07db      	lsls	r3, r3, #31
    75d0:	d516      	bpl.n	7600 <mesh_adv_data_send+0x74>
    75d2:	4c28      	ldr	r4, [pc, #160]	; (7674 <mesh_adv_data_send+0xe8>)
    75d4:	0023      	movs	r3, r4
    75d6:	0022      	movs	r2, r4
    75d8:	0020      	movs	r0, r4
    75da:	336b      	adds	r3, #107	; 0x6b
    75dc:	321c      	adds	r2, #28
    75de:	9300      	str	r3, [sp, #0]
    75e0:	0021      	movs	r1, r4
    75e2:	2373      	movs	r3, #115	; 0x73
    75e4:	3026      	adds	r0, #38	; 0x26
    75e6:	f7fd f9e1 	bl	49ac <m_print>
    75ea:	0020      	movs	r0, r4
    75ec:	0029      	movs	r1, r5
    75ee:	307e      	adds	r0, #126	; 0x7e
    75f0:	9a02      	ldr	r2, [sp, #8]
    75f2:	f7fd f9db 	bl	49ac <m_print>
    75f6:	0020      	movs	r0, r4
    75f8:	1da1      	adds	r1, r4, #6
    75fa:	3045      	adds	r0, #69	; 0x45
    75fc:	f7fd f9d6 	bl	49ac <m_print>
	m_printf_hex(L_AL, "mesh adv data send", data, len);
    7600:	491d      	ldr	r1, [pc, #116]	; (7678 <mesh_adv_data_send+0xec>)
    7602:	0033      	movs	r3, r6
    7604:	003a      	movs	r2, r7
    7606:	310d      	adds	r1, #13
    7608:	2001      	movs	r0, #1
    760a:	f7fd fa2f 	bl	4a6c <m_printf_hex>
	HWRITE(mem_le_adv_type, ADV_TYPE_NOCONNECT);
    760e:	2302      	movs	r3, #2
    7610:	4a13      	ldr	r2, [pc, #76]	; (7660 <mesh_adv_data_send+0xd4>)
    7612:	7013      	strb	r3, [r2, #0]
#define OS_EXIT_CRITICAL() __enable_irq() 


static inline void HW_REG_16BIT(uint32_t reg, uint16_t word)
{
    HW_REG_8BIT(reg, word & 0x00FF);
    7614:	4a14      	ldr	r2, [pc, #80]	; (7668 <mesh_adv_data_send+0xdc>)
    7616:	b2eb      	uxtb	r3, r5
    7618:	7013      	strb	r3, [r2, #0]
    hw_delay();
    761a:	f7ff ff21 	bl	7460 <hw_delay>
    HW_REG_8BIT(reg + 1,(word >> 8));
    761e:	4b17      	ldr	r3, [pc, #92]	; (767c <mesh_adv_data_send+0xf0>)
    7620:	0a2a      	lsrs	r2, r5, #8
    7622:	701a      	strb	r2, [r3, #0]
	HW_REG_16BIT(reg_map(mem_le_adv_interval_max), itl);	
	memcpy((unsigned char*)reg_map(mem_le_adv_data),data,len);
    7624:	0039      	movs	r1, r7
    7626:	0032      	movs	r2, r6
    7628:	480e      	ldr	r0, [pc, #56]	; (7664 <mesh_adv_data_send+0xd8>)
    762a:	f00e f9d1 	bl	159d0 <memcpy>
	HWRITE(mem_le_adv_data_len,len);
    762e:	4b0f      	ldr	r3, [pc, #60]	; (766c <mesh_adv_data_send+0xe0>)
    7630:	b2f6      	uxtb	r6, r6
    7632:	701e      	strb	r6, [r3, #0]

	HWRITE(mem_le_adv_enable, 0x01);
    7634:	2301      	movs	r3, #1
    7636:	9a03      	ldr	r2, [sp, #12]

	//start timer to close adv
	SYS_SetTimer(&stAdvTimer, (nb)*itl/10+10, TIMER_SINGLE, adv_close_cb);
    7638:	210a      	movs	r1, #10
	HWRITE(mem_le_adv_type, ADV_TYPE_NOCONNECT);
	HW_REG_16BIT(reg_map(mem_le_adv_interval_max), itl);	
	memcpy((unsigned char*)reg_map(mem_le_adv_data),data,len);
	HWRITE(mem_le_adv_data_len,len);

	HWRITE(mem_le_adv_enable, 0x01);
    763a:	7013      	strb	r3, [r2, #0]

	//start timer to close adv
	SYS_SetTimer(&stAdvTimer, (nb)*itl/10+10, TIMER_SINGLE, adv_close_cb);
    763c:	9802      	ldr	r0, [sp, #8]
    763e:	4368      	muls	r0, r5
    7640:	f7fc fe2d 	bl	429e <__aeabi_idiv>
    7644:	0001      	movs	r1, r0
    7646:	4805      	ldr	r0, [pc, #20]	; (765c <mesh_adv_data_send+0xd0>)
    7648:	310a      	adds	r1, #10
    764a:	4b0d      	ldr	r3, [pc, #52]	; (7680 <mesh_adv_data_send+0xf4>)
    764c:	2200      	movs	r2, #0
    764e:	3028      	adds	r0, #40	; 0x28
    7650:	f7fa fb7e 	bl	1d50 <SYS_SetTimer>
}
    7654:	b005      	add	sp, #20
    7656:	bdf0      	pop	{r4, r5, r6, r7, pc}
    7658:	100043b1 	.word	0x100043b1
    765c:	1001123c 	.word	0x1001123c
    7660:	100044ee 	.word	0x100044ee
    7664:	100043b3 	.word	0x100043b3
    7668:	100044ec 	.word	0x100044ec
    766c:	100043b2 	.word	0x100043b2
    7670:	10010514 	.word	0x10010514
    7674:	00020def 	.word	0x00020def
    7678:	00020e6f 	.word	0x00020e6f
    767c:	100044ed 	.word	0x100044ed
    7680:	00007525 	.word	0x00007525

00007684 <mesh_con_adv_data_send>:
 ****************************************************************************************
 * @brief start connectable and scannable undirected advertising events
 ****************************************************************************************
 */
void mesh_con_adv_data_send(uint16_t itl, uint16_t len, const uint8_t* data)
{	
    7684:	b5f0      	push	{r4, r5, r6, r7, lr}
#if 1
	// 02 01 02
	uint8_t advD[] = {2,1,2};
    7686:	4d30      	ldr	r5, [pc, #192]	; (7748 <mesh_con_adv_data_send+0xc4>)
 ****************************************************************************************
 * @brief start connectable and scannable undirected advertising events
 ****************************************************************************************
 */
void mesh_con_adv_data_send(uint16_t itl, uint16_t len, const uint8_t* data)
{	
    7688:	000e      	movs	r6, r1
#if 1
	// 02 01 02
	uint8_t advD[] = {2,1,2};
    768a:	0029      	movs	r1, r5
 ****************************************************************************************
 * @brief start connectable and scannable undirected advertising events
 ****************************************************************************************
 */
void mesh_con_adv_data_send(uint16_t itl, uint16_t len, const uint8_t* data)
{	
    768c:	b087      	sub	sp, #28
    768e:	0004      	movs	r4, r0
    7690:	9203      	str	r2, [sp, #12]
#if 1
	// 02 01 02
	uint8_t advD[] = {2,1,2};
    7692:	3120      	adds	r1, #32
    7694:	2203      	movs	r2, #3
    7696:	a805      	add	r0, sp, #20
    7698:	f00e f99a 	bl	159d0 <memcpy>

	con_adv_t.state = 1;
    769c:	2301      	movs	r3, #1
    769e:	482b      	ldr	r0, [pc, #172]	; (774c <mesh_con_adv_data_send+0xc8>)
	con_adv_t.len = len + 3;
    76a0:	b2f7      	uxtb	r7, r6
{	
#if 1
	// 02 01 02
	uint8_t advD[] = {2,1,2};

	con_adv_t.state = 1;
    76a2:	7003      	strb	r3, [r0, #0]
	con_adv_t.len = len + 3;
    76a4:	1cfb      	adds	r3, r7, #3
    76a6:	7043      	strb	r3, [r0, #1]
	con_adv_t.itl = itl;
    76a8:	b2e3      	uxtb	r3, r4
    76aa:	9302      	str	r3, [sp, #8]
    76ac:	466b      	mov	r3, sp
    76ae:	7a1b      	ldrb	r3, [r3, #8]
    76b0:	3002      	adds	r0, #2
	
	memcpy(con_adv_t.data, advD, sizeof(advD));
    76b2:	2203      	movs	r2, #3
    76b4:	a905      	add	r1, sp, #20
	// 02 01 02
	uint8_t advD[] = {2,1,2};

	con_adv_t.state = 1;
	con_adv_t.len = len + 3;
	con_adv_t.itl = itl;
    76b6:	77c3      	strb	r3, [r0, #31]
	
	memcpy(con_adv_t.data, advD, sizeof(advD));
    76b8:	f00e f98a 	bl	159d0 <memcpy>
	memcpy(con_adv_t.data+3, data, len);
    76bc:	0032      	movs	r2, r6
    76be:	9903      	ldr	r1, [sp, #12]
    76c0:	4823      	ldr	r0, [pc, #140]	; (7750 <mesh_con_adv_data_send+0xcc>)
    76c2:	f00e f985 	bl	159d0 <memcpy>
	M_PRINTF(L_AL, "itl = %d", itl);
    76c6:	2201      	movs	r2, #1
    76c8:	4b22      	ldr	r3, [pc, #136]	; (7754 <mesh_con_adv_data_send+0xd0>)
    76ca:	681b      	ldr	r3, [r3, #0]
    76cc:	4213      	tst	r3, r2
    76ce:	d015      	beq.n	76fc <mesh_con_adv_data_send+0x78>
    76d0:	4e21      	ldr	r6, [pc, #132]	; (7758 <mesh_con_adv_data_send+0xd4>)
    76d2:	002b      	movs	r3, r5
    76d4:	0032      	movs	r2, r6
    76d6:	0030      	movs	r0, r6
    76d8:	3323      	adds	r3, #35	; 0x23
    76da:	321c      	adds	r2, #28
    76dc:	9300      	str	r3, [sp, #0]
    76de:	0031      	movs	r1, r6
    76e0:	2391      	movs	r3, #145	; 0x91
    76e2:	3026      	adds	r0, #38	; 0x26
    76e4:	f7fd f962 	bl	49ac <m_print>
    76e8:	0028      	movs	r0, r5
    76ea:	0021      	movs	r1, r4
    76ec:	303a      	adds	r0, #58	; 0x3a
    76ee:	f7fd f95d 	bl	49ac <m_print>
    76f2:	0030      	movs	r0, r6
    76f4:	1db1      	adds	r1, r6, #6
    76f6:	3045      	adds	r0, #69	; 0x45
    76f8:	f7fd f958 	bl	49ac <m_print>
	m_printf_hex(L_AL, "mesh con adv data send", con_adv_t.data, con_adv_t.len);
    76fc:	4d13      	ldr	r5, [pc, #76]	; (774c <mesh_con_adv_data_send+0xc8>)
    76fe:	4e17      	ldr	r6, [pc, #92]	; (775c <mesh_con_adv_data_send+0xd8>)
    7700:	4911      	ldr	r1, [pc, #68]	; (7748 <mesh_con_adv_data_send+0xc4>)
    7702:	786b      	ldrb	r3, [r5, #1]
    7704:	0032      	movs	r2, r6
    7706:	3143      	adds	r1, #67	; 0x43
    7708:	2001      	movs	r0, #1
    770a:	f7fd f9af 	bl	4a6c <m_printf_hex>
	
	if(con_adv_t.len > 31  || con_adv_t.len <=0 )
    770e:	786b      	ldrb	r3, [r5, #1]
    7710:	3b01      	subs	r3, #1
    7712:	2b1e      	cmp	r3, #30
    7714:	d815      	bhi.n	7742 <mesh_con_adv_data_send+0xbe>
		return ;
	//MSH_SetAdvType(ADV_TYPE_NOMAL);
	HWRITE(mem_le_adv_type, ADV_TYPE_NOMAL);
    7716:	2200      	movs	r2, #0
    7718:	4b11      	ldr	r3, [pc, #68]	; (7760 <mesh_con_adv_data_send+0xdc>)
    771a:	0a24      	lsrs	r4, r4, #8
    771c:	701a      	strb	r2, [r3, #0]
#define OS_EXIT_CRITICAL() __enable_irq() 


static inline void HW_REG_16BIT(uint32_t reg, uint16_t word)
{
    HW_REG_8BIT(reg, word & 0x00FF);
    771e:	466a      	mov	r2, sp
    7720:	4b10      	ldr	r3, [pc, #64]	; (7764 <mesh_con_adv_data_send+0xe0>)
    7722:	7a12      	ldrb	r2, [r2, #8]
    7724:	701a      	strb	r2, [r3, #0]
    hw_delay();
    7726:	f7ff fe9b 	bl	7460 <hw_delay>
    HW_REG_8BIT(reg + 1,(word >> 8));
    772a:	4b0f      	ldr	r3, [pc, #60]	; (7768 <mesh_con_adv_data_send+0xe4>)
	//MSH_SetAdvInterval(itl);	
	HW_REG_16BIT(reg_map(mem_le_adv_interval_max), itl);
	memcpy((unsigned char*)reg_map(mem_le_adv_data),con_adv_t.data,con_adv_t.len);
    772c:	0031      	movs	r1, r6
    772e:	701c      	strb	r4, [r3, #0]
    7730:	786a      	ldrb	r2, [r5, #1]
    7732:	480e      	ldr	r0, [pc, #56]	; (776c <mesh_con_adv_data_send+0xe8>)
    7734:	f00e f94c 	bl	159d0 <memcpy>
	HWRITE(mem_le_adv_data_len,len);

	HWRITE(mem_le_adv_enable, 0x01);
    7738:	2201      	movs	r2, #1
	//MSH_SetAdvType(ADV_TYPE_NOMAL);
	HWRITE(mem_le_adv_type, ADV_TYPE_NOMAL);
	//MSH_SetAdvInterval(itl);	
	HW_REG_16BIT(reg_map(mem_le_adv_interval_max), itl);
	memcpy((unsigned char*)reg_map(mem_le_adv_data),con_adv_t.data,con_adv_t.len);
	HWRITE(mem_le_adv_data_len,len);
    773a:	4b0d      	ldr	r3, [pc, #52]	; (7770 <mesh_con_adv_data_send+0xec>)
    773c:	701f      	strb	r7, [r3, #0]

	HWRITE(mem_le_adv_enable, 0x01);
    773e:	4b0d      	ldr	r3, [pc, #52]	; (7774 <mesh_con_adv_data_send+0xf0>)
    7740:	701a      	strb	r2, [r3, #0]

#endif
	
}
    7742:	b007      	add	sp, #28
    7744:	bdf0      	pop	{r4, r5, r6, r7, pc}
    7746:	46c0      	nop			; (mov r8, r8)
    7748:	00020e6f 	.word	0x00020e6f
    774c:	10012878 	.word	0x10012878
    7750:	1001287d 	.word	0x1001287d
    7754:	10010514 	.word	0x10010514
    7758:	00020def 	.word	0x00020def
    775c:	1001287a 	.word	0x1001287a
    7760:	100044ee 	.word	0x100044ee
    7764:	100044ec 	.word	0x100044ec
    7768:	100044ed 	.word	0x100044ed
    776c:	100043b3 	.word	0x100043b3
    7770:	100043b2 	.word	0x100043b2
    7774:	100043b1 	.word	0x100043b1

00007778 <mesh_con_adv_stop>:
 * @brief stop connectable adversting
 ****************************************************************************************
 */
void mesh_con_adv_stop(void)
{
	M_PRINTF(L_AL, "");
    7778:	4b0e      	ldr	r3, [pc, #56]	; (77b4 <mesh_con_adv_stop+0x3c>)
 ****************************************************************************************
 * @brief stop connectable adversting
 ****************************************************************************************
 */
void mesh_con_adv_stop(void)
{
    777a:	b513      	push	{r0, r1, r4, lr}
	M_PRINTF(L_AL, "");
    777c:	681b      	ldr	r3, [r3, #0]
    777e:	07db      	lsls	r3, r3, #31
    7780:	d514      	bpl.n	77ac <mesh_con_adv_stop+0x34>
    7782:	4c0d      	ldr	r4, [pc, #52]	; (77b8 <mesh_con_adv_stop+0x40>)
    7784:	4b0d      	ldr	r3, [pc, #52]	; (77bc <mesh_con_adv_stop+0x44>)
    7786:	0022      	movs	r2, r4
    7788:	0020      	movs	r0, r4
    778a:	335a      	adds	r3, #90	; 0x5a
    778c:	0021      	movs	r1, r4
    778e:	321c      	adds	r2, #28
    7790:	9300      	str	r3, [sp, #0]
    7792:	3026      	adds	r0, #38	; 0x26
    7794:	23aa      	movs	r3, #170	; 0xaa
    7796:	f7fd f909 	bl	49ac <m_print>
    779a:	0020      	movs	r0, r4
    779c:	3044      	adds	r0, #68	; 0x44
    779e:	f7fd f905 	bl	49ac <m_print>
    77a2:	0020      	movs	r0, r4
    77a4:	1da1      	adds	r1, r4, #6
    77a6:	3045      	adds	r0, #69	; 0x45
    77a8:	f7fd f900 	bl	49ac <m_print>
	HWRITE(mem_le_adv_enable, 0x00);
    77ac:	2200      	movs	r2, #0
    77ae:	4b04      	ldr	r3, [pc, #16]	; (77c0 <mesh_con_adv_stop+0x48>)
    77b0:	701a      	strb	r2, [r3, #0]
}
    77b2:	bd13      	pop	{r0, r1, r4, pc}
    77b4:	10010514 	.word	0x10010514
    77b8:	00020def 	.word	0x00020def
    77bc:	00020e6f 	.word	0x00020e6f
    77c0:	100043b1 	.word	0x100043b1

000077c4 <mesh_con_stop>:
 * @param[in] handle	need to closed connected handle 
 ****************************************************************************************
 */
void mesh_con_stop(uint16_t handle)
{
	M_PRINTF(L_AL, "");
    77c4:	4b0e      	ldr	r3, [pc, #56]	; (7800 <mesh_con_stop+0x3c>)
 *
 * @param[in] handle	need to closed connected handle 
 ****************************************************************************************
 */
void mesh_con_stop(uint16_t handle)
{
    77c6:	b513      	push	{r0, r1, r4, lr}
	M_PRINTF(L_AL, "");
    77c8:	681b      	ldr	r3, [r3, #0]
    77ca:	07db      	lsls	r3, r3, #31
    77cc:	d514      	bpl.n	77f8 <mesh_con_stop+0x34>
    77ce:	4c0d      	ldr	r4, [pc, #52]	; (7804 <mesh_con_stop+0x40>)
    77d0:	4b0d      	ldr	r3, [pc, #52]	; (7808 <mesh_con_stop+0x44>)
    77d2:	0022      	movs	r2, r4
    77d4:	0020      	movs	r0, r4
    77d6:	336c      	adds	r3, #108	; 0x6c
    77d8:	0021      	movs	r1, r4
    77da:	321c      	adds	r2, #28
    77dc:	9300      	str	r3, [sp, #0]
    77de:	3026      	adds	r0, #38	; 0x26
    77e0:	23b7      	movs	r3, #183	; 0xb7
    77e2:	f7fd f8e3 	bl	49ac <m_print>
    77e6:	0020      	movs	r0, r4
    77e8:	3044      	adds	r0, #68	; 0x44
    77ea:	f7fd f8df 	bl	49ac <m_print>
    77ee:	0020      	movs	r0, r4
    77f0:	1da1      	adds	r1, r4, #6
    77f2:	3045      	adds	r0, #69	; 0x45
    77f4:	f7fd f8da 	bl	49ac <m_print>
	IPC_TxControlCmd(IPC_CMD_LE_DISCONNECT);
    77f8:	2011      	movs	r0, #17
    77fa:	f7f9 f998 	bl	b2e <IPC_TxControlCmd>
}
    77fe:	bd13      	pop	{r0, r1, r4, pc}
    7800:	10010514 	.word	0x10010514
    7804:	00020def 	.word	0x00020def
    7808:	00020e6f 	.word	0x00020e6f

0000780c <mesh_adv_scan_start>:
* @brief scan start function
****************************************************************************************
*/
void mesh_adv_scan_start(uint16_t itl)
{
	M_PRINTF(L_AL, "itl = 0x%02x", itl);
    780c:	4b1a      	ldr	r3, [pc, #104]	; (7878 <mesh_adv_scan_start+0x6c>)
****************************************************************************************
* @brief scan start function
****************************************************************************************
*/
void mesh_adv_scan_start(uint16_t itl)
{
    780e:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	M_PRINTF(L_AL, "itl = 0x%02x", itl);
    7810:	681b      	ldr	r3, [r3, #0]
****************************************************************************************
* @brief scan start function
****************************************************************************************
*/
void mesh_adv_scan_start(uint16_t itl)
{
    7812:	0005      	movs	r5, r0
	M_PRINTF(L_AL, "itl = 0x%02x", itl);
    7814:	07db      	lsls	r3, r3, #31
    7816:	d515      	bpl.n	7844 <mesh_adv_scan_start+0x38>
    7818:	4c18      	ldr	r4, [pc, #96]	; (787c <mesh_adv_scan_start+0x70>)
    781a:	4b19      	ldr	r3, [pc, #100]	; (7880 <mesh_adv_scan_start+0x74>)
    781c:	0022      	movs	r2, r4
    781e:	0020      	movs	r0, r4
    7820:	337a      	adds	r3, #122	; 0x7a
    7822:	321c      	adds	r2, #28
    7824:	9300      	str	r3, [sp, #0]
    7826:	0021      	movs	r1, r4
    7828:	23c2      	movs	r3, #194	; 0xc2
    782a:	3026      	adds	r0, #38	; 0x26
    782c:	f7fd f8be 	bl	49ac <m_print>
    7830:	4814      	ldr	r0, [pc, #80]	; (7884 <mesh_adv_scan_start+0x78>)
    7832:	0029      	movs	r1, r5
    7834:	300e      	adds	r0, #14
    7836:	f7fd f8b9 	bl	49ac <m_print>
    783a:	0020      	movs	r0, r4
    783c:	1da1      	adds	r1, r4, #6
    783e:	3045      	adds	r0, #69	; 0x45
    7840:	f7fd f8b4 	bl	49ac <m_print>
#define OS_EXIT_CRITICAL() __enable_irq() 


static inline void HW_REG_16BIT(uint32_t reg, uint16_t word)
{
    HW_REG_8BIT(reg, word & 0x00FF);
    7844:	2330      	movs	r3, #48	; 0x30
    7846:	4f10      	ldr	r7, [pc, #64]	; (7888 <mesh_adv_scan_start+0x7c>)
    hw_delay();
    HW_REG_8BIT(reg + 1,(word >> 8));
    7848:	4e10      	ldr	r6, [pc, #64]	; (788c <mesh_adv_scan_start+0x80>)
#define OS_EXIT_CRITICAL() __enable_irq() 


static inline void HW_REG_16BIT(uint32_t reg, uint16_t word)
{
    HW_REG_8BIT(reg, word & 0x00FF);
    784a:	703b      	strb	r3, [r7, #0]
    hw_delay();
    784c:	f7ff fe08 	bl	7460 <hw_delay>
    HW_REG_8BIT(reg + 1,(word >> 8));
    7850:	2300      	movs	r3, #0

	HW_REG_16BIT(reg_map(mem_le_scan_interval), 48);
	
	HWRITE(mem_le_scan_type, SCAN_TYPE_PASSIVE);	//Set scan type: 
    7852:	4a0f      	ldr	r2, [pc, #60]	; (7890 <mesh_adv_scan_start+0x84>)
#define OS_EXIT_CRITICAL() __enable_irq() 


static inline void HW_REG_16BIT(uint32_t reg, uint16_t word)
{
    HW_REG_8BIT(reg, word & 0x00FF);
    7854:	b2ec      	uxtb	r4, r5
    hw_delay();
    HW_REG_8BIT(reg + 1,(word >> 8));
    7856:	7033      	strb	r3, [r6, #0]
    7858:	7013      	strb	r3, [r2, #0]
#define OS_EXIT_CRITICAL() __enable_irq() 


static inline void HW_REG_16BIT(uint32_t reg, uint16_t word)
{
    HW_REG_8BIT(reg, word & 0x00FF);
    785a:	703c      	strb	r4, [r7, #0]
    hw_delay();
    785c:	f7ff fe00 	bl	7460 <hw_delay>
#define OS_EXIT_CRITICAL() __enable_irq() 


static inline void HW_REG_16BIT(uint32_t reg, uint16_t word)
{
    HW_REG_8BIT(reg, word & 0x00FF);
    7860:	4b0c      	ldr	r3, [pc, #48]	; (7894 <mesh_adv_scan_start+0x88>)
    hw_delay();
    HW_REG_8BIT(reg + 1,(word >> 8));
    7862:	0a2d      	lsrs	r5, r5, #8
    7864:	7035      	strb	r5, [r6, #0]
#define OS_EXIT_CRITICAL() __enable_irq() 


static inline void HW_REG_16BIT(uint32_t reg, uint16_t word)
{
    HW_REG_8BIT(reg, word & 0x00FF);
    7866:	701c      	strb	r4, [r3, #0]
    hw_delay();
    7868:	f7ff fdfa 	bl	7460 <hw_delay>
											//1.SCAN_TYPE_ACTIVE, both adv and scan response can be received;
											//2.SCAN_TYPE_PASSIVE, only can receive adv.
	
	HW_REG_16BIT(reg_map(mem_le_scan_interval), itl);
	HW_REG_16BIT(reg_map(mem_le_scan_window), itl);
	HWRITE(mem_le_scan_enable,0x01);
    786c:	2201      	movs	r2, #1
    HW_REG_8BIT(reg + 1,(word >> 8));
    786e:	4b0a      	ldr	r3, [pc, #40]	; (7898 <mesh_adv_scan_start+0x8c>)
    7870:	701d      	strb	r5, [r3, #0]
    7872:	4b0a      	ldr	r3, [pc, #40]	; (789c <mesh_adv_scan_start+0x90>)
    7874:	701a      	strb	r2, [r3, #0]
}
    7876:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
    7878:	10010514 	.word	0x10010514
    787c:	00020def 	.word	0x00020def
    7880:	00020e6f 	.word	0x00020e6f
    7884:	00020eef 	.word	0x00020eef
    7888:	100043ac 	.word	0x100043ac
    788c:	100043ad 	.word	0x100043ad
    7890:	10004509 	.word	0x10004509
    7894:	100043ae 	.word	0x100043ae
    7898:	100043af 	.word	0x100043af
    789c:	100043ab 	.word	0x100043ab

000078a0 <mesh_adv_scan_stop>:
* @brief scan stop function
****************************************************************************************
*/
void mesh_adv_scan_stop(void)
{
	M_PRINTF(L_AL, "");
    78a0:	4b0e      	ldr	r3, [pc, #56]	; (78dc <mesh_adv_scan_stop+0x3c>)
****************************************************************************************
* @brief scan stop function
****************************************************************************************
*/
void mesh_adv_scan_stop(void)
{
    78a2:	b513      	push	{r0, r1, r4, lr}
	M_PRINTF(L_AL, "");
    78a4:	681b      	ldr	r3, [r3, #0]
    78a6:	07db      	lsls	r3, r3, #31
    78a8:	d514      	bpl.n	78d4 <mesh_adv_scan_stop+0x34>
    78aa:	4c0d      	ldr	r4, [pc, #52]	; (78e0 <mesh_adv_scan_stop+0x40>)
    78ac:	4b0d      	ldr	r3, [pc, #52]	; (78e4 <mesh_adv_scan_stop+0x44>)
    78ae:	0022      	movs	r2, r4
    78b0:	0020      	movs	r0, r4
    78b2:	331b      	adds	r3, #27
    78b4:	0021      	movs	r1, r4
    78b6:	321c      	adds	r2, #28
    78b8:	9300      	str	r3, [sp, #0]
    78ba:	3026      	adds	r0, #38	; 0x26
    78bc:	23d6      	movs	r3, #214	; 0xd6
    78be:	f7fd f875 	bl	49ac <m_print>
    78c2:	0020      	movs	r0, r4
    78c4:	3044      	adds	r0, #68	; 0x44
    78c6:	f7fd f871 	bl	49ac <m_print>
    78ca:	0020      	movs	r0, r4
    78cc:	1da1      	adds	r1, r4, #6
    78ce:	3045      	adds	r0, #69	; 0x45
    78d0:	f7fd f86c 	bl	49ac <m_print>
	IPC_TxControlCmd(IPC_CMD_STOP_SCAN);
    78d4:	2018      	movs	r0, #24
    78d6:	f7f9 f92a 	bl	b2e <IPC_TxControlCmd>
}
    78da:	bd13      	pop	{r0, r1, r4, pc}
    78dc:	10010514 	.word	0x10010514
    78e0:	00020def 	.word	0x00020def
    78e4:	00020eef 	.word	0x00020eef

000078e8 <mesh_con_notify>:
data: value
len: length of packet to send
****************************************************************************************
*/
uint32_t mesh_con_notify(uint16_t handle, uint8_t* data, uint32_t len)
{
    78e8:	b5f0      	push	{r4, r5, r6, r7, lr}
	M_PRINTF(L_AL, "");
    78ea:	4b1d      	ldr	r3, [pc, #116]	; (7960 <mesh_con_notify+0x78>)
data: value
len: length of packet to send
****************************************************************************************
*/
uint32_t mesh_con_notify(uint16_t handle, uint8_t* data, uint32_t len)
{
    78ec:	b089      	sub	sp, #36	; 0x24
	M_PRINTF(L_AL, "");
    78ee:	681b      	ldr	r3, [r3, #0]
data: value
len: length of packet to send
****************************************************************************************
*/
uint32_t mesh_con_notify(uint16_t handle, uint8_t* data, uint32_t len)
{
    78f0:	0007      	movs	r7, r0
    78f2:	000e      	movs	r6, r1
    78f4:	0015      	movs	r5, r2
	M_PRINTF(L_AL, "");
    78f6:	07db      	lsls	r3, r3, #31
    78f8:	d514      	bpl.n	7924 <mesh_con_notify+0x3c>
    78fa:	4c1a      	ldr	r4, [pc, #104]	; (7964 <mesh_con_notify+0x7c>)
    78fc:	4b1a      	ldr	r3, [pc, #104]	; (7968 <mesh_con_notify+0x80>)
    78fe:	0022      	movs	r2, r4
    7900:	0020      	movs	r0, r4
    7902:	332e      	adds	r3, #46	; 0x2e
    7904:	0021      	movs	r1, r4
    7906:	321c      	adds	r2, #28
    7908:	9300      	str	r3, [sp, #0]
    790a:	3026      	adds	r0, #38	; 0x26
    790c:	23e4      	movs	r3, #228	; 0xe4
    790e:	f7fd f84d 	bl	49ac <m_print>
    7912:	0020      	movs	r0, r4
    7914:	3044      	adds	r0, #68	; 0x44
    7916:	f7fd f849 	bl	49ac <m_print>
    791a:	0020      	movs	r0, r4
    791c:	1da1      	adds	r1, r4, #6
    791e:	3045      	adds	r0, #69	; 0x45
    7920:	f7fd f844 	bl	49ac <m_print>
	uint8_t BleSendData[24]={0};
    7924:	ac02      	add	r4, sp, #8
    7926:	2218      	movs	r2, #24
    7928:	2100      	movs	r1, #0
    792a:	0020      	movs	r0, r4
    792c:	f00e f88e 	bl	15a4c <memset>
	uint8_t cnt;

	ASSERT_ERR(len>0 && len<=20);
    7930:	1e6b      	subs	r3, r5, #1
    7932:	2b13      	cmp	r3, #19
    7934:	d8fd      	bhi.n	7932 <mesh_con_notify+0x4a>
	
	IPC_DATA_FORMAT* temp = (IPC_DATA_FORMAT*)BleSendData;

	temp->ipctype =IPC_BLE_DATA;
    7936:	2305      	movs	r3, #5
    7938:	7023      	strb	r3, [r4, #0]
	temp->len = len+2;
    793a:	1cab      	adds	r3, r5, #2
    793c:	7063      	strb	r3, [r4, #1]
	temp->ipcUnion.uBleData.mhandle = handle;

	unsigned char *dataAy = (unsigned char *)&temp->ipcUnion.uBleData.data;

	for(cnt=0; cnt<len; cnt++){
    793e:	2300      	movs	r3, #0
	
	IPC_DATA_FORMAT* temp = (IPC_DATA_FORMAT*)BleSendData;

	temp->ipctype =IPC_BLE_DATA;
	temp->len = len+2;
	temp->ipcUnion.uBleData.mhandle = handle;
    7940:	8067      	strh	r7, [r4, #2]

	unsigned char *dataAy = (unsigned char *)&temp->ipcUnion.uBleData.data;

	for(cnt=0; cnt<len; cnt++){
		*(dataAy+cnt) = *(data+cnt);
    7942:	aa03      	add	r2, sp, #12
	temp->len = len+2;
	temp->ipcUnion.uBleData.mhandle = handle;

	unsigned char *dataAy = (unsigned char *)&temp->ipcUnion.uBleData.data;

	for(cnt=0; cnt<len; cnt++){
    7944:	429d      	cmp	r5, r3
    7946:	d904      	bls.n	7952 <mesh_con_notify+0x6a>
		*(dataAy+cnt) = *(data+cnt);
    7948:	5cf1      	ldrb	r1, [r6, r3]
    794a:	54d1      	strb	r1, [r2, r3]
	temp->len = len+2;
	temp->ipcUnion.uBleData.mhandle = handle;

	unsigned char *dataAy = (unsigned char *)&temp->ipcUnion.uBleData.data;

	for(cnt=0; cnt<len; cnt++){
    794c:	3301      	adds	r3, #1
    794e:	b2db      	uxtb	r3, r3
    7950:	e7f8      	b.n	7944 <mesh_con_notify+0x5c>
		*(dataAy+cnt) = *(data+cnt);
	}
	IPC_TxPacket(temp);
    7952:	0020      	movs	r0, r4
    7954:	f7f9 f8e2 	bl	b1c <IPC_TxPacket>
	return 0;
}
    7958:	2000      	movs	r0, #0
    795a:	b009      	add	sp, #36	; 0x24
    795c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    795e:	46c0      	nop			; (mov r8, r8)
    7960:	10010514 	.word	0x10010514
    7964:	00020def 	.word	0x00020def
    7968:	00020eef 	.word	0x00020eef

0000796c <mesh_con_read_cfm>:
len: length of packet to send
****************************************************************************************
*/
uint32_t mesh_con_read_cfm(uint16_t handle, uint8_t* data, uint32_t len)
{
	M_PRINTF(L_AL, "");
    796c:	4b0e      	ldr	r3, [pc, #56]	; (79a8 <mesh_con_read_cfm+0x3c>)
data: value
len: length of packet to send
****************************************************************************************
*/
uint32_t mesh_con_read_cfm(uint16_t handle, uint8_t* data, uint32_t len)
{
    796e:	b513      	push	{r0, r1, r4, lr}
	M_PRINTF(L_AL, "");
    7970:	681b      	ldr	r3, [r3, #0]
    7972:	07db      	lsls	r3, r3, #31
    7974:	d515      	bpl.n	79a2 <mesh_con_read_cfm+0x36>
    7976:	4b0d      	ldr	r3, [pc, #52]	; (79ac <mesh_con_read_cfm+0x40>)
    7978:	4c0d      	ldr	r4, [pc, #52]	; (79b0 <mesh_con_read_cfm+0x44>)
    797a:	333e      	adds	r3, #62	; 0x3e
    797c:	9300      	str	r3, [sp, #0]
    797e:	0022      	movs	r2, r4
    7980:	0020      	movs	r0, r4
    7982:	2381      	movs	r3, #129	; 0x81
    7984:	0021      	movs	r1, r4
    7986:	321c      	adds	r2, #28
    7988:	005b      	lsls	r3, r3, #1
    798a:	3026      	adds	r0, #38	; 0x26
    798c:	f7fd f80e 	bl	49ac <m_print>
    7990:	0020      	movs	r0, r4
    7992:	3044      	adds	r0, #68	; 0x44
    7994:	f7fd f80a 	bl	49ac <m_print>
    7998:	0020      	movs	r0, r4
    799a:	1da1      	adds	r1, r4, #6
    799c:	3045      	adds	r0, #69	; 0x45
    799e:	f7fd f805 	bl	49ac <m_print>
	return 0;
}
    79a2:	2000      	movs	r0, #0
    79a4:	bd16      	pop	{r1, r2, r4, pc}
    79a6:	46c0      	nop			; (mov r8, r8)
    79a8:	10010514 	.word	0x10010514
    79ac:	00020eef 	.word	0x00020eef
    79b0:	00020def 	.word	0x00020def

000079b4 <mesh_con_write_rsp>:
handle: characteristic handle
****************************************************************************************
*/
uint8_t mesh_con_write_rsp(uint16_t handle)
{
	M_PRINTF(L_AL, "");
    79b4:	4b0e      	ldr	r3, [pc, #56]	; (79f0 <mesh_con_write_rsp+0x3c>)
* @brief write response function
handle: characteristic handle
****************************************************************************************
*/
uint8_t mesh_con_write_rsp(uint16_t handle)
{
    79b6:	b513      	push	{r0, r1, r4, lr}
	M_PRINTF(L_AL, "");
    79b8:	681b      	ldr	r3, [r3, #0]
    79ba:	07db      	lsls	r3, r3, #31
    79bc:	d515      	bpl.n	79ea <mesh_con_write_rsp+0x36>
    79be:	4b0d      	ldr	r3, [pc, #52]	; (79f4 <mesh_con_write_rsp+0x40>)
    79c0:	4c0d      	ldr	r4, [pc, #52]	; (79f8 <mesh_con_write_rsp+0x44>)
    79c2:	3350      	adds	r3, #80	; 0x50
    79c4:	9300      	str	r3, [sp, #0]
    79c6:	0022      	movs	r2, r4
    79c8:	0020      	movs	r0, r4
    79ca:	230e      	movs	r3, #14
    79cc:	0021      	movs	r1, r4
    79ce:	321c      	adds	r2, #28
    79d0:	33ff      	adds	r3, #255	; 0xff
    79d2:	3026      	adds	r0, #38	; 0x26
    79d4:	f7fc ffea 	bl	49ac <m_print>
    79d8:	0020      	movs	r0, r4
    79da:	3044      	adds	r0, #68	; 0x44
    79dc:	f7fc ffe6 	bl	49ac <m_print>
    79e0:	0020      	movs	r0, r4
    79e2:	1da1      	adds	r1, r4, #6
    79e4:	3045      	adds	r0, #69	; 0x45
    79e6:	f7fc ffe1 	bl	49ac <m_print>
	return 0;
}
    79ea:	2000      	movs	r0, #0
    79ec:	bd16      	pop	{r1, r2, r4, pc}
    79ee:	46c0      	nop			; (mov r8, r8)
    79f0:	10010514 	.word	0x10010514
    79f4:	00020eef 	.word	0x00020eef
    79f8:	00020def 	.word	0x00020def

000079fc <gattc_get_mtu>:
* @brief Get mtu size
****************************************************************************************
*/
uint32_t gattc_get_mtu(uint8_t conidx)
{
	M_PRINTF(L_AL, "");
    79fc:	4b0e      	ldr	r3, [pc, #56]	; (7a38 <gattc_get_mtu+0x3c>)
****************************************************************************************
* @brief Get mtu size
****************************************************************************************
*/
uint32_t gattc_get_mtu(uint8_t conidx)
{
    79fe:	b513      	push	{r0, r1, r4, lr}
	M_PRINTF(L_AL, "");
    7a00:	681b      	ldr	r3, [r3, #0]
    7a02:	07db      	lsls	r3, r3, #31
    7a04:	d515      	bpl.n	7a32 <gattc_get_mtu+0x36>
    7a06:	4b0d      	ldr	r3, [pc, #52]	; (7a3c <gattc_get_mtu+0x40>)
    7a08:	4c0d      	ldr	r4, [pc, #52]	; (7a40 <gattc_get_mtu+0x44>)
    7a0a:	3363      	adds	r3, #99	; 0x63
    7a0c:	9300      	str	r3, [sp, #0]
    7a0e:	0022      	movs	r2, r4
    7a10:	0020      	movs	r0, r4
    7a12:	238c      	movs	r3, #140	; 0x8c
    7a14:	0021      	movs	r1, r4
    7a16:	321c      	adds	r2, #28
    7a18:	005b      	lsls	r3, r3, #1
    7a1a:	3026      	adds	r0, #38	; 0x26
    7a1c:	f7fc ffc6 	bl	49ac <m_print>
    7a20:	0020      	movs	r0, r4
    7a22:	3044      	adds	r0, #68	; 0x44
    7a24:	f7fc ffc2 	bl	49ac <m_print>
    7a28:	0020      	movs	r0, r4
    7a2a:	1da1      	adds	r1, r4, #6
    7a2c:	3045      	adds	r0, #69	; 0x45
    7a2e:	f7fc ffbd 	bl	49ac <m_print>
	return 196;
}
    7a32:	20c4      	movs	r0, #196	; 0xc4
    7a34:	bd16      	pop	{r1, r2, r4, pc}
    7a36:	46c0      	nop			; (mov r8, r8)
    7a38:	10010514 	.word	0x10010514
    7a3c:	00020eef 	.word	0x00020eef
    7a40:	00020def 	.word	0x00020def

00007a44 <attm_reserve_handle_range>:


uint8_t attm_reserve_handle_range(uint16_t* start_hdl, uint8_t nb_att)
{
	M_PRINTF(L_AL, "");
    7a44:	4b0e      	ldr	r3, [pc, #56]	; (7a80 <attm_reserve_handle_range+0x3c>)
	return 196;
}


uint8_t attm_reserve_handle_range(uint16_t* start_hdl, uint8_t nb_att)
{
    7a46:	b513      	push	{r0, r1, r4, lr}
	M_PRINTF(L_AL, "");
    7a48:	681b      	ldr	r3, [r3, #0]
    7a4a:	07db      	lsls	r3, r3, #31
    7a4c:	d515      	bpl.n	7a7a <attm_reserve_handle_range+0x36>
    7a4e:	4b0d      	ldr	r3, [pc, #52]	; (7a84 <attm_reserve_handle_range+0x40>)
    7a50:	4c0d      	ldr	r4, [pc, #52]	; (7a88 <attm_reserve_handle_range+0x44>)
    7a52:	3371      	adds	r3, #113	; 0x71
    7a54:	9300      	str	r3, [sp, #0]
    7a56:	0022      	movs	r2, r4
    7a58:	0020      	movs	r0, r4
    7a5a:	2320      	movs	r3, #32
    7a5c:	0021      	movs	r1, r4
    7a5e:	321c      	adds	r2, #28
    7a60:	33ff      	adds	r3, #255	; 0xff
    7a62:	3026      	adds	r0, #38	; 0x26
    7a64:	f7fc ffa2 	bl	49ac <m_print>
    7a68:	0020      	movs	r0, r4
    7a6a:	3044      	adds	r0, #68	; 0x44
    7a6c:	f7fc ff9e 	bl	49ac <m_print>
    7a70:	0020      	movs	r0, r4
    7a72:	1da1      	adds	r1, r4, #6
    7a74:	3045      	adds	r0, #69	; 0x45
    7a76:	f7fc ff99 	bl	49ac <m_print>
	//need dynamic allocation service
	return 0;
}
    7a7a:	2000      	movs	r0, #0
    7a7c:	bd16      	pop	{r1, r2, r4, pc}
    7a7e:	46c0      	nop			; (mov r8, r8)
    7a80:	10010514 	.word	0x10010514
    7a84:	00020eef 	.word	0x00020eef
    7a88:	00020def 	.word	0x00020def

00007a8c <attm_svc_create_db>:

uint8_t attm_svc_create_db(uint16_t *shdl, uint16_t uuid, uint8_t *cfg_flag, uint8_t max_nb_att,
                           uint8_t *att_tbl, ke_task_id_t const dest_id,
                           const struct attm_desc *att_db, uint8_t svc_perm)
{
	M_PRINTF(L_AL, "");
    7a8c:	4b14      	ldr	r3, [pc, #80]	; (7ae0 <attm_svc_create_db+0x54>)
}

uint8_t attm_svc_create_db(uint16_t *shdl, uint16_t uuid, uint8_t *cfg_flag, uint8_t max_nb_att,
                           uint8_t *att_tbl, ke_task_id_t const dest_id,
                           const struct attm_desc *att_db, uint8_t svc_perm)
{
    7a8e:	b573      	push	{r0, r1, r4, r5, r6, lr}
	M_PRINTF(L_AL, "");
    7a90:	681b      	ldr	r3, [r3, #0]
}

uint8_t attm_svc_create_db(uint16_t *shdl, uint16_t uuid, uint8_t *cfg_flag, uint8_t max_nb_att,
                           uint8_t *att_tbl, ke_task_id_t const dest_id,
                           const struct attm_desc *att_db, uint8_t svc_perm)
{
    7a92:	0005      	movs	r5, r0
    7a94:	000e      	movs	r6, r1
	M_PRINTF(L_AL, "");
    7a96:	07db      	lsls	r3, r3, #31
    7a98:	d515      	bpl.n	7ac6 <attm_svc_create_db+0x3a>
    7a9a:	4b12      	ldr	r3, [pc, #72]	; (7ae4 <attm_svc_create_db+0x58>)
    7a9c:	4c12      	ldr	r4, [pc, #72]	; (7ae8 <attm_svc_create_db+0x5c>)
    7a9e:	330b      	adds	r3, #11
    7aa0:	9300      	str	r3, [sp, #0]
    7aa2:	0022      	movs	r2, r4
    7aa4:	0020      	movs	r0, r4
    7aa6:	2394      	movs	r3, #148	; 0x94
    7aa8:	0021      	movs	r1, r4
    7aaa:	321c      	adds	r2, #28
    7aac:	005b      	lsls	r3, r3, #1
    7aae:	3026      	adds	r0, #38	; 0x26
    7ab0:	f7fc ff7c 	bl	49ac <m_print>
    7ab4:	0020      	movs	r0, r4
    7ab6:	3044      	adds	r0, #68	; 0x44
    7ab8:	f7fc ff78 	bl	49ac <m_print>
    7abc:	0020      	movs	r0, r4
    7abe:	1da1      	adds	r1, r4, #6
    7ac0:	3045      	adds	r0, #69	; 0x45
    7ac2:	f7fc ff73 	bl	49ac <m_print>
	if(uuid == ATT_SVC_MESH_PROVISIONING){
    7ac6:	4b09      	ldr	r3, [pc, #36]	; (7aec <attm_svc_create_db+0x60>)
    7ac8:	429e      	cmp	r6, r3
    7aca:	d102      	bne.n	7ad2 <attm_svc_create_db+0x46>
		*shdl = 0x1B;
    7acc:	231b      	movs	r3, #27
    7ace:	802b      	strh	r3, [r5, #0]
    7ad0:	e004      	b.n	7adc <attm_svc_create_db+0x50>
	}else if(uuid == ATT_SVC_MESH_PROXY){
    7ad2:	4b07      	ldr	r3, [pc, #28]	; (7af0 <attm_svc_create_db+0x64>)
    7ad4:	429e      	cmp	r6, r3
    7ad6:	d101      	bne.n	7adc <attm_svc_create_db+0x50>
		*shdl = 0x21;
    7ad8:	2321      	movs	r3, #33	; 0x21
    7ada:	802b      	strh	r3, [r5, #0]
	}
	
	return 0;
}
    7adc:	2000      	movs	r0, #0
    7ade:	bd76      	pop	{r1, r2, r4, r5, r6, pc}
    7ae0:	10010514 	.word	0x10010514
    7ae4:	00020f6f 	.word	0x00020f6f
    7ae8:	00020def 	.word	0x00020def
    7aec:	00001827 	.word	0x00001827
    7af0:	00001828 	.word	0x00001828

00007af4 <attmdb_svc_visibility_set>:
*  - @ref ATT_ERR_INVALID_HANDLE: If start_hdl given in parameter or UUIDs value invalid
****************************************************************************************
*/
uint8_t attmdb_svc_visibility_set(uint16_t handle, bool hide)
{
	M_PRINTF(L_AL, "");
    7af4:	4b0e      	ldr	r3, [pc, #56]	; (7b30 <attmdb_svc_visibility_set+0x3c>)
*  - @ref ATT_ERR_NO_ERROR: If service allocation succeeds.
*  - @ref ATT_ERR_INVALID_HANDLE: If start_hdl given in parameter or UUIDs value invalid
****************************************************************************************
*/
uint8_t attmdb_svc_visibility_set(uint16_t handle, bool hide)
{
    7af6:	b513      	push	{r0, r1, r4, lr}
	M_PRINTF(L_AL, "");
    7af8:	681b      	ldr	r3, [r3, #0]
    7afa:	07db      	lsls	r3, r3, #31
    7afc:	d515      	bpl.n	7b2a <attmdb_svc_visibility_set+0x36>
    7afe:	4b0d      	ldr	r3, [pc, #52]	; (7b34 <attmdb_svc_visibility_set+0x40>)
    7b00:	4c0d      	ldr	r4, [pc, #52]	; (7b38 <attmdb_svc_visibility_set+0x44>)
    7b02:	331e      	adds	r3, #30
    7b04:	9300      	str	r3, [sp, #0]
    7b06:	0022      	movs	r2, r4
    7b08:	0020      	movs	r0, r4
    7b0a:	23a0      	movs	r3, #160	; 0xa0
    7b0c:	0021      	movs	r1, r4
    7b0e:	321c      	adds	r2, #28
    7b10:	005b      	lsls	r3, r3, #1
    7b12:	3026      	adds	r0, #38	; 0x26
    7b14:	f7fc ff4a 	bl	49ac <m_print>
    7b18:	0020      	movs	r0, r4
    7b1a:	3044      	adds	r0, #68	; 0x44
    7b1c:	f7fc ff46 	bl	49ac <m_print>
    7b20:	0020      	movs	r0, r4
    7b22:	1da1      	adds	r1, r4, #6
    7b24:	3045      	adds	r0, #69	; 0x45
    7b26:	f7fc ff41 	bl	49ac <m_print>
	return 0;
}
    7b2a:	2000      	movs	r0, #0
    7b2c:	bd16      	pop	{r1, r2, r4, pc}
    7b2e:	46c0      	nop			; (mov r8, r8)
    7b30:	10010514 	.word	0x10010514
    7b34:	00020f6f 	.word	0x00020f6f
    7b38:	00020def 	.word	0x00020def

00007b3c <mesh_mac_set>:
 *  - 0: If set success.
 *  - 1: If ser failed.
 ****************************************************************************************
 */
uint8_t mesh_mac_set(bool reversal, uint8_t* mac)
{
    7b3c:	b510      	push	{r4, lr}
	uint8_t* addr = (uint8_t*)reg_map(mem_le_lap);
	if(memcmp(addr, mac, 6)){
    7b3e:	2206      	movs	r2, #6
    7b40:	4809      	ldr	r0, [pc, #36]	; (7b68 <mesh_mac_set+0x2c>)
 *  - 0: If set success.
 *  - 1: If ser failed.
 ****************************************************************************************
 */
uint8_t mesh_mac_set(bool reversal, uint8_t* mac)
{
    7b42:	000c      	movs	r4, r1
	uint8_t* addr = (uint8_t*)reg_map(mem_le_lap);
	if(memcmp(addr, mac, 6)){
    7b44:	f00d ff1c 	bl	15980 <memcmp>
    7b48:	2800      	cmp	r0, #0
    7b4a:	d00b      	beq.n	7b64 <mesh_mac_set+0x28>
		m_printf_hex(L_AL, "set mac", mac, 6);
    7b4c:	4907      	ldr	r1, [pc, #28]	; (7b6c <mesh_mac_set+0x30>)
    7b4e:	0022      	movs	r2, r4
    7b50:	3138      	adds	r1, #56	; 0x38
    7b52:	2306      	movs	r3, #6
    7b54:	2001      	movs	r0, #1
    7b56:	f7fc ff89 	bl	4a6c <m_printf_hex>
		memcpy(addr, mac, 6);	
    7b5a:	2206      	movs	r2, #6
    7b5c:	0021      	movs	r1, r4
    7b5e:	4802      	ldr	r0, [pc, #8]	; (7b68 <mesh_mac_set+0x2c>)
    7b60:	f00d ff36 	bl	159d0 <memcpy>
	}
	return 0;
}
    7b64:	2000      	movs	r0, #0
    7b66:	bd10      	pop	{r4, pc}
    7b68:	1000450c 	.word	0x1000450c
    7b6c:	00020f6f 	.word	0x00020f6f

00007b70 <mesh_mac_get>:
 *  - 1: If ger failed.
 ****************************************************************************************
 */
uint8_t mesh_mac_get(bool reversal, uint8_t* mac)
{
	M_PRINTF(L_AL, "");	
    7b70:	4b11      	ldr	r3, [pc, #68]	; (7bb8 <mesh_mac_get+0x48>)
 *  - 0: If get success.
 *  - 1: If ger failed.
 ****************************************************************************************
 */
uint8_t mesh_mac_get(bool reversal, uint8_t* mac)
{
    7b72:	b537      	push	{r0, r1, r2, r4, r5, lr}
	M_PRINTF(L_AL, "");	
    7b74:	681b      	ldr	r3, [r3, #0]
 *  - 0: If get success.
 *  - 1: If ger failed.
 ****************************************************************************************
 */
uint8_t mesh_mac_get(bool reversal, uint8_t* mac)
{
    7b76:	000d      	movs	r5, r1
	M_PRINTF(L_AL, "");	
    7b78:	07db      	lsls	r3, r3, #31
    7b7a:	d515      	bpl.n	7ba8 <mesh_mac_get+0x38>
    7b7c:	4b0f      	ldr	r3, [pc, #60]	; (7bbc <mesh_mac_get+0x4c>)
    7b7e:	4c10      	ldr	r4, [pc, #64]	; (7bc0 <mesh_mac_get+0x50>)
    7b80:	3340      	adds	r3, #64	; 0x40
    7b82:	9300      	str	r3, [sp, #0]
    7b84:	0022      	movs	r2, r4
    7b86:	0020      	movs	r0, r4
    7b88:	23b4      	movs	r3, #180	; 0xb4
    7b8a:	0021      	movs	r1, r4
    7b8c:	321c      	adds	r2, #28
    7b8e:	005b      	lsls	r3, r3, #1
    7b90:	3026      	adds	r0, #38	; 0x26
    7b92:	f7fc ff0b 	bl	49ac <m_print>
    7b96:	0020      	movs	r0, r4
    7b98:	3044      	adds	r0, #68	; 0x44
    7b9a:	f7fc ff07 	bl	49ac <m_print>
    7b9e:	0020      	movs	r0, r4
    7ba0:	1da1      	adds	r1, r4, #6
    7ba2:	3045      	adds	r0, #69	; 0x45
    7ba4:	f7fc ff02 	bl	49ac <m_print>
	memcpy(mac,(uint8_t*)reg_map(mem_le_lap),6);	
    7ba8:	0028      	movs	r0, r5
    7baa:	2206      	movs	r2, #6
    7bac:	4905      	ldr	r1, [pc, #20]	; (7bc4 <mesh_mac_get+0x54>)
    7bae:	f00d ff0f 	bl	159d0 <memcpy>
	return 0;
}
    7bb2:	2000      	movs	r0, #0
    7bb4:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
    7bb6:	46c0      	nop			; (mov r8, r8)
    7bb8:	10010514 	.word	0x10010514
    7bbc:	00020f6f 	.word	0x00020f6f
    7bc0:	00020def 	.word	0x00020def
    7bc4:	1000450c 	.word	0x1000450c

00007bc8 <mesh_flash_read>:
 *
 * @return read data length:
 ****************************************************************************************
 */
uint32_t mesh_flash_read(uint32_t addr, uint32_t len, uint8_t* data)
{
    7bc8:	b5f0      	push	{r4, r5, r6, r7, lr}
	M_PRINTF(L_AL, "addr=%08x", addr);
    7bca:	4b1b      	ldr	r3, [pc, #108]	; (7c38 <mesh_flash_read+0x70>)
 *
 * @return read data length:
 ****************************************************************************************
 */
uint32_t mesh_flash_read(uint32_t addr, uint32_t len, uint8_t* data)
{
    7bcc:	b085      	sub	sp, #20
	M_PRINTF(L_AL, "addr=%08x", addr);
    7bce:	681b      	ldr	r3, [r3, #0]
 *
 * @return read data length:
 ****************************************************************************************
 */
uint32_t mesh_flash_read(uint32_t addr, uint32_t len, uint8_t* data)
{
    7bd0:	0005      	movs	r5, r0
    7bd2:	000f      	movs	r7, r1
    7bd4:	9203      	str	r2, [sp, #12]
	M_PRINTF(L_AL, "addr=%08x", addr);
    7bd6:	07db      	lsls	r3, r3, #31
    7bd8:	d517      	bpl.n	7c0a <mesh_flash_read+0x42>
    7bda:	4e18      	ldr	r6, [pc, #96]	; (7c3c <mesh_flash_read+0x74>)
    7bdc:	4c18      	ldr	r4, [pc, #96]	; (7c40 <mesh_flash_read+0x78>)
    7bde:	0033      	movs	r3, r6
    7be0:	334d      	adds	r3, #77	; 0x4d
    7be2:	9300      	str	r3, [sp, #0]
    7be4:	0022      	movs	r2, r4
    7be6:	0020      	movs	r0, r4
    7be8:	23bd      	movs	r3, #189	; 0xbd
    7bea:	321c      	adds	r2, #28
    7bec:	005b      	lsls	r3, r3, #1
    7bee:	0021      	movs	r1, r4
    7bf0:	3026      	adds	r0, #38	; 0x26
    7bf2:	f7fc fedb 	bl	49ac <m_print>
    7bf6:	0030      	movs	r0, r6
    7bf8:	0029      	movs	r1, r5
    7bfa:	305d      	adds	r0, #93	; 0x5d
    7bfc:	f7fc fed6 	bl	49ac <m_print>
    7c00:	0020      	movs	r0, r4
    7c02:	1da1      	adds	r1, r4, #6
    7c04:	3045      	adds	r0, #69	; 0x45
    7c06:	f7fc fed1 	bl	49ac <m_print>
	ASSERT_ERR(((addr+len)&PAGE_MASK) == ((addr)&PAGE_MASK));
    7c0a:	23ff      	movs	r3, #255	; 0xff
    7c0c:	19ec      	adds	r4, r5, r7
    7c0e:	406c      	eors	r4, r5
    7c10:	439c      	bics	r4, r3
    7c12:	2c00      	cmp	r4, #0
    7c14:	d1fd      	bne.n	7c12 <mesh_flash_read+0x4a>
	
	QSPI_Init();
    7c16:	f7f9 fc3d 	bl	1494 <QSPI_Init>
	
	QSPI_ReadFlashData(addr,len,data);
    7c1a:	9a03      	ldr	r2, [sp, #12]
    7c1c:	0039      	movs	r1, r7
    7c1e:	0028      	movs	r0, r5
    7c20:	f7f9 f93e 	bl	ea0 <QSPI_ReadFlashData>
	m_printf_hex(L_AL, "read end", data, len);
    7c24:	4905      	ldr	r1, [pc, #20]	; (7c3c <mesh_flash_read+0x74>)
    7c26:	003b      	movs	r3, r7
    7c28:	9a03      	ldr	r2, [sp, #12]
    7c2a:	3167      	adds	r1, #103	; 0x67
    7c2c:	2001      	movs	r0, #1
    7c2e:	f7fc ff1d 	bl	4a6c <m_printf_hex>
	return 0;
}
    7c32:	0020      	movs	r0, r4
    7c34:	b005      	add	sp, #20
    7c36:	bdf0      	pop	{r4, r5, r6, r7, pc}
    7c38:	10010514 	.word	0x10010514
    7c3c:	00020f6f 	.word	0x00020f6f
    7c40:	00020def 	.word	0x00020def

00007c44 <mesh_flash_write>:
 *
 * @return write data length:
 ****************************************************************************************
 */
uint32_t mesh_flash_write(uint32_t addr, uint32_t len, uint8_t* data)
{
    7c44:	b5f0      	push	{r4, r5, r6, r7, lr}
	M_PRINTF(L_AL, "addr = %08x", addr);
    7c46:	4b2b      	ldr	r3, [pc, #172]	; (7cf4 <mesh_flash_write+0xb0>)
 *
 * @return write data length:
 ****************************************************************************************
 */
uint32_t mesh_flash_write(uint32_t addr, uint32_t len, uint8_t* data)
{
    7c48:	0017      	movs	r7, r2
	M_PRINTF(L_AL, "addr = %08x", addr);
    7c4a:	681a      	ldr	r2, [r3, #0]
 *
 * @return write data length:
 ****************************************************************************************
 */
uint32_t mesh_flash_write(uint32_t addr, uint32_t len, uint8_t* data)
{
    7c4c:	b085      	sub	sp, #20
    7c4e:	0005      	movs	r5, r0
    7c50:	000e      	movs	r6, r1
    7c52:	9303      	str	r3, [sp, #12]
	M_PRINTF(L_AL, "addr = %08x", addr);
    7c54:	07d3      	lsls	r3, r2, #31
    7c56:	d516      	bpl.n	7c86 <mesh_flash_write+0x42>
    7c58:	4b27      	ldr	r3, [pc, #156]	; (7cf8 <mesh_flash_write+0xb4>)
    7c5a:	4c28      	ldr	r4, [pc, #160]	; (7cfc <mesh_flash_write+0xb8>)
    7c5c:	3370      	adds	r3, #112	; 0x70
    7c5e:	9300      	str	r3, [sp, #0]
    7c60:	0022      	movs	r2, r4
    7c62:	0020      	movs	r0, r4
    7c64:	2392      	movs	r3, #146	; 0x92
    7c66:	321c      	adds	r2, #28
    7c68:	33ff      	adds	r3, #255	; 0xff
    7c6a:	0021      	movs	r1, r4
    7c6c:	3026      	adds	r0, #38	; 0x26
    7c6e:	f7fc fe9d 	bl	49ac <m_print>
    7c72:	4823      	ldr	r0, [pc, #140]	; (7d00 <mesh_flash_write+0xbc>)
    7c74:	0029      	movs	r1, r5
    7c76:	3001      	adds	r0, #1
    7c78:	f7fc fe98 	bl	49ac <m_print>
    7c7c:	0020      	movs	r0, r4
    7c7e:	1da1      	adds	r1, r4, #6
    7c80:	3045      	adds	r0, #69	; 0x45
    7c82:	f7fc fe93 	bl	49ac <m_print>
	m_printf_hex(L_AL, "write data", data, len);
    7c86:	4c1e      	ldr	r4, [pc, #120]	; (7d00 <mesh_flash_write+0xbc>)
    7c88:	0033      	movs	r3, r6
    7c8a:	0021      	movs	r1, r4
    7c8c:	003a      	movs	r2, r7
    7c8e:	310d      	adds	r1, #13
    7c90:	2001      	movs	r0, #1
    7c92:	f7fc feeb 	bl	4a6c <m_printf_hex>

	ASSERT_ERR(len <= BUFF_SIZE && (addr&(PAGE_SIZE-1))==0);
    7c96:	2280      	movs	r2, #128	; 0x80
    7c98:	b2eb      	uxtb	r3, r5
    7c9a:	0052      	lsls	r2, r2, #1
    7c9c:	4296      	cmp	r6, r2
    7c9e:	d8fd      	bhi.n	7c9c <mesh_flash_write+0x58>
    7ca0:	2b00      	cmp	r3, #0
    7ca2:	d1fb      	bne.n	7c9c <mesh_flash_write+0x58>
	QSPI_Init();
    7ca4:	f7f9 fbf6 	bl	1494 <QSPI_Init>
	
	QSPI_PageEraseFlash(addr);
    7ca8:	0028      	movs	r0, r5
    7caa:	f7f9 fb79 	bl	13a0 <QSPI_PageEraseFlash>
	QSPI_WriteFlashData(addr,len,data);
    7cae:	003a      	movs	r2, r7
    7cb0:	0031      	movs	r1, r6
    7cb2:	0028      	movs	r0, r5
    7cb4:	f7f9 fa34 	bl	1120 <QSPI_WriteFlashData>
	M_PRINTF(L_AL, "write end");
    7cb8:	9b03      	ldr	r3, [sp, #12]
    7cba:	681b      	ldr	r3, [r3, #0]
    7cbc:	07db      	lsls	r3, r3, #31
    7cbe:	d515      	bpl.n	7cec <mesh_flash_write+0xa8>
    7cc0:	4b0d      	ldr	r3, [pc, #52]	; (7cf8 <mesh_flash_write+0xb4>)
    7cc2:	4d0e      	ldr	r5, [pc, #56]	; (7cfc <mesh_flash_write+0xb8>)
    7cc4:	3370      	adds	r3, #112	; 0x70
    7cc6:	9300      	str	r3, [sp, #0]
    7cc8:	002a      	movs	r2, r5
    7cca:	0028      	movs	r0, r5
    7ccc:	239a      	movs	r3, #154	; 0x9a
    7cce:	0029      	movs	r1, r5
    7cd0:	321c      	adds	r2, #28
    7cd2:	33ff      	adds	r3, #255	; 0xff
    7cd4:	3026      	adds	r0, #38	; 0x26
    7cd6:	f7fc fe69 	bl	49ac <m_print>
    7cda:	0020      	movs	r0, r4
    7cdc:	3018      	adds	r0, #24
    7cde:	f7fc fe65 	bl	49ac <m_print>
    7ce2:	0028      	movs	r0, r5
    7ce4:	1da9      	adds	r1, r5, #6
    7ce6:	3045      	adds	r0, #69	; 0x45
    7ce8:	f7fc fe60 	bl	49ac <m_print>
	return 0;
}
    7cec:	2000      	movs	r0, #0
    7cee:	b005      	add	sp, #20
    7cf0:	bdf0      	pop	{r4, r5, r6, r7, pc}
    7cf2:	46c0      	nop			; (mov r8, r8)
    7cf4:	10010514 	.word	0x10010514
    7cf8:	00020f6f 	.word	0x00020f6f
    7cfc:	00020def 	.word	0x00020def
    7d00:	00020fef 	.word	0x00020fef

00007d04 <mesh_flash_write_nerase>:

uint32_t mesh_flash_write_nerase(uint32_t addr, uint32_t len, uint8_t* data)
{
    7d04:	b5f0      	push	{r4, r5, r6, r7, lr}
	M_PRINTF(L_AL, "addr = %08x", addr);
    7d06:	4b1b      	ldr	r3, [pc, #108]	; (7d74 <mesh_flash_write_nerase+0x70>)
	M_PRINTF(L_AL, "write end");
	return 0;
}

uint32_t mesh_flash_write_nerase(uint32_t addr, uint32_t len, uint8_t* data)
{
    7d08:	b085      	sub	sp, #20
	M_PRINTF(L_AL, "addr = %08x", addr);
    7d0a:	681b      	ldr	r3, [r3, #0]
	M_PRINTF(L_AL, "write end");
	return 0;
}

uint32_t mesh_flash_write_nerase(uint32_t addr, uint32_t len, uint8_t* data)
{
    7d0c:	0005      	movs	r5, r0
    7d0e:	000f      	movs	r7, r1
    7d10:	9203      	str	r2, [sp, #12]
	M_PRINTF(L_AL, "addr = %08x", addr);
    7d12:	07db      	lsls	r3, r3, #31
    7d14:	d516      	bpl.n	7d44 <mesh_flash_write_nerase+0x40>
    7d16:	4e18      	ldr	r6, [pc, #96]	; (7d78 <mesh_flash_write_nerase+0x74>)
    7d18:	4c18      	ldr	r4, [pc, #96]	; (7d7c <mesh_flash_write_nerase+0x78>)
    7d1a:	0033      	movs	r3, r6
    7d1c:	3322      	adds	r3, #34	; 0x22
    7d1e:	9300      	str	r3, [sp, #0]
    7d20:	0022      	movs	r2, r4
    7d22:	0020      	movs	r0, r4
    7d24:	23a0      	movs	r3, #160	; 0xa0
    7d26:	321c      	adds	r2, #28
    7d28:	33ff      	adds	r3, #255	; 0xff
    7d2a:	0021      	movs	r1, r4
    7d2c:	3026      	adds	r0, #38	; 0x26
    7d2e:	f7fc fe3d 	bl	49ac <m_print>
    7d32:	0029      	movs	r1, r5
    7d34:	1c70      	adds	r0, r6, #1
    7d36:	f7fc fe39 	bl	49ac <m_print>
    7d3a:	0020      	movs	r0, r4
    7d3c:	1da1      	adds	r1, r4, #6
    7d3e:	3045      	adds	r0, #69	; 0x45
    7d40:	f7fc fe34 	bl	49ac <m_print>
	m_printf_hex(L_AL, "write data", data, len);
    7d44:	490c      	ldr	r1, [pc, #48]	; (7d78 <mesh_flash_write_nerase+0x74>)
    7d46:	003b      	movs	r3, r7
    7d48:	9a03      	ldr	r2, [sp, #12]
    7d4a:	310d      	adds	r1, #13
    7d4c:	2001      	movs	r0, #1
    7d4e:	f7fc fe8d 	bl	4a6c <m_printf_hex>
	
	ASSERT_ERR(((addr+len)&PAGE_MASK) == ((addr)&PAGE_MASK));
    7d52:	23ff      	movs	r3, #255	; 0xff
    7d54:	19ec      	adds	r4, r5, r7
    7d56:	406c      	eors	r4, r5
    7d58:	439c      	bics	r4, r3
    7d5a:	2c00      	cmp	r4, #0
    7d5c:	d1fd      	bne.n	7d5a <mesh_flash_write_nerase+0x56>
	
	QSPI_Init();
    7d5e:	f7f9 fb99 	bl	1494 <QSPI_Init>
	QSPI_WriteFlashData(addr,len,data);
    7d62:	0028      	movs	r0, r5
    7d64:	9a03      	ldr	r2, [sp, #12]
    7d66:	0039      	movs	r1, r7
    7d68:	f7f9 f9da 	bl	1120 <QSPI_WriteFlashData>
	return 0;
}
    7d6c:	0020      	movs	r0, r4
    7d6e:	b005      	add	sp, #20
    7d70:	bdf0      	pop	{r4, r5, r6, r7, pc}
    7d72:	46c0      	nop			; (mov r8, r8)
    7d74:	10010514 	.word	0x10010514
    7d78:	00020fef 	.word	0x00020fef
    7d7c:	00020def 	.word	0x00020def

00007d80 <mesh_flash_erase>:

uint32_t mesh_flash_erase(uint32_t addr)
{
	M_PRINTF(L_AL, "erase data addr=0x%08x", addr);
    7d80:	4b13      	ldr	r3, [pc, #76]	; (7dd0 <mesh_flash_erase+0x50>)
	QSPI_WriteFlashData(addr,len,data);
	return 0;
}

uint32_t mesh_flash_erase(uint32_t addr)
{
    7d82:	b573      	push	{r0, r1, r4, r5, r6, lr}
	M_PRINTF(L_AL, "erase data addr=0x%08x", addr);
    7d84:	681b      	ldr	r3, [r3, #0]
	QSPI_WriteFlashData(addr,len,data);
	return 0;
}

uint32_t mesh_flash_erase(uint32_t addr)
{
    7d86:	0006      	movs	r6, r0
	M_PRINTF(L_AL, "erase data addr=0x%08x", addr);
    7d88:	07db      	lsls	r3, r3, #31
    7d8a:	d517      	bpl.n	7dbc <mesh_flash_erase+0x3c>
    7d8c:	4d11      	ldr	r5, [pc, #68]	; (7dd4 <mesh_flash_erase+0x54>)
    7d8e:	4c12      	ldr	r4, [pc, #72]	; (7dd8 <mesh_flash_erase+0x58>)
    7d90:	002b      	movs	r3, r5
    7d92:	333a      	adds	r3, #58	; 0x3a
    7d94:	9300      	str	r3, [sp, #0]
    7d96:	0022      	movs	r2, r4
    7d98:	0020      	movs	r0, r4
    7d9a:	23ac      	movs	r3, #172	; 0xac
    7d9c:	321c      	adds	r2, #28
    7d9e:	33ff      	adds	r3, #255	; 0xff
    7da0:	0021      	movs	r1, r4
    7da2:	3026      	adds	r0, #38	; 0x26
    7da4:	f7fc fe02 	bl	49ac <m_print>
    7da8:	0028      	movs	r0, r5
    7daa:	0031      	movs	r1, r6
    7dac:	304b      	adds	r0, #75	; 0x4b
    7dae:	f7fc fdfd 	bl	49ac <m_print>
    7db2:	0020      	movs	r0, r4
    7db4:	1da1      	adds	r1, r4, #6
    7db6:	3045      	adds	r0, #69	; 0x45
    7db8:	f7fc fdf8 	bl	49ac <m_print>
	ASSERT_ERR((addr&(PAGE_SIZE-1))== 0);
    7dbc:	b2f4      	uxtb	r4, r6
    7dbe:	2c00      	cmp	r4, #0
    7dc0:	d1fd      	bne.n	7dbe <mesh_flash_erase+0x3e>
	QSPI_Init();
    7dc2:	f7f9 fb67 	bl	1494 <QSPI_Init>
	QSPI_PageEraseFlash(addr);
    7dc6:	0030      	movs	r0, r6
    7dc8:	f7f9 faea 	bl	13a0 <QSPI_PageEraseFlash>
	return 0;
}
    7dcc:	0020      	movs	r0, r4
    7dce:	bd76      	pop	{r1, r2, r4, r5, r6, pc}
    7dd0:	10010514 	.word	0x10010514
    7dd4:	00020fef 	.word	0x00020fef
    7dd8:	00020def 	.word	0x00020def

00007ddc <mesh_aes_encrypt>:
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

void mesh_aes_encrypt(const uint8_t* key, const uint8_t *val, uint8_t* aes_res)						
{
    7ddc:	b570      	push	{r4, r5, r6, lr}
    7dde:	000d      	movs	r5, r1
    7de0:	0014      	movs	r4, r2
	memcpy((unsigned char*)reg_map(mem_aes_key),key,GAP_KEY_LEN);
    7de2:	0001      	movs	r1, r0
    7de4:	2210      	movs	r2, #16
    7de6:	480c      	ldr	r0, [pc, #48]	; (7e18 <mesh_aes_encrypt+0x3c>)
    7de8:	f00d fdf2 	bl	159d0 <memcpy>
	memcpy((unsigned char*)reg_map(mem_aes_input),val,GAP_KEY_LEN);
    7dec:	2210      	movs	r2, #16
    7dee:	0029      	movs	r1, r5
    7df0:	480a      	ldr	r0, [pc, #40]	; (7e1c <mesh_aes_encrypt+0x40>)
    7df2:	f00d fded 	bl	159d0 <memcpy>
	AES_TYPE_SELECT(AES_ENCRY_ECB);
    7df6:	2302      	movs	r3, #2
    7df8:	4a09      	ldr	r2, [pc, #36]	; (7e20 <mesh_aes_encrypt+0x44>)
    7dfa:	7013      	strb	r3, [r2, #0]
	START_AES_ENCRY();
    7dfc:	4a09      	ldr	r2, [pc, #36]	; (7e24 <mesh_aes_encrypt+0x48>)
    7dfe:	7811      	ldrb	r1, [r2, #0]
    7e00:	4319      	orrs	r1, r3
    7e02:	7011      	strb	r1, [r2, #0]
	while((HREAD(mem_aes_state_map) >> 1)&1); 	//wait aes done
    7e04:	7811      	ldrb	r1, [r2, #0]
    7e06:	4219      	tst	r1, r3
    7e08:	d1fc      	bne.n	7e04 <mesh_aes_encrypt+0x28>
	memcpy(aes_res,(unsigned char*)reg_map(mem_aes_output),GAP_KEY_LEN);
    7e0a:	2210      	movs	r2, #16
    7e0c:	4906      	ldr	r1, [pc, #24]	; (7e28 <mesh_aes_encrypt+0x4c>)
    7e0e:	0020      	movs	r0, r4
    7e10:	f00d fdde 	bl	159d0 <memcpy>

	return;
}
    7e14:	bd70      	pop	{r4, r5, r6, pc}
    7e16:	46c0      	nop			; (mov r8, r8)
    7e18:	10004cc6 	.word	0x10004cc6
    7e1c:	10004cd6 	.word	0x10004cd6
    7e20:	10000bb5 	.word	0x10000bb5
    7e24:	10000bb4 	.word	0x10000bb4
    7e28:	10004ce6 	.word	0x10004ce6

00007e2c <mesh_aes_rand>:

void mesh_aes_rand(uint8_t* randbuf,uint8_t randlen)
{
    7e2c:	b570      	push	{r4, r5, r6, lr}
	HREAD(mem_random_len) = randlen;
	START_RAND();
    7e2e:	2404      	movs	r4, #4

	return;
}

void mesh_aes_rand(uint8_t* randbuf,uint8_t randlen)
{
    7e30:	000a      	movs	r2, r1
	HREAD(mem_random_len) = randlen;
    7e32:	4b06      	ldr	r3, [pc, #24]	; (7e4c <mesh_aes_rand+0x20>)
    7e34:	7019      	strb	r1, [r3, #0]
	START_RAND();
    7e36:	4b06      	ldr	r3, [pc, #24]	; (7e50 <mesh_aes_rand+0x24>)
    7e38:	781d      	ldrb	r5, [r3, #0]
    7e3a:	4325      	orrs	r5, r4
    7e3c:	701d      	strb	r5, [r3, #0]
	while((HREAD(mem_aes_state_map) >> 2)&1); 	//wait aes done
    7e3e:	7819      	ldrb	r1, [r3, #0]
    7e40:	4221      	tst	r1, r4
    7e42:	d1fc      	bne.n	7e3e <mesh_aes_rand+0x12>
	memcpy(randbuf,(unsigned char*)reg_map(mem_random_buff),randlen);
    7e44:	4903      	ldr	r1, [pc, #12]	; (7e54 <mesh_aes_rand+0x28>)
    7e46:	f00d fdc3 	bl	159d0 <memcpy>
	return;
}
    7e4a:	bd70      	pop	{r4, r5, r6, pc}
    7e4c:	10004d0b 	.word	0x10004d0b
    7e50:	10000bb4 	.word	0x10000bb4
    7e54:	10004d0c 	.word	0x10004d0c

00007e58 <xor_128>:

void xor_128(const uint8_t *a, const uint8_t *b, uint8_t *out)
{
	int i;
	for (i=0;i<16; i++)
    7e58:	2300      	movs	r3, #0
	memcpy(randbuf,(unsigned char*)reg_map(mem_random_buff),randlen);
	return;
}

void xor_128(const uint8_t *a, const uint8_t *b, uint8_t *out)
{
    7e5a:	b530      	push	{r4, r5, lr}
	int i;
	for (i=0;i<16; i++)
	{
	  out[i] = a[i] ^ b[i];
    7e5c:	5cc5      	ldrb	r5, [r0, r3]
    7e5e:	5ccc      	ldrb	r4, [r1, r3]
    7e60:	406c      	eors	r4, r5
    7e62:	54d4      	strb	r4, [r2, r3]
}

void xor_128(const uint8_t *a, const uint8_t *b, uint8_t *out)
{
	int i;
	for (i=0;i<16; i++)
    7e64:	3301      	adds	r3, #1
    7e66:	2b10      	cmp	r3, #16
    7e68:	d1f8      	bne.n	7e5c <xor_128+0x4>
	{
	  out[i] = a[i] ^ b[i];
	}
}
    7e6a:	bd30      	pop	{r4, r5, pc}

00007e6c <leftshift_onebit>:

void leftshift_onebit(uint8_t *input,uint8_t *output)
{
    7e6c:	b510      	push	{r4, lr}
  int i;
  unsigned char overflow = 0;

  for ( i=15; i>=0; i-- ) {
    7e6e:	230f      	movs	r3, #15
}

void leftshift_onebit(uint8_t *input,uint8_t *output)
{
  int i;
  unsigned char overflow = 0;
    7e70:	2400      	movs	r4, #0

  for ( i=15; i>=0; i-- ) {
      output[i] = input[i] << 1;
      output[i] |= overflow;
    7e72:	5cc2      	ldrb	r2, [r0, r3]
    7e74:	0052      	lsls	r2, r2, #1
    7e76:	4322      	orrs	r2, r4
    7e78:	54ca      	strb	r2, [r1, r3]
      overflow = (input[i] & 0x80)?1:0;
    7e7a:	5cc2      	ldrb	r2, [r0, r3]
    7e7c:	09d4      	lsrs	r4, r2, #7
void leftshift_onebit(uint8_t *input,uint8_t *output)
{
  int i;
  unsigned char overflow = 0;

  for ( i=15; i>=0; i-- ) {
    7e7e:	3b01      	subs	r3, #1
    7e80:	d2f7      	bcs.n	7e72 <leftshift_onebit+0x6>
      output[i] = input[i] << 1;
      output[i] |= overflow;
      overflow = (input[i] & 0x80)?1:0;
  }
  return;
}
    7e82:	bd10      	pop	{r4, pc}

00007e84 <swap_u256_bytes>:

void swap_u256_bytes(uint8_t *u256)
{
    7e84:	b510      	push	{r4, lr}
    7e86:	0003      	movs	r3, r0
    7e88:	0004      	movs	r4, r0
    7e8a:	331f      	adds	r3, #31
    7e8c:	340f      	adds	r4, #15
	int i;

	/* End-to-End byte reflection of 32 octet buffer */
	for (i = 0; i < 16; i++) {
		u256[i] ^= u256[31 - i];
    7e8e:	7801      	ldrb	r1, [r0, #0]
    7e90:	781a      	ldrb	r2, [r3, #0]
    7e92:	3b01      	subs	r3, #1
    7e94:	404a      	eors	r2, r1
    7e96:	7002      	strb	r2, [r0, #0]
		u256[31 - i] ^= u256[i];
    7e98:	7859      	ldrb	r1, [r3, #1]
    7e9a:	404a      	eors	r2, r1
    7e9c:	705a      	strb	r2, [r3, #1]
		u256[i] ^= u256[31 - i];
    7e9e:	7801      	ldrb	r1, [r0, #0]
    7ea0:	404a      	eors	r2, r1
    7ea2:	7002      	strb	r2, [r0, #0]
    7ea4:	3001      	adds	r0, #1
void swap_u256_bytes(uint8_t *u256)
{
	int i;

	/* End-to-End byte reflection of 32 octet buffer */
	for (i = 0; i < 16; i++) {
    7ea6:	42a3      	cmp	r3, r4
    7ea8:	d1f1      	bne.n	7e8e <swap_u256_bytes+0xa>
		u256[i] ^= u256[31 - i];
		u256[31 - i] ^= u256[i];
		u256[i] ^= u256[31 - i];
	}
}
    7eaa:	bd10      	pop	{r4, pc}

00007eac <generate_subkey>:
	uint8_t L[16];
	uint8_t Z[16];
	uint8_t tmp[16];
	int i;

	for ( i=0; i<16; i++ ) Z[i] = 0;
    7eac:	2300      	movs	r3, #0
		u256[i] ^= u256[31 - i];
	}
}

void generate_subkey(const uint8_t *key, uint8_t *K1, uint8_t *K2)
{
    7eae:	b530      	push	{r4, r5, lr}
    7eb0:	0015      	movs	r5, r2
    7eb2:	000c      	movs	r4, r1
	uint8_t L[16];
	uint8_t Z[16];
	uint8_t tmp[16];
	int i;

	for ( i=0; i<16; i++ ) Z[i] = 0;
    7eb4:	001a      	movs	r2, r3
		u256[i] ^= u256[31 - i];
	}
}

void generate_subkey(const uint8_t *key, uint8_t *K1, uint8_t *K2)
{
    7eb6:	b08d      	sub	sp, #52	; 0x34
	uint8_t L[16];
	uint8_t Z[16];
	uint8_t tmp[16];
	int i;

	for ( i=0; i<16; i++ ) Z[i] = 0;
    7eb8:	a904      	add	r1, sp, #16
    7eba:	545a      	strb	r2, [r3, r1]
    7ebc:	3301      	adds	r3, #1
    7ebe:	2b10      	cmp	r3, #16
    7ec0:	d1fa      	bne.n	7eb8 <generate_subkey+0xc>

	mesh_aes_encrypt(key,Z,L);
    7ec2:	466a      	mov	r2, sp
    7ec4:	f7ff ff8a 	bl	7ddc <mesh_aes_encrypt>

	if ( (L[0] & 0x80) == 0 ) { /* If MSB(L) = 0, then K1 = L << 1 */
    7ec8:	466b      	mov	r3, sp
    7eca:	781b      	ldrb	r3, [r3, #0]
    7ecc:	2b7f      	cmp	r3, #127	; 0x7f
    7ece:	d804      	bhi.n	7eda <generate_subkey+0x2e>
		leftshift_onebit(L,K1);
    7ed0:	0021      	movs	r1, r4
    7ed2:	4668      	mov	r0, sp
    7ed4:	f7ff ffca 	bl	7e6c <leftshift_onebit>
    7ed8:	e009      	b.n	7eee <generate_subkey+0x42>
	} else {    /* Else K1 = ( L << 1 ) (+) Rb */

		leftshift_onebit(L,tmp);
    7eda:	a908      	add	r1, sp, #32
    7edc:	4668      	mov	r0, sp
    7ede:	f7ff ffc5 	bl	7e6c <leftshift_onebit>
		xor_128(tmp,const_Rb,K1);
    7ee2:	490d      	ldr	r1, [pc, #52]	; (7f18 <generate_subkey+0x6c>)
    7ee4:	0022      	movs	r2, r4
    7ee6:	3109      	adds	r1, #9
    7ee8:	a808      	add	r0, sp, #32
    7eea:	f7ff ffb5 	bl	7e58 <xor_128>
	}

	if ( (K1[0] & 0x80) == 0 ) {
    7eee:	7823      	ldrb	r3, [r4, #0]
    7ef0:	2b7f      	cmp	r3, #127	; 0x7f
    7ef2:	d804      	bhi.n	7efe <generate_subkey+0x52>
		leftshift_onebit(K1,K2);
    7ef4:	0029      	movs	r1, r5
    7ef6:	0020      	movs	r0, r4
    7ef8:	f7ff ffb8 	bl	7e6c <leftshift_onebit>
    7efc:	e009      	b.n	7f12 <generate_subkey+0x66>
	} else {
		leftshift_onebit(K1,tmp);
    7efe:	a908      	add	r1, sp, #32
    7f00:	0020      	movs	r0, r4
    7f02:	f7ff ffb3 	bl	7e6c <leftshift_onebit>
		xor_128(tmp,const_Rb,K2);
    7f06:	4904      	ldr	r1, [pc, #16]	; (7f18 <generate_subkey+0x6c>)
    7f08:	002a      	movs	r2, r5
    7f0a:	3109      	adds	r1, #9
    7f0c:	a808      	add	r0, sp, #32
    7f0e:	f7ff ffa3 	bl	7e58 <xor_128>
	}
	return;
}
    7f12:	b00d      	add	sp, #52	; 0x34
    7f14:	bd30      	pop	{r4, r5, pc}
    7f16:	46c0      	nop			; (mov r8, r8)
    7f18:	00021051 	.word	0x00021051

00007f1c <padding>:
void padding ( const unsigned char *lastb, unsigned char *pad, int length)
{
	int j;

	/* original last block */
	for ( j=0; j<16; j++ ) {
    7f1c:	2300      	movs	r3, #0
		xor_128(tmp,const_Rb,K2);
	}
	return;
}
void padding ( const unsigned char *lastb, unsigned char *pad, int length)
{
    7f1e:	b570      	push	{r4, r5, r6, lr}
	  if ( j < length ) {
	      pad[j] = lastb[j];
	  } else if ( j == length ) {
	      pad[j] = 0x80;
	  } else {
	      pad[j] = 0x00;
    7f20:	001c      	movs	r4, r3
	/* original last block */
	for ( j=0; j<16; j++ ) {
	  if ( j < length ) {
	      pad[j] = lastb[j];
	  } else if ( j == length ) {
	      pad[j] = 0x80;
    7f22:	2580      	movs	r5, #128	; 0x80
{
	int j;

	/* original last block */
	for ( j=0; j<16; j++ ) {
	  if ( j < length ) {
    7f24:	429a      	cmp	r2, r3
    7f26:	dd02      	ble.n	7f2e <padding+0x12>
	      pad[j] = lastb[j];
    7f28:	5cc6      	ldrb	r6, [r0, r3]
    7f2a:	54ce      	strb	r6, [r1, r3]
    7f2c:	e004      	b.n	7f38 <padding+0x1c>
	  } else if ( j == length ) {
    7f2e:	429a      	cmp	r2, r3
    7f30:	d101      	bne.n	7f36 <padding+0x1a>
	      pad[j] = 0x80;
    7f32:	548d      	strb	r5, [r1, r2]
    7f34:	e000      	b.n	7f38 <padding+0x1c>
	  } else {
	      pad[j] = 0x00;
    7f36:	54cc      	strb	r4, [r1, r3]
void padding ( const unsigned char *lastb, unsigned char *pad, int length)
{
	int j;

	/* original last block */
	for ( j=0; j<16; j++ ) {
    7f38:	3301      	adds	r3, #1
    7f3a:	2b10      	cmp	r3, #16
    7f3c:	d1f2      	bne.n	7f24 <padding+0x8>
	      pad[j] = 0x80;
	  } else {
	      pad[j] = 0x00;
	  }
	}
}
    7f3e:	bd70      	pop	{r4, r5, r6, pc}

00007f40 <mesh_aes_cmac_internal>:

void mesh_aes_cmac_internal(const uint8_t* key, const uint8_t* message, uint16_t message_len, uint8_t*mac)
{
    7f40:	b5f0      	push	{r4, r5, r6, r7, lr}
    7f42:	0015      	movs	r5, r2
	unsigned char K1[16], K2[16];
	
	int n, i, flag;
	generate_subkey(key,K1,K2);

	n = (message_len+15) / 16;       /* n is number of rounds */
    7f44:	002c      	movs	r4, r5
	  }
	}
}

void mesh_aes_cmac_internal(const uint8_t* key, const uint8_t* message, uint16_t message_len, uint8_t*mac)
{
    7f46:	b09b      	sub	sp, #108	; 0x6c
    7f48:	000e      	movs	r6, r1
              
	unsigned char X[16],Y[16],M_last[16],padded[16];
	unsigned char K1[16], K2[16];
	
	int n, i, flag;
	generate_subkey(key,K1,K2);
    7f4a:	aa16      	add	r2, sp, #88	; 0x58
    7f4c:	a912      	add	r1, sp, #72	; 0x48

	n = (message_len+15) / 16;       /* n is number of rounds */
    7f4e:	340f      	adds	r4, #15
	  }
	}
}

void mesh_aes_cmac_internal(const uint8_t* key, const uint8_t* message, uint16_t message_len, uint8_t*mac)
{
    7f50:	0007      	movs	r7, r0
    7f52:	9301      	str	r3, [sp, #4]
	unsigned char K1[16], K2[16];
	
	int n, i, flag;
	generate_subkey(key,K1,K2);

	n = (message_len+15) / 16;       /* n is number of rounds */
    7f54:	1124      	asrs	r4, r4, #4
              
	unsigned char X[16],Y[16],M_last[16],padded[16];
	unsigned char K1[16], K2[16];
	
	int n, i, flag;
	generate_subkey(key,K1,K2);
    7f56:	f7ff ffa9 	bl	7eac <generate_subkey>

	n = (message_len+15) / 16;       /* n is number of rounds */

	if ( n == 0 ) {
    7f5a:	2c00      	cmp	r4, #0
    7f5c:	d002      	beq.n	7f64 <mesh_aes_cmac_internal+0x24>
	  n = 1;
	  flag = 0;
	} else {
	  if ( (message_len%16) == 0 ) { /* last block is a complete block */
    7f5e:	072b      	lsls	r3, r5, #28
    7f60:	d039      	beq.n	7fd6 <mesh_aes_cmac_internal+0x96>
    7f62:	e000      	b.n	7f66 <mesh_aes_cmac_internal+0x26>
	generate_subkey(key,K1,K2);

	n = (message_len+15) / 16;       /* n is number of rounds */

	if ( n == 0 ) {
	  n = 1;
    7f64:	2401      	movs	r4, #1
	}

	if ( flag ) { /* last block is complete block */
	  xor_128(&message[16*(n-1)],K1,M_last);
	} else {
	  padding(&message[16*(n-1)],padded,message_len%16);
    7f66:	220f      	movs	r2, #15
    7f68:	1e60      	subs	r0, r4, #1
    7f6a:	0100      	lsls	r0, r0, #4
    7f6c:	402a      	ands	r2, r5
    7f6e:	1830      	adds	r0, r6, r0
    7f70:	a90e      	add	r1, sp, #56	; 0x38
    7f72:	f7ff ffd3 	bl	7f1c <padding>
	  xor_128(padded,K2,M_last);
    7f76:	aa0a      	add	r2, sp, #40	; 0x28
    7f78:	a916      	add	r1, sp, #88	; 0x58
    7f7a:	a80e      	add	r0, sp, #56	; 0x38
    7f7c:	f7ff ff6c 	bl	7e58 <xor_128>
	  }
	}
}

void mesh_aes_cmac_internal(const uint8_t* key, const uint8_t* message, uint16_t message_len, uint8_t*mac)
{
    7f80:	2300      	movs	r3, #0
	} else {
	  padding(&message[16*(n-1)],padded,message_len%16);
	  xor_128(padded,K2,M_last);
	}

	for ( i=0; i<16; i++ ) X[i] = 0;
    7f82:	001a      	movs	r2, r3
    7f84:	a902      	add	r1, sp, #8
    7f86:	545a      	strb	r2, [r3, r1]
    7f88:	3301      	adds	r3, #1
    7f8a:	2b10      	cmp	r3, #16
    7f8c:	d1fa      	bne.n	7f84 <mesh_aes_cmac_internal+0x44>
    7f8e:	2500      	movs	r5, #0
	for ( i=0; i<n-1; i++ ) {
    7f90:	1e63      	subs	r3, r4, #1
    7f92:	429d      	cmp	r5, r3
    7f94:	da0c      	bge.n	7fb0 <mesh_aes_cmac_internal+0x70>
	  xor_128(X,&message[16*i],Y); /* Y := Mi (+) X  */
    7f96:	0129      	lsls	r1, r5, #4
    7f98:	1871      	adds	r1, r6, r1
    7f9a:	aa06      	add	r2, sp, #24
    7f9c:	a802      	add	r0, sp, #8
    7f9e:	f7ff ff5b 	bl	7e58 <xor_128>
	  mesh_aes_encrypt(key,Y,X);      /* X := AES-128(KEY, Y); */
    7fa2:	aa02      	add	r2, sp, #8
    7fa4:	a906      	add	r1, sp, #24
    7fa6:	0038      	movs	r0, r7
    7fa8:	f7ff ff18 	bl	7ddc <mesh_aes_encrypt>
	  padding(&message[16*(n-1)],padded,message_len%16);
	  xor_128(padded,K2,M_last);
	}

	for ( i=0; i<16; i++ ) X[i] = 0;
	for ( i=0; i<n-1; i++ ) {
    7fac:	3501      	adds	r5, #1
    7fae:	e7ef      	b.n	7f90 <mesh_aes_cmac_internal+0x50>
	  xor_128(X,&message[16*i],Y); /* Y := Mi (+) X  */
	  mesh_aes_encrypt(key,Y,X);      /* X := AES-128(KEY, Y); */
	}

	xor_128(X,M_last,Y);
    7fb0:	aa06      	add	r2, sp, #24
    7fb2:	a90a      	add	r1, sp, #40	; 0x28
    7fb4:	a802      	add	r0, sp, #8
    7fb6:	f7ff ff4f 	bl	7e58 <xor_128>
	mesh_aes_encrypt(key,Y,X);
    7fba:	aa02      	add	r2, sp, #8
    7fbc:	a906      	add	r1, sp, #24
    7fbe:	0038      	movs	r0, r7
    7fc0:	f7ff ff0c 	bl	7ddc <mesh_aes_encrypt>

	for ( i=0; i<16; i++ ) {
    7fc4:	2300      	movs	r3, #0
	  mac[i] = X[i];
    7fc6:	aa02      	add	r2, sp, #8
    7fc8:	5cd2      	ldrb	r2, [r2, r3]
    7fca:	9901      	ldr	r1, [sp, #4]
    7fcc:	54ca      	strb	r2, [r1, r3]
	}

	xor_128(X,M_last,Y);
	mesh_aes_encrypt(key,Y,X);

	for ( i=0; i<16; i++ ) {
    7fce:	3301      	adds	r3, #1
    7fd0:	2b10      	cmp	r3, #16
    7fd2:	d1f8      	bne.n	7fc6 <mesh_aes_cmac_internal+0x86>
    7fd4:	e007      	b.n	7fe6 <mesh_aes_cmac_internal+0xa6>
	      flag = 0;
	  }
	}

	if ( flag ) { /* last block is complete block */
	  xor_128(&message[16*(n-1)],K1,M_last);
    7fd6:	1e60      	subs	r0, r4, #1
    7fd8:	0100      	lsls	r0, r0, #4
    7fda:	1830      	adds	r0, r6, r0
    7fdc:	aa0a      	add	r2, sp, #40	; 0x28
    7fde:	a912      	add	r1, sp, #72	; 0x48
    7fe0:	f7ff ff3a 	bl	7e58 <xor_128>
    7fe4:	e7cc      	b.n	7f80 <mesh_aes_cmac_internal+0x40>

	for ( i=0; i<16; i++ ) {
	  mac[i] = X[i];
	}
	
}
    7fe6:	b01b      	add	sp, #108	; 0x6c
    7fe8:	bdf0      	pop	{r4, r5, r6, r7, pc}

00007fea <mesh_aes_cmac>:

void mesh_aes_cmac(const uint8_t* key, const uint8_t* message, uint16_t message_len,
              mesh_aes_func_result_cb res_cb, uint32_t src_info)
{
    7fea:	b5f0      	push	{r4, r5, r6, r7, lr}
    7fec:	0015      	movs	r5, r2

	//zjl modify //res = malloc(16);    // need to be freed
	unsigned char res[16];
	memset(res, 0x00, 16);

	n = (message_len+15) / 16;       /* n is number of rounds */
    7fee:	002c      	movs	r4, r5
	
}

void mesh_aes_cmac(const uint8_t* key, const uint8_t* message, uint16_t message_len,
              mesh_aes_func_result_cb res_cb, uint32_t src_info)
{
    7ff0:	b09f      	sub	sp, #124	; 0x7c
	unsigned char K1[16], K2[16];

	//uint8_t *res;
	
	int n, i, flag;
	generate_subkey(key,K1,K2);
    7ff2:	aa16      	add	r2, sp, #88	; 0x58
	
}

void mesh_aes_cmac(const uint8_t* key, const uint8_t* message, uint16_t message_len,
              mesh_aes_func_result_cb res_cb, uint32_t src_info)
{
    7ff4:	000e      	movs	r6, r1
	unsigned char K1[16], K2[16];

	//uint8_t *res;
	
	int n, i, flag;
	generate_subkey(key,K1,K2);
    7ff6:	a912      	add	r1, sp, #72	; 0x48
	
}

void mesh_aes_cmac(const uint8_t* key, const uint8_t* message, uint16_t message_len,
              mesh_aes_func_result_cb res_cb, uint32_t src_info)
{
    7ff8:	0007      	movs	r7, r0
    7ffa:	9301      	str	r3, [sp, #4]

	//zjl modify //res = malloc(16);    // need to be freed
	unsigned char res[16];
	memset(res, 0x00, 16);

	n = (message_len+15) / 16;       /* n is number of rounds */
    7ffc:	340f      	adds	r4, #15
	unsigned char K1[16], K2[16];

	//uint8_t *res;
	
	int n, i, flag;
	generate_subkey(key,K1,K2);
    7ffe:	f7ff ff55 	bl	7eac <generate_subkey>

	//zjl modify //res = malloc(16);    // need to be freed
	unsigned char res[16];
	memset(res, 0x00, 16);
    8002:	2210      	movs	r2, #16
    8004:	2100      	movs	r1, #0
    8006:	a81a      	add	r0, sp, #104	; 0x68
    8008:	f00d fd20 	bl	15a4c <memset>

	n = (message_len+15) / 16;       /* n is number of rounds */
    800c:	1124      	asrs	r4, r4, #4

	if ( n == 0 ) {
    800e:	d002      	beq.n	8016 <mesh_aes_cmac+0x2c>
	  n = 1;
	  flag = 0;
	} else {
	  if ( (message_len%16) == 0 ) { /* last block is a complete block */
    8010:	072b      	lsls	r3, r5, #28
    8012:	d047      	beq.n	80a4 <mesh_aes_cmac+0xba>
    8014:	e000      	b.n	8018 <mesh_aes_cmac+0x2e>
	memset(res, 0x00, 16);

	n = (message_len+15) / 16;       /* n is number of rounds */

	if ( n == 0 ) {
	  n = 1;
    8016:	2401      	movs	r4, #1
	}

	if ( flag ) { /* last block is complete block */
	  xor_128(&message[16*(n-1)],K1,M_last);
	} else {
	  padding(&message[16*(n-1)],padded,message_len%16);
    8018:	220f      	movs	r2, #15
    801a:	1e60      	subs	r0, r4, #1
    801c:	0100      	lsls	r0, r0, #4
    801e:	402a      	ands	r2, r5
    8020:	1830      	adds	r0, r6, r0
    8022:	a90e      	add	r1, sp, #56	; 0x38
    8024:	f7ff ff7a 	bl	7f1c <padding>
	  xor_128(padded,K2,M_last);
    8028:	aa0a      	add	r2, sp, #40	; 0x28
    802a:	a916      	add	r1, sp, #88	; 0x58
    802c:	a80e      	add	r0, sp, #56	; 0x38
    802e:	f7ff ff13 	bl	7e58 <xor_128>
	
}

void mesh_aes_cmac(const uint8_t* key, const uint8_t* message, uint16_t message_len,
              mesh_aes_func_result_cb res_cb, uint32_t src_info)
{
    8032:	2300      	movs	r3, #0
	} else {
	  padding(&message[16*(n-1)],padded,message_len%16);
	  xor_128(padded,K2,M_last);
	}

	for ( i=0; i<16; i++ ) X[i] = 0;
    8034:	001a      	movs	r2, r3
    8036:	a902      	add	r1, sp, #8
    8038:	545a      	strb	r2, [r3, r1]
    803a:	3301      	adds	r3, #1
    803c:	2b10      	cmp	r3, #16
    803e:	d1fa      	bne.n	8036 <mesh_aes_cmac+0x4c>
    8040:	2500      	movs	r5, #0
	for ( i=0; i<n-1; i++ ) {
    8042:	1e63      	subs	r3, r4, #1
    8044:	429d      	cmp	r5, r3
    8046:	da0c      	bge.n	8062 <mesh_aes_cmac+0x78>
	  xor_128(X,&message[16*i],Y); /* Y := Mi (+) X  */
    8048:	0129      	lsls	r1, r5, #4
    804a:	1871      	adds	r1, r6, r1
    804c:	aa06      	add	r2, sp, #24
    804e:	a802      	add	r0, sp, #8
    8050:	f7ff ff02 	bl	7e58 <xor_128>
	  mesh_aes_encrypt(key,Y,X);      /* X := AES-128(KEY, Y); */
    8054:	aa02      	add	r2, sp, #8
    8056:	a906      	add	r1, sp, #24
    8058:	0038      	movs	r0, r7
    805a:	f7ff febf 	bl	7ddc <mesh_aes_encrypt>
	  padding(&message[16*(n-1)],padded,message_len%16);
	  xor_128(padded,K2,M_last);
	}

	for ( i=0; i<16; i++ ) X[i] = 0;
	for ( i=0; i<n-1; i++ ) {
    805e:	3501      	adds	r5, #1
    8060:	e7ef      	b.n	8042 <mesh_aes_cmac+0x58>
	  xor_128(X,&message[16*i],Y); /* Y := Mi (+) X  */
	  mesh_aes_encrypt(key,Y,X);      /* X := AES-128(KEY, Y); */
	}

	xor_128(X,M_last,Y);
    8062:	aa06      	add	r2, sp, #24
    8064:	a90a      	add	r1, sp, #40	; 0x28
    8066:	a802      	add	r0, sp, #8
    8068:	f7ff fef6 	bl	7e58 <xor_128>
	mesh_aes_encrypt(key,Y,X);
    806c:	a906      	add	r1, sp, #24
    806e:	aa02      	add	r2, sp, #8
    8070:	0038      	movs	r0, r7
    8072:	f7ff feb3 	bl	7ddc <mesh_aes_encrypt>

	for ( i=0; i<16; i++ ) {
    8076:	2300      	movs	r3, #0
	  res[i] = X[15-i];
    8078:	a902      	add	r1, sp, #8
    807a:	1aca      	subs	r2, r1, r3
    807c:	7bd2      	ldrb	r2, [r2, #15]
    807e:	ac1a      	add	r4, sp, #104	; 0x68
    8080:	551a      	strb	r2, [r3, r4]
	}

	xor_128(X,M_last,Y);
	mesh_aes_encrypt(key,Y,X);

	for ( i=0; i<16; i++ ) {
    8082:	3301      	adds	r3, #1
    8084:	2b10      	cmp	r3, #16
    8086:	d1f8      	bne.n	807a <mesh_aes_cmac+0x90>
	  res[i] = X[15-i];
	}
	m_printf_hex(L_AL, "cmac result", res, 16);
    8088:	490b      	ldr	r1, [pc, #44]	; (80b8 <mesh_aes_cmac+0xce>)
    808a:	0022      	movs	r2, r4
    808c:	3129      	adds	r1, #41	; 0x29
    808e:	2001      	movs	r0, #1
    8090:	f7fc fcec 	bl	4a6c <m_printf_hex>
	if(res_cb)
    8094:	9b01      	ldr	r3, [sp, #4]
    8096:	2b00      	cmp	r3, #0
    8098:	d00c      	beq.n	80b4 <mesh_aes_cmac+0xca>
		res_cb(0, res, src_info);
    809a:	9a24      	ldr	r2, [sp, #144]	; 0x90
    809c:	0021      	movs	r1, r4
    809e:	2000      	movs	r0, #0
    80a0:	4798      	blx	r3
	
}
    80a2:	e007      	b.n	80b4 <mesh_aes_cmac+0xca>
	      flag = 0;
	  }
	}

	if ( flag ) { /* last block is complete block */
	  xor_128(&message[16*(n-1)],K1,M_last);
    80a4:	1e60      	subs	r0, r4, #1
    80a6:	0100      	lsls	r0, r0, #4
    80a8:	1830      	adds	r0, r6, r0
    80aa:	aa0a      	add	r2, sp, #40	; 0x28
    80ac:	a912      	add	r1, sp, #72	; 0x48
    80ae:	f7ff fed3 	bl	7e58 <xor_128>
    80b2:	e7be      	b.n	8032 <mesh_aes_cmac+0x48>
	}
	m_printf_hex(L_AL, "cmac result", res, 16);
	if(res_cb)
		res_cb(0, res, src_info);
	
}
    80b4:	b01f      	add	sp, #124	; 0x7c
    80b6:	bdf0      	pop	{r4, r5, r6, r7, pc}
    80b8:	00021051 	.word	0x00021051

000080bc <mesh_aes_s1>:
const uint8_t smk3[4] = {"smk3"};
const uint8_t smk4[4] = {"smk4"};
const uint8_t t1=0x01,t2=0x02,t3=0x03;

void mesh_aes_s1(const uint8_t* message, uint8_t message_len, uint8_t* aes_res)
{
    80bc:	b510      	push	{r4, lr}
    80be:	0013      	movs	r3, r2
	mesh_aes_cmac_internal(const_Zero,message,message_len,aes_res);
    80c0:	b28a      	uxth	r2, r1
    80c2:	0001      	movs	r1, r0
    80c4:	4802      	ldr	r0, [pc, #8]	; (80d0 <mesh_aes_s1+0x14>)
    80c6:	3019      	adds	r0, #25
    80c8:	f7ff ff3a 	bl	7f40 <mesh_aes_cmac_internal>
}
    80cc:	bd10      	pop	{r4, pc}
    80ce:	46c0      	nop			; (mov r8, r8)
    80d0:	00021051 	.word	0x00021051

000080d4 <mesh_aes_k1>:

void mesh_aes_k1(const uint8_t* salt, const uint8_t* n, uint8_t n_len, const uint8_t* p, 
						uint8_t p_len, uint8_t* aes_res)
{
    80d4:	b5f0      	push	{r4, r5, r6, r7, lr}
    80d6:	0006      	movs	r6, r0
    80d8:	000f      	movs	r7, r1
    80da:	0014      	movs	r4, r2
    80dc:	b087      	sub	sp, #28
    80de:	001d      	movs	r5, r3
    80e0:	ab0c      	add	r3, sp, #48	; 0x30
    80e2:	781b      	ldrb	r3, [r3, #0]
	uint8_t T[16];
	memset(T, 0x00, 16);
    80e4:	2210      	movs	r2, #16
    80e6:	2100      	movs	r1, #0
    80e8:	a802      	add	r0, sp, #8
	mesh_aes_cmac_internal(const_Zero,message,message_len,aes_res);
}

void mesh_aes_k1(const uint8_t* salt, const uint8_t* n, uint8_t n_len, const uint8_t* p, 
						uint8_t p_len, uint8_t* aes_res)
{
    80ea:	9301      	str	r3, [sp, #4]
	uint8_t T[16];
	memset(T, 0x00, 16);
    80ec:	f00d fcae 	bl	15a4c <memset>
	mesh_aes_cmac_internal(salt,n,n_len,T);
    80f0:	b2a2      	uxth	r2, r4
    80f2:	ab02      	add	r3, sp, #8
    80f4:	0039      	movs	r1, r7
    80f6:	0030      	movs	r0, r6
    80f8:	f7ff ff22 	bl	7f40 <mesh_aes_cmac_internal>
	mesh_aes_cmac_internal((const uint8_t*)T,p,p_len,aes_res);
    80fc:	466b      	mov	r3, sp
    80fe:	0029      	movs	r1, r5
    8100:	889a      	ldrh	r2, [r3, #4]
    8102:	a802      	add	r0, sp, #8
    8104:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    8106:	f7ff ff1b 	bl	7f40 <mesh_aes_cmac_internal>
}
    810a:	b007      	add	sp, #28
    810c:	bdf0      	pop	{r4, r5, r6, r7, pc}

0000810e <mesh_aes_k2>:

void mesh_aes_k2(const uint8_t* n, const uint8_t* p, uint8_t p_len, 
						uint8_t* aes_res)
						
{
    810e:	b5f0      	push	{r4, r5, r6, r7, lr}
    8110:	0005      	movs	r5, r0
    8112:	0014      	movs	r4, r2

	//return values
	uint8_t nid;
	
	//compute s1
	mesh_aes_s1(smk2,4,salt);
    8114:	4849      	ldr	r0, [pc, #292]	; (823c <mesh_aes_k2+0x12e>)
}

void mesh_aes_k2(const uint8_t* n, const uint8_t* p, uint8_t p_len, 
						uint8_t* aes_res)
						
{
    8116:	b09b      	sub	sp, #108	; 0x6c
    8118:	9101      	str	r1, [sp, #4]

	//return values
	uint8_t nid;
	
	//compute s1
	mesh_aes_s1(smk2,4,salt);
    811a:	aa16      	add	r2, sp, #88	; 0x58
    811c:	2104      	movs	r1, #4
    811e:	3035      	adds	r0, #53	; 0x35
}

void mesh_aes_k2(const uint8_t* n, const uint8_t* p, uint8_t p_len, 
						uint8_t* aes_res)
						
{
    8120:	9302      	str	r3, [sp, #8]

	//return values
	uint8_t nid;
	
	//compute s1
	mesh_aes_s1(smk2,4,salt);
    8122:	f7ff ffcb 	bl	80bc <mesh_aes_s1>

	//compute T
	mesh_aes_cmac_internal((const uint8_t*)salt,n,16,T);
    8126:	0029      	movs	r1, r5
    8128:	ab06      	add	r3, sp, #24
    812a:	2210      	movs	r2, #16
    812c:	a816      	add	r0, sp, #88	; 0x58
    812e:	f7ff ff07 	bl	7f40 <mesh_aes_cmac_internal>

	//compute T1
	T1_in = ke_malloc(p_len +1, 0);
    8132:	1c60      	adds	r0, r4, #1
    8134:	2100      	movs	r1, #0
    8136:	f7ff f8d3 	bl	72e0 <ke_malloc>
    813a:	1e05      	subs	r5, r0, #0
	if(!T1_in){
    813c:	d07c      	beq.n	8238 <mesh_aes_k2+0x12a>
		return;
	}
	memcpy(T1_in, p, p_len);
    813e:	0022      	movs	r2, r4
    8140:	9901      	ldr	r1, [sp, #4]
    8142:	f00d fc45 	bl	159d0 <memcpy>
	T1_in[p_len] = 0x01;
    8146:	2301      	movs	r3, #1
	mesh_aes_cmac_internal((const uint8_t*)T,(const uint8_t*)T1_in, p_len+1,T1);	
    8148:	ae0a      	add	r6, sp, #40	; 0x28
    814a:	b2a7      	uxth	r7, r4
    814c:	18fa      	adds	r2, r7, r3
	T1_in = ke_malloc(p_len +1, 0);
	if(!T1_in){
		return;
	}
	memcpy(T1_in, p, p_len);
	T1_in[p_len] = 0x01;
    814e:	552b      	strb	r3, [r5, r4]
	mesh_aes_cmac_internal((const uint8_t*)T,(const uint8_t*)T1_in, p_len+1,T1);	
    8150:	0029      	movs	r1, r5
    8152:	0033      	movs	r3, r6
    8154:	a806      	add	r0, sp, #24
    8156:	f7ff fef3 	bl	7f40 <mesh_aes_cmac_internal>

	nid = T1[15] & 0x7F;

	*aes_res++ = nid;
    815a:	237f      	movs	r3, #127	; 0x7f
    815c:	7bf2      	ldrb	r2, [r6, #15]
	
	//compute T2
	T2_in = ke_malloc(16 + p_len +1, 0);
    815e:	2100      	movs	r1, #0
	T1_in[p_len] = 0x01;
	mesh_aes_cmac_internal((const uint8_t*)T,(const uint8_t*)T1_in, p_len+1,T1);	

	nid = T1[15] & 0x7F;

	*aes_res++ = nid;
    8160:	4013      	ands	r3, r2
    8162:	9a02      	ldr	r2, [sp, #8]
    8164:	7013      	strb	r3, [r2, #0]
	
	//compute T2
	T2_in = ke_malloc(16 + p_len +1, 0);
    8166:	0023      	movs	r3, r4
    8168:	3311      	adds	r3, #17
    816a:	0018      	movs	r0, r3
    816c:	9303      	str	r3, [sp, #12]
    816e:	f7ff f8b7 	bl	72e0 <ke_malloc>
    8172:	9000      	str	r0, [sp, #0]
	if(!T2_in){
    8174:	2800      	cmp	r0, #0
    8176:	d103      	bne.n	8180 <mesh_aes_k2+0x72>
		ke_free(T1_in);
    8178:	0028      	movs	r0, r5
    817a:	f7ff f8b5 	bl	72e8 <ke_free>
		return;
    817e:	e05b      	b.n	8238 <mesh_aes_k2+0x12a>
	}
	memcpy(T2_in, T1, 16);
    8180:	0031      	movs	r1, r6
    8182:	2210      	movs	r2, #16
    8184:	9800      	ldr	r0, [sp, #0]
    8186:	f00d fc23 	bl	159d0 <memcpy>
	memcpy(T2_in + 16, p, p_len);
    818a:	9800      	ldr	r0, [sp, #0]
    818c:	0022      	movs	r2, r4
    818e:	9901      	ldr	r1, [sp, #4]
    8190:	3010      	adds	r0, #16
    8192:	f00d fc1d 	bl	159d0 <memcpy>
	T2_in[16+p_len] = 0x02;
    8196:	0023      	movs	r3, r4
    8198:	3310      	adds	r3, #16
    819a:	9304      	str	r3, [sp, #16]
    819c:	2302      	movs	r3, #2
    819e:	9a00      	ldr	r2, [sp, #0]
    81a0:	9904      	ldr	r1, [sp, #16]
	mesh_aes_cmac_internal((const uint8_t*)T,(const uint8_t*)T2_in, 16+p_len+1,T2);	
    81a2:	3711      	adds	r7, #17
		ke_free(T1_in);
		return;
	}
	memcpy(T2_in, T1, 16);
	memcpy(T2_in + 16, p, p_len);
	T2_in[16+p_len] = 0x02;
    81a4:	5453      	strb	r3, [r2, r1]
	mesh_aes_cmac_internal((const uint8_t*)T,(const uint8_t*)T2_in, 16+p_len+1,T2);	
    81a6:	a806      	add	r0, sp, #24
    81a8:	ab0e      	add	r3, sp, #56	; 0x38
    81aa:	003a      	movs	r2, r7
    81ac:	9900      	ldr	r1, [sp, #0]
    81ae:	9705      	str	r7, [sp, #20]

	for(int i=0; i<16; i++){
    81b0:	2600      	movs	r6, #0
		return;
	}
	memcpy(T2_in, T1, 16);
	memcpy(T2_in + 16, p, p_len);
	T2_in[16+p_len] = 0x02;
	mesh_aes_cmac_internal((const uint8_t*)T,(const uint8_t*)T2_in, 16+p_len+1,T2);	
    81b2:	f7ff fec5 	bl	7f40 <mesh_aes_cmac_internal>

	for(int i=0; i<16; i++){
		*aes_res++ = T2[i];
    81b6:	2120      	movs	r1, #32
    81b8:	aa06      	add	r2, sp, #24
    81ba:	9b02      	ldr	r3, [sp, #8]
    81bc:	1852      	adds	r2, r2, r1
    81be:	5d92      	ldrb	r2, [r2, r6]
    81c0:	199b      	adds	r3, r3, r6
	memcpy(T2_in, T1, 16);
	memcpy(T2_in + 16, p, p_len);
	T2_in[16+p_len] = 0x02;
	mesh_aes_cmac_internal((const uint8_t*)T,(const uint8_t*)T2_in, 16+p_len+1,T2);	

	for(int i=0; i<16; i++){
    81c2:	3601      	adds	r6, #1
		*aes_res++ = T2[i];
    81c4:	705a      	strb	r2, [r3, #1]
	memcpy(T2_in, T1, 16);
	memcpy(T2_in + 16, p, p_len);
	T2_in[16+p_len] = 0x02;
	mesh_aes_cmac_internal((const uint8_t*)T,(const uint8_t*)T2_in, 16+p_len+1,T2);	

	for(int i=0; i<16; i++){
    81c6:	2e10      	cmp	r6, #16
    81c8:	d1f5      	bne.n	81b6 <mesh_aes_k2+0xa8>
		*aes_res++ = T2[i];
	}

	//compute T3
	T3_in = ke_malloc(16 + p_len +1, 0);
    81ca:	2100      	movs	r1, #0
    81cc:	9803      	ldr	r0, [sp, #12]
    81ce:	f7ff f887 	bl	72e0 <ke_malloc>
    81d2:	1e07      	subs	r7, r0, #0
	if(!T3_in){
    81d4:	d106      	bne.n	81e4 <mesh_aes_k2+0xd6>
		ke_free(T1_in);
    81d6:	0028      	movs	r0, r5
    81d8:	f7ff f886 	bl	72e8 <ke_free>
		ke_free(T2_in);
    81dc:	9800      	ldr	r0, [sp, #0]
    81de:	f7ff f883 	bl	72e8 <ke_free>
		return;
    81e2:	e029      	b.n	8238 <mesh_aes_k2+0x12a>
	}
	memcpy(T3_in, T2, 16);
    81e4:	0032      	movs	r2, r6
    81e6:	a90e      	add	r1, sp, #56	; 0x38
    81e8:	f00d fbf2 	bl	159d0 <memcpy>
	memcpy(T3_in + 16, p, p_len);
    81ec:	0038      	movs	r0, r7
    81ee:	0022      	movs	r2, r4
    81f0:	9901      	ldr	r1, [sp, #4]
    81f2:	3010      	adds	r0, #16
    81f4:	f00d fbec 	bl	159d0 <memcpy>
	T3_in[16+p_len] = 0x03;
    81f8:	2303      	movs	r3, #3
    81fa:	9a04      	ldr	r2, [sp, #16]
	memset(T3, 0x00, 16);
    81fc:	ac12      	add	r4, sp, #72	; 0x48
		ke_free(T2_in);
		return;
	}
	memcpy(T3_in, T2, 16);
	memcpy(T3_in + 16, p, p_len);
	T3_in[16+p_len] = 0x03;
    81fe:	54bb      	strb	r3, [r7, r2]
	memset(T3, 0x00, 16);
    8200:	2100      	movs	r1, #0
    8202:	0032      	movs	r2, r6
    8204:	0020      	movs	r0, r4
    8206:	f00d fc21 	bl	15a4c <memset>
	mesh_aes_cmac_internal((const uint8_t*)T,(const uint8_t*)T3_in, 16+ p_len+1,T3);	
    820a:	0023      	movs	r3, r4
    820c:	9a05      	ldr	r2, [sp, #20]
    820e:	0039      	movs	r1, r7
    8210:	a806      	add	r0, sp, #24
    8212:	f7ff fe95 	bl	7f40 <mesh_aes_cmac_internal>
	for(int i=0; i<16; i++){
    8216:	2300      	movs	r3, #0
		*aes_res++ = T3[i];
    8218:	9a02      	ldr	r2, [sp, #8]
    821a:	5ce1      	ldrb	r1, [r4, r3]
    821c:	18d2      	adds	r2, r2, r3
	memcpy(T3_in, T2, 16);
	memcpy(T3_in + 16, p, p_len);
	T3_in[16+p_len] = 0x03;
	memset(T3, 0x00, 16);
	mesh_aes_cmac_internal((const uint8_t*)T,(const uint8_t*)T3_in, 16+ p_len+1,T3);	
	for(int i=0; i<16; i++){
    821e:	3301      	adds	r3, #1
		*aes_res++ = T3[i];
    8220:	7451      	strb	r1, [r2, #17]
	memcpy(T3_in, T2, 16);
	memcpy(T3_in + 16, p, p_len);
	T3_in[16+p_len] = 0x03;
	memset(T3, 0x00, 16);
	mesh_aes_cmac_internal((const uint8_t*)T,(const uint8_t*)T3_in, 16+ p_len+1,T3);	
	for(int i=0; i<16; i++){
    8222:	2b10      	cmp	r3, #16
    8224:	d1f8      	bne.n	8218 <mesh_aes_k2+0x10a>
		*aes_res++ = T3[i];
	}

	//	*aes_res = strcat(strcat(T1,T2),T3) % pow(2,263);
	ke_free(T1_in);
    8226:	0028      	movs	r0, r5
    8228:	f7ff f85e 	bl	72e8 <ke_free>
	ke_free(T2_in);
    822c:	9800      	ldr	r0, [sp, #0]
    822e:	f7ff f85b 	bl	72e8 <ke_free>
	ke_free(T3_in);
    8232:	0038      	movs	r0, r7
    8234:	f7ff f858 	bl	72e8 <ke_free>
}
    8238:	b01b      	add	sp, #108	; 0x6c
    823a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    823c:	00021051 	.word	0x00021051

00008240 <mesh_aes_k3>:

void mesh_aes_k3(const uint8_t* n, uint8_t* aes_res)
{
    8240:	b5f0      	push	{r4, r5, r6, r7, lr}
	uint8_t salt[16], T[16];
	const uint8_t id64[] = { 'i', 'd', '6', '4', 0x01 };
    8242:	4c12      	ldr	r4, [pc, #72]	; (828c <mesh_aes_k3+0x4c>)
	ke_free(T2_in);
	ke_free(T3_in);
}

void mesh_aes_k3(const uint8_t* n, uint8_t* aes_res)
{
    8244:	000e      	movs	r6, r1
	uint8_t salt[16], T[16];
	const uint8_t id64[] = { 'i', 'd', '6', '4', 0x01 };
    8246:	2505      	movs	r5, #5
    8248:	0021      	movs	r1, r4
	ke_free(T2_in);
	ke_free(T3_in);
}

void mesh_aes_k3(const uint8_t* n, uint8_t* aes_res)
{
    824a:	b08f      	sub	sp, #60	; 0x3c
    824c:	0007      	movs	r7, r0
	uint8_t salt[16], T[16];
	const uint8_t id64[] = { 'i', 'd', '6', '4', 0x01 };
    824e:	002a      	movs	r2, r5
    8250:	3144      	adds	r1, #68	; 0x44
    8252:	4668      	mov	r0, sp
    8254:	f00d fbbc 	bl	159d0 <memcpy>
	uint8_t out_tmp[16];

	mesh_aes_s1(smk3,4,salt);
    8258:	0020      	movs	r0, r4
    825a:	aa02      	add	r2, sp, #8
    825c:	3039      	adds	r0, #57	; 0x39
    825e:	2104      	movs	r1, #4
    8260:	f7ff ff2c 	bl	80bc <mesh_aes_s1>
	
	mesh_aes_cmac_internal((const uint8_t*)salt,n,16,T);
    8264:	ab06      	add	r3, sp, #24
    8266:	0039      	movs	r1, r7
    8268:	a802      	add	r0, sp, #8
    826a:	2210      	movs	r2, #16
    826c:	f7ff fe68 	bl	7f40 <mesh_aes_cmac_internal>
	mesh_aes_cmac_internal((const uint8_t*)T, id64, sizeof(id64), out_tmp);
    8270:	ab0a      	add	r3, sp, #40	; 0x28
    8272:	002a      	movs	r2, r5
    8274:	4669      	mov	r1, sp
    8276:	a806      	add	r0, sp, #24
    8278:	f7ff fe62 	bl	7f40 <mesh_aes_cmac_internal>

	memcpy(aes_res, out_tmp+8, 8);
    827c:	2208      	movs	r2, #8
    827e:	a90c      	add	r1, sp, #48	; 0x30
    8280:	0030      	movs	r0, r6
    8282:	f00d fba5 	bl	159d0 <memcpy>
}
    8286:	b00f      	add	sp, #60	; 0x3c
    8288:	bdf0      	pop	{r4, r5, r6, r7, pc}
    828a:	46c0      	nop			; (mov r8, r8)
    828c:	00021051 	.word	0x00021051

00008290 <mesh_aes_k4>:

void mesh_aes_k4(const uint8_t* n, uint8_t* aes_res)
{
    8290:	b5f0      	push	{r4, r5, r6, r7, lr}
	uint8_t salt[16], T[16];	
	const uint8_t id6[] = { 'i', 'd', '6', 0x01 };
    8292:	4c12      	ldr	r4, [pc, #72]	; (82dc <mesh_aes_k4+0x4c>)
    8294:	2504      	movs	r5, #4

	memcpy(aes_res, out_tmp+8, 8);
}

void mesh_aes_k4(const uint8_t* n, uint8_t* aes_res)
{
    8296:	000e      	movs	r6, r1
	uint8_t salt[16], T[16];	
	const uint8_t id6[] = { 'i', 'd', '6', 0x01 };
    8298:	0021      	movs	r1, r4

	memcpy(aes_res, out_tmp+8, 8);
}

void mesh_aes_k4(const uint8_t* n, uint8_t* aes_res)
{
    829a:	b08f      	sub	sp, #60	; 0x3c
    829c:	0007      	movs	r7, r0
	uint8_t salt[16], T[16];	
	const uint8_t id6[] = { 'i', 'd', '6', 0x01 };
    829e:	002a      	movs	r2, r5
    82a0:	3149      	adds	r1, #73	; 0x49
    82a2:	a801      	add	r0, sp, #4
    82a4:	f00d fb94 	bl	159d0 <memcpy>
	uint8_t out_tmp[16];
	uint8_t out;
	mesh_aes_s1(smk4,4,salt);
    82a8:	0020      	movs	r0, r4
    82aa:	aa02      	add	r2, sp, #8
    82ac:	0029      	movs	r1, r5
    82ae:	303d      	adds	r0, #61	; 0x3d
    82b0:	f7ff ff04 	bl	80bc <mesh_aes_s1>
	
	mesh_aes_cmac_internal((const uint8_t*)salt,n,16,T);
	mesh_aes_cmac_internal((const uint8_t*)T, id6, sizeof(id6), out_tmp);
    82b4:	ac0a      	add	r4, sp, #40	; 0x28
	const uint8_t id6[] = { 'i', 'd', '6', 0x01 };
	uint8_t out_tmp[16];
	uint8_t out;
	mesh_aes_s1(smk4,4,salt);
	
	mesh_aes_cmac_internal((const uint8_t*)salt,n,16,T);
    82b6:	ab06      	add	r3, sp, #24
    82b8:	0039      	movs	r1, r7
    82ba:	a802      	add	r0, sp, #8
    82bc:	2210      	movs	r2, #16
    82be:	f7ff fe3f 	bl	7f40 <mesh_aes_cmac_internal>
	mesh_aes_cmac_internal((const uint8_t*)T, id6, sizeof(id6), out_tmp);
    82c2:	0023      	movs	r3, r4
    82c4:	002a      	movs	r2, r5
    82c6:	a901      	add	r1, sp, #4
    82c8:	a806      	add	r0, sp, #24
    82ca:	f7ff fe39 	bl	7f40 <mesh_aes_cmac_internal>

	out = out_tmp[15] & 0x3f;
	*aes_res = out;
    82ce:	233f      	movs	r3, #63	; 0x3f
    82d0:	7be2      	ldrb	r2, [r4, #15]
    82d2:	4013      	ands	r3, r2
    82d4:	7033      	strb	r3, [r6, #0]
//	*aes_res %= pow(2,6);
}
    82d6:	b00f      	add	sp, #60	; 0x3c
    82d8:	bdf0      	pop	{r4, r5, r6, r7, pc}
    82da:	46c0      	nop			; (mov r8, r8)
    82dc:	00021051 	.word	0x00021051

000082e0 <mesh_aes_ccm>:

void mesh_aes_ccm(const uint8_t* key, const uint8_t* nonce, const uint8_t* in_message,
		   uint8_t* out_message, uint16_t message_len, uint8_t mic_len, bool cipher,
		   const uint8_t* add_auth_data, uint8_t add_auth_data_len, mesh_aes_ccm_func_result_cb res_cb,
		   uint32_t src_info)
{
    82e0:	b5f0      	push	{r4, r5, r6, r7, lr}
    82e2:	b0a5      	sub	sp, #148	; 0x94
    82e4:	9305      	str	r3, [sp, #20]
    82e6:	ab2a      	add	r3, sp, #168	; 0xa8
    82e8:	881b      	ldrh	r3, [r3, #0]
    82ea:	9206      	str	r2, [sp, #24]
    82ec:	9303      	str	r3, [sp, #12]
    82ee:	ab2b      	add	r3, sp, #172	; 0xac
    82f0:	781b      	ldrb	r3, [r3, #0]
    82f2:	9002      	str	r0, [sp, #8]
    82f4:	9307      	str	r3, [sp, #28]
    82f6:	ab2c      	add	r3, sp, #176	; 0xb0
    82f8:	781e      	ldrb	r6, [r3, #0]
    82fa:	ab2e      	add	r3, sp, #184	; 0xb8
    82fc:	9104      	str	r1, [sp, #16]
    82fe:	781c      	ldrb	r4, [r3, #0]
    8300:	ad0c      	add	r5, sp, #48	; 0x30
	uint8_t *out_msg = out_message;
	const uint8_t* aad = add_auth_data;

	if(cipher == true )  // encrypt it
	{
		memset(pmsg, 0x00, 16);
    8302:	2210      	movs	r2, #16
	uint8_t mic_size = mic_len;
	uint16_t msg_len = message_len;
	uint8_t *out_msg = out_message;
	const uint8_t* aad = add_auth_data;

	if(cipher == true )  // encrypt it
    8304:	2e00      	cmp	r6, #0
    8306:	d100      	bne.n	830a <mesh_aes_ccm+0x2a>
    8308:	e13b      	b.n	8582 <mesh_aes_ccm+0x2a2>
	{
		memset(pmsg, 0x00, 16);
    830a:	2100      	movs	r1, #0
    830c:	0028      	movs	r0, r5
    830e:	f00d fb9d 	bl	15a4c <memset>
		memset(cmic, 0x00, 16);
    8312:	2210      	movs	r2, #16
    8314:	2100      	movs	r1, #0
    8316:	a810      	add	r0, sp, #64	; 0x40
    8318:	f00d fb98 	bl	15a4c <memset>
		memset(cmsg, 0x00, 16);
    831c:	2210      	movs	r2, #16
    831e:	2100      	movs	r1, #0
    8320:	a814      	add	r0, sp, #80	; 0x50
    8322:	f00d fb93 	bl	15a4c <memset>
		memset(Xn, 0x00, 16);
    8326:	2210      	movs	r2, #16
    8328:	2100      	movs	r1, #0
    832a:	a818      	add	r0, sp, #96	; 0x60
    832c:	f00d fb8e 	bl	15a4c <memset>
		memset(mic, 0x00, 16);
    8330:	2210      	movs	r2, #16
    8332:	2100      	movs	r1, #0
    8334:	a81c      	add	r0, sp, #112	; 0x70
    8336:	f00d fb89 	bl	15a4c <memset>
		const uint8_t *msg = in_message;

		if (msg_len < 1 || aad_len >= 0xff00) {
    833a:	9b03      	ldr	r3, [sp, #12]
    833c:	2b00      	cmp	r3, #0
    833e:	d100      	bne.n	8342 <mesh_aes_ccm+0x62>
    8340:	e281      	b.n	8846 <mesh_aes_ccm+0x566>
			return;
		}

		/* C_mic = e(AppKey, 0x01 || nonce || 0x0000) */
		pmsg[0] = 0x01;
    8342:	2301      	movs	r3, #1
		memcpy(pmsg + 1, nonce, 13);
    8344:	2009      	movs	r0, #9
		if (msg_len < 1 || aad_len >= 0xff00) {
			return;
		}

		/* C_mic = e(AppKey, 0x01 || nonce || 0x0000) */
		pmsg[0] = 0x01;
    8346:	702b      	strb	r3, [r5, #0]
		memcpy(pmsg + 1, nonce, 13);
    8348:	ab0a      	add	r3, sp, #40	; 0x28
    834a:	18c0      	adds	r0, r0, r3
    834c:	220d      	movs	r2, #13
    834e:	9904      	ldr	r1, [sp, #16]
    8350:	f00d fb3e 	bl	159d0 <memcpy>
		sys_put_be16(0x0000, pmsg + 14);

		mesh_aes_encrypt(key, pmsg, cmic);
    8354:	aa10      	add	r2, sp, #64	; 0x40
    8356:	0029      	movs	r1, r5
    8358:	9802      	ldr	r0, [sp, #8]
    835a:	f7ff fd3f 	bl	7ddc <mesh_aes_encrypt>

		/* X_0 = e(AppKey, 0x09 || nonce || length) */
		if (mic_size == sizeof(uint64_t)) {
    835e:	9b07      	ldr	r3, [sp, #28]
    8360:	2b08      	cmp	r3, #8
    8362:	d103      	bne.n	836c <mesh_aes_ccm+0x8c>
			pmsg[0] = 0x19 | (aad_len ? 0x40 : 0x00);
    8364:	3351      	adds	r3, #81	; 0x51
    8366:	2c00      	cmp	r4, #0
    8368:	d104      	bne.n	8374 <mesh_aes_ccm+0x94>
    836a:	e002      	b.n	8372 <mesh_aes_ccm+0x92>
		} else {
			pmsg[0] = 0x09 | (aad_len ? 0x40 : 0x00);
    836c:	2349      	movs	r3, #73	; 0x49
    836e:	2c00      	cmp	r4, #0
    8370:	d100      	bne.n	8374 <mesh_aes_ccm+0x94>
    8372:	3b40      	subs	r3, #64	; 0x40
		}

		memcpy(pmsg + 1, nonce, 13);
    8374:	2009      	movs	r0, #9

		/* X_0 = e(AppKey, 0x09 || nonce || length) */
		if (mic_size == sizeof(uint64_t)) {
			pmsg[0] = 0x19 | (aad_len ? 0x40 : 0x00);
		} else {
			pmsg[0] = 0x09 | (aad_len ? 0x40 : 0x00);
    8376:	702b      	strb	r3, [r5, #0]
		}

		memcpy(pmsg + 1, nonce, 13);
    8378:	ab0a      	add	r3, sp, #40	; 0x28
    837a:	220d      	movs	r2, #13
    837c:	9904      	ldr	r1, [sp, #16]
    837e:	18c0      	adds	r0, r0, r3
    8380:	f00d fb26 	bl	159d0 <memcpy>
}

#define AUTHENTICATION_DOMAIN 
static inline void sys_put_be16(uint16_t val, uint8_t dst[2])
{
	dst[0] = val >> 8;
    8384:	9b03      	ldr	r3, [sp, #12]
			pmsg[0] = 0x19 | (aad_len ? 0x40 : 0x00);
		} else {
			pmsg[0] = 0x09 | (aad_len ? 0x40 : 0x00);
		}

		memcpy(pmsg + 1, nonce, 13);
    8386:	ad0c      	add	r5, sp, #48	; 0x30
}

#define AUTHENTICATION_DOMAIN 
static inline void sys_put_be16(uint16_t val, uint8_t dst[2])
{
	dst[0] = val >> 8;
    8388:	0a1b      	lsrs	r3, r3, #8
    838a:	73ab      	strb	r3, [r5, #14]
	dst[1] = val;
    838c:	466b      	mov	r3, sp
    838e:	7b1b      	ldrb	r3, [r3, #12]
		}

		memcpy(pmsg + 1, nonce, 13);
		sys_put_be16(msg_len, pmsg + 14);

		mesh_aes_encrypt(key, pmsg, Xn);
    8390:	ae18      	add	r6, sp, #96	; 0x60

#define AUTHENTICATION_DOMAIN 
static inline void sys_put_be16(uint16_t val, uint8_t dst[2])
{
	dst[0] = val >> 8;
	dst[1] = val;
    8392:	73eb      	strb	r3, [r5, #15]
		}

		memcpy(pmsg + 1, nonce, 13);
		sys_put_be16(msg_len, pmsg + 14);

		mesh_aes_encrypt(key, pmsg, Xn);
    8394:	0032      	movs	r2, r6
    8396:	0029      	movs	r1, r5
    8398:	9802      	ldr	r0, [sp, #8]
    839a:	f7ff fd1f 	bl	7ddc <mesh_aes_encrypt>

		/* If AAD is being used to authenticate, include it here */
		if (aad_len) {
    839e:	2c00      	cmp	r4, #0
    83a0:	d040      	beq.n	8424 <mesh_aes_ccm+0x144>
			sys_put_be16(aad_len, pmsg);

			for (i = 0; i < sizeof(uint16_t); i++) {
				pmsg[i] = Xn[i] ^ pmsg[i];
    83a2:	7833      	ldrb	r3, [r6, #0]

		/* If AAD is being used to authenticate, include it here */
		if (aad_len) {
			sys_put_be16(aad_len, pmsg);

			for (i = 0; i < sizeof(uint16_t); i++) {
    83a4:	2002      	movs	r0, #2
				pmsg[i] = Xn[i] ^ pmsg[i];
    83a6:	702b      	strb	r3, [r5, #0]
    83a8:	7873      	ldrb	r3, [r6, #1]
    83aa:	4063      	eors	r3, r4
    83ac:	706b      	strb	r3, [r5, #1]
			}

			j = 0;
    83ae:	2500      	movs	r5, #0
			aad_len += sizeof(uint16_t);
    83b0:	3402      	adds	r4, #2
    83b2:	b2e4      	uxtb	r4, r4
			while (aad_len > 16) {
    83b4:	2c10      	cmp	r4, #16
    83b6:	d91a      	bls.n	83ee <mesh_aes_ccm+0x10e>
				do {
					pmsg[i] = Xn[i] ^ aad[j];
    83b8:	1a2a      	subs	r2, r5, r0
    83ba:	0003      	movs	r3, r0
    83bc:	4694      	mov	ip, r2
    83be:	4662      	mov	r2, ip
    83c0:	9f2d      	ldr	r7, [sp, #180]	; 0xb4
    83c2:	189e      	adds	r6, r3, r2
    83c4:	b2f6      	uxtb	r6, r6
    83c6:	aa18      	add	r2, sp, #96	; 0x60
    83c8:	5dbf      	ldrb	r7, [r7, r6]
    83ca:	5cd6      	ldrb	r6, [r2, r3]
    83cc:	a90c      	add	r1, sp, #48	; 0x30
    83ce:	407e      	eors	r6, r7
    83d0:	54ce      	strb	r6, [r1, r3]
					i++, j++;
    83d2:	3301      	adds	r3, #1
    83d4:	b2db      	uxtb	r3, r3
				} while (i < 16);
    83d6:	2b10      	cmp	r3, #16
    83d8:	d1f1      	bne.n	83be <mesh_aes_ccm+0xde>
    83da:	1a1b      	subs	r3, r3, r0
    83dc:	18ed      	adds	r5, r5, r3

				aad_len -= 16;
				i = 0;
				
				 mesh_aes_encrypt(key, pmsg, Xn);
    83de:	9802      	ldr	r0, [sp, #8]
				do {
					pmsg[i] = Xn[i] ^ aad[j];
					i++, j++;
				} while (i < 16);

				aad_len -= 16;
    83e0:	3c10      	subs	r4, #16
				i = 0;
				
				 mesh_aes_encrypt(key, pmsg, Xn);
    83e2:	f7ff fcfb 	bl	7ddc <mesh_aes_encrypt>
    83e6:	b2ed      	uxtb	r5, r5
				do {
					pmsg[i] = Xn[i] ^ aad[j];
					i++, j++;
				} while (i < 16);

				aad_len -= 16;
    83e8:	b2e4      	uxtb	r4, r4
				i = 0;
    83ea:	2000      	movs	r0, #0
    83ec:	e7e2      	b.n	83b4 <mesh_aes_ccm+0xd4>
    83ee:	2300      	movs	r3, #0
    83f0:	b2d9      	uxtb	r1, r3
    83f2:	186a      	adds	r2, r5, r1
    83f4:	b2d2      	uxtb	r2, r2
				
				 mesh_aes_encrypt(key, pmsg, Xn);
			}

			for (i = 0; i < aad_len; i++, j++) {
    83f6:	428c      	cmp	r4, r1
    83f8:	d908      	bls.n	840c <mesh_aes_ccm+0x12c>
				pmsg[i] = Xn[i] ^ aad[j];
    83fa:	992d      	ldr	r1, [sp, #180]	; 0xb4
    83fc:	5c89      	ldrb	r1, [r1, r2]
    83fe:	aa18      	add	r2, sp, #96	; 0x60
    8400:	5c9a      	ldrb	r2, [r3, r2]
    8402:	404a      	eors	r2, r1
    8404:	a90c      	add	r1, sp, #48	; 0x30
    8406:	545a      	strb	r2, [r3, r1]
    8408:	3301      	adds	r3, #1
    840a:	e7f1      	b.n	83f0 <mesh_aes_ccm+0x110>
    840c:	a90c      	add	r1, sp, #48	; 0x30
    840e:	aa18      	add	r2, sp, #96	; 0x60
			}

			for (i = aad_len; i < 16; i++) {
    8410:	2c10      	cmp	r4, #16
    8412:	d004      	beq.n	841e <mesh_aes_ccm+0x13e>
				pmsg[i] = Xn[i];
    8414:	5d13      	ldrb	r3, [r2, r4]
    8416:	550b      	strb	r3, [r1, r4]

			for (i = 0; i < aad_len; i++, j++) {
				pmsg[i] = Xn[i] ^ aad[j];
			}

			for (i = aad_len; i < 16; i++) {
    8418:	3401      	adds	r4, #1
    841a:	b2e4      	uxtb	r4, r4
    841c:	e7f6      	b.n	840c <mesh_aes_ccm+0x12c>
				pmsg[i] = Xn[i];
			}
			mesh_aes_encrypt(key, pmsg, Xn);
    841e:	9802      	ldr	r0, [sp, #8]
    8420:	f7ff fcdc 	bl	7ddc <mesh_aes_encrypt>
		}

		last_blk = msg_len % 16;
    8424:	230f      	movs	r3, #15
    8426:	9e03      	ldr	r6, [sp, #12]
    8428:	401e      	ands	r6, r3
		blk_cnt = (msg_len + 15) / 16;
    842a:	9b03      	ldr	r3, [sp, #12]
    842c:	330f      	adds	r3, #15
    842e:	111b      	asrs	r3, r3, #4
    8430:	9309      	str	r3, [sp, #36]	; 0x24
    8432:	466b      	mov	r3, sp
    8434:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
    8436:	930b      	str	r3, [sp, #44]	; 0x2c
		if (!last_blk) {
    8438:	2e00      	cmp	r6, #0
    843a:	d100      	bne.n	843e <mesh_aes_ccm+0x15e>
			last_blk = 16U;
    843c:	3610      	adds	r6, #16
		}

		for (j = 0; j < blk_cnt; j++) {
    843e:	2700      	movs	r7, #0
    8440:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    8442:	b2bc      	uxth	r4, r7
    8444:	42a3      	cmp	r3, r4
    8446:	d800      	bhi.n	844a <mesh_aes_ccm+0x16a>
    8448:	e085      	b.n	8556 <mesh_aes_ccm+0x276>
			if (j + 1 == blk_cnt) {
    844a:	9909      	ldr	r1, [sp, #36]	; 0x24
    844c:	013b      	lsls	r3, r7, #4
    844e:	1c7a      	adds	r2, r7, #1
    8450:	9308      	str	r3, [sp, #32]
				}
			} 
			else {
				/* X_1 = e(AppKey, X_0 ^ Payload[0-15]) */
				for (i = 0; i < 16; i++) {
					pmsg[i] = Xn[i] ^ msg[(j * 16) + i];
    8452:	2300      	movs	r3, #0
		if (!last_blk) {
			last_blk = 16U;
		}

		for (j = 0; j < blk_cnt; j++) {
			if (j + 1 == blk_cnt) {
    8454:	4291      	cmp	r1, r2
    8456:	d148      	bne.n	84ea <mesh_aes_ccm+0x20a>
				/* X_1 = e(AppKey, X_0 ^ Payload[0-15]) */
				for (i = 0; i < last_blk; i++) {
    8458:	429e      	cmp	r6, r3
    845a:	d90b      	bls.n	8474 <mesh_aes_ccm+0x194>
					pmsg[i] = Xn[i] ^ msg[(j * 16) + i];
    845c:	9a06      	ldr	r2, [sp, #24]
    845e:	9908      	ldr	r1, [sp, #32]
    8460:	18d2      	adds	r2, r2, r3
    8462:	5c51      	ldrb	r1, [r2, r1]
    8464:	aa18      	add	r2, sp, #96	; 0x60
    8466:	5cd2      	ldrb	r2, [r2, r3]
    8468:	404a      	eors	r2, r1
    846a:	a90c      	add	r1, sp, #48	; 0x30
    846c:	54ca      	strb	r2, [r1, r3]
		}

		for (j = 0; j < blk_cnt; j++) {
			if (j + 1 == blk_cnt) {
				/* X_1 = e(AppKey, X_0 ^ Payload[0-15]) */
				for (i = 0; i < last_blk; i++) {
    846e:	3301      	adds	r3, #1
    8470:	b2db      	uxtb	r3, r3
    8472:	e7f1      	b.n	8458 <mesh_aes_ccm+0x178>
					pmsg[i] = Xn[i] ^ msg[(j * 16) + i];
				}
				for (i = last_blk; i < 16; i++) {
    8474:	b2f3      	uxtb	r3, r6
    8476:	a90c      	add	r1, sp, #48	; 0x30
    8478:	aa18      	add	r2, sp, #96	; 0x60
    847a:	2b10      	cmp	r3, #16
    847c:	d004      	beq.n	8488 <mesh_aes_ccm+0x1a8>
					pmsg[i] = Xn[i] ^ 0x00;
    847e:	5cd2      	ldrb	r2, [r2, r3]
    8480:	54ca      	strb	r2, [r1, r3]
			if (j + 1 == blk_cnt) {
				/* X_1 = e(AppKey, X_0 ^ Payload[0-15]) */
				for (i = 0; i < last_blk; i++) {
					pmsg[i] = Xn[i] ^ msg[(j * 16) + i];
				}
				for (i = last_blk; i < 16; i++) {
    8482:	3301      	adds	r3, #1
    8484:	b2db      	uxtb	r3, r3
    8486:	e7f6      	b.n	8476 <mesh_aes_ccm+0x196>
					pmsg[i] = Xn[i] ^ 0x00;
				}
				mesh_aes_encrypt(key, pmsg, Xn);
    8488:	9802      	ldr	r0, [sp, #8]
    848a:	f7ff fca7 	bl	7ddc <mesh_aes_encrypt>
    848e:	2300      	movs	r3, #0

				/* MIC = C_mic ^ X_1 */
				for (i = 0; i < sizeof(mic); i++) {
					mic[i] = cmic[i] ^ Xn[i];
    8490:	aa10      	add	r2, sp, #64	; 0x40
    8492:	5c99      	ldrb	r1, [r3, r2]
    8494:	aa18      	add	r2, sp, #96	; 0x60
    8496:	5c9a      	ldrb	r2, [r3, r2]
    8498:	404a      	eors	r2, r1
    849a:	a91c      	add	r1, sp, #112	; 0x70
    849c:	545a      	strb	r2, [r3, r1]
    849e:	3301      	adds	r3, #1
					pmsg[i] = Xn[i] ^ 0x00;
				}
				mesh_aes_encrypt(key, pmsg, Xn);

				/* MIC = C_mic ^ X_1 */
				for (i = 0; i < sizeof(mic); i++) {
    84a0:	2b10      	cmp	r3, #16
    84a2:	d1f5      	bne.n	8490 <mesh_aes_ccm+0x1b0>
					mic[i] = cmic[i] ^ Xn[i];
				}

				/* C_1 = e(AppKey, 0x01 || nonce || 0x0001) */
				pmsg[0] = 0x01;
				memcpy(pmsg + 1, nonce, 13);
    84a4:	2009      	movs	r0, #9
				for (i = 0; i < sizeof(mic); i++) {
					mic[i] = cmic[i] ^ Xn[i];
				}

				/* C_1 = e(AppKey, 0x01 || nonce || 0x0001) */
				pmsg[0] = 0x01;
    84a6:	ad0c      	add	r5, sp, #48	; 0x30
    84a8:	3b0f      	subs	r3, #15
    84aa:	702b      	strb	r3, [r5, #0]
				memcpy(pmsg + 1, nonce, 13);
				sys_put_be16(j + 1, pmsg + 14);
    84ac:	3401      	adds	r4, #1
					mic[i] = cmic[i] ^ Xn[i];
				}

				/* C_1 = e(AppKey, 0x01 || nonce || 0x0001) */
				pmsg[0] = 0x01;
				memcpy(pmsg + 1, nonce, 13);
    84ae:	ab0a      	add	r3, sp, #40	; 0x28
    84b0:	220d      	movs	r2, #13
    84b2:	9904      	ldr	r1, [sp, #16]
    84b4:	18c0      	adds	r0, r0, r3
				sys_put_be16(j + 1, pmsg + 14);
    84b6:	b2a4      	uxth	r4, r4
					mic[i] = cmic[i] ^ Xn[i];
				}

				/* C_1 = e(AppKey, 0x01 || nonce || 0x0001) */
				pmsg[0] = 0x01;
				memcpy(pmsg + 1, nonce, 13);
    84b8:	f00d fa8a 	bl	159d0 <memcpy>
}

#define AUTHENTICATION_DOMAIN 
static inline void sys_put_be16(uint16_t val, uint8_t dst[2])
{
	dst[0] = val >> 8;
    84bc:	0a23      	lsrs	r3, r4, #8
    84be:	73ab      	strb	r3, [r5, #14]
	dst[1] = val;
    84c0:	73ec      	strb	r4, [r5, #15]
				/* C_1 = e(AppKey, 0x01 || nonce || 0x0001) */
				pmsg[0] = 0x01;
				memcpy(pmsg + 1, nonce, 13);
				sys_put_be16(j + 1, pmsg + 14);

				mesh_aes_encrypt(key, pmsg, cmsg);
    84c2:	aa14      	add	r2, sp, #80	; 0x50
    84c4:	0029      	movs	r1, r5
    84c6:	9802      	ldr	r0, [sp, #8]
    84c8:	f7ff fc88 	bl	7ddc <mesh_aes_encrypt>

				/* Encrypted = Payload[0-15] ^ C_1 */
				for (i = 0; i < last_blk; i++) {
    84cc:	2300      	movs	r3, #0
    84ce:	429e      	cmp	r6, r3
    84d0:	d93e      	bls.n	8550 <mesh_aes_ccm+0x270>
					out_msg[(j * 16) + i] =
    84d2:	9a08      	ldr	r2, [sp, #32]
    84d4:	18d1      	adds	r1, r2, r3
    84d6:	9a06      	ldr	r2, [sp, #24]
    84d8:	5c50      	ldrb	r0, [r2, r1]
    84da:	aa14      	add	r2, sp, #80	; 0x50
    84dc:	5cd2      	ldrb	r2, [r2, r3]
				sys_put_be16(j + 1, pmsg + 14);

				mesh_aes_encrypt(key, pmsg, cmsg);

				/* Encrypted = Payload[0-15] ^ C_1 */
				for (i = 0; i < last_blk; i++) {
    84de:	3301      	adds	r3, #1
					out_msg[(j * 16) + i] =
    84e0:	4042      	eors	r2, r0
    84e2:	9805      	ldr	r0, [sp, #20]
				sys_put_be16(j + 1, pmsg + 14);

				mesh_aes_encrypt(key, pmsg, cmsg);

				/* Encrypted = Payload[0-15] ^ C_1 */
				for (i = 0; i < last_blk; i++) {
    84e4:	b2db      	uxtb	r3, r3
					out_msg[(j * 16) + i] =
    84e6:	5442      	strb	r2, [r0, r1]
    84e8:	e7f1      	b.n	84ce <mesh_aes_ccm+0x1ee>
    84ea:	9908      	ldr	r1, [sp, #32]
    84ec:	9a06      	ldr	r2, [sp, #24]
    84ee:	468c      	mov	ip, r1
    84f0:	4462      	add	r2, ip
    84f2:	920a      	str	r2, [sp, #40]	; 0x28
				}
			} 
			else {
				/* X_1 = e(AppKey, X_0 ^ Payload[0-15]) */
				for (i = 0; i < 16; i++) {
					pmsg[i] = Xn[i] ^ msg[(j * 16) + i];
    84f4:	990a      	ldr	r1, [sp, #40]	; 0x28
    84f6:	aa18      	add	r2, sp, #96	; 0x60
    84f8:	5c98      	ldrb	r0, [r3, r2]
    84fa:	5cc9      	ldrb	r1, [r1, r3]
    84fc:	ad0c      	add	r5, sp, #48	; 0x30
    84fe:	4041      	eors	r1, r0
    8500:	5559      	strb	r1, [r3, r5]
    8502:	3301      	adds	r3, #1
						msg[(j * 16) + i] ^ cmsg[i];
				}
			} 
			else {
				/* X_1 = e(AppKey, X_0 ^ Payload[0-15]) */
				for (i = 0; i < 16; i++) {
    8504:	2b10      	cmp	r3, #16
    8506:	d1f0      	bne.n	84ea <mesh_aes_ccm+0x20a>
					pmsg[i] = Xn[i] ^ msg[(j * 16) + i];
				}

				mesh_aes_encrypt(key, pmsg, Xn);
    8508:	0029      	movs	r1, r5
    850a:	9802      	ldr	r0, [sp, #8]
    850c:	f7ff fc66 	bl	7ddc <mesh_aes_encrypt>

				/* C_1 = e(AppKey, 0x01 || nonce || 0x0001) */
				pmsg[0] = 0x01;
    8510:	2301      	movs	r3, #1
				memcpy(pmsg + 1, nonce, 13);
    8512:	2009      	movs	r0, #9
				}

				mesh_aes_encrypt(key, pmsg, Xn);

				/* C_1 = e(AppKey, 0x01 || nonce || 0x0001) */
				pmsg[0] = 0x01;
    8514:	702b      	strb	r3, [r5, #0]
				memcpy(pmsg + 1, nonce, 13);
				sys_put_be16(j + 1, pmsg + 14);
    8516:	3401      	adds	r4, #1

				mesh_aes_encrypt(key, pmsg, Xn);

				/* C_1 = e(AppKey, 0x01 || nonce || 0x0001) */
				pmsg[0] = 0x01;
				memcpy(pmsg + 1, nonce, 13);
    8518:	ab0a      	add	r3, sp, #40	; 0x28
    851a:	220d      	movs	r2, #13
    851c:	9904      	ldr	r1, [sp, #16]
    851e:	18c0      	adds	r0, r0, r3
				sys_put_be16(j + 1, pmsg + 14);
    8520:	b2a4      	uxth	r4, r4

				mesh_aes_encrypt(key, pmsg, Xn);

				/* C_1 = e(AppKey, 0x01 || nonce || 0x0001) */
				pmsg[0] = 0x01;
				memcpy(pmsg + 1, nonce, 13);
    8522:	f00d fa55 	bl	159d0 <memcpy>
}

#define AUTHENTICATION_DOMAIN 
static inline void sys_put_be16(uint16_t val, uint8_t dst[2])
{
	dst[0] = val >> 8;
    8526:	0a23      	lsrs	r3, r4, #8
    8528:	73ab      	strb	r3, [r5, #14]
	dst[1] = val;
    852a:	73ec      	strb	r4, [r5, #15]
				/* C_1 = e(AppKey, 0x01 || nonce || 0x0001) */
				pmsg[0] = 0x01;
				memcpy(pmsg + 1, nonce, 13);
				sys_put_be16(j + 1, pmsg + 14);

				mesh_aes_encrypt(key, pmsg, cmsg);
    852c:	aa14      	add	r2, sp, #80	; 0x50
    852e:	0029      	movs	r1, r5
    8530:	9802      	ldr	r0, [sp, #8]
    8532:	f7ff fc53 	bl	7ddc <mesh_aes_encrypt>
    8536:	2300      	movs	r3, #0

				/* Encrypted = Payload[0-15] ^ C_N */
				for (i = 0; i < 16; i++) {
					out_msg[(j * 16) + i] =
    8538:	9908      	ldr	r1, [sp, #32]
    853a:	9a05      	ldr	r2, [sp, #20]
    853c:	1852      	adds	r2, r2, r1
    853e:	990a      	ldr	r1, [sp, #40]	; 0x28
    8540:	5cc8      	ldrb	r0, [r1, r3]
    8542:	a914      	add	r1, sp, #80	; 0x50
    8544:	5c59      	ldrb	r1, [r3, r1]
    8546:	4041      	eors	r1, r0
    8548:	54d1      	strb	r1, [r2, r3]
    854a:	3301      	adds	r3, #1
				sys_put_be16(j + 1, pmsg + 14);

				mesh_aes_encrypt(key, pmsg, cmsg);

				/* Encrypted = Payload[0-15] ^ C_N */
				for (i = 0; i < 16; i++) {
    854c:	2b10      	cmp	r3, #16
    854e:	d1f3      	bne.n	8538 <mesh_aes_ccm+0x258>
		blk_cnt = (msg_len + 15) / 16;
		if (!last_blk) {
			last_blk = 16U;
		}

		for (j = 0; j < blk_cnt; j++) {
    8550:	3701      	adds	r7, #1
    8552:	b2ff      	uxtb	r7, r7
    8554:	e774      	b.n	8440 <mesh_aes_ccm+0x160>
				}

			}
		}

		memcpy(out_msg + msg_len, mic, mic_size);
    8556:	9b05      	ldr	r3, [sp, #20]
    8558:	9a03      	ldr	r2, [sp, #12]
    855a:	a91c      	add	r1, sp, #112	; 0x70
    855c:	1898      	adds	r0, r3, r2
    855e:	9a07      	ldr	r2, [sp, #28]
    8560:	f00d fa36 	bl	159d0 <memcpy>

		m_printf_hex(L_AL, "ccm encrypt res", out_msg, msg_len+mic_size);
    8564:	9a03      	ldr	r2, [sp, #12]
    8566:	9b07      	ldr	r3, [sp, #28]
    8568:	4694      	mov	ip, r2
    856a:	49b8      	ldr	r1, [pc, #736]	; (884c <mesh_aes_ccm+0x56c>)
    856c:	4463      	add	r3, ip
    856e:	9a05      	ldr	r2, [sp, #20]
    8570:	314d      	adds	r1, #77	; 0x4d
    8572:	2001      	movs	r0, #1
    8574:	f7fc fa7a 	bl	4a6c <m_printf_hex>
		res_cb(0, src_info); 
    8578:	9930      	ldr	r1, [sp, #192]	; 0xc0
    857a:	2000      	movs	r0, #0
    857c:	9b2f      	ldr	r3, [sp, #188]	; 0xbc
    857e:	4798      	blx	r3
    8580:	e161      	b.n	8846 <mesh_aes_ccm+0x566>
	}
	else   // decrypt it
	{
		const uint8_t*enc_msg = in_message;
		memset(pmsg, 0x00, 16);
    8582:	0031      	movs	r1, r6
    8584:	0028      	movs	r0, r5
    8586:	f00d fa61 	bl	15a4c <memset>
		memset(cmic, 0x00, 16);
    858a:	2210      	movs	r2, #16
    858c:	0031      	movs	r1, r6
    858e:	a810      	add	r0, sp, #64	; 0x40
    8590:	f00d fa5c 	bl	15a4c <memset>
		memset(cmsg, 0x00, 16);
    8594:	2210      	movs	r2, #16
    8596:	0031      	movs	r1, r6
    8598:	a814      	add	r0, sp, #80	; 0x50
    859a:	f00d fa57 	bl	15a4c <memset>
		memset(Xn, 0x00, 16);
    859e:	2210      	movs	r2, #16
    85a0:	0031      	movs	r1, r6
    85a2:	a818      	add	r0, sp, #96	; 0x60
    85a4:	f00d fa52 	bl	15a4c <memset>
		memset(mic, 0x00, 16);
    85a8:	2210      	movs	r2, #16
    85aa:	0031      	movs	r1, r6
    85ac:	a81c      	add	r0, sp, #112	; 0x70
    85ae:	f00d fa4d 	bl	15a4c <memset>
		memset(msg1, 0x00, 16);
    85b2:	2210      	movs	r2, #16
    85b4:	0031      	movs	r1, r6
    85b6:	a820      	add	r0, sp, #128	; 0x80
    85b8:	f00d fa48 	bl	15a4c <memset>

		if (msg_len < 1 || aad_len >= 0xff00) {
    85bc:	9b03      	ldr	r3, [sp, #12]
    85be:	2b00      	cmp	r3, #0
    85c0:	d100      	bne.n	85c4 <mesh_aes_ccm+0x2e4>
    85c2:	e140      	b.n	8846 <mesh_aes_ccm+0x566>
			return ;
		}

		/* C_mic = e(AppKey, 0x01 || nonce || 0x0000) */
		pmsg[0] = 0x01;
    85c4:	2301      	movs	r3, #1
		memcpy(pmsg + 1, nonce, 13);
    85c6:	2009      	movs	r0, #9
		if (msg_len < 1 || aad_len >= 0xff00) {
			return ;
		}

		/* C_mic = e(AppKey, 0x01 || nonce || 0x0000) */
		pmsg[0] = 0x01;
    85c8:	702b      	strb	r3, [r5, #0]
		memcpy(pmsg + 1, nonce, 13);
    85ca:	ab0a      	add	r3, sp, #40	; 0x28
    85cc:	18c0      	adds	r0, r0, r3
    85ce:	220d      	movs	r2, #13
    85d0:	9904      	ldr	r1, [sp, #16]
    85d2:	f00d f9fd 	bl	159d0 <memcpy>
		sys_put_be16(0x0000, pmsg + 14);

		mesh_aes_encrypt(key, pmsg, cmic);
    85d6:	aa10      	add	r2, sp, #64	; 0x40
    85d8:	0029      	movs	r1, r5
    85da:	9802      	ldr	r0, [sp, #8]
    85dc:	f7ff fbfe 	bl	7ddc <mesh_aes_encrypt>

		/* X_0 = e(AppKey, 0x09 || nonce || length) */
		if (mic_size == sizeof(uint64_t)) {
    85e0:	9b07      	ldr	r3, [sp, #28]
    85e2:	2b08      	cmp	r3, #8
    85e4:	d103      	bne.n	85ee <mesh_aes_ccm+0x30e>
			pmsg[0] = 0x19 | (aad_len ? 0x40 : 0x00);
    85e6:	3351      	adds	r3, #81	; 0x51
    85e8:	2c00      	cmp	r4, #0
    85ea:	d104      	bne.n	85f6 <mesh_aes_ccm+0x316>
    85ec:	e002      	b.n	85f4 <mesh_aes_ccm+0x314>
		} else {
			pmsg[0] = 0x09 | (aad_len ? 0x40 : 0x00);
    85ee:	2349      	movs	r3, #73	; 0x49
    85f0:	2c00      	cmp	r4, #0
    85f2:	d100      	bne.n	85f6 <mesh_aes_ccm+0x316>
    85f4:	3b40      	subs	r3, #64	; 0x40
		}

		memcpy(pmsg + 1, nonce, 13);
    85f6:	2009      	movs	r0, #9

		/* X_0 = e(AppKey, 0x09 || nonce || length) */
		if (mic_size == sizeof(uint64_t)) {
			pmsg[0] = 0x19 | (aad_len ? 0x40 : 0x00);
		} else {
			pmsg[0] = 0x09 | (aad_len ? 0x40 : 0x00);
    85f8:	702b      	strb	r3, [r5, #0]
		}

		memcpy(pmsg + 1, nonce, 13);
    85fa:	ab0a      	add	r3, sp, #40	; 0x28
    85fc:	220d      	movs	r2, #13
    85fe:	9904      	ldr	r1, [sp, #16]
    8600:	18c0      	adds	r0, r0, r3
    8602:	f00d f9e5 	bl	159d0 <memcpy>
}

#define AUTHENTICATION_DOMAIN 
static inline void sys_put_be16(uint16_t val, uint8_t dst[2])
{
	dst[0] = val >> 8;
    8606:	9b03      	ldr	r3, [sp, #12]
			pmsg[0] = 0x19 | (aad_len ? 0x40 : 0x00);
		} else {
			pmsg[0] = 0x09 | (aad_len ? 0x40 : 0x00);
		}

		memcpy(pmsg + 1, nonce, 13);
    8608:	ad0c      	add	r5, sp, #48	; 0x30
}

#define AUTHENTICATION_DOMAIN 
static inline void sys_put_be16(uint16_t val, uint8_t dst[2])
{
	dst[0] = val >> 8;
    860a:	0a1b      	lsrs	r3, r3, #8
    860c:	73ab      	strb	r3, [r5, #14]
	dst[1] = val;
    860e:	466b      	mov	r3, sp
    8610:	7b1b      	ldrb	r3, [r3, #12]
		}

		memcpy(pmsg + 1, nonce, 13);
		sys_put_be16(msg_len, pmsg + 14);

		mesh_aes_encrypt(key, pmsg, Xn);
    8612:	ae18      	add	r6, sp, #96	; 0x60

#define AUTHENTICATION_DOMAIN 
static inline void sys_put_be16(uint16_t val, uint8_t dst[2])
{
	dst[0] = val >> 8;
	dst[1] = val;
    8614:	73eb      	strb	r3, [r5, #15]
		}

		memcpy(pmsg + 1, nonce, 13);
		sys_put_be16(msg_len, pmsg + 14);

		mesh_aes_encrypt(key, pmsg, Xn);
    8616:	0032      	movs	r2, r6
    8618:	0029      	movs	r1, r5
    861a:	9802      	ldr	r0, [sp, #8]
    861c:	f7ff fbde 	bl	7ddc <mesh_aes_encrypt>

		/* If AAD is being used to authenticate, include it here */
		if (aad_len) {
    8620:	2c00      	cmp	r4, #0
    8622:	d040      	beq.n	86a6 <mesh_aes_ccm+0x3c6>
			sys_put_be16(aad_len, pmsg);

			for (i = 0; i < sizeof(uint16_t); i++) {
				pmsg[i] = Xn[i] ^ pmsg[i];
    8624:	7833      	ldrb	r3, [r6, #0]

		/* If AAD is being used to authenticate, include it here */
		if (aad_len) {
			sys_put_be16(aad_len, pmsg);

			for (i = 0; i < sizeof(uint16_t); i++) {
    8626:	2002      	movs	r0, #2
				pmsg[i] = Xn[i] ^ pmsg[i];
    8628:	702b      	strb	r3, [r5, #0]
    862a:	7873      	ldrb	r3, [r6, #1]
    862c:	4063      	eors	r3, r4
    862e:	706b      	strb	r3, [r5, #1]
			}

			j = 0;
    8630:	2500      	movs	r5, #0
			aad_len += sizeof(uint16_t);
    8632:	3402      	adds	r4, #2
    8634:	b2e4      	uxtb	r4, r4
			while (aad_len > 16) {
    8636:	2c10      	cmp	r4, #16
    8638:	d91a      	bls.n	8670 <mesh_aes_ccm+0x390>
				do {
					pmsg[i] = Xn[i] ^ aad[j];
    863a:	1a2a      	subs	r2, r5, r0
    863c:	0003      	movs	r3, r0
    863e:	4694      	mov	ip, r2
    8640:	4662      	mov	r2, ip
    8642:	9f2d      	ldr	r7, [sp, #180]	; 0xb4
    8644:	189e      	adds	r6, r3, r2
    8646:	b2f6      	uxtb	r6, r6
    8648:	aa18      	add	r2, sp, #96	; 0x60
    864a:	5dbf      	ldrb	r7, [r7, r6]
    864c:	5cd6      	ldrb	r6, [r2, r3]
    864e:	a90c      	add	r1, sp, #48	; 0x30
    8650:	407e      	eors	r6, r7
    8652:	54ce      	strb	r6, [r1, r3]
					i++, j++;
    8654:	3301      	adds	r3, #1
    8656:	b2db      	uxtb	r3, r3
				} while (i < 16);
    8658:	2b10      	cmp	r3, #16
    865a:	d1f1      	bne.n	8640 <mesh_aes_ccm+0x360>
    865c:	1a1b      	subs	r3, r3, r0
    865e:	18ed      	adds	r5, r5, r3

				aad_len -= 16;
				i = 0;

				 mesh_aes_encrypt(key, pmsg, Xn);
    8660:	9802      	ldr	r0, [sp, #8]
				do {
					pmsg[i] = Xn[i] ^ aad[j];
					i++, j++;
				} while (i < 16);

				aad_len -= 16;
    8662:	3c10      	subs	r4, #16
				i = 0;

				 mesh_aes_encrypt(key, pmsg, Xn);
    8664:	f7ff fbba 	bl	7ddc <mesh_aes_encrypt>
    8668:	b2ed      	uxtb	r5, r5
				do {
					pmsg[i] = Xn[i] ^ aad[j];
					i++, j++;
				} while (i < 16);

				aad_len -= 16;
    866a:	b2e4      	uxtb	r4, r4
				i = 0;
    866c:	2000      	movs	r0, #0
    866e:	e7e2      	b.n	8636 <mesh_aes_ccm+0x356>
    8670:	2300      	movs	r3, #0
    8672:	b2d9      	uxtb	r1, r3
    8674:	186a      	adds	r2, r5, r1
    8676:	b2d2      	uxtb	r2, r2

				 mesh_aes_encrypt(key, pmsg, Xn);

			}

			for (i = 0; i < aad_len; i++, j++) {
    8678:	428c      	cmp	r4, r1
    867a:	d908      	bls.n	868e <mesh_aes_ccm+0x3ae>
				pmsg[i] = Xn[i] ^ aad[j];
    867c:	992d      	ldr	r1, [sp, #180]	; 0xb4
    867e:	5c89      	ldrb	r1, [r1, r2]
    8680:	aa18      	add	r2, sp, #96	; 0x60
    8682:	5c9a      	ldrb	r2, [r3, r2]
    8684:	404a      	eors	r2, r1
    8686:	a90c      	add	r1, sp, #48	; 0x30
    8688:	545a      	strb	r2, [r3, r1]
    868a:	3301      	adds	r3, #1
    868c:	e7f1      	b.n	8672 <mesh_aes_ccm+0x392>
    868e:	a90c      	add	r1, sp, #48	; 0x30
    8690:	aa18      	add	r2, sp, #96	; 0x60
			}

			for (i = aad_len; i < 16; i++) {
    8692:	2c10      	cmp	r4, #16
    8694:	d004      	beq.n	86a0 <mesh_aes_ccm+0x3c0>
				pmsg[i] = Xn[i];
    8696:	5d13      	ldrb	r3, [r2, r4]
    8698:	550b      	strb	r3, [r1, r4]

			for (i = 0; i < aad_len; i++, j++) {
				pmsg[i] = Xn[i] ^ aad[j];
			}

			for (i = aad_len; i < 16; i++) {
    869a:	3401      	adds	r4, #1
    869c:	b2e4      	uxtb	r4, r4
    869e:	e7f6      	b.n	868e <mesh_aes_ccm+0x3ae>
				pmsg[i] = Xn[i];
			}

			mesh_aes_encrypt(key, pmsg, Xn);
    86a0:	9802      	ldr	r0, [sp, #8]
    86a2:	f7ff fb9b 	bl	7ddc <mesh_aes_encrypt>
		}

		last_blk = msg_len % 16;
    86a6:	270f      	movs	r7, #15
    86a8:	9b03      	ldr	r3, [sp, #12]
    86aa:	401f      	ands	r7, r3
		blk_cnt = (msg_len + 15) / 16;
    86ac:	330f      	adds	r3, #15
    86ae:	111b      	asrs	r3, r3, #4
    86b0:	9308      	str	r3, [sp, #32]
    86b2:	466b      	mov	r3, sp
    86b4:	8c1b      	ldrh	r3, [r3, #32]
    86b6:	9309      	str	r3, [sp, #36]	; 0x24
		if (!last_blk) {
    86b8:	2f00      	cmp	r7, #0
    86ba:	d100      	bne.n	86be <mesh_aes_ccm+0x3de>
			last_blk = 16U;
    86bc:	3710      	adds	r7, #16
		}
	
		for (j = 0; j < blk_cnt; j++) {
    86be:	2500      	movs	r5, #0
    86c0:	9b09      	ldr	r3, [sp, #36]	; 0x24
    86c2:	b2ac      	uxth	r4, r5
    86c4:	42a3      	cmp	r3, r4
    86c6:	d800      	bhi.n	86ca <mesh_aes_ccm+0x3ea>
    86c8:	e088      	b.n	87dc <mesh_aes_ccm+0x4fc>
			if (j + 1 == blk_cnt) {
    86ca:	9a08      	ldr	r2, [sp, #32]
    86cc:	1c6b      	adds	r3, r5, #1
    86ce:	ae0c      	add	r6, sp, #48	; 0x30
    86d0:	3401      	adds	r4, #1
    86d2:	429a      	cmp	r2, r3
    86d4:	d14d      	bne.n	8772 <mesh_aes_ccm+0x492>
				/* C_1 = e(AppKey, 0x01 || nonce || 0x0001) */
				pmsg[0] = 0x01;
    86d6:	2301      	movs	r3, #1
    86d8:	7033      	strb	r3, [r6, #0]
				memcpy(pmsg + 1, nonce, 13);
    86da:	2309      	movs	r3, #9
    86dc:	a80a      	add	r0, sp, #40	; 0x28
    86de:	181b      	adds	r3, r3, r0
    86e0:	220d      	movs	r2, #13
    86e2:	9904      	ldr	r1, [sp, #16]
    86e4:	0018      	movs	r0, r3
				sys_put_be16(j + 1, pmsg + 14);
    86e6:	b2a4      	uxth	r4, r4
	
		for (j = 0; j < blk_cnt; j++) {
			if (j + 1 == blk_cnt) {
				/* C_1 = e(AppKey, 0x01 || nonce || 0x0001) */
				pmsg[0] = 0x01;
				memcpy(pmsg + 1, nonce, 13);
    86e8:	f00d f972 	bl	159d0 <memcpy>
}

#define AUTHENTICATION_DOMAIN 
static inline void sys_put_be16(uint16_t val, uint8_t dst[2])
{
	dst[0] = val >> 8;
    86ec:	0a23      	lsrs	r3, r4, #8
    86ee:	73b3      	strb	r3, [r6, #14]
				/* C_1 = e(AppKey, 0x01 || nonce || 0x0001) */
				pmsg[0] = 0x01;
				memcpy(pmsg + 1, nonce, 13);
				sys_put_be16(j + 1, pmsg + 14);

				mesh_aes_encrypt(key, pmsg, cmsg);
    86f0:	9802      	ldr	r0, [sp, #8]

#define AUTHENTICATION_DOMAIN 
static inline void sys_put_be16(uint16_t val, uint8_t dst[2])
{
	dst[0] = val >> 8;
	dst[1] = val;
    86f2:	73f4      	strb	r4, [r6, #15]
				/* C_1 = e(AppKey, 0x01 || nonce || 0x0001) */
				pmsg[0] = 0x01;
				memcpy(pmsg + 1, nonce, 13);
				sys_put_be16(j + 1, pmsg + 14);

				mesh_aes_encrypt(key, pmsg, cmsg);
    86f4:	aa14      	add	r2, sp, #80	; 0x50
    86f6:	0031      	movs	r1, r6
    86f8:	f7ff fb70 	bl	7ddc <mesh_aes_encrypt>

				/* Encrypted = Payload[0-15] ^ C_1 */
				for (i = 0; i < last_blk; i++) {
    86fc:	2300      	movs	r3, #0
    86fe:	0128      	lsls	r0, r5, #4
    8700:	a920      	add	r1, sp, #128	; 0x80
    8702:	429f      	cmp	r7, r3
    8704:	d909      	bls.n	871a <mesh_aes_ccm+0x43a>
					msg1[i] = enc_msg[(j * 16) + i] ^ cmsg[i];
    8706:	9a06      	ldr	r2, [sp, #24]
    8708:	1812      	adds	r2, r2, r0
    870a:	5cd4      	ldrb	r4, [r2, r3]
    870c:	aa14      	add	r2, sp, #80	; 0x50
    870e:	5cd2      	ldrb	r2, [r2, r3]
    8710:	4062      	eors	r2, r4
    8712:	54ca      	strb	r2, [r1, r3]
				sys_put_be16(j + 1, pmsg + 14);

				mesh_aes_encrypt(key, pmsg, cmsg);

				/* Encrypted = Payload[0-15] ^ C_1 */
				for (i = 0; i < last_blk; i++) {
    8714:	3301      	adds	r3, #1
    8716:	b2db      	uxtb	r3, r3
    8718:	e7f2      	b.n	8700 <mesh_aes_ccm+0x420>
					msg1[i] = enc_msg[(j * 16) + i] ^ cmsg[i];
				}

				memcpy(out_msg + (j * 16), msg1, last_blk);
    871a:	9b05      	ldr	r3, [sp, #20]
    871c:	0128      	lsls	r0, r5, #4
    871e:	1818      	adds	r0, r3, r0
    8720:	003a      	movs	r2, r7
    8722:	f00d f955 	bl	159d0 <memcpy>

				/* X_1 = e(AppKey, X_0 ^ Payload[0-15]) */
				for (i = 0; i < last_blk; i++) {
    8726:	2300      	movs	r3, #0
    8728:	429f      	cmp	r7, r3
    872a:	d909      	bls.n	8740 <mesh_aes_ccm+0x460>
					pmsg[i] = Xn[i] ^ msg1[i];
    872c:	aa18      	add	r2, sp, #96	; 0x60
    872e:	5cd1      	ldrb	r1, [r2, r3]
    8730:	aa20      	add	r2, sp, #128	; 0x80
    8732:	5cd2      	ldrb	r2, [r2, r3]
    8734:	404a      	eors	r2, r1
    8736:	a90c      	add	r1, sp, #48	; 0x30
    8738:	54ca      	strb	r2, [r1, r3]
				}

				memcpy(out_msg + (j * 16), msg1, last_blk);

				/* X_1 = e(AppKey, X_0 ^ Payload[0-15]) */
				for (i = 0; i < last_blk; i++) {
    873a:	3301      	adds	r3, #1
    873c:	b2db      	uxtb	r3, r3
    873e:	e7f3      	b.n	8728 <mesh_aes_ccm+0x448>
					pmsg[i] = Xn[i] ^ msg1[i];
				}

				for (i = last_blk; i < 16; i++) {
    8740:	b2fb      	uxtb	r3, r7
    8742:	a90c      	add	r1, sp, #48	; 0x30
    8744:	aa18      	add	r2, sp, #96	; 0x60
    8746:	2b10      	cmp	r3, #16
    8748:	d004      	beq.n	8754 <mesh_aes_ccm+0x474>
					pmsg[i] = Xn[i] ^ 0x00;
    874a:	5cd2      	ldrb	r2, [r2, r3]
    874c:	54ca      	strb	r2, [r1, r3]
				/* X_1 = e(AppKey, X_0 ^ Payload[0-15]) */
				for (i = 0; i < last_blk; i++) {
					pmsg[i] = Xn[i] ^ msg1[i];
				}

				for (i = last_blk; i < 16; i++) {
    874e:	3301      	adds	r3, #1
    8750:	b2db      	uxtb	r3, r3
    8752:	e7f6      	b.n	8742 <mesh_aes_ccm+0x462>
					pmsg[i] = Xn[i] ^ 0x00;
				}

				 mesh_aes_encrypt(key, pmsg, Xn);
    8754:	9802      	ldr	r0, [sp, #8]
    8756:	f7ff fb41 	bl	7ddc <mesh_aes_encrypt>
    875a:	2300      	movs	r3, #0

				/* MIC = C_mic ^ X_1 */
				for (i = 0; i < sizeof(mic); i++) {
					mic[i] = cmic[i] ^ Xn[i];
    875c:	aa10      	add	r2, sp, #64	; 0x40
    875e:	5c99      	ldrb	r1, [r3, r2]
    8760:	aa18      	add	r2, sp, #96	; 0x60
    8762:	5c9a      	ldrb	r2, [r3, r2]
    8764:	404a      	eors	r2, r1
    8766:	a91c      	add	r1, sp, #112	; 0x70
    8768:	545a      	strb	r2, [r3, r1]
    876a:	3301      	adds	r3, #1
				}

				 mesh_aes_encrypt(key, pmsg, Xn);

				/* MIC = C_mic ^ X_1 */
				for (i = 0; i < sizeof(mic); i++) {
    876c:	2b10      	cmp	r3, #16
    876e:	d1f5      	bne.n	875c <mesh_aes_ccm+0x47c>
    8770:	e031      	b.n	87d6 <mesh_aes_ccm+0x4f6>
					mic[i] = cmic[i] ^ Xn[i];
				}
			} 
			else {
				/* C_1 = e(AppKey, 0x01 || nonce || 0x0001) */
				pmsg[0] = 0x01;
    8772:	2301      	movs	r3, #1
    8774:	7033      	strb	r3, [r6, #0]
				memcpy(pmsg + 1, nonce, 13);
    8776:	2309      	movs	r3, #9
    8778:	a80a      	add	r0, sp, #40	; 0x28
    877a:	181b      	adds	r3, r3, r0
    877c:	220d      	movs	r2, #13
    877e:	9904      	ldr	r1, [sp, #16]
    8780:	0018      	movs	r0, r3
				sys_put_be16(j + 1, pmsg + 14);
    8782:	b2a4      	uxth	r4, r4
				}
			} 
			else {
				/* C_1 = e(AppKey, 0x01 || nonce || 0x0001) */
				pmsg[0] = 0x01;
				memcpy(pmsg + 1, nonce, 13);
    8784:	f00d f924 	bl	159d0 <memcpy>
}

#define AUTHENTICATION_DOMAIN 
static inline void sys_put_be16(uint16_t val, uint8_t dst[2])
{
	dst[0] = val >> 8;
    8788:	0a23      	lsrs	r3, r4, #8
				/* C_1 = e(AppKey, 0x01 || nonce || 0x0001) */
				pmsg[0] = 0x01;
				memcpy(pmsg + 1, nonce, 13);
				sys_put_be16(j + 1, pmsg + 14);

				mesh_aes_encrypt(key, pmsg, cmsg);
    878a:	aa14      	add	r2, sp, #80	; 0x50
    878c:	9802      	ldr	r0, [sp, #8]
}

#define AUTHENTICATION_DOMAIN 
static inline void sys_put_be16(uint16_t val, uint8_t dst[2])
{
	dst[0] = val >> 8;
    878e:	73b3      	strb	r3, [r6, #14]
	dst[1] = val;
    8790:	73f4      	strb	r4, [r6, #15]
				/* C_1 = e(AppKey, 0x01 || nonce || 0x0001) */
				pmsg[0] = 0x01;
				memcpy(pmsg + 1, nonce, 13);
				sys_put_be16(j + 1, pmsg + 14);

				mesh_aes_encrypt(key, pmsg, cmsg);
    8792:	0031      	movs	r1, r6
    8794:	f7ff fb22 	bl	7ddc <mesh_aes_encrypt>

				/* Encrypted = Payload[0-15] ^ C_1 */
				for (i = 0; i < 16; i++) {
					msg1[i] = enc_msg[(j * 16) + i] ^ cmsg[i];
    8798:	2200      	movs	r2, #0
    879a:	0128      	lsls	r0, r5, #4
    879c:	9b06      	ldr	r3, [sp, #24]
    879e:	a920      	add	r1, sp, #128	; 0x80
    87a0:	181b      	adds	r3, r3, r0
    87a2:	5c9c      	ldrb	r4, [r3, r2]
    87a4:	ab14      	add	r3, sp, #80	; 0x50
    87a6:	5cd3      	ldrb	r3, [r2, r3]
    87a8:	4063      	eors	r3, r4
    87aa:	5453      	strb	r3, [r2, r1]
    87ac:	3201      	adds	r2, #1
				sys_put_be16(j + 1, pmsg + 14);

				mesh_aes_encrypt(key, pmsg, cmsg);

				/* Encrypted = Payload[0-15] ^ C_1 */
				for (i = 0; i < 16; i++) {
    87ae:	2a10      	cmp	r2, #16
    87b0:	d1f4      	bne.n	879c <mesh_aes_ccm+0x4bc>
					msg1[i] = enc_msg[(j * 16) + i] ^ cmsg[i];
				}

				memcpy(out_msg + (j * 16), msg1, 16);
    87b2:	9b05      	ldr	r3, [sp, #20]
    87b4:	1818      	adds	r0, r3, r0
    87b6:	f00d f90b 	bl	159d0 <memcpy>
    87ba:	2300      	movs	r3, #0
	
				/* X_1 = e(AppKey, X_0 ^ Payload[0-15]) */
				for (i = 0; i < 16; i++) {
					pmsg[i] = Xn[i] ^ msg1[i];
    87bc:	aa18      	add	r2, sp, #96	; 0x60
    87be:	a820      	add	r0, sp, #128	; 0x80
    87c0:	5c9c      	ldrb	r4, [r3, r2]
    87c2:	5c18      	ldrb	r0, [r3, r0]
    87c4:	a90c      	add	r1, sp, #48	; 0x30
    87c6:	4060      	eors	r0, r4
    87c8:	5458      	strb	r0, [r3, r1]
    87ca:	3301      	adds	r3, #1
				}

				memcpy(out_msg + (j * 16), msg1, 16);
	
				/* X_1 = e(AppKey, X_0 ^ Payload[0-15]) */
				for (i = 0; i < 16; i++) {
    87cc:	2b10      	cmp	r3, #16
    87ce:	d1f5      	bne.n	87bc <mesh_aes_ccm+0x4dc>
					pmsg[i] = Xn[i] ^ msg1[i];
				}

				mesh_aes_encrypt(key, pmsg, Xn);
    87d0:	9802      	ldr	r0, [sp, #8]
    87d2:	f7ff fb03 	bl	7ddc <mesh_aes_encrypt>
		blk_cnt = (msg_len + 15) / 16;
		if (!last_blk) {
			last_blk = 16U;
		}
	
		for (j = 0; j < blk_cnt; j++) {
    87d6:	3501      	adds	r5, #1
    87d8:	b2ed      	uxtb	r5, r5
    87da:	e771      	b.n	86c0 <mesh_aes_ccm+0x3e0>

				mesh_aes_encrypt(key, pmsg, Xn);

			}
		}
		if(memcmp(mic, enc_msg + msg_len, mic_size) == 0){
    87dc:	9a03      	ldr	r2, [sp, #12]
    87de:	9b06      	ldr	r3, [sp, #24]
    87e0:	4694      	mov	ip, r2
    87e2:	4463      	add	r3, ip
    87e4:	0019      	movs	r1, r3
    87e6:	9a07      	ldr	r2, [sp, #28]
    87e8:	a81c      	add	r0, sp, #112	; 0x70
    87ea:	f00d f8c9 	bl	15980 <memcmp>
    87ee:	1e04      	subs	r4, r0, #0
    87f0:	d10b      	bne.n	880a <mesh_aes_ccm+0x52a>
			//TODO: the returned value could be adjusted
			m_printf_hex(L_AL, "ccm decrypt success", out_message, msg_len);
    87f2:	4916      	ldr	r1, [pc, #88]	; (884c <mesh_aes_ccm+0x56c>)
    87f4:	9b03      	ldr	r3, [sp, #12]
    87f6:	9a05      	ldr	r2, [sp, #20]
    87f8:	315d      	adds	r1, #93	; 0x5d
    87fa:	2001      	movs	r0, #1
    87fc:	f7fc f936 	bl	4a6c <m_printf_hex>
			res_cb(0, src_info); //first 0 indicate no MIC error. 
    8800:	9930      	ldr	r1, [sp, #192]	; 0xc0
    8802:	0020      	movs	r0, r4
    8804:	9b2f      	ldr	r3, [sp, #188]	; 0xbc
    8806:	4798      	blx	r3
    8808:	e01d      	b.n	8846 <mesh_aes_ccm+0x566>
		}
		else{
			M_PRINTF(L_AL, "ccm decrypt error");
    880a:	4b11      	ldr	r3, [pc, #68]	; (8850 <mesh_aes_ccm+0x570>)
    880c:	681b      	ldr	r3, [r3, #0]
    880e:	07db      	lsls	r3, r3, #31
    8810:	d515      	bpl.n	883e <mesh_aes_ccm+0x55e>
    8812:	4c10      	ldr	r4, [pc, #64]	; (8854 <mesh_aes_ccm+0x574>)
    8814:	4d0d      	ldr	r5, [pc, #52]	; (884c <mesh_aes_ccm+0x56c>)
    8816:	0023      	movs	r3, r4
    8818:	002a      	movs	r2, r5
    881a:	0020      	movs	r0, r4
    881c:	331d      	adds	r3, #29
    881e:	0029      	movs	r1, r5
    8820:	3284      	adds	r2, #132	; 0x84
    8822:	9300      	str	r3, [sp, #0]
    8824:	300e      	adds	r0, #14
    8826:	4b0c      	ldr	r3, [pc, #48]	; (8858 <mesh_aes_ccm+0x578>)
    8828:	f7fc f8c0 	bl	49ac <m_print>
    882c:	0020      	movs	r0, r4
    882e:	302a      	adds	r0, #42	; 0x2a
    8830:	f7fc f8bc 	bl	49ac <m_print>
    8834:	0020      	movs	r0, r4
    8836:	1da9      	adds	r1, r5, #6
    8838:	303c      	adds	r0, #60	; 0x3c
    883a:	f7fc f8b7 	bl	49ac <m_print>
			res_cb(1, src_info); //first para 1, indicate MIC error observed
    883e:	9930      	ldr	r1, [sp, #192]	; 0xc0
    8840:	2001      	movs	r0, #1
    8842:	9b2f      	ldr	r3, [sp, #188]	; 0xbc
    8844:	4798      	blx	r3
		}
		

	}
}
    8846:	b025      	add	sp, #148	; 0x94
    8848:	bdf0      	pop	{r4, r5, r6, r7, pc}
    884a:	46c0      	nop			; (mov r8, r8)
    884c:	00021051 	.word	0x00021051
    8850:	10010514 	.word	0x10010514
    8854:	000210d1 	.word	0x000210d1
    8858:	00000273 	.word	0x00000273

0000885c <ecdh_key_deal>:
   ECDH_SECRET_OK
};
ecdh_key_t* ecdh_key_data = NULL;

uint8_t ecdh_key_deal(uint8_t destory)
{
    885c:	b570      	push	{r4, r5, r6, lr}
    885e:	1e04      	subs	r4, r0, #0
	if(destory){//destory
    8860:	d002      	beq.n	8868 <ecdh_key_deal+0xc>
    8862:	f000 f8e7 	bl	8a34 <ecdh_key_deal.part.0>
    8866:	e018      	b.n	889a <ecdh_key_deal+0x3e>
		mesh_flash_write(CONFIG_ECDH_KEY_ADDR, sizeof(ecdh_key_t), (uint8_t*)ecdh_key_data);
		ke_free(ecdh_key_data);
		ecdh_key_data = NULL;
		return ECDH_NONE;	
	}
	ecdh_key_data = ke_malloc(sizeof(ecdh_key_t), 0);
    8868:	0001      	movs	r1, r0
    886a:	20c2      	movs	r0, #194	; 0xc2
    886c:	f7fe fd38 	bl	72e0 <ke_malloc>
    8870:	4d0a      	ldr	r5, [pc, #40]	; (889c <ecdh_key_deal+0x40>)
    8872:	0002      	movs	r2, r0
    8874:	6028      	str	r0, [r5, #0]
	mesh_flash_read(CONFIG_ECDH_KEY_ADDR, sizeof(ecdh_key_t), (uint8_t*)ecdh_key_data);
    8876:	21c2      	movs	r1, #194	; 0xc2
    8878:	4809      	ldr	r0, [pc, #36]	; (88a0 <ecdh_key_deal+0x44>)
    887a:	f7ff f9a5 	bl	7bc8 <mesh_flash_read>
	if(ecdh_key_data->crc != bc_sys_check_sum((uint8_t * )ecdh_key_data, sizeof(ecdh_key_t)-1))
    887e:	682b      	ldr	r3, [r5, #0]
    8880:	21c1      	movs	r1, #193	; 0xc1
    8882:	33c1      	adds	r3, #193	; 0xc1
    8884:	6828      	ldr	r0, [r5, #0]
    8886:	781e      	ldrb	r6, [r3, #0]
    8888:	f7f9 ff00 	bl	268c <bc_sys_check_sum>
    888c:	0003      	movs	r3, r0
		return ECDH_NONE;
    888e:	0020      	movs	r0, r4
		ecdh_key_data = NULL;
		return ECDH_NONE;	
	}
	ecdh_key_data = ke_malloc(sizeof(ecdh_key_t), 0);
	mesh_flash_read(CONFIG_ECDH_KEY_ADDR, sizeof(ecdh_key_t), (uint8_t*)ecdh_key_data);
	if(ecdh_key_data->crc != bc_sys_check_sum((uint8_t * )ecdh_key_data, sizeof(ecdh_key_t)-1))
    8890:	429e      	cmp	r6, r3
    8892:	d102      	bne.n	889a <ecdh_key_deal+0x3e>
		return ECDH_NONE;
	return ecdh_key_data->status;
    8894:	682b      	ldr	r3, [r5, #0]
    8896:	33c0      	adds	r3, #192	; 0xc0
    8898:	7818      	ldrb	r0, [r3, #0]
}
    889a:	bd70      	pop	{r4, r5, r6, pc}
    889c:	1001127c 	.word	0x1001127c
    88a0:	0007d100 	.word	0x0007d100

000088a4 <mesh_pub_key_read>:

void mesh_pub_key_read(bool renew, mesh_sec_pub_key_res_cb res_cb)
{
	M_PRINTF(L_AL, "renew = %d", renew);
    88a4:	4b25      	ldr	r3, [pc, #148]	; (893c <mesh_pub_key_read+0x98>)
		return ECDH_NONE;
	return ecdh_key_data->status;
}

void mesh_pub_key_read(bool renew, mesh_sec_pub_key_res_cb res_cb)
{
    88a6:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	M_PRINTF(L_AL, "renew = %d", renew);
    88a8:	681b      	ldr	r3, [r3, #0]
		return ECDH_NONE;
	return ecdh_key_data->status;
}

void mesh_pub_key_read(bool renew, mesh_sec_pub_key_res_cb res_cb)
{
    88aa:	0007      	movs	r7, r0
    88ac:	000e      	movs	r6, r1
    88ae:	4c24      	ldr	r4, [pc, #144]	; (8940 <mesh_pub_key_read+0x9c>)
	M_PRINTF(L_AL, "renew = %d", renew);
    88b0:	07db      	lsls	r3, r3, #31
    88b2:	d515      	bpl.n	88e0 <mesh_pub_key_read+0x3c>
    88b4:	4d23      	ldr	r5, [pc, #140]	; (8944 <mesh_pub_key_read+0xa0>)
    88b6:	0023      	movs	r3, r4
    88b8:	002a      	movs	r2, r5
    88ba:	0020      	movs	r0, r4
    88bc:	333f      	adds	r3, #63	; 0x3f
    88be:	3284      	adds	r2, #132	; 0x84
    88c0:	9300      	str	r3, [sp, #0]
    88c2:	0029      	movs	r1, r5
    88c4:	4b20      	ldr	r3, [pc, #128]	; (8948 <mesh_pub_key_read+0xa4>)
    88c6:	300e      	adds	r0, #14
    88c8:	f7fc f870 	bl	49ac <m_print>
    88cc:	0020      	movs	r0, r4
    88ce:	0039      	movs	r1, r7
    88d0:	3051      	adds	r0, #81	; 0x51
    88d2:	f7fc f86b 	bl	49ac <m_print>
    88d6:	0020      	movs	r0, r4
    88d8:	1da9      	adds	r1, r5, #6
    88da:	303c      	adds	r0, #60	; 0x3c
    88dc:	f7fc f866 	bl	49ac <m_print>
	
	if (ECDH_NONE == ecdh_key_deal(0) || renew == true){
    88e0:	2000      	movs	r0, #0
    88e2:	f7ff ffbb 	bl	885c <ecdh_key_deal>
    88e6:	4d19      	ldr	r5, [pc, #100]	; (894c <mesh_pub_key_read+0xa8>)
    88e8:	2800      	cmp	r0, #0
    88ea:	d001      	beq.n	88f0 <mesh_pub_key_read+0x4c>
    88ec:	2f00      	cmp	r7, #0
    88ee:	d008      	beq.n	8902 <mesh_pub_key_read+0x5e>
		ecc_make_key(ecdh_key_data->pubk_x, ecdh_key_data->prik);
    88f0:	6829      	ldr	r1, [r5, #0]
    88f2:	6828      	ldr	r0, [r5, #0]
    88f4:	3140      	adds	r1, #64	; 0x40
    88f6:	f7fe fc31 	bl	715c <ecc_make_key>
		ecdh_key_data->status = ECDH_PRIVATE_OK;
    88fa:	2201      	movs	r2, #1
    88fc:	682b      	ldr	r3, [r5, #0]
    88fe:	33c0      	adds	r3, #192	; 0xc0
    8900:	701a      	strb	r2, [r3, #0]
	}
	
	m_printf_hex(L_AL, "local read pub_key_x", ecdh_key_data->pubk_x, GAP_P256_KEY_LEN);
    8902:	0021      	movs	r1, r4
    8904:	682a      	ldr	r2, [r5, #0]
    8906:	315c      	adds	r1, #92	; 0x5c
    8908:	2320      	movs	r3, #32
    890a:	2001      	movs	r0, #1
    890c:	f7fc f8ae 	bl	4a6c <m_printf_hex>
	m_printf_hex(L_AL, "local read pub_key_y", ecdh_key_data->pubk_y, GAP_P256_KEY_LEN);
    8910:	0021      	movs	r1, r4
    8912:	682a      	ldr	r2, [r5, #0]
    8914:	3171      	adds	r1, #113	; 0x71
    8916:	3220      	adds	r2, #32
    8918:	2320      	movs	r3, #32
    891a:	2001      	movs	r0, #1
    891c:	f7fc f8a6 	bl	4a6c <m_printf_hex>
	m_printf_hex(L_AL, "local read prv_key", ecdh_key_data->prik, GAP_P256_KEY_LEN);
    8920:	682a      	ldr	r2, [r5, #0]
    8922:	490b      	ldr	r1, [pc, #44]	; (8950 <mesh_pub_key_read+0xac>)
    8924:	2320      	movs	r3, #32
    8926:	3240      	adds	r2, #64	; 0x40
    8928:	3106      	adds	r1, #6
    892a:	2001      	movs	r0, #1
    892c:	f7fc f89e 	bl	4a6c <m_printf_hex>
	
	res_cb(0, ecdh_key_data->pubk_x, ecdh_key_data->pubk_y);
    8930:	6829      	ldr	r1, [r5, #0]
    8932:	2000      	movs	r0, #0
    8934:	000a      	movs	r2, r1
    8936:	3220      	adds	r2, #32
    8938:	47b0      	blx	r6
}
    893a:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
    893c:	10010514 	.word	0x10010514
    8940:	000210d1 	.word	0x000210d1
    8944:	00021051 	.word	0x00021051
    8948:	0000029e 	.word	0x0000029e
    894c:	1001127c 	.word	0x1001127c
    8950:	00021151 	.word	0x00021151

00008954 <mesh_ecdh_secret>:

void mesh_ecdh_secret(const uint8_t* p_pub_key_x, const uint8_t* p_pub_key_y, mesh_sec_ecdh_secret_res_cb res_cb)
{	
    8954:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	uint8_t sts = ecdh_key_data->status;
    8956:	4c35      	ldr	r4, [pc, #212]	; (8a2c <mesh_ecdh_secret+0xd8>)
	
	res_cb(0, ecdh_key_data->pubk_x, ecdh_key_data->pubk_y);
}

void mesh_ecdh_secret(const uint8_t* p_pub_key_x, const uint8_t* p_pub_key_y, mesh_sec_ecdh_secret_res_cb res_cb)
{	
    8958:	9000      	str	r0, [sp, #0]
	uint8_t sts = ecdh_key_data->status;
    895a:	6825      	ldr	r5, [r4, #0]
	
	res_cb(0, ecdh_key_data->pubk_x, ecdh_key_data->pubk_y);
}

void mesh_ecdh_secret(const uint8_t* p_pub_key_x, const uint8_t* p_pub_key_y, mesh_sec_ecdh_secret_res_cb res_cb)
{	
    895c:	9101      	str	r1, [sp, #4]
	uint8_t sts = ecdh_key_data->status;
    895e:	002b      	movs	r3, r5
    8960:	33c0      	adds	r3, #192	; 0xc0
    8962:	781b      	ldrb	r3, [r3, #0]
	
	res_cb(0, ecdh_key_data->pubk_x, ecdh_key_data->pubk_y);
}

void mesh_ecdh_secret(const uint8_t* p_pub_key_x, const uint8_t* p_pub_key_y, mesh_sec_ecdh_secret_res_cb res_cb)
{	
    8964:	0016      	movs	r6, r2
	uint8_t sts = ecdh_key_data->status;
	if(ecdh_key_data == NULL){
		sts = ecdh_key_deal(0);
	}
	if(sts == ECDH_NONE){
    8966:	2b00      	cmp	r3, #0
    8968:	d05e      	beq.n	8a28 <mesh_ecdh_secret+0xd4>
    896a:	002f      	movs	r7, r5
    896c:	3760      	adds	r7, #96	; 0x60
		return;
	}
	
	if(sts == ECDH_SECRET_OK){
    896e:	2b02      	cmp	r3, #2
    8970:	d114      	bne.n	899c <mesh_ecdh_secret+0x48>
		if(0 == memcmp(p_pub_key_x, ecdh_key_data->peerk_x, GAP_P256_KEY_LEN)
    8972:	2220      	movs	r2, #32
    8974:	0039      	movs	r1, r7
    8976:	f00d f803 	bl	15980 <memcmp>
    897a:	2800      	cmp	r0, #0
    897c:	d10e      	bne.n	899c <mesh_ecdh_secret+0x48>
			&& 0 == memcmp(p_pub_key_y, ecdh_key_data->peerk_y, GAP_P256_KEY_LEN)){
    897e:	0029      	movs	r1, r5
    8980:	2220      	movs	r2, #32
    8982:	3180      	adds	r1, #128	; 0x80
    8984:	9801      	ldr	r0, [sp, #4]
    8986:	f00c fffb 	bl	15980 <memcmp>
    898a:	2800      	cmp	r0, #0
    898c:	d106      	bne.n	899c <mesh_ecdh_secret+0x48>
			ASSERT_ERR(res_cb != NULL);
    898e:	2e00      	cmp	r6, #0
    8990:	d100      	bne.n	8994 <mesh_ecdh_secret+0x40>
    8992:	e7fe      	b.n	8992 <mesh_ecdh_secret+0x3e>
			res_cb(0, ecdh_key_data->secret);
    8994:	0029      	movs	r1, r5
    8996:	31a0      	adds	r1, #160	; 0xa0
    8998:	47b0      	blx	r6
			return;
    899a:	e045      	b.n	8a28 <mesh_ecdh_secret+0xd4>
		}
			
	}

	memcpy(ecdh_key_data->peerk_x, p_pub_key_x, GAP_P256_KEY_LEN);
    899c:	2220      	movs	r2, #32
    899e:	9900      	ldr	r1, [sp, #0]
    89a0:	0038      	movs	r0, r7
    89a2:	f00d f815 	bl	159d0 <memcpy>
	memcpy(ecdh_key_data->peerk_y, p_pub_key_y, GAP_P256_KEY_LEN);
    89a6:	0028      	movs	r0, r5
    89a8:	2220      	movs	r2, #32
    89aa:	9901      	ldr	r1, [sp, #4]
    89ac:	3080      	adds	r0, #128	; 0x80
    89ae:	f00d f80f 	bl	159d0 <memcpy>
	m_printf_hex(L_AL, "ecdh_secret p_pub_key_x",ecdh_key_data->peerk_x, GAP_P256_KEY_LEN);
    89b2:	4d1f      	ldr	r5, [pc, #124]	; (8a30 <mesh_ecdh_secret+0xdc>)
    89b4:	003a      	movs	r2, r7
    89b6:	0029      	movs	r1, r5
    89b8:	2320      	movs	r3, #32
    89ba:	3119      	adds	r1, #25
    89bc:	2001      	movs	r0, #1
    89be:	f7fc f855 	bl	4a6c <m_printf_hex>
	m_printf_hex(L_AL, "ecdh_secret p_pub_key_y",ecdh_key_data->peerk_y, GAP_P256_KEY_LEN);
    89c2:	0029      	movs	r1, r5
    89c4:	6822      	ldr	r2, [r4, #0]
    89c6:	3131      	adds	r1, #49	; 0x31
    89c8:	3280      	adds	r2, #128	; 0x80
    89ca:	2320      	movs	r3, #32
    89cc:	2001      	movs	r0, #1
    89ce:	f7fc f84d 	bl	4a6c <m_printf_hex>
	m_printf_hex(L_AL, "ecdh_secret prv_key",ecdh_key_data->prik, GAP_P256_KEY_LEN);
    89d2:	0029      	movs	r1, r5
    89d4:	6822      	ldr	r2, [r4, #0]
    89d6:	2320      	movs	r3, #32
    89d8:	3240      	adds	r2, #64	; 0x40
    89da:	3149      	adds	r1, #73	; 0x49
    89dc:	2001      	movs	r0, #1
    89de:	f7fc f845 	bl	4a6c <m_printf_hex>

	bool res = ecdh_shared_secret(ecdh_key_data->peerk_x, ecdh_key_data->prik, ecdh_key_data->secret);
    89e2:	6820      	ldr	r0, [r4, #0]
    89e4:	0002      	movs	r2, r0
    89e6:	0001      	movs	r1, r0
    89e8:	32a0      	adds	r2, #160	; 0xa0
    89ea:	3140      	adds	r1, #64	; 0x40
    89ec:	3060      	adds	r0, #96	; 0x60
    89ee:	f7fe fbdf 	bl	71b0 <ecdh_shared_secret>

	m_printf_hex(L_AL, "ecdh_secret res",ecdh_key_data->secret, GAP_P256_KEY_LEN);
    89f2:	0029      	movs	r1, r5
    89f4:	6822      	ldr	r2, [r4, #0]
	memcpy(ecdh_key_data->peerk_y, p_pub_key_y, GAP_P256_KEY_LEN);
	m_printf_hex(L_AL, "ecdh_secret p_pub_key_x",ecdh_key_data->peerk_x, GAP_P256_KEY_LEN);
	m_printf_hex(L_AL, "ecdh_secret p_pub_key_y",ecdh_key_data->peerk_y, GAP_P256_KEY_LEN);
	m_printf_hex(L_AL, "ecdh_secret prv_key",ecdh_key_data->prik, GAP_P256_KEY_LEN);

	bool res = ecdh_shared_secret(ecdh_key_data->peerk_x, ecdh_key_data->prik, ecdh_key_data->secret);
    89f6:	0007      	movs	r7, r0

	m_printf_hex(L_AL, "ecdh_secret res",ecdh_key_data->secret, GAP_P256_KEY_LEN);
    89f8:	32a0      	adds	r2, #160	; 0xa0
    89fa:	315d      	adds	r1, #93	; 0x5d
    89fc:	2320      	movs	r3, #32
    89fe:	2001      	movs	r0, #1
    8a00:	f7fc f834 	bl	4a6c <m_printf_hex>
	
	
	ASSERT_ERR(res_cb != NULL);
    8a04:	2e00      	cmp	r6, #0
    8a06:	d100      	bne.n	8a0a <mesh_ecdh_secret+0xb6>
    8a08:	e7fe      	b.n	8a08 <mesh_ecdh_secret+0xb4>
	if(res == true){
		res_cb(0, ecdh_key_data->secret);
    8a0a:	6821      	ldr	r1, [r4, #0]
    8a0c:	31a0      	adds	r1, #160	; 0xa0

	m_printf_hex(L_AL, "ecdh_secret res",ecdh_key_data->secret, GAP_P256_KEY_LEN);
	
	
	ASSERT_ERR(res_cb != NULL);
	if(res == true){
    8a0e:	2f00      	cmp	r7, #0
    8a10:	d002      	beq.n	8a18 <mesh_ecdh_secret+0xc4>
		res_cb(0, ecdh_key_data->secret);
    8a12:	2000      	movs	r0, #0
    8a14:	47b0      	blx	r6
    8a16:	e001      	b.n	8a1c <mesh_ecdh_secret+0xc8>
	}
	else{
		res_cb(1, ecdh_key_data->secret);
    8a18:	2001      	movs	r0, #1
    8a1a:	47b0      	blx	r6
	}
	//destory buffer
	ecdh_key_data->status = ECDH_SECRET_OK;
    8a1c:	2202      	movs	r2, #2
    8a1e:	6823      	ldr	r3, [r4, #0]
    8a20:	33c0      	adds	r3, #192	; 0xc0
    8a22:	701a      	strb	r2, [r3, #0]
    8a24:	f000 f806 	bl	8a34 <ecdh_key_deal.part.0>
	ecdh_key_deal(1);
}
    8a28:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
    8a2a:	46c0      	nop			; (mov r8, r8)
    8a2c:	1001127c 	.word	0x1001127c
    8a30:	00021151 	.word	0x00021151

00008a34 <ecdh_key_deal.part.0>:
   ECDH_PRIVATE_OK,
   ECDH_SECRET_OK
};
ecdh_key_t* ecdh_key_data = NULL;

uint8_t ecdh_key_deal(uint8_t destory)
    8a34:	b570      	push	{r4, r5, r6, lr}
{
	if(destory){//destory
		ecdh_key_data->crc = bc_sys_check_sum((uint8_t * )ecdh_key_data, sizeof(ecdh_key_t)-1);
    8a36:	4c09      	ldr	r4, [pc, #36]	; (8a5c <ecdh_key_deal.part.0+0x28>)
    8a38:	21c1      	movs	r1, #193	; 0xc1
    8a3a:	6825      	ldr	r5, [r4, #0]
    8a3c:	0028      	movs	r0, r5
    8a3e:	f7f9 fe25 	bl	268c <bc_sys_check_sum>
    8a42:	35c1      	adds	r5, #193	; 0xc1
    8a44:	7028      	strb	r0, [r5, #0]
		mesh_flash_write(CONFIG_ECDH_KEY_ADDR, sizeof(ecdh_key_t), (uint8_t*)ecdh_key_data);
    8a46:	6822      	ldr	r2, [r4, #0]
    8a48:	21c2      	movs	r1, #194	; 0xc2
    8a4a:	4805      	ldr	r0, [pc, #20]	; (8a60 <ecdh_key_deal.part.0+0x2c>)
    8a4c:	f7ff f8fa 	bl	7c44 <mesh_flash_write>
		ke_free(ecdh_key_data);
    8a50:	6820      	ldr	r0, [r4, #0]
    8a52:	f7fe fc49 	bl	72e8 <ke_free>
		ecdh_key_data = NULL;
    8a56:	2000      	movs	r0, #0
    8a58:	6020      	str	r0, [r4, #0]
	ecdh_key_data = ke_malloc(sizeof(ecdh_key_t), 0);
	mesh_flash_read(CONFIG_ECDH_KEY_ADDR, sizeof(ecdh_key_t), (uint8_t*)ecdh_key_data);
	if(ecdh_key_data->crc != bc_sys_check_sum((uint8_t * )ecdh_key_data, sizeof(ecdh_key_t)-1))
		return ECDH_NONE;
	return ecdh_key_data->status;
}
    8a5a:	bd70      	pop	{r4, r5, r6, pc}
    8a5c:	1001127c 	.word	0x1001127c
    8a60:	0007d100 	.word	0x0007d100

00008a64 <pvPortMalloc>:
static size_t xBlockAllocatedBit = 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    8a64:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
#define ASSERT_WARN(cond, param0, param1) {while(!(cond));}
#endif

__INLINE_S__ void GLOBAL_INT_DISABLE(void )
{
	__asm volatile ("cpsid i" : : : "memory");
    8a66:	b672      	cpsid	i

	vTaskSuspendAll();
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( pxEnd == NULL )
    8a68:	4c37      	ldr	r4, [pc, #220]	; (8b48 <pvPortMalloc+0xe4>)
    8a6a:	68a3      	ldr	r3, [r4, #8]
    8a6c:	2b00      	cmp	r3, #0
    8a6e:	d11f      	bne.n	8ab0 <pvPortMalloc+0x4c>
uint8_t *pucAlignedHeap;
size_t uxAddress;
size_t xTotalHeapSize = configTOTAL_HEAP_SIZE;

	/* Ensure the heap starts on a correctly aligned boundary. */
	uxAddress = ( size_t ) ucHeap;
    8a70:	4a36      	ldr	r2, [pc, #216]	; (8b4c <pvPortMalloc+0xe8>)

	if( ( uxAddress & portBYTE_ALIGNMENT_MASK ) != 0 )
    8a72:	3303      	adds	r3, #3
    8a74:	421a      	tst	r2, r3
    8a76:	d007      	beq.n	8a88 <pvPortMalloc+0x24>
	{
		uxAddress += ( portBYTE_ALIGNMENT - 1 );
    8a78:	18d1      	adds	r1, r2, r3
		uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
    8a7a:	4399      	bics	r1, r3
		xTotalHeapSize -= uxAddress - ( size_t ) ucHeap;
    8a7c:	23a0      	movs	r3, #160	; 0xa0
    8a7e:	015b      	lsls	r3, r3, #5
    8a80:	18d3      	adds	r3, r2, r3
    8a82:	1a5b      	subs	r3, r3, r1
	uxAddress = ( size_t ) ucHeap;

	if( ( uxAddress & portBYTE_ALIGNMENT_MASK ) != 0 )
	{
		uxAddress += ( portBYTE_ALIGNMENT - 1 );
		uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
    8a84:	000a      	movs	r2, r1
    8a86:	e001      	b.n	8a8c <pvPortMalloc+0x28>
static void prvHeapInit( void )
{
BlockLink_t *pxFirstFreeBlock;
uint8_t *pucAlignedHeap;
size_t uxAddress;
size_t xTotalHeapSize = configTOTAL_HEAP_SIZE;
    8a88:	23a0      	movs	r3, #160	; 0xa0
    8a8a:	015b      	lsls	r3, r3, #5

	/* pxEnd is used to mark the end of the list of free blocks and is inserted
	at the end of the heap space. */
	uxAddress = ( ( size_t ) pucAlignedHeap ) + xTotalHeapSize;
	uxAddress -= xHeapStructSize;
	uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
    8a8c:	2503      	movs	r5, #3
	pucAlignedHeap = ( uint8_t * ) uxAddress;

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
	xStart.xBlockSize = ( size_t ) 0;
    8a8e:	2100      	movs	r1, #0

	/* pxEnd is used to mark the end of the list of free blocks and is inserted
	at the end of the heap space. */
	uxAddress = ( ( size_t ) pucAlignedHeap ) + xTotalHeapSize;
    8a90:	18d3      	adds	r3, r2, r3
	uxAddress -= xHeapStructSize;
    8a92:	3b08      	subs	r3, #8
	uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
    8a94:	43ab      	bics	r3, r5
	pucAlignedHeap = ( uint8_t * ) uxAddress;

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
	xStart.xBlockSize = ( size_t ) 0;
    8a96:	6061      	str	r1, [r4, #4]

	pucAlignedHeap = ( uint8_t * ) uxAddress;

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
    8a98:	6022      	str	r2, [r4, #0]
	at the end of the heap space. */
	uxAddress = ( ( size_t ) pucAlignedHeap ) + xTotalHeapSize;
	uxAddress -= xHeapStructSize;
	uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
	pxEnd = ( void * ) uxAddress;
	pxEnd->xBlockSize = 0;
    8a9a:	6059      	str	r1, [r3, #4]
	pxEnd->pxNextFreeBlock = NULL;
    8a9c:	6019      	str	r1, [r3, #0]
	/* pxEnd is used to mark the end of the list of free blocks and is inserted
	at the end of the heap space. */
	uxAddress = ( ( size_t ) pucAlignedHeap ) + xTotalHeapSize;
	uxAddress -= xHeapStructSize;
	uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
	pxEnd = ( void * ) uxAddress;
    8a9e:	60a3      	str	r3, [r4, #8]
	pxEnd->pxNextFreeBlock = NULL;

	/* To start with there is a single free block that is sized to take up the
	entire heap space, minus the space taken by pxEnd. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
	pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
    8aa0:	1a99      	subs	r1, r3, r2
	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
    8aa2:	6013      	str	r3, [r2, #0]
	/* Only one block exists - and it covers the entire usable heap space. */
	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;

	/* Work out the position of the top bit in a size_t variable. */
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
    8aa4:	2380      	movs	r3, #128	; 0x80
    8aa6:	061b      	lsls	r3, r3, #24
	pxEnd->pxNextFreeBlock = NULL;

	/* To start with there is a single free block that is sized to take up the
	entire heap space, minus the space taken by pxEnd. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
	pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
    8aa8:	6051      	str	r1, [r2, #4]
	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;

	/* Only one block exists - and it covers the entire usable heap space. */
	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
    8aaa:	6121      	str	r1, [r4, #16]
	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
    8aac:	60e1      	str	r1, [r4, #12]

	/* Work out the position of the top bit in a size_t variable. */
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
    8aae:	6163      	str	r3, [r4, #20]
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
void *pvReturn = NULL;
    8ab0:	2600      	movs	r6, #0

		/* Check the requested block size is not so large that the top bit is
		set.  The top bit of the block size member of the BlockLink_t structure
		is used to determine who owns the block - the application or the
		kernel, so it must be free. */
		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
    8ab2:	6963      	ldr	r3, [r4, #20]
    8ab4:	9301      	str	r3, [sp, #4]
    8ab6:	4003      	ands	r3, r0
    8ab8:	42b3      	cmp	r3, r6
    8aba:	d13b      	bne.n	8b34 <pvPortMalloc+0xd0>
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
void *pvReturn = NULL;
    8abc:	001e      	movs	r6, r3
		kernel, so it must be free. */
		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
		{
			/* The wanted size is increased so it can contain a BlockLink_t
			structure in addition to the requested amount of bytes. */
			if( xWantedSize > 0 )
    8abe:	2800      	cmp	r0, #0
    8ac0:	d038      	beq.n	8b34 <pvPortMalloc+0xd0>
			{
				xWantedSize += xHeapStructSize;
    8ac2:	0003      	movs	r3, r0

				/* Ensure that blocks are always aligned to the required number
				of bytes. */
				if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )
    8ac4:	2203      	movs	r2, #3
		{
			/* The wanted size is increased so it can contain a BlockLink_t
			structure in addition to the requested amount of bytes. */
			if( xWantedSize > 0 )
			{
				xWantedSize += xHeapStructSize;
    8ac6:	3308      	adds	r3, #8

				/* Ensure that blocks are always aligned to the required number
				of bytes. */
				if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )
    8ac8:	4213      	tst	r3, r2
    8aca:	d001      	beq.n	8ad0 <pvPortMalloc+0x6c>
				{
					/* Byte alignment required. */
					xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
    8acc:	4393      	bics	r3, r2
    8ace:	3304      	adds	r3, #4
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
void *pvReturn = NULL;
    8ad0:	2600      	movs	r6, #0
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
    8ad2:	42b3      	cmp	r3, r6
    8ad4:	d02e      	beq.n	8b34 <pvPortMalloc+0xd0>
    8ad6:	68e7      	ldr	r7, [r4, #12]
    8ad8:	42bb      	cmp	r3, r7
    8ada:	d82b      	bhi.n	8b34 <pvPortMalloc+0xd0>
			{
				/* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
    8adc:	0021      	movs	r1, r4
				pxBlock = xStart.pxNextFreeBlock;
    8ade:	6825      	ldr	r5, [r4, #0]
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
    8ae0:	686a      	ldr	r2, [r5, #4]
    8ae2:	4293      	cmp	r3, r2
    8ae4:	d804      	bhi.n	8af0 <pvPortMalloc+0x8c>
					pxBlock = pxBlock->pxNextFreeBlock;
				}

				/* If the end marker was reached then a block of adequate size
				was	not found. */
				if( pxBlock != pxEnd )
    8ae6:	68a0      	ldr	r0, [r4, #8]
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
void *pvReturn = NULL;
    8ae8:	2600      	movs	r6, #0
					pxBlock = pxBlock->pxNextFreeBlock;
				}

				/* If the end marker was reached then a block of adequate size
				was	not found. */
				if( pxBlock != pxEnd )
    8aea:	4285      	cmp	r5, r0
    8aec:	d106      	bne.n	8afc <pvPortMalloc+0x98>
    8aee:	e021      	b.n	8b34 <pvPortMalloc+0xd0>
			{
				/* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
				pxBlock = xStart.pxNextFreeBlock;
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
    8af0:	6828      	ldr	r0, [r5, #0]
    8af2:	2800      	cmp	r0, #0
    8af4:	d0f7      	beq.n	8ae6 <pvPortMalloc+0x82>
    8af6:	0029      	movs	r1, r5
    8af8:	0005      	movs	r5, r0
    8afa:	e7f1      	b.n	8ae0 <pvPortMalloc+0x7c>
				was	not found. */
				if( pxBlock != pxEnd )
				{
					/* Return the memory space pointed to - jumping over the
					BlockLink_t structure at its start. */
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
    8afc:	680e      	ldr	r6, [r1, #0]

					/* This block is being returned for use so must be taken out
					of the list of free blocks. */
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
    8afe:	6828      	ldr	r0, [r5, #0]
				was	not found. */
				if( pxBlock != pxEnd )
				{
					/* Return the memory space pointed to - jumping over the
					BlockLink_t structure at its start. */
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
    8b00:	3608      	adds	r6, #8

					/* This block is being returned for use so must be taken out
					of the list of free blocks. */
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
    8b02:	6008      	str	r0, [r1, #0]

					/* If the block is larger than required it can be split into
					two. */
					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
    8b04:	1ad2      	subs	r2, r2, r3
    8b06:	2a10      	cmp	r2, #16
    8b08:	d908      	bls.n	8b1c <pvPortMalloc+0xb8>
						/* This block is to be split into two.  Create a new
						block following the number of bytes requested. The void
						cast is used to prevent byte alignment warnings from the
						compiler. */
						pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
						configASSERT( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );
    8b0a:	2103      	movs	r1, #3
					{
						/* This block is to be split into two.  Create a new
						block following the number of bytes requested. The void
						cast is used to prevent byte alignment warnings from the
						compiler. */
						pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
    8b0c:	18e8      	adds	r0, r5, r3
						configASSERT( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );
    8b0e:	4001      	ands	r1, r0
    8b10:	2900      	cmp	r1, #0
    8b12:	d1fd      	bne.n	8b10 <pvPortMalloc+0xac>

						/* Calculate the sizes of two blocks split from the
						single block. */
						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
    8b14:	6042      	str	r2, [r0, #4]
						pxBlock->xBlockSize = xWantedSize;
    8b16:	606b      	str	r3, [r5, #4]

						/* Insert the new block into the list of free blocks. */
						prvInsertBlockIntoFreeList( pxNewBlockLink );
    8b18:	f000 f841 	bl	8b9e <prvInsertBlockIntoFreeList>
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					xFreeBytesRemaining -= pxBlock->xBlockSize;
    8b1c:	686b      	ldr	r3, [r5, #4]

					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
    8b1e:	6922      	ldr	r2, [r4, #16]
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					xFreeBytesRemaining -= pxBlock->xBlockSize;
    8b20:	1aff      	subs	r7, r7, r3
    8b22:	60e7      	str	r7, [r4, #12]

					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
    8b24:	4297      	cmp	r7, r2
    8b26:	d200      	bcs.n	8b2a <pvPortMalloc+0xc6>
					{
						xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
    8b28:	6127      	str	r7, [r4, #16]
						mtCOVERAGE_TEST_MARKER();
					}

					/* The block is being returned - it is allocated and owned
					by the application and has no "next" block. */
					pxBlock->xBlockSize |= xBlockAllocatedBit;
    8b2a:	9a01      	ldr	r2, [sp, #4]
    8b2c:	431a      	orrs	r2, r3
					pxBlock->pxNextFreeBlock = NULL;
    8b2e:	2300      	movs	r3, #0
						mtCOVERAGE_TEST_MARKER();
					}

					/* The block is being returned - it is allocated and owned
					by the application and has no "next" block. */
					pxBlock->xBlockSize |= xBlockAllocatedBit;
    8b30:	606a      	str	r2, [r5, #4]
					pxBlock->pxNextFreeBlock = NULL;
    8b32:	602b      	str	r3, [r5, #0]
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		traceMALLOC( pvReturn, xWantedSize );
    8b34:	2e00      	cmp	r6, #0
    8b36:	d100      	bne.n	8b3a <pvPortMalloc+0xd6>
    8b38:	e7fe      	b.n	8b38 <pvPortMalloc+0xd4>
}

__INLINE_S__ void GLOBAL_INT_RESTORE(void)
{
	__asm volatile ("cpsie i" : : : "memory");
    8b3a:	b662      	cpsie	i
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif

	configASSERT( ( ( ( size_t ) pvReturn ) & ( size_t ) portBYTE_ALIGNMENT_MASK ) == 0 );
    8b3c:	2303      	movs	r3, #3
    8b3e:	4033      	ands	r3, r6
    8b40:	2b00      	cmp	r3, #0
    8b42:	d1fd      	bne.n	8b40 <pvPortMalloc+0xdc>
	return pvReturn;
}
    8b44:	0030      	movs	r0, r6
    8b46:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
    8b48:	10012680 	.word	0x10012680
    8b4c:	10011280 	.word	0x10011280

00008b50 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    8b50:	b510      	push	{r4, lr}
uint8_t *puc = ( uint8_t * ) pv;
BlockLink_t *pxLink;

	if( pv != NULL )
    8b52:	2800      	cmp	r0, #0
    8b54:	d013      	beq.n	8b7e <vPortFree+0x2e>

		/* This casting is to keep the compiler from issuing warnings. */
		pxLink = ( void * ) puc;

		/* Check the block is actually allocated. */
		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
    8b56:	4b0a      	ldr	r3, [pc, #40]	; (8b80 <vPortFree+0x30>)

	if( pv != NULL )
	{
		/* The memory being freed will have an BlockLink_t structure immediately
		before it. */
		puc -= xHeapStructSize;
    8b58:	3808      	subs	r0, #8

		/* This casting is to keep the compiler from issuing warnings. */
		pxLink = ( void * ) puc;

		/* Check the block is actually allocated. */
		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
    8b5a:	6842      	ldr	r2, [r0, #4]
    8b5c:	6959      	ldr	r1, [r3, #20]
    8b5e:	4211      	tst	r1, r2
    8b60:	d100      	bne.n	8b64 <vPortFree+0x14>
    8b62:	e7fe      	b.n	8b62 <vPortFree+0x12>
		configASSERT( pxLink->pxNextFreeBlock == NULL );
    8b64:	6804      	ldr	r4, [r0, #0]
    8b66:	2c00      	cmp	r4, #0
    8b68:	d1fd      	bne.n	8b66 <vPortFree+0x16>
		{
			if( pxLink->pxNextFreeBlock == NULL )
			{
				/* The block is being returned to the heap - it is no longer
				allocated. */
				pxLink->xBlockSize &= ~xBlockAllocatedBit;
    8b6a:	438a      	bics	r2, r1
    8b6c:	6042      	str	r2, [r0, #4]
#define ASSERT_WARN(cond, param0, param1) {while(!(cond));}
#endif

__INLINE_S__ void GLOBAL_INT_DISABLE(void )
{
	__asm volatile ("cpsid i" : : : "memory");
    8b6e:	b672      	cpsid	i

				vTaskSuspendAll();
				{
					/* Add this block to the list of free blocks. */
					xFreeBytesRemaining += pxLink->xBlockSize;
    8b70:	68d9      	ldr	r1, [r3, #12]
    8b72:	6842      	ldr	r2, [r0, #4]
    8b74:	1852      	adds	r2, r2, r1
    8b76:	60da      	str	r2, [r3, #12]
					traceFREE( pv, pxLink->xBlockSize );
					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
    8b78:	f000 f811 	bl	8b9e <prvInsertBlockIntoFreeList>
}

__INLINE_S__ void GLOBAL_INT_RESTORE(void)
{
	__asm volatile ("cpsie i" : : : "memory");
    8b7c:	b662      	cpsie	i
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
}
    8b7e:	bd10      	pop	{r4, pc}
    8b80:	10012680 	.word	0x10012680

00008b84 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return xFreeBytesRemaining;
    8b84:	4b01      	ldr	r3, [pc, #4]	; (8b8c <xPortGetFreeHeapSize+0x8>)
    8b86:	68d8      	ldr	r0, [r3, #12]
}
    8b88:	4770      	bx	lr
    8b8a:	46c0      	nop			; (mov r8, r8)
    8b8c:	10012680 	.word	0x10012680

00008b90 <xPortGetMinimumEverFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetMinimumEverFreeHeapSize( void )
{
	return xMinimumEverFreeBytesRemaining;
    8b90:	4b01      	ldr	r3, [pc, #4]	; (8b98 <xPortGetMinimumEverFreeHeapSize+0x8>)
    8b92:	6918      	ldr	r0, [r3, #16]
}
    8b94:	4770      	bx	lr
    8b96:	46c0      	nop			; (mov r8, r8)
    8b98:	10012680 	.word	0x10012680

00008b9c <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
	/* This just exists to keep the linker quiet. */
}
    8b9c:	4770      	bx	lr

00008b9e <prvInsertBlockIntoFreeList>:
BlockLink_t *pxIterator;
uint8_t *puc;

	/* Iterate through the list until a block is found that has a higher address
	than the block being inserted. */
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
    8b9e:	4b11      	ldr	r3, [pc, #68]	; (8be4 <prvInsertBlockIntoFreeList+0x46>)
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
}
/*-----------------------------------------------------------*/

static void prvInsertBlockIntoFreeList( BlockLink_t *pxBlockToInsert )
{
    8ba0:	b530      	push	{r4, r5, lr}
    8ba2:	001c      	movs	r4, r3
BlockLink_t *pxIterator;
uint8_t *puc;

	/* Iterate through the list until a block is found that has a higher address
	than the block being inserted. */
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
    8ba4:	681a      	ldr	r2, [r3, #0]
    8ba6:	4282      	cmp	r2, r0
    8ba8:	d201      	bcs.n	8bae <prvInsertBlockIntoFreeList+0x10>
    8baa:	0013      	movs	r3, r2
    8bac:	e7fa      	b.n	8ba4 <prvInsertBlockIntoFreeList+0x6>
	}

	/* Do the block being inserted, and the block it is being inserted after
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxIterator;
	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
    8bae:	6859      	ldr	r1, [r3, #4]
    8bb0:	185d      	adds	r5, r3, r1
    8bb2:	42a8      	cmp	r0, r5
    8bb4:	d103      	bne.n	8bbe <prvInsertBlockIntoFreeList+0x20>
	{
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
    8bb6:	6840      	ldr	r0, [r0, #4]
    8bb8:	1841      	adds	r1, r0, r1
    8bba:	0018      	movs	r0, r3
    8bbc:	6059      	str	r1, [r3, #4]
	}

	/* Do the block being inserted, and the block it is being inserted before
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxBlockToInsert;
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
    8bbe:	6841      	ldr	r1, [r0, #4]
    8bc0:	1845      	adds	r5, r0, r1
    8bc2:	42aa      	cmp	r2, r5
    8bc4:	d108      	bne.n	8bd8 <prvInsertBlockIntoFreeList+0x3a>
	{
		if( pxIterator->pxNextFreeBlock != pxEnd )
    8bc6:	68a4      	ldr	r4, [r4, #8]
    8bc8:	42a2      	cmp	r2, r4
    8bca:	d005      	beq.n	8bd8 <prvInsertBlockIntoFreeList+0x3a>
		{
			/* Form one big block from the two blocks. */
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
    8bcc:	6854      	ldr	r4, [r2, #4]
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
    8bce:	6812      	ldr	r2, [r2, #0]
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
	{
		if( pxIterator->pxNextFreeBlock != pxEnd )
		{
			/* Form one big block from the two blocks. */
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
    8bd0:	1861      	adds	r1, r4, r1
    8bd2:	6041      	str	r1, [r0, #4]
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
    8bd4:	6002      	str	r2, [r0, #0]
    8bd6:	e000      	b.n	8bda <prvInsertBlockIntoFreeList+0x3c>
			pxBlockToInsert->pxNextFreeBlock = pxEnd;
		}
	}
	else
	{
		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
    8bd8:	6002      	str	r2, [r0, #0]

	/* If the block being inserted plugged a gab, so was merged with the block
	before and the block after, then it's pxNextFreeBlock pointer will have
	already been set, and should not be set here as that would make it point
	to itself. */
	if( pxIterator != pxBlockToInsert )
    8bda:	4298      	cmp	r0, r3
    8bdc:	d000      	beq.n	8be0 <prvInsertBlockIntoFreeList+0x42>
	{
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
    8bde:	6018      	str	r0, [r3, #0]
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
    8be0:	bd30      	pop	{r4, r5, pc}
    8be2:	46c0      	nop			; (mov r8, r8)
    8be4:	10012680 	.word	0x10012680

00008be8 <m_api_bearer_operation_open_cb>:
 ****************************************************************************************
 */

__STATIC void m_api_bearer_operation_open_cb(uint16_t status)
{
	M_PRINTF(L_APP,"");
    8be8:	4b27      	ldr	r3, [pc, #156]	; (8c88 <m_api_bearer_operation_open_cb+0xa0>)
 * STATIC FUNCTIONS
 ****************************************************************************************
 */

__STATIC void m_api_bearer_operation_open_cb(uint16_t status)
{
    8bea:	b573      	push	{r0, r1, r4, r5, r6, lr}
	M_PRINTF(L_APP,"");
    8bec:	681a      	ldr	r2, [r3, #0]
 * STATIC FUNCTIONS
 ****************************************************************************************
 */

__STATIC void m_api_bearer_operation_open_cb(uint16_t status)
{
    8bee:	0005      	movs	r5, r0
    8bf0:	001e      	movs	r6, r3
	M_PRINTF(L_APP,"");
    8bf2:	0493      	lsls	r3, r2, #18
    8bf4:	d514      	bpl.n	8c20 <m_api_bearer_operation_open_cb+0x38>
    8bf6:	4c25      	ldr	r4, [pc, #148]	; (8c8c <m_api_bearer_operation_open_cb+0xa4>)
    8bf8:	0023      	movs	r3, r4
    8bfa:	0022      	movs	r2, r4
    8bfc:	0020      	movs	r0, r4
    8bfe:	3332      	adds	r3, #50	; 0x32
    8c00:	0021      	movs	r1, r4
    8c02:	321b      	adds	r2, #27
    8c04:	9300      	str	r3, [sp, #0]
    8c06:	3023      	adds	r0, #35	; 0x23
    8c08:	2334      	movs	r3, #52	; 0x34
    8c0a:	f7fb fecf 	bl	49ac <m_print>
    8c0e:	0020      	movs	r0, r4
    8c10:	3051      	adds	r0, #81	; 0x51
    8c12:	f7fb fecb 	bl	49ac <m_print>
    8c16:	0020      	movs	r0, r4
    8c18:	1da1      	adds	r1, r4, #6
    8c1a:	3052      	adds	r0, #82	; 0x52
    8c1c:	f7fb fec6 	bl	49ac <m_print>
    do{
        if (status == M_ERR_NO_ERROR){
    8c20:	2d00      	cmp	r5, #0
    8c22:	d120      	bne.n	8c66 <m_api_bearer_operation_open_cb+0x7e>
            if (m_tb_state_get_prov_state() == M_TB_STATE_PROV_STATE_UNPROV){
    8c24:	f00b fbd0 	bl	143c8 <m_tb_state_get_prov_state>
    8c28:	2800      	cmp	r0, #0
    8c2a:	d126      	bne.n	8c7a <m_api_bearer_operation_open_cb+0x92>
                // Start provisioning
                M_PRINTF(L_APP,"Start provisioning");
    8c2c:	6833      	ldr	r3, [r6, #0]
    8c2e:	049b      	lsls	r3, r3, #18
    8c30:	d514      	bpl.n	8c5c <m_api_bearer_operation_open_cb+0x74>
    8c32:	4c16      	ldr	r4, [pc, #88]	; (8c8c <m_api_bearer_operation_open_cb+0xa4>)
    8c34:	0023      	movs	r3, r4
    8c36:	0022      	movs	r2, r4
    8c38:	0020      	movs	r0, r4
    8c3a:	3332      	adds	r3, #50	; 0x32
    8c3c:	0021      	movs	r1, r4
    8c3e:	321b      	adds	r2, #27
    8c40:	9300      	str	r3, [sp, #0]
    8c42:	3023      	adds	r0, #35	; 0x23
    8c44:	2339      	movs	r3, #57	; 0x39
    8c46:	f7fb feb1 	bl	49ac <m_print>
    8c4a:	0020      	movs	r0, r4
    8c4c:	3055      	adds	r0, #85	; 0x55
    8c4e:	f7fb fead 	bl	49ac <m_print>
    8c52:	0020      	movs	r0, r4
    8c54:	1da1      	adds	r1, r4, #6
    8c56:	3052      	adds	r0, #82	; 0x52
    8c58:	f7fb fea8 	bl	49ac <m_print>
                status = m_prov_start();
    8c5c:	f007 f970 	bl	ff40 <m_prov_start>

                if (status == M_ERR_NO_ERROR){
    8c60:	2800      	cmp	r0, #0
    8c62:	d00c      	beq.n	8c7e <m_api_bearer_operation_open_cb+0x96>
    8c64:	0005      	movs	r5, r0

    } while (0);
	if (status == M_ERR_NO_ERROR){
            m_tb_state_set_enabled(true);
	}
	if(p_m_api_cb && p_m_api_cb->cb_enabled)
    8c66:	4b0a      	ldr	r3, [pc, #40]	; (8c90 <m_api_bearer_operation_open_cb+0xa8>)
    8c68:	681b      	ldr	r3, [r3, #0]
    8c6a:	2b00      	cmp	r3, #0
    8c6c:	d00b      	beq.n	8c86 <m_api_bearer_operation_open_cb+0x9e>
    8c6e:	681b      	ldr	r3, [r3, #0]
    8c70:	2b00      	cmp	r3, #0
    8c72:	d008      	beq.n	8c86 <m_api_bearer_operation_open_cb+0x9e>
    	p_m_api_cb->cb_enabled(status);
    8c74:	0028      	movs	r0, r5
    8c76:	4798      	blx	r3
}
    8c78:	e005      	b.n	8c86 <m_api_bearer_operation_open_cb+0x9e>
            }
        }

        if (status == M_ERR_NO_ERROR){
            // update beacon state machine
            m_bcn_state_update();
    8c7a:	f000 ff67 	bl	9b4c <m_bcn_state_update>
        }

    } while (0);
	if (status == M_ERR_NO_ERROR){
            m_tb_state_set_enabled(true);
    8c7e:	2001      	movs	r0, #1
    8c80:	f00b fa2e 	bl	140e0 <m_tb_state_set_enabled>
    8c84:	e7ef      	b.n	8c66 <m_api_bearer_operation_open_cb+0x7e>
	}
	if(p_m_api_cb && p_m_api_cb->cb_enabled)
    	p_m_api_cb->cb_enabled(status);
}
    8c86:	bd73      	pop	{r0, r1, r4, r5, r6, pc}
    8c88:	10010514 	.word	0x10010514
    8c8c:	000211c4 	.word	0x000211c4
    8c90:	10012698 	.word	0x10012698

00008c94 <m_api_bearer_operation_close_cb>:

__STATIC void m_api_bearer_operation_close_cb(uint16_t status)
{
    8c94:	b510      	push	{r4, lr}
    8c96:	1e04      	subs	r4, r0, #0
    if (status == M_ERR_NO_ERROR)
    8c98:	d101      	bne.n	8c9e <m_api_bearer_operation_close_cb+0xa>
    {
        m_tb_state_set_enabled(false);
    8c9a:	f00b fa21 	bl	140e0 <m_tb_state_set_enabled>
    }
	if(p_m_api_cb && p_m_api_cb->cb_disabled)
    8c9e:	4b05      	ldr	r3, [pc, #20]	; (8cb4 <m_api_bearer_operation_close_cb+0x20>)
    8ca0:	681b      	ldr	r3, [r3, #0]
    8ca2:	2b00      	cmp	r3, #0
    8ca4:	d004      	beq.n	8cb0 <m_api_bearer_operation_close_cb+0x1c>
    8ca6:	685b      	ldr	r3, [r3, #4]
    8ca8:	2b00      	cmp	r3, #0
    8caa:	d001      	beq.n	8cb0 <m_api_bearer_operation_close_cb+0x1c>
    	p_m_api_cb->cb_disabled(status);
    8cac:	0020      	movs	r0, r4
    8cae:	4798      	blx	r3
}
    8cb0:	bd10      	pop	{r4, pc}
    8cb2:	46c0      	nop			; (mov r8, r8)
    8cb4:	10012698 	.word	0x10012698

00008cb8 <m_api_stored_info_load_cb>:

__STATIC void m_api_stored_info_load_cb(uint16_t status)
{
	if(p_m_api_cb && p_m_api_cb->cb_loaded)
    8cb8:	4b04      	ldr	r3, [pc, #16]	; (8ccc <m_api_stored_info_load_cb+0x14>)
	if(p_m_api_cb && p_m_api_cb->cb_disabled)
    	p_m_api_cb->cb_disabled(status);
}

__STATIC void m_api_stored_info_load_cb(uint16_t status)
{
    8cba:	b510      	push	{r4, lr}
	if(p_m_api_cb && p_m_api_cb->cb_loaded)
    8cbc:	681b      	ldr	r3, [r3, #0]
    8cbe:	2b00      	cmp	r3, #0
    8cc0:	d003      	beq.n	8cca <m_api_stored_info_load_cb+0x12>
    8cc2:	699b      	ldr	r3, [r3, #24]
    8cc4:	2b00      	cmp	r3, #0
    8cc6:	d000      	beq.n	8cca <m_api_stored_info_load_cb+0x12>
   		p_m_api_cb->cb_loaded(status);
    8cc8:	4798      	blx	r3
}
    8cca:	bd10      	pop	{r4, pc}
    8ccc:	10012698 	.word	0x10012698

00008cd0 <bc_m_set>:
uint16_t bc_m_set(const m_api_cb_t* p_cb_api)
{
    uint16_t status = M_ERR_INVALID_PARAM;

    // Sanity check to ensure that all callbacks are configured
    if(   (p_cb_api->cb_release != NULL)
    8cd0:	6943      	ldr	r3, [r0, #20]
    8cd2:	2b00      	cmp	r3, #0
    8cd4:	d008      	beq.n	8ce8 <bc_m_set+0x18>
       && (p_cb_api->cb_prov_state != NULL) && (p_cb_api->cb_prov_param_req != NULL)
    8cd6:	6883      	ldr	r3, [r0, #8]
    8cd8:	2b00      	cmp	r3, #0
    8cda:	d005      	beq.n	8ce8 <bc_m_set+0x18>
    8cdc:	68c3      	ldr	r3, [r0, #12]
    8cde:	2b00      	cmp	r3, #0
    8ce0:	d002      	beq.n	8ce8 <bc_m_set+0x18>
       && (p_cb_api->cb_prov_auth_req != NULL))
    8ce2:	6903      	ldr	r3, [r0, #16]
    8ce4:	2b00      	cmp	r3, #0
    8ce6:	d100      	bne.n	8cea <bc_m_set+0x1a>
    8ce8:	e7fe      	b.n	8ce8 <bc_m_set+0x18>
    {
        p_m_api_cb = p_cb_api;
    8cea:	4b02      	ldr	r3, [pc, #8]	; (8cf4 <bc_m_set+0x24>)
    8cec:	6018      	str	r0, [r3, #0]
    {
        ASSERT_ERR(0);
    }

    return (status);
}
    8cee:	2000      	movs	r0, #0
    8cf0:	4770      	bx	lr
    8cf2:	46c0      	nop			; (mov r8, r8)
    8cf4:	10012698 	.word	0x10012698

00008cf8 <bc_m_enable>:

uint16_t bc_m_enable(void)
{
    uint16_t status = M_ERR_COMMAND_DISALLOWED;

    if ((p_m_api_cb != NULL) && !m_tb_state_is_enabled())
    8cf8:	4b08      	ldr	r3, [pc, #32]	; (8d1c <bc_m_enable+0x24>)

    return (status);
}

uint16_t bc_m_enable(void)
{
    8cfa:	b510      	push	{r4, lr}
    uint16_t status = M_ERR_COMMAND_DISALLOWED;

    if ((p_m_api_cb != NULL) && !m_tb_state_is_enabled())
    8cfc:	681b      	ldr	r3, [r3, #0]
    8cfe:	2b00      	cmp	r3, #0
    8d00:	d101      	bne.n	8d06 <bc_m_enable+0xe>
    return (status);
}

uint16_t bc_m_enable(void)
{
    uint16_t status = M_ERR_COMMAND_DISALLOWED;
    8d02:	4807      	ldr	r0, [pc, #28]	; (8d20 <bc_m_enable+0x28>)
    8d04:	e008      	b.n	8d18 <bc_m_enable+0x20>

    if ((p_m_api_cb != NULL) && !m_tb_state_is_enabled())
    8d06:	f00b fbe9 	bl	144dc <m_tb_state_is_enabled>
    8d0a:	2800      	cmp	r0, #0
    8d0c:	d1f9      	bne.n	8d02 <bc_m_enable+0xa>
    {
        // Enable bearer layer and return the status
        status = m_bearer_start(M_BEARER_TYPE_ADV, 0, NULL, m_api_bearer_operation_open_cb);
    8d0e:	4b05      	ldr	r3, [pc, #20]	; (8d24 <bc_m_enable+0x2c>)
    8d10:	0002      	movs	r2, r0
    8d12:	0001      	movs	r1, r0
    8d14:	f001 f888 	bl	9e28 <m_bearer_start>
    }

    return (status);
}
    8d18:	bd10      	pop	{r4, pc}
    8d1a:	46c0      	nop			; (mov r8, r8)
    8d1c:	10012698 	.word	0x10012698
    8d20:	00000282 	.word	0x00000282
    8d24:	00008be9 	.word	0x00008be9

00008d28 <bc_m_disable>:

uint16_t bc_m_disable(void)
{
    uint16_t status = M_ERR_COMMAND_DISALLOWED;

    if ((p_m_api_cb != NULL) && m_tb_state_is_enabled())
    8d28:	4b07      	ldr	r3, [pc, #28]	; (8d48 <bc_m_disable+0x20>)

    return (status);
}

uint16_t bc_m_disable(void)
{
    8d2a:	b510      	push	{r4, lr}
    uint16_t status = M_ERR_COMMAND_DISALLOWED;

    if ((p_m_api_cb != NULL) && m_tb_state_is_enabled())
    8d2c:	681b      	ldr	r3, [r3, #0]
    8d2e:	2b00      	cmp	r3, #0
    8d30:	d101      	bne.n	8d36 <bc_m_disable+0xe>
    return (status);
}

uint16_t bc_m_disable(void)
{
    uint16_t status = M_ERR_COMMAND_DISALLOWED;
    8d32:	4806      	ldr	r0, [pc, #24]	; (8d4c <bc_m_disable+0x24>)
    8d34:	e007      	b.n	8d46 <bc_m_disable+0x1e>

    if ((p_m_api_cb != NULL) && m_tb_state_is_enabled())
    8d36:	f00b fbd1 	bl	144dc <m_tb_state_is_enabled>
    8d3a:	2800      	cmp	r0, #0
    8d3c:	d0f9      	beq.n	8d32 <bc_m_disable+0xa>
    {
        // Disable bearer layer and return the status
        status = m_bearer_stop(M_BEARER_TYPE_ADV, m_api_bearer_operation_close_cb);
    8d3e:	4904      	ldr	r1, [pc, #16]	; (8d50 <bc_m_disable+0x28>)
    8d40:	2000      	movs	r0, #0
    8d42:	f001 f8c7 	bl	9ed4 <m_bearer_stop>
    }

    return (status);
}
    8d46:	bd10      	pop	{r4, pc}
    8d48:	10012698 	.word	0x10012698
    8d4c:	00000282 	.word	0x00000282
    8d50:	00008c95 	.word	0x00008c95

00008d54 <bc_m_get_run_time>:

void bc_m_get_run_time(uint32_t *p_clock_ms, uint16_t *p_nb_wrap)
{
    8d54:	b510      	push	{r4, lr}
    // Get clock information
    m_al_timer_get_clock(p_clock_ms, p_nb_wrap);
    8d56:	f7fc fcd5 	bl	5704 <m_al_timer_get_clock>
}
    8d5a:	bd10      	pop	{r4, pc}

00008d5c <bc_m_set_run_time>:

uint16_t bc_m_set_run_time(uint32_t clock_ms, uint16_t nb_wrap)
{
    8d5c:	b570      	push	{r4, r5, r6, lr}
    8d5e:	0005      	movs	r5, r0
    8d60:	000e      	movs	r6, r1
    // Status
    uint16_t status;

    // Reject the command if stack is enabled
    if (m_tb_state_is_enabled())
    8d62:	f00b fbbb 	bl	144dc <m_tb_state_is_enabled>
    8d66:	1e04      	subs	r4, r0, #0
    8d68:	d105      	bne.n	8d76 <bc_m_set_run_time+0x1a>
        status = M_ERR_COMMAND_DISALLOWED;
    }
    else
    {
        // Set run time
        m_al_timer_set_clock(clock_ms, nb_wrap);
    8d6a:	0028      	movs	r0, r5
    8d6c:	0031      	movs	r1, r6
    8d6e:	f7fc fcc1 	bl	56f4 <m_al_timer_set_clock>
        status = M_ERR_NO_ERROR;
    8d72:	0020      	movs	r0, r4
    8d74:	e000      	b.n	8d78 <bc_m_set_run_time+0x1c>
    uint16_t status;

    // Reject the command if stack is enabled
    if (m_tb_state_is_enabled())
    {
        status = M_ERR_COMMAND_DISALLOWED;
    8d76:	4801      	ldr	r0, [pc, #4]	; (8d7c <bc_m_set_run_time+0x20>)
        m_al_timer_set_clock(clock_ms, nb_wrap);
        status = M_ERR_NO_ERROR;
    }

    return (status);
}
    8d78:	bd70      	pop	{r4, r5, r6, pc}
    8d7a:	46c0      	nop			; (mov r8, r8)
    8d7c:	00000282 	.word	0x00000282

00008d80 <bc_m_buf_alloc_block>:

uint16_t bc_m_buf_alloc_block(uint8_t *p_block_id, uint8_t nb_bufs, bool small)
{
    8d80:	b510      	push	{r4, lr}
    return (m_tb_buf_block_alloc(p_block_id, nb_bufs, small));
    8d82:	f008 fb4d 	bl	11420 <m_tb_buf_block_alloc>
}
    8d86:	bd10      	pop	{r4, pc}

00008d88 <bc_m_buf_free_block>:

uint16_t bc_m_buf_free_block(uint8_t block_id)
{
    uint16_t status = M_ERR_COMMAND_DISALLOWED;

    if(p_m_api_cb != NULL)
    8d88:	4b05      	ldr	r3, [pc, #20]	; (8da0 <bc_m_buf_free_block+0x18>)
{
    return (m_tb_buf_block_alloc(p_block_id, nb_bufs, small));
}

uint16_t bc_m_buf_free_block(uint8_t block_id)
{
    8d8a:	b510      	push	{r4, lr}
    uint16_t status = M_ERR_COMMAND_DISALLOWED;

    if(p_m_api_cb != NULL)
    8d8c:	681b      	ldr	r3, [r3, #0]
    8d8e:	2b00      	cmp	r3, #0
    8d90:	d003      	beq.n	8d9a <bc_m_buf_free_block+0x12>
    {
        // Disable network layer and return the status
        status = m_tb_buf_block_free(block_id, p_m_api_cb->cb_release);
    8d92:	6959      	ldr	r1, [r3, #20]
    8d94:	f008 fb98 	bl	114c8 <m_tb_buf_block_free>
    8d98:	e000      	b.n	8d9c <bc_m_buf_free_block+0x14>
    return (m_tb_buf_block_alloc(p_block_id, nb_bufs, small));
}

uint16_t bc_m_buf_free_block(uint8_t block_id)
{
    uint16_t status = M_ERR_COMMAND_DISALLOWED;
    8d9a:	4802      	ldr	r0, [pc, #8]	; (8da4 <bc_m_buf_free_block+0x1c>)
        // Disable network layer and return the status
        status = m_tb_buf_block_free(block_id, p_m_api_cb->cb_release);
    }

    return (status);
}
    8d9c:	bd10      	pop	{r4, pc}
    8d9e:	46c0      	nop			; (mov r8, r8)
    8da0:	10012698 	.word	0x10012698
    8da4:	00000282 	.word	0x00000282

00008da8 <bc_m_buf_alloc>:

uint16_t bc_m_buf_alloc(m_api_buf_t** pp_buf, uint16_t size)
{
    8da8:	b510      	push	{r4, lr}
    8daa:	000a      	movs	r2, r1
    return (m_tb_buf_alloc((m_tb_buf_t **)pp_buf, M_LAY_ACCESS_BUF_HEADER_LEN, size, M_LAY_ACCESS_BUF_TAIL_LEN));
    8dac:	2300      	movs	r3, #0
    8dae:	2103      	movs	r1, #3
    8db0:	f008 fbc2 	bl	11538 <m_tb_buf_alloc>
}
    8db4:	bd10      	pop	{r4, pc}

00008db6 <bc_m_buf_release>:

uint16_t bc_m_buf_release(m_api_buf_t* p_buf)
{
    8db6:	b510      	push	{r4, lr}
    return (m_tb_buf_release((m_tb_buf_t *)p_buf));
    8db8:	f008 fc70 	bl	1169c <m_tb_buf_release>
}
    8dbc:	bd10      	pop	{r4, pc}

00008dbe <bc_m_buf_data_get>:

uint8_t* bc_m_buf_data_get(m_api_buf_t* p_buf)
{
    8dbe:	1e03      	subs	r3, r0, #0
    uint8_t* p_data = NULL;
    if(p_buf != NULL)
    8dc0:	d002      	beq.n	8dc8 <bc_m_buf_data_get+0xa>
    {
        p_data = M_TB_BUF_DATA((m_tb_buf_t *)p_buf);
    8dc2:	889b      	ldrh	r3, [r3, #4]
    8dc4:	3030      	adds	r0, #48	; 0x30
    8dc6:	18c0      	adds	r0, r0, r3
    }

    return (p_data);
}
    8dc8:	4770      	bx	lr

00008dca <bc_m_buf_data_len_get>:

uint16_t bc_m_buf_data_len_get(m_api_buf_t* p_buf)
{
    uint16_t data_len = 0;

    if(p_buf != NULL)
    8dca:	2800      	cmp	r0, #0
    8dcc:	d000      	beq.n	8dd0 <bc_m_buf_data_len_get+0x6>
    {
        data_len = ((m_tb_buf_t *)p_buf)->data_len;
    8dce:	8900      	ldrh	r0, [r0, #8]
    }

    return (data_len);
}
    8dd0:	4770      	bx	lr

00008dd2 <bc_m_model_publish>:

uint16_t bc_m_model_publish(m_lid_t model_lid, uint32_t opcode, uint8_t tx_hdl, m_api_buf_t *p_buf, bool trans_mic_64)
{
    8dd2:	b513      	push	{r0, r1, r4, lr}
    8dd4:	ac04      	add	r4, sp, #16
    8dd6:	7824      	ldrb	r4, [r4, #0]
    // handled by access layer
    return (m_lay_access_publish(model_lid, opcode, tx_hdl, (m_tb_buf_t*) p_buf, trans_mic_64));
    8dd8:	9400      	str	r4, [sp, #0]
    8dda:	f003 fb0f 	bl	c3fc <m_lay_access_publish>
}
    8dde:	bd16      	pop	{r1, r2, r4, pc}

00008de0 <bc_m_model_rsp_send>:

uint16_t bc_m_model_rsp_send(m_lid_t model_lid, uint32_t opcode, uint8_t tx_hdl, m_api_buf_t *p_buf,
                              m_lid_t key_lid, uint16_t dst, bool trans_mic_64, bool not_relay)
{
    8de0:	b5f0      	push	{r4, r5, r6, r7, lr}
    8de2:	b085      	sub	sp, #20
    8de4:	ac0a      	add	r4, sp, #40	; 0x28
    8de6:	ad0b      	add	r5, sp, #44	; 0x2c
    8de8:	ae0c      	add	r6, sp, #48	; 0x30
    8dea:	af0d      	add	r7, sp, #52	; 0x34
    8dec:	7824      	ldrb	r4, [r4, #0]
    8dee:	882d      	ldrh	r5, [r5, #0]
    8df0:	7836      	ldrb	r6, [r6, #0]
    8df2:	783f      	ldrb	r7, [r7, #0]
    // handled by access layer
    return (m_lay_access_rsp_send(model_lid, opcode, tx_hdl, (m_tb_buf_t*) p_buf, key_lid, dst, trans_mic_64, not_relay));
    8df4:	9602      	str	r6, [sp, #8]
    8df6:	9703      	str	r7, [sp, #12]
    8df8:	9501      	str	r5, [sp, #4]
    8dfa:	9400      	str	r4, [sp, #0]
    8dfc:	f003 fb74 	bl	c4e8 <m_lay_access_rsp_send>
}
    8e00:	b005      	add	sp, #20
    8e02:	bdf0      	pop	{r4, r5, r6, r7, pc}

00008e04 <bc_m_model_opcode_status>:

void bc_m_model_opcode_status(m_lid_t model_lid, uint32_t opcode, uint16_t status)
{
    8e04:	b510      	push	{r4, lr}
    // handled by access layer
    m_lay_access_opcode_status(model_lid, opcode, status);
    8e06:	f003 fbd5 	bl	c5b4 <m_lay_access_opcode_status>
}
    8e0a:	bd10      	pop	{r4, pc}

00008e0c <bc_m_register_model>:

uint16_t bc_m_register_model(uint32_t model_id, uint8_t addr_offset, bool vendor,
                             const m_api_model_cb_t *p_cb, m_lid_t *p_model_lid)
{
    8e0c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    8e0e:	0004      	movs	r4, r0
    8e10:	000d      	movs	r5, r1
    8e12:	0016      	movs	r6, r2
    8e14:	001f      	movs	r7, r3
    // Status
    uint16_t status;

    // Reject the command if stack is enabled
    if (m_tb_state_is_enabled())
    8e16:	f00b fb61 	bl	144dc <m_tb_state_is_enabled>
    8e1a:	2800      	cmp	r0, #0
    8e1c:	d108      	bne.n	8e30 <bc_m_register_model+0x24>
        status = M_ERR_COMMAND_DISALLOWED;
    }
    else
    {
        // Register the model instance
        status = m_tb_mio_register_model(model_id, addr_offset, vendor, p_cb, p_model_lid);
    8e1e:	9b08      	ldr	r3, [sp, #32]
    8e20:	0032      	movs	r2, r6
    8e22:	9300      	str	r3, [sp, #0]
    8e24:	0029      	movs	r1, r5
    8e26:	003b      	movs	r3, r7
    8e28:	0020      	movs	r0, r4
    8e2a:	f00a f99c 	bl	13166 <m_tb_mio_register_model>
    8e2e:	e000      	b.n	8e32 <bc_m_register_model+0x26>
    uint16_t status;

    // Reject the command if stack is enabled
    if (m_tb_state_is_enabled())
    {
        status = M_ERR_COMMAND_DISALLOWED;
    8e30:	4800      	ldr	r0, [pc, #0]	; (8e34 <bc_m_register_model+0x28>)
        // Register the model instance
        status = m_tb_mio_register_model(model_id, addr_offset, vendor, p_cb, p_model_lid);
    }

    return (status);
}
    8e32:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
    8e34:	00000282 	.word	0x00000282

00008e38 <bc_m_load_stored_info>:

uint16_t bc_m_load_stored_info(uint16_t length, uint8_t *p_data)
{
    8e38:	b570      	push	{r4, r5, r6, lr}
    8e3a:	0004      	movs	r4, r0
    8e3c:	000d      	movs	r5, r1
    // Status
    uint16_t status;

    // Reject the command if stack is enabled
    if (m_tb_state_is_enabled())
    8e3e:	f00b fb4d 	bl	144dc <m_tb_state_is_enabled>
    8e42:	2800      	cmp	r0, #0
    8e44:	d105      	bne.n	8e52 <bc_m_load_stored_info+0x1a>
        status = M_ERR_COMMAND_DISALLOWED;
    }
    else
    {
        // Store provided information
        status = m_tb_store_load(length, p_data, m_api_stored_info_load_cb);
    8e46:	4a04      	ldr	r2, [pc, #16]	; (8e58 <bc_m_load_stored_info+0x20>)
    8e48:	0029      	movs	r1, r5
    8e4a:	0020      	movs	r0, r4
    8e4c:	f00b fe0c 	bl	14a68 <m_tb_store_load>
    8e50:	e000      	b.n	8e54 <bc_m_load_stored_info+0x1c>
    uint16_t status;

    // Reject the command if stack is enabled
    if (m_tb_state_is_enabled())
    {
        status = M_ERR_COMMAND_DISALLOWED;
    8e52:	4802      	ldr	r0, [pc, #8]	; (8e5c <bc_m_load_stored_info+0x24>)
        // Store provided information
        status = m_tb_store_load(length, p_data, m_api_stored_info_load_cb);
    }

    return (status);
}
    8e54:	bd70      	pop	{r4, r5, r6, pc}
    8e56:	46c0      	nop			; (mov r8, r8)
    8e58:	00008cb9 	.word	0x00008cb9
    8e5c:	00000282 	.word	0x00000282

00008e60 <bc_m_iv_upd_test_mode>:

void bc_m_iv_upd_test_mode(bool update)
{
    8e60:	b510      	push	{r4, lr}
    // Inform the key manager about the request
    m_tb_key_iv_upd_test_mode_ind(update);
    8e62:	f00a f89f 	bl	12fa4 <m_tb_key_iv_upd_test_mode_ind>
}
    8e66:	bd10      	pop	{r4, pc}

00008e68 <m_api_message_handler>:
uint8_t m_api_msg_handler(uint16_t msg_id, uint16_t src_id, const void *p_param);
void m_api_msg_init(void);
#endif // (BLE_MESH_MSG_API)

uint8_t m_api_message_handler(uint16_t msg_id, uint16_t src_id, const void *p_param)
{
    8e68:	b573      	push	{r0, r1, r4, r5, r6, lr}
    8e6a:	0005      	movs	r5, r0
    8e6c:	000e      	movs	r6, r1
    uint8_t msg_status = M_AL_MSG_FREE;

    // Mesh Message API
    if(msg_id < MESH_DBG_CMD)
    8e6e:	2869      	cmp	r0, #105	; 0x69
    8e70:	d81c      	bhi.n	8eac <m_api_message_handler+0x44>
    {
    	M_PRINTF(L_APP, "msg_id[%x] src_id[%x]", msg_id, src_id);
    8e72:	4b0f      	ldr	r3, [pc, #60]	; (8eb0 <m_api_message_handler+0x48>)
    8e74:	681b      	ldr	r3, [r3, #0]
    8e76:	049b      	lsls	r3, r3, #18
    8e78:	d517      	bpl.n	8eaa <m_api_message_handler+0x42>
    8e7a:	4c0e      	ldr	r4, [pc, #56]	; (8eb4 <m_api_message_handler+0x4c>)
    8e7c:	0023      	movs	r3, r4
    8e7e:	3368      	adds	r3, #104	; 0x68
    8e80:	9300      	str	r3, [sp, #0]
    8e82:	0022      	movs	r2, r4
    8e84:	0020      	movs	r0, r4
    8e86:	2332      	movs	r3, #50	; 0x32
    8e88:	321b      	adds	r2, #27
    8e8a:	33ff      	adds	r3, #255	; 0xff
    8e8c:	0021      	movs	r1, r4
    8e8e:	3023      	adds	r0, #35	; 0x23
    8e90:	f7fb fd8c 	bl	49ac <m_print>
    8e94:	0020      	movs	r0, r4
    8e96:	0029      	movs	r1, r5
    8e98:	307e      	adds	r0, #126	; 0x7e
    8e9a:	0032      	movs	r2, r6
    8e9c:	f7fb fd86 	bl	49ac <m_print>
    8ea0:	0020      	movs	r0, r4
    8ea2:	1da1      	adds	r1, r4, #6
    8ea4:	3052      	adds	r0, #82	; 0x52
    8ea6:	f7fb fd81 	bl	49ac <m_print>
    8eaa:	e7fe      	b.n	8eaa <m_api_message_handler+0x42>
    8eac:	e7fe      	b.n	8eac <m_api_message_handler+0x44>
    8eae:	46c0      	nop			; (mov r8, r8)
    8eb0:	10010514 	.word	0x10010514
    8eb4:	000211c4 	.word	0x000211c4

00008eb8 <m_api_get_env_size>:

    return (msg_status);
}

uint16_t m_api_get_env_size(const m_cfg_t* p_cfg)
{
    8eb8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    8eba:	0007      	movs	r7, r0
    uint16_t total_env_size = 0;

    // Retrieve size of environment variable required for following mesh layers
    total_env_size += CO_ALIGN4_HI(m_tb_get_env_size(p_cfg));
    8ebc:	f008 f9c2 	bl	11244 <m_tb_get_env_size>
    8ec0:	0006      	movs	r6, r0
    total_env_size += CO_ALIGN4_HI(m_bearer_get_env_size(p_cfg));
    8ec2:	0038      	movs	r0, r7
    8ec4:	2503      	movs	r5, #3
    8ec6:	f000 ffa5 	bl	9e14 <m_bearer_get_env_size>
    8eca:	3603      	adds	r6, #3
    8ecc:	1940      	adds	r0, r0, r5
    8ece:	43a8      	bics	r0, r5
    8ed0:	43ae      	bics	r6, r5
    8ed2:	1836      	adds	r6, r6, r0
    total_env_size += CO_ALIGN4_HI(m_lay_get_env_size(p_cfg));
    8ed4:	0038      	movs	r0, r7
    8ed6:	f003 f865 	bl	bfa4 <m_lay_get_env_size>
    8eda:	1944      	adds	r4, r0, r5
    total_env_size += CO_ALIGN4_HI(m_prov_get_env_size(p_cfg));
    8edc:	0038      	movs	r0, r7
    8ede:	f007 f82d 	bl	ff3c <m_prov_get_env_size>
    uint16_t total_env_size = 0;

    // Retrieve size of environment variable required for following mesh layers
    total_env_size += CO_ALIGN4_HI(m_tb_get_env_size(p_cfg));
    total_env_size += CO_ALIGN4_HI(m_bearer_get_env_size(p_cfg));
    total_env_size += CO_ALIGN4_HI(m_lay_get_env_size(p_cfg));
    8ee2:	43ac      	bics	r4, r5
{
    uint16_t total_env_size = 0;

    // Retrieve size of environment variable required for following mesh layers
    total_env_size += CO_ALIGN4_HI(m_tb_get_env_size(p_cfg));
    total_env_size += CO_ALIGN4_HI(m_bearer_get_env_size(p_cfg));
    8ee4:	b2b6      	uxth	r6, r6
    total_env_size += CO_ALIGN4_HI(m_lay_get_env_size(p_cfg));
    8ee6:	1936      	adds	r6, r6, r4
    8ee8:	b2b4      	uxth	r4, r6
    total_env_size += CO_ALIGN4_HI(m_prov_get_env_size(p_cfg));
    8eea:	1946      	adds	r6, r0, r5
    total_env_size += CO_ALIGN4_HI(m_fnd_get_env_size(p_cfg));
    8eec:	0038      	movs	r0, r7
    8eee:	f001 fb00 	bl	a4f2 <m_fnd_get_env_size>

    // Retrieve size of environment variable required for following mesh layers
    total_env_size += CO_ALIGN4_HI(m_tb_get_env_size(p_cfg));
    total_env_size += CO_ALIGN4_HI(m_bearer_get_env_size(p_cfg));
    total_env_size += CO_ALIGN4_HI(m_lay_get_env_size(p_cfg));
    total_env_size += CO_ALIGN4_HI(m_prov_get_env_size(p_cfg));
    8ef2:	43ae      	bics	r6, r5
    8ef4:	19a4      	adds	r4, r4, r6
    8ef6:	b2a6      	uxth	r6, r4
    total_env_size += CO_ALIGN4_HI(m_fnd_get_env_size(p_cfg));
    8ef8:	1944      	adds	r4, r0, r5
    total_env_size += CO_ALIGN4_HI(m_bcn_get_env_size(p_cfg));
    8efa:	0038      	movs	r0, r7
    8efc:	f000 fd38 	bl	9970 <m_bcn_get_env_size>
    // Retrieve size of environment variable required for following mesh layers
    total_env_size += CO_ALIGN4_HI(m_tb_get_env_size(p_cfg));
    total_env_size += CO_ALIGN4_HI(m_bearer_get_env_size(p_cfg));
    total_env_size += CO_ALIGN4_HI(m_lay_get_env_size(p_cfg));
    total_env_size += CO_ALIGN4_HI(m_prov_get_env_size(p_cfg));
    total_env_size += CO_ALIGN4_HI(m_fnd_get_env_size(p_cfg));
    8f00:	43ac      	bics	r4, r5
    8f02:	1936      	adds	r6, r6, r4

    #if (BLE_MESH_DBG)
    total_env_size += CO_ALIGN4_HI(m_dbg_get_env_size(p_cfg));
    #endif //(BLE_MESH_DBG)

    return (total_env_size);
    8f04:	1940      	adds	r0, r0, r5
    // Retrieve size of environment variable required for following mesh layers
    total_env_size += CO_ALIGN4_HI(m_tb_get_env_size(p_cfg));
    total_env_size += CO_ALIGN4_HI(m_bearer_get_env_size(p_cfg));
    total_env_size += CO_ALIGN4_HI(m_lay_get_env_size(p_cfg));
    total_env_size += CO_ALIGN4_HI(m_prov_get_env_size(p_cfg));
    total_env_size += CO_ALIGN4_HI(m_fnd_get_env_size(p_cfg));
    8f06:	b2b4      	uxth	r4, r6

    #if (BLE_MESH_DBG)
    total_env_size += CO_ALIGN4_HI(m_dbg_get_env_size(p_cfg));
    #endif //(BLE_MESH_DBG)

    return (total_env_size);
    8f08:	43a8      	bics	r0, r5
    8f0a:	1820      	adds	r0, r4, r0
    8f0c:	b280      	uxth	r0, r0
}
    8f0e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

00008f10 <m_api_init>:

uint16_t m_api_init(bool reset, void *p_env, const m_cfg_t* p_cfg)
{
    8f10:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    8f12:	0016      	movs	r6, r2
    // Stack initialization
    uint8_t *p_env_cursor = (uint8_t*) p_env;
    // Initialize set of API
    p_m_api_cb = NULL;
    8f14:	2200      	movs	r2, #0
    8f16:	4b20      	ldr	r3, [pc, #128]	; (8f98 <m_api_init+0x88>)

    return (total_env_size);
}

uint16_t m_api_init(bool reset, void *p_env, const m_cfg_t* p_cfg)
{
    8f18:	0005      	movs	r5, r0
    // Stack initialization
    uint8_t *p_env_cursor = (uint8_t*) p_env;
    // Initialize set of API
    p_m_api_cb = NULL;
    8f1a:	601a      	str	r2, [r3, #0]

    p_env_cursor += CO_ALIGN4_HI(m_tb_init(reset, (void*) p_env_cursor, p_cfg));
    8f1c:	0032      	movs	r2, r6

    return (total_env_size);
}

uint16_t m_api_init(bool reset, void *p_env, const m_cfg_t* p_cfg)
{
    8f1e:	000f      	movs	r7, r1
    // Stack initialization
    uint8_t *p_env_cursor = (uint8_t*) p_env;
    // Initialize set of API
    p_m_api_cb = NULL;

    p_env_cursor += CO_ALIGN4_HI(m_tb_init(reset, (void*) p_env_cursor, p_cfg));
    8f20:	f008 f9c3 	bl	112aa <m_tb_init>
    8f24:	2403      	movs	r4, #3
    8f26:	3003      	adds	r0, #3
    8f28:	43a0      	bics	r0, r4
    8f2a:	183b      	adds	r3, r7, r0
    p_env_cursor += CO_ALIGN4_HI(m_bearer_init(reset, (void*) p_env_cursor, p_cfg));
    8f2c:	0032      	movs	r2, r6
    8f2e:	0019      	movs	r1, r3
    8f30:	0028      	movs	r0, r5
    // Stack initialization
    uint8_t *p_env_cursor = (uint8_t*) p_env;
    // Initialize set of API
    p_m_api_cb = NULL;

    p_env_cursor += CO_ALIGN4_HI(m_tb_init(reset, (void*) p_env_cursor, p_cfg));
    8f32:	9301      	str	r3, [sp, #4]
    p_env_cursor += CO_ALIGN4_HI(m_bearer_init(reset, (void*) p_env_cursor, p_cfg));
    8f34:	f000 ff3e 	bl	9db4 <m_bearer_init>
    8f38:	9b01      	ldr	r3, [sp, #4]
    8f3a:	1900      	adds	r0, r0, r4
    8f3c:	43a0      	bics	r0, r4
    8f3e:	181b      	adds	r3, r3, r0
    p_env_cursor += CO_ALIGN4_HI(m_lay_init(reset, (void*) p_env_cursor, p_cfg));
    8f40:	0032      	movs	r2, r6
    8f42:	0019      	movs	r1, r3
    8f44:	0028      	movs	r0, r5
    uint8_t *p_env_cursor = (uint8_t*) p_env;
    // Initialize set of API
    p_m_api_cb = NULL;

    p_env_cursor += CO_ALIGN4_HI(m_tb_init(reset, (void*) p_env_cursor, p_cfg));
    p_env_cursor += CO_ALIGN4_HI(m_bearer_init(reset, (void*) p_env_cursor, p_cfg));
    8f46:	9301      	str	r3, [sp, #4]
    p_env_cursor += CO_ALIGN4_HI(m_lay_init(reset, (void*) p_env_cursor, p_cfg));
    8f48:	f003 f850 	bl	bfec <m_lay_init>
    8f4c:	9b01      	ldr	r3, [sp, #4]
    8f4e:	1900      	adds	r0, r0, r4
    8f50:	43a0      	bics	r0, r4
    8f52:	181b      	adds	r3, r3, r0
    p_env_cursor += CO_ALIGN4_HI(m_prov_init(reset, (void*) p_env_cursor, p_cfg));
    8f54:	0032      	movs	r2, r6
    8f56:	0019      	movs	r1, r3
    8f58:	0028      	movs	r0, r5
    // Initialize set of API
    p_m_api_cb = NULL;

    p_env_cursor += CO_ALIGN4_HI(m_tb_init(reset, (void*) p_env_cursor, p_cfg));
    p_env_cursor += CO_ALIGN4_HI(m_bearer_init(reset, (void*) p_env_cursor, p_cfg));
    p_env_cursor += CO_ALIGN4_HI(m_lay_init(reset, (void*) p_env_cursor, p_cfg));
    8f5a:	9301      	str	r3, [sp, #4]
    p_env_cursor += CO_ALIGN4_HI(m_prov_init(reset, (void*) p_env_cursor, p_cfg));
    8f5c:	f006 ffc6 	bl	feec <m_prov_init>
    8f60:	9b01      	ldr	r3, [sp, #4]
    8f62:	1900      	adds	r0, r0, r4
    8f64:	43a0      	bics	r0, r4
    8f66:	181b      	adds	r3, r3, r0
    p_env_cursor += CO_ALIGN4_HI(m_fnd_init(reset, (void*) p_env_cursor, p_cfg));
    8f68:	0032      	movs	r2, r6
    8f6a:	0019      	movs	r1, r3
    8f6c:	0028      	movs	r0, r5
    p_m_api_cb = NULL;

    p_env_cursor += CO_ALIGN4_HI(m_tb_init(reset, (void*) p_env_cursor, p_cfg));
    p_env_cursor += CO_ALIGN4_HI(m_bearer_init(reset, (void*) p_env_cursor, p_cfg));
    p_env_cursor += CO_ALIGN4_HI(m_lay_init(reset, (void*) p_env_cursor, p_cfg));
    p_env_cursor += CO_ALIGN4_HI(m_prov_init(reset, (void*) p_env_cursor, p_cfg));
    8f6e:	9301      	str	r3, [sp, #4]
    p_env_cursor += CO_ALIGN4_HI(m_fnd_init(reset, (void*) p_env_cursor, p_cfg));
    8f70:	f001 faa8 	bl	a4c4 <m_fnd_init>
    8f74:	9b01      	ldr	r3, [sp, #4]
    8f76:	1900      	adds	r0, r0, r4
    8f78:	43a0      	bics	r0, r4
    8f7a:	181b      	adds	r3, r3, r0
    p_env_cursor += CO_ALIGN4_HI(m_bcn_init(reset, (void*) p_env_cursor, p_cfg));
    8f7c:	0032      	movs	r2, r6
    8f7e:	0019      	movs	r1, r3
    8f80:	0028      	movs	r0, r5

    p_env_cursor += CO_ALIGN4_HI(m_tb_init(reset, (void*) p_env_cursor, p_cfg));
    p_env_cursor += CO_ALIGN4_HI(m_bearer_init(reset, (void*) p_env_cursor, p_cfg));
    p_env_cursor += CO_ALIGN4_HI(m_lay_init(reset, (void*) p_env_cursor, p_cfg));
    p_env_cursor += CO_ALIGN4_HI(m_prov_init(reset, (void*) p_env_cursor, p_cfg));
    p_env_cursor += CO_ALIGN4_HI(m_fnd_init(reset, (void*) p_env_cursor, p_cfg));
    8f82:	9301      	str	r3, [sp, #4]
    p_env_cursor += CO_ALIGN4_HI(m_bcn_init(reset, (void*) p_env_cursor, p_cfg));
    8f84:	f000 fcbc 	bl	9900 <m_bcn_init>
        }
        #endif //(BLE_MESH_MSG_API)
    }

    // Return size of the environment used
    return (((uint32_t) p_env_cursor) - ((uint32_t) p_env));
    8f88:	9b01      	ldr	r3, [sp, #4]
    8f8a:	1900      	adds	r0, r0, r4
    8f8c:	43a0      	bics	r0, r4
    8f8e:	1818      	adds	r0, r3, r0
    8f90:	1bc0      	subs	r0, r0, r7
    8f92:	b280      	uxth	r0, r0
}
    8f94:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
    8f96:	46c0      	nop			; (mov r8, r8)
    8f98:	10012698 	.word	0x10012698

00008f9c <bc_m_send_attention_update_ind>:

void bc_m_send_attention_update_ind(uint8_t attention_state)
{
	M_PRINTF(L_APP, "%d", attention_state);
    8f9c:	4b0f      	ldr	r3, [pc, #60]	; (8fdc <bc_m_send_attention_update_ind+0x40>)
    // Return size of the environment used
    return (((uint32_t) p_env_cursor) - ((uint32_t) p_env));
}

void bc_m_send_attention_update_ind(uint8_t attention_state)
{
    8f9e:	b573      	push	{r0, r1, r4, r5, r6, lr}
	M_PRINTF(L_APP, "%d", attention_state);
    8fa0:	681b      	ldr	r3, [r3, #0]
    // Return size of the environment used
    return (((uint32_t) p_env_cursor) - ((uint32_t) p_env));
}

void bc_m_send_attention_update_ind(uint8_t attention_state)
{
    8fa2:	0006      	movs	r6, r0
	M_PRINTF(L_APP, "%d", attention_state);
    8fa4:	049b      	lsls	r3, r3, #18
    8fa6:	d517      	bpl.n	8fd8 <bc_m_send_attention_update_ind+0x3c>
    8fa8:	4d0d      	ldr	r5, [pc, #52]	; (8fe0 <bc_m_send_attention_update_ind+0x44>)
    8faa:	4c0e      	ldr	r4, [pc, #56]	; (8fe4 <bc_m_send_attention_update_ind+0x48>)
    8fac:	002b      	movs	r3, r5
    8fae:	3314      	adds	r3, #20
    8fb0:	9300      	str	r3, [sp, #0]
    8fb2:	0022      	movs	r2, r4
    8fb4:	0020      	movs	r0, r4
    8fb6:	237c      	movs	r3, #124	; 0x7c
    8fb8:	321b      	adds	r2, #27
    8fba:	33ff      	adds	r3, #255	; 0xff
    8fbc:	0021      	movs	r1, r4
    8fbe:	3023      	adds	r0, #35	; 0x23
    8fc0:	f7fb fcf4 	bl	49ac <m_print>
    8fc4:	0028      	movs	r0, r5
    8fc6:	0031      	movs	r1, r6
    8fc8:	3033      	adds	r0, #51	; 0x33
    8fca:	f7fb fcef 	bl	49ac <m_print>
    8fce:	0020      	movs	r0, r4
    8fd0:	1da1      	adds	r1, r4, #6
    8fd2:	3052      	adds	r0, #82	; 0x52
    8fd4:	f7fb fcea 	bl	49ac <m_print>
    p_ind->attention_state = attention_state;

    // Send the message
    m_al_msg_send(TASK_AHI, p_ind);
#endif
}
    8fd8:	bd73      	pop	{r0, r1, r4, r5, r6, pc}
    8fda:	46c0      	nop			; (mov r8, r8)
    8fdc:	10010514 	.word	0x10010514
    8fe0:	00021244 	.word	0x00021244
    8fe4:	000211c4 	.word	0x000211c4

00008fe8 <bc_m_send_compo_data_req_ind>:

void bc_m_send_compo_data_req_ind(uint8_t page)
{
	M_PRINTF(L_APP,"");
    8fe8:	4b12      	ldr	r3, [pc, #72]	; (9034 <bc_m_send_compo_data_req_ind+0x4c>)
    m_al_msg_send(TASK_AHI, p_ind);
#endif
}

void bc_m_send_compo_data_req_ind(uint8_t page)
{
    8fea:	b537      	push	{r0, r1, r2, r4, r5, lr}
	M_PRINTF(L_APP,"");
    8fec:	681b      	ldr	r3, [r3, #0]
    m_al_msg_send(TASK_AHI, p_ind);
#endif
}

void bc_m_send_compo_data_req_ind(uint8_t page)
{
    8fee:	0005      	movs	r5, r0
	M_PRINTF(L_APP,"");
    8ff0:	049b      	lsls	r3, r3, #18
    8ff2:	d515      	bpl.n	9020 <bc_m_send_compo_data_req_ind+0x38>
    8ff4:	4b10      	ldr	r3, [pc, #64]	; (9038 <bc_m_send_compo_data_req_ind+0x50>)
    8ff6:	4c11      	ldr	r4, [pc, #68]	; (903c <bc_m_send_compo_data_req_ind+0x54>)
    8ff8:	3336      	adds	r3, #54	; 0x36
    8ffa:	9300      	str	r3, [sp, #0]
    8ffc:	0022      	movs	r2, r4
    8ffe:	0020      	movs	r0, r4
    9000:	23c5      	movs	r3, #197	; 0xc5
    9002:	0021      	movs	r1, r4
    9004:	321b      	adds	r2, #27
    9006:	005b      	lsls	r3, r3, #1
    9008:	3023      	adds	r0, #35	; 0x23
    900a:	f7fb fccf 	bl	49ac <m_print>
    900e:	0020      	movs	r0, r4
    9010:	3051      	adds	r0, #81	; 0x51
    9012:	f7fb fccb 	bl	49ac <m_print>
    9016:	0020      	movs	r0, r4
    9018:	1da1      	adds	r1, r4, #6
    901a:	3052      	adds	r0, #82	; 0x52
    901c:	f7fb fcc6 	bl	49ac <m_print>
    p_req_ind->page = page;

    // Send the message
    m_al_msg_send(p_req_ind);
#else
	if(p_m_api_cb && p_m_api_cb->cb_compo_data_req)
    9020:	4b07      	ldr	r3, [pc, #28]	; (9040 <bc_m_send_compo_data_req_ind+0x58>)
    9022:	681b      	ldr	r3, [r3, #0]
    9024:	2b00      	cmp	r3, #0
    9026:	d004      	beq.n	9032 <bc_m_send_compo_data_req_ind+0x4a>
    9028:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    902a:	2b00      	cmp	r3, #0
    902c:	d001      	beq.n	9032 <bc_m_send_compo_data_req_ind+0x4a>
		p_m_api_cb->cb_compo_data_req(page);
    902e:	0028      	movs	r0, r5
    9030:	4798      	blx	r3
#endif
}
    9032:	bd37      	pop	{r0, r1, r2, r4, r5, pc}
    9034:	10010514 	.word	0x10010514
    9038:	00021244 	.word	0x00021244
    903c:	000211c4 	.word	0x000211c4
    9040:	10012698 	.word	0x10012698

00009044 <bc_m_send_fault_get_req_ind>:

void bc_m_send_fault_get_req_ind(uint16_t comp_id)
{
	M_PRINTF(L_APP,"");
    9044:	4b0d      	ldr	r3, [pc, #52]	; (907c <bc_m_send_fault_get_req_ind+0x38>)
		p_m_api_cb->cb_compo_data_req(page);
#endif
}

void bc_m_send_fault_get_req_ind(uint16_t comp_id)
{
    9046:	b513      	push	{r0, r1, r4, lr}
	M_PRINTF(L_APP,"");
    9048:	681b      	ldr	r3, [r3, #0]
    904a:	049b      	lsls	r3, r3, #18
    904c:	d515      	bpl.n	907a <bc_m_send_fault_get_req_ind+0x36>
    904e:	4b0c      	ldr	r3, [pc, #48]	; (9080 <bc_m_send_fault_get_req_ind+0x3c>)
    9050:	4c0c      	ldr	r4, [pc, #48]	; (9084 <bc_m_send_fault_get_req_ind+0x40>)
    9052:	3353      	adds	r3, #83	; 0x53
    9054:	9300      	str	r3, [sp, #0]
    9056:	0022      	movs	r2, r4
    9058:	0020      	movs	r0, r4
    905a:	23ce      	movs	r3, #206	; 0xce
    905c:	0021      	movs	r1, r4
    905e:	321b      	adds	r2, #27
    9060:	005b      	lsls	r3, r3, #1
    9062:	3023      	adds	r0, #35	; 0x23
    9064:	f7fb fca2 	bl	49ac <m_print>
    9068:	0020      	movs	r0, r4
    906a:	3051      	adds	r0, #81	; 0x51
    906c:	f7fb fc9e 	bl	49ac <m_print>
    9070:	0020      	movs	r0, r4
    9072:	1da1      	adds	r1, r4, #6
    9074:	3052      	adds	r0, #82	; 0x52
    9076:	f7fb fc99 	bl	49ac <m_print>
    p_req_ind->comp_id = comp_id;

    // Send the message
    m_al_msg_send(TASK_AHI, p_req_ind);
#endif
}
    907a:	bd13      	pop	{r0, r1, r4, pc}
    907c:	10010514 	.word	0x10010514
    9080:	00021244 	.word	0x00021244
    9084:	000211c4 	.word	0x000211c4

00009088 <bc_m_send_fault_test_req_ind>:

void bc_m_send_fault_test_req_ind(uint16_t comp_id, uint8_t test_id, bool cfm_needed)
{
	M_PRINTF(L_APP,"");
    9088:	4b0d      	ldr	r3, [pc, #52]	; (90c0 <bc_m_send_fault_test_req_ind+0x38>)
    m_al_msg_send(TASK_AHI, p_req_ind);
#endif
}

void bc_m_send_fault_test_req_ind(uint16_t comp_id, uint8_t test_id, bool cfm_needed)
{
    908a:	b513      	push	{r0, r1, r4, lr}
	M_PRINTF(L_APP,"");
    908c:	681b      	ldr	r3, [r3, #0]
    908e:	049b      	lsls	r3, r3, #18
    9090:	d515      	bpl.n	90be <bc_m_send_fault_test_req_ind+0x36>
    9092:	4b0c      	ldr	r3, [pc, #48]	; (90c4 <bc_m_send_fault_test_req_ind+0x3c>)
    9094:	4c0c      	ldr	r4, [pc, #48]	; (90c8 <bc_m_send_fault_test_req_ind+0x40>)
    9096:	336f      	adds	r3, #111	; 0x6f
    9098:	9300      	str	r3, [sp, #0]
    909a:	0022      	movs	r2, r4
    909c:	0020      	movs	r0, r4
    909e:	23ac      	movs	r3, #172	; 0xac
    90a0:	0021      	movs	r1, r4
    90a2:	321b      	adds	r2, #27
    90a4:	33ff      	adds	r3, #255	; 0xff
    90a6:	3023      	adds	r0, #35	; 0x23
    90a8:	f7fb fc80 	bl	49ac <m_print>
    90ac:	0020      	movs	r0, r4
    90ae:	3051      	adds	r0, #81	; 0x51
    90b0:	f7fb fc7c 	bl	49ac <m_print>
    90b4:	0020      	movs	r0, r4
    90b6:	1da1      	adds	r1, r4, #6
    90b8:	3052      	adds	r0, #82	; 0x52
    90ba:	f7fb fc77 	bl	49ac <m_print>
    p_req_ind->cfm_needed = cfm_needed;

    // Send the message
    m_al_msg_send(TASK_AHI, p_req_ind);
#endif
}
    90be:	bd13      	pop	{r0, r1, r4, pc}
    90c0:	10010514 	.word	0x10010514
    90c4:	00021244 	.word	0x00021244
    90c8:	000211c4 	.word	0x000211c4

000090cc <bc_m_send_fault_clear_ind>:

void bc_m_send_fault_clear_ind(uint16_t comp_id)
{
	M_PRINTF(L_APP,"");
    90cc:	4b0d      	ldr	r3, [pc, #52]	; (9104 <bc_m_send_fault_clear_ind+0x38>)
    m_al_msg_send(TASK_AHI, p_req_ind);
#endif
}

void bc_m_send_fault_clear_ind(uint16_t comp_id)
{
    90ce:	b513      	push	{r0, r1, r4, lr}
	M_PRINTF(L_APP,"");
    90d0:	681b      	ldr	r3, [r3, #0]
    90d2:	049b      	lsls	r3, r3, #18
    90d4:	d515      	bpl.n	9102 <bc_m_send_fault_clear_ind+0x36>
    90d6:	4b0c      	ldr	r3, [pc, #48]	; (9108 <bc_m_send_fault_clear_ind+0x3c>)
    90d8:	4c0c      	ldr	r4, [pc, #48]	; (910c <bc_m_send_fault_clear_ind+0x40>)
    90da:	330c      	adds	r3, #12
    90dc:	9300      	str	r3, [sp, #0]
    90de:	0022      	movs	r2, r4
    90e0:	0020      	movs	r0, r4
    90e2:	23de      	movs	r3, #222	; 0xde
    90e4:	0021      	movs	r1, r4
    90e6:	321b      	adds	r2, #27
    90e8:	005b      	lsls	r3, r3, #1
    90ea:	3023      	adds	r0, #35	; 0x23
    90ec:	f7fb fc5e 	bl	49ac <m_print>
    90f0:	0020      	movs	r0, r4
    90f2:	3051      	adds	r0, #81	; 0x51
    90f4:	f7fb fc5a 	bl	49ac <m_print>
    90f8:	0020      	movs	r0, r4
    90fa:	1da1      	adds	r1, r4, #6
    90fc:	3052      	adds	r0, #82	; 0x52
    90fe:	f7fb fc55 	bl	49ac <m_print>
    p_ind->comp_id = comp_id;

    // Send the message
    m_al_msg_send(TASK_AHI, p_ind);
#endif
}
    9102:	bd13      	pop	{r0, r1, r4, pc}
    9104:	10010514 	.word	0x10010514
    9108:	000212c4 	.word	0x000212c4
    910c:	000211c4 	.word	0x000211c4

00009110 <bc_m_send_fault_period_ind>:

void bc_m_send_fault_period_ind(uint32_t period_ms, uint32_t period_fault_ms)
{
	M_PRINTF(L_APP,"");
    9110:	4b0d      	ldr	r3, [pc, #52]	; (9148 <bc_m_send_fault_period_ind+0x38>)
    m_al_msg_send(TASK_AHI, p_ind);
#endif
}

void bc_m_send_fault_period_ind(uint32_t period_ms, uint32_t period_fault_ms)
{
    9112:	b513      	push	{r0, r1, r4, lr}
	M_PRINTF(L_APP,"");
    9114:	681b      	ldr	r3, [r3, #0]
    9116:	049b      	lsls	r3, r3, #18
    9118:	d515      	bpl.n	9146 <bc_m_send_fault_period_ind+0x36>
    911a:	4b0c      	ldr	r3, [pc, #48]	; (914c <bc_m_send_fault_period_ind+0x3c>)
    911c:	4c0c      	ldr	r4, [pc, #48]	; (9150 <bc_m_send_fault_period_ind+0x40>)
    911e:	3326      	adds	r3, #38	; 0x26
    9120:	9300      	str	r3, [sp, #0]
    9122:	0022      	movs	r2, r4
    9124:	0020      	movs	r0, r4
    9126:	23cc      	movs	r3, #204	; 0xcc
    9128:	0021      	movs	r1, r4
    912a:	321b      	adds	r2, #27
    912c:	33ff      	adds	r3, #255	; 0xff
    912e:	3023      	adds	r0, #35	; 0x23
    9130:	f7fb fc3c 	bl	49ac <m_print>
    9134:	0020      	movs	r0, r4
    9136:	3051      	adds	r0, #81	; 0x51
    9138:	f7fb fc38 	bl	49ac <m_print>
    913c:	0020      	movs	r0, r4
    913e:	1da1      	adds	r1, r4, #6
    9140:	3052      	adds	r0, #82	; 0x52
    9142:	f7fb fc33 	bl	49ac <m_print>
    p_ind->period_fault_ms = period_fault_ms;

    // Send the message
    m_al_msg_send(TASK_AHI, p_ind);
#endif
}
    9146:	bd13      	pop	{r0, r1, r4, pc}
    9148:	10010514 	.word	0x10010514
    914c:	000212c4 	.word	0x000212c4
    9150:	000211c4 	.word	0x000211c4

00009154 <bc_m_send_update_ind>:
    memcpy(&p_ind->data[0], p_data, length);

    // Send the message
    m_al_msg_send(p_ind);
#else
	if(p_m_api_cb && p_m_api_cb->cb_update_ind)
    9154:	4b04      	ldr	r3, [pc, #16]	; (9168 <bc_m_send_update_ind+0x14>)
    m_al_msg_send(TASK_AHI, p_ind);
#endif
}

void bc_m_send_update_ind(uint8_t upd_type, uint16_t length, uint8_t *p_data)
{
    9156:	b510      	push	{r4, lr}
    memcpy(&p_ind->data[0], p_data, length);

    // Send the message
    m_al_msg_send(p_ind);
#else
	if(p_m_api_cb && p_m_api_cb->cb_update_ind)
    9158:	681b      	ldr	r3, [r3, #0]
    915a:	2b00      	cmp	r3, #0
    915c:	d003      	beq.n	9166 <bc_m_send_update_ind+0x12>
    915e:	69db      	ldr	r3, [r3, #28]
    9160:	2b00      	cmp	r3, #0
    9162:	d000      	beq.n	9166 <bc_m_send_update_ind+0x12>
		p_m_api_cb->cb_update_ind(upd_type, length, p_data);
    9164:	4798      	blx	r3
#endif
}
    9166:	bd10      	pop	{r4, pc}
    9168:	10012698 	.word	0x10012698

0000916c <bc_m_send_node_reset_ind>:

void bc_m_send_node_reset_ind(void)
{
	M_PRINTF(L_APP,"");
    916c:	4b11      	ldr	r3, [pc, #68]	; (91b4 <bc_m_send_node_reset_ind+0x48>)
		p_m_api_cb->cb_update_ind(upd_type, length, p_data);
#endif
}

void bc_m_send_node_reset_ind(void)
{
    916e:	b513      	push	{r0, r1, r4, lr}
	M_PRINTF(L_APP,"");
    9170:	681b      	ldr	r3, [r3, #0]
    9172:	049b      	lsls	r3, r3, #18
    9174:	d515      	bpl.n	91a2 <bc_m_send_node_reset_ind+0x36>
    9176:	4b10      	ldr	r3, [pc, #64]	; (91b8 <bc_m_send_node_reset_ind+0x4c>)
    9178:	4c10      	ldr	r4, [pc, #64]	; (91bc <bc_m_send_node_reset_ind+0x50>)
    917a:	3341      	adds	r3, #65	; 0x41
    917c:	9300      	str	r3, [sp, #0]
    917e:	0022      	movs	r2, r4
    9180:	0020      	movs	r0, r4
    9182:	23f7      	movs	r3, #247	; 0xf7
    9184:	0021      	movs	r1, r4
    9186:	321b      	adds	r2, #27
    9188:	005b      	lsls	r3, r3, #1
    918a:	3023      	adds	r0, #35	; 0x23
    918c:	f7fb fc0e 	bl	49ac <m_print>
    9190:	0020      	movs	r0, r4
    9192:	3051      	adds	r0, #81	; 0x51
    9194:	f7fb fc0a 	bl	49ac <m_print>
    9198:	0020      	movs	r0, r4
    919a:	1da1      	adds	r1, r4, #6
    919c:	3052      	adds	r0, #82	; 0x52
    919e:	f7fb fc05 	bl	49ac <m_print>
    void *p_ind = M_AL_MSG_ALLOC_DEFAULT(MESH_API_NODE_RESET_IND);

    // Send the message
    m_al_msg_send(p_ind);
#else
	if(p_m_api_cb && p_m_api_cb->cb_reset_ind)
    91a2:	4b07      	ldr	r3, [pc, #28]	; (91c0 <bc_m_send_node_reset_ind+0x54>)
    91a4:	681b      	ldr	r3, [r3, #0]
    91a6:	2b00      	cmp	r3, #0
    91a8:	d003      	beq.n	91b2 <bc_m_send_node_reset_ind+0x46>
    91aa:	6a1b      	ldr	r3, [r3, #32]
    91ac:	2b00      	cmp	r3, #0
    91ae:	d000      	beq.n	91b2 <bc_m_send_node_reset_ind+0x46>
		p_m_api_cb->cb_reset_ind();
    91b0:	4798      	blx	r3
#endif
}
    91b2:	bd13      	pop	{r0, r1, r4, pc}
    91b4:	10010514 	.word	0x10010514
    91b8:	000212c4 	.word	0x000212c4
    91bc:	000211c4 	.word	0x000211c4
    91c0:	10012698 	.word	0x10012698

000091c4 <bc_m_health_status_send>:
#endif
}
#endif //(BLE_MESH_LPN)

void bc_m_health_status_send(uint16_t comp_id, uint8_t test_id, uint8_t length, uint8_t *p_fault_array)
{
    91c4:	b510      	push	{r4, lr}
    m_fnd_hlths_status_ind(comp_id, test_id, length, p_fault_array);
    91c6:	f002 fed7 	bl	bf78 <m_fnd_hlths_status_ind>
}
    91ca:	bd10      	pop	{r4, pc}

000091cc <bc_m_health_cfm>:

void bc_m_health_cfm(bool accept, uint16_t comp_id, uint8_t test_id, uint8_t length,
                      uint8_t *p_fault_array)
{
    91cc:	b513      	push	{r0, r1, r4, lr}
    m_fnd_hlths_cfm(accept, comp_id, test_id, length, p_fault_array);
    91ce:	9c04      	ldr	r4, [sp, #16]
    91d0:	9400      	str	r4, [sp, #0]
    91d2:	f002 fed8 	bl	bf86 <m_fnd_hlths_cfm>
}
    91d6:	bd13      	pop	{r0, r1, r4, pc}

000091d8 <bc_m_compo_data_cfm>:

void bc_m_compo_data_cfm(uint8_t page, uint8_t length, uint8_t *p_data)
{
    91d8:	b510      	push	{r4, lr}
    // Inform the storage manager about received application response
    m_tb_store_rx_compo_data(page, length, p_data);
    91da:	f00b fef3 	bl	14fc4 <m_tb_store_rx_compo_data>
}
    91de:	bd10      	pop	{r4, pc}

000091e0 <bc_m_prov_param_rsp>:
// -----------------------------------------------------------------------------
//                    Provisioning API
// -----------------------------------------------------------------------------

void bc_m_prov_param_rsp(void *p_param)
{
    91e0:	b510      	push	{r4, lr}
    m_prov_param_rsp(p_param);
    91e2:	f006 ff49 	bl	10078 <m_prov_param_rsp>
}
    91e6:	bd10      	pop	{r4, pc}

000091e8 <bc_m_prov_oob_auth_rsp>:

void bc_m_prov_oob_auth_rsp(bool accept, uint8_t auth_size, const uint8_t* p_auth_data)
{
    91e8:	b510      	push	{r4, lr}
    m_prov_oob_auth_rsp(accept, auth_size, p_auth_data);
    91ea:	f006 fed9 	bl	ffa0 <m_prov_oob_auth_rsp>
}
    91ee:	bd10      	pop	{r4, pc}

000091f0 <bc_m_prov_pub_key_read>:

uint16_t bc_m_prov_pub_key_read(uint8_t* p_pub_key_x, uint8_t* p_pub_key_y)
{
    91f0:	b510      	push	{r4, lr}
    return (m_prov_pub_key_get(p_pub_key_x, p_pub_key_y));
    91f2:	f006 ff7f 	bl	100f4 <m_prov_pub_key_get>
}
    91f6:	bd10      	pop	{r4, pc}

000091f8 <m_call_back>:
extern void m_al_destroy(struct prf_task_env* env);
extern void m_al_create(struct prf_task_env* env, uint8_t conidx);
extern void m_al_cleanup(struct prf_task_env* env, uint8_t conidx, uint8_t reason);

uint32_t m_call_back(MESH_BLE_EVENT e,void *param)
{
    91f8:	b570      	push	{r4, r5, r6, lr}
    91fa:	0003      	movs	r3, r0
    91fc:	000c      	movs	r4, r1
#endif
		default:{
			return 1;
		}break;
	}
	return 0;
    91fe:	2000      	movs	r0, #0
extern void m_al_create(struct prf_task_env* env, uint8_t conidx);
extern void m_al_cleanup(struct prf_task_env* env, uint8_t conidx, uint8_t reason);

uint32_t m_call_back(MESH_BLE_EVENT e,void *param)
{
	switch(e){
    9200:	2b02      	cmp	r3, #2
    9202:	d91f      	bls.n	9244 <m_call_back+0x4c>
    9204:	2b03      	cmp	r3, #3
    9206:	d11c      	bne.n	9242 <m_call_back+0x4a>
			
		}break;
		case MESH_BLE_SCAN_RX_CB:{
			struct mesh_adv_report_param* p = (struct mesh_adv_report_param*)param;
			
			if(p->data[1] != M_BEARER_ADV_TYPE_PB_ADV 
    9208:	684b      	ldr	r3, [r1, #4]
				&& p->data[1] != M_BEARER_ADV_TYPE_MSG
				&& p->data[1] != M_BEARER_ADV_TYPE_BEACON){
				return 1;
    920a:	3001      	adds	r0, #1
			
		}break;
		case MESH_BLE_SCAN_RX_CB:{
			struct mesh_adv_report_param* p = (struct mesh_adv_report_param*)param;
			
			if(p->data[1] != M_BEARER_ADV_TYPE_PB_ADV 
    920c:	785b      	ldrb	r3, [r3, #1]
    920e:	3b29      	subs	r3, #41	; 0x29
    9210:	2b02      	cmp	r3, #2
    9212:	d817      	bhi.n	9244 <m_call_back+0x4c>
				&& p->data[1] != M_BEARER_ADV_TYPE_MSG
				&& p->data[1] != M_BEARER_ADV_TYPE_BEACON){
				return 1;
			}
			struct gapm_ext_adv_report_ind *cfm = M_AL_MSG_ALLOC_DYN(MESH_EXT_ADV_REPORT_IND,
    9214:	8849      	ldrh	r1, [r1, #2]
    9216:	3104      	adds	r1, #4
    9218:	b289      	uxth	r1, r1
    921a:	f7fc f9bf 	bl	559c <m_al_msg_alloc>
													struct gapm_ext_adv_report_ind, p->length);
			cfm->info = p->info;
    921e:	7823      	ldrb	r3, [r4, #0]
			if(p->data[1] != M_BEARER_ADV_TYPE_PB_ADV 
				&& p->data[1] != M_BEARER_ADV_TYPE_MSG
				&& p->data[1] != M_BEARER_ADV_TYPE_BEACON){
				return 1;
			}
			struct gapm_ext_adv_report_ind *cfm = M_AL_MSG_ALLOC_DYN(MESH_EXT_ADV_REPORT_IND,
    9220:	0005      	movs	r5, r0
													struct gapm_ext_adv_report_ind, p->length);
			cfm->info = p->info;
    9222:	7003      	strb	r3, [r0, #0]
			cfm->length = p->length;
    9224:	8863      	ldrh	r3, [r4, #2]
    9226:	8043      	strh	r3, [r0, #2]
			cfm->rssi = p->rssi;
    9228:	2301      	movs	r3, #1
    922a:	56e3      	ldrsb	r3, [r4, r3]
    922c:	7043      	strb	r3, [r0, #1]
			memcpy(cfm->data, p->data, p->length);
    922e:	8862      	ldrh	r2, [r4, #2]
    9230:	6861      	ldr	r1, [r4, #4]
    9232:	3004      	adds	r0, #4
    9234:	f00c fbcc 	bl	159d0 <memcpy>
			ke_msg_send(cfm);
    9238:	0028      	movs	r0, r5
    923a:	f7fe f8e3 	bl	7404 <ke_msg_send>
    923e:	2000      	movs	r0, #0
    9240:	e000      	b.n	9244 <m_call_back+0x4c>
			memcpy(cfm->value, p->value, p->length);
			ke_msg_send(cfm);
		}break;
#endif
		default:{
			return 1;
    9242:	2001      	movs	r0, #1
		}break;
	}
	return 0;
}
    9244:	bd70      	pop	{r4, r5, r6, pc}

00009246 <bc_m_mesh_init>:

uint16_t bc_m_mesh_init(void)
{
    9246:	b5f0      	push	{r4, r5, r6, r7, lr}
	task_info = ke_malloc(sizeof(prf_task_env_t), 0);
    9248:	2100      	movs	r1, #0
	}
	return 0;
}

uint16_t bc_m_mesh_init(void)
{
    924a:	b087      	sub	sp, #28
	task_info = ke_malloc(sizeof(prf_task_env_t), 0);
    924c:	2014      	movs	r0, #20
    924e:	f7fe f847 	bl	72e0 <ke_malloc>
    9252:	4d10      	ldr	r5, [pc, #64]	; (9294 <bc_m_mesh_init+0x4e>)
    9254:	6028      	str	r0, [r5, #0]
	ASSERT_ERR(task_info);
    9256:	2800      	cmp	r0, #0
    9258:	d100      	bne.n	925c <bc_m_mesh_init+0x16>
    925a:	e7fe      	b.n	925a <bc_m_mesh_init+0x14>
	ke_event_init();
	mesh_timer_init();
	uint16_t start_hdl = ATT_INVALID_HANDLE;
    925c:	260a      	movs	r6, #10
    925e:	2400      	movs	r4, #0

uint16_t bc_m_mesh_init(void)
{
	task_info = ke_malloc(sizeof(prf_task_env_t), 0);
	ASSERT_ERR(task_info);
	ke_event_init();
    9260:	f7fe f849 	bl	72f6 <ke_event_init>
	mesh_timer_init();
    9264:	f7fd f840 	bl	62e8 <mesh_timer_init>
	uint16_t start_hdl = ATT_INVALID_HANDLE;
	m_cfg_t p_cfg = {M_FEAT_RELAY_NODE_SUP,1,2,3,4,8};
    9268:	490b      	ldr	r1, [pc, #44]	; (9298 <bc_m_mesh_init+0x52>)
    926a:	af03      	add	r7, sp, #12
{
	task_info = ke_malloc(sizeof(prf_task_env_t), 0);
	ASSERT_ERR(task_info);
	ke_event_init();
	mesh_timer_init();
	uint16_t start_hdl = ATT_INVALID_HANDLE;
    926c:	446e      	add	r6, sp
	m_cfg_t p_cfg = {M_FEAT_RELAY_NODE_SUP,1,2,3,4,8};
    926e:	220c      	movs	r2, #12
    9270:	315a      	adds	r1, #90	; 0x5a
    9272:	0038      	movs	r0, r7
{
	task_info = ke_malloc(sizeof(prf_task_env_t), 0);
	ASSERT_ERR(task_info);
	ke_event_init();
	mesh_timer_init();
	uint16_t start_hdl = ATT_INVALID_HANDLE;
    9274:	8034      	strh	r4, [r6, #0]
	m_cfg_t p_cfg = {M_FEAT_RELAY_NODE_SUP,1,2,3,4,8};
    9276:	f00c fbab 	bl	159d0 <memcpy>
	m_al_init(task_info, &start_hdl, 0, 0, &p_cfg);
    927a:	9700      	str	r7, [sp, #0]
    927c:	0023      	movs	r3, r4
    927e:	0022      	movs	r2, r4
    9280:	0031      	movs	r1, r6
    9282:	6828      	ldr	r0, [r5, #0]
    9284:	f7fc f8d2 	bl	542c <m_al_init>

	mesh_ble_start(m_call_back);
    9288:	4804      	ldr	r0, [pc, #16]	; (929c <bc_m_mesh_init+0x56>)
    928a:	f7fe f8ef 	bl	746c <mesh_ble_start>
	return 0;
}
    928e:	0020      	movs	r0, r4
    9290:	b007      	add	sp, #28
    9292:	bdf0      	pop	{r4, r5, r6, r7, pc}
    9294:	1001289c 	.word	0x1001289c
    9298:	000212c4 	.word	0x000212c4
    929c:	000091f9 	.word	0x000091f9

000092a0 <bc_m_mesh_deinit>:

uint16_t bc_m_mesh_deinit(void)
{	
    92a0:	b510      	push	{r4, lr}
	ASSERT_ERR(task_info);
    92a2:	4c06      	ldr	r4, [pc, #24]	; (92bc <bc_m_mesh_deinit+0x1c>)
    92a4:	6820      	ldr	r0, [r4, #0]
    92a6:	2800      	cmp	r0, #0
    92a8:	d100      	bne.n	92ac <bc_m_mesh_deinit+0xc>
    92aa:	e7fe      	b.n	92aa <bc_m_mesh_deinit+0xa>
	m_al_destroy(task_info);
    92ac:	f7fc f918 	bl	54e0 <m_al_destroy>
	ke_free(task_info);
    92b0:	6820      	ldr	r0, [r4, #0]
    92b2:	f7fe f819 	bl	72e8 <ke_free>
	return 0;
}
    92b6:	2000      	movs	r0, #0
    92b8:	bd10      	pop	{r4, pc}
    92ba:	46c0      	nop			; (mov r8, r8)
    92bc:	1001289c 	.word	0x1001289c

000092c0 <bc_m_mesh_loop>:

uint16_t bc_m_mesh_loop()
{
    92c0:	b510      	push	{r4, lr}
	//msg event schedule
	ke_event_schedule();
    92c2:	f7fe f835 	bl	7330 <ke_event_schedule>
	//timer poll for mesh timer
	mesh_timer_polling();
    92c6:	f7fd f82d 	bl	6324 <mesh_timer_polling>
	return 0;
}
    92ca:	2000      	movs	r0, #0
    92cc:	bd10      	pop	{r4, pc}

000092ce <bc_m_clear_config>:

void bc_m_clear_config(void){
    92ce:	b510      	push	{r4, lr}
	m_tb_store_data_clear();
    92d0:	f00b ffc0 	bl	15254 <m_tb_store_data_clear>
}
    92d4:	bd10      	pop	{r4, pc}

000092d6 <bc_m_param_save>:

void bc_m_param_save(uint8_t upd_type, uint16_t length, uint8_t *p_data)
{
    92d6:	b510      	push	{r4, lr}
	m_tb_store_save(upd_type, length, p_data);
    92d8:	f00b fe82 	bl	14fe0 <m_tb_store_save>
}
    92dc:	bd10      	pop	{r4, pc}

000092de <bc_m_param_data_len>:

uint32_t bc_m_param_data_len(void)
{
    92de:	b510      	push	{r4, lr}
	return m_tb_store_data_len();
    92e0:	f00b ff70 	bl	151c4 <m_tb_store_data_len>
}
    92e4:	bd10      	pop	{r4, pc}

000092e6 <bc_m_param_get_data>:

uint32_t bc_m_param_get_data(uint32_t len, uint8_t* data)
{
    92e6:	b510      	push	{r4, lr}
	return m_tb_store_get_data(len, data);
    92e8:	f00b ff98 	bl	1521c <m_tb_store_get_data>
}
    92ec:	bd10      	pop	{r4, pc}

000092ee <bc_m_ali_save_seq_iv>:
//for ali
void bc_m_ali_save_seq_iv(void)
{
    92ee:	b510      	push	{r4, lr}
	m_tb_store_update_ind(M_TB_STORE_UPD_TYPE_STATE, M_TB_STORE_TYPE_IV_SEQ);
    92f0:	2108      	movs	r1, #8
    92f2:	2007      	movs	r0, #7
    92f4:	f00b fc90 	bl	14c18 <m_tb_store_update_ind>
}
    92f8:	bd10      	pop	{r4, pc}

000092fa <bc_m_bcn_stop_tx_unprov_bcn>:
void bc_m_bcn_stop_tx_unprov_bcn(void)
{
    92fa:	b510      	push	{r4, lr}
	m_bcn_stop_tx_unprov_bcn();
    92fc:	f000 fbd4 	bl	9aa8 <m_bcn_stop_tx_unprov_bcn>
}
    9300:	bd10      	pop	{r4, pc}

00009302 <bc_m_key_app_find>:
 *
 * @return Execution status (@see enum m_error)
 ****************************************************************************************
 */
uint16_t bc_m_key_app_find(uint16_t app_key_id, m_lid_t* p_app_key_lid)
{
    9302:	b510      	push	{r4, lr}
	return m_tb_key_app_find(app_key_id, p_app_key_lid);
    9304:	f009 fa7a 	bl	127fc <m_tb_key_app_find>
}
    9308:	bd10      	pop	{r4, pc}

0000930a <bc_m_mio_bind>:
 *
 * @param[in] model_lid        Model local index.
 ****************************************************************************************
 */
void bc_m_mio_bind(m_lid_t model_lid)
{
    930a:	b510      	push	{r4, lr}
	m_tb_mio_bind(model_lid);
    930c:	f00a fb06 	bl	1391c <m_tb_mio_bind>
}
    9310:	bd10      	pop	{r4, pc}

00009312 <bc_m_key_model_bind>:
 *
 * @return Execution status (@see enum m_error)
 ****************************************************************************************
 */
uint16_t bc_m_key_model_bind(m_lid_t app_key_lid, m_lid_t model_lid)
{
    9312:	b510      	push	{r4, lr}
	return m_tb_key_model_bind(app_key_lid, model_lid);
    9314:	f009 fb3e 	bl	12994 <m_tb_key_model_bind>
}
    9318:	bd10      	pop	{r4, pc}

0000931a <bc_m_mio_add_subscription>:
 * @return M_ERR_NO_ERROR if address has been inserted.
 *         M_ERR_COMMAND_DISALLOWED if address cannot be inserted.
 ****************************************************************************************
 */
uint16_t bc_m_mio_add_subscription(m_lid_t model_lid, uint16_t addr)
{
    931a:	b510      	push	{r4, lr}
	return m_tb_mio_add_subscription(model_lid, addr);
    931c:	f00a f8c8 	bl	134b0 <m_tb_mio_add_subscription>
}
    9320:	bd10      	pop	{r4, pc}

00009322 <bc_m_mio_set_publi_param>:
 ****************************************************************************************
 */
uint16_t bc_m_mio_set_publi_param(m_lid_t model_lid, uint16_t addr, uint8_t *p_label_uuid,
                                  uint8_t app_key_lid, uint8_t ttl, uint8_t period, uint8_t retx_params,
                                  uint8_t friend_cred)
{
    9322:	b5f0      	push	{r4, r5, r6, r7, lr}
    9324:	b085      	sub	sp, #20
    9326:	ac0a      	add	r4, sp, #40	; 0x28
    9328:	ad0b      	add	r5, sp, #44	; 0x2c
    932a:	ae0c      	add	r6, sp, #48	; 0x30
    932c:	af0d      	add	r7, sp, #52	; 0x34
    932e:	7824      	ldrb	r4, [r4, #0]
    9330:	782d      	ldrb	r5, [r5, #0]
    9332:	7836      	ldrb	r6, [r6, #0]
    9334:	783f      	ldrb	r7, [r7, #0]
	return m_tb_mio_set_publi_param(model_lid, addr, p_label_uuid,
    9336:	9602      	str	r6, [sp, #8]
    9338:	9703      	str	r7, [sp, #12]
    933a:	9501      	str	r5, [sp, #4]
    933c:	9400      	str	r4, [sp, #0]
    933e:	f00a f80d 	bl	1335c <m_tb_mio_set_publi_param>
                                  app_key_lid, ttl, period, retx_params,
                                  friend_cred);
}
    9342:	b005      	add	sp, #20
    9344:	bdf0      	pop	{r4, r5, r6, r7, pc}
    9346:	46c0      	nop			; (mov r8, r8)

00009348 <co_bswap>:
 * @param[in] len       number of bytes to swap
 ****************************************************************************************
 */
__INLINE_S__ void co_bswap(uint8_t* p_val_out, const uint8_t* p_val_in, uint16_t len)
{
    while (len > 0)
    9348:	2a00      	cmp	r2, #0
    934a:	d005      	beq.n	9358 <co_bswap+0x10>
    {
        len--;
    934c:	3a01      	subs	r2, #1
    934e:	b292      	uxth	r2, r2
        *p_val_out = p_val_in[len];
    9350:	5c8b      	ldrb	r3, [r1, r2]
    9352:	7003      	strb	r3, [r0, #0]
        p_val_out++;
    9354:	3001      	adds	r0, #1
    9356:	e7f7      	b.n	9348 <co_bswap>
    }
}
    9358:	4770      	bx	lr

0000935a <co_bswap32>:
 * @param[in] val32 The 32 bits value to swap.
 * @return The 32 bit swapped value.
 ****************************************************************************************
 */
__INLINE_S__ uint32_t co_bswap32(uint32_t val32)
{
    935a:	ba00      	rev	r0, r0
    return (val32<<24) | ((val32<<8)&0xFF0000) | ((val32>>8)&0xFF00) | ((val32>>24)&0xFF);
}
    935c:	4770      	bx	lr

0000935e <m_bcn_adv_tx_check>:
 ****************************************************************************************
 * @brief Check if an advertising beacon packet should be transmitted
 ****************************************************************************************
 */
__STATIC void m_bcn_adv_tx_check(void)
{
    935e:	b5f0      	push	{r4, r5, r6, r7, lr}
	M_PRINTF(L_BCN, "");
    9360:	4d76      	ldr	r5, [pc, #472]	; (953c <m_bcn_adv_tx_check+0x1de>)
 ****************************************************************************************
 * @brief Check if an advertising beacon packet should be transmitted
 ****************************************************************************************
 */
__STATIC void m_bcn_adv_tx_check(void)
{
    9362:	b087      	sub	sp, #28
	M_PRINTF(L_BCN, "");
    9364:	682b      	ldr	r3, [r5, #0]
    9366:	069b      	lsls	r3, r3, #26
    9368:	d515      	bpl.n	9396 <m_bcn_adv_tx_check+0x38>
    936a:	4c75      	ldr	r4, [pc, #468]	; (9540 <m_bcn_adv_tx_check+0x1e2>)
    936c:	0023      	movs	r3, r4
    936e:	3338      	adds	r3, #56	; 0x38
    9370:	9300      	str	r3, [sp, #0]
    9372:	0022      	movs	r2, r4
    9374:	0020      	movs	r0, r4
    9376:	230c      	movs	r3, #12
    9378:	0021      	movs	r1, r4
    937a:	3221      	adds	r2, #33	; 0x21
    937c:	33ff      	adds	r3, #255	; 0xff
    937e:	3029      	adds	r0, #41	; 0x29
    9380:	f7fb fb14 	bl	49ac <m_print>
    9384:	0020      	movs	r0, r4
    9386:	304b      	adds	r0, #75	; 0x4b
    9388:	f7fb fb10 	bl	49ac <m_print>
    938c:	0020      	movs	r0, r4
    938e:	1da1      	adds	r1, r4, #6
    9390:	304c      	adds	r0, #76	; 0x4c
    9392:	f7fb fb0b 	bl	49ac <m_print>
    do
    {
        // Get buffer and environment buffer
        m_tb_buf_t *p_buf = p_m_bcn_env->p_adv_buf_bcn;
    9396:	4e6b      	ldr	r6, [pc, #428]	; (9544 <m_bcn_adv_tx_check+0x1e6>)
    9398:	6833      	ldr	r3, [r6, #0]
        m_lay_bearer_buf_env_t *p_env = (m_lay_bearer_buf_env_t *)p_buf->env;

        // Check if advertising bearer is opened
        if (p_m_bcn_env->adv_bearer_lid == M_INVALID_LID)
    939a:	001a      	movs	r2, r3
    939c:	3244      	adds	r2, #68	; 0x44
    939e:	7811      	ldrb	r1, [r2, #0]
    93a0:	29ff      	cmp	r1, #255	; 0xff
    93a2:	d100      	bne.n	93a6 <m_bcn_adv_tx_check+0x48>
    93a4:	e0c8      	b.n	9538 <m_bcn_adv_tx_check+0x1da>
{
	M_PRINTF(L_BCN, "");
    do
    {
        // Get buffer and environment buffer
        m_tb_buf_t *p_buf = p_m_bcn_env->p_adv_buf_bcn;
    93a6:	6b5c      	ldr	r4, [r3, #52]	; 0x34
        {
            break;
        }

        // Check if a transmission is on-going
        if (GETB(p_env->flags, M_BCN_BUF_IN_TX))
    93a8:	7c23      	ldrb	r3, [r4, #16]
    93aa:	06d9      	lsls	r1, r3, #27
    93ac:	d500      	bpl.n	93b0 <m_bcn_adv_tx_check+0x52>
    93ae:	e0c3      	b.n	9538 <m_bcn_adv_tx_check+0x1da>
        {
            break;
        }

        // Check if beacon is ready to be transmitted
        if (GETB(p_env->flags, M_BCN_BUF_RTS))
    93b0:	2108      	movs	r1, #8
    93b2:	420b      	tst	r3, r1
    93b4:	d04a      	beq.n	944c <m_bcn_adv_tx_check+0xee>
        {
            // Send the beacon over advertising bearer
            SETB(p_env->flags, M_BCN_BUF_RTS, 0);
    93b6:	438b      	bics	r3, r1
    93b8:	7423      	strb	r3, [r4, #16]
            p_env->bearer_lid = p_m_bcn_env->adv_bearer_lid;
    93ba:	7813      	ldrb	r3, [r2, #0]
    93bc:	7463      	strb	r3, [r4, #17]
 * @return execution status
 ****************************************************************************************
 */
__STATIC uint16_t m_bcn_send(m_tb_buf_t* p_buf)
{
	M_PRINTF(L_BCN, "");
    93be:	682b      	ldr	r3, [r5, #0]
    93c0:	069b      	lsls	r3, r3, #26
    93c2:	d515      	bpl.n	93f0 <m_bcn_adv_tx_check+0x92>
    93c4:	4f5e      	ldr	r7, [pc, #376]	; (9540 <m_bcn_adv_tx_check+0x1e2>)
    93c6:	003b      	movs	r3, r7
    93c8:	334f      	adds	r3, #79	; 0x4f
    93ca:	9300      	str	r3, [sp, #0]
    93cc:	003a      	movs	r2, r7
    93ce:	0038      	movs	r0, r7
    93d0:	23d5      	movs	r3, #213	; 0xd5
    93d2:	0039      	movs	r1, r7
    93d4:	3221      	adds	r2, #33	; 0x21
    93d6:	005b      	lsls	r3, r3, #1
    93d8:	3029      	adds	r0, #41	; 0x29
    93da:	f7fb fae7 	bl	49ac <m_print>
    93de:	0038      	movs	r0, r7
    93e0:	304b      	adds	r0, #75	; 0x4b
    93e2:	f7fb fae3 	bl	49ac <m_print>
    93e6:	0038      	movs	r0, r7
    93e8:	1db9      	adds	r1, r7, #6
    93ea:	304c      	adds	r0, #76	; 0x4c
    93ec:	f7fb fade 	bl	49ac <m_print>
    // Returned status
    uint16_t status = M_ERR_NO_ERROR;
    // Point to buffer environment
    m_lay_bearer_buf_env_t *p_env = (m_lay_bearer_buf_env_t *)p_buf->env;

    if ((p_env->bearer_lid == M_INVALID_LID)
    93f0:	7c63      	ldrb	r3, [r4, #17]
    93f2:	2bff      	cmp	r3, #255	; 0xff
    93f4:	d104      	bne.n	9400 <m_bcn_adv_tx_check+0xa2>
        status = p_m_bcn_env->p_bearer_api->send(M_BEARER_CLI_BEACON, p_buf);
    }

    if (status != M_ERR_NO_ERROR)
    {
        if (GETB(p_env->flags, M_BCN_BUF_ADV) && GETB(p_m_bcn_env->state, M_BCN_STATE_PROV))
    93f6:	2302      	movs	r3, #2
    93f8:	7c22      	ldrb	r2, [r4, #16]
    93fa:	421a      	tst	r2, r3
    93fc:	d113      	bne.n	9426 <m_bcn_adv_tx_check+0xc8>
    93fe:	e021      	b.n	9444 <m_bcn_adv_tx_check+0xe6>
    uint16_t status = M_ERR_NO_ERROR;
    // Point to buffer environment
    m_lay_bearer_buf_env_t *p_env = (m_lay_bearer_buf_env_t *)p_buf->env;

    if ((p_env->bearer_lid == M_INVALID_LID)
            || (p_m_bcn_env->bearer_lid_opened_bf & CO_BIT(p_env->bearer_lid)) == 0)
    9400:	6832      	ldr	r2, [r6, #0]
    9402:	6c11      	ldr	r1, [r2, #64]	; 0x40
    9404:	40d9      	lsrs	r1, r3
    9406:	000b      	movs	r3, r1
    9408:	07db      	lsls	r3, r3, #31
    940a:	d5f4      	bpl.n	93f6 <m_bcn_adv_tx_check+0x98>
        status = M_ERR_BEARER_CLOSED;
    }
    else
    {
        // Keep in mind that transmission is on-going
        SETB(p_env->flags, M_BCN_BUF_IN_TX, 1);
    940c:	2110      	movs	r1, #16
    940e:	7c23      	ldrb	r3, [r4, #16]
        // Push the beacon for transmission
        status = p_m_bcn_env->p_bearer_api->send(M_BEARER_CLI_BEACON, p_buf);
    9410:	2002      	movs	r0, #2
        status = M_ERR_BEARER_CLOSED;
    }
    else
    {
        // Keep in mind that transmission is on-going
        SETB(p_env->flags, M_BCN_BUF_IN_TX, 1);
    9412:	430b      	orrs	r3, r1
    9414:	7423      	strb	r3, [r4, #16]
        // Push the beacon for transmission
        status = p_m_bcn_env->p_bearer_api->send(M_BEARER_CLI_BEACON, p_buf);
    9416:	6813      	ldr	r3, [r2, #0]
    9418:	0021      	movs	r1, r4
    941a:	681b      	ldr	r3, [r3, #0]
    941c:	4798      	blx	r3
    }

    if (status != M_ERR_NO_ERROR)
    941e:	2800      	cmp	r0, #0
    9420:	d100      	bne.n	9424 <m_bcn_adv_tx_check+0xc6>
    9422:	e089      	b.n	9538 <m_bcn_adv_tx_check+0x1da>
    9424:	e7e7      	b.n	93f6 <m_bcn_adv_tx_check+0x98>
    {
        if (GETB(p_env->flags, M_BCN_BUF_ADV) && GETB(p_m_bcn_env->state, M_BCN_STATE_PROV))
    9426:	6832      	ldr	r2, [r6, #0]
    9428:	0011      	movs	r1, r2
    942a:	3145      	adds	r1, #69	; 0x45
    942c:	7809      	ldrb	r1, [r1, #0]
    942e:	4219      	tst	r1, r3
    9430:	d008      	beq.n	9444 <m_bcn_adv_tx_check+0xe6>
        {
            // Get beaconing information structure for the subnet
            m_bcn_info_t *p_info = &p_m_bcn_env->bcn_info[p_env->u9.subnet_lid];
    9432:	1ce3      	adds	r3, r4, #3
    9434:	7fdb      	ldrb	r3, [r3, #31]
    9436:	009b      	lsls	r3, r3, #2
    9438:	18d3      	adds	r3, r2, r3

            // And reset remaining duration before next transmission of a beacon
            p_info->rem_dur = p_info->bcn_intv;
    943a:	001a      	movs	r2, r3
    943c:	333a      	adds	r3, #58	; 0x3a
    943e:	781b      	ldrb	r3, [r3, #0]
    9440:	323b      	adds	r2, #59	; 0x3b
    9442:	7013      	strb	r3, [r2, #0]
        }

        // Consider transmission as done
        SETB(p_env->flags, M_BCN_BUF_IN_TX, 0);
    9444:	2210      	movs	r2, #16
    9446:	7c23      	ldrb	r3, [r4, #16]
    9448:	4393      	bics	r3, r2
    944a:	7423      	strb	r3, [r4, #16]
                break;
            }
        }

        // Check if node is provisioned
        if (GETB(p_m_bcn_env->state, M_BCN_STATE_PROV)
    944c:	6830      	ldr	r0, [r6, #0]
    944e:	0003      	movs	r3, r0
    9450:	3345      	adds	r3, #69	; 0x45
    9452:	781b      	ldrb	r3, [r3, #0]
    9454:	43db      	mvns	r3, r3
    9456:	079b      	lsls	r3, r3, #30
    9458:	d16e      	bne.n	9538 <m_bcn_adv_tx_check+0x1da>
                // And Secure Network Beacon can be sent
                && (GETB(p_m_bcn_env->state, M_BCN_STATE_ENABLE))
                // Buffer not in preparation state
                && (!GETB(p_env->flags, M_BCN_BUF_PREP)))
    945a:	7c21      	ldrb	r1, [r4, #16]
    945c:	074b      	lsls	r3, r1, #29
    945e:	d46b      	bmi.n	9538 <m_bcn_adv_tx_check+0x1da>

            // Find which Secure Network beacon has to be sent
            for (cnt = 0; cnt < M_SUBNET_NB_MAX; cnt++)
            {
                // Get information structure
                m_bcn_info_t *p_info = &p_m_bcn_env->bcn_info[p_env->u9.subnet_lid];
    9460:	1ce7      	adds	r7, r4, #3
    9462:	7ffb      	ldrb	r3, [r7, #31]
    9464:	009a      	lsls	r2, r3, #2
    9466:	1882      	adds	r2, r0, r2
    9468:	469c      	mov	ip, r3

                if ((p_info->net_key_lid != M_INVALID_LID) && (p_info->rem_dur == 0))
    946a:	0013      	movs	r3, r2
    946c:	3338      	adds	r3, #56	; 0x38
    946e:	781b      	ldrb	r3, [r3, #0]
    9470:	2bff      	cmp	r3, #255	; 0xff
    9472:	d004      	beq.n	947e <m_bcn_adv_tx_check+0x120>
    9474:	0013      	movs	r3, r2
    9476:	333b      	adds	r3, #59	; 0x3b
    9478:	781b      	ldrb	r3, [r3, #0]
    947a:	2b00      	cmp	r3, #0
    947c:	d00f      	beq.n	949e <m_bcn_adv_tx_check+0x140>
                    SETB(p_env->flags, M_BCN_BUF_PREP, 1);
                    m_bcn_prep_secure_bcn(p_buf);
                    break;
                }

                p_env->u9.subnet_lid = (p_env->u9.subnet_lid + 1) % M_SUBNET_NB_MAX;
    947e:	4662      	mov	r2, ip
    9480:	2301      	movs	r3, #1
    9482:	3201      	adds	r2, #1
    9484:	401a      	ands	r2, r3
    9486:	0093      	lsls	r3, r2, #2
    9488:	18c3      	adds	r3, r0, r3
            for (cnt = 0; cnt < M_SUBNET_NB_MAX; cnt++)
            {
                // Get information structure
                m_bcn_info_t *p_info = &p_m_bcn_env->bcn_info[p_env->u9.subnet_lid];

                if ((p_info->net_key_lid != M_INVALID_LID) && (p_info->rem_dur == 0))
    948a:	0018      	movs	r0, r3
                    SETB(p_env->flags, M_BCN_BUF_PREP, 1);
                    m_bcn_prep_secure_bcn(p_buf);
                    break;
                }

                p_env->u9.subnet_lid = (p_env->u9.subnet_lid + 1) % M_SUBNET_NB_MAX;
    948c:	77fa      	strb	r2, [r7, #31]
            for (cnt = 0; cnt < M_SUBNET_NB_MAX; cnt++)
            {
                // Get information structure
                m_bcn_info_t *p_info = &p_m_bcn_env->bcn_info[p_env->u9.subnet_lid];

                if ((p_info->net_key_lid != M_INVALID_LID) && (p_info->rem_dur == 0))
    948e:	3038      	adds	r0, #56	; 0x38
    9490:	7800      	ldrb	r0, [r0, #0]
    9492:	28ff      	cmp	r0, #255	; 0xff
    9494:	d04d      	beq.n	9532 <m_bcn_adv_tx_check+0x1d4>
    9496:	333b      	adds	r3, #59	; 0x3b
    9498:	781b      	ldrb	r3, [r3, #0]
    949a:	2b00      	cmp	r3, #0
    949c:	d149      	bne.n	9532 <m_bcn_adv_tx_check+0x1d4>
                {
                    // Prepare the beacon
                    SETB(p_env->flags, M_BCN_BUF_PREP, 1);
    949e:	2304      	movs	r3, #4
    94a0:	4319      	orrs	r1, r3
 * @param[in] p_buf        Pointer to buffer to prepare
 ****************************************************************************************
 */
__STATIC void m_bcn_prep_secure_bcn(m_tb_buf_t *p_buf)
{
	M_PRINTF(L_BCN, "");
    94a2:	682b      	ldr	r3, [r5, #0]
                m_bcn_info_t *p_info = &p_m_bcn_env->bcn_info[p_env->u9.subnet_lid];

                if ((p_info->net_key_lid != M_INVALID_LID) && (p_info->rem_dur == 0))
                {
                    // Prepare the beacon
                    SETB(p_env->flags, M_BCN_BUF_PREP, 1);
    94a4:	7421      	strb	r1, [r4, #16]
 * @param[in] p_buf        Pointer to buffer to prepare
 ****************************************************************************************
 */
__STATIC void m_bcn_prep_secure_bcn(m_tb_buf_t *p_buf)
{
	M_PRINTF(L_BCN, "");
    94a6:	069b      	lsls	r3, r3, #26
    94a8:	d514      	bpl.n	94d4 <m_bcn_adv_tx_check+0x176>
    94aa:	4d25      	ldr	r5, [pc, #148]	; (9540 <m_bcn_adv_tx_check+0x1e2>)
    94ac:	002b      	movs	r3, r5
    94ae:	002a      	movs	r2, r5
    94b0:	0028      	movs	r0, r5
    94b2:	335a      	adds	r3, #90	; 0x5a
    94b4:	0029      	movs	r1, r5
    94b6:	3221      	adds	r2, #33	; 0x21
    94b8:	9300      	str	r3, [sp, #0]
    94ba:	3029      	adds	r0, #41	; 0x29
    94bc:	4b22      	ldr	r3, [pc, #136]	; (9548 <m_bcn_adv_tx_check+0x1ea>)
    94be:	f7fb fa75 	bl	49ac <m_print>
    94c2:	0028      	movs	r0, r5
    94c4:	304b      	adds	r0, #75	; 0x4b
    94c6:	f7fb fa71 	bl	49ac <m_print>
    94ca:	0028      	movs	r0, r5
    94cc:	1da9      	adds	r1, r5, #6
    94ce:	304c      	adds	r0, #76	; 0x4c
    94d0:	f7fb fa6c 	bl	49ac <m_print>
    // Pointer to buffer environment
    m_lay_bearer_buf_env_t *p_env = (m_lay_bearer_buf_env_t *)&p_buf->env[0];
    // Pointer to beaconing information structure for the subnet
    m_bcn_info_t *p_info = &p_m_bcn_env->bcn_info[p_env->u9.subnet_lid];
    // Get pointer to data
    uint8_t *p_data = M_TB_BUF_DATA(p_buf);
    94d4:	0022      	movs	r2, r4
{
	M_PRINTF(L_BCN, "");
    // Pointer to buffer environment
    m_lay_bearer_buf_env_t *p_env = (m_lay_bearer_buf_env_t *)&p_buf->env[0];
    // Pointer to beaconing information structure for the subnet
    m_bcn_info_t *p_info = &p_m_bcn_env->bcn_info[p_env->u9.subnet_lid];
    94d6:	6831      	ldr	r1, [r6, #0]
    // Get pointer to data
    uint8_t *p_data = M_TB_BUF_DATA(p_buf);
    94d8:	88a5      	ldrh	r5, [r4, #4]
    94da:	3230      	adds	r2, #48	; 0x30
    94dc:	1955      	adds	r5, r2, r5
    uint8_t *p_network_id;
    // Flags
    uint8_t flags;

    // Sanity checks - Bearer is opened
    ASSERT_ERR(p_m_bcn_env->adv_bearer_lid != M_INVALID_LID);
    94de:	000a      	movs	r2, r1
    94e0:	3244      	adds	r2, #68	; 0x44
    94e2:	7812      	ldrb	r2, [r2, #0]
{
	M_PRINTF(L_BCN, "");
    // Pointer to buffer environment
    m_lay_bearer_buf_env_t *p_env = (m_lay_bearer_buf_env_t *)&p_buf->env[0];
    // Pointer to beaconing information structure for the subnet
    m_bcn_info_t *p_info = &p_m_bcn_env->bcn_info[p_env->u9.subnet_lid];
    94e4:	7ffb      	ldrb	r3, [r7, #31]
    uint8_t *p_network_id;
    // Flags
    uint8_t flags;

    // Sanity checks - Bearer is opened
    ASSERT_ERR(p_m_bcn_env->adv_bearer_lid != M_INVALID_LID);
    94e6:	2aff      	cmp	r2, #255	; 0xff
    94e8:	d100      	bne.n	94ec <m_bcn_adv_tx_check+0x18e>
    94ea:	e7fe      	b.n	94ea <m_bcn_adv_tx_check+0x18c>

    // Retrieve information to insert in the beacon from the key manager
    m_tb_key_get_net_info(p_info->net_key_lid, &iv, &p_network_id, &flags);
    94ec:	260f      	movs	r6, #15
    94ee:	330e      	adds	r3, #14
    94f0:	446e      	add	r6, sp
    94f2:	009b      	lsls	r3, r3, #2
    94f4:	5c58      	ldrb	r0, [r3, r1]
    94f6:	aa05      	add	r2, sp, #20
    94f8:	0033      	movs	r3, r6
    94fa:	a904      	add	r1, sp, #16
    94fc:	f009 fd22 	bl	12f44 <m_tb_key_get_net_info>

    // Set length
    p_buf->data_len = M_BCN_SECURE_BCN_LEN;
    9500:	2316      	movs	r3, #22
    9502:	8123      	strh	r3, [r4, #8]

    // Set beacon type
    *(p_data + M_BCN_SECURE_BCN_TYPE_POS) = M_BCN_SECURE_BCN_TYPE;
    9504:	3b15      	subs	r3, #21
    9506:	702b      	strb	r3, [r5, #0]

    // Write Flags
    *(p_data + M_BCN_SECURE_BCN_FLAGS_POS) = flags;
    9508:	7833      	ldrb	r3, [r6, #0]
    // Write Network ID
    co_bswap(p_data + M_BCN_SECURE_BCN_NET_ID_POS, p_network_id, M_NET_ID_LEN);
    950a:	1ca8      	adds	r0, r5, #2

    // Set beacon type
    *(p_data + M_BCN_SECURE_BCN_TYPE_POS) = M_BCN_SECURE_BCN_TYPE;

    // Write Flags
    *(p_data + M_BCN_SECURE_BCN_FLAGS_POS) = flags;
    950c:	706b      	strb	r3, [r5, #1]
    // Write Network ID
    co_bswap(p_data + M_BCN_SECURE_BCN_NET_ID_POS, p_network_id, M_NET_ID_LEN);
    950e:	2208      	movs	r2, #8
    9510:	9905      	ldr	r1, [sp, #20]
    9512:	f7ff ff19 	bl	9348 <co_bswap>
__INLINE_S__ uint32_t co_htonl(uint32_t hostlong)
{
    #if (!CPU_LE)
        return hostlong;
    #else
        return co_bswap32(hostlong);
    9516:	9804      	ldr	r0, [sp, #16]
    9518:	f7ff ff1f 	bl	935a <co_bswap32>
__INLINE_S__ void co_write32p(void const *ptr32, uint32_t value)
{
    uint8_t *ptr=(uint8_t*)ptr32;

    *ptr++ = (uint8_t)(value&0xff);
    *ptr++ = (uint8_t)((value&0xff00)>>8);
    951c:	0a03      	lsrs	r3, r0, #8
 */
__INLINE_S__ void co_write32p(void const *ptr32, uint32_t value)
{
    uint8_t *ptr=(uint8_t*)ptr32;

    *ptr++ = (uint8_t)(value&0xff);
    951e:	72a8      	strb	r0, [r5, #10]
    *ptr++ = (uint8_t)((value&0xff00)>>8);
    9520:	72eb      	strb	r3, [r5, #11]
    *ptr++ = (uint8_t)((value&0xff0000)>>16);
    9522:	0c03      	lsrs	r3, r0, #16
    *ptr = (uint8_t)((value&0xff000000)>>24);
    9524:	0e00      	lsrs	r0, r0, #24
    9526:	7368      	strb	r0, [r5, #13]
{
    uint8_t *ptr=(uint8_t*)ptr32;

    *ptr++ = (uint8_t)(value&0xff);
    *ptr++ = (uint8_t)((value&0xff00)>>8);
    *ptr++ = (uint8_t)((value&0xff0000)>>16);
    9528:	732b      	strb	r3, [r5, #12]
    // Write IV
    co_write32p(p_data + M_BCN_SECURE_BCN_IV_INDEX_POS, co_htonl(iv));

    // Push the buffer in the encryption queue
    m_bcn_insert_encrypt_queue(p_buf);
    952a:	0020      	movs	r0, r4
    952c:	f000 f8a2 	bl	9674 <m_bcn_insert_encrypt_queue>
    9530:	e002      	b.n	9538 <m_bcn_adv_tx_check+0x1da>
                    SETB(p_env->flags, M_BCN_BUF_PREP, 1);
                    m_bcn_prep_secure_bcn(p_buf);
                    break;
                }

                p_env->u9.subnet_lid = (p_env->u9.subnet_lid + 1) % M_SUBNET_NB_MAX;
    9532:	2301      	movs	r3, #1
    9534:	405a      	eors	r2, r3
    9536:	77fa      	strb	r2, [r7, #31]
            }
        }
    } while(0);
}
    9538:	b007      	add	sp, #28
    953a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    953c:	10010514 	.word	0x10010514
    9540:	0002132c 	.word	0x0002132c
    9544:	1001269c 	.word	0x1001269c
    9548:	00000281 	.word	0x00000281

0000954c <m_bcn_cmac_ready_cb>:
 * will be called once the encryption has been performed.
 ****************************************************************************************
 */
__STATIC uint16_t m_bcn_cmac_ready_cb(uint8_t token_id, const uint8_t **pp_key, const uint8_t **pp_msg,
                                      uint16_t *p_msg_len)
{
    954c:	b5f0      	push	{r4, r5, r6, r7, lr}
    954e:	b087      	sub	sp, #28
    9550:	9202      	str	r2, [sp, #8]
        uint8_t *p_data = M_TB_BUF_DATA(p_buf);
        // Network key information
        const m_tb_key_net_t *p_net_key;

        // Retrieve network key information
        status = m_tb_key_net_get(M_TB_KEY_GET_NET_KEY_LID(p_env->u9.subnet_lid),
    9552:	2201      	movs	r2, #1
                                      uint16_t *p_msg_len)
{
    // Status
    uint16_t status;
    // Retrieve buffer containing the beacon
    m_tb_buf_t *p_buf = (m_tb_buf_t *)co_list_pick(&p_m_bcn_env->encrypt_queue);
    9554:	4c13      	ldr	r4, [pc, #76]	; (95a4 <m_bcn_cmac_ready_cb+0x58>)
 * will be called once the encryption has been performed.
 ****************************************************************************************
 */
__STATIC uint16_t m_bcn_cmac_ready_cb(uint8_t token_id, const uint8_t **pp_key, const uint8_t **pp_msg,
                                      uint16_t *p_msg_len)
{
    9556:	9303      	str	r3, [sp, #12]
    9558:	6823      	ldr	r3, [r4, #0]
    955a:	000f      	movs	r7, r1
    955c:	6add      	ldr	r5, [r3, #44]	; 0x2c
        uint8_t *p_data = M_TB_BUF_DATA(p_buf);
        // Network key information
        const m_tb_key_net_t *p_net_key;

        // Retrieve network key information
        status = m_tb_key_net_get(M_TB_KEY_GET_NET_KEY_LID(p_env->u9.subnet_lid),
    955e:	a905      	add	r1, sp, #20
    do
    {
        // Get pointer to buffer environment
        m_lay_bearer_buf_env_t *p_env = (m_lay_bearer_buf_env_t *)&p_buf->env[0];
        // Get pointer to received data
        uint8_t *p_data = M_TB_BUF_DATA(p_buf);
    9560:	88ab      	ldrh	r3, [r5, #4]
    9562:	9301      	str	r3, [sp, #4]
        // Network key information
        const m_tb_key_net_t *p_net_key;

        // Retrieve network key information
        status = m_tb_key_net_get(M_TB_KEY_GET_NET_KEY_LID(p_env->u9.subnet_lid),
    9564:	7c2b      	ldrb	r3, [r5, #16]
    9566:	439a      	bics	r2, r3
    9568:	1ceb      	adds	r3, r5, #3
    956a:	7fd8      	ldrb	r0, [r3, #31]
    956c:	3001      	adds	r0, #1
    956e:	b2c0      	uxtb	r0, r0
    9570:	f008 fed0 	bl	12314 <m_tb_key_net_get>
    9574:	1e06      	subs	r6, r0, #0
                                  &p_net_key, !GETB(p_env->flags, M_BCN_BUF_RX));

        if (status != M_ERR_NO_ERROR)
    9576:	d111      	bne.n	959c <m_bcn_cmac_ready_cb+0x50>
        {
            break;
        }

        // Reverse all bytes for AES-CMAC block
        co_bswap(p_m_bcn_env->rev_buf, &p_data[M_BCN_SECURE_BCN_FLAGS_POS], M_BCN_SECURE_BCN_CMAC_LEN);
    9578:	9b01      	ldr	r3, [sp, #4]
    957a:	6824      	ldr	r4, [r4, #0]
    957c:	18ed      	adds	r5, r5, r3
    957e:	0029      	movs	r1, r5
    9580:	3446      	adds	r4, #70	; 0x46
    9582:	220d      	movs	r2, #13
    9584:	3131      	adds	r1, #49	; 0x31
    9586:	0020      	movs	r0, r4
    9588:	f7ff fede 	bl	9348 <co_bswap>

        // Provide the requested information
        *pp_key = &p_net_key->beacon_key[0];
    958c:	9b05      	ldr	r3, [sp, #20]
        *pp_msg = &p_m_bcn_env->rev_buf[0];
        *p_msg_len = M_BCN_SECURE_BCN_CMAC_LEN;
    958e:	9a03      	ldr	r2, [sp, #12]

        // Reverse all bytes for AES-CMAC block
        co_bswap(p_m_bcn_env->rev_buf, &p_data[M_BCN_SECURE_BCN_FLAGS_POS], M_BCN_SECURE_BCN_CMAC_LEN);

        // Provide the requested information
        *pp_key = &p_net_key->beacon_key[0];
    9590:	3332      	adds	r3, #50	; 0x32
    9592:	603b      	str	r3, [r7, #0]
        *pp_msg = &p_m_bcn_env->rev_buf[0];
    9594:	9b02      	ldr	r3, [sp, #8]
    9596:	601c      	str	r4, [r3, #0]
        *p_msg_len = M_BCN_SECURE_BCN_CMAC_LEN;
    9598:	230d      	movs	r3, #13
    959a:	8013      	strh	r3, [r2, #0]
    } while (0);

    return (status);
}
    959c:	0030      	movs	r0, r6
    959e:	b007      	add	sp, #28
    95a0:	bdf0      	pop	{r4, r5, r6, r7, pc}
    95a2:	46c0      	nop			; (mov r8, r8)
    95a4:	1001269c 	.word	0x1001269c

000095a8 <m_bcn_cmac_finished_cb>:
 * @param[in] status            Encryption status
 * @param[in] p_auth_val        Pointer to computed authentication value
 ****************************************************************************************
 */
__STATIC void m_bcn_cmac_finished_cb(uint8_t token_id, uint16_t status, const uint8_t *p_auth_val)
{
    95a8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    // Retrieve buffer containing the beacon
    m_tb_buf_t *p_buf = (m_tb_buf_t *)co_list_pop_front(&p_m_bcn_env->encrypt_queue);
    95aa:	4e2f      	ldr	r6, [pc, #188]	; (9668 <m_bcn_cmac_finished_cb+0xc0>)
 * @param[in] status            Encryption status
 * @param[in] p_auth_val        Pointer to computed authentication value
 ****************************************************************************************
 */
__STATIC void m_bcn_cmac_finished_cb(uint8_t token_id, uint16_t status, const uint8_t *p_auth_val)
{
    95ac:	0015      	movs	r5, r2
    // Retrieve buffer containing the beacon
    m_tb_buf_t *p_buf = (m_tb_buf_t *)co_list_pop_front(&p_m_bcn_env->encrypt_queue);
    95ae:	6830      	ldr	r0, [r6, #0]
 * @param[in] status            Encryption status
 * @param[in] p_auth_val        Pointer to computed authentication value
 ****************************************************************************************
 */
__STATIC void m_bcn_cmac_finished_cb(uint8_t token_id, uint16_t status, const uint8_t *p_auth_val)
{
    95b0:	000f      	movs	r7, r1
    // Retrieve buffer containing the beacon
    m_tb_buf_t *p_buf = (m_tb_buf_t *)co_list_pop_front(&p_m_bcn_env->encrypt_queue);
    95b2:	302c      	adds	r0, #44	; 0x2c
    95b4:	f7fa ff1a 	bl	43ec <co_list_pop_front>
    95b8:	0004      	movs	r4, r0
    // Point to buffer environment
    m_lay_bearer_buf_env_t *p_env = (m_lay_bearer_buf_env_t *)&p_buf->env[0];
    // Get pointer to received data
    uint8_t *p_data = M_TB_BUF_DATA(p_buf);
    95ba:	88a3      	ldrh	r3, [r4, #4]

    if (!GETB(p_env->flags, M_BCN_BUF_RX))
    95bc:	7c22      	ldrb	r2, [r4, #16]
    // Retrieve buffer containing the beacon
    m_tb_buf_t *p_buf = (m_tb_buf_t *)co_list_pop_front(&p_m_bcn_env->encrypt_queue);
    // Point to buffer environment
    m_lay_bearer_buf_env_t *p_env = (m_lay_bearer_buf_env_t *)&p_buf->env[0];
    // Get pointer to received data
    uint8_t *p_data = M_TB_BUF_DATA(p_buf);
    95be:	3030      	adds	r0, #48	; 0x30
    95c0:	18c3      	adds	r3, r0, r3

    if (!GETB(p_env->flags, M_BCN_BUF_RX))
    95c2:	07d1      	lsls	r1, r2, #31
    95c4:	d412      	bmi.n	95ec <m_bcn_cmac_finished_cb+0x44>
    {
        SETB(p_env->flags, M_BCN_BUF_PREP, false);
    95c6:	2104      	movs	r1, #4
    95c8:	438a      	bics	r2, r1
    95ca:	7422      	strb	r2, [r4, #16]

        if (status == M_ERR_NO_ERROR)
    95cc:	2f00      	cmp	r7, #0
    95ce:	d10a      	bne.n	95e6 <m_bcn_cmac_finished_cb+0x3e>
        {
            // Copy the authentication value in the buffer
            co_bswap(&p_data[M_BCN_SECURE_BCN_AUTH_VAL_POS],
    95d0:	0029      	movs	r1, r5
    95d2:	330e      	adds	r3, #14
    95d4:	0018      	movs	r0, r3
    95d6:	2208      	movs	r2, #8
    95d8:	3108      	adds	r1, #8
    95da:	f7ff feb5 	bl	9348 <co_bswap>
                     &p_auth_val[M_KEY_LEN-M_BCN_SECURE_BCN_AUTH_VAL_LEN],
                     M_BCN_SECURE_BCN_AUTH_VAL_LEN);

            // Mark buffer as ready to be sent
            SETB(p_env->flags, M_BCN_BUF_RTS, 1);
    95de:	2208      	movs	r2, #8
    95e0:	7c23      	ldrb	r3, [r4, #16]
    95e2:	4313      	orrs	r3, r2
    95e4:	7423      	strb	r3, [r4, #16]
        }
        else
        #endif //(BLE_MESH_GATT_PROXY)
        // Advertising TX Buffer
        {
            m_bcn_adv_tx_check();
    95e6:	f7ff feba 	bl	935e <m_bcn_adv_tx_check>
    95ea:	e033      	b.n	9654 <m_bcn_cmac_finished_cb+0xac>
        }
    }
    else
    {
        if (status == M_ERR_NO_ERROR)
    95ec:	2f00      	cmp	r7, #0
    95ee:	d12e      	bne.n	964e <m_bcn_cmac_finished_cb+0xa6>
    95f0:	001a      	movs	r2, r3
    95f2:	0019      	movs	r1, r3
    95f4:	320e      	adds	r2, #14
    95f6:	350f      	adds	r5, #15
    95f8:	3116      	adds	r1, #22
            uint8_t cnt;

            // Compare received authentication value with computed one
            for (cnt = 0; cnt < M_BCN_SECURE_BCN_AUTH_VAL_LEN; cnt++)
            {
                if (p_rx_auth_val[cnt] != p_auth_val[M_KEY_LEN - 1 - cnt])
    95fa:	7817      	ldrb	r7, [r2, #0]
    95fc:	7828      	ldrb	r0, [r5, #0]
    95fe:	4287      	cmp	r7, r0
    9600:	d125      	bne.n	964e <m_bcn_cmac_finished_cb+0xa6>
    9602:	3201      	adds	r2, #1
    9604:	3d01      	subs	r5, #1
            uint8_t *p_rx_auth_val = p_data + M_BCN_SECURE_BCN_AUTH_VAL_POS;
            // Counter
            uint8_t cnt;

            // Compare received authentication value with computed one
            for (cnt = 0; cnt < M_BCN_SECURE_BCN_AUTH_VAL_LEN; cnt++)
    9606:	428a      	cmp	r2, r1
    9608:	d1f7      	bne.n	95fa <m_bcn_cmac_finished_cb+0x52>
    960a:	7b58      	ldrb	r0, [r3, #13]
    960c:	7b19      	ldrb	r1, [r3, #12]
    960e:	0200      	lsls	r0, r0, #8
    9610:	7ada      	ldrb	r2, [r3, #11]
    9612:	4308      	orrs	r0, r1
    9614:	0401      	lsls	r1, r0, #16
    9616:	7a98      	ldrb	r0, [r3, #10]
    9618:	0212      	lsls	r2, r2, #8
    961a:	4310      	orrs	r0, r2
    961c:	4308      	orrs	r0, r1
            }

            if (cnt == M_BCN_SECURE_BCN_AUTH_VAL_LEN)
            {
                // Read flags
                uint8_t flags = *(p_data + M_BCN_SECURE_BCN_FLAGS_POS);
    961e:	785d      	ldrb	r5, [r3, #1]
    9620:	f7ff fe9b 	bl	935a <co_bswap32>
    9624:	0002      	movs	r2, r0
                // Read IV
                uint32_t iv = co_ntohl(co_read32p(p_data + M_BCN_SECURE_BCN_IV_INDEX_POS));

                if (GETB(p_m_bcn_env->state, M_BCN_STATE_ENABLE))
    9626:	6830      	ldr	r0, [r6, #0]
    9628:	1ce1      	adds	r1, r4, #3
    962a:	0003      	movs	r3, r0
    962c:	3345      	adds	r3, #69	; 0x45
    962e:	781b      	ldrb	r3, [r3, #0]
    9630:	07db      	lsls	r3, r3, #31
    9632:	d506      	bpl.n	9642 <m_bcn_cmac_finished_cb+0x9a>
                {
                    // Get information structure
                    m_bcn_info_t *p_info = &p_m_bcn_env->bcn_info[p_env->u9.subnet_lid];
    9634:	7fcb      	ldrb	r3, [r1, #31]
    9636:	009b      	lsls	r3, r3, #2
    9638:	18c3      	adds	r3, r0, r3

                    // Increase number of valid received beacons
                    p_info->nb_rx_snb++;
    963a:	3339      	adds	r3, #57	; 0x39
    963c:	7818      	ldrb	r0, [r3, #0]
    963e:	3001      	adds	r0, #1
    9640:	7018      	strb	r0, [r3, #0]
                }

                // Inform the key manager about valid reception of a secure network beacon
                m_tb_key_secure_bcn_rx_ind(M_TB_KEY_GET_NET_KEY_LID(p_env->u9.subnet_lid), flags, iv);
    9642:	7fc8      	ldrb	r0, [r1, #31]
    9644:	0029      	movs	r1, r5
    9646:	3001      	adds	r0, #1
    9648:	b2c0      	uxtb	r0, r0
    964a:	f009 fbc9 	bl	12de0 <m_tb_key_secure_bcn_rx_ind>
            }
        }

        // Release the buffer
        m_tb_buf_release(p_buf);
    964e:	0020      	movs	r0, r4
    9650:	f008 f824 	bl	1169c <m_tb_buf_release>
    9654:	6833      	ldr	r3, [r6, #0]
    }

    // Check if a buffer must be processed
    if (co_list_pick(&p_m_bcn_env->encrypt_queue))
    9656:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    9658:	2b00      	cmp	r3, #0
    965a:	d004      	beq.n	9666 <m_bcn_cmac_finished_cb+0xbe>
    {
        m_tb_sec_cmac_start(M_TB_SEC_TOKEN_BEACONING, m_bcn_cmac_ready_cb, m_bcn_cmac_finished_cb);
    965c:	4a03      	ldr	r2, [pc, #12]	; (966c <m_bcn_cmac_finished_cb+0xc4>)
    965e:	4904      	ldr	r1, [pc, #16]	; (9670 <m_bcn_cmac_finished_cb+0xc8>)
    9660:	2006      	movs	r0, #6
    9662:	f00a fc9e 	bl	13fa2 <m_tb_sec_cmac_start>
    }
}
    9666:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    9668:	1001269c 	.word	0x1001269c
    966c:	000095a9 	.word	0x000095a9
    9670:	0000954d 	.word	0x0000954d

00009674 <m_bcn_insert_encrypt_queue>:
 *
 * @param[in] p_buf       Pointer to the buffer to insert
 ****************************************************************************************
 */
__STATIC void m_bcn_insert_encrypt_queue(m_tb_buf_t *p_buf)
{
    9674:	b570      	push	{r4, r5, r6, lr}
    9676:	0004      	movs	r4, r0
    // Push the buffer in the encryption queue
    co_list_push_back(&p_m_bcn_env->encrypt_queue, &p_buf->hdr);
    9678:	4d07      	ldr	r5, [pc, #28]	; (9698 <m_bcn_insert_encrypt_queue+0x24>)
    967a:	0021      	movs	r1, r4
    967c:	6828      	ldr	r0, [r5, #0]
    967e:	302c      	adds	r0, #44	; 0x2c
    9680:	f7fa fe89 	bl	4396 <co_list_push_back>
    9684:	682b      	ldr	r3, [r5, #0]

    // If buffer is the first element in the encryption queue, request to start AES-CMAC
    if ((m_tb_buf_t *)co_list_pick(&p_m_bcn_env->encrypt_queue) == p_buf)
    9686:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    9688:	429c      	cmp	r4, r3
    968a:	d104      	bne.n	9696 <m_bcn_insert_encrypt_queue+0x22>
    {
        m_tb_sec_cmac_start(M_TB_SEC_TOKEN_BEACONING, m_bcn_cmac_ready_cb, m_bcn_cmac_finished_cb);
    968c:	4a03      	ldr	r2, [pc, #12]	; (969c <m_bcn_insert_encrypt_queue+0x28>)
    968e:	4904      	ldr	r1, [pc, #16]	; (96a0 <m_bcn_insert_encrypt_queue+0x2c>)
    9690:	2006      	movs	r0, #6
    9692:	f00a fc86 	bl	13fa2 <m_tb_sec_cmac_start>
    }
}
    9696:	bd70      	pop	{r4, r5, r6, pc}
    9698:	1001269c 	.word	0x1001269c
    969c:	000095a9 	.word	0x000095a9
    96a0:	0000954d 	.word	0x0000954d

000096a4 <m_bcn_cb_rx>:
 *
 * @param[in] p_buf             Pointer to the buffer containing the received beacon.
 ****************************************************************************************
 */
__STATIC void m_bcn_cb_rx(m_tb_buf_t *p_buf)
{
    96a4:	b573      	push	{r0, r1, r4, r5, r6, lr}
	m_printf_hex(L_BCN, "beacon data recved", M_TB_BUF_DATA(p_buf), p_buf->data_len);
    96a6:	0006      	movs	r6, r0
    96a8:	8882      	ldrh	r2, [r0, #4]
    96aa:	491c      	ldr	r1, [pc, #112]	; (971c <m_bcn_cb_rx+0x78>)
    96ac:	3630      	adds	r6, #48	; 0x30
    96ae:	8903      	ldrh	r3, [r0, #8]
 *
 * @param[in] p_buf             Pointer to the buffer containing the received beacon.
 ****************************************************************************************
 */
__STATIC void m_bcn_cb_rx(m_tb_buf_t *p_buf)
{
    96b0:	0004      	movs	r4, r0
	m_printf_hex(L_BCN, "beacon data recved", M_TB_BUF_DATA(p_buf), p_buf->data_len);
    96b2:	18b2      	adds	r2, r6, r2
    96b4:	3170      	adds	r1, #112	; 0x70
    96b6:	2020      	movs	r0, #32
    96b8:	f7fb f9d8 	bl	4a6c <m_printf_hex>
    // Get buffer environment
    m_lay_bearer_buf_env_t *p_env = (m_lay_bearer_buf_env_t *)&p_buf->env[0];

    // Check bearer local index and we are provisioned
    if ((p_env->bearer_lid == p_m_bcn_env->adv_bearer_lid)
    96bc:	4b18      	ldr	r3, [pc, #96]	; (9720 <m_bcn_cb_rx+0x7c>)
    96be:	7c61      	ldrb	r1, [r4, #17]
    96c0:	681b      	ldr	r3, [r3, #0]
    96c2:	001a      	movs	r2, r3
    96c4:	3244      	adds	r2, #68	; 0x44
    96c6:	7812      	ldrb	r2, [r2, #0]
    96c8:	4291      	cmp	r1, r2
    96ca:	d125      	bne.n	9718 <m_bcn_cb_rx+0x74>
            && GETB(p_m_bcn_env->state, M_BCN_STATE_PROV))
    96cc:	2502      	movs	r5, #2
    96ce:	3345      	adds	r3, #69	; 0x45
    96d0:	781b      	ldrb	r3, [r3, #0]
    96d2:	422b      	tst	r3, r5
    96d4:	d020      	beq.n	9718 <m_bcn_cb_rx+0x74>
    {
        // Get beacon type
        uint8_t bcn_type = *(M_TB_BUF_DATA(p_buf) + M_BCN_SECURE_BCN_TYPE_POS);
    96d6:	88a3      	ldrh	r3, [r4, #4]

        // Check if a Secure Network Beacon has been received
        if (bcn_type == M_BCN_SECURE_BCN_TYPE)
    96d8:	5cf2      	ldrb	r2, [r6, r3]
    96da:	2a01      	cmp	r2, #1
    96dc:	d11c      	bne.n	9718 <m_bcn_cb_rx+0x74>
        {
            uint8_t net_id[M_NET_ID_LEN];

            // Retrieve Network ID value
            co_bswap(net_id, M_TB_BUF_DATA(p_buf) + M_BCN_SECURE_BCN_NET_ID_POS, M_NET_ID_LEN);
    96de:	1959      	adds	r1, r3, r5
    96e0:	1871      	adds	r1, r6, r1
    96e2:	4668      	mov	r0, sp
    96e4:	3207      	adds	r2, #7
    96e6:	f7ff fe2f 	bl	9348 <co_bswap>

            SETB(p_env->flags, M_BCN_BUF_ADV, 0);

            // Look for network key with received network ID
            if (m_tb_key_get_net_from_net_id(&net_id[0], &p_env->u9.net_key_lid) == M_ERR_NO_ERROR)
    96ea:	0021      	movs	r1, r4
            uint8_t net_id[M_NET_ID_LEN];

            // Retrieve Network ID value
            co_bswap(net_id, M_TB_BUF_DATA(p_buf) + M_BCN_SECURE_BCN_NET_ID_POS, M_NET_ID_LEN);

            SETB(p_env->flags, M_BCN_BUF_ADV, 0);
    96ec:	7c23      	ldrb	r3, [r4, #16]

            // Look for network key with received network ID
            if (m_tb_key_get_net_from_net_id(&net_id[0], &p_env->u9.net_key_lid) == M_ERR_NO_ERROR)
    96ee:	3122      	adds	r1, #34	; 0x22
            uint8_t net_id[M_NET_ID_LEN];

            // Retrieve Network ID value
            co_bswap(net_id, M_TB_BUF_DATA(p_buf) + M_BCN_SECURE_BCN_NET_ID_POS, M_NET_ID_LEN);

            SETB(p_env->flags, M_BCN_BUF_ADV, 0);
    96f0:	43ab      	bics	r3, r5
    96f2:	7423      	strb	r3, [r4, #16]

            // Look for network key with received network ID
            if (m_tb_key_get_net_from_net_id(&net_id[0], &p_env->u9.net_key_lid) == M_ERR_NO_ERROR)
    96f4:	4668      	mov	r0, sp
    96f6:	f009 fb31 	bl	12d5c <m_tb_key_get_net_from_net_id>
    96fa:	2800      	cmp	r0, #0
    96fc:	d10c      	bne.n	9718 <m_bcn_cb_rx+0x74>
            {
                // Acquire buffer
                m_tb_buf_acquire(p_buf);
    96fe:	0020      	movs	r0, r4
    9700:	f007 ffc8 	bl	11694 <m_tb_buf_acquire>

                // Update environment
                p_env->u9.subnet_lid = M_TB_KEY_GET_SUBNET_LID(p_env->u9.net_key_lid);
    9704:	1ce2      	adds	r2, r4, #3
    9706:	7fd3      	ldrb	r3, [r2, #31]
                SETB(p_env->flags, M_BCN_BUF_ADV, 1);

                // Push the buffer in the encryption queue
                m_bcn_insert_encrypt_queue(p_buf);
    9708:	0020      	movs	r0, r4
            {
                // Acquire buffer
                m_tb_buf_acquire(p_buf);

                // Update environment
                p_env->u9.subnet_lid = M_TB_KEY_GET_SUBNET_LID(p_env->u9.net_key_lid);
    970a:	3b01      	subs	r3, #1
    970c:	77d3      	strb	r3, [r2, #31]
                SETB(p_env->flags, M_BCN_BUF_ADV, 1);
    970e:	7c23      	ldrb	r3, [r4, #16]
    9710:	431d      	orrs	r5, r3
    9712:	7425      	strb	r5, [r4, #16]

                // Push the buffer in the encryption queue
                m_bcn_insert_encrypt_queue(p_buf);
    9714:	f7ff ffae 	bl	9674 <m_bcn_insert_encrypt_queue>
            }
        }
    }
}
    9718:	bd73      	pop	{r0, r1, r4, r5, r6, pc}
    971a:	46c0      	nop			; (mov r8, r8)
    971c:	0002132c 	.word	0x0002132c
    9720:	1001269c 	.word	0x1001269c

00009724 <m_bcn_cb_sent>:
 * @param[in] p_buf             Pointer to the buffer containing the sent PDU.
 * @param[in] status            Transmission status.
 ****************************************************************************************
 */
__STATIC void m_bcn_cb_sent(m_tb_buf_t *p_buf, uint16_t status)
{
    9724:	b510      	push	{r4, lr}
    // Point to buffer environment
    m_lay_bearer_buf_env_t *p_env = (m_lay_bearer_buf_env_t *)p_buf->env;

    // No more TX in progress
    SETB(p_env->flags, M_BCN_BUF_IN_TX, 0);
    9726:	7c02      	ldrb	r2, [r0, #16]
    9728:	2310      	movs	r3, #16
    972a:	0011      	movs	r1, r2
    972c:	4399      	bics	r1, r3

    if (GETB(p_env->flags, M_BCN_BUF_ADV))
    972e:	2302      	movs	r3, #2
{
    // Point to buffer environment
    m_lay_bearer_buf_env_t *p_env = (m_lay_bearer_buf_env_t *)p_buf->env;

    // No more TX in progress
    SETB(p_env->flags, M_BCN_BUF_IN_TX, 0);
    9730:	7401      	strb	r1, [r0, #16]

    if (GETB(p_env->flags, M_BCN_BUF_ADV))
    9732:	421a      	tst	r2, r3
    9734:	d011      	beq.n	975a <m_bcn_cb_sent+0x36>
    {
        if (GETB(p_m_bcn_env->state, M_BCN_STATE_PROV))
    9736:	4a09      	ldr	r2, [pc, #36]	; (975c <m_bcn_cb_sent+0x38>)
    9738:	6812      	ldr	r2, [r2, #0]
    973a:	0011      	movs	r1, r2
    973c:	3145      	adds	r1, #69	; 0x45
    973e:	7809      	ldrb	r1, [r1, #0]
    9740:	4219      	tst	r1, r3
    9742:	d008      	beq.n	9756 <m_bcn_cb_sent+0x32>
        {
            // Get beaconing information structure
            m_bcn_info_t *p_info = &p_m_bcn_env->bcn_info[p_env->u9.subnet_lid];
    9744:	3003      	adds	r0, #3
    9746:	7fc3      	ldrb	r3, [r0, #31]
    9748:	009b      	lsls	r3, r3, #2
    974a:	18d3      	adds	r3, r2, r3

            // And reset remaining duration before next transmission
            p_info->rem_dur = p_info->bcn_intv;
    974c:	001a      	movs	r2, r3
    974e:	333a      	adds	r3, #58	; 0x3a
    9750:	781b      	ldrb	r3, [r3, #0]
    9752:	323b      	adds	r2, #59	; 0x3b
    9754:	7013      	strb	r3, [r2, #0]
        }

        m_bcn_adv_tx_check();
    9756:	f7ff fe02 	bl	935e <m_bcn_adv_tx_check>
    else
    {
        m_bcn_proxy_tx_check();
    }
    #endif //(BLE_MESH_GATT_PROXY)
}
    975a:	bd10      	pop	{r4, pc}
    975c:	1001269c 	.word	0x1001269c

00009760 <m_bcn_cb_opened>:
 ****************************************************************************************
 */
__STATIC void m_bcn_cb_opened(uint8_t bearer_lid, uint8_t type)
{
    // Update opened bearer bit field
    p_m_bcn_env->bearer_lid_opened_bf |= CO_BIT(bearer_lid);
    9760:	2201      	movs	r2, #1
    9762:	4082      	lsls	r2, r0
    9764:	4b14      	ldr	r3, [pc, #80]	; (97b8 <m_bcn_cb_opened+0x58>)
 * @param[in] bearer_lid        Bearer local index
 * @param[in] type              Bearer type
 ****************************************************************************************
 */
__STATIC void m_bcn_cb_opened(uint8_t bearer_lid, uint8_t type)
{
    9766:	b570      	push	{r4, r5, r6, lr}
    // Update opened bearer bit field
    p_m_bcn_env->bearer_lid_opened_bf |= CO_BIT(bearer_lid);
    9768:	681b      	ldr	r3, [r3, #0]
    976a:	6c1c      	ldr	r4, [r3, #64]	; 0x40
    976c:	4322      	orrs	r2, r4
    976e:	641a      	str	r2, [r3, #64]	; 0x40

    // Register advertising bearer
    if ((p_m_bcn_env->adv_bearer_lid == M_INVALID_LID) && (type == M_BEARER_TYPE_ADV))
    9770:	001a      	movs	r2, r3
    9772:	3244      	adds	r2, #68	; 0x44
    9774:	7815      	ldrb	r5, [r2, #0]
    9776:	1d1c      	adds	r4, r3, #4
    9778:	2dff      	cmp	r5, #255	; 0xff
    977a:	d11c      	bne.n	97b6 <m_bcn_cb_opened+0x56>
    977c:	2900      	cmp	r1, #0
    977e:	d11a      	bne.n	97b6 <m_bcn_cb_opened+0x56>
    {
        // Keep provided bearer local index
        p_m_bcn_env->adv_bearer_lid = bearer_lid;
    9780:	7010      	strb	r0, [r2, #0]

        if (GETB(p_m_bcn_env->state, M_BCN_STATE_TX_UNPROV))
    9782:	3201      	adds	r2, #1
    9784:	7812      	ldrb	r2, [r2, #0]
    9786:	0751      	lsls	r1, r2, #29
    9788:	d50c      	bpl.n	97a4 <m_bcn_cb_opened+0x44>
{
    // Point to buffer environment
    m_lay_bearer_buf_env_t *p_env = (m_lay_bearer_buf_env_t *)p_buf->env;

    // Update RTS bit
    SETB(p_env->flags, M_BCN_BUF_RTS, enable);
    978a:	2008      	movs	r0, #8
        p_m_bcn_env->adv_bearer_lid = bearer_lid;

        if (GETB(p_m_bcn_env->state, M_BCN_STATE_TX_UNPROV))
        {
            // mark that buffer ready to send
            m_bcn_buf_rts_set(p_m_bcn_env->p_adv_buf_bcn, true);
    978c:	6b59      	ldr	r1, [r3, #52]	; 0x34
            m_tb_timer_set(&p_m_bcn_env->timer_bcn, M_BCN_DEFAULT_UNPROV_BCN_INTV_MS);
    978e:	3318      	adds	r3, #24
{
    // Point to buffer environment
    m_lay_bearer_buf_env_t *p_env = (m_lay_bearer_buf_env_t *)p_buf->env;

    // Update RTS bit
    SETB(p_env->flags, M_BCN_BUF_RTS, enable);
    9790:	7c0a      	ldrb	r2, [r1, #16]
    9792:	4382      	bics	r2, r0
    9794:	4302      	orrs	r2, r0
    9796:	740a      	strb	r2, [r1, #16]

        if (GETB(p_m_bcn_env->state, M_BCN_STATE_TX_UNPROV))
        {
            // mark that buffer ready to send
            m_bcn_buf_rts_set(p_m_bcn_env->p_adv_buf_bcn, true);
            m_tb_timer_set(&p_m_bcn_env->timer_bcn, M_BCN_DEFAULT_UNPROV_BCN_INTV_MS);
    9798:	21fa      	movs	r1, #250	; 0xfa
    979a:	0018      	movs	r0, r3
    979c:	0089      	lsls	r1, r1, #2
    979e:	f00b fdb1 	bl	15304 <m_tb_timer_set>
    97a2:	e006      	b.n	97b2 <m_bcn_cb_opened+0x52>
        }
        else if (GETB(p_m_bcn_env->state, M_BCN_STATE_PROV))
        {
            if(GETB(p_m_bcn_env->state, M_BCN_STATE_ENABLE))
    97a4:	43d2      	mvns	r2, r2
    97a6:	0793      	lsls	r3, r2, #30
    97a8:	d103      	bne.n	97b2 <m_bcn_cb_opened+0x52>
            {
                // Start observation timer
                m_tb_timer_set(&p_m_bcn_env->timer_obs, M_BCN_DEFAULT_OBS_PERIOD_MS);
    97aa:	4904      	ldr	r1, [pc, #16]	; (97bc <m_bcn_cb_opened+0x5c>)
    97ac:	0020      	movs	r0, r4
    97ae:	f00b fda9 	bl	15304 <m_tb_timer_set>
            }
        }

        // check if something must be sent
        m_bcn_adv_tx_check();
    97b2:	f7ff fdd4 	bl	935e <m_bcn_adv_tx_check>
    else if(type == M_BEARER_TYPE_PROXY_GATT)
    {
        m_bcn_proxy_tx_check();
    }
    #endif // (BLE_MESH_GATT_PROXY)
}
    97b6:	bd70      	pop	{r4, r5, r6, pc}
    97b8:	1001269c 	.word	0x1001269c
    97bc:	00004e20 	.word	0x00004e20

000097c0 <m_bcn_cb_closed>:
 ****************************************************************************************
 */
__STATIC void m_bcn_cb_closed(uint8_t bearer_lid)
{
    // Update opened bearer bit field
    p_m_bcn_env->bearer_lid_opened_bf &= ~CO_BIT(bearer_lid);
    97c0:	2201      	movs	r2, #1
    97c2:	4082      	lsls	r2, r0
    97c4:	4b08      	ldr	r3, [pc, #32]	; (97e8 <m_bcn_cb_closed+0x28>)
 *
 * @param[in] bearer_lid        Bearer LID.
 ****************************************************************************************
 */
__STATIC void m_bcn_cb_closed(uint8_t bearer_lid)
{
    97c6:	b510      	push	{r4, lr}
    // Update opened bearer bit field
    p_m_bcn_env->bearer_lid_opened_bf &= ~CO_BIT(bearer_lid);
    97c8:	681b      	ldr	r3, [r3, #0]
 *
 * @param[in] bearer_lid        Bearer LID.
 ****************************************************************************************
 */
__STATIC void m_bcn_cb_closed(uint8_t bearer_lid)
{
    97ca:	0001      	movs	r1, r0
    // Update opened bearer bit field
    p_m_bcn_env->bearer_lid_opened_bf &= ~CO_BIT(bearer_lid);
    97cc:	6c18      	ldr	r0, [r3, #64]	; 0x40
    97ce:	4390      	bics	r0, r2
    97d0:	6418      	str	r0, [r3, #64]	; 0x40

    // Unregister advertising bearer
    if (p_m_bcn_env->adv_bearer_lid == bearer_lid)
    97d2:	1d18      	adds	r0, r3, #4
    97d4:	3344      	adds	r3, #68	; 0x44
    97d6:	781a      	ldrb	r2, [r3, #0]
    97d8:	428a      	cmp	r2, r1
    97da:	d103      	bne.n	97e4 <m_bcn_cb_closed+0x24>
    {
        p_m_bcn_env->adv_bearer_lid = M_INVALID_LID;
    97dc:	22ff      	movs	r2, #255	; 0xff
    97de:	701a      	strb	r2, [r3, #0]

        // Stop observation timer
        m_tb_timer_clear(&p_m_bcn_env->timer_obs);
    97e0:	f00b fdda 	bl	15398 <m_tb_timer_clear>
    }
}
    97e4:	bd10      	pop	{r4, pc}
    97e6:	46c0      	nop			; (mov r8, r8)
    97e8:	1001269c 	.word	0x1001269c

000097ec <m_bcn_cb_timer_obs_expired>:
    m_lid_t cnt;

    for (cnt = 0; cnt < M_SUBNET_NB_MAX; cnt++)
    {
        // Get information structure
        m_bcn_info_t *p_info = &p_m_bcn_env->bcn_info[cnt];
    97ec:	4b11      	ldr	r3, [pc, #68]	; (9834 <m_bcn_cb_timer_obs_expired+0x48>)
 *
 * @param[in] p_env         Pointer to an environment variable (not used)
 ****************************************************************************************
 */
__STATIC void m_bcn_cb_timer_obs_expired(void *p_env)
{
    97ee:	b510      	push	{r4, lr}
    m_lid_t cnt;

    for (cnt = 0; cnt < M_SUBNET_NB_MAX; cnt++)
    {
        // Get information structure
        m_bcn_info_t *p_info = &p_m_bcn_env->bcn_info[cnt];
    97f0:	6818      	ldr	r0, [r3, #0]

        if (p_info->net_key_lid != M_INVALID_LID)
    97f2:	0003      	movs	r3, r0
    97f4:	3338      	adds	r3, #56	; 0x38
    97f6:	781b      	ldrb	r3, [r3, #0]
    97f8:	2bff      	cmp	r3, #255	; 0xff
    97fa:	d008      	beq.n	980e <m_bcn_cb_timer_obs_expired+0x22>
        {
            // Compute beacon interval based on number of secure network beacon received during the
            // observation period
            p_info->bcn_intv = (M_BCN_DEFAULT_OBS_PERIOD_10S * (p_info->nb_rx_snb + 1)) >> 1;
    97fc:	0001      	movs	r1, r0
    97fe:	0003      	movs	r3, r0
    9800:	3139      	adds	r1, #57	; 0x39
    9802:	780a      	ldrb	r2, [r1, #0]
    9804:	333a      	adds	r3, #58	; 0x3a
    9806:	3201      	adds	r2, #1
    9808:	701a      	strb	r2, [r3, #0]

            // And reset statistics
            p_info->nb_rx_snb = 0;
    980a:	2300      	movs	r3, #0
    980c:	700b      	strb	r3, [r1, #0]
    for (cnt = 0; cnt < M_SUBNET_NB_MAX; cnt++)
    {
        // Get information structure
        m_bcn_info_t *p_info = &p_m_bcn_env->bcn_info[cnt];

        if (p_info->net_key_lid != M_INVALID_LID)
    980e:	0003      	movs	r3, r0
    9810:	333c      	adds	r3, #60	; 0x3c
    9812:	781b      	ldrb	r3, [r3, #0]
    9814:	2bff      	cmp	r3, #255	; 0xff
    9816:	d008      	beq.n	982a <m_bcn_cb_timer_obs_expired+0x3e>
        {
            // Compute beacon interval based on number of secure network beacon received during the
            // observation period
            p_info->bcn_intv = (M_BCN_DEFAULT_OBS_PERIOD_10S * (p_info->nb_rx_snb + 1)) >> 1;
    9818:	0001      	movs	r1, r0
    981a:	0003      	movs	r3, r0
    981c:	313d      	adds	r1, #61	; 0x3d
    981e:	780a      	ldrb	r2, [r1, #0]
    9820:	333e      	adds	r3, #62	; 0x3e
    9822:	3201      	adds	r2, #1
    9824:	701a      	strb	r2, [r3, #0]

            // And reset statistics
            p_info->nb_rx_snb = 0;
    9826:	2300      	movs	r3, #0
    9828:	700b      	strb	r3, [r1, #0]
        }
    }

    // Relaunch the observation timer
    m_tb_timer_set(&p_m_bcn_env->timer_obs, M_BCN_DEFAULT_OBS_PERIOD_MS);
    982a:	3004      	adds	r0, #4
    982c:	4902      	ldr	r1, [pc, #8]	; (9838 <m_bcn_cb_timer_obs_expired+0x4c>)
    982e:	f00b fd69 	bl	15304 <m_tb_timer_set>
}
    9832:	bd10      	pop	{r4, pc}
    9834:	1001269c 	.word	0x1001269c
    9838:	00004e20 	.word	0x00004e20

0000983c <m_bcn_cb_timer_bcn_expired>:
 * time elapsed since timer has been programmed (in multiple of 10s).
 ****************************************************************************************
 */
__STATIC void m_bcn_cb_timer_bcn_expired(void *p_env)
{
	M_PRINTF(L_BCN, "");
    983c:	4b2a      	ldr	r3, [pc, #168]	; (98e8 <m_bcn_cb_timer_bcn_expired+0xac>)
 * @param[in] p_env       If timer is used for transmission of secure network beacons, contains
 * time elapsed since timer has been programmed (in multiple of 10s).
 ****************************************************************************************
 */
__STATIC void m_bcn_cb_timer_bcn_expired(void *p_env)
{
    983e:	b537      	push	{r0, r1, r2, r4, r5, lr}
	M_PRINTF(L_BCN, "");
    9840:	681b      	ldr	r3, [r3, #0]
    9842:	069b      	lsls	r3, r3, #26
    9844:	d514      	bpl.n	9870 <m_bcn_cb_timer_bcn_expired+0x34>
    9846:	4c29      	ldr	r4, [pc, #164]	; (98ec <m_bcn_cb_timer_bcn_expired+0xb0>)
    9848:	4b29      	ldr	r3, [pc, #164]	; (98f0 <m_bcn_cb_timer_bcn_expired+0xb4>)
    984a:	0022      	movs	r2, r4
    984c:	0020      	movs	r0, r4
    984e:	3303      	adds	r3, #3
    9850:	0021      	movs	r1, r4
    9852:	3221      	adds	r2, #33	; 0x21
    9854:	9300      	str	r3, [sp, #0]
    9856:	3029      	adds	r0, #41	; 0x29
    9858:	4b26      	ldr	r3, [pc, #152]	; (98f4 <m_bcn_cb_timer_bcn_expired+0xb8>)
    985a:	f7fb f8a7 	bl	49ac <m_print>
    985e:	0020      	movs	r0, r4
    9860:	304b      	adds	r0, #75	; 0x4b
    9862:	f7fb f8a3 	bl	49ac <m_print>
    9866:	0020      	movs	r0, r4
    9868:	1da1      	adds	r1, r4, #6
    986a:	304c      	adds	r0, #76	; 0x4c
    986c:	f7fb f89e 	bl	49ac <m_print>
    bool transmit = false;

    // Check if we are provisioned or not
    if (GETB(p_m_bcn_env->state, M_BCN_STATE_PROV))
    9870:	4c21      	ldr	r4, [pc, #132]	; (98f8 <m_bcn_cb_timer_bcn_expired+0xbc>)
    9872:	6820      	ldr	r0, [r4, #0]
    9874:	0003      	movs	r3, r0
    9876:	3345      	adds	r3, #69	; 0x45
    9878:	781b      	ldrb	r3, [r3, #0]
    987a:	079a      	lsls	r2, r3, #30
    987c:	d51a      	bpl.n	98b4 <m_bcn_cb_timer_bcn_expired+0x78>
    987e:	0003      	movs	r3, r0
    9880:	0001      	movs	r1, r0
    9882:	2500      	movs	r5, #0
    9884:	3338      	adds	r3, #56	; 0x38
    9886:	3140      	adds	r1, #64	; 0x40
        {
            // Get information structure
            m_bcn_info_t *p_info = &p_m_bcn_env->bcn_info[cnt];

            // check if remaining time should be updated
            if (p_info->net_key_lid != M_INVALID_LID)
    9888:	781a      	ldrb	r2, [r3, #0]
    988a:	2aff      	cmp	r2, #255	; 0xff
    988c:	d008      	beq.n	98a0 <m_bcn_cb_timer_bcn_expired+0x64>
            {
                // Update remaining time before beacon transmission on Advertising bearer
                if(p_info->rem_dur > 0)
    988e:	78da      	ldrb	r2, [r3, #3]
    9890:	2a00      	cmp	r2, #0
    9892:	d001      	beq.n	9898 <m_bcn_cb_timer_bcn_expired+0x5c>
                {
                    p_info->rem_dur--;
    9894:	3a01      	subs	r2, #1
    9896:	70da      	strb	r2, [r3, #3]
                }

                // the timer has elapsed
                if (p_info->rem_dur == 0)
    9898:	78da      	ldrb	r2, [r3, #3]
    989a:	2a00      	cmp	r2, #0
    989c:	d100      	bne.n	98a0 <m_bcn_cb_timer_bcn_expired+0x64>
                {
                    transmit = true;
    989e:	2501      	movs	r5, #1
    98a0:	3304      	adds	r3, #4
    {
        // Counter
        m_lid_t cnt;

        // update reamaining time for all counters
        for (cnt = 0; cnt < M_SUBNET_NB_MAX; cnt++)
    98a2:	428b      	cmp	r3, r1
    98a4:	d1f0      	bne.n	9888 <m_bcn_cb_timer_bcn_expired+0x4c>
                }
            }
        }

        // Restart the beacon timer
        m_tb_timer_set(&p_m_bcn_env->timer_bcn, M_BCN_DEFAULT_BCN_TIMER_10S);
    98a6:	3018      	adds	r0, #24
    98a8:	4914      	ldr	r1, [pc, #80]	; (98fc <m_bcn_cb_timer_bcn_expired+0xc0>)
    98aa:	f00b fd2b 	bl	15304 <m_tb_timer_set>
            m_tb_timer_set(&p_m_bcn_env->timer_bcn, M_BCN_DEFAULT_UNPROV_BCN_INTV_MS);
            transmit = true;
        }
    }

    if((transmit) && (p_m_bcn_env->adv_bearer_lid != M_INVALID_LID))
    98ae:	2d00      	cmp	r5, #0
    98b0:	d112      	bne.n	98d8 <m_bcn_cb_timer_bcn_expired+0x9c>
    98b2:	e018      	b.n	98e6 <m_bcn_cb_timer_bcn_expired+0xaa>
        }

        // Restart the beacon timer
        m_tb_timer_set(&p_m_bcn_env->timer_bcn, M_BCN_DEFAULT_BCN_TIMER_10S);
    }
    else if (GETB(p_m_bcn_env->state, M_BCN_STATE_TX_UNPROV))
    98b4:	075b      	lsls	r3, r3, #29
    98b6:	d516      	bpl.n	98e6 <m_bcn_cb_timer_bcn_expired+0xaa>
{
    // Point to buffer environment
    m_lay_bearer_buf_env_t *p_env = (m_lay_bearer_buf_env_t *)p_buf->env;

    // Update RTS bit
    SETB(p_env->flags, M_BCN_BUF_RTS, enable);
    98b8:	2108      	movs	r1, #8
        m_tb_timer_set(&p_m_bcn_env->timer_bcn, M_BCN_DEFAULT_BCN_TIMER_10S);
    }
    else if (GETB(p_m_bcn_env->state, M_BCN_STATE_TX_UNPROV))
    {
        // mark that buffer ready to send
        m_bcn_buf_rts_set(p_m_bcn_env->p_adv_buf_bcn, true);
    98ba:	6b42      	ldr	r2, [r0, #52]	; 0x34
{
    // Point to buffer environment
    m_lay_bearer_buf_env_t *p_env = (m_lay_bearer_buf_env_t *)p_buf->env;

    // Update RTS bit
    SETB(p_env->flags, M_BCN_BUF_RTS, enable);
    98bc:	7c13      	ldrb	r3, [r2, #16]
    98be:	438b      	bics	r3, r1
    98c0:	430b      	orrs	r3, r1
    98c2:	7413      	strb	r3, [r2, #16]
    else if (GETB(p_m_bcn_env->state, M_BCN_STATE_TX_UNPROV))
    {
        // mark that buffer ready to send
        m_bcn_buf_rts_set(p_m_bcn_env->p_adv_buf_bcn, true);

        if(p_m_bcn_env->adv_bearer_lid != M_INVALID_LID)
    98c4:	0003      	movs	r3, r0
    98c6:	3344      	adds	r3, #68	; 0x44
    98c8:	781b      	ldrb	r3, [r3, #0]
    98ca:	2bff      	cmp	r3, #255	; 0xff
    98cc:	d00b      	beq.n	98e6 <m_bcn_cb_timer_bcn_expired+0xaa>
        {
            // Program timer for next transmission - Will directly call bearer API send function upon expiration
            m_tb_timer_set(&p_m_bcn_env->timer_bcn, M_BCN_DEFAULT_UNPROV_BCN_INTV_MS);
    98ce:	21fa      	movs	r1, #250	; 0xfa
    98d0:	3018      	adds	r0, #24
    98d2:	0089      	lsls	r1, r1, #2
    98d4:	f00b fd16 	bl	15304 <m_tb_timer_set>
            transmit = true;
        }
    }

    if((transmit) && (p_m_bcn_env->adv_bearer_lid != M_INVALID_LID))
    98d8:	6823      	ldr	r3, [r4, #0]
    98da:	3344      	adds	r3, #68	; 0x44
    98dc:	781b      	ldrb	r3, [r3, #0]
    98de:	2bff      	cmp	r3, #255	; 0xff
    98e0:	d001      	beq.n	98e6 <m_bcn_cb_timer_bcn_expired+0xaa>
    {
        // Prepare transmission of a beacon
        m_bcn_adv_tx_check();
    98e2:	f7ff fd3c 	bl	935e <m_bcn_adv_tx_check>
    }
}
    98e6:	bd37      	pop	{r0, r1, r2, r4, r5, pc}
    98e8:	10010514 	.word	0x10010514
    98ec:	0002132c 	.word	0x0002132c
    98f0:	000213ac 	.word	0x000213ac
    98f4:	00000372 	.word	0x00000372
    98f8:	1001269c 	.word	0x1001269c
    98fc:	00002710 	.word	0x00002710

00009900 <m_bcn_init>:
 ****************************************************************************************
 */


uint16_t m_bcn_init(bool reset, void *p_env, const m_cfg_t* p_cfg)
{
    9900:	b570      	push	{r4, r5, r6, lr}
    9902:	4b16      	ldr	r3, [pc, #88]	; (995c <m_bcn_init+0x5c>)
    9904:	0005      	movs	r5, r0
    9906:	000c      	movs	r4, r1
    uint16_t env_size = 0;

    if (!reset)
    9908:	2800      	cmp	r0, #0
    990a:	d124      	bne.n	9956 <m_bcn_init+0x56>

        // Retrieve environment size
        env_size = m_bcn_get_env_size(p_cfg);

        // Get environment for Beacon Layer
        p_m_bcn_env = (m_bcn_env_t *)p_env;
    990c:	6019      	str	r1, [r3, #0]
        p_env = p_env + CO_ALIGN4_HI(sizeof(m_bcn_env_t));

        // Initialize environment content
        memset(p_m_bcn_env, 0, sizeof(m_bcn_env_t));
    990e:	2254      	movs	r2, #84	; 0x54
    9910:	0001      	movs	r1, r0
    9912:	0020      	movs	r0, r4
    9914:	f00c f89a 	bl	15a4c <memset>

        // Initialize advertising bearer local index
        p_m_bcn_env->adv_bearer_lid = M_INVALID_LID;
    9918:	0022      	movs	r2, r4
    991a:	23ff      	movs	r3, #255	; 0xff
    991c:	3244      	adds	r2, #68	; 0x44
    991e:	7013      	strb	r3, [r2, #0]
        p_m_bcn_env->bearer_lid_opened_bf = 0;

        // Initialize subnet information
        for (cnt = 0; cnt < M_SUBNET_NB_MAX; cnt++)
        {
            p_m_bcn_env->bcn_info[cnt].net_key_lid = M_INVALID_LID;
    9920:	3a0c      	subs	r2, #12
        // Initialize environment content
        memset(p_m_bcn_env, 0, sizeof(m_bcn_env_t));

        // Initialize advertising bearer local index
        p_m_bcn_env->adv_bearer_lid = M_INVALID_LID;
        p_m_bcn_env->bearer_lid_opened_bf = 0;
    9922:	6425      	str	r5, [r4, #64]	; 0x40

        // Initialize subnet information
        for (cnt = 0; cnt < M_SUBNET_NB_MAX; cnt++)
        {
            p_m_bcn_env->bcn_info[cnt].net_key_lid = M_INVALID_LID;
    9924:	7013      	strb	r3, [r2, #0]
    9926:	7113      	strb	r3, [r2, #4]
            p_m_bcn_env->bcn_info[cnt].bearer_lid_tx_bf = 0;
            #endif //(BLE_MESH_GATT_PROXY)
        }

        // Allocate a buffer to be used for transmission of beacon
        p_m_bcn_env->p_adv_buf_bcn = (m_tb_buf_t *)p_env;
    9928:	0023      	movs	r3, r4
    // Point to buffer environment
    m_lay_bearer_buf_env_t *p_env = (m_lay_bearer_buf_env_t *)p_buf->env;

    // Prepare buffer
    p_buf->acq_cnt = 1;
    p_buf->head_len = M_BEARER_ADV_HEAD_LEN;
    992a:	2002      	movs	r0, #2
{
    // Point to buffer environment
    m_lay_bearer_buf_env_t *p_env = (m_lay_bearer_buf_env_t *)p_buf->env;

    // Prepare buffer
    p_buf->acq_cnt = 1;
    992c:	2201      	movs	r2, #1
            p_m_bcn_env->bcn_info[cnt].bearer_lid_tx_bf = 0;
            #endif //(BLE_MESH_GATT_PROXY)
        }

        // Allocate a buffer to be used for transmission of beacon
        p_m_bcn_env->p_adv_buf_bcn = (m_tb_buf_t *)p_env;
    992e:	3354      	adds	r3, #84	; 0x54
    9930:	6363      	str	r3, [r4, #52]	; 0x34
    // Point to buffer environment
    m_lay_bearer_buf_env_t *p_env = (m_lay_bearer_buf_env_t *)p_buf->env;

    // Prepare buffer
    p_buf->acq_cnt = 1;
    p_buf->head_len = M_BEARER_ADV_HEAD_LEN;
    9932:	8098      	strh	r0, [r3, #4]
{
    // Point to buffer environment
    m_lay_bearer_buf_env_t *p_env = (m_lay_bearer_buf_env_t *)p_buf->env;

    // Prepare buffer
    p_buf->acq_cnt = 1;
    9934:	739a      	strb	r2, [r3, #14]
    p_buf->pattern = M_TB_BUF_DBG_PATTERN;
    #endif //(BLE_MESH_DBG)

    // Initialize buffer environment
    p_env->flags = 0;
    p_env->u9.subnet_lid = 0;
    9936:	3310      	adds	r3, #16
    p_env->msg_type = M_BEARER_MSG_BEACON;
    9938:	7098      	strb	r0, [r3, #2]
    SETB(p_env->flags, M_BCN_BUF_ADV, adv);
    993a:	7018      	strb	r0, [r3, #0]
    p_buf->pattern = M_TB_BUF_DBG_PATTERN;
    #endif //(BLE_MESH_DBG)

    // Initialize buffer environment
    p_env->flags = 0;
    p_env->u9.subnet_lid = 0;
    993c:	749d      	strb	r5, [r3, #18]
            m_bcn_buf_init(p_m_bcn_env->p_gatt_buf_bcn, false);
        }
        #endif //(BLE_MESH_GATT_PROXY)

        // Set timer callback functions
        p_m_bcn_env->timer_obs.cb = m_bcn_cb_timer_obs_expired;
    993e:	4b08      	ldr	r3, [pc, #32]	; (9960 <m_bcn_init+0x60>)
        p_m_bcn_env->timer_bcn.cb = m_bcn_cb_timer_bcn_expired;

        // Connect beaconing layer to bearer layer API functions
        p_m_bcn_env->p_bearer_api = &m_bearer_api;
        // Connect bearer layer to beaconing layer CB functions
        m_bearer_connect_client_cb(M_BEARER_CLI_BEACON, &m_bcn_cb);
    9940:	4908      	ldr	r1, [pc, #32]	; (9964 <m_bcn_init+0x64>)
            m_bcn_buf_init(p_m_bcn_env->p_gatt_buf_bcn, false);
        }
        #endif //(BLE_MESH_GATT_PROXY)

        // Set timer callback functions
        p_m_bcn_env->timer_obs.cb = m_bcn_cb_timer_obs_expired;
    9942:	60a3      	str	r3, [r4, #8]
        p_m_bcn_env->timer_bcn.cb = m_bcn_cb_timer_bcn_expired;
    9944:	4b08      	ldr	r3, [pc, #32]	; (9968 <m_bcn_init+0x68>)

        // Connect beaconing layer to bearer layer API functions
        p_m_bcn_env->p_bearer_api = &m_bearer_api;
        // Connect bearer layer to beaconing layer CB functions
        m_bearer_connect_client_cb(M_BEARER_CLI_BEACON, &m_bcn_cb);
    9946:	3120      	adds	r1, #32
        }
        #endif //(BLE_MESH_GATT_PROXY)

        // Set timer callback functions
        p_m_bcn_env->timer_obs.cb = m_bcn_cb_timer_obs_expired;
        p_m_bcn_env->timer_bcn.cb = m_bcn_cb_timer_bcn_expired;
    9948:	61e3      	str	r3, [r4, #28]

        // Connect beaconing layer to bearer layer API functions
        p_m_bcn_env->p_bearer_api = &m_bearer_api;
    994a:	4b08      	ldr	r3, [pc, #32]	; (996c <m_bcn_init+0x6c>)
    994c:	6023      	str	r3, [r4, #0]
        // Connect bearer layer to beaconing layer CB functions
        m_bearer_connect_client_cb(M_BEARER_CLI_BEACON, &m_bcn_cb);
    994e:	f000 fa63 	bl	9e18 <m_bearer_connect_client_cb>
    {
        // Counter
        m_lid_t cnt;

        // Retrieve environment size
        env_size = m_bcn_get_env_size(p_cfg);
    9952:	209d      	movs	r0, #157	; 0x9d
    9954:	e001      	b.n	995a <m_bcn_init+0x5a>
        // Connect bearer layer to beaconing layer CB functions
        m_bearer_connect_client_cb(M_BEARER_CLI_BEACON, &m_bcn_cb);
    }
    else
    {
        p_m_bcn_env = NULL;
    9956:	2000      	movs	r0, #0
    9958:	6018      	str	r0, [r3, #0]
    }

    return (env_size);
}
    995a:	bd70      	pop	{r4, r5, r6, pc}
    995c:	1001269c 	.word	0x1001269c
    9960:	000097ed 	.word	0x000097ed
    9964:	000213ac 	.word	0x000213ac
    9968:	0000983d 	.word	0x0000983d
    996c:	000214e8 	.word	0x000214e8

00009970 <m_bcn_get_env_size>:
                                            + M_BCN_BEACON_MAX_LEN + M_BEARER_ADV_HEAD_LEN;
    }
    #endif //(BLE_MESH_GATT_PROXY)

    return (env_size);
}
    9970:	209d      	movs	r0, #157	; 0x9d
    9972:	4770      	bx	lr

00009974 <m_bcn_connect_api>:

void m_bcn_connect_api(const m_bearer_api_t *p_api)
{
    p_m_bcn_env->p_bearer_api = p_api;
    9974:	4b01      	ldr	r3, [pc, #4]	; (997c <m_bcn_connect_api+0x8>)
    9976:	681b      	ldr	r3, [r3, #0]
    9978:	6018      	str	r0, [r3, #0]
}
    997a:	4770      	bx	lr
    997c:	1001269c 	.word	0x1001269c

00009980 <m_bcn_subnet_update_ind>:

void m_bcn_subnet_update_ind(m_lid_t net_key_lid, bool add)
{
    // Subnet local index
    m_lid_t subnet_lid = M_TB_KEY_GET_SUBNET_LID(net_key_lid);
    9980:	1e43      	subs	r3, r0, #1
    9982:	b2da      	uxtb	r2, r3
    // Get beaconing information structure
    m_bcn_info_t *p_info = &p_m_bcn_env->bcn_info[subnet_lid];
    9984:	4b10      	ldr	r3, [pc, #64]	; (99c8 <m_bcn_subnet_update_ind+0x48>)
{
    p_m_bcn_env->p_bearer_api = p_api;
}

void m_bcn_subnet_update_ind(m_lid_t net_key_lid, bool add)
{
    9986:	b510      	push	{r4, lr}
    // Subnet local index
    m_lid_t subnet_lid = M_TB_KEY_GET_SUBNET_LID(net_key_lid);
    // Get beaconing information structure
    m_bcn_info_t *p_info = &p_m_bcn_env->bcn_info[subnet_lid];
    9988:	681c      	ldr	r4, [r3, #0]
    998a:	0093      	lsls	r3, r2, #2
    998c:	18e3      	adds	r3, r4, r3

    if (add)
    998e:	2900      	cmp	r1, #0
    9990:	d012      	beq.n	99b8 <m_bcn_subnet_update_ind+0x38>
    {
        // Sanity check
        ASSERT_INFO(p_info->net_key_lid == M_INVALID_LID, net_key_lid, 0);
    9992:	001a      	movs	r2, r3
    9994:	3238      	adds	r2, #56	; 0x38
    9996:	7811      	ldrb	r1, [r2, #0]
    9998:	29ff      	cmp	r1, #255	; 0xff
    999a:	d1fd      	bne.n	9998 <m_bcn_subnet_update_ind+0x18>

        // Initialize information structure
        p_info->net_key_lid = net_key_lid;
    999c:	7010      	strb	r0, [r2, #0]
        p_info->bcn_intv = M_BCN_DEFAULT_SECURE_BCN_INTV_10S;
    999e:	001a      	movs	r2, r3
    99a0:	39fe      	subs	r1, #254	; 0xfe
    99a2:	323a      	adds	r2, #58	; 0x3a
    99a4:	7011      	strb	r1, [r2, #0]
        p_info->rem_dur = 0;
    99a6:	0019      	movs	r1, r3
    99a8:	2200      	movs	r2, #0
    99aa:	313b      	adds	r1, #59	; 0x3b
        p_info->nb_rx_snb = 0;
    99ac:	3339      	adds	r3, #57	; 0x39
        ASSERT_INFO(p_info->net_key_lid == M_INVALID_LID, net_key_lid, 0);

        // Initialize information structure
        p_info->net_key_lid = net_key_lid;
        p_info->bcn_intv = M_BCN_DEFAULT_SECURE_BCN_INTV_10S;
        p_info->rem_dur = 0;
    99ae:	700a      	strb	r2, [r1, #0]
        p_info->nb_rx_snb = 0;
    99b0:	701a      	strb	r2, [r3, #0]

        m_bcn_adv_tx_check();
    99b2:	f7ff fcd4 	bl	935e <m_bcn_adv_tx_check>
    99b6:	e005      	b.n	99c4 <m_bcn_subnet_update_ind+0x44>
    }
    else
    {
        // Sanity check
        ASSERT_INFO(p_info->net_key_lid == net_key_lid, net_key_lid, 0);
    99b8:	3338      	adds	r3, #56	; 0x38
    99ba:	781a      	ldrb	r2, [r3, #0]
    99bc:	4290      	cmp	r0, r2
    99be:	d1fd      	bne.n	99bc <m_bcn_subnet_update_ind+0x3c>

        p_info->net_key_lid = M_INVALID_LID;
    99c0:	22ff      	movs	r2, #255	; 0xff
    99c2:	701a      	strb	r2, [r3, #0]
    }
}
    99c4:	bd10      	pop	{r4, pc}
    99c6:	46c0      	nop			; (mov r8, r8)
    99c8:	1001269c 	.word	0x1001269c

000099cc <m_bcn_start_tx_unprov_bcn>:

void m_bcn_start_tx_unprov_bcn(uint8_t *p_dev_uuid, uint16_t oob_info, uint32_t uri_hash, bool uri_hash_present)
{
    99cc:	b5f0      	push	{r4, r5, r6, r7, lr}
    99ce:	001f      	movs	r7, r3
	M_PRINTF(L_BCN, "");
    99d0:	4b31      	ldr	r3, [pc, #196]	; (9a98 <m_bcn_start_tx_unprov_bcn+0xcc>)
        p_info->net_key_lid = M_INVALID_LID;
    }
}

void m_bcn_start_tx_unprov_bcn(uint8_t *p_dev_uuid, uint16_t oob_info, uint32_t uri_hash, bool uri_hash_present)
{
    99d2:	b087      	sub	sp, #28
	M_PRINTF(L_BCN, "");
    99d4:	681b      	ldr	r3, [r3, #0]
        p_info->net_key_lid = M_INVALID_LID;
    }
}

void m_bcn_start_tx_unprov_bcn(uint8_t *p_dev_uuid, uint16_t oob_info, uint32_t uri_hash, bool uri_hash_present)
{
    99d6:	9003      	str	r0, [sp, #12]
    99d8:	9104      	str	r1, [sp, #16]
    99da:	9205      	str	r2, [sp, #20]
	M_PRINTF(L_BCN, "");
    99dc:	069b      	lsls	r3, r3, #26
    99de:	d515      	bpl.n	9a0c <m_bcn_start_tx_unprov_bcn+0x40>
    99e0:	4b2e      	ldr	r3, [pc, #184]	; (9a9c <m_bcn_start_tx_unprov_bcn+0xd0>)
    99e2:	4c2f      	ldr	r4, [pc, #188]	; (9aa0 <m_bcn_start_tx_unprov_bcn+0xd4>)
    99e4:	3330      	adds	r3, #48	; 0x30
    99e6:	9300      	str	r3, [sp, #0]
    99e8:	0022      	movs	r2, r4
    99ea:	0020      	movs	r0, r4
    99ec:	2386      	movs	r3, #134	; 0x86
    99ee:	0021      	movs	r1, r4
    99f0:	3221      	adds	r2, #33	; 0x21
    99f2:	00db      	lsls	r3, r3, #3
    99f4:	3029      	adds	r0, #41	; 0x29
    99f6:	f7fa ffd9 	bl	49ac <m_print>
    99fa:	0020      	movs	r0, r4
    99fc:	304b      	adds	r0, #75	; 0x4b
    99fe:	f7fa ffd5 	bl	49ac <m_print>
    9a02:	0020      	movs	r0, r4
    9a04:	1da1      	adds	r1, r4, #6
    9a06:	304c      	adds	r0, #76	; 0x4c
    9a08:	f7fa ffd0 	bl	49ac <m_print>
    // Get current state
    uint8_t state = p_m_bcn_env->state;
    9a0c:	4b25      	ldr	r3, [pc, #148]	; (9aa4 <m_bcn_start_tx_unprov_bcn+0xd8>)
    9a0e:	681d      	ldr	r5, [r3, #0]

    // Check that beacon layer is authorized to send unprovisioned device beacons
    if (!GETB(state, M_BCN_STATE_PROV) && !GETB(state, M_BCN_STATE_TX_UNPROV))
    9a10:	2306      	movs	r3, #6

void m_bcn_start_tx_unprov_bcn(uint8_t *p_dev_uuid, uint16_t oob_info, uint32_t uri_hash, bool uri_hash_present)
{
	M_PRINTF(L_BCN, "");
    // Get current state
    uint8_t state = p_m_bcn_env->state;
    9a12:	002e      	movs	r6, r5
    9a14:	3645      	adds	r6, #69	; 0x45

    // Check that beacon layer is authorized to send unprovisioned device beacons
    if (!GETB(state, M_BCN_STATE_PROV) && !GETB(state, M_BCN_STATE_TX_UNPROV))
    9a16:	7832      	ldrb	r2, [r6, #0]
    9a18:	421a      	tst	r2, r3
    9a1a:	d13a      	bne.n	9a92 <m_bcn_start_tx_unprov_bcn+0xc6>
    {
        // Get pointer to data
        uint8_t *p_data = M_TB_BUF_DATA(p_m_bcn_env->p_adv_buf_bcn);
    9a1c:	6b6b      	ldr	r3, [r5, #52]	; 0x34
    9a1e:	001c      	movs	r4, r3
    9a20:	889a      	ldrh	r2, [r3, #4]
    9a22:	3430      	adds	r4, #48	; 0x30
    9a24:	18a4      	adds	r4, r4, r2

        // Set length
        p_m_bcn_env->p_adv_buf_bcn->data_len = (uri_hash_present) ? M_BCN_UNPROV_BCN_FULL_LEN : M_BCN_UNPROV_BCN_LEN;
    9a26:	2213      	movs	r2, #19
    9a28:	2f00      	cmp	r7, #0
    9a2a:	d000      	beq.n	9a2e <m_bcn_start_tx_unprov_bcn+0x62>
    9a2c:	3204      	adds	r2, #4
    9a2e:	811a      	strh	r2, [r3, #8]

        // Set beacon type
        *(p_data + M_BCN_UNPROV_BCN_TYPE_POS) = M_BCN_UNPROV_BCN_TYPE;
    9a30:	2300      	movs	r3, #0
        // Set device UUID
        memcpy(p_data + M_BCN_UNPROV_BCN_DEV_UUID_POS, p_dev_uuid, M_DEV_UUID_LEN);
    9a32:	1c60      	adds	r0, r4, #1

        // Set length
        p_m_bcn_env->p_adv_buf_bcn->data_len = (uri_hash_present) ? M_BCN_UNPROV_BCN_FULL_LEN : M_BCN_UNPROV_BCN_LEN;

        // Set beacon type
        *(p_data + M_BCN_UNPROV_BCN_TYPE_POS) = M_BCN_UNPROV_BCN_TYPE;
    9a34:	7023      	strb	r3, [r4, #0]
        // Set device UUID
        memcpy(p_data + M_BCN_UNPROV_BCN_DEV_UUID_POS, p_dev_uuid, M_DEV_UUID_LEN);
    9a36:	2210      	movs	r2, #16
    9a38:	9903      	ldr	r1, [sp, #12]
    9a3a:	f00b ffc9 	bl	159d0 <memcpy>
    9a3e:	466b      	mov	r3, sp
    9a40:	8a1b      	ldrh	r3, [r3, #16]
    9a42:	ba5b      	rev16	r3, r3
    9a44:	b29b      	uxth	r3, r3
 */
__INLINE_S__ void co_write16p(void const *ptr16, uint16_t value)
{
    uint8_t *ptr=(uint8_t*)ptr16;

    *ptr++ = value&0xff;
    9a46:	7463      	strb	r3, [r4, #17]
    *ptr = (value&0xff00)>>8;
    9a48:	0a1b      	lsrs	r3, r3, #8
    9a4a:	74a3      	strb	r3, [r4, #18]
        // Set OOB information
        co_write16p(p_data + M_BCN_UNPROV_BCN_OOB_INFO_POS, co_htons(oob_info));

        if (uri_hash_present)
    9a4c:	2f00      	cmp	r7, #0
    9a4e:	d009      	beq.n	9a64 <m_bcn_start_tx_unprov_bcn+0x98>
    9a50:	9805      	ldr	r0, [sp, #20]
    9a52:	f7ff fc82 	bl	935a <co_bswap32>
__INLINE_S__ void co_write32p(void const *ptr32, uint32_t value)
{
    uint8_t *ptr=(uint8_t*)ptr32;

    *ptr++ = (uint8_t)(value&0xff);
    *ptr++ = (uint8_t)((value&0xff00)>>8);
    9a56:	0a03      	lsrs	r3, r0, #8
 */
__INLINE_S__ void co_write32p(void const *ptr32, uint32_t value)
{
    uint8_t *ptr=(uint8_t*)ptr32;

    *ptr++ = (uint8_t)(value&0xff);
    9a58:	74e0      	strb	r0, [r4, #19]
    *ptr++ = (uint8_t)((value&0xff00)>>8);
    9a5a:	7523      	strb	r3, [r4, #20]
    *ptr++ = (uint8_t)((value&0xff0000)>>16);
    9a5c:	0c03      	lsrs	r3, r0, #16
    *ptr = (uint8_t)((value&0xff000000)>>24);
    9a5e:	0e00      	lsrs	r0, r0, #24
{
    uint8_t *ptr=(uint8_t*)ptr32;

    *ptr++ = (uint8_t)(value&0xff);
    *ptr++ = (uint8_t)((value&0xff00)>>8);
    *ptr++ = (uint8_t)((value&0xff0000)>>16);
    9a60:	7563      	strb	r3, [r4, #21]
    *ptr = (uint8_t)((value&0xff000000)>>24);
    9a62:	75a0      	strb	r0, [r4, #22]
            // Set URI hash
            co_write32p(p_data + M_BCN_UNPROV_BCN_URI_HASH_POS, co_htonl(uri_hash));
        }

        // Update status
        SETB(p_m_bcn_env->state, M_BCN_STATE_TX_UNPROV, 1);
    9a64:	2204      	movs	r2, #4
    9a66:	7833      	ldrb	r3, [r6, #0]
    9a68:	4313      	orrs	r3, r2
    9a6a:	7033      	strb	r3, [r6, #0]

        if(p_m_bcn_env->adv_bearer_lid != M_INVALID_LID)
    9a6c:	002b      	movs	r3, r5
    9a6e:	3344      	adds	r3, #68	; 0x44
    9a70:	781b      	ldrb	r3, [r3, #0]
    9a72:	2bff      	cmp	r3, #255	; 0xff
    9a74:	d00d      	beq.n	9a92 <m_bcn_start_tx_unprov_bcn+0xc6>
{
    // Point to buffer environment
    m_lay_bearer_buf_env_t *p_env = (m_lay_bearer_buf_env_t *)p_buf->env;

    // Update RTS bit
    SETB(p_env->flags, M_BCN_BUF_RTS, enable);
    9a76:	2108      	movs	r1, #8
        SETB(p_m_bcn_env->state, M_BCN_STATE_TX_UNPROV, 1);

        if(p_m_bcn_env->adv_bearer_lid != M_INVALID_LID)
        {
            // mark that buffer ready to send
            m_bcn_buf_rts_set(p_m_bcn_env->p_adv_buf_bcn, true);
    9a78:	6b6a      	ldr	r2, [r5, #52]	; 0x34
            // Program timer for next transmission - Will directly call bearer API send function upon expiration
            m_tb_timer_set(&p_m_bcn_env->timer_bcn, M_BCN_DEFAULT_UNPROV_BCN_INTV_MS);
    9a7a:	0028      	movs	r0, r5
{
    // Point to buffer environment
    m_lay_bearer_buf_env_t *p_env = (m_lay_bearer_buf_env_t *)p_buf->env;

    // Update RTS bit
    SETB(p_env->flags, M_BCN_BUF_RTS, enable);
    9a7c:	7c13      	ldrb	r3, [r2, #16]
        if(p_m_bcn_env->adv_bearer_lid != M_INVALID_LID)
        {
            // mark that buffer ready to send
            m_bcn_buf_rts_set(p_m_bcn_env->p_adv_buf_bcn, true);
            // Program timer for next transmission - Will directly call bearer API send function upon expiration
            m_tb_timer_set(&p_m_bcn_env->timer_bcn, M_BCN_DEFAULT_UNPROV_BCN_INTV_MS);
    9a7e:	3018      	adds	r0, #24
{
    // Point to buffer environment
    m_lay_bearer_buf_env_t *p_env = (m_lay_bearer_buf_env_t *)p_buf->env;

    // Update RTS bit
    SETB(p_env->flags, M_BCN_BUF_RTS, enable);
    9a80:	438b      	bics	r3, r1
    9a82:	430b      	orrs	r3, r1
        if(p_m_bcn_env->adv_bearer_lid != M_INVALID_LID)
        {
            // mark that buffer ready to send
            m_bcn_buf_rts_set(p_m_bcn_env->p_adv_buf_bcn, true);
            // Program timer for next transmission - Will directly call bearer API send function upon expiration
            m_tb_timer_set(&p_m_bcn_env->timer_bcn, M_BCN_DEFAULT_UNPROV_BCN_INTV_MS);
    9a84:	21fa      	movs	r1, #250	; 0xfa
{
    // Point to buffer environment
    m_lay_bearer_buf_env_t *p_env = (m_lay_bearer_buf_env_t *)p_buf->env;

    // Update RTS bit
    SETB(p_env->flags, M_BCN_BUF_RTS, enable);
    9a86:	7413      	strb	r3, [r2, #16]
        if(p_m_bcn_env->adv_bearer_lid != M_INVALID_LID)
        {
            // mark that buffer ready to send
            m_bcn_buf_rts_set(p_m_bcn_env->p_adv_buf_bcn, true);
            // Program timer for next transmission - Will directly call bearer API send function upon expiration
            m_tb_timer_set(&p_m_bcn_env->timer_bcn, M_BCN_DEFAULT_UNPROV_BCN_INTV_MS);
    9a88:	0089      	lsls	r1, r1, #2
    9a8a:	f00b fc3b 	bl	15304 <m_tb_timer_set>
            // Check if beacon can be sent
            m_bcn_adv_tx_check();
    9a8e:	f7ff fc66 	bl	935e <m_bcn_adv_tx_check>
        }
    }
}
    9a92:	b007      	add	sp, #28
    9a94:	bdf0      	pop	{r4, r5, r6, r7, pc}
    9a96:	46c0      	nop			; (mov r8, r8)
    9a98:	10010514 	.word	0x10010514
    9a9c:	000213ac 	.word	0x000213ac
    9aa0:	0002132c 	.word	0x0002132c
    9aa4:	1001269c 	.word	0x1001269c

00009aa8 <m_bcn_stop_tx_unprov_bcn>:

void m_bcn_stop_tx_unprov_bcn()
{
    9aa8:	b537      	push	{r0, r1, r2, r4, r5, lr}
	M_PRINTF(L_BCN, "");
    9aaa:	4d22      	ldr	r5, [pc, #136]	; (9b34 <m_bcn_stop_tx_unprov_bcn+0x8c>)
    9aac:	682b      	ldr	r3, [r5, #0]
    9aae:	069b      	lsls	r3, r3, #26
    9ab0:	d514      	bpl.n	9adc <m_bcn_stop_tx_unprov_bcn+0x34>
    9ab2:	4c21      	ldr	r4, [pc, #132]	; (9b38 <m_bcn_stop_tx_unprov_bcn+0x90>)
    9ab4:	4b21      	ldr	r3, [pc, #132]	; (9b3c <m_bcn_stop_tx_unprov_bcn+0x94>)
    9ab6:	0022      	movs	r2, r4
    9ab8:	0020      	movs	r0, r4
    9aba:	334a      	adds	r3, #74	; 0x4a
    9abc:	0021      	movs	r1, r4
    9abe:	3221      	adds	r2, #33	; 0x21
    9ac0:	9300      	str	r3, [sp, #0]
    9ac2:	3029      	adds	r0, #41	; 0x29
    9ac4:	4b1e      	ldr	r3, [pc, #120]	; (9b40 <m_bcn_stop_tx_unprov_bcn+0x98>)
    9ac6:	f7fa ff71 	bl	49ac <m_print>
    9aca:	0020      	movs	r0, r4
    9acc:	304b      	adds	r0, #75	; 0x4b
    9ace:	f7fa ff6d 	bl	49ac <m_print>
    9ad2:	0020      	movs	r0, r4
    9ad4:	1da1      	adds	r1, r4, #6
    9ad6:	304c      	adds	r0, #76	; 0x4c
    9ad8:	f7fa ff68 	bl	49ac <m_print>
    if (GETB(p_m_bcn_env->state, M_BCN_STATE_TX_UNPROV))
    9adc:	4b19      	ldr	r3, [pc, #100]	; (9b44 <m_bcn_stop_tx_unprov_bcn+0x9c>)
    9ade:	2104      	movs	r1, #4
    9ae0:	6818      	ldr	r0, [r3, #0]
    9ae2:	0002      	movs	r2, r0
    9ae4:	3245      	adds	r2, #69	; 0x45
    9ae6:	7813      	ldrb	r3, [r2, #0]
    9ae8:	420b      	tst	r3, r1
    9aea:	d022      	beq.n	9b32 <m_bcn_stop_tx_unprov_bcn+0x8a>
    {
        // Stop sending unprovisioning beacons
        SETB(p_m_bcn_env->state, M_BCN_STATE_TX_UNPROV, 0);
    9aec:	438b      	bics	r3, r1
    9aee:	7013      	strb	r3, [r2, #0]
        m_bcn_buf_rts_set(p_m_bcn_env->p_adv_buf_bcn, false);
    9af0:	6b42      	ldr	r2, [r0, #52]	; 0x34
{
    // Point to buffer environment
    m_lay_bearer_buf_env_t *p_env = (m_lay_bearer_buf_env_t *)p_buf->env;

    // Update RTS bit
    SETB(p_env->flags, M_BCN_BUF_RTS, enable);
    9af2:	1849      	adds	r1, r1, r1
    9af4:	7c13      	ldrb	r3, [r2, #16]
    {
        // Stop sending unprovisioning beacons
        SETB(p_m_bcn_env->state, M_BCN_STATE_TX_UNPROV, 0);
        m_bcn_buf_rts_set(p_m_bcn_env->p_adv_buf_bcn, false);
        // Clear beacon timer
        m_tb_timer_clear(&p_m_bcn_env->timer_bcn);
    9af6:	3018      	adds	r0, #24
{
    // Point to buffer environment
    m_lay_bearer_buf_env_t *p_env = (m_lay_bearer_buf_env_t *)p_buf->env;

    // Update RTS bit
    SETB(p_env->flags, M_BCN_BUF_RTS, enable);
    9af8:	438b      	bics	r3, r1
    9afa:	7413      	strb	r3, [r2, #16]
    {
        // Stop sending unprovisioning beacons
        SETB(p_m_bcn_env->state, M_BCN_STATE_TX_UNPROV, 0);
        m_bcn_buf_rts_set(p_m_bcn_env->p_adv_buf_bcn, false);
        // Clear beacon timer
        m_tb_timer_clear(&p_m_bcn_env->timer_bcn);
    9afc:	f00b fc4c 	bl	15398 <m_tb_timer_clear>
		M_PRINTF(L_BCN, "clear bcn timer");
    9b00:	682b      	ldr	r3, [r5, #0]
    9b02:	069b      	lsls	r3, r3, #26
    9b04:	d515      	bpl.n	9b32 <m_bcn_stop_tx_unprov_bcn+0x8a>
    9b06:	4d0d      	ldr	r5, [pc, #52]	; (9b3c <m_bcn_stop_tx_unprov_bcn+0x94>)
    9b08:	4c0b      	ldr	r4, [pc, #44]	; (9b38 <m_bcn_stop_tx_unprov_bcn+0x90>)
    9b0a:	002b      	movs	r3, r5
    9b0c:	0022      	movs	r2, r4
    9b0e:	0020      	movs	r0, r4
    9b10:	334a      	adds	r3, #74	; 0x4a
    9b12:	0021      	movs	r1, r4
    9b14:	3221      	adds	r2, #33	; 0x21
    9b16:	9300      	str	r3, [sp, #0]
    9b18:	3029      	adds	r0, #41	; 0x29
    9b1a:	4b0b      	ldr	r3, [pc, #44]	; (9b48 <m_bcn_stop_tx_unprov_bcn+0xa0>)
    9b1c:	f7fa ff46 	bl	49ac <m_print>
    9b20:	0028      	movs	r0, r5
    9b22:	3063      	adds	r0, #99	; 0x63
    9b24:	f7fa ff42 	bl	49ac <m_print>
    9b28:	0020      	movs	r0, r4
    9b2a:	1da1      	adds	r1, r4, #6
    9b2c:	304c      	adds	r0, #76	; 0x4c
    9b2e:	f7fa ff3d 	bl	49ac <m_print>
    }
}
    9b32:	bd37      	pop	{r0, r1, r2, r4, r5, pc}
    9b34:	10010514 	.word	0x10010514
    9b38:	0002132c 	.word	0x0002132c
    9b3c:	000213ac 	.word	0x000213ac
    9b40:	0000045b 	.word	0x0000045b
    9b44:	1001269c 	.word	0x1001269c
    9b48:	00000463 	.word	0x00000463

00009b4c <m_bcn_state_update>:

void m_bcn_state_update(void)
{
    9b4c:	b570      	push	{r4, r5, r6, lr}
    // Update Beacon state
    SETB(p_m_bcn_env->state, M_BCN_STATE_PROV, m_tb_state_get_prov_state() == M_TB_STATE_PROV_STATE_PROV);
    9b4e:	f00a fc3b 	bl	143c8 <m_tb_state_get_prov_state>
    9b52:	2302      	movs	r3, #2
    9b54:	4c1f      	ldr	r4, [pc, #124]	; (9bd4 <m_bcn_state_update+0x88>)
    9b56:	6826      	ldr	r6, [r4, #0]
    9b58:	3645      	adds	r6, #69	; 0x45
    9b5a:	7835      	ldrb	r5, [r6, #0]
    9b5c:	439d      	bics	r5, r3
    9b5e:	f00a fc33 	bl	143c8 <m_tb_state_get_prov_state>
    9b62:	3802      	subs	r0, #2
    9b64:	4242      	negs	r2, r0
    9b66:	4142      	adcs	r2, r0
    9b68:	b26d      	sxtb	r5, r5
    9b6a:	0050      	lsls	r0, r2, #1
    9b6c:	4305      	orrs	r5, r0
    9b6e:	7035      	strb	r5, [r6, #0]
    SETB(p_m_bcn_env->state, M_BCN_STATE_ENABLE, m_tb_state_get_beacon_state() == M_CONF_BCN_STATE_BROAD);
    9b70:	f00a fc3a 	bl	143e8 <m_tb_state_get_beacon_state>
    9b74:	2301      	movs	r3, #1
    9b76:	6825      	ldr	r5, [r4, #0]
    9b78:	3545      	adds	r5, #69	; 0x45
    9b7a:	7828      	ldrb	r0, [r5, #0]
    9b7c:	4398      	bics	r0, r3
    9b7e:	b246      	sxtb	r6, r0
    9b80:	f00a fc32 	bl	143e8 <m_tb_state_get_beacon_state>
    9b84:	3801      	subs	r0, #1
    9b86:	4242      	negs	r2, r0
    9b88:	4142      	adcs	r2, r0

    // If provisioned and Beacon Broadcast enabled
    if (GETB(p_m_bcn_env->state, M_BCN_STATE_PROV) && GETB(p_m_bcn_env->state, M_BCN_STATE_ENABLE))
    9b8a:	6820      	ldr	r0, [r4, #0]

void m_bcn_state_update(void)
{
    // Update Beacon state
    SETB(p_m_bcn_env->state, M_BCN_STATE_PROV, m_tb_state_get_prov_state() == M_TB_STATE_PROV_STATE_PROV);
    SETB(p_m_bcn_env->state, M_BCN_STATE_ENABLE, m_tb_state_get_beacon_state() == M_CONF_BCN_STATE_BROAD);
    9b8c:	4332      	orrs	r2, r6

    // If provisioned and Beacon Broadcast enabled
    if (GETB(p_m_bcn_env->state, M_BCN_STATE_PROV) && GETB(p_m_bcn_env->state, M_BCN_STATE_ENABLE))
    9b8e:	0003      	movs	r3, r0

void m_bcn_state_update(void)
{
    // Update Beacon state
    SETB(p_m_bcn_env->state, M_BCN_STATE_PROV, m_tb_state_get_prov_state() == M_TB_STATE_PROV_STATE_PROV);
    SETB(p_m_bcn_env->state, M_BCN_STATE_ENABLE, m_tb_state_get_beacon_state() == M_CONF_BCN_STATE_BROAD);
    9b90:	702a      	strb	r2, [r5, #0]

    // If provisioned and Beacon Broadcast enabled
    if (GETB(p_m_bcn_env->state, M_BCN_STATE_PROV) && GETB(p_m_bcn_env->state, M_BCN_STATE_ENABLE))
    9b92:	3345      	adds	r3, #69	; 0x45
    9b94:	781b      	ldrb	r3, [r3, #0]
    9b96:	43db      	mvns	r3, r3
    9b98:	079b      	lsls	r3, r3, #30
    9b9a:	d10f      	bne.n	9bbc <m_bcn_state_update+0x70>
    {
        // Restart timers
        m_tb_timer_set(&p_m_bcn_env->timer_bcn, M_BCN_DEFAULT_BCN_TIMER_10S);
    9b9c:	3018      	adds	r0, #24
    9b9e:	490e      	ldr	r1, [pc, #56]	; (9bd8 <m_bcn_state_update+0x8c>)
    9ba0:	f00b fbb0 	bl	15304 <m_tb_timer_set>

        if(p_m_bcn_env->adv_bearer_lid != M_INVALID_LID)
    9ba4:	6823      	ldr	r3, [r4, #0]
    9ba6:	1d18      	adds	r0, r3, #4
    9ba8:	3344      	adds	r3, #68	; 0x44
    9baa:	781b      	ldrb	r3, [r3, #0]
    9bac:	2bff      	cmp	r3, #255	; 0xff
    9bae:	d00f      	beq.n	9bd0 <m_bcn_state_update+0x84>
        {
            m_tb_timer_set(&p_m_bcn_env->timer_obs, M_BCN_DEFAULT_OBS_PERIOD_MS);
    9bb0:	490a      	ldr	r1, [pc, #40]	; (9bdc <m_bcn_state_update+0x90>)
    9bb2:	f00b fba7 	bl	15304 <m_tb_timer_set>

            // check if something must be sent
            m_bcn_adv_tx_check();
    9bb6:	f7ff fbd2 	bl	935e <m_bcn_adv_tx_check>
    9bba:	e009      	b.n	9bd0 <m_bcn_state_update+0x84>
    }
    // Stop timers
    else
    {
        // Ensure that here is no unrovisioned beacon transmitted
        m_bcn_stop_tx_unprov_bcn();
    9bbc:	f7ff ff74 	bl	9aa8 <m_bcn_stop_tx_unprov_bcn>

        m_tb_timer_clear(&p_m_bcn_env->timer_bcn);
    9bc0:	6820      	ldr	r0, [r4, #0]
    9bc2:	3018      	adds	r0, #24
    9bc4:	f00b fbe8 	bl	15398 <m_tb_timer_clear>
        m_tb_timer_clear(&p_m_bcn_env->timer_obs);
    9bc8:	6820      	ldr	r0, [r4, #0]
    9bca:	3004      	adds	r0, #4
    9bcc:	f00b fbe4 	bl	15398 <m_tb_timer_clear>
    }
}
    9bd0:	bd70      	pop	{r4, r5, r6, pc}
    9bd2:	46c0      	nop			; (mov r8, r8)
    9bd4:	1001269c 	.word	0x1001269c
    9bd8:	00002710 	.word	0x00002710
    9bdc:	00004e20 	.word	0x00004e20

00009be0 <m_bearer_send>:
 *
 * @return M_ERR_NO_ERROR if PDU has been properly pushed.
 ****************************************************************************************
 */
__STATIC uint16_t m_bearer_send(uint8_t client, m_tb_buf_t *p_buf)
{
    9be0:	b5f0      	push	{r4, r5, r6, r7, lr}
	M_PRINTF(L_BEAR, "");
    9be2:	4b27      	ldr	r3, [pc, #156]	; (9c80 <m_bearer_send+0xa0>)
 *
 * @return M_ERR_NO_ERROR if PDU has been properly pushed.
 ****************************************************************************************
 */
__STATIC uint16_t m_bearer_send(uint8_t client, m_tb_buf_t *p_buf)
{
    9be4:	b085      	sub	sp, #20
	M_PRINTF(L_BEAR, "");
    9be6:	681b      	ldr	r3, [r3, #0]
 *
 * @return M_ERR_NO_ERROR if PDU has been properly pushed.
 ****************************************************************************************
 */
__STATIC uint16_t m_bearer_send(uint8_t client, m_tb_buf_t *p_buf)
{
    9be8:	9003      	str	r0, [sp, #12]
    9bea:	000c      	movs	r4, r1
	M_PRINTF(L_BEAR, "");
    9bec:	075b      	lsls	r3, r3, #29
    9bee:	d514      	bpl.n	9c1a <m_bearer_send+0x3a>
    9bf0:	4d24      	ldr	r5, [pc, #144]	; (9c84 <m_bearer_send+0xa4>)
    9bf2:	002b      	movs	r3, r5
    9bf4:	002a      	movs	r2, r5
    9bf6:	0028      	movs	r0, r5
    9bf8:	333e      	adds	r3, #62	; 0x3e
    9bfa:	0029      	movs	r1, r5
    9bfc:	3224      	adds	r2, #36	; 0x24
    9bfe:	9300      	str	r3, [sp, #0]
    9c00:	302f      	adds	r0, #47	; 0x2f
    9c02:	2335      	movs	r3, #53	; 0x35
    9c04:	f7fa fed2 	bl	49ac <m_print>
    9c08:	0028      	movs	r0, r5
    9c0a:	304c      	adds	r0, #76	; 0x4c
    9c0c:	f7fa fece 	bl	49ac <m_print>
    9c10:	0028      	movs	r0, r5
    9c12:	1da9      	adds	r1, r5, #6
    9c14:	304d      	adds	r0, #77	; 0x4d
    9c16:	f7fa fec9 	bl	49ac <m_print>
    9c1a:	2018      	movs	r0, #24
        m_lay_bearer_buf_env_t *p_env = (m_lay_bearer_buf_env_t *)&p_buf->env[0];
        // Get bearer information
        m_bearer_t *p_bearer = &p_m_bearer_env->bearers[p_env->bearer_lid];

        // Check if bearer is opened
        if (!GETB(p_bearer->state, M_BEARER_OPEN) || GETB(p_bearer->state, M_BEARER_PAUSE))
    9c1c:	2203      	movs	r2, #3
    do
    {
        // Get buffer environment
        m_lay_bearer_buf_env_t *p_env = (m_lay_bearer_buf_env_t *)&p_buf->env[0];
        // Get bearer information
        m_bearer_t *p_bearer = &p_m_bearer_env->bearers[p_env->bearer_lid];
    9c1e:	4b1a      	ldr	r3, [pc, #104]	; (9c88 <m_bearer_send+0xa8>)
    9c20:	681e      	ldr	r6, [r3, #0]
    9c22:	7c63      	ldrb	r3, [r4, #17]
    9c24:	4358      	muls	r0, r3
    9c26:	1833      	adds	r3, r6, r0

        // Check if bearer is opened
        if (!GETB(p_bearer->state, M_BEARER_OPEN) || GETB(p_bearer->state, M_BEARER_PAUSE))
    9c28:	1c9f      	adds	r7, r3, #2
    9c2a:	7ff9      	ldrb	r1, [r7, #31]
    9c2c:	9002      	str	r0, [sp, #8]
    9c2e:	400a      	ands	r2, r1
    9c30:	2a01      	cmp	r2, #1
    9c32:	d121      	bne.n	9c78 <m_bearer_send+0x98>
            status = M_ERR_COMMAND_DISALLOWED;
            break;
        }

        // Prepare packet for transmission
        switch (p_bearer->type)
    9c34:	3301      	adds	r3, #1
    9c36:	7fdb      	ldrb	r3, [r3, #31]
    9c38:	2b00      	cmp	r3, #0
    9c3a:	d11d      	bne.n	9c78 <m_bearer_send+0x98>
        {
            case (M_BEARER_TYPE_ADV):
            {
                status = m_bearer_adv_tx_prepare(p_buf);
    9c3c:	0020      	movs	r0, r4
    9c3e:	f000 fb4b 	bl	a2d8 <m_bearer_adv_tx_prepare>
    9c42:	1e05      	subs	r5, r0, #0
                status = M_ERR_COMMAND_DISALLOWED;
            } break;
        }

        // Check that transmission can be performed
        if (status != M_ERR_NO_ERROR)
    9c44:	d119      	bne.n	9c7a <m_bearer_send+0x9a>
        {
            break;
        }

        // Keep in mind which client has pushed the buffer
        p_env->client  = client;
    9c46:	466b      	mov	r3, sp
    9c48:	7b1b      	ldrb	r3, [r3, #12]

        // Acquire buffer
        m_tb_buf_acquire(p_buf);
    9c4a:	0020      	movs	r0, r4
        {
            break;
        }

        // Keep in mind which client has pushed the buffer
        p_env->client  = client;
    9c4c:	74e3      	strb	r3, [r4, #19]

        // Acquire buffer
        m_tb_buf_acquire(p_buf);
    9c4e:	f007 fd21 	bl	11694 <m_tb_buf_acquire>

        // Add the buffer in the TX queue
        co_list_push_back(&p_bearer->tx_queue, &p_buf->hdr);
    9c52:	9b02      	ldr	r3, [sp, #8]
    9c54:	0021      	movs	r1, r4
    9c56:	18f0      	adds	r0, r6, r3
    9c58:	3018      	adds	r0, #24
    9c5a:	f7fa fb9c 	bl	4396 <co_list_push_back>

        // Check if transmission can be immediately started
        if (!GETB(p_bearer->state, M_BEARER_TX))
    9c5e:	2204      	movs	r2, #4
    9c60:	7ffb      	ldrb	r3, [r7, #31]
    9c62:	4213      	tst	r3, r2
    9c64:	d109      	bne.n	9c7a <m_bearer_send+0x9a>
        {
            SETB(p_bearer->state, M_BEARER_TX, 1);
    9c66:	4313      	orrs	r3, r2
    9c68:	77fb      	strb	r3, [r7, #31]
            m_al_djob_reg(&(p_bearer->djob));
    9c6a:	9b02      	ldr	r3, [sp, #8]
    9c6c:	18f6      	adds	r6, r6, r3
    9c6e:	0030      	movs	r0, r6
    9c70:	300c      	adds	r0, #12
    9c72:	f7fb f80b 	bl	4c8c <m_al_djob_reg>
    9c76:	e000      	b.n	9c7a <m_bearer_send+0x9a>
            } break;
            #endif //(BLE_MESH_GATT_BEARER)

            default:
            {
                status = M_ERR_COMMAND_DISALLOWED;
    9c78:	4d04      	ldr	r5, [pc, #16]	; (9c8c <m_bearer_send+0xac>)
            m_al_djob_reg(&(p_bearer->djob));
        }
    } while (0);

    return (status);
}
    9c7a:	0028      	movs	r0, r5
    9c7c:	b005      	add	sp, #20
    9c7e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    9c80:	10010514 	.word	0x10010514
    9c84:	00021420 	.word	0x00021420
    9c88:	100128a0 	.word	0x100128a0
    9c8c:	00000282 	.word	0x00000282

00009c90 <m_bearer_update>:
 * @return Execution status
 ****************************************************************************************
 */
__STATIC uint16_t m_bearer_update(m_lid_t bearer_lid, uint8_t action)
{
	M_PRINTF(L_BEAR, "");
    9c90:	4b17      	ldr	r3, [pc, #92]	; (9cf0 <m_bearer_update+0x60>)
 *
 * @return Execution status
 ****************************************************************************************
 */
__STATIC uint16_t m_bearer_update(m_lid_t bearer_lid, uint8_t action)
{
    9c92:	b573      	push	{r0, r1, r4, r5, r6, lr}
	M_PRINTF(L_BEAR, "");
    9c94:	681b      	ldr	r3, [r3, #0]
 *
 * @return Execution status
 ****************************************************************************************
 */
__STATIC uint16_t m_bearer_update(m_lid_t bearer_lid, uint8_t action)
{
    9c96:	0006      	movs	r6, r0
    9c98:	000d      	movs	r5, r1
	M_PRINTF(L_BEAR, "");
    9c9a:	075b      	lsls	r3, r3, #29
    9c9c:	d514      	bpl.n	9cc8 <m_bearer_update+0x38>
    9c9e:	4c15      	ldr	r4, [pc, #84]	; (9cf4 <m_bearer_update+0x64>)
    9ca0:	0023      	movs	r3, r4
    9ca2:	0022      	movs	r2, r4
    9ca4:	0020      	movs	r0, r4
    9ca6:	3350      	adds	r3, #80	; 0x50
    9ca8:	0021      	movs	r1, r4
    9caa:	3224      	adds	r2, #36	; 0x24
    9cac:	9300      	str	r3, [sp, #0]
    9cae:	302f      	adds	r0, #47	; 0x2f
    9cb0:	2388      	movs	r3, #136	; 0x88
    9cb2:	f7fa fe7b 	bl	49ac <m_print>
    9cb6:	0020      	movs	r0, r4
    9cb8:	304c      	adds	r0, #76	; 0x4c
    9cba:	f7fa fe77 	bl	49ac <m_print>
    9cbe:	0020      	movs	r0, r4
    9cc0:	1da1      	adds	r1, r4, #6
    9cc2:	304d      	adds	r0, #77	; 0x4d
    9cc4:	f7fa fe72 	bl	49ac <m_print>
    9cc8:	2018      	movs	r0, #24
    9cca:	4b0b      	ldr	r3, [pc, #44]	; (9cf8 <m_bearer_update+0x68>)
    9ccc:	4370      	muls	r0, r6
    9cce:	681b      	ldr	r3, [r3, #0]
    9cd0:	1818      	adds	r0, r3, r0
    uint16_t status;
    // Get bearer information
    m_bearer_t *p_bearer = &p_m_bearer_env->bearers[bearer_lid];

    // Check if bearer is opened
    if (!GETB(p_bearer->state, M_BEARER_OPEN))
    9cd2:	1c83      	adds	r3, r0, #2
    9cd4:	7fdb      	ldrb	r3, [r3, #31]
    9cd6:	07db      	lsls	r3, r3, #31
    9cd8:	d507      	bpl.n	9cea <m_bearer_update+0x5a>
        status = M_ERR_COMMAND_DISALLOWED;
    }
    else
    {
        // Prepare packet for transmission
        switch (p_bearer->type)
    9cda:	3001      	adds	r0, #1
    9cdc:	7fc3      	ldrb	r3, [r0, #31]
    9cde:	2b00      	cmp	r3, #0
    9ce0:	d103      	bne.n	9cea <m_bearer_update+0x5a>
        {
            case (M_BEARER_TYPE_ADV):
            {
                status = m_bearer_adv_update(action);
    9ce2:	0028      	movs	r0, r5
    9ce4:	f000 fb7e 	bl	a3e4 <m_bearer_adv_update>
            } break;
    9ce8:	e000      	b.n	9cec <m_bearer_update+0x5c>
            } break;
            #endif //(BLE_MESH_GATT_BEARER)

            default:
            {
                status = M_ERR_COMMAND_DISALLOWED;
    9cea:	4804      	ldr	r0, [pc, #16]	; (9cfc <m_bearer_update+0x6c>)
            } break;
        }
    }

    return (status);
}
    9cec:	bd76      	pop	{r1, r2, r4, r5, r6, pc}
    9cee:	46c0      	nop			; (mov r8, r8)
    9cf0:	10010514 	.word	0x10010514
    9cf4:	00021420 	.word	0x00021420
    9cf8:	100128a0 	.word	0x100128a0
    9cfc:	00000282 	.word	0x00000282

00009d00 <m_bearer_send_continue>:
 *
 * @return M_ERR_NO_ERROR if PDU has been properly pushed.
 ****************************************************************************************
 */
__STATIC void m_bearer_send_continue(m_bearer_t* p_bearer)
{
    9d00:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    9d02:	68c6      	ldr	r6, [r0, #12]
    9d04:	0005      	movs	r5, r0
	
    m_tb_buf_t *p_buf = (m_tb_buf_t *)co_list_pick(&(p_bearer->tx_queue));

    if (p_buf != NULL)
    9d06:	2e00      	cmp	r6, #0
    9d08:	d048      	beq.n	9d9c <m_bearer_send_continue+0x9c>
    {
        uint16_t status;

        // Check if bearer is opened
        if (!GETB(p_bearer->state, M_BEARER_OPEN) || GETB(p_bearer->state, M_BEARER_PAUSE))
    9d0a:	2303      	movs	r3, #3
    9d0c:	7d42      	ldrb	r2, [r0, #21]
    9d0e:	4013      	ands	r3, r2
    9d10:	2b01      	cmp	r3, #1
    9d12:	d107      	bne.n	9d24 <m_bearer_send_continue+0x24>
            status = M_ERR_BEARER_CLOSED;
        }
        else
        {
            // Request bearer to send packet
            switch (p_bearer->type)
    9d14:	7d03      	ldrb	r3, [r0, #20]
    9d16:	2b00      	cmp	r3, #0
    9d18:	d106      	bne.n	9d28 <m_bearer_send_continue+0x28>
            {
                case (M_BEARER_TYPE_ADV):
                {
                    status = m_bearer_adv_send(p_buf);
    9d1a:	0030      	movs	r0, r6
    9d1c:	f000 fb1a 	bl	a354 <m_bearer_adv_send>
    9d20:	0007      	movs	r7, r0
                } break;
    9d22:	e002      	b.n	9d2a <m_bearer_send_continue+0x2a>
        uint16_t status;

        // Check if bearer is opened
        if (!GETB(p_bearer->state, M_BEARER_OPEN) || GETB(p_bearer->state, M_BEARER_PAUSE))
        {
            status = M_ERR_BEARER_CLOSED;
    9d24:	4f1e      	ldr	r7, [pc, #120]	; (9da0 <m_bearer_send_continue+0xa0>)
    9d26:	e000      	b.n	9d2a <m_bearer_send_continue+0x2a>
                } break;
                #endif //(BLE_MESH_GATT_BEARER)

                default:
                {
                    status = M_ERR_COMMAND_DISALLOWED;
    9d28:	4f1e      	ldr	r7, [pc, #120]	; (9da4 <m_bearer_send_continue+0xa4>)
                } break;
            }
        }
		M_PRINTF(L_BEAR, "status = %d", status);
    9d2a:	4b1f      	ldr	r3, [pc, #124]	; (9da8 <m_bearer_send_continue+0xa8>)
    9d2c:	681b      	ldr	r3, [r3, #0]
    9d2e:	075b      	lsls	r3, r3, #29
    9d30:	d515      	bpl.n	9d5e <m_bearer_send_continue+0x5e>
    9d32:	4c1e      	ldr	r4, [pc, #120]	; (9dac <m_bearer_send_continue+0xac>)
    9d34:	0023      	movs	r3, r4
    9d36:	0022      	movs	r2, r4
    9d38:	0020      	movs	r0, r4
    9d3a:	3360      	adds	r3, #96	; 0x60
    9d3c:	3224      	adds	r2, #36	; 0x24
    9d3e:	9300      	str	r3, [sp, #0]
    9d40:	0021      	movs	r1, r4
    9d42:	23e6      	movs	r3, #230	; 0xe6
    9d44:	302f      	adds	r0, #47	; 0x2f
    9d46:	f7fa fe31 	bl	49ac <m_print>
    9d4a:	0020      	movs	r0, r4
    9d4c:	0039      	movs	r1, r7
    9d4e:	3077      	adds	r0, #119	; 0x77
    9d50:	f7fa fe2c 	bl	49ac <m_print>
    9d54:	0020      	movs	r0, r4
    9d56:	1da1      	adds	r1, r4, #6
    9d58:	304d      	adds	r0, #77	; 0x4d
    9d5a:	f7fa fe27 	bl	49ac <m_print>
        // An error has occurred, inform requester
        if (status != M_ERR_NO_ERROR)
    9d5e:	2f00      	cmp	r7, #0
    9d60:	d01c      	beq.n	9d9c <m_bearer_send_continue+0x9c>
        {
            // Get pointer to buffer environment
            m_lay_bearer_buf_env_t *p_env = (m_lay_bearer_buf_env_t *)&p_buf->env[0];

            // Remove buffer from TX queue
            co_list_pop_front(&p_bearer->tx_queue);
    9d62:	0028      	movs	r0, r5
    9d64:	300c      	adds	r0, #12
    9d66:	f7fa fb41 	bl	43ec <co_list_pop_front>

            if (p_m_bearer_env->p_cb[p_env->client])
    9d6a:	4b11      	ldr	r3, [pc, #68]	; (9db0 <m_bearer_send_continue+0xb0>)
    9d6c:	681a      	ldr	r2, [r3, #0]
    9d6e:	7cf3      	ldrb	r3, [r6, #19]
    9d70:	009b      	lsls	r3, r3, #2
    9d72:	589b      	ldr	r3, [r3, r2]
    9d74:	2b00      	cmp	r3, #0
    9d76:	d003      	beq.n	9d80 <m_bearer_send_continue+0x80>
            {
                p_m_bearer_env->p_cb[p_env->client]->sent(p_buf, status);
    9d78:	681b      	ldr	r3, [r3, #0]
    9d7a:	0039      	movs	r1, r7
    9d7c:	0030      	movs	r0, r6
    9d7e:	4798      	blx	r3
            }

            // Release the buffer
            m_tb_buf_release(p_buf);
    9d80:	0030      	movs	r0, r6
    9d82:	f007 fc8b 	bl	1169c <m_tb_buf_release>

            // Check if another buffer can be pushed
            if (!co_list_is_empty(&p_bearer->tx_queue))
    9d86:	68eb      	ldr	r3, [r5, #12]
    9d88:	2b00      	cmp	r3, #0
    9d8a:	d003      	beq.n	9d94 <m_bearer_send_continue+0x94>
            {
                m_al_djob_reg(&(p_bearer->djob));
    9d8c:	0028      	movs	r0, r5
    9d8e:	f7fa ff7d 	bl	4c8c <m_al_djob_reg>
    9d92:	e003      	b.n	9d9c <m_bearer_send_continue+0x9c>
            }
            else
            {
                SETB(p_bearer->state, M_BEARER_TX, 0);
    9d94:	2204      	movs	r2, #4
    9d96:	7d6b      	ldrb	r3, [r5, #21]
    9d98:	4393      	bics	r3, r2
    9d9a:	756b      	strb	r3, [r5, #21]
            }
        }
    }
}
    9d9c:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
    9d9e:	46c0      	nop			; (mov r8, r8)
    9da0:	00000882 	.word	0x00000882
    9da4:	00000282 	.word	0x00000282
    9da8:	10010514 	.word	0x10010514
    9dac:	00021420 	.word	0x00021420
    9db0:	100128a0 	.word	0x100128a0

00009db4 <m_bearer_init>:
 * GLOBAL FUNCTIONS
 ****************************************************************************************
 */

uint16_t m_bearer_init(bool reset, void* p_env, const m_cfg_t* p_cfg)
{
    9db4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    9db6:	0005      	movs	r5, r0
    9db8:	000c      	movs	r4, r1
    9dba:	4f14      	ldr	r7, [pc, #80]	; (9e0c <m_bearer_init+0x58>)
    if (!reset)
    9dbc:	2800      	cmp	r0, #0
    9dbe:	d120      	bne.n	9e02 <m_bearer_init+0x4e>

        // Keep address of environment for bearer layer
        p_m_bearer_env = (m_bearer_env_t *)p_env;

        // Clean the environment
        p_m_bearer_env->nb_bearers = 0;
    9dc0:	000b      	movs	r3, r1
    9dc2:	3345      	adds	r3, #69	; 0x45
    9dc4:	7018      	strb	r0, [r3, #0]
        p_m_bearer_env->bearers_started = 0;
    9dc6:	3b01      	subs	r3, #1
    9dc8:	7018      	strb	r0, [r3, #0]
    if (!reset)
    {
        uint8_t cnt;

        // Keep address of environment for bearer layer
        p_m_bearer_env = (m_bearer_env_t *)p_env;
    9dca:	6039      	str	r1, [r7, #0]

        // Clean the environment
        p_m_bearer_env->nb_bearers = 0;
        p_m_bearer_env->bearers_started = 0;
        p_m_bearer_env->cb_end = NULL;
    9dcc:	63e0      	str	r0, [r4, #60]	; 0x3c
        p_m_bearer_env->adv.p_api = NULL;
    9dce:	6420      	str	r0, [r4, #64]	; 0x40
        p_m_bearer_env->gatt.type = M_BEARER_GATT_INVALID;
        #endif // (BLE_MESH_GATT_BEARER)

        for (cnt = 0; cnt < M_BEARER_CLI_NB; cnt++)
        {
            p_m_bearer_env->p_cb[cnt] = NULL;
    9dd0:	6020      	str	r0, [r4, #0]
    9dd2:	6060      	str	r0, [r4, #4]
    9dd4:	60a0      	str	r0, [r4, #8]
        // Initialize bearers
        for (cnt = 0; cnt < M_BEARER_MAX; cnt++)
        {
            m_bearer_t *p_bearer = &p_m_bearer_env->bearers[cnt];

            co_list_init(&(p_bearer->tx_queue));
    9dd6:	0008      	movs	r0, r1
    9dd8:	3018      	adds	r0, #24
    9dda:	f7fa faa1 	bl	4320 <co_list_init>

            p_bearer->state = 0;
    9dde:	1ca3      	adds	r3, r4, #2
            p_bearer->djob.cb = (m_al_djob_cb) m_bearer_send_continue;
    9de0:	4e0b      	ldr	r6, [pc, #44]	; (9e10 <m_bearer_init+0x5c>)
        {
            m_bearer_t *p_bearer = &p_m_bearer_env->bearers[cnt];

            co_list_init(&(p_bearer->tx_queue));

            p_bearer->state = 0;
    9de2:	77dd      	strb	r5, [r3, #31]
        }

        // Initialize bearers
        for (cnt = 0; cnt < M_BEARER_MAX; cnt++)
        {
            m_bearer_t *p_bearer = &p_m_bearer_env->bearers[cnt];
    9de4:	330a      	adds	r3, #10

            co_list_init(&(p_bearer->tx_queue));

            p_bearer->state = 0;
            p_bearer->djob.cb = (m_al_djob_cb) m_bearer_send_continue;
            p_bearer->djob.p_env = p_bearer;
    9de6:	6123      	str	r3, [r4, #16]
            m_bearer_t *p_bearer = &p_m_bearer_env->bearers[cnt];

            co_list_init(&(p_bearer->tx_queue));

            p_bearer->state = 0;
            p_bearer->djob.cb = (m_al_djob_cb) m_bearer_send_continue;
    9de8:	6166      	str	r6, [r4, #20]
        }

        // Initialize bearers
        for (cnt = 0; cnt < M_BEARER_MAX; cnt++)
        {
            m_bearer_t *p_bearer = &p_m_bearer_env->bearers[cnt];
    9dea:	683c      	ldr	r4, [r7, #0]

            co_list_init(&(p_bearer->tx_queue));
    9dec:	0020      	movs	r0, r4
    9dee:	3030      	adds	r0, #48	; 0x30
    9df0:	f7fa fa96 	bl	4320 <co_list_init>

            p_bearer->state = 0;
    9df4:	0023      	movs	r3, r4
    9df6:	3339      	adds	r3, #57	; 0x39
    9df8:	701d      	strb	r5, [r3, #0]
        }

        // Initialize bearers
        for (cnt = 0; cnt < M_BEARER_MAX; cnt++)
        {
            m_bearer_t *p_bearer = &p_m_bearer_env->bearers[cnt];
    9dfa:	3b15      	subs	r3, #21

            co_list_init(&(p_bearer->tx_queue));

            p_bearer->state = 0;
            p_bearer->djob.cb = (m_al_djob_cb) m_bearer_send_continue;
    9dfc:	62e6      	str	r6, [r4, #44]	; 0x2c
            p_bearer->djob.p_env = p_bearer;
    9dfe:	62a3      	str	r3, [r4, #40]	; 0x28
    9e00:	e001      	b.n	9e06 <m_bearer_init+0x52>
        }
    }
    else
    {
        p_m_bearer_env = NULL;
    9e02:	2300      	movs	r3, #0
    9e04:	603b      	str	r3, [r7, #0]
    }

    return (sizeof(m_bearer_env_t));
}
    9e06:	2048      	movs	r0, #72	; 0x48
    9e08:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    9e0a:	46c0      	nop			; (mov r8, r8)
    9e0c:	100128a0 	.word	0x100128a0
    9e10:	00009d01 	.word	0x00009d01

00009e14 <m_bearer_get_env_size>:

uint16_t m_bearer_get_env_size(const m_cfg_t* p_cfg)
{
    return (sizeof(m_bearer_env_t));
}
    9e14:	2048      	movs	r0, #72	; 0x48
    9e16:	4770      	bx	lr

00009e18 <m_bearer_connect_client_cb>:

void m_bearer_connect_client_cb(uint8_t client, const m_bearer_cb_t *p_cb)
{
    p_m_bearer_env->p_cb[client] = p_cb;
    9e18:	4b02      	ldr	r3, [pc, #8]	; (9e24 <m_bearer_connect_client_cb+0xc>)
    9e1a:	0080      	lsls	r0, r0, #2
    9e1c:	681b      	ldr	r3, [r3, #0]
    9e1e:	50c1      	str	r1, [r0, r3]
}
    9e20:	4770      	bx	lr
    9e22:	46c0      	nop			; (mov r8, r8)
    9e24:	100128a0 	.word	0x100128a0

00009e28 <m_bearer_start>:

uint16_t m_bearer_start(uint8_t bearer_type, uint16_t data_len, const uint8_t* p_data, m_bearer_op_end_cb cb)
{
    9e28:	b5f0      	push	{r4, r5, r6, r7, lr}
	M_PRINTF(L_BEAR, "bearer_type = %d", bearer_type);
    9e2a:	4d25      	ldr	r5, [pc, #148]	; (9ec0 <m_bearer_start+0x98>)
{
    p_m_bearer_env->p_cb[client] = p_cb;
}

uint16_t m_bearer_start(uint8_t bearer_type, uint16_t data_len, const uint8_t* p_data, m_bearer_op_end_cb cb)
{
    9e2c:	b085      	sub	sp, #20
    9e2e:	9303      	str	r3, [sp, #12]
	M_PRINTF(L_BEAR, "bearer_type = %d", bearer_type);
    9e30:	682b      	ldr	r3, [r5, #0]
{
    p_m_bearer_env->p_cb[client] = p_cb;
}

uint16_t m_bearer_start(uint8_t bearer_type, uint16_t data_len, const uint8_t* p_data, m_bearer_op_end_cb cb)
{
    9e32:	0006      	movs	r6, r0
	M_PRINTF(L_BEAR, "bearer_type = %d", bearer_type);
    9e34:	075b      	lsls	r3, r3, #29
    9e36:	d516      	bpl.n	9e66 <m_bearer_start+0x3e>
    9e38:	4f22      	ldr	r7, [pc, #136]	; (9ec4 <m_bearer_start+0x9c>)
    9e3a:	4c23      	ldr	r4, [pc, #140]	; (9ec8 <m_bearer_start+0xa0>)
    9e3c:	1cfb      	adds	r3, r7, #3
    9e3e:	9300      	str	r3, [sp, #0]
    9e40:	0022      	movs	r2, r4
    9e42:	0020      	movs	r0, r4
    9e44:	23a1      	movs	r3, #161	; 0xa1
    9e46:	3224      	adds	r2, #36	; 0x24
    9e48:	005b      	lsls	r3, r3, #1
    9e4a:	0021      	movs	r1, r4
    9e4c:	302f      	adds	r0, #47	; 0x2f
    9e4e:	f7fa fdad 	bl	49ac <m_print>
    9e52:	0038      	movs	r0, r7
    9e54:	0031      	movs	r1, r6
    9e56:	3012      	adds	r0, #18
    9e58:	f7fa fda8 	bl	49ac <m_print>
    9e5c:	0020      	movs	r0, r4
    9e5e:	1da1      	adds	r1, r4, #6
    9e60:	304d      	adds	r0, #77	; 0x4d
    9e62:	f7fa fda3 	bl	49ac <m_print>
    // Status
    uint16_t status = M_ERR_NO_ERROR;

	M_PRINTF(L_BEAR, "cb_end = %d", p_m_bearer_env->cb_end);
    9e66:	682b      	ldr	r3, [r5, #0]
    9e68:	4f18      	ldr	r7, [pc, #96]	; (9ecc <m_bearer_start+0xa4>)
    9e6a:	075b      	lsls	r3, r3, #29
    9e6c:	d517      	bpl.n	9e9e <m_bearer_start+0x76>
    9e6e:	4d15      	ldr	r5, [pc, #84]	; (9ec4 <m_bearer_start+0x9c>)
    9e70:	4c15      	ldr	r4, [pc, #84]	; (9ec8 <m_bearer_start+0xa0>)
    9e72:	1ceb      	adds	r3, r5, #3
    9e74:	9300      	str	r3, [sp, #0]
    9e76:	0022      	movs	r2, r4
    9e78:	0020      	movs	r0, r4
    9e7a:	23a3      	movs	r3, #163	; 0xa3
    9e7c:	3224      	adds	r2, #36	; 0x24
    9e7e:	005b      	lsls	r3, r3, #1
    9e80:	0021      	movs	r1, r4
    9e82:	302f      	adds	r0, #47	; 0x2f
    9e84:	f7fa fd92 	bl	49ac <m_print>
    9e88:	0028      	movs	r0, r5
    9e8a:	683b      	ldr	r3, [r7, #0]
    9e8c:	3023      	adds	r0, #35	; 0x23
    9e8e:	6bd9      	ldr	r1, [r3, #60]	; 0x3c
    9e90:	f7fa fd8c 	bl	49ac <m_print>
    9e94:	0020      	movs	r0, r4
    9e96:	1da1      	adds	r1, r4, #6
    9e98:	304d      	adds	r0, #77	; 0x4d
    9e9a:	f7fa fd87 	bl	49ac <m_print>
    if (p_m_bearer_env->cb_end != NULL)
    9e9e:	683b      	ldr	r3, [r7, #0]
    9ea0:	6bda      	ldr	r2, [r3, #60]	; 0x3c
    9ea2:	2a00      	cmp	r2, #0
    9ea4:	d106      	bne.n	9eb4 <m_bearer_start+0x8c>
        status = M_ERR_COMMAND_DISALLOWED;
    }
    else
    {
#ifndef PROC_BLOCK
    	p_m_bearer_env->cb_end = cb;
    9ea6:	9a03      	ldr	r2, [sp, #12]
    9ea8:	63da      	str	r2, [r3, #60]	; 0x3c
#endif
        switch (bearer_type)
    9eaa:	2e00      	cmp	r6, #0
    9eac:	d104      	bne.n	9eb8 <m_bearer_start+0x90>
        {
            case (M_BEARER_TYPE_ADV):
            {
                status = m_bearer_adv_start();
    9eae:	f000 f9ee 	bl	a28e <m_bearer_adv_start>
            } break;
    9eb2:	e003      	b.n	9ebc <m_bearer_start+0x94>
    uint16_t status = M_ERR_NO_ERROR;

	M_PRINTF(L_BEAR, "cb_end = %d", p_m_bearer_env->cb_end);
    if (p_m_bearer_env->cb_end != NULL)
    {
        status = M_ERR_COMMAND_DISALLOWED;
    9eb4:	4806      	ldr	r0, [pc, #24]	; (9ed0 <m_bearer_start+0xa8>)
    9eb6:	e001      	b.n	9ebc <m_bearer_start+0x94>
            } break;
            #endif //(BLE_MESH_GATT_BEARER)

            default:
            {
                status = M_ERR_INVALID_PARAM;
    9eb8:	20c1      	movs	r0, #193	; 0xc1
    9eba:	0040      	lsls	r0, r0, #1
        // Keep provided callback
        p_m_bearer_env->cb_end = cb;
    }
#endif
    return (status);
}
    9ebc:	b005      	add	sp, #20
    9ebe:	bdf0      	pop	{r4, r5, r6, r7, pc}
    9ec0:	10010514 	.word	0x10010514
    9ec4:	000214a0 	.word	0x000214a0
    9ec8:	00021420 	.word	0x00021420
    9ecc:	100128a0 	.word	0x100128a0
    9ed0:	00000282 	.word	0x00000282

00009ed4 <m_bearer_stop>:
uint16_t m_bearer_stop(uint8_t bearer_type, m_bearer_op_end_cb cb_end)
{
    // Status
    uint16_t status = M_ERR_NO_ERROR;

    if (p_m_bearer_env->cb_end != NULL){
    9ed4:	4b08      	ldr	r3, [pc, #32]	; (9ef8 <m_bearer_stop+0x24>)
#endif
    return (status);
}

uint16_t m_bearer_stop(uint8_t bearer_type, m_bearer_op_end_cb cb_end)
{
    9ed6:	b510      	push	{r4, lr}
    // Status
    uint16_t status = M_ERR_NO_ERROR;

    if (p_m_bearer_env->cb_end != NULL){
    9ed8:	681b      	ldr	r3, [r3, #0]
    9eda:	6bda      	ldr	r2, [r3, #60]	; 0x3c
    9edc:	2a00      	cmp	r2, #0
    9ede:	d105      	bne.n	9eec <m_bearer_stop+0x18>
        status = M_ERR_COMMAND_DISALLOWED;
    }
    else{
#ifndef PROC_BLOCK
    	p_m_bearer_env->cb_end = cb_end;
    9ee0:	63d9      	str	r1, [r3, #60]	; 0x3c
#endif
        switch (bearer_type){
    9ee2:	2800      	cmp	r0, #0
    9ee4:	d104      	bne.n	9ef0 <m_bearer_stop+0x1c>
            case (M_BEARER_TYPE_ADV):{
                status = m_bearer_adv_stop();
    9ee6:	f000 f9cd 	bl	a284 <m_bearer_adv_stop>
            } break;
    9eea:	e003      	b.n	9ef4 <m_bearer_stop+0x20>
{
    // Status
    uint16_t status = M_ERR_NO_ERROR;

    if (p_m_bearer_env->cb_end != NULL){
        status = M_ERR_COMMAND_DISALLOWED;
    9eec:	4803      	ldr	r0, [pc, #12]	; (9efc <m_bearer_stop+0x28>)
    9eee:	e001      	b.n	9ef4 <m_bearer_stop+0x20>
                status = m_bearer_gatt_stop();
            } break;
            #endif //(BLE_MESH_GATT_BEARER)

            default:{
                status = M_ERR_INVALID_PARAM;
    9ef0:	20c1      	movs	r0, #193	; 0xc1
    9ef2:	0040      	lsls	r0, r0, #1
        // Keep provided callback
        p_m_bearer_env->cb_end = cb_end;
    }
#endif
    return (status);
}
    9ef4:	bd10      	pop	{r4, pc}
    9ef6:	46c0      	nop			; (mov r8, r8)
    9ef8:	100128a0 	.word	0x100128a0
    9efc:	00000282 	.word	0x00000282

00009f00 <m_bearer_started>:

void m_bearer_started(uint8_t bearer_type, uint8_t status)
{
	M_PRINTF(L_BEAR, "%p", p_m_bearer_env->cb_end);
    9f00:	4b14      	ldr	r3, [pc, #80]	; (9f54 <m_bearer_started+0x54>)
#endif
    return (status);
}

void m_bearer_started(uint8_t bearer_type, uint8_t status)
{
    9f02:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	M_PRINTF(L_BEAR, "%p", p_m_bearer_env->cb_end);
    9f04:	681b      	ldr	r3, [r3, #0]
#endif
    return (status);
}

void m_bearer_started(uint8_t bearer_type, uint8_t status)
{
    9f06:	000d      	movs	r5, r1
    9f08:	4e13      	ldr	r6, [pc, #76]	; (9f58 <m_bearer_started+0x58>)
	M_PRINTF(L_BEAR, "%p", p_m_bearer_env->cb_end);
    9f0a:	075b      	lsls	r3, r3, #29
    9f0c:	d518      	bpl.n	9f40 <m_bearer_started+0x40>
    9f0e:	4f13      	ldr	r7, [pc, #76]	; (9f5c <m_bearer_started+0x5c>)
    9f10:	4c13      	ldr	r4, [pc, #76]	; (9f60 <m_bearer_started+0x60>)
    9f12:	003b      	movs	r3, r7
    9f14:	332f      	adds	r3, #47	; 0x2f
    9f16:	9300      	str	r3, [sp, #0]
    9f18:	0022      	movs	r2, r4
    9f1a:	0020      	movs	r0, r4
    9f1c:	23a2      	movs	r3, #162	; 0xa2
    9f1e:	3224      	adds	r2, #36	; 0x24
    9f20:	33ff      	adds	r3, #255	; 0xff
    9f22:	0021      	movs	r1, r4
    9f24:	302f      	adds	r0, #47	; 0x2f
    9f26:	f7fa fd41 	bl	49ac <m_print>
    9f2a:	0038      	movs	r0, r7
    9f2c:	6833      	ldr	r3, [r6, #0]
    9f2e:	3040      	adds	r0, #64	; 0x40
    9f30:	6bd9      	ldr	r1, [r3, #60]	; 0x3c
    9f32:	f7fa fd3b 	bl	49ac <m_print>
    9f36:	0020      	movs	r0, r4
    9f38:	1da1      	adds	r1, r4, #6
    9f3a:	304d      	adds	r0, #77	; 0x4d
    9f3c:	f7fa fd36 	bl	49ac <m_print>
    m_bearer_op_end_cb op_cb = p_m_bearer_env->cb_end;

    p_m_bearer_env->cb_end = NULL;
    9f40:	2100      	movs	r1, #0
}

void m_bearer_started(uint8_t bearer_type, uint8_t status)
{
	M_PRINTF(L_BEAR, "%p", p_m_bearer_env->cb_end);
    m_bearer_op_end_cb op_cb = p_m_bearer_env->cb_end;
    9f42:	6832      	ldr	r2, [r6, #0]
    9f44:	6bd3      	ldr	r3, [r2, #60]	; 0x3c

    p_m_bearer_env->cb_end = NULL;
    9f46:	63d1      	str	r1, [r2, #60]	; 0x3c

    // Inform that operation is over
    if (op_cb){
    9f48:	428b      	cmp	r3, r1
    9f4a:	d001      	beq.n	9f50 <m_bearer_started+0x50>
        op_cb(status);
    9f4c:	b2a8      	uxth	r0, r5
    9f4e:	4798      	blx	r3
    }
}
    9f50:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
    9f52:	46c0      	nop			; (mov r8, r8)
    9f54:	10010514 	.word	0x10010514
    9f58:	100128a0 	.word	0x100128a0
    9f5c:	000214a0 	.word	0x000214a0
    9f60:	00021420 	.word	0x00021420

00009f64 <m_bearer_stopped>:

void m_bearer_stopped(uint8_t bearer_type, uint8_t status)
{
    m_bearer_op_end_cb op_cb = p_m_bearer_env->cb_end;

    p_m_bearer_env->cb_end = NULL;
    9f64:	2000      	movs	r0, #0
    }
}

void m_bearer_stopped(uint8_t bearer_type, uint8_t status)
{
    m_bearer_op_end_cb op_cb = p_m_bearer_env->cb_end;
    9f66:	4b05      	ldr	r3, [pc, #20]	; (9f7c <m_bearer_stopped+0x18>)
        op_cb(status);
    }
}

void m_bearer_stopped(uint8_t bearer_type, uint8_t status)
{
    9f68:	b510      	push	{r4, lr}
    m_bearer_op_end_cb op_cb = p_m_bearer_env->cb_end;
    9f6a:	681a      	ldr	r2, [r3, #0]
    9f6c:	6bd3      	ldr	r3, [r2, #60]	; 0x3c

    p_m_bearer_env->cb_end = NULL;
    9f6e:	63d0      	str	r0, [r2, #60]	; 0x3c

    // Inform that operation is over
    if (op_cb){
    9f70:	4283      	cmp	r3, r0
    9f72:	d001      	beq.n	9f78 <m_bearer_stopped+0x14>
        op_cb(status);
    9f74:	b288      	uxth	r0, r1
    9f76:	4798      	blx	r3
    }
}
    9f78:	bd10      	pop	{r4, pc}
    9f7a:	46c0      	nop			; (mov r8, r8)
    9f7c:	100128a0 	.word	0x100128a0

00009f80 <m_bearer_opened>:

void m_bearer_opened(m_lid_t bearer_lid, uint8_t bearer_type)
{
    9f80:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    9f82:	0006      	movs	r6, r0
    9f84:	000f      	movs	r7, r1
    // Counter
    uint8_t cnt;

    // Increase number of opened bearers
    p_m_bearer_env->nb_bearers++;
    9f86:	2400      	movs	r4, #0
    9f88:	4d09      	ldr	r5, [pc, #36]	; (9fb0 <m_bearer_opened+0x30>)
    9f8a:	682b      	ldr	r3, [r5, #0]
    9f8c:	3345      	adds	r3, #69	; 0x45
    9f8e:	781a      	ldrb	r2, [r3, #0]
    9f90:	3201      	adds	r2, #1
    9f92:	701a      	strb	r2, [r3, #0]

    // Inform clients that bearer has been opened
    for (cnt = 0; cnt < M_BEARER_CLI_NB; cnt++){
        const m_bearer_cb_t *p_cb = p_m_bearer_env->p_cb[cnt];
    9f94:	682a      	ldr	r2, [r5, #0]
    9f96:	00a3      	lsls	r3, r4, #2
    9f98:	589b      	ldr	r3, [r3, r2]

        if (p_cb){
    9f9a:	2b00      	cmp	r3, #0
    9f9c:	d003      	beq.n	9fa6 <m_bearer_opened+0x26>
            p_cb->opened(bearer_lid, bearer_type);
    9f9e:	689b      	ldr	r3, [r3, #8]
    9fa0:	0039      	movs	r1, r7
    9fa2:	0030      	movs	r0, r6
    9fa4:	4798      	blx	r3
    9fa6:	3401      	adds	r4, #1

    // Increase number of opened bearers
    p_m_bearer_env->nb_bearers++;

    // Inform clients that bearer has been opened
    for (cnt = 0; cnt < M_BEARER_CLI_NB; cnt++){
    9fa8:	2c03      	cmp	r4, #3
    9faa:	d1f3      	bne.n	9f94 <m_bearer_opened+0x14>

        if (p_cb){
            p_cb->opened(bearer_lid, bearer_type);
        }
    }
}
    9fac:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    9fae:	46c0      	nop			; (mov r8, r8)
    9fb0:	100128a0 	.word	0x100128a0

00009fb4 <m_bearer_closed>:

void m_bearer_closed(m_lid_t bearer_lid, uint16_t status)
{
    9fb4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    uint8_t cnt;
    // Get bearer information
    m_bearer_t *p_bearer = &p_m_bearer_env->bearers[bearer_lid];

    // Release the buffers
    while (!co_list_is_empty(&p_bearer->tx_queue))
    9fb6:	2418      	movs	r4, #24
        }
    }
}

void m_bearer_closed(m_lid_t bearer_lid, uint16_t status)
{
    9fb8:	0006      	movs	r6, r0
    // Counter
    uint8_t cnt;
    // Get bearer information
    m_bearer_t *p_bearer = &p_m_bearer_env->bearers[bearer_lid];
    9fba:	4d15      	ldr	r5, [pc, #84]	; (a010 <m_bearer_closed+0x5c>)

    // Release the buffers
    while (!co_list_is_empty(&p_bearer->tx_queue))
    9fbc:	4344      	muls	r4, r0
void m_bearer_closed(m_lid_t bearer_lid, uint16_t status)
{
    // Counter
    uint8_t cnt;
    // Get bearer information
    m_bearer_t *p_bearer = &p_m_bearer_env->bearers[bearer_lid];
    9fbe:	682b      	ldr	r3, [r5, #0]

    // Release the buffers
    while (!co_list_is_empty(&p_bearer->tx_queue))
    9fc0:	191c      	adds	r4, r3, r4
    9fc2:	3418      	adds	r4, #24
    9fc4:	6823      	ldr	r3, [r4, #0]
    9fc6:	2b00      	cmp	r3, #0
    9fc8:	d010      	beq.n	9fec <m_bearer_closed+0x38>
    {
        // Get buffer that has been transmitted
        m_tb_buf_t *p_buf = (m_tb_buf_t *)co_list_pop_front(&p_bearer->tx_queue);
    9fca:	0020      	movs	r0, r4
    9fcc:	f7fa fa0e 	bl	43ec <co_list_pop_front>
        // Get pointer to buffer environment
        m_lay_bearer_buf_env_t *p_env = (m_lay_bearer_buf_env_t *)&p_buf->env[0];

        // Inform client that packet has not been sent
        if (p_m_bearer_env->p_cb[p_env->client])
    9fd0:	7cc3      	ldrb	r3, [r0, #19]
    9fd2:	682a      	ldr	r2, [r5, #0]
    9fd4:	009b      	lsls	r3, r3, #2
    9fd6:	589b      	ldr	r3, [r3, r2]

    // Release the buffers
    while (!co_list_is_empty(&p_bearer->tx_queue))
    {
        // Get buffer that has been transmitted
        m_tb_buf_t *p_buf = (m_tb_buf_t *)co_list_pop_front(&p_bearer->tx_queue);
    9fd8:	0007      	movs	r7, r0
        // Get pointer to buffer environment
        m_lay_bearer_buf_env_t *p_env = (m_lay_bearer_buf_env_t *)&p_buf->env[0];

        // Inform client that packet has not been sent
        if (p_m_bearer_env->p_cb[p_env->client])
    9fda:	2b00      	cmp	r3, #0
    9fdc:	d002      	beq.n	9fe4 <m_bearer_closed+0x30>
        {
            p_m_bearer_env->p_cb[p_env->client]->sent(p_buf, M_ERR_BEARER_CLOSED);
    9fde:	681b      	ldr	r3, [r3, #0]
    9fe0:	490c      	ldr	r1, [pc, #48]	; (a014 <m_bearer_closed+0x60>)
    9fe2:	4798      	blx	r3
        }

        // Release the buffer
        m_tb_buf_release(p_buf);
    9fe4:	0038      	movs	r0, r7
    9fe6:	f007 fb59 	bl	1169c <m_tb_buf_release>
    9fea:	e7eb      	b.n	9fc4 <m_bearer_closed+0x10>
    9fec:	001c      	movs	r4, r3
    }

    // Inform clients that bearer has been closed
    for (cnt = 0; cnt < M_BEARER_CLI_NB; cnt++)
    {
        const m_bearer_cb_t *p_cb = p_m_bearer_env->p_cb[cnt];
    9fee:	682a      	ldr	r2, [r5, #0]
    9ff0:	00a3      	lsls	r3, r4, #2
    9ff2:	589b      	ldr	r3, [r3, r2]

        if (p_cb)
    9ff4:	2b00      	cmp	r3, #0
    9ff6:	d002      	beq.n	9ffe <m_bearer_closed+0x4a>
        {
            p_cb->closed(bearer_lid);
    9ff8:	68db      	ldr	r3, [r3, #12]
    9ffa:	0030      	movs	r0, r6
    9ffc:	4798      	blx	r3
    9ffe:	3401      	adds	r4, #1
        // Release the buffer
        m_tb_buf_release(p_buf);
    }

    // Inform clients that bearer has been closed
    for (cnt = 0; cnt < M_BEARER_CLI_NB; cnt++)
    a000:	2c03      	cmp	r4, #3
    a002:	d1f4      	bne.n	9fee <m_bearer_closed+0x3a>
            p_cb->closed(bearer_lid);
        }
    }

    // Decrease number of opened bearers
    p_m_bearer_env->nb_bearers--;
    a004:	682b      	ldr	r3, [r5, #0]
    a006:	3345      	adds	r3, #69	; 0x45
    a008:	781a      	ldrb	r2, [r3, #0]
    a00a:	3a01      	subs	r2, #1
    a00c:	701a      	strb	r2, [r3, #0]
}
    a00e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    a010:	100128a0 	.word	0x100128a0
    a014:	00000882 	.word	0x00000882

0000a018 <m_bearer_sent>:
void m_bearer_sent(uint8_t bearer_lid, uint16_t status)
{
    // Get bearer information
    m_bearer_t *p_bearer = &p_m_bearer_env->bearers[bearer_lid];
    // Get buffer that has been transmitted
    m_tb_buf_t *p_buf = (m_tb_buf_t *)co_list_pop_front(&p_bearer->tx_queue);
    a018:	2318      	movs	r3, #24
    a01a:	4343      	muls	r3, r0
    // Decrease number of opened bearers
    p_m_bearer_env->nb_bearers--;
}

void m_bearer_sent(uint8_t bearer_lid, uint16_t status)
{
    a01c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    // Get bearer information
    m_bearer_t *p_bearer = &p_m_bearer_env->bearers[bearer_lid];
    a01e:	4f1d      	ldr	r7, [pc, #116]	; (a094 <m_bearer_sent+0x7c>)
    // Get buffer that has been transmitted
    m_tb_buf_t *p_buf = (m_tb_buf_t *)co_list_pop_front(&p_bearer->tx_queue);
    a020:	3310      	adds	r3, #16
}

void m_bearer_sent(uint8_t bearer_lid, uint16_t status)
{
    // Get bearer information
    m_bearer_t *p_bearer = &p_m_bearer_env->bearers[bearer_lid];
    a022:	683e      	ldr	r6, [r7, #0]
    // Decrease number of opened bearers
    p_m_bearer_env->nb_bearers--;
}

void m_bearer_sent(uint8_t bearer_lid, uint16_t status)
{
    a024:	0004      	movs	r4, r0
    // Get bearer information
    m_bearer_t *p_bearer = &p_m_bearer_env->bearers[bearer_lid];
    // Get buffer that has been transmitted
    m_tb_buf_t *p_buf = (m_tb_buf_t *)co_list_pop_front(&p_bearer->tx_queue);
    a026:	18f3      	adds	r3, r6, r3
    a028:	0018      	movs	r0, r3
    a02a:	3008      	adds	r0, #8
    // Decrease number of opened bearers
    p_m_bearer_env->nb_bearers--;
}

void m_bearer_sent(uint8_t bearer_lid, uint16_t status)
{
    a02c:	9101      	str	r1, [sp, #4]
    // Get bearer information
    m_bearer_t *p_bearer = &p_m_bearer_env->bearers[bearer_lid];
    // Get buffer that has been transmitted
    m_tb_buf_t *p_buf = (m_tb_buf_t *)co_list_pop_front(&p_bearer->tx_queue);
    a02e:	9300      	str	r3, [sp, #0]
    a030:	f7fa f9dc 	bl	43ec <co_list_pop_front>
    a034:	1e05      	subs	r5, r0, #0

    if (p_buf != NULL)
    a036:	d02b      	beq.n	a090 <m_bearer_sent+0x78>
    {
        // Get pointer to buffer environment
        m_lay_bearer_buf_env_t *p_env = (m_lay_bearer_buf_env_t *)&p_buf->env[0];

        if (bearer_lid == M_BEARER_ADV_LID)
    a038:	2c01      	cmp	r4, #1
    a03a:	d102      	bne.n	a042 <m_bearer_sent+0x2a>
        {
            // Release header part
            m_tb_buf_head_release(p_buf, M_BEARER_ADV_HEAD_LEN);
    a03c:	2102      	movs	r1, #2
    a03e:	f007 faff 	bl	11640 <m_tb_buf_head_release>
        }

        // Inform client that packet has been sent
        if (p_m_bearer_env->p_cb[p_env->client])
    a042:	7ceb      	ldrb	r3, [r5, #19]
    a044:	683a      	ldr	r2, [r7, #0]
    a046:	009b      	lsls	r3, r3, #2
    a048:	589b      	ldr	r3, [r3, r2]
    a04a:	2b00      	cmp	r3, #0
    a04c:	d003      	beq.n	a056 <m_bearer_sent+0x3e>
        {
            p_m_bearer_env->p_cb[p_env->client]->sent(p_buf, status);
    a04e:	681b      	ldr	r3, [r3, #0]
    a050:	9901      	ldr	r1, [sp, #4]
    a052:	0028      	movs	r0, r5
    a054:	4798      	blx	r3
        }

        // Release the buffer
        m_tb_buf_release(p_buf);
    a056:	0028      	movs	r0, r5
    a058:	f007 fb20 	bl	1169c <m_tb_buf_release>

        // Check if another buffer can be pushed
        if (!co_list_is_empty(&p_bearer->tx_queue)
    a05c:	9b00      	ldr	r3, [sp, #0]
    a05e:	689b      	ldr	r3, [r3, #8]
    a060:	2b00      	cmp	r3, #0
    a062:	d00d      	beq.n	a080 <m_bearer_sent+0x68>
                && GETB(p_bearer->state, M_BEARER_OPEN))
    a064:	2018      	movs	r0, #24
    a066:	1c63      	adds	r3, r4, #1
    a068:	4343      	muls	r3, r0
    a06a:	18f3      	adds	r3, r6, r3
    a06c:	7a5b      	ldrb	r3, [r3, #9]
    a06e:	07db      	lsls	r3, r3, #31
    a070:	d506      	bpl.n	a080 <m_bearer_sent+0x68>
        {
            m_al_djob_reg(&(p_bearer->djob));
    a072:	4360      	muls	r0, r4
    a074:	1836      	adds	r6, r6, r0
    a076:	0030      	movs	r0, r6
    a078:	300c      	adds	r0, #12
    a07a:	f7fa fe07 	bl	4c8c <m_al_djob_reg>
    a07e:	e007      	b.n	a090 <m_bearer_sent+0x78>
    a080:	2018      	movs	r0, #24
        }
        else
        {
            // Keep in mind that bearer is available for transmission
            SETB(p_bearer->state, M_BEARER_TX, 0);
    a082:	2204      	movs	r2, #4
    a084:	4344      	muls	r4, r0
    a086:	1936      	adds	r6, r6, r4
    a088:	3602      	adds	r6, #2
    a08a:	7ff3      	ldrb	r3, [r6, #31]
    a08c:	4393      	bics	r3, r2
    a08e:	77f3      	strb	r3, [r6, #31]
        }
    }
}
    a090:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
    a092:	46c0      	nop			; (mov r8, r8)
    a094:	100128a0 	.word	0x100128a0

0000a098 <m_bearer_rx>:

void m_bearer_rx(m_lid_t bearer_lid, uint8_t msg_type, int8_t rssi, uint8_t len, const uint8_t *p_data)
{
    a098:	b5f0      	push	{r4, r5, r6, r7, lr}
    a09a:	b087      	sub	sp, #28
    a09c:	9001      	str	r0, [sp, #4]
    a09e:	000e      	movs	r6, r1
    a0a0:	9202      	str	r2, [sp, #8]
    a0a2:	2902      	cmp	r1, #2
    a0a4:	d836      	bhi.n	a114 <m_bearer_rx+0x7c>
    a0a6:	4a1c      	ldr	r2, [pc, #112]	; (a118 <m_bearer_rx+0x80>)
    a0a8:	3243      	adds	r2, #67	; 0x43
    a0aa:	5c55      	ldrb	r5, [r2, r1]
            /* Unknown Message, Ignore it */
        } break;
    }

    // Check that client is ready
    if ((client != M_BEARER_CLI_NB) && (p_m_bearer_env->p_cb[client]))
    a0ac:	2d03      	cmp	r5, #3
    a0ae:	d031      	beq.n	a114 <m_bearer_rx+0x7c>
    a0b0:	4f1a      	ldr	r7, [pc, #104]	; (a11c <m_bearer_rx+0x84>)
    a0b2:	00aa      	lsls	r2, r5, #2
    a0b4:	9203      	str	r2, [sp, #12]
    a0b6:	683a      	ldr	r2, [r7, #0]
    a0b8:	00a9      	lsls	r1, r5, #2
    a0ba:	588a      	ldr	r2, [r1, r2]
    a0bc:	2a00      	cmp	r2, #0
    a0be:	d029      	beq.n	a114 <m_bearer_rx+0x7c>
    {
        m_tb_buf_t *p_buf;

        // Allocate buffer
        if (m_tb_buf_alloc(&p_buf, 0, len, 0) == M_ERR_NO_ERROR)
    a0c0:	b29b      	uxth	r3, r3
    a0c2:	9300      	str	r3, [sp, #0]
    a0c4:	2300      	movs	r3, #0
    a0c6:	9a00      	ldr	r2, [sp, #0]
    a0c8:	0019      	movs	r1, r3
    a0ca:	a805      	add	r0, sp, #20
    a0cc:	f007 fa34 	bl	11538 <m_tb_buf_alloc>
    a0d0:	2800      	cmp	r0, #0
    a0d2:	d11f      	bne.n	a114 <m_bearer_rx+0x7c>
        {
            // Get pointer environment
            m_lay_bearer_buf_env_t *p_env = (m_lay_bearer_buf_env_t *)&p_buf->env[0];
    a0d4:	9c05      	ldr	r4, [sp, #20]

            // Copy the received data
            m_tb_buf_copy_data_from_mem(p_buf, p_data, len);
    a0d6:	9a00      	ldr	r2, [sp, #0]
    a0d8:	990c      	ldr	r1, [sp, #48]	; 0x30
    a0da:	0020      	movs	r0, r4
    a0dc:	f007 fb40 	bl	11760 <m_tb_buf_copy_data_from_mem>

            // Set buffer environment
            p_env->flags = 1;
            p_env->rssi = rssi;
    a0e0:	466a      	mov	r2, sp

            // Copy the received data
            m_tb_buf_copy_data_from_mem(p_buf, p_data, len);

            // Set buffer environment
            p_env->flags = 1;
    a0e2:	2301      	movs	r3, #1
            p_env->rssi = rssi;
    a0e4:	7a12      	ldrb	r2, [r2, #8]

            // Copy the received data
            m_tb_buf_copy_data_from_mem(p_buf, p_data, len);

            // Set buffer environment
            p_env->flags = 1;
    a0e6:	7423      	strb	r3, [r4, #16]
            p_env->rssi = rssi;
    a0e8:	18e3      	adds	r3, r4, r3
    a0ea:	77da      	strb	r2, [r3, #31]
            p_env->bearer_lid = bearer_lid;
    a0ec:	466b      	mov	r3, sp
    a0ee:	791b      	ldrb	r3, [r3, #4]
            p_env->msg_type = msg_type;
            p_env->client = client;

            ASSERT_INFO(p_m_bearer_env->p_cb[client] != NULL, bearer_lid, client);
    a0f0:	9a03      	ldr	r2, [sp, #12]
            m_tb_buf_copy_data_from_mem(p_buf, p_data, len);

            // Set buffer environment
            p_env->flags = 1;
            p_env->rssi = rssi;
            p_env->bearer_lid = bearer_lid;
    a0f2:	7463      	strb	r3, [r4, #17]
            p_env->msg_type = msg_type;
            p_env->client = client;

            ASSERT_INFO(p_m_bearer_env->p_cb[client] != NULL, bearer_lid, client);
    a0f4:	683b      	ldr	r3, [r7, #0]

            // Set buffer environment
            p_env->flags = 1;
            p_env->rssi = rssi;
            p_env->bearer_lid = bearer_lid;
            p_env->msg_type = msg_type;
    a0f6:	74a6      	strb	r6, [r4, #18]
            p_env->client = client;
    a0f8:	74e5      	strb	r5, [r4, #19]

            ASSERT_INFO(p_m_bearer_env->p_cb[client] != NULL, bearer_lid, client);
    a0fa:	58d3      	ldr	r3, [r2, r3]
    a0fc:	2b00      	cmp	r3, #0
    a0fe:	d100      	bne.n	a102 <m_bearer_rx+0x6a>
    a100:	e7fe      	b.n	a100 <m_bearer_rx+0x68>
            ASSERT_INFO(p_m_bearer_env->p_cb[client]->rx != NULL, bearer_lid, client);
    a102:	685b      	ldr	r3, [r3, #4]
    a104:	2b00      	cmp	r3, #0
    a106:	d100      	bne.n	a10a <m_bearer_rx+0x72>
    a108:	e7fe      	b.n	a108 <m_bearer_rx+0x70>

            // Inform client that packet has been received
            p_m_bearer_env->p_cb[client]->rx(p_buf);
    a10a:	9805      	ldr	r0, [sp, #20]
    a10c:	4798      	blx	r3

            // Release the allocated buffer
            m_tb_buf_release(p_buf);
    a10e:	9805      	ldr	r0, [sp, #20]
    a110:	f007 fac4 	bl	1169c <m_tb_buf_release>
        }
    }
}
    a114:	b007      	add	sp, #28
    a116:	bdf0      	pop	{r4, r5, r6, r7, pc}
    a118:	000214a0 	.word	0x000214a0
    a11c:	100128a0 	.word	0x100128a0

0000a120 <m_bearer_adv_sent>:
 *
 * @param[in] bearer_lid        Bearer local index
 ****************************************************************************************
 */
__STATIC void m_bearer_adv_sent(uint8_t bearer_lid, uint16_t status)
{
    a120:	b510      	push	{r4, lr}
    ASSERT_INFO(bearer_lid == M_BEARER_ADV_LID, bearer_lid, status);
    a122:	2801      	cmp	r0, #1
    a124:	d1fd      	bne.n	a122 <m_bearer_adv_sent+0x2>

    if (bearer_lid == M_BEARER_ADV_LID)
    {
        m_bearer_sent(M_BEARER_ADV_LID, status);
    a126:	f7ff ff77 	bl	a018 <m_bearer_sent>
    }
}
    a12a:	bd10      	pop	{r4, pc}

0000a12c <m_bearer_adv_rx>:
 * @param[in] len           Data Length
 * @param[in] p_data        Data payload.
 ****************************************************************************************
 */
__STATIC void m_bearer_adv_rx(m_lid_t bearer_lid, uint16_t status, int8_t rssi, uint8_t len, const uint8_t *p_data)
{
    a12c:	b5f0      	push	{r4, r5, r6, r7, lr}
    a12e:	001d      	movs	r5, r3
	M_PRINTF(L_BEAR, "");
    a130:	4b24      	ldr	r3, [pc, #144]	; (a1c4 <m_bearer_adv_rx+0x98>)
 * @param[in] len           Data Length
 * @param[in] p_data        Data payload.
 ****************************************************************************************
 */
__STATIC void m_bearer_adv_rx(m_lid_t bearer_lid, uint16_t status, int8_t rssi, uint8_t len, const uint8_t *p_data)
{
    a132:	b085      	sub	sp, #20
	M_PRINTF(L_BEAR, "");
    a134:	681b      	ldr	r3, [r3, #0]
 * @param[in] len           Data Length
 * @param[in] p_data        Data payload.
 ****************************************************************************************
 */
__STATIC void m_bearer_adv_rx(m_lid_t bearer_lid, uint16_t status, int8_t rssi, uint8_t len, const uint8_t *p_data)
{
    a136:	0007      	movs	r7, r0
    a138:	000e      	movs	r6, r1
    a13a:	9203      	str	r2, [sp, #12]
	M_PRINTF(L_BEAR, "");
    a13c:	075b      	lsls	r3, r3, #29
    a13e:	d514      	bpl.n	a16a <m_bearer_adv_rx+0x3e>
    a140:	4c21      	ldr	r4, [pc, #132]	; (a1c8 <m_bearer_adv_rx+0x9c>)
    a142:	0023      	movs	r3, r4
    a144:	0022      	movs	r2, r4
    a146:	0020      	movs	r0, r4
    a148:	3355      	adds	r3, #85	; 0x55
    a14a:	0021      	movs	r1, r4
    a14c:	3237      	adds	r2, #55	; 0x37
    a14e:	9300      	str	r3, [sp, #0]
    a150:	3046      	adds	r0, #70	; 0x46
    a152:	2353      	movs	r3, #83	; 0x53
    a154:	f7fa fc2a 	bl	49ac <m_print>
    a158:	0020      	movs	r0, r4
    a15a:	3065      	adds	r0, #101	; 0x65
    a15c:	f7fa fc26 	bl	49ac <m_print>
    a160:	0020      	movs	r0, r4
    a162:	1da1      	adds	r1, r4, #6
    a164:	3066      	adds	r0, #102	; 0x66
    a166:	f7fa fc21 	bl	49ac <m_print>
    ASSERT_INFO(bearer_lid == M_BEARER_ADV_LID, bearer_lid, status);
    a16a:	2f01      	cmp	r7, #1
    a16c:	d1fd      	bne.n	a16a <m_bearer_adv_rx+0x3e>
    {
        // Get bearer information
        m_bearer_t *p_bearer = &p_m_bearer_env->bearers[M_BEARER_ADV_LID];
        uint8_t     msg_type;

        if ((status != M_ERR_NO_ERROR) || (bearer_lid != M_BEARER_ADV_LID)) { break; }
    a16e:	2e00      	cmp	r6, #0
    a170:	d126      	bne.n	a1c0 <m_bearer_adv_rx+0x94>

        // Check that bearer is well opened
        if (   !GETB(p_bearer->state, M_BEARER_OPEN)
    a172:	4b16      	ldr	r3, [pc, #88]	; (a1cc <m_bearer_adv_rx+0xa0>)
    a174:	681b      	ldr	r3, [r3, #0]
    a176:	3339      	adds	r3, #57	; 0x39
    a178:	781a      	ldrb	r2, [r3, #0]
    a17a:	2303      	movs	r3, #3
    a17c:	4013      	ands	r3, r2
    a17e:	2b01      	cmp	r3, #1
    a180:	d11e      	bne.n	a1c0 <m_bearer_adv_rx+0x94>
            || GETB(p_bearer->state, M_BEARER_PAUSE)
            || GETB(p_bearer->state, M_BEARER_RX_PAUSE))
    a182:	06d3      	lsls	r3, r2, #27
    a184:	d41c      	bmi.n	a1c0 <m_bearer_adv_rx+0x94>
        {
            break;
        }

        // Check advertising data length
        if ((len != (p_data[M_BEARER_ADV_HEAD_LEN_POS] + 1)) || (len < M_BEARER_MIN_ADV_LEN)) { break; }
    a186:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    a188:	781b      	ldrb	r3, [r3, #0]
    a18a:	3301      	adds	r3, #1
    a18c:	429d      	cmp	r5, r3
    a18e:	d117      	bne.n	a1c0 <m_bearer_adv_rx+0x94>
    a190:	2d02      	cmp	r5, #2
    a192:	d915      	bls.n	a1c0 <m_bearer_adv_rx+0x94>

        // retrieve client from advertising type
        switch (p_data[M_BEARER_ADV_HEAD_TYPE_POS])
    a194:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    a196:	785b      	ldrb	r3, [r3, #1]
    a198:	2b2a      	cmp	r3, #42	; 0x2a
    a19a:	d005      	beq.n	a1a8 <m_bearer_adv_rx+0x7c>
    a19c:	2b2b      	cmp	r3, #43	; 0x2b
    a19e:	d005      	beq.n	a1ac <m_bearer_adv_rx+0x80>
        {
            case M_BEARER_ADV_TYPE_MSG:    { msg_type = M_BEARER_MSG_NET;    } break;
            case M_BEARER_ADV_TYPE_PB_ADV: { msg_type = M_BEARER_MSG_PROV;   } break;
    a1a0:	0039      	movs	r1, r7

        // Check advertising data length
        if ((len != (p_data[M_BEARER_ADV_HEAD_LEN_POS] + 1)) || (len < M_BEARER_MIN_ADV_LEN)) { break; }

        // retrieve client from advertising type
        switch (p_data[M_BEARER_ADV_HEAD_TYPE_POS])
    a1a2:	2b29      	cmp	r3, #41	; 0x29
    a1a4:	d10c      	bne.n	a1c0 <m_bearer_adv_rx+0x94>
    a1a6:	e002      	b.n	a1ae <m_bearer_adv_rx+0x82>
        {
            case M_BEARER_ADV_TYPE_MSG:    { msg_type = M_BEARER_MSG_NET;    } break;
    a1a8:	0031      	movs	r1, r6
    a1aa:	e000      	b.n	a1ae <m_bearer_adv_rx+0x82>
            case M_BEARER_ADV_TYPE_PB_ADV: { msg_type = M_BEARER_MSG_PROV;   } break;
            case M_BEARER_ADV_TYPE_BEACON: { msg_type = M_BEARER_MSG_BEACON; } break;
    a1ac:	2102      	movs	r1, #2
        // update data cursor
        len    -= M_BEARER_ADV_HEAD_LEN;
        p_data += M_BEARER_ADV_HEAD_LEN;

        // inform that buffer has been properly received
        m_bearer_rx(bearer_lid, msg_type, rssi, len, p_data);
    a1ae:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    a1b0:	3d02      	subs	r5, #2
    a1b2:	1c96      	adds	r6, r2, #2
    a1b4:	b2eb      	uxtb	r3, r5
    a1b6:	9600      	str	r6, [sp, #0]
    a1b8:	9a03      	ldr	r2, [sp, #12]
    a1ba:	2001      	movs	r0, #1
    a1bc:	f7ff ff6c 	bl	a098 <m_bearer_rx>
    } while(0);
}
    a1c0:	b005      	add	sp, #20
    a1c2:	bdf0      	pop	{r4, r5, r6, r7, pc}
    a1c4:	10010514 	.word	0x10010514
    a1c8:	000214f0 	.word	0x000214f0
    a1cc:	100128a0 	.word	0x100128a0

0000a1d0 <m_bearer_adv_started>:
 * @param[in] bearer_lid      Local index of bearer instance to be closed.
 ****************************************************************************************
 */
__STATIC void m_bearer_adv_started(m_lid_t bearer_lid, uint16_t status)
{
	M_PRINTF(L_BEAR, "");
    a1d0:	4b1c      	ldr	r3, [pc, #112]	; (a244 <m_bearer_adv_started+0x74>)
 *
 * @param[in] bearer_lid      Local index of bearer instance to be closed.
 ****************************************************************************************
 */
__STATIC void m_bearer_adv_started(m_lid_t bearer_lid, uint16_t status)
{
    a1d2:	b573      	push	{r0, r1, r4, r5, r6, lr}
	M_PRINTF(L_BEAR, "");
    a1d4:	681b      	ldr	r3, [r3, #0]
 *
 * @param[in] bearer_lid      Local index of bearer instance to be closed.
 ****************************************************************************************
 */
__STATIC void m_bearer_adv_started(m_lid_t bearer_lid, uint16_t status)
{
    a1d6:	0005      	movs	r5, r0
    a1d8:	000c      	movs	r4, r1
	M_PRINTF(L_BEAR, "");
    a1da:	075b      	lsls	r3, r3, #29
    a1dc:	d514      	bpl.n	a208 <m_bearer_adv_started+0x38>
    a1de:	4e1a      	ldr	r6, [pc, #104]	; (a248 <m_bearer_adv_started+0x78>)
    a1e0:	0033      	movs	r3, r6
    a1e2:	0032      	movs	r2, r6
    a1e4:	0030      	movs	r0, r6
    a1e6:	3369      	adds	r3, #105	; 0x69
    a1e8:	0031      	movs	r1, r6
    a1ea:	3237      	adds	r2, #55	; 0x37
    a1ec:	9300      	str	r3, [sp, #0]
    a1ee:	3046      	adds	r0, #70	; 0x46
    a1f0:	2387      	movs	r3, #135	; 0x87
    a1f2:	f7fa fbdb 	bl	49ac <m_print>
    a1f6:	0030      	movs	r0, r6
    a1f8:	3065      	adds	r0, #101	; 0x65
    a1fa:	f7fa fbd7 	bl	49ac <m_print>
    a1fe:	0030      	movs	r0, r6
    a200:	1db1      	adds	r1, r6, #6
    a202:	3066      	adds	r0, #102	; 0x66
    a204:	f7fa fbd2 	bl	49ac <m_print>
    // Get bearer information
    m_bearer_t *p_bearer = &p_m_bearer_env->bearers[M_BEARER_ADV_LID];

    ASSERT_INFO(bearer_lid == M_BEARER_ADV_LID, bearer_lid, status);
    a208:	2d01      	cmp	r5, #1
    a20a:	d1fd      	bne.n	a208 <m_bearer_adv_started+0x38>
    if(bearer_lid == M_BEARER_ADV_LID)
    {

        // Bearer update on-going
        if(GETB(p_bearer->state, M_BEARER_UPDATE))
    a20c:	2108      	movs	r1, #8
 */
__STATIC void m_bearer_adv_started(m_lid_t bearer_lid, uint16_t status)
{
	M_PRINTF(L_BEAR, "");
    // Get bearer information
    m_bearer_t *p_bearer = &p_m_bearer_env->bearers[M_BEARER_ADV_LID];
    a20e:	4b0f      	ldr	r3, [pc, #60]	; (a24c <m_bearer_adv_started+0x7c>)
    a210:	681a      	ldr	r2, [r3, #0]
    ASSERT_INFO(bearer_lid == M_BEARER_ADV_LID, bearer_lid, status);
    if(bearer_lid == M_BEARER_ADV_LID)
    {

        // Bearer update on-going
        if(GETB(p_bearer->state, M_BEARER_UPDATE))
    a212:	3239      	adds	r2, #57	; 0x39
    a214:	7813      	ldrb	r3, [r2, #0]
    a216:	420b      	tst	r3, r1
    a218:	d002      	beq.n	a220 <m_bearer_adv_started+0x50>
        {
            SETB(p_bearer->state, M_BEARER_UPDATE, false);
    a21a:	438b      	bics	r3, r1
    a21c:	7013      	strb	r3, [r2, #0]
    a21e:	e00f      	b.n	a240 <m_bearer_adv_started+0x70>
        }
        else
        {
            if (status == M_ERR_NO_ERROR)
    a220:	2c00      	cmp	r4, #0
    a222:	d107      	bne.n	a234 <m_bearer_adv_started+0x64>
            {
                // Unpause the bearer
                SETB(p_bearer->state, M_BEARER_PAUSE, false);
    a224:	2102      	movs	r1, #2
    a226:	438b      	bics	r3, r1
    a228:	7013      	strb	r3, [r2, #0]
                // mark bearer opened
                m_bearer_opened(bearer_lid, M_BEARER_TYPE_ADV);
    a22a:	0021      	movs	r1, r4
    a22c:	0028      	movs	r0, r5
    a22e:	f7ff fea7 	bl	9f80 <m_bearer_opened>
    a232:	e001      	b.n	a238 <m_bearer_adv_started+0x68>
            }
            else
            {
                // Bearer cannot be opened
                SETB(p_bearer->state, M_BEARER_OPEN, false);
    a234:	43ab      	bics	r3, r5
    a236:	7013      	strb	r3, [r2, #0]
            }

            // Mark Advertising started
            m_bearer_started(M_BEARER_TYPE_ADV, status);
    a238:	b2e1      	uxtb	r1, r4
    a23a:	2000      	movs	r0, #0
    a23c:	f7ff fe60 	bl	9f00 <m_bearer_started>
        }
    }
}
    a240:	bd73      	pop	{r0, r1, r4, r5, r6, pc}
    a242:	46c0      	nop			; (mov r8, r8)
    a244:	10010514 	.word	0x10010514
    a248:	000214f0 	.word	0x000214f0
    a24c:	100128a0 	.word	0x100128a0

0000a250 <m_bearer_adv_stopped>:
 *
 * @param[in] bearer_lid      Local index of bearer instance to be closed.
 ****************************************************************************************
 */
__STATIC void m_bearer_adv_stopped(m_lid_t bearer_lid, uint16_t status)
{
    a250:	b510      	push	{r4, lr}
    // Get bearer information
    m_bearer_t *p_bearer = &p_m_bearer_env->bearers[M_BEARER_ADV_LID];

    ASSERT_INFO(bearer_lid == M_BEARER_ADV_LID, bearer_lid, status);
    a252:	2801      	cmp	r0, #1
    a254:	d1fd      	bne.n	a252 <m_bearer_adv_stopped+0x2>
 ****************************************************************************************
 */
__STATIC void m_bearer_adv_stopped(m_lid_t bearer_lid, uint16_t status)
{
    // Get bearer information
    m_bearer_t *p_bearer = &p_m_bearer_env->bearers[M_BEARER_ADV_LID];
    a256:	4b0a      	ldr	r3, [pc, #40]	; (a280 <m_bearer_adv_stopped+0x30>)

    // right bearer is targeted
    if(bearer_lid == M_BEARER_ADV_LID)
    {
        // Bearer update on-going
        if(GETB(p_bearer->state, M_BEARER_UPDATE))
    a258:	2108      	movs	r1, #8
 ****************************************************************************************
 */
__STATIC void m_bearer_adv_stopped(m_lid_t bearer_lid, uint16_t status)
{
    // Get bearer information
    m_bearer_t *p_bearer = &p_m_bearer_env->bearers[M_BEARER_ADV_LID];
    a25a:	681a      	ldr	r2, [r3, #0]

    // right bearer is targeted
    if(bearer_lid == M_BEARER_ADV_LID)
    {
        // Bearer update on-going
        if(GETB(p_bearer->state, M_BEARER_UPDATE))
    a25c:	3239      	adds	r2, #57	; 0x39
    a25e:	7813      	ldrb	r3, [r2, #0]
    a260:	001c      	movs	r4, r3
    a262:	400c      	ands	r4, r1
    a264:	d002      	beq.n	a26c <m_bearer_adv_stopped+0x1c>
        {
            SETB(p_bearer->state, M_BEARER_UPDATE, 0);
    a266:	438b      	bics	r3, r1
    a268:	7013      	strb	r3, [r2, #0]
    a26a:	e008      	b.n	a27e <m_bearer_adv_stopped+0x2e>
        }
        else
        {
            // Close the interface
            SETB(p_bearer->state, M_BEARER_OPEN, 0);
    a26c:	4383      	bics	r3, r0

            // Inform that bearer is closed
            m_bearer_closed(bearer_lid, M_ERR_NO_ERROR);
    a26e:	0021      	movs	r1, r4
            SETB(p_bearer->state, M_BEARER_UPDATE, 0);
        }
        else
        {
            // Close the interface
            SETB(p_bearer->state, M_BEARER_OPEN, 0);
    a270:	7013      	strb	r3, [r2, #0]

            // Inform that bearer is closed
            m_bearer_closed(bearer_lid, M_ERR_NO_ERROR);
    a272:	f7ff fe9f 	bl	9fb4 <m_bearer_closed>

            // Mark Advertising stopped
            m_bearer_stopped(M_BEARER_TYPE_ADV, M_ERR_NO_ERROR);
    a276:	0021      	movs	r1, r4
    a278:	0020      	movs	r0, r4
    a27a:	f7ff fe73 	bl	9f64 <m_bearer_stopped>
        }
    }
}
    a27e:	bd10      	pop	{r4, pc}
    a280:	100128a0 	.word	0x100128a0

0000a284 <m_bearer_adv_stop>:
 * GLOBAL FUNCTIONS
 ****************************************************************************************
 */

uint16_t m_bearer_adv_stop(void)
{
    a284:	b510      	push	{r4, lr}
    // use update API
    return (m_bearer_adv_update(M_BEARER_ACT_CLOSE));
    a286:	2000      	movs	r0, #0
    a288:	f000 f8ac 	bl	a3e4 <m_bearer_adv_update>
}
    a28c:	bd10      	pop	{r4, pc}

0000a28e <m_bearer_adv_start>:


uint16_t m_bearer_adv_start(void)
{
    a28e:	b570      	push	{r4, r5, r6, lr}
    // Returned status
    uint16_t status = M_ERR_COMMAND_DISALLOWED;
    m_bearer_t *p_bearer = &p_m_bearer_env->bearers[M_BEARER_ADV_LID];
    a290:	4e0e      	ldr	r6, [pc, #56]	; (a2cc <m_bearer_adv_start+0x3e>)

    // Check if bearer is open
    if (!GETB(p_bearer->state, M_BEARER_OPEN))
    a292:	2501      	movs	r5, #1

uint16_t m_bearer_adv_start(void)
{
    // Returned status
    uint16_t status = M_ERR_COMMAND_DISALLOWED;
    m_bearer_t *p_bearer = &p_m_bearer_env->bearers[M_BEARER_ADV_LID];
    a294:	6830      	ldr	r0, [r6, #0]

    // Check if bearer is open
    if (!GETB(p_bearer->state, M_BEARER_OPEN))
    a296:	0004      	movs	r4, r0
    a298:	3439      	adds	r4, #57	; 0x39
    a29a:	7823      	ldrb	r3, [r4, #0]
    a29c:	402b      	ands	r3, r5
    a29e:	d113      	bne.n	a2c8 <m_bearer_adv_start+0x3a>
    {
        // Open the bearer
        p_bearer->type   = M_BEARER_TYPE_ADV;
    a2a0:	0002      	movs	r2, r0
    a2a2:	3238      	adds	r2, #56	; 0x38
    a2a4:	7013      	strb	r3, [r2, #0]
        p_bearer->state = 0;
        co_list_init(&p_bearer->tx_queue);
    a2a6:	3030      	adds	r0, #48	; 0x30
    // Check if bearer is open
    if (!GETB(p_bearer->state, M_BEARER_OPEN))
    {
        // Open the bearer
        p_bearer->type   = M_BEARER_TYPE_ADV;
        p_bearer->state = 0;
    a2a8:	7023      	strb	r3, [r4, #0]
        co_list_init(&p_bearer->tx_queue);
    a2aa:	f7fa f839 	bl	4320 <co_list_init>
#ifndef PROC_BLOCK
		SETB(p_bearer->state, M_BEARER_OPEN,  true);
        SETB(p_bearer->state, M_BEARER_PAUSE, true);
    a2ae:	2203      	movs	r2, #3
    a2b0:	7823      	ldrb	r3, [r4, #0]
#endif
        status = p_m_bearer_env->adv.p_api->scan_start(M_BEARER_ADV_LID, M_ADV_SCAN_INTERVAL, &m_bearer_adv_cb);
    a2b2:	2110      	movs	r1, #16
        p_bearer->type   = M_BEARER_TYPE_ADV;
        p_bearer->state = 0;
        co_list_init(&p_bearer->tx_queue);
#ifndef PROC_BLOCK
		SETB(p_bearer->state, M_BEARER_OPEN,  true);
        SETB(p_bearer->state, M_BEARER_PAUSE, true);
    a2b4:	4313      	orrs	r3, r2
    a2b6:	7023      	strb	r3, [r4, #0]
#endif
        status = p_m_bearer_env->adv.p_api->scan_start(M_BEARER_ADV_LID, M_ADV_SCAN_INTERVAL, &m_bearer_adv_cb);
    a2b8:	6833      	ldr	r3, [r6, #0]
    a2ba:	4a05      	ldr	r2, [pc, #20]	; (a2d0 <m_bearer_adv_start+0x42>)
    a2bc:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    a2be:	320c      	adds	r2, #12
    a2c0:	681b      	ldr	r3, [r3, #0]
    a2c2:	0028      	movs	r0, r5
    a2c4:	4798      	blx	r3
    a2c6:	e000      	b.n	a2ca <m_bearer_adv_start+0x3c>


uint16_t m_bearer_adv_start(void)
{
    // Returned status
    uint16_t status = M_ERR_COMMAND_DISALLOWED;
    a2c8:	4802      	ldr	r0, [pc, #8]	; (a2d4 <m_bearer_adv_start+0x46>)
        }
#endif
    }

    return (status);
}
    a2ca:	bd70      	pop	{r4, r5, r6, pc}
    a2cc:	100128a0 	.word	0x100128a0
    a2d0:	000214f0 	.word	0x000214f0
    a2d4:	00000282 	.word	0x00000282

0000a2d8 <m_bearer_adv_tx_prepare>:

uint16_t m_bearer_adv_tx_prepare(m_tb_buf_t *p_buf)
{
	M_PRINTF(L_BEAR, "");
    a2d8:	4b1c      	ldr	r3, [pc, #112]	; (a34c <m_bearer_adv_tx_prepare+0x74>)

    return (status);
}

uint16_t m_bearer_adv_tx_prepare(m_tb_buf_t *p_buf)
{
    a2da:	b537      	push	{r0, r1, r2, r4, r5, lr}
	M_PRINTF(L_BEAR, "");
    a2dc:	681b      	ldr	r3, [r3, #0]

    return (status);
}

uint16_t m_bearer_adv_tx_prepare(m_tb_buf_t *p_buf)
{
    a2de:	0005      	movs	r5, r0
	M_PRINTF(L_BEAR, "");
    a2e0:	075b      	lsls	r3, r3, #29
    a2e2:	d514      	bpl.n	a30e <m_bearer_adv_tx_prepare+0x36>
    a2e4:	4c1a      	ldr	r4, [pc, #104]	; (a350 <m_bearer_adv_tx_prepare+0x78>)
    a2e6:	0023      	movs	r3, r4
    a2e8:	0022      	movs	r2, r4
    a2ea:	0020      	movs	r0, r4
    a2ec:	337e      	adds	r3, #126	; 0x7e
    a2ee:	0021      	movs	r1, r4
    a2f0:	3237      	adds	r2, #55	; 0x37
    a2f2:	9300      	str	r3, [sp, #0]
    a2f4:	3046      	adds	r0, #70	; 0x46
    a2f6:	23fa      	movs	r3, #250	; 0xfa
    a2f8:	f7fa fb58 	bl	49ac <m_print>
    a2fc:	0020      	movs	r0, r4
    a2fe:	3065      	adds	r0, #101	; 0x65
    a300:	f7fa fb54 	bl	49ac <m_print>
    a304:	0020      	movs	r0, r4
    a306:	1da1      	adds	r1, r4, #6
    a308:	3066      	adds	r0, #102	; 0x66
    a30a:	f7fa fb4f 	bl	49ac <m_print>
        // Get bearer information
        uint8_t *p_data;
        uint8_t adv_type;

        // retrieve advertising type
        switch(p_env->msg_type)
    a30e:	7cab      	ldrb	r3, [r5, #18]
    a310:	2b01      	cmp	r3, #1
    a312:	d006      	beq.n	a322 <m_bearer_adv_tx_prepare+0x4a>
    a314:	2b00      	cmp	r3, #0
    a316:	d006      	beq.n	a326 <m_bearer_adv_tx_prepare+0x4e>
    a318:	2b02      	cmp	r3, #2
    a31a:	d006      	beq.n	a32a <m_bearer_adv_tx_prepare+0x52>
        {
            case M_BEARER_MSG_NET:    { adv_type = M_BEARER_ADV_TYPE_MSG;    } break;
            case M_BEARER_MSG_PROV:   { adv_type = M_BEARER_ADV_TYPE_PB_ADV; } break;
            case M_BEARER_MSG_BEACON: { adv_type = M_BEARER_ADV_TYPE_BEACON; } break;
            default:                  { status   = M_ERR_NOT_SUPPORTED;      } break;
    a31c:	20a8      	movs	r0, #168	; 0xa8
    a31e:	0100      	lsls	r0, r0, #4
    a320:	e012      	b.n	a348 <m_bearer_adv_tx_prepare+0x70>

        // retrieve advertising type
        switch(p_env->msg_type)
        {
            case M_BEARER_MSG_NET:    { adv_type = M_BEARER_ADV_TYPE_MSG;    } break;
            case M_BEARER_MSG_PROV:   { adv_type = M_BEARER_ADV_TYPE_PB_ADV; } break;
    a322:	2429      	movs	r4, #41	; 0x29
    a324:	e002      	b.n	a32c <m_bearer_adv_tx_prepare+0x54>
        uint8_t adv_type;

        // retrieve advertising type
        switch(p_env->msg_type)
        {
            case M_BEARER_MSG_NET:    { adv_type = M_BEARER_ADV_TYPE_MSG;    } break;
    a326:	242a      	movs	r4, #42	; 0x2a
    a328:	e000      	b.n	a32c <m_bearer_adv_tx_prepare+0x54>
            case M_BEARER_MSG_PROV:   { adv_type = M_BEARER_ADV_TYPE_PB_ADV; } break;
            case M_BEARER_MSG_BEACON: { adv_type = M_BEARER_ADV_TYPE_BEACON; } break;
    a32a:	242b      	movs	r4, #43	; 0x2b
            default:                  { status   = M_ERR_NOT_SUPPORTED;      } break;
        }

        if (status != M_ERR_NO_ERROR) {  break; }

        status = m_tb_buf_head_reserve(p_buf, M_BEARER_ADV_HEAD_LEN);
    a32c:	2102      	movs	r1, #2
    a32e:	0028      	movs	r0, r5
    a330:	f007 f978 	bl	11624 <m_tb_buf_head_reserve>

        if (status != M_ERR_NO_ERROR) {  break; }
    a334:	2800      	cmp	r0, #0
    a336:	d107      	bne.n	a348 <m_bearer_adv_tx_prepare+0x70>

        // Pointer to data
        p_data = M_TB_BUF_DATA(p_buf);
    a338:	002a      	movs	r2, r5
    a33a:	88ab      	ldrh	r3, [r5, #4]
    a33c:	3230      	adds	r2, #48	; 0x30
    a33e:	18d3      	adds	r3, r2, r3

        // Prepare PDU for transmission on an advertising bearer.
        p_data[M_BEARER_ADV_HEAD_LEN_POS]  = p_buf->data_len - 1;
    a340:	892a      	ldrh	r2, [r5, #8]
        p_data[M_BEARER_ADV_HEAD_TYPE_POS] = adv_type;
    a342:	705c      	strb	r4, [r3, #1]

        // Pointer to data
        p_data = M_TB_BUF_DATA(p_buf);

        // Prepare PDU for transmission on an advertising bearer.
        p_data[M_BEARER_ADV_HEAD_LEN_POS]  = p_buf->data_len - 1;
    a344:	3a01      	subs	r2, #1
    a346:	701a      	strb	r2, [r3, #0]
        p_data[M_BEARER_ADV_HEAD_TYPE_POS] = adv_type;
    } while (0);

    return (status);
}
    a348:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
    a34a:	46c0      	nop			; (mov r8, r8)
    a34c:	10010514 	.word	0x10010514
    a350:	000214f0 	.word	0x000214f0

0000a354 <m_bearer_adv_send>:

uint16_t m_bearer_adv_send(m_tb_buf_t *p_buf)
{
    a354:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
    a356:	250e      	movs	r5, #14
    a358:	260d      	movs	r6, #13
    uint8_t nb_tx;
    // Get buffer environment
    m_lay_bearer_buf_env_t *p_env = (m_lay_bearer_buf_env_t *)&p_buf->env[0];

    // Retrieve number of transmission and transmission interval in slots
    if (p_env->msg_type == M_BEARER_MSG_NET)
    a35a:	7c83      	ldrb	r3, [r0, #18]

    return (status);
}

uint16_t m_bearer_adv_send(m_tb_buf_t *p_buf)
{
    a35c:	0004      	movs	r4, r0
    a35e:	446d      	add	r5, sp
    a360:	446e      	add	r6, sp
    uint8_t nb_tx;
    // Get buffer environment
    m_lay_bearer_buf_env_t *p_env = (m_lay_bearer_buf_env_t *)&p_buf->env[0];

    // Retrieve number of transmission and transmission interval in slots
    if (p_env->msg_type == M_BEARER_MSG_NET)
    a362:	2b00      	cmp	r3, #0
    a364:	d104      	bne.n	a370 <m_bearer_adv_send+0x1c>
    {
        m_tb_state_get_net_tx_params(&nb_tx, &intv_slots);
    a366:	0029      	movs	r1, r5
    a368:	0030      	movs	r0, r6
    a36a:	f00a f869 	bl	14440 <m_tb_state_get_net_tx_params>
    a36e:	e003      	b.n	a378 <m_bearer_adv_send+0x24>
    }
    else
    {
        intv_slots = M_ADV_INTERVAL;
    a370:	2310      	movs	r3, #16
    a372:	802b      	strh	r3, [r5, #0]
        nb_tx      = M_ADV_NB_TX;
    a374:	3b09      	subs	r3, #9
    a376:	7033      	strb	r3, [r6, #0]
    }

    p_data = M_TB_BUF_DATA(p_buf);

    // Send the packet
    status = p_m_bearer_env->adv.p_api->send(M_BEARER_ADV_LID, intv_slots, nb_tx, p_buf->data_len, p_data);
    a378:	7832      	ldrb	r2, [r6, #0]
    {
        intv_slots = M_ADV_INTERVAL;
        nb_tx      = M_ADV_NB_TX;
    }

    p_data = M_TB_BUF_DATA(p_buf);
    a37a:	0026      	movs	r6, r4

    // Send the packet
    status = p_m_bearer_env->adv.p_api->send(M_BEARER_ADV_LID, intv_slots, nb_tx, p_buf->data_len, p_data);
    a37c:	4815      	ldr	r0, [pc, #84]	; (a3d4 <m_bearer_adv_send+0x80>)
    a37e:	8829      	ldrh	r1, [r5, #0]
    a380:	6800      	ldr	r0, [r0, #0]
    {
        intv_slots = M_ADV_INTERVAL;
        nb_tx      = M_ADV_NB_TX;
    }

    p_data = M_TB_BUF_DATA(p_buf);
    a382:	3630      	adds	r6, #48	; 0x30

    // Send the packet
    status = p_m_bearer_env->adv.p_api->send(M_BEARER_ADV_LID, intv_slots, nb_tx, p_buf->data_len, p_data);
    a384:	6c05      	ldr	r5, [r0, #64]	; 0x40
    a386:	88a0      	ldrh	r0, [r4, #4]
    a388:	8923      	ldrh	r3, [r4, #8]
    a38a:	1830      	adds	r0, r6, r0
    a38c:	9000      	str	r0, [sp, #0]
    a38e:	68ac      	ldr	r4, [r5, #8]
    a390:	2001      	movs	r0, #1
    a392:	47a0      	blx	r4
	M_PRINTF(L_BEAR, "status = %d", status);
    a394:	4b10      	ldr	r3, [pc, #64]	; (a3d8 <m_bearer_adv_send+0x84>)
    }

    p_data = M_TB_BUF_DATA(p_buf);

    // Send the packet
    status = p_m_bearer_env->adv.p_api->send(M_BEARER_ADV_LID, intv_slots, nb_tx, p_buf->data_len, p_data);
    a396:	0006      	movs	r6, r0
	M_PRINTF(L_BEAR, "status = %d", status);
    a398:	681b      	ldr	r3, [r3, #0]
    a39a:	075b      	lsls	r3, r3, #29
    a39c:	d517      	bpl.n	a3ce <m_bearer_adv_send+0x7a>
    a39e:	4d0f      	ldr	r5, [pc, #60]	; (a3dc <m_bearer_adv_send+0x88>)
    a3a0:	4c0f      	ldr	r4, [pc, #60]	; (a3e0 <m_bearer_adv_send+0x8c>)
    a3a2:	002b      	movs	r3, r5
    a3a4:	3316      	adds	r3, #22
    a3a6:	9300      	str	r3, [sp, #0]
    a3a8:	0022      	movs	r2, r4
    a3aa:	0020      	movs	r0, r4
    a3ac:	233a      	movs	r3, #58	; 0x3a
    a3ae:	3237      	adds	r2, #55	; 0x37
    a3b0:	33ff      	adds	r3, #255	; 0xff
    a3b2:	0021      	movs	r1, r4
    a3b4:	3046      	adds	r0, #70	; 0x46
    a3b6:	f7fa faf9 	bl	49ac <m_print>
    a3ba:	0028      	movs	r0, r5
    a3bc:	0031      	movs	r1, r6
    a3be:	3028      	adds	r0, #40	; 0x28
    a3c0:	f7fa faf4 	bl	49ac <m_print>
    a3c4:	0020      	movs	r0, r4
    a3c6:	1da1      	adds	r1, r4, #6
    a3c8:	3066      	adds	r0, #102	; 0x66
    a3ca:	f7fa faef 	bl	49ac <m_print>
    return (status);
}
    a3ce:	0030      	movs	r0, r6
    a3d0:	b004      	add	sp, #16
    a3d2:	bd70      	pop	{r4, r5, r6, pc}
    a3d4:	100128a0 	.word	0x100128a0
    a3d8:	10010514 	.word	0x10010514
    a3dc:	00021570 	.word	0x00021570
    a3e0:	000214f0 	.word	0x000214f0

0000a3e4 <m_bearer_adv_update>:
uint16_t m_bearer_adv_update(uint8_t action)
{
    uint16_t status = M_ERR_COMMAND_DISALLOWED;
    // Get bearer information
    m_bearer_t *p_bearer = &p_m_bearer_env->bearers[M_BEARER_ADV_LID];
	M_PRINTF(L_BEAR, "action=%d bear state[%x]", action, p_bearer->state);
    a3e4:	4b2f      	ldr	r3, [pc, #188]	; (a4a4 <m_bearer_adv_update+0xc0>)
	M_PRINTF(L_BEAR, "status = %d", status);
    return (status);
}

uint16_t m_bearer_adv_update(uint8_t action)
{
    a3e6:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    uint16_t status = M_ERR_COMMAND_DISALLOWED;
    // Get bearer information
    m_bearer_t *p_bearer = &p_m_bearer_env->bearers[M_BEARER_ADV_LID];
	M_PRINTF(L_BEAR, "action=%d bear state[%x]", action, p_bearer->state);
    a3e8:	681b      	ldr	r3, [r3, #0]

uint16_t m_bearer_adv_update(uint8_t action)
{
    uint16_t status = M_ERR_COMMAND_DISALLOWED;
    // Get bearer information
    m_bearer_t *p_bearer = &p_m_bearer_env->bearers[M_BEARER_ADV_LID];
    a3ea:	4e2f      	ldr	r6, [pc, #188]	; (a4a8 <m_bearer_adv_update+0xc4>)
	M_PRINTF(L_BEAR, "status = %d", status);
    return (status);
}

uint16_t m_bearer_adv_update(uint8_t action)
{
    a3ec:	0007      	movs	r7, r0
    uint16_t status = M_ERR_COMMAND_DISALLOWED;
    // Get bearer information
    m_bearer_t *p_bearer = &p_m_bearer_env->bearers[M_BEARER_ADV_LID];
    a3ee:	6834      	ldr	r4, [r6, #0]
	M_PRINTF(L_BEAR, "action=%d bear state[%x]", action, p_bearer->state);
    a3f0:	075b      	lsls	r3, r3, #29
    a3f2:	d519      	bpl.n	a428 <m_bearer_adv_update+0x44>
    a3f4:	4b2d      	ldr	r3, [pc, #180]	; (a4ac <m_bearer_adv_update+0xc8>)
    a3f6:	4d2e      	ldr	r5, [pc, #184]	; (a4b0 <m_bearer_adv_update+0xcc>)
    a3f8:	3334      	adds	r3, #52	; 0x34
    a3fa:	9300      	str	r3, [sp, #0]
    a3fc:	002a      	movs	r2, r5
    a3fe:	0028      	movs	r0, r5
    a400:	23a1      	movs	r3, #161	; 0xa1
    a402:	3237      	adds	r2, #55	; 0x37
    a404:	005b      	lsls	r3, r3, #1
    a406:	0029      	movs	r1, r5
    a408:	3046      	adds	r0, #70	; 0x46
    a40a:	f7fa facf 	bl	49ac <m_print>
    a40e:	0023      	movs	r3, r4
    a410:	4826      	ldr	r0, [pc, #152]	; (a4ac <m_bearer_adv_update+0xc8>)
    a412:	3339      	adds	r3, #57	; 0x39
    a414:	0039      	movs	r1, r7
    a416:	781a      	ldrb	r2, [r3, #0]
    a418:	3048      	adds	r0, #72	; 0x48
    a41a:	f7fa fac7 	bl	49ac <m_print>
    a41e:	0028      	movs	r0, r5
    a420:	1da9      	adds	r1, r5, #6
    a422:	3066      	adds	r0, #102	; 0x66
    a424:	f7fa fac2 	bl	49ac <m_print>
    switch(action)
    a428:	2f01      	cmp	r7, #1
    a42a:	d01b      	beq.n	a464 <m_bearer_adv_update+0x80>
    a42c:	2f00      	cmp	r7, #0
    a42e:	d002      	beq.n	a436 <m_bearer_adv_update+0x52>
    a430:	2f02      	cmp	r7, #2
    a432:	d024      	beq.n	a47e <m_bearer_adv_update+0x9a>
    a434:	e034      	b.n	a4a0 <m_bearer_adv_update+0xbc>
    {
        case M_BEARER_ACT_CLOSE:
        {
            // Verify that bearer is opened
            if(GETB(p_bearer->state, M_BEARER_OPEN))
    a436:	2001      	movs	r0, #1
    a438:	3439      	adds	r4, #57	; 0x39
    a43a:	7822      	ldrb	r2, [r4, #0]
    a43c:	4202      	tst	r2, r0
    a43e:	d02f      	beq.n	a4a0 <m_bearer_adv_update+0xbc>
            {
                // Mark Bearer closed
                SETB(p_bearer->state, M_BEARER_OPEN, false);
    a440:	0013      	movs	r3, r2

                if (!GETB(p_bearer->state, M_BEARER_PAUSE))
    a442:	2102      	movs	r1, #2
        {
            // Verify that bearer is opened
            if(GETB(p_bearer->state, M_BEARER_OPEN))
            {
                // Mark Bearer closed
                SETB(p_bearer->state, M_BEARER_OPEN, false);
    a444:	4383      	bics	r3, r0
    a446:	7023      	strb	r3, [r4, #0]

                if (!GETB(p_bearer->state, M_BEARER_PAUSE))
    a448:	420a      	tst	r2, r1
    a44a:	d106      	bne.n	a45a <m_bearer_adv_update+0x76>
                {
                    SETB(p_bearer->state, M_BEARER_PAUSE, true);
    a44c:	430b      	orrs	r3, r1
    a44e:	7023      	strb	r3, [r4, #0]
                    // Stop scan
                    status = p_m_bearer_env->adv.p_api->scan_stop(M_BEARER_ADV_LID);
    a450:	6833      	ldr	r3, [r6, #0]
    a452:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    a454:	685b      	ldr	r3, [r3, #4]
    a456:	4798      	blx	r3
    a458:	e023      	b.n	a4a2 <m_bearer_adv_update+0xbe>
                }
                else
                {
                    // bearer already stopped
                    m_bearer_adv_stopped(M_BEARER_ADV_LID, M_ERR_NO_ERROR);
    a45a:	0039      	movs	r1, r7
    a45c:	f7ff fef8 	bl	a250 <m_bearer_adv_stopped>
    return (status);
}

uint16_t m_bearer_adv_update(uint8_t action)
{
    uint16_t status = M_ERR_COMMAND_DISALLOWED;
    a460:	4814      	ldr	r0, [pc, #80]	; (a4b4 <m_bearer_adv_update+0xd0>)
    a462:	e01e      	b.n	a4a2 <m_bearer_adv_update+0xbe>
            }
        } break;
        case M_BEARER_ACT_PAUSE:
        {
            // Pause the bearer
            if (!GETB(p_bearer->state, M_BEARER_RX_PAUSE))
    a464:	3439      	adds	r4, #57	; 0x39
    a466:	7823      	ldrb	r3, [r4, #0]
    a468:	06da      	lsls	r2, r3, #27
    a46a:	d419      	bmi.n	a4a0 <m_bearer_adv_update+0xbc>
            {
                SETB(p_bearer->state, M_BEARER_RX_PAUSE,  true);
                SETB(p_bearer->state, M_BEARER_UPDATE, true);
    a46c:	2218      	movs	r2, #24
    a46e:	4313      	orrs	r3, r2
    a470:	7023      	strb	r3, [r4, #0]
                // Stop scan
                status = p_m_bearer_env->adv.p_api->scan_stop(M_BEARER_ADV_LID);
    a472:	6833      	ldr	r3, [r6, #0]
    a474:	0038      	movs	r0, r7
    a476:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    a478:	685b      	ldr	r3, [r3, #4]
    a47a:	4798      	blx	r3
    a47c:	e011      	b.n	a4a2 <m_bearer_adv_update+0xbe>
            }
        } break;
        case M_BEARER_ACT_RESUME:
        {
            // Resume the bearer
            if (GETB(p_bearer->state, M_BEARER_RX_PAUSE))
    a47e:	2110      	movs	r1, #16
    a480:	3439      	adds	r4, #57	; 0x39
    a482:	7823      	ldrb	r3, [r4, #0]
    a484:	420b      	tst	r3, r1
    a486:	d00b      	beq.n	a4a0 <m_bearer_adv_update+0xbc>
            {
                SETB(p_bearer->state, M_BEARER_RX_PAUSE, false);
                SETB(p_bearer->state, M_BEARER_UPDATE, true);
    a488:	2208      	movs	r2, #8
    a48a:	438b      	bics	r3, r1
    a48c:	4313      	orrs	r3, r2
    a48e:	7023      	strb	r3, [r4, #0]
                status = p_m_bearer_env->adv.p_api->scan_start(M_BEARER_ADV_LID, M_ADV_SCAN_INTERVAL, &m_bearer_adv_cb);
    a490:	6833      	ldr	r3, [r6, #0]
    a492:	4a07      	ldr	r2, [pc, #28]	; (a4b0 <m_bearer_adv_update+0xcc>)
    a494:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    a496:	320c      	adds	r2, #12
    a498:	681b      	ldr	r3, [r3, #0]
    a49a:	2001      	movs	r0, #1
    a49c:	4798      	blx	r3
    a49e:	e000      	b.n	a4a2 <m_bearer_adv_update+0xbe>
    return (status);
}

uint16_t m_bearer_adv_update(uint8_t action)
{
    uint16_t status = M_ERR_COMMAND_DISALLOWED;
    a4a0:	4804      	ldr	r0, [pc, #16]	; (a4b4 <m_bearer_adv_update+0xd0>)
        default: { /* Nothing to do */ } break;
    }

    return (status);

}
    a4a2:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
    a4a4:	10010514 	.word	0x10010514
    a4a8:	100128a0 	.word	0x100128a0
    a4ac:	00021570 	.word	0x00021570
    a4b0:	000214f0 	.word	0x000214f0
    a4b4:	00000282 	.word	0x00000282

0000a4b8 <m_bearer_adv_connect_api_al>:

void m_bearer_adv_connect_api_al(const m_al_adv_api_t *p_api)
{
    p_m_bearer_env->adv.p_api = p_api;
    a4b8:	4b01      	ldr	r3, [pc, #4]	; (a4c0 <m_bearer_adv_connect_api_al+0x8>)
    a4ba:	681b      	ldr	r3, [r3, #0]
    a4bc:	6418      	str	r0, [r3, #64]	; 0x40
}
    a4be:	4770      	bx	lr
    a4c0:	100128a0 	.word	0x100128a0

0000a4c4 <m_fnd_init>:
 * FUNCTIONS
 ****************************************************************************************
 */

uint16_t m_fnd_init(bool reset, void *p_env, const m_cfg_t* p_cfg)
{
    a4c4:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    a4c6:	000c      	movs	r4, r1
    a4c8:	0006      	movs	r6, r0
    a4ca:	0017      	movs	r7, r2
    // Environment initialization
    uint8_t *p_env_cursor = (uint8_t *)p_env;

    p_env_cursor += CO_ALIGN4_HI(m_fnd_confs_init(reset, (void *)p_env_cursor, p_cfg));
    a4cc:	f001 fb3a 	bl	bb44 <m_fnd_confs_init>
    a4d0:	2503      	movs	r5, #3
    a4d2:	3003      	adds	r0, #3
    a4d4:	43a8      	bics	r0, r5
    a4d6:	1823      	adds	r3, r4, r0
    p_env_cursor += CO_ALIGN4_HI(m_fnd_hlths_init(reset, (void *)p_env_cursor, p_cfg));
    a4d8:	003a      	movs	r2, r7
    a4da:	0019      	movs	r1, r3
    a4dc:	0030      	movs	r0, r6
uint16_t m_fnd_init(bool reset, void *p_env, const m_cfg_t* p_cfg)
{
    // Environment initialization
    uint8_t *p_env_cursor = (uint8_t *)p_env;

    p_env_cursor += CO_ALIGN4_HI(m_fnd_confs_init(reset, (void *)p_env_cursor, p_cfg));
    a4de:	9301      	str	r3, [sp, #4]
    p_env_cursor += CO_ALIGN4_HI(m_fnd_hlths_init(reset, (void *)p_env_cursor, p_cfg));
    a4e0:	f001 fd2a 	bl	bf38 <m_fnd_hlths_init>

    // Return size of the used environment
    return ((uint32_t)p_env_cursor - (uint32_t)p_env);
    a4e4:	9b01      	ldr	r3, [sp, #4]
    a4e6:	1940      	adds	r0, r0, r5
    a4e8:	43a8      	bics	r0, r5
    a4ea:	1818      	adds	r0, r3, r0
    a4ec:	1b00      	subs	r0, r0, r4
    a4ee:	b280      	uxth	r0, r0
}
    a4f0:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}

0000a4f2 <m_fnd_get_env_size>:

uint16_t m_fnd_get_env_size(const m_cfg_t* p_cfg)
{
    a4f2:	b570      	push	{r4, r5, r6, lr}
    a4f4:	0005      	movs	r5, r0
    uint16_t total_env_size = 0;

    // Retrieve size of environments used by the different models
    total_env_size += CO_ALIGN4_HI(m_fnd_confs_get_env_size(p_cfg));
    a4f6:	f001 fb49 	bl	bb8c <m_fnd_confs_get_env_size>
    a4fa:	0004      	movs	r4, r0
    total_env_size += CO_ALIGN4_HI(m_fnd_hlths_get_env_size(p_cfg));
    a4fc:	0028      	movs	r0, r5
    a4fe:	f001 fd39 	bl	bf74 <m_fnd_hlths_get_env_size>

    return (total_env_size);
    a502:	2303      	movs	r3, #3
    a504:	3403      	adds	r4, #3
    a506:	18c0      	adds	r0, r0, r3
    a508:	439c      	bics	r4, r3
    a50a:	4398      	bics	r0, r3
    a50c:	1820      	adds	r0, r4, r0
    a50e:	b280      	uxth	r0, r0
}
    a510:	bd70      	pop	{r4, r5, r6, pc}
	...

0000a514 <co_read32p>:
__INLINE_S__ uint32_t co_read32p(void const *ptr32)
{
    uint16_t addr_l, addr_h;
    addr_l = co_read16p(ptr32);
    addr_h = co_read16p((uint8_t *)ptr32 + 2);
    return ((uint32_t)addr_l | (uint32_t)addr_h << 16);
    a514:	78c2      	ldrb	r2, [r0, #3]
    a516:	7883      	ldrb	r3, [r0, #2]
    a518:	0212      	lsls	r2, r2, #8
    a51a:	431a      	orrs	r2, r3
    a51c:	7843      	ldrb	r3, [r0, #1]
    a51e:	7800      	ldrb	r0, [r0, #0]
    a520:	021b      	lsls	r3, r3, #8
    a522:	0412      	lsls	r2, r2, #16
    a524:	4318      	orrs	r0, r3
    a526:	4310      	orrs	r0, r2
}
    a528:	4770      	bx	lr

0000a52a <m_fnd_confs_get_air_status>:
{
    // Status sent in the air
    uint8_t air_status;

    // Check if status is a Protocol status or not
    if ((status != M_ERR_NO_ERROR) && (M_ERR_GRP(status) != M_ERR_PROTOCOL_CODE))
    a52a:	2800      	cmp	r0, #0
    a52c:	d008      	beq.n	a540 <m_fnd_confs_get_air_status+0x16>
    a52e:	b2c3      	uxtb	r3, r0
    a530:	2b80      	cmp	r3, #128	; 0x80
    a532:	d005      	beq.n	a540 <m_fnd_confs_get_air_status+0x16>
            air_status = M_SUBERR(M_ERR_NO_ERROR);
        }
        else
        {
            // Send an unspecified error status
            air_status = M_SUBERR(M_ERR_UNSPECIFIED_ERROR);
    a534:	4b03      	ldr	r3, [pc, #12]	; (a544 <m_fnd_confs_get_air_status+0x1a>)
    a536:	18c0      	adds	r0, r0, r3
    a538:	1e43      	subs	r3, r0, #1
    a53a:	4198      	sbcs	r0, r3
    a53c:	0100      	lsls	r0, r0, #4
    a53e:	e000      	b.n	a542 <m_fnd_confs_get_air_status+0x18>
        }
    }
    else
    {
        air_status = M_SUBERR(status);
    a540:	0a00      	lsrs	r0, r0, #8
    }

    return (air_status);
}
    a542:	4770      	bx	lr
    a544:	fffff37e 	.word	0xfffff37e

0000a548 <m_fnd_confs_buf_alloc>:
 *
 * @return M_ERR_NO_ERR if buffer has been successfully allocated, else another error code.
 ****************************************************************************************
 */
__STATIC uint16_t m_fnd_confs_buf_alloc(m_tb_buf_t **pp_buf, uint16_t data_len)
{
    a548:	b510      	push	{r4, lr}
    a54a:	000a      	movs	r2, r1
    // Try to allocate a buffer and return the status
    return (m_tb_buf_alloc(pp_buf, M_FND_BUF_HEAD_LEN, data_len, 0));
    a54c:	2300      	movs	r3, #0
    a54e:	2102      	movs	r1, #2
    a550:	f006 fff2 	bl	11538 <m_tb_buf_alloc>
}
    a554:	bd10      	pop	{r4, pc}

0000a556 <m_fnd_confs_send>:
 * @param[in] p_buf     Pointer to the buffer containing the message to send.
 * @param[in] opcode    Operation code
 ****************************************************************************************
 */
__STATIC void m_fnd_confs_send(m_tb_buf_t *p_buf, uint16_t opcode)
{
    a556:	b5f0      	push	{r4, r5, r6, r7, lr}
    a558:	b087      	sub	sp, #28
    a55a:	9005      	str	r0, [sp, #20]
    m_lay_buf_env_t *p_env = (m_lay_buf_env_t *)&p_buf_req->env[0];
    // Use request source address as destination address
    uint16_t dst = p_env->src;

    // Send the provided message
    m_printf(L_FND, "model_lid[%x] net_lid[%x] dst[%x]",
    a55c:	2080      	movs	r0, #128	; 0x80
 ****************************************************************************************
 */
__STATIC void m_fnd_confs_send(m_tb_buf_t *p_buf, uint16_t opcode)
{
    // Retrieve buffer containing the message for which a response is sent
    m_tb_buf_t *p_buf_req = (m_tb_buf_t *)co_list_pick(&p_m_fnd_confs_env->process_queue);
    a55e:	4e0e      	ldr	r6, [pc, #56]	; (a598 <m_fnd_confs_send+0x42>)
 * @param[in] p_buf     Pointer to the buffer containing the message to send.
 * @param[in] opcode    Operation code
 ****************************************************************************************
 */
__STATIC void m_fnd_confs_send(m_tb_buf_t *p_buf, uint16_t opcode)
{
    a560:	000f      	movs	r7, r1
    // Retrieve buffer containing the message for which a response is sent
    m_tb_buf_t *p_buf_req = (m_tb_buf_t *)co_list_pick(&p_m_fnd_confs_env->process_queue);
    a562:	6832      	ldr	r2, [r6, #0]
    m_lay_buf_env_t *p_env = (m_lay_buf_env_t *)&p_buf_req->env[0];
    // Use request source address as destination address
    uint16_t dst = p_env->src;

    // Send the provided message
    m_printf(L_FND, "model_lid[%x] net_lid[%x] dst[%x]",
    a564:	490d      	ldr	r1, [pc, #52]	; (a59c <m_fnd_confs_send+0x46>)
    a566:	6814      	ldr	r4, [r2, #0]
    a568:	3119      	adds	r1, #25
    // Retrieve buffer containing the message for which a response is sent
    m_tb_buf_t *p_buf_req = (m_tb_buf_t *)co_list_pick(&p_m_fnd_confs_env->process_queue);
    // Get buffer environment
    m_lay_buf_env_t *p_env = (m_lay_buf_env_t *)&p_buf_req->env[0];
    // Use request source address as destination address
    uint16_t dst = p_env->src;
    a56a:	8ba5      	ldrh	r5, [r4, #28]

    // Send the provided message
    m_printf(L_FND, "model_lid[%x] net_lid[%x] dst[%x]",
    a56c:	7c63      	ldrb	r3, [r4, #17]
    a56e:	7e52      	ldrb	r2, [r2, #25]
    a570:	0100      	lsls	r0, r0, #4
    a572:	9500      	str	r5, [sp, #0]
    a574:	f7fa fa3c 	bl	49f0 <m_printf>
    				p_m_fnd_confs_env->model_lid,
					p_env->net_lid,
					dst);
    bc_m_model_rsp_send(p_m_fnd_confs_env->model_lid, (uint32_t)opcode, 0,
    a578:	2200      	movs	r2, #0
    a57a:	6833      	ldr	r3, [r6, #0]
    a57c:	7e58      	ldrb	r0, [r3, #25]
    a57e:	2380      	movs	r3, #128	; 0x80
    a580:	9203      	str	r2, [sp, #12]
    a582:	9202      	str	r2, [sp, #8]
    a584:	9501      	str	r5, [sp, #4]
    a586:	7c61      	ldrb	r1, [r4, #17]
    a588:	430b      	orrs	r3, r1
    a58a:	9300      	str	r3, [sp, #0]
    a58c:	0039      	movs	r1, r7
    a58e:	9b05      	ldr	r3, [sp, #20]
    a590:	f7fe fc26 	bl	8de0 <bc_m_model_rsp_send>
                         p_buf, p_env->net_lid | 0x80, dst, false, false);
}
    a594:	b007      	add	sp, #28
    a596:	bdf0      	pop	{r4, r5, r6, r7, pc}
    a598:	100126a0 	.word	0x100126a0
    a59c:	000215dc 	.word	0x000215dc

0000a5a0 <m_fnd_confs_get_ids_length>:
 *
 * @param[in] nb_ids        Number of indexes
 ****************************************************************************************
 */
__STATIC uint8_t m_fnd_confs_get_ids_length(uint8_t nb_ids)
{
    a5a0:	2303      	movs	r3, #3
    uint8_t length;

    if (nb_ids & 0x1)
    a5a2:	07c2      	lsls	r2, r0, #31
    a5a4:	d505      	bpl.n	a5b2 <m_fnd_confs_get_ids_length+0x12>
    {
        length = (((nb_ids - 1) >> 1) * 3) + 2;
    a5a6:	3801      	subs	r0, #1
    a5a8:	1040      	asrs	r0, r0, #1
    a5aa:	4343      	muls	r3, r0
    a5ac:	3302      	adds	r3, #2
    a5ae:	b2d8      	uxtb	r0, r3
    a5b0:	e002      	b.n	a5b8 <m_fnd_confs_get_ids_length+0x18>
    }
    else
    {
        length = (nb_ids >> 1) * 3;
    a5b2:	0840      	lsrs	r0, r0, #1
    a5b4:	4343      	muls	r3, r0
    a5b6:	b2d8      	uxtb	r0, r3
    }

    return (length);
}
    a5b8:	4770      	bx	lr

0000a5ba <m_fnd_confs_send_model_subs_status>:
 * @param[in] addr          Address.
 ****************************************************************************************
 */
__STATIC void m_fnd_confs_send_model_subs_status(uint16_t status, uint16_t element_addr, uint32_t model_id,
                                                 bool vendor, uint16_t addr)
{
    a5ba:	b5f0      	push	{r4, r5, r6, r7, lr}
    a5bc:	b085      	sub	sp, #20
    a5be:	001f      	movs	r7, r3
    a5c0:	ab0a      	add	r3, sp, #40	; 0x28
    a5c2:	881b      	ldrh	r3, [r3, #0]
    a5c4:	000e      	movs	r6, r1
    a5c6:	9001      	str	r0, [sp, #4]
    a5c8:	0015      	movs	r5, r2
    a5ca:	9300      	str	r3, [sp, #0]
    // Pointer to the buffer that will contain the message
    m_tb_buf_t *p_buf_status;
    // Data length
    uint16_t data_length = M_FND_CONFS_MODEL_SUBS_STATUS_LEN;
    a5cc:	2107      	movs	r1, #7

    if (vendor == true)
    a5ce:	2f00      	cmp	r7, #0
    a5d0:	d000      	beq.n	a5d4 <m_fnd_confs_send_model_subs_status+0x1a>
    {
        data_length += M_FND_CONFS_VENDOR_MODEL_ID_ADD_LEN;
    a5d2:	3102      	adds	r1, #2
    }

    if (m_fnd_confs_buf_alloc(&p_buf_status, data_length) == M_ERR_NO_ERROR)
    a5d4:	a803      	add	r0, sp, #12
    a5d6:	f7ff ffb7 	bl	a548 <m_fnd_confs_buf_alloc>
    a5da:	2800      	cmp	r0, #0
    a5dc:	d122      	bne.n	a624 <m_fnd_confs_send_model_subs_status+0x6a>
    {
        // Get pointer to data
        uint8_t *p_data = M_TB_BUF_DATA(p_buf_status);
    a5de:	9b03      	ldr	r3, [sp, #12]

        // Write status
        *p_data = m_fnd_confs_get_air_status(status);
    a5e0:	9801      	ldr	r0, [sp, #4]
    }

    if (m_fnd_confs_buf_alloc(&p_buf_status, data_length) == M_ERR_NO_ERROR)
    {
        // Get pointer to data
        uint8_t *p_data = M_TB_BUF_DATA(p_buf_status);
    a5e2:	001c      	movs	r4, r3
    a5e4:	889b      	ldrh	r3, [r3, #4]
    a5e6:	3430      	adds	r4, #48	; 0x30
    a5e8:	18e4      	adds	r4, r4, r3

        // Write status
        *p_data = m_fnd_confs_get_air_status(status);
    a5ea:	f7ff ff9e 	bl	a52a <m_fnd_confs_get_air_status>
 */
__INLINE_S__ void co_write16p(void const *ptr16, uint16_t value)
{
    uint8_t *ptr=(uint8_t*)ptr16;

    *ptr++ = value&0xff;
    a5ee:	466b      	mov	r3, sp
    a5f0:	781b      	ldrb	r3, [r3, #0]
    a5f2:	7066      	strb	r6, [r4, #1]
    a5f4:	70e3      	strb	r3, [r4, #3]
    *ptr = (value&0xff00)>>8;
    a5f6:	9b00      	ldr	r3, [sp, #0]
    a5f8:	0a36      	lsrs	r6, r6, #8
    a5fa:	0a1b      	lsrs	r3, r3, #8
    a5fc:	7020      	strb	r0, [r4, #0]
    a5fe:	70a6      	strb	r6, [r4, #2]
    a600:	7123      	strb	r3, [r4, #4]
 */
__INLINE_S__ void co_write32p(void const *ptr32, uint32_t value)
{
    uint8_t *ptr=(uint8_t*)ptr32;

    *ptr++ = (uint8_t)(value&0xff);
    a602:	7165      	strb	r5, [r4, #5]
        // Write address
        co_write16p(p_data, addr);
        p_data += 2;

        // Write model identifier
        if (vendor)
    a604:	2f00      	cmp	r7, #0
    a606:	d006      	beq.n	a616 <m_fnd_confs_send_model_subs_status+0x5c>
    *ptr++ = (uint8_t)((value&0xff00)>>8);
    a608:	0a2b      	lsrs	r3, r5, #8
    a60a:	71a3      	strb	r3, [r4, #6]
    *ptr++ = (uint8_t)((value&0xff0000)>>16);
    a60c:	0c2b      	lsrs	r3, r5, #16
    *ptr = (uint8_t)((value&0xff000000)>>24);
    a60e:	0e2d      	lsrs	r5, r5, #24
{
    uint8_t *ptr=(uint8_t*)ptr32;

    *ptr++ = (uint8_t)(value&0xff);
    *ptr++ = (uint8_t)((value&0xff00)>>8);
    *ptr++ = (uint8_t)((value&0xff0000)>>16);
    a610:	71e3      	strb	r3, [r4, #7]
    *ptr = (uint8_t)((value&0xff000000)>>24);
    a612:	7225      	strb	r5, [r4, #8]
    a614:	e001      	b.n	a61a <m_fnd_confs_send_model_subs_status+0x60>
__INLINE_S__ void co_write16p(void const *ptr16, uint16_t value)
{
    uint8_t *ptr=(uint8_t*)ptr16;

    *ptr++ = value&0xff;
    *ptr = (value&0xff00)>>8;
    a616:	0a2d      	lsrs	r5, r5, #8
    a618:	71a5      	strb	r5, [r4, #6]
        {
            co_write16p(p_data, (uint16_t)model_id);
        };

        // Send the message
        m_fnd_confs_send(p_buf_status, M_FND_CONFS_2B_OPCODE(M_FND_CONFS_OPCODE_MODEL_SUBS_STATUS));
    a61a:	21fc      	movs	r1, #252	; 0xfc
    a61c:	9803      	ldr	r0, [sp, #12]
    a61e:	0149      	lsls	r1, r1, #5
    a620:	f7ff ff99 	bl	a556 <m_fnd_confs_send>
    }

    // End procedure and process next message
    m_fnd_confs_process_next();
    a624:	f001 f9ba 	bl	b99c <m_fnd_confs_process_next>
}
    a628:	b005      	add	sp, #20
    a62a:	bdf0      	pop	{r4, r5, r6, r7, pc}

0000a62c <m_fnd_confs_send_model_pub_status>:
 * @param[in] model_lid     Model local index.
 ****************************************************************************************
 */
__STATIC void m_fnd_confs_send_model_pub_status(uint16_t status, uint16_t element_addr, uint32_t model_id,
                                                bool vendor, m_lid_t model_lid)
{
    a62c:	b5f0      	push	{r4, r5, r6, r7, lr}
    a62e:	b08d      	sub	sp, #52	; 0x34
    a630:	9306      	str	r3, [sp, #24]
    a632:	ab12      	add	r3, sp, #72	; 0x48
    a634:	781b      	ldrb	r3, [r3, #0]
    a636:	9105      	str	r1, [sp, #20]
    a638:	9307      	str	r3, [sp, #28]
    // Pointer to the buffer that will contain the message
    m_tb_buf_t *p_buf_status;
    // Data length
    uint16_t data_length = M_FND_CONFS_MODEL_PUB_STATUS_LEN;

    if (vendor == true)
    a63a:	9b06      	ldr	r3, [sp, #24]
 * @param[in] model_lid     Model local index.
 ****************************************************************************************
 */
__STATIC void m_fnd_confs_send_model_pub_status(uint16_t status, uint16_t element_addr, uint32_t model_id,
                                                bool vendor, m_lid_t model_lid)
{
    a63c:	9004      	str	r0, [sp, #16]
    a63e:	0015      	movs	r5, r2
    // Pointer to the buffer that will contain the message
    m_tb_buf_t *p_buf_status;
    // Data length
    uint16_t data_length = M_FND_CONFS_MODEL_PUB_STATUS_LEN;
    a640:	210c      	movs	r1, #12

    if (vendor == true)
    a642:	2b00      	cmp	r3, #0
    a644:	d000      	beq.n	a648 <m_fnd_confs_send_model_pub_status+0x1c>
    {
        data_length += M_FND_CONFS_VENDOR_MODEL_ID_ADD_LEN;
    a646:	3102      	adds	r1, #2
    }

    if (m_fnd_confs_buf_alloc(&p_buf_status, data_length) == M_ERR_NO_ERROR)
    a648:	a80a      	add	r0, sp, #40	; 0x28
    a64a:	f7ff ff7d 	bl	a548 <m_fnd_confs_buf_alloc>
    a64e:	2800      	cmp	r0, #0
    a650:	d169      	bne.n	a726 <m_fnd_confs_send_model_pub_status+0xfa>
    {
        // Get pointer to data
        uint8_t *p_data = M_TB_BUF_DATA(p_buf_status);
    a652:	9b0a      	ldr	r3, [sp, #40]	; 0x28
        // Application key local identifier
        m_lid_t app_key_lid = M_INVALID_LID;
        // Virtual address local index
        m_lid_t va_lid = 0;
        // Publish address
        uint16_t publish_addr = M_UNASSIGNED_ADDR;
    a654:	2716      	movs	r7, #22
    }

    if (m_fnd_confs_buf_alloc(&p_buf_status, data_length) == M_ERR_NO_ERROR)
    {
        // Get pointer to data
        uint8_t *p_data = M_TB_BUF_DATA(p_buf_status);
    a656:	001c      	movs	r4, r3
    a658:	889b      	ldrh	r3, [r3, #4]
    a65a:	3430      	adds	r4, #48	; 0x30
    a65c:	18e4      	adds	r4, r4, r3
        // Application key local identifier
        m_lid_t app_key_lid = M_INVALID_LID;
    a65e:	ab08      	add	r3, sp, #32
    a660:	469c      	mov	ip, r3
    a662:	23ff      	movs	r3, #255	; 0xff
    a664:	4662      	mov	r2, ip
        // Publish address
        uint16_t publish_addr = M_UNASSIGNED_ADDR;
        // Publish TTL
        uint8_t publish_ttl = 0;
        // Publish period
        uint8_t publish_period = 0;
    a666:	2113      	movs	r1, #19
    if (m_fnd_confs_buf_alloc(&p_buf_status, data_length) == M_ERR_NO_ERROR)
    {
        // Get pointer to data
        uint8_t *p_data = M_TB_BUF_DATA(p_buf_status);
        // Application key local identifier
        m_lid_t app_key_lid = M_INVALID_LID;
    a668:	7013      	strb	r3, [r2, #0]
        // Virtual address local index
        m_lid_t va_lid = 0;
    a66a:	2211      	movs	r2, #17
    a66c:	ab04      	add	r3, sp, #16
    a66e:	18d2      	adds	r2, r2, r3
        // Publish address
        uint16_t publish_addr = M_UNASSIGNED_ADDR;
    a670:	18ff      	adds	r7, r7, r3
        // Publish TTL
        uint8_t publish_ttl = 0;
    a672:	7498      	strb	r0, [r3, #18]
        // Publish period
        uint8_t publish_period = 0;
    a674:	18c9      	adds	r1, r1, r3
        // Publish retransmission parameters
        uint8_t publish_retx_params = 0;
    a676:	2624      	movs	r6, #36	; 0x24
    a678:	466b      	mov	r3, sp
    a67a:	199b      	adds	r3, r3, r6
    a67c:	7018      	strb	r0, [r3, #0]
        // Friendship credential
        uint8_t friend_cred = 0;
    a67e:	3e0f      	subs	r6, #15
    a680:	ab04      	add	r3, sp, #16
    a682:	18f6      	adds	r6, r6, r3
        // Get pointer to data
        uint8_t *p_data = M_TB_BUF_DATA(p_buf_status);
        // Application key local identifier
        m_lid_t app_key_lid = M_INVALID_LID;
        // Virtual address local index
        m_lid_t va_lid = 0;
    a684:	7010      	strb	r0, [r2, #0]
        // Publish address
        uint16_t publish_addr = M_UNASSIGNED_ADDR;
    a686:	8038      	strh	r0, [r7, #0]
        // Publish TTL
        uint8_t publish_ttl = 0;
        // Publish period
        uint8_t publish_period = 0;
    a688:	7008      	strb	r0, [r1, #0]
        // Publish retransmission parameters
        uint8_t publish_retx_params = 0;
        // Friendship credential
        uint8_t friend_cred = 0;
    a68a:	7030      	strb	r0, [r6, #0]
        // AppKey ID
        uint16_t appkey_id = 0;

        if (status == M_ERR_NO_ERROR)
    a68c:	9804      	ldr	r0, [sp, #16]
    a68e:	2800      	cmp	r0, #0
    a690:	d10d      	bne.n	a6ae <m_fnd_confs_send_model_pub_status+0x82>
        {
            // Retrieve publication parameters
            status = m_tb_mio_get_publi_param(model_lid, &publish_addr, &va_lid,
    a692:	ab09      	add	r3, sp, #36	; 0x24
    a694:	9302      	str	r3, [sp, #8]
    a696:	2312      	movs	r3, #18
    a698:	9101      	str	r1, [sp, #4]
    a69a:	a904      	add	r1, sp, #16
    a69c:	185b      	adds	r3, r3, r1
    a69e:	9300      	str	r3, [sp, #0]
    a6a0:	9603      	str	r6, [sp, #12]
    a6a2:	4663      	mov	r3, ip
    a6a4:	0039      	movs	r1, r7
    a6a6:	9807      	ldr	r0, [sp, #28]
    a6a8:	f008 fed6 	bl	13458 <m_tb_mio_get_publi_param>
    a6ac:	9004      	str	r0, [sp, #16]
                                              &app_key_lid, &publish_ttl, &publish_period,
                                              &publish_retx_params, &friend_cred);
        }

        // Write status
        *p_data = m_fnd_confs_get_air_status(status);
    a6ae:	9804      	ldr	r0, [sp, #16]
    a6b0:	f7ff ff3b 	bl	a52a <m_fnd_confs_get_air_status>
 */
__INLINE_S__ void co_write16p(void const *ptr16, uint16_t value)
{
    uint8_t *ptr=(uint8_t*)ptr16;

    *ptr++ = value&0xff;
    a6b4:	466b      	mov	r3, sp
    a6b6:	7d1b      	ldrb	r3, [r3, #20]
    a6b8:	7020      	strb	r0, [r4, #0]
    a6ba:	7063      	strb	r3, [r4, #1]
    *ptr = (value&0xff00)>>8;
    a6bc:	9b05      	ldr	r3, [sp, #20]
        // Publish retransmission parameters
        uint8_t publish_retx_params = 0;
        // Friendship credential
        uint8_t friend_cred = 0;
        // AppKey ID
        uint16_t appkey_id = 0;
    a6be:	2200      	movs	r2, #0
    a6c0:	0a1b      	lsrs	r3, r3, #8
    a6c2:	70a3      	strb	r3, [r4, #2]

        // Write Element address
        co_write16p(p_data, element_addr);
        p_data += 2;

        if (app_key_lid != M_INVALID_LID)
    a6c4:	ab08      	add	r3, sp, #32
    a6c6:	7818      	ldrb	r0, [r3, #0]
    a6c8:	28ff      	cmp	r0, #255	; 0xff
    a6ca:	d004      	beq.n	a6d6 <m_fnd_confs_send_model_pub_status+0xaa>
        {
            // Application key parameters
            const m_tb_key_app_t *p_key_app;

            // Get application key parameters
            m_tb_key_app_get(app_key_lid, &p_key_app, false);
    a6cc:	a90b      	add	r1, sp, #44	; 0x2c
    a6ce:	f008 f861 	bl	12794 <m_tb_key_app_get>

            appkey_id = p_key_app->app_key_id;
    a6d2:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    a6d4:	8a9a      	ldrh	r2, [r3, #20]
        }

        // Write Publish Address
        co_write16p(p_data, publish_addr);
    a6d6:	883b      	ldrh	r3, [r7, #0]
 */
__INLINE_S__ void co_write32p(void const *ptr32, uint32_t value)
{
    uint8_t *ptr=(uint8_t*)ptr32;

    *ptr++ = (uint8_t)(value&0xff);
    a6d8:	72a5      	strb	r5, [r4, #10]
 */
__INLINE_S__ void co_write16p(void const *ptr16, uint16_t value)
{
    uint8_t *ptr=(uint8_t*)ptr16;

    *ptr++ = value&0xff;
    a6da:	70e3      	strb	r3, [r4, #3]
    *ptr = (value&0xff00)>>8;
    a6dc:	0a1b      	lsrs	r3, r3, #8
    a6de:	7123      	strb	r3, [r4, #4]
        p_data += 2;

        // Write AppKey index + Friendship Credential Flag
        co_write16p(p_data, appkey_id | ((uint16_t)friend_cred << M_FND_CONFS_CREDENTIAL_FLAG_POS));
    a6e0:	7833      	ldrb	r3, [r6, #0]
    a6e2:	031b      	lsls	r3, r3, #12
    a6e4:	431a      	orrs	r2, r3
        p_data += 2;

        // Write Publish TTL
        *p_data = publish_ttl;
    a6e6:	ab04      	add	r3, sp, #16
    a6e8:	7c9b      	ldrb	r3, [r3, #18]
        // Write Publish Address
        co_write16p(p_data, publish_addr);
        p_data += 2;

        // Write AppKey index + Friendship Credential Flag
        co_write16p(p_data, appkey_id | ((uint16_t)friend_cred << M_FND_CONFS_CREDENTIAL_FLAG_POS));
    a6ea:	b212      	sxth	r2, r2
        p_data += 2;

        // Write Publish TTL
        *p_data = publish_ttl;
    a6ec:	71e3      	strb	r3, [r4, #7]
        p_data++;

        // Write Publish Period
        *p_data = publish_period;
    a6ee:	2313      	movs	r3, #19
 */
__INLINE_S__ void co_write16p(void const *ptr16, uint16_t value)
{
    uint8_t *ptr=(uint8_t*)ptr16;

    *ptr++ = value&0xff;
    a6f0:	7162      	strb	r2, [r4, #5]
    *ptr = (value&0xff00)>>8;
    a6f2:	0a12      	lsrs	r2, r2, #8
    a6f4:	71a2      	strb	r2, [r4, #6]
    a6f6:	aa04      	add	r2, sp, #16
    a6f8:	189b      	adds	r3, r3, r2
    a6fa:	781b      	ldrb	r3, [r3, #0]
    a6fc:	7223      	strb	r3, [r4, #8]
        p_data++;

        // Write Publish Retransmission Parameters
        *p_data = publish_retx_params;
    a6fe:	ab09      	add	r3, sp, #36	; 0x24
    a700:	781b      	ldrb	r3, [r3, #0]
    a702:	7263      	strb	r3, [r4, #9]
        p_data++;

        // Write Model Identifier
        if (vendor)
    a704:	9b06      	ldr	r3, [sp, #24]
    a706:	2b00      	cmp	r3, #0
    a708:	d006      	beq.n	a718 <m_fnd_confs_send_model_pub_status+0xec>
__INLINE_S__ void co_write32p(void const *ptr32, uint32_t value)
{
    uint8_t *ptr=(uint8_t*)ptr32;

    *ptr++ = (uint8_t)(value&0xff);
    *ptr++ = (uint8_t)((value&0xff00)>>8);
    a70a:	0a2b      	lsrs	r3, r5, #8
    a70c:	72e3      	strb	r3, [r4, #11]
    *ptr++ = (uint8_t)((value&0xff0000)>>16);
    a70e:	0c2b      	lsrs	r3, r5, #16
    a710:	7323      	strb	r3, [r4, #12]
    *ptr = (uint8_t)((value&0xff000000)>>24);
    a712:	0e2b      	lsrs	r3, r5, #24
    a714:	7363      	strb	r3, [r4, #13]
    a716:	e001      	b.n	a71c <m_fnd_confs_send_model_pub_status+0xf0>
__INLINE_S__ void co_write16p(void const *ptr16, uint16_t value)
{
    uint8_t *ptr=(uint8_t*)ptr16;

    *ptr++ = value&0xff;
    *ptr = (value&0xff00)>>8;
    a718:	0a2b      	lsrs	r3, r5, #8
    a71a:	72e3      	strb	r3, [r4, #11]
        {
            co_write16p(p_data, (uint16_t)model_id);
        }

        // Send the message
        m_fnd_confs_send(p_buf_status, M_FND_CONFS_2B_OPCODE(M_FND_CONFS_OPCODE_MODEL_PUB_STATUS));
    a71c:	21cc      	movs	r1, #204	; 0xcc
    a71e:	980a      	ldr	r0, [sp, #40]	; 0x28
    a720:	0149      	lsls	r1, r1, #5
    a722:	f7ff ff18 	bl	a556 <m_fnd_confs_send>
    }

    // End procedure and process next message
    m_fnd_confs_process_next();
    a726:	f001 f939 	bl	b99c <m_fnd_confs_process_next>
}
    a72a:	b00d      	add	sp, #52	; 0x34
    a72c:	bdf0      	pop	{r4, r5, r6, r7, pc}

0000a72e <m_fnd_confs_send_netkey_status>:
 * @param[in] status      Handling status for the command that triggered sending of this message.
 * @param[in] netkey_id   Received NetKey index.
 ****************************************************************************************
 */
__STATIC void m_fnd_confs_send_netkey_status(uint16_t status, uint16_t netkey_id)
{
    a72e:	b573      	push	{r0, r1, r4, r5, r6, lr}
    a730:	0006      	movs	r6, r0
    a732:	000d      	movs	r5, r1
    // Pointer to the buffer that will contain the message
    m_tb_buf_t *p_buf_status;

    if (m_fnd_confs_buf_alloc(&p_buf_status, M_FND_CONFS_NETKEY_STATUS_LEN) == M_ERR_NO_ERROR)
    a734:	a801      	add	r0, sp, #4
    a736:	2103      	movs	r1, #3
    a738:	f7ff ff06 	bl	a548 <m_fnd_confs_buf_alloc>
    a73c:	2800      	cmp	r0, #0
    a73e:	d110      	bne.n	a762 <m_fnd_confs_send_netkey_status+0x34>
    {
        // Get pointer to data
        uint8_t *p_data = M_TB_BUF_DATA(p_buf_status);
    a740:	9b01      	ldr	r3, [sp, #4]

        // Write status
        *p_data = m_fnd_confs_get_air_status(status);
    a742:	0030      	movs	r0, r6
    m_tb_buf_t *p_buf_status;

    if (m_fnd_confs_buf_alloc(&p_buf_status, M_FND_CONFS_NETKEY_STATUS_LEN) == M_ERR_NO_ERROR)
    {
        // Get pointer to data
        uint8_t *p_data = M_TB_BUF_DATA(p_buf_status);
    a744:	001c      	movs	r4, r3
    a746:	889b      	ldrh	r3, [r3, #4]
    a748:	3430      	adds	r4, #48	; 0x30
    a74a:	18e4      	adds	r4, r4, r3

        // Write status
        *p_data = m_fnd_confs_get_air_status(status);
    a74c:	f7ff feed 	bl	a52a <m_fnd_confs_get_air_status>
        // Write NetKey index
        co_write16p(p_data, netkey_id);
        p_data += 2;

        // Send the message
        m_fnd_confs_send(p_buf_status, M_FND_CONFS_2B_OPCODE(M_FND_CONFS_OPCODE_NETKEY_STATUS));
    a750:	2189      	movs	r1, #137	; 0x89
 */
__INLINE_S__ void co_write16p(void const *ptr16, uint16_t value)
{
    uint8_t *ptr=(uint8_t*)ptr16;

    *ptr++ = value&0xff;
    a752:	7065      	strb	r5, [r4, #1]
    *ptr = (value&0xff00)>>8;
    a754:	0a2d      	lsrs	r5, r5, #8
    {
        // Get pointer to data
        uint8_t *p_data = M_TB_BUF_DATA(p_buf_status);

        // Write status
        *p_data = m_fnd_confs_get_air_status(status);
    a756:	7020      	strb	r0, [r4, #0]
    a758:	70a5      	strb	r5, [r4, #2]
        // Write NetKey index
        co_write16p(p_data, netkey_id);
        p_data += 2;

        // Send the message
        m_fnd_confs_send(p_buf_status, M_FND_CONFS_2B_OPCODE(M_FND_CONFS_OPCODE_NETKEY_STATUS));
    a75a:	01c9      	lsls	r1, r1, #7
    a75c:	9801      	ldr	r0, [sp, #4]
    a75e:	f7ff fefa 	bl	a556 <m_fnd_confs_send>
    }

    // End procedure and process next message
    m_fnd_confs_process_next();
    a762:	f001 f91b 	bl	b99c <m_fnd_confs_process_next>
}
    a766:	bd73      	pop	{r0, r1, r4, r5, r6, pc}

0000a768 <m_fnd_confs_send_appkey_status>:
 * @param[in] status               Handling status for the command that triggered sending of this message.
 * @param[in] netkey_appkey_id     Received NetKey and AppKey indexes field.
 ****************************************************************************************
 */
__STATIC void m_fnd_confs_send_appkey_status(uint16_t status, uint32_t netkey_appkey_id)
{
    a768:	b573      	push	{r0, r1, r4, r5, r6, lr}
    a76a:	0006      	movs	r6, r0
    a76c:	000d      	movs	r5, r1
    // Pointer to the buffer that will contain the message
    m_tb_buf_t *p_buf_status;

    if (m_fnd_confs_buf_alloc(&p_buf_status, M_FND_CONFS_APPKEY_STATUS_LEN) == M_ERR_NO_ERROR)
    a76e:	a801      	add	r0, sp, #4
    a770:	2104      	movs	r1, #4
    a772:	f7ff fee9 	bl	a548 <m_fnd_confs_buf_alloc>
    a776:	2800      	cmp	r0, #0
    a778:	d112      	bne.n	a7a0 <m_fnd_confs_send_appkey_status+0x38>
    {
        // Get pointer to data
        uint8_t *p_data = M_TB_BUF_DATA(p_buf_status);
    a77a:	9b01      	ldr	r3, [sp, #4]

        // Write status
        *p_data = m_fnd_confs_get_air_status(status);
    a77c:	0030      	movs	r0, r6
    m_tb_buf_t *p_buf_status;

    if (m_fnd_confs_buf_alloc(&p_buf_status, M_FND_CONFS_APPKEY_STATUS_LEN) == M_ERR_NO_ERROR)
    {
        // Get pointer to data
        uint8_t *p_data = M_TB_BUF_DATA(p_buf_status);
    a77e:	001c      	movs	r4, r3
    a780:	889b      	ldrh	r3, [r3, #4]
    a782:	3430      	adds	r4, #48	; 0x30
    a784:	18e4      	adds	r4, r4, r3

        // Write status
        *p_data = m_fnd_confs_get_air_status(status);
    a786:	f7ff fed0 	bl	a52a <m_fnd_confs_get_air_status>
        // Write NetKey index/AppKey index
        co_write24p(p_data + 1, netkey_appkey_id);

        // Send the message
        m_fnd_confs_send(p_buf_status, M_FND_CONFS_2B_OPCODE(M_FND_CONFS_OPCODE_APPKEY_STATUS));
    a78a:	21e0      	movs	r1, #224	; 0xe0
 */
__INLINE_S__ void co_write24p(void const *ptr24, uint32_t value)
{
    uint8_t *ptr=(uint8_t*)ptr24;

    *ptr++ = (uint8_t)(value&0xff);
    a78c:	7065      	strb	r5, [r4, #1]
    *ptr++ = (uint8_t)((value&0xff00)>>8);
    a78e:	0a2b      	lsrs	r3, r5, #8
    *ptr++ = (uint8_t)((value&0xff0000)>>16);
    a790:	0c2d      	lsrs	r5, r5, #16
    {
        // Get pointer to data
        uint8_t *p_data = M_TB_BUF_DATA(p_buf_status);

        // Write status
        *p_data = m_fnd_confs_get_air_status(status);
    a792:	7020      	strb	r0, [r4, #0]
__INLINE_S__ void co_write24p(void const *ptr24, uint32_t value)
{
    uint8_t *ptr=(uint8_t*)ptr24;

    *ptr++ = (uint8_t)(value&0xff);
    *ptr++ = (uint8_t)((value&0xff00)>>8);
    a794:	70a3      	strb	r3, [r4, #2]
    *ptr++ = (uint8_t)((value&0xff0000)>>16);
    a796:	70e5      	strb	r5, [r4, #3]
        // Write NetKey index/AppKey index
        co_write24p(p_data + 1, netkey_appkey_id);

        // Send the message
        m_fnd_confs_send(p_buf_status, M_FND_CONFS_2B_OPCODE(M_FND_CONFS_OPCODE_APPKEY_STATUS));
    a798:	0089      	lsls	r1, r1, #2
    a79a:	9801      	ldr	r0, [sp, #4]
    a79c:	f7ff fedb 	bl	a556 <m_fnd_confs_send>
    }

    // End procedure and process next message
    m_fnd_confs_process_next();
    a7a0:	f001 f8fc 	bl	b99c <m_fnd_confs_process_next>
//zjl add callback to api
#ifdef APP_FOR_ALI
	if(p_m_api_cb && p_m_api_cb->cb_prov_state){
    a7a4:	4b05      	ldr	r3, [pc, #20]	; (a7bc <m_fnd_confs_send_appkey_status+0x54>)
    a7a6:	681b      	ldr	r3, [r3, #0]
    a7a8:	2b00      	cmp	r3, #0
    a7aa:	d005      	beq.n	a7b8 <m_fnd_confs_send_appkey_status+0x50>
    a7ac:	689b      	ldr	r3, [r3, #8]
    a7ae:	2b00      	cmp	r3, #0
    a7b0:	d002      	beq.n	a7b8 <m_fnd_confs_send_appkey_status+0x50>
		// inform application that provisioning failed or succeed
		p_m_api_cb->cb_prov_state(M_PROV_SUCCEED_APP, M_ERR_NO_ERROR);
    a7b2:	2100      	movs	r1, #0
    a7b4:	2003      	movs	r0, #3
    a7b6:	4798      	blx	r3
	}
#endif
}
    a7b8:	bd73      	pop	{r0, r1, r4, r5, r6, pc}
    a7ba:	46c0      	nop			; (mov r8, r8)
    a7bc:	10012698 	.word	0x10012698

0000a7c0 <m_fnd_confs_send_compo_data_status>:
 * @param[in] length    Page length
 * @param[in] p_data    Pointer to page content
 ****************************************************************************************
 */
__STATIC void m_fnd_confs_send_compo_data_status(uint8_t page, uint8_t length, uint8_t *p_data)
{
    a7c0:	b573      	push	{r0, r1, r4, r5, r6, lr}
    a7c2:	0006      	movs	r6, r0
    a7c4:	000c      	movs	r4, r1
    // Pointer to the buffer that will contain the message
    m_tb_buf_t *p_buf_status;

    if (m_fnd_confs_buf_alloc(&p_buf_status, M_FND_CONFS_COMPO_DATA_STATUS_LEN + length) == M_ERR_NO_ERROR)
    a7c6:	a801      	add	r0, sp, #4
    a7c8:	3101      	adds	r1, #1
 * @param[in] length    Page length
 * @param[in] p_data    Pointer to page content
 ****************************************************************************************
 */
__STATIC void m_fnd_confs_send_compo_data_status(uint8_t page, uint8_t length, uint8_t *p_data)
{
    a7ca:	0015      	movs	r5, r2
    // Pointer to the buffer that will contain the message
    m_tb_buf_t *p_buf_status;

    if (m_fnd_confs_buf_alloc(&p_buf_status, M_FND_CONFS_COMPO_DATA_STATUS_LEN + length) == M_ERR_NO_ERROR)
    a7cc:	f7ff febc 	bl	a548 <m_fnd_confs_buf_alloc>
    a7d0:	2800      	cmp	r0, #0
    a7d2:	d10e      	bne.n	a7f2 <m_fnd_confs_send_compo_data_status+0x32>
    {
        // Get pointer to data
        uint8_t *p_data_buf = M_TB_BUF_DATA(p_buf_status);
    a7d4:	9b01      	ldr	r3, [sp, #4]

        // Write page
        *p_data_buf = page;
        // Write page content
        memcpy(p_data_buf + 1, p_data, length);
    a7d6:	0029      	movs	r1, r5
    m_tb_buf_t *p_buf_status;

    if (m_fnd_confs_buf_alloc(&p_buf_status, M_FND_CONFS_COMPO_DATA_STATUS_LEN + length) == M_ERR_NO_ERROR)
    {
        // Get pointer to data
        uint8_t *p_data_buf = M_TB_BUF_DATA(p_buf_status);
    a7d8:	0018      	movs	r0, r3
    a7da:	889b      	ldrh	r3, [r3, #4]
    a7dc:	3030      	adds	r0, #48	; 0x30
    a7de:	18c0      	adds	r0, r0, r3

        // Write page
        *p_data_buf = page;
    a7e0:	7006      	strb	r6, [r0, #0]
        // Write page content
        memcpy(p_data_buf + 1, p_data, length);
    a7e2:	0022      	movs	r2, r4
    a7e4:	3001      	adds	r0, #1
    a7e6:	f00b f8f3 	bl	159d0 <memcpy>

        // Send the message
        m_fnd_confs_send(p_buf_status, M_FND_CONFS_OPCODE_COMPO_DATA_STATUS);
    a7ea:	2102      	movs	r1, #2
    a7ec:	9801      	ldr	r0, [sp, #4]
    a7ee:	f7ff feb2 	bl	a556 <m_fnd_confs_send>
    }

    // End procedure and process next message
    m_fnd_confs_process_next();
    a7f2:	f001 f8d3 	bl	b99c <m_fnd_confs_process_next>
}
    a7f6:	bd73      	pop	{r0, r1, r4, r5, r6, pc}

0000a7f8 <m_fnd_confs_cb_sec_cmac_ready>:
 * @param[in] net_key_lid   Network key local index allocated.
 ****************************************************************************************
 */
__STATIC uint16_t m_fnd_confs_cb_sec_cmac_ready(uint8_t token_id, const uint8_t **pp_key, const uint8_t **pp_msg,
                                                uint16_t *p_msg_len)
{
    a7f8:	b530      	push	{r4, r5, lr}
    a7fa:	000d      	movs	r5, r1
    // Retrieve the buffer being processed
    m_tb_buf_t *p_buf = (m_tb_buf_t *)co_list_pick(&p_m_fnd_confs_env->process_queue);
    a7fc:	4908      	ldr	r1, [pc, #32]	; (a820 <m_fnd_confs_cb_sec_cmac_ready+0x28>)
    a7fe:	6809      	ldr	r1, [r1, #0]
    a800:	6809      	ldr	r1, [r1, #0]

    if (p_buf)
    a802:	2900      	cmp	r1, #0
    a804:	d100      	bne.n	a808 <m_fnd_confs_cb_sec_cmac_ready+0x10>
    a806:	e7fe      	b.n	a806 <m_fnd_confs_cb_sec_cmac_ready+0xe>
    {
        // Get pointer to data
        uint8_t *p_data = M_TB_BUF_DATA(p_buf);
    a808:	8888      	ldrh	r0, [r1, #4]

        // Provide requested information
        *pp_key = &m_fnd_confs_vtad_salt[0];
    a80a:	4c06      	ldr	r4, [pc, #24]	; (a824 <m_fnd_confs_cb_sec_cmac_ready+0x2c>)
        // Label UUID is always right after the element address whose length is 2 bytes
        *pp_msg = p_data + 2;
    a80c:	1809      	adds	r1, r1, r0
    {
        // Get pointer to data
        uint8_t *p_data = M_TB_BUF_DATA(p_buf);

        // Provide requested information
        *pp_key = &m_fnd_confs_vtad_salt[0];
    a80e:	3409      	adds	r4, #9
        // Label UUID is always right after the element address whose length is 2 bytes
        *pp_msg = p_data + 2;
    a810:	3132      	adds	r1, #50	; 0x32
    {
        // Get pointer to data
        uint8_t *p_data = M_TB_BUF_DATA(p_buf);

        // Provide requested information
        *pp_key = &m_fnd_confs_vtad_salt[0];
    a812:	602c      	str	r4, [r5, #0]
        // Label UUID is always right after the element address whose length is 2 bytes
        *pp_msg = p_data + 2;
    a814:	6011      	str	r1, [r2, #0]
        *p_msg_len = M_LABEL_UUID_LEN;
    a816:	2210      	movs	r2, #16
    {
        ASSERT_ERR(0);
    }

    return (M_ERR_NO_ERROR);
}
    a818:	2000      	movs	r0, #0

        // Provide requested information
        *pp_key = &m_fnd_confs_vtad_salt[0];
        // Label UUID is always right after the element address whose length is 2 bytes
        *pp_msg = p_data + 2;
        *p_msg_len = M_LABEL_UUID_LEN;
    a81a:	801a      	strh	r2, [r3, #0]
    {
        ASSERT_ERR(0);
    }

    return (M_ERR_NO_ERROR);
}
    a81c:	bd30      	pop	{r4, r5, pc}
    a81e:	46c0      	nop			; (mov r8, r8)
    a820:	100126a0 	.word	0x100126a0
    a824:	000215dc 	.word	0x000215dc

0000a828 <m_fnd_confs_cb_sec_cmac_pub_finished>:
 ****************************************************************************************
 */
__STATIC void m_fnd_confs_cb_sec_cmac_pub_finished(uint8_t token_id, uint16_t status, const uint8_t *p_auth_val)
{
    // Retrieve the buffer being processed
    m_tb_buf_t *p_buf = (m_tb_buf_t *)co_list_pick(&p_m_fnd_confs_env->process_queue);
    a828:	4b32      	ldr	r3, [pc, #200]	; (a8f4 <m_fnd_confs_cb_sec_cmac_pub_finished+0xcc>)
 * @param[in] status        Add status.
 * @param[in] net_key_lid   Network key local index allocated.
 ****************************************************************************************
 */
__STATIC void m_fnd_confs_cb_sec_cmac_pub_finished(uint8_t token_id, uint16_t status, const uint8_t *p_auth_val)
{
    a82a:	b5f0      	push	{r4, r5, r6, r7, lr}
    a82c:	681b      	ldr	r3, [r3, #0]
    a82e:	b08d      	sub	sp, #52	; 0x34
    a830:	681b      	ldr	r3, [r3, #0]
    // Retrieve the buffer being processed
    m_tb_buf_t *p_buf = (m_tb_buf_t *)co_list_pick(&p_m_fnd_confs_env->process_queue);

    if (p_buf)
    a832:	2b00      	cmp	r3, #0
    a834:	d05d      	beq.n	a8f2 <m_fnd_confs_cb_sec_cmac_pub_finished+0xca>
    {
        // Get pointer to data
        uint8_t *p_data = M_TB_BUF_DATA(p_buf);
    a836:	001c      	movs	r4, r3
    a838:	8899      	ldrh	r1, [r3, #4]
        m_fnd_confs_model_pub_set_t p_msg;

        // Extract received parameters
        p_msg.element_addr = co_read16p(p_data);
        // Create a virtual address from the generated hash value
        p_msg.publish_addr = (*(uint16_t *)p_auth_val & ~CO_BIT(14)) | CO_BIT(15);;
    a83a:	8812      	ldrh	r2, [r2, #0]
    m_tb_buf_t *p_buf = (m_tb_buf_t *)co_list_pick(&p_m_fnd_confs_env->process_queue);

    if (p_buf)
    {
        // Get pointer to data
        uint8_t *p_data = M_TB_BUF_DATA(p_buf);
    a83c:	3430      	adds	r4, #48	; 0x30
    a83e:	1864      	adds	r4, r4, r1
        m_fnd_confs_model_pub_set_t p_msg;

        // Extract received parameters
        p_msg.element_addr = co_read16p(p_data);
        // Create a virtual address from the generated hash value
        p_msg.publish_addr = (*(uint16_t *)p_auth_val & ~CO_BIT(14)) | CO_BIT(15);;
    a840:	9205      	str	r2, [sp, #20]
        p_msg.appkey_id_cred_flag = *(p_data + 18);
    a842:	7ca2      	ldrb	r2, [r4, #18]
 * @return The 16 bits value.
 ****************************************************************************************
 */
__INLINE_S__ uint16_t co_read16p(void const *ptr16)
{
    uint16_t value = ((uint8_t *)ptr16)[0] | ((uint8_t *)ptr16)[1] << 8;
    a844:	7861      	ldrb	r1, [r4, #1]
    a846:	9206      	str	r2, [sp, #24]
        p_msg.publish_ttl = *(p_data + 20);
    a848:	7d22      	ldrb	r2, [r4, #20]
    a84a:	7820      	ldrb	r0, [r4, #0]
    a84c:	9207      	str	r2, [sp, #28]
        p_msg.publish_period = *(p_data + 21);
    a84e:	7d62      	ldrb	r2, [r4, #21]
    a850:	0209      	lsls	r1, r1, #8
    a852:	9208      	str	r2, [sp, #32]
        p_msg.publish_retx_params = *(p_data + 22);
    a854:	7da2      	ldrb	r2, [r4, #22]
    a856:	4308      	orrs	r0, r1
    a858:	9004      	str	r0, [sp, #16]
    a85a:	9209      	str	r2, [sp, #36]	; 0x24

        if (p_buf->data_len == M_FND_CONFS_MODEL_PUB_VADDR_SET_LEN)
    a85c:	891b      	ldrh	r3, [r3, #8]
    a85e:	2b19      	cmp	r3, #25
    a860:	d105      	bne.n	a86e <m_fnd_confs_cb_sec_cmac_pub_finished+0x46>
        {
            p_msg.model_id = co_read16p(p_data + 23);
    a862:	7e25      	ldrb	r5, [r4, #24]
    a864:	7de3      	ldrb	r3, [r4, #23]
    a866:	022d      	lsls	r5, r5, #8
    a868:	431d      	orrs	r5, r3
            p_msg.vendor = false;
    a86a:	2600      	movs	r6, #0
    a86c:	e005      	b.n	a87a <m_fnd_confs_cb_sec_cmac_pub_finished+0x52>

        }
        else
        {
            p_msg.model_id = co_read32p(p_data + 23);
    a86e:	0020      	movs	r0, r4
    a870:	3017      	adds	r0, #23
    a872:	f7ff fe4f 	bl	a514 <co_read32p>
            p_msg.vendor = true;
    a876:	2601      	movs	r6, #1
            p_msg.vendor = false;

        }
        else
        {
            p_msg.model_id = co_read32p(p_data + 23);
    a878:	0005      	movs	r5, r0
        {
            // Application key local index
            m_lid_t app_key_lid;

            // Check that element address is well a local address
            if (!m_tb_mio_is_local_addr(p_msg.element_addr))
    a87a:	9804      	ldr	r0, [sp, #16]
    a87c:	f009 f8e4 	bl	13a48 <m_tb_mio_is_local_addr>
    a880:	2800      	cmp	r0, #0
    a882:	d028      	beq.n	a8d6 <m_fnd_confs_cb_sec_cmac_pub_finished+0xae>
                status = M_ERR_INVALID_ADDR;
                break;
            }

            // Look for model local index
            status = m_tb_mio_get_local_id(p_msg.element_addr, p_msg.model_id, p_msg.vendor, &model_lid);
    a884:	2316      	movs	r3, #22
    a886:	aa06      	add	r2, sp, #24
    a888:	189b      	adds	r3, r3, r2
    a88a:	0029      	movs	r1, r5
    a88c:	0032      	movs	r2, r6
    a88e:	9804      	ldr	r0, [sp, #16]
    a890:	f008 fcd2 	bl	13238 <m_tb_mio_get_local_id>

            if (status != M_ERR_NO_ERROR)
    a894:	2800      	cmp	r0, #0
    a896:	d120      	bne.n	a8da <m_fnd_confs_cb_sec_cmac_pub_finished+0xb2>
            {
                break;
            }

            // Look for indicated application key
            status = m_tb_key_app_find(GETF(p_msg.appkey_id_cred_flag, M_FND_CONFS_APPKEY_ID),
    a898:	2717      	movs	r7, #23
    a89a:	ab06      	add	r3, sp, #24
    a89c:	18ff      	adds	r7, r7, r3
    a89e:	466b      	mov	r3, sp
    a8a0:	0039      	movs	r1, r7
    a8a2:	8b18      	ldrh	r0, [r3, #24]
    a8a4:	f007 ffaa 	bl	127fc <m_tb_key_app_find>
                                       &app_key_lid);

            if (status != M_ERR_NO_ERROR)
    a8a8:	2800      	cmp	r0, #0
    a8aa:	d116      	bne.n	a8da <m_fnd_confs_cb_sec_cmac_pub_finished+0xb2>
            {
                break;
            }

            // Set publication parameters
            status = m_tb_mio_set_publi_param(model_lid, p_msg.publish_addr, p_data + 2,
    a8ac:	1ca2      	adds	r2, r4, #2
    a8ae:	2480      	movs	r4, #128	; 0x80
    a8b0:	9905      	ldr	r1, [sp, #20]
    a8b2:	0224      	lsls	r4, r4, #8
    a8b4:	0489      	lsls	r1, r1, #18
    a8b6:	0c89      	lsrs	r1, r1, #18
    a8b8:	4321      	orrs	r1, r4
    a8ba:	ac06      	add	r4, sp, #24
    a8bc:	783b      	ldrb	r3, [r7, #0]
    a8be:	7da7      	ldrb	r7, [r4, #22]
    a8c0:	9003      	str	r0, [sp, #12]
    a8c2:	9809      	ldr	r0, [sp, #36]	; 0x24
    a8c4:	9002      	str	r0, [sp, #8]
    a8c6:	9808      	ldr	r0, [sp, #32]
    a8c8:	9001      	str	r0, [sp, #4]
    a8ca:	9807      	ldr	r0, [sp, #28]
    a8cc:	9000      	str	r0, [sp, #0]
    a8ce:	0038      	movs	r0, r7
    a8d0:	f008 fd44 	bl	1335c <m_tb_mio_set_publi_param>
    a8d4:	e001      	b.n	a8da <m_fnd_confs_cb_sec_cmac_pub_finished+0xb2>
            m_lid_t app_key_lid;

            // Check that element address is well a local address
            if (!m_tb_mio_is_local_addr(p_msg.element_addr))
            {
                status = M_ERR_INVALID_ADDR;
    a8d6:	20c0      	movs	r0, #192	; 0xc0
    a8d8:	0040      	lsls	r0, r0, #1
                                              p_msg.publish_retx_params,
                                              GETB(p_msg.appkey_id_cred_flag, M_FND_CONFS_CREDENTIAL_FLAG));
        } while (0);

        // Send the status
        m_fnd_confs_send_model_pub_status(status, p_msg.element_addr, p_msg.model_id, p_msg.vendor, model_lid);
    a8da:	2316      	movs	r3, #22
    a8dc:	aa06      	add	r2, sp, #24
    a8de:	189b      	adds	r3, r3, r2
    a8e0:	781b      	ldrb	r3, [r3, #0]
    a8e2:	002a      	movs	r2, r5
    a8e4:	9300      	str	r3, [sp, #0]
    a8e6:	9904      	ldr	r1, [sp, #16]
    a8e8:	0033      	movs	r3, r6
    a8ea:	f7ff fe9f 	bl	a62c <m_fnd_confs_send_model_pub_status>
    }
    else
    {
        ASSERT_ERR(0);
    }
}
    a8ee:	b00d      	add	sp, #52	; 0x34
    a8f0:	bdf0      	pop	{r4, r5, r6, r7, pc}
    a8f2:	e7fe      	b.n	a8f2 <m_fnd_confs_cb_sec_cmac_pub_finished+0xca>
    a8f4:	100126a0 	.word	0x100126a0

0000a8f8 <m_fnd_confs_cb_sec_cmac_subs_finished>:
 * @param[in] status        Add status.
 * @param[in] net_key_lid   Network key local index allocated.
 ****************************************************************************************
 */
__STATIC void m_fnd_confs_cb_sec_cmac_subs_finished(uint8_t token_id, uint16_t status, const uint8_t *p_auth_val)
{
    a8f8:	b5f0      	push	{r4, r5, r6, r7, lr}
    // Retrieve the buffer being processed
    m_tb_buf_t *p_buf = (m_tb_buf_t *)co_list_pick(&p_m_fnd_confs_env->process_queue);
    a8fa:	4b28      	ldr	r3, [pc, #160]	; (a99c <m_fnd_confs_cb_sec_cmac_subs_finished+0xa4>)
 * @param[in] status        Add status.
 * @param[in] net_key_lid   Network key local index allocated.
 ****************************************************************************************
 */
__STATIC void m_fnd_confs_cb_sec_cmac_subs_finished(uint8_t token_id, uint16_t status, const uint8_t *p_auth_val)
{
    a8fc:	b089      	sub	sp, #36	; 0x24
    a8fe:	681b      	ldr	r3, [r3, #0]
    a900:	000e      	movs	r6, r1
    a902:	681b      	ldr	r3, [r3, #0]
    a904:	9205      	str	r2, [sp, #20]
    // Retrieve the buffer being processed
    m_tb_buf_t *p_buf = (m_tb_buf_t *)co_list_pick(&p_m_fnd_confs_env->process_queue);

    if (p_buf)
    a906:	2b00      	cmp	r3, #0
    a908:	d046      	beq.n	a998 <m_fnd_confs_cb_sec_cmac_subs_finished+0xa0>
    {
        // Get pointer to data
        uint8_t *p_data = M_TB_BUF_DATA(p_buf);
    a90a:	001c      	movs	r4, r3
    a90c:	889a      	ldrh	r2, [r3, #4]
    a90e:	3430      	adds	r4, #48	; 0x30
    a910:	18a4      	adds	r4, r4, r2
    a912:	7862      	ldrb	r2, [r4, #1]
    a914:	7821      	ldrb	r1, [r4, #0]
    a916:	0212      	lsls	r2, r2, #8
    a918:	4311      	orrs	r1, r2
    a91a:	9104      	str	r1, [sp, #16]
        uint32_t model_id;
        // SIG or vendor model identifier
        bool vendor;

        // Read model identifier with the appropriate format
        if (p_buf->data_len != M_FND_CONFS_MODEL_SUBS_VADDR_LEN)
    a91c:	891b      	ldrh	r3, [r3, #8]
    a91e:	2b14      	cmp	r3, #20
    a920:	d007      	beq.n	a932 <m_fnd_confs_cb_sec_cmac_subs_finished+0x3a>
        {
            model_id = co_read32p(p_data + 18);
    a922:	0020      	movs	r0, r4
    a924:	3012      	adds	r0, #18
    a926:	f7ff fdf5 	bl	a514 <co_read32p>
            vendor = true;
    a92a:	2301      	movs	r3, #1
        bool vendor;

        // Read model identifier with the appropriate format
        if (p_buf->data_len != M_FND_CONFS_MODEL_SUBS_VADDR_LEN)
        {
            model_id = co_read32p(p_data + 18);
    a92c:	9002      	str	r0, [sp, #8]
            vendor = true;
    a92e:	9303      	str	r3, [sp, #12]
    a930:	e006      	b.n	a940 <m_fnd_confs_cb_sec_cmac_subs_finished+0x48>
        }
        else
        {
            model_id = (uint32_t)co_read16p(p_data + 18);
    a932:	7ce3      	ldrb	r3, [r4, #19]
    a934:	7ca2      	ldrb	r2, [r4, #18]
    a936:	021b      	lsls	r3, r3, #8
    a938:	431a      	orrs	r2, r3
            vendor = false;
    a93a:	2300      	movs	r3, #0
            model_id = co_read32p(p_data + 18);
            vendor = true;
        }
        else
        {
            model_id = (uint32_t)co_read16p(p_data + 18);
    a93c:	9202      	str	r2, [sp, #8]
            vendor = false;
    a93e:	9303      	str	r3, [sp, #12]
    if (p_buf)
    {
        // Get pointer to data
        uint8_t *p_data = M_TB_BUF_DATA(p_buf);
        // Virtual address
        uint16_t vaddr = M_UNASSIGNED_ADDR;
    a940:	2500      	movs	r5, #0
        {
            model_id = (uint32_t)co_read16p(p_data + 18);
            vendor = false;
        }

        if (status == M_ERR_NO_ERROR)
    a942:	42ae      	cmp	r6, r5
    a944:	d11f      	bne.n	a986 <m_fnd_confs_cb_sec_cmac_subs_finished+0x8e>
        {
            // Model local index
            m_lid_t model_lid;

            // Retrieve model local identifier
            m_tb_mio_get_local_id(element_addr, model_id, vendor, &model_lid);
    a946:	270f      	movs	r7, #15
    a948:	ab04      	add	r3, sp, #16
    a94a:	18ff      	adds	r7, r7, r3
    a94c:	003b      	movs	r3, r7
    a94e:	9a03      	ldr	r2, [sp, #12]
    a950:	9902      	ldr	r1, [sp, #8]
    a952:	9804      	ldr	r0, [sp, #16]
    a954:	f008 fc70 	bl	13238 <m_tb_mio_get_local_id>

            // Deduce virtual address from generated hash value
            vaddr = (*(uint16_t *)p_auth_val & ~CO_BIT(14)) | CO_BIT(15);
    a958:	9b05      	ldr	r3, [sp, #20]
    a95a:	881d      	ldrh	r5, [r3, #0]
    a95c:	2380      	movs	r3, #128	; 0x80
    a95e:	04ad      	lsls	r5, r5, #18
    a960:	021b      	lsls	r3, r3, #8
    a962:	0cad      	lsrs	r5, r5, #18
    a964:	431d      	orrs	r5, r3

            switch (p_m_fnd_confs_env->opcode)
    a966:	4b0d      	ldr	r3, [pc, #52]	; (a99c <m_fnd_confs_cb_sec_cmac_subs_finished+0xa4>)
    a968:	681b      	ldr	r3, [r3, #0]
    a96a:	7e1b      	ldrb	r3, [r3, #24]
    a96c:	2b20      	cmp	r3, #32
    a96e:	d004      	beq.n	a97a <m_fnd_confs_cb_sec_cmac_subs_finished+0x82>
    a970:	2b22      	cmp	r3, #34	; 0x22
    a972:	d108      	bne.n	a986 <m_fnd_confs_cb_sec_cmac_subs_finished+0x8e>
                } break;

                case (M_FND_CONFS_OPCODE_MODEL_SUBS_VADDR_OVERWRITE):
                {
                    // Delete content of the subscription list
                    m_tb_mio_delete_all_subscription(model_lid);
    a974:	7838      	ldrb	r0, [r7, #0]
    a976:	f008 fed9 	bl	1372c <m_tb_mio_delete_all_subscription>

                    // Add address to the subscription list
                    status = m_tb_mio_add_subscription_virt(model_lid, vaddr, p_data + 2);
    a97a:	1ca2      	adds	r2, r4, #2
    a97c:	7838      	ldrb	r0, [r7, #0]
    a97e:	0029      	movs	r1, r5
    a980:	f008 fe0c 	bl	1359c <m_tb_mio_add_subscription_virt>
    a984:	0006      	movs	r6, r0
                } break;
            }
        }

        // Send the status
        m_fnd_confs_send_model_subs_status(status, element_addr, model_id, vendor, vaddr);
    a986:	9500      	str	r5, [sp, #0]
    a988:	9b03      	ldr	r3, [sp, #12]
    a98a:	9a02      	ldr	r2, [sp, #8]
    a98c:	9904      	ldr	r1, [sp, #16]
    a98e:	0030      	movs	r0, r6
    a990:	f7ff fe13 	bl	a5ba <m_fnd_confs_send_model_subs_status>
    }
    else
    {
        ASSERT_ERR(0);
    }
}
    a994:	b009      	add	sp, #36	; 0x24
    a996:	bdf0      	pop	{r4, r5, r6, r7, pc}
    a998:	e7fe      	b.n	a998 <m_fnd_confs_cb_sec_cmac_subs_finished+0xa0>
    a99a:	46c0      	nop			; (mov r8, r8)
    a99c:	100126a0 	.word	0x100126a0

0000a9a0 <m_fnd_confs_cb_netkey_added>:
 ****************************************************************************************
 */
__STATIC void m_fnd_confs_cb_netkey_added(uint16_t status, m_lid_t net_key_lid)
{
    // Retrieve the buffer being processed
    m_tb_buf_t *p_buf = (m_tb_buf_t *)co_list_pick(&p_m_fnd_confs_env->process_queue);
    a9a0:	4b08      	ldr	r3, [pc, #32]	; (a9c4 <m_fnd_confs_cb_netkey_added+0x24>)
 * @param[in] status        Add status.
 * @param[in] net_key_lid   Network key local index allocated.
 ****************************************************************************************
 */
__STATIC void m_fnd_confs_cb_netkey_added(uint16_t status, m_lid_t net_key_lid)
{
    a9a2:	b510      	push	{r4, lr}
    a9a4:	681b      	ldr	r3, [r3, #0]
    a9a6:	681a      	ldr	r2, [r3, #0]
    // Retrieve the buffer being processed
    m_tb_buf_t *p_buf = (m_tb_buf_t *)co_list_pick(&p_m_fnd_confs_env->process_queue);

    if (p_buf)
    a9a8:	2a00      	cmp	r2, #0
    a9aa:	d00a      	beq.n	a9c2 <m_fnd_confs_cb_netkey_added+0x22>
    {
        // Retrieve received NetKey index
        uint16_t netkey_id = co_read16p(M_TB_BUF_DATA(p_buf));
    a9ac:	0011      	movs	r1, r2
    a9ae:	8893      	ldrh	r3, [r2, #4]
    a9b0:	3130      	adds	r1, #48	; 0x30
    a9b2:	18cb      	adds	r3, r1, r3

        // Send a Config NetKey Status message
        m_fnd_confs_send_netkey_status(status, netkey_id);
    a9b4:	7859      	ldrb	r1, [r3, #1]
    a9b6:	781b      	ldrb	r3, [r3, #0]
    a9b8:	0209      	lsls	r1, r1, #8
    a9ba:	4319      	orrs	r1, r3
    a9bc:	f7ff feb7 	bl	a72e <m_fnd_confs_send_netkey_status>
    }
    else
    {
        ASSERT_ERR(0);
    }
}
    a9c0:	bd10      	pop	{r4, pc}
    a9c2:	e7fe      	b.n	a9c2 <m_fnd_confs_cb_netkey_added+0x22>
    a9c4:	100126a0 	.word	0x100126a0

0000a9c8 <m_fnd_confs_cb_appkey_added>:
 ****************************************************************************************
 */
__STATIC void m_fnd_confs_cb_appkey_added(uint16_t status, m_lid_t app_key_lid)
{
    // Retrieve the buffer being processed
    m_tb_buf_t *p_buf = (m_tb_buf_t *)co_list_pick(&p_m_fnd_confs_env->process_queue);
    a9c8:	4b19      	ldr	r3, [pc, #100]	; (aa30 <m_fnd_confs_cb_appkey_added+0x68>)
 * @param[in] status        Add status.
 * @param[in] app_key_lid   Application key local index allocated.
 ****************************************************************************************
 */
__STATIC void m_fnd_confs_cb_appkey_added(uint16_t status, m_lid_t app_key_lid)
{
    a9ca:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    a9cc:	681b      	ldr	r3, [r3, #0]
    a9ce:	0007      	movs	r7, r0
    a9d0:	681b      	ldr	r3, [r3, #0]
    // Retrieve the buffer being processed
    m_tb_buf_t *p_buf = (m_tb_buf_t *)co_list_pick(&p_m_fnd_confs_env->process_queue);

    if (p_buf)
    a9d2:	2b00      	cmp	r3, #0
    a9d4:	d02a      	beq.n	aa2c <m_fnd_confs_cb_appkey_added+0x64>
    {
        // Retrieve received NetKey/AppKey index
        uint32_t netkey_appkey_id = co_read24p(M_TB_BUF_DATA(p_buf));
    a9d6:	001a      	movs	r2, r3
    a9d8:	889b      	ldrh	r3, [r3, #4]
    a9da:	3230      	adds	r2, #48	; 0x30
    a9dc:	18d2      	adds	r2, r2, r3
__INLINE_S__ uint32_t co_read24p(void const *ptr24)
{
    uint16_t addr_l, addr_h;
    addr_l = co_read16p(ptr24);
    addr_h = *((uint8_t *)ptr24 + 2) & 0x00FF;
    return ((uint32_t)addr_l | (uint32_t)addr_h << 16);
    a9de:	7855      	ldrb	r5, [r2, #1]
    a9e0:	7813      	ldrb	r3, [r2, #0]
    a9e2:	022d      	lsls	r5, r5, #8
    a9e4:	432b      	orrs	r3, r5
    a9e6:	7895      	ldrb	r5, [r2, #2]
    a9e8:	042d      	lsls	r5, r5, #16
    a9ea:	431d      	orrs	r5, r3
		M_PRINTF(L_FND, "netkey_appkey_id = %d", netkey_appkey_id);
    a9ec:	4b11      	ldr	r3, [pc, #68]	; (aa34 <m_fnd_confs_cb_appkey_added+0x6c>)
    a9ee:	681b      	ldr	r3, [r3, #0]
    a9f0:	051b      	lsls	r3, r3, #20
    a9f2:	d516      	bpl.n	aa22 <m_fnd_confs_cb_appkey_added+0x5a>
    a9f4:	4c10      	ldr	r4, [pc, #64]	; (aa38 <m_fnd_confs_cb_appkey_added+0x70>)
    a9f6:	0023      	movs	r3, r4
    a9f8:	0022      	movs	r2, r4
    a9fa:	0020      	movs	r0, r4
    a9fc:	3370      	adds	r3, #112	; 0x70
    a9fe:	3253      	adds	r2, #83	; 0x53
    aa00:	9300      	str	r3, [sp, #0]
    aa02:	0021      	movs	r1, r4
    aa04:	4b0d      	ldr	r3, [pc, #52]	; (aa3c <m_fnd_confs_cb_appkey_added+0x74>)
    aa06:	3061      	adds	r0, #97	; 0x61
    aa08:	f7f9 ffd0 	bl	49ac <m_print>
    aa0c:	4e0c      	ldr	r6, [pc, #48]	; (aa40 <m_fnd_confs_cb_appkey_added+0x78>)
    aa0e:	0029      	movs	r1, r5
    aa10:	0030      	movs	r0, r6
    aa12:	300c      	adds	r0, #12
    aa14:	f7f9 ffca 	bl	49ac <m_print>
    aa18:	0030      	movs	r0, r6
    aa1a:	1da1      	adds	r1, r4, #6
    aa1c:	3022      	adds	r0, #34	; 0x22
    aa1e:	f7f9 ffc5 	bl	49ac <m_print>
        // Send a Config AppKey Status message
        m_fnd_confs_send_appkey_status(status, netkey_appkey_id);
    aa22:	0029      	movs	r1, r5
    aa24:	0038      	movs	r0, r7
    aa26:	f7ff fe9f 	bl	a768 <m_fnd_confs_send_appkey_status>
    }
    else
    {
        ASSERT_ERR(0);
    }
}
    aa2a:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
    aa2c:	e7fe      	b.n	aa2c <m_fnd_confs_cb_appkey_added+0x64>
    aa2e:	46c0      	nop			; (mov r8, r8)
    aa30:	100126a0 	.word	0x100126a0
    aa34:	10010514 	.word	0x10010514
    aa38:	000215dc 	.word	0x000215dc
    aa3c:	000006e1 	.word	0x000006e1
    aa40:	0002165c 	.word	0x0002165c

0000aa44 <m_fnd_confs_cb_compo_data>:
 * @param[in] length    Page length
 * @param[in] p_data    Pointer to page content
 ****************************************************************************************
 */
__STATIC void m_fnd_confs_cb_compo_data(uint8_t page, uint8_t length, uint8_t *p_data)
{
    aa44:	b570      	push	{r4, r5, r6, lr}
    aa46:	0004      	movs	r4, r0
    aa48:	000d      	movs	r5, r1
    aa4a:	0016      	movs	r6, r2
    if ((page != 0)
    aa4c:	2800      	cmp	r0, #0
    aa4e:	d008      	beq.n	aa62 <m_fnd_confs_cb_compo_data+0x1e>
            && (page < m_tb_state_get_nb_cdata_page()))
    aa50:	f009 fd10 	bl	14474 <m_tb_state_get_nb_cdata_page>
    aa54:	4284      	cmp	r4, r0
    aa56:	d204      	bcs.n	aa62 <m_fnd_confs_cb_compo_data+0x1e>
    {
        /// Send Config Composition Data Status
        m_fnd_confs_send_compo_data_status(page, length, p_data);
    aa58:	0032      	movs	r2, r6
    aa5a:	0029      	movs	r1, r5
    aa5c:	0020      	movs	r0, r4
    aa5e:	f7ff feaf 	bl	a7c0 <m_fnd_confs_send_compo_data_status>
    }
}
    aa62:	bd70      	pop	{r4, r5, r6, pc}

0000aa64 <m_fnd_confs_handler_appkey>:
 * @param[in] opcode_2b     True if provided opcode was a 2-byte opcode (Config AppKey Delete),
 * else False
 ****************************************************************************************
 */
__STATIC void m_fnd_confs_handler_appkey(m_tb_buf_t *p_buf, uint8_t opcode, bool opcode_2b)
{	
    aa64:	b5f0      	push	{r4, r5, r6, r7, lr}
    // Status
    uint16_t status;
    // Get pointer to data
    uint8_t *p_data = M_TB_BUF_DATA(p_buf);
    aa66:	0004      	movs	r4, r0
 * @param[in] opcode_2b     True if provided opcode was a 2-byte opcode (Config AppKey Delete),
 * else False
 ****************************************************************************************
 */
__STATIC void m_fnd_confs_handler_appkey(m_tb_buf_t *p_buf, uint8_t opcode, bool opcode_2b)
{	
    aa68:	b08b      	sub	sp, #44	; 0x2c
    aa6a:	9103      	str	r1, [sp, #12]
    aa6c:	9202      	str	r2, [sp, #8]
    // Status
    uint16_t status;
    // Get pointer to data
    uint8_t *p_data = M_TB_BUF_DATA(p_buf);
    aa6e:	8883      	ldrh	r3, [r0, #4]
    aa70:	3430      	adds	r4, #48	; 0x30
    aa72:	18e4      	adds	r4, r4, r3
	m_printf_hex(L_FND, "config appkey recv data ", p_data, p_buf->data_len);
    aa74:	8903      	ldrh	r3, [r0, #8]
    aa76:	2080      	movs	r0, #128	; 0x80
    aa78:	4926      	ldr	r1, [pc, #152]	; (ab14 <m_fnd_confs_handler_appkey+0xb0>)
    aa7a:	0022      	movs	r2, r4
    aa7c:	3125      	adds	r1, #37	; 0x25
    aa7e:	0100      	lsls	r0, r0, #4
    aa80:	f7f9 fff4 	bl	4a6c <m_printf_hex>
    aa84:	7863      	ldrb	r3, [r4, #1]
    aa86:	7822      	ldrb	r2, [r4, #0]
    aa88:	021b      	lsls	r3, r3, #8
    aa8a:	4313      	orrs	r3, r2
    aa8c:	78a2      	ldrb	r2, [r4, #2]
    aa8e:	0412      	lsls	r2, r2, #16
    aa90:	4313      	orrs	r3, r2
    aa92:	9301      	str	r3, [sp, #4]
        uint16_t appkey_id = M_FND_CONFS_EXTRACT_APPKEY_ID(netkey_appkey_id);
        // Network Key local index
        m_lid_t net_key_lid;

        // Look for indicated Network Key
        status = m_tb_key_net_find(netkey_id, &net_key_lid);
    aa94:	0518      	lsls	r0, r3, #20
    aa96:	ab04      	add	r3, sp, #16
    aa98:	0d00      	lsrs	r0, r0, #20
    aa9a:	1dd9      	adds	r1, r3, #7
    aa9c:	f007 fbf4 	bl	12288 <m_tb_key_net_find>
    aaa0:	1e05      	subs	r5, r0, #0

        if (status != M_ERR_NO_ERROR)
    aaa2:	d131      	bne.n	ab08 <m_fnd_confs_handler_appkey+0xa4>
    do
    {
        // Extract NetKey ID
        uint16_t netkey_id = M_FND_CONFS_EXTRACT_NETKEY_ID(netkey_appkey_id);
        // Extract AppKey ID
        uint16_t appkey_id = M_FND_CONFS_EXTRACT_APPKEY_ID(netkey_appkey_id);
    aaa4:	9b01      	ldr	r3, [sp, #4]
    aaa6:	ae06      	add	r6, sp, #24
    aaa8:	0b1f      	lsrs	r7, r3, #12
        {
            // Network Key has not been found
            break;
        }

        if (opcode_2b)
    aaaa:	9b02      	ldr	r3, [sp, #8]
    aaac:	2b00      	cmp	r3, #0
    aaae:	d010      	beq.n	aad2 <m_fnd_confs_handler_appkey+0x6e>
        {
            // Application Key local index
            m_lid_t app_key_lid;

            // Look for indicated Application Key
            status = m_tb_key_app_find(appkey_id, &app_key_lid);
    aab0:	0031      	movs	r1, r6
    aab2:	0038      	movs	r0, r7
    aab4:	f007 fea2 	bl	127fc <m_tb_key_app_find>

            if (status != M_ERR_NO_ERROR)
    aab8:	2800      	cmp	r0, #0
    aaba:	d122      	bne.n	ab02 <m_fnd_confs_handler_appkey+0x9e>
                status = M_ERR_NO_ERROR;
                break;
            }

            // Delete the Application Key
            status = m_tb_key_app_delete(app_key_lid, net_key_lid);
    aabc:	ab04      	add	r3, sp, #16
    aabe:	79d9      	ldrb	r1, [r3, #7]
    aac0:	7830      	ldrb	r0, [r6, #0]
    aac2:	f007 fd61 	bl	12588 <m_tb_key_app_delete>
    aac6:	1e05      	subs	r5, r0, #0

            if (status == M_ERR_NO_ERROR)
    aac8:	d11e      	bne.n	ab08 <m_fnd_confs_handler_appkey+0xa4>
            {
                // Inform the Model IO manager that an Application Key has been removed
                m_tb_mio_app_key_rem_ind(app_key_lid);
    aaca:	7830      	ldrb	r0, [r6, #0]
    aacc:	f009 f838 	bl	13b40 <m_tb_mio_app_key_rem_ind>
    aad0:	e017      	b.n	ab02 <m_fnd_confs_handler_appkey+0x9e>
        else
        {
            // Key is received MSB->LSB and must be swapped
            uint8_t key[M_KEY_LEN];

            co_bswap(&key[0], p_data + 3, M_KEY_LEN);
    aad2:	1ce1      	adds	r1, r4, #3
    aad4:	0030      	movs	r0, r6
    aad6:	f001 f85b 	bl	bb90 <co_bswap.constprop.7>

            if (opcode == M_FND_CONFS_OPCODE_APPKEY_ADD)
    aada:	9903      	ldr	r1, [sp, #12]
    aadc:	ab04      	add	r3, sp, #16
    aade:	79da      	ldrb	r2, [r3, #7]
    aae0:	4b0d      	ldr	r3, [pc, #52]	; (ab18 <m_fnd_confs_handler_appkey+0xb4>)
    aae2:	2900      	cmp	r1, #0
    aae4:	d105      	bne.n	aaf2 <m_fnd_confs_handler_appkey+0x8e>
            {
                // Inform the key manager about the request
                status = m_tb_key_app_add(appkey_id, &key[0], net_key_lid,
    aae6:	0031      	movs	r1, r6
    aae8:	0038      	movs	r0, r7
    aaea:	f007 fcc1 	bl	12470 <m_tb_key_app_add>
    aaee:	0005      	movs	r5, r0
    aaf0:	e004      	b.n	aafc <m_fnd_confs_handler_appkey+0x98>
                                          m_fnd_confs_cb_appkey_added);
            }
            else
            {
                // Inform the key manager about the request
                status = m_tb_key_app_update(appkey_id, &key[0], net_key_lid,
    aaf2:	0031      	movs	r1, r6
    aaf4:	0038      	movs	r0, r7
    aaf6:	f007 fde3 	bl	126c0 <m_tb_key_app_update>
    aafa:	0005      	movs	r5, r0
                                             m_fnd_confs_cb_appkey_added);
            }
        }
    } while (0);

    if ((status != M_ERR_NO_ERROR) || opcode_2b)
    aafc:	2d00      	cmp	r5, #0
    aafe:	d007      	beq.n	ab10 <m_fnd_confs_handler_appkey+0xac>
    ab00:	e002      	b.n	ab08 <m_fnd_confs_handler_appkey+0xa4>
    ab02:	9b02      	ldr	r3, [sp, #8]
    ab04:	2b00      	cmp	r3, #0
    ab06:	d003      	beq.n	ab10 <m_fnd_confs_handler_appkey+0xac>
    {
        // An error has been raised, directly send the status
        m_fnd_confs_send_appkey_status(status, netkey_appkey_id);
    ab08:	9901      	ldr	r1, [sp, #4]
    ab0a:	0028      	movs	r0, r5
    ab0c:	f7ff fe2c 	bl	a768 <m_fnd_confs_send_appkey_status>
    }
}
    ab10:	b00b      	add	sp, #44	; 0x2c
    ab12:	bdf0      	pop	{r4, r5, r6, r7, pc}
    ab14:	0002165c 	.word	0x0002165c
    ab18:	0000a9c9 	.word	0x0000a9c9

0000ab1c <m_fnd_confs_process>:
 *
 * @param[in] p_buf     Buffer to handle.
 ****************************************************************************************
 */
__STATIC void m_fnd_confs_process(void *p_param)
{
    ab1c:	b5f0      	push	{r4, r5, r6, r7, lr}
    // Get buffer to handle
    m_tb_buf_t *p_buf = (m_tb_buf_t *)co_list_pick(&p_m_fnd_confs_env->process_queue);
    // Get buffer environment
    m_lay_buf_env_t *p_env = (m_lay_buf_env_t *)(&p_buf->env[0]);
	m_printf(L_FND, "fnd process opcede[%x]", p_env->u5.opcode);
    ab1e:	4fb7      	ldr	r7, [pc, #732]	; (adfc <m_fnd_confs_process+0x2e0>)
    ab20:	2080      	movs	r0, #128	; 0x80
    ab22:	0039      	movs	r1, r7
 ****************************************************************************************
 */
__STATIC void m_fnd_confs_process(void *p_param)
{
    // Get buffer to handle
    m_tb_buf_t *p_buf = (m_tb_buf_t *)co_list_pick(&p_m_fnd_confs_env->process_queue);
    ab24:	4eb6      	ldr	r6, [pc, #728]	; (ae00 <m_fnd_confs_process+0x2e4>)
    // Get buffer environment
    m_lay_buf_env_t *p_env = (m_lay_buf_env_t *)(&p_buf->env[0]);
	m_printf(L_FND, "fnd process opcede[%x]", p_env->u5.opcode);
    ab26:	313e      	adds	r1, #62	; 0x3e
    ab28:	6833      	ldr	r3, [r6, #0]
 *
 * @param[in] p_buf     Buffer to handle.
 ****************************************************************************************
 */
__STATIC void m_fnd_confs_process(void *p_param)
{
    ab2a:	b093      	sub	sp, #76	; 0x4c
    ab2c:	681d      	ldr	r5, [r3, #0]
    // Get buffer to handle
    m_tb_buf_t *p_buf = (m_tb_buf_t *)co_list_pick(&p_m_fnd_confs_env->process_queue);
    // Get buffer environment
    m_lay_buf_env_t *p_env = (m_lay_buf_env_t *)(&p_buf->env[0]);
	m_printf(L_FND, "fnd process opcede[%x]", p_env->u5.opcode);
    ab2e:	0100      	lsls	r0, r0, #4
    ab30:	69aa      	ldr	r2, [r5, #24]
    ab32:	f7f9 ff5d 	bl	49f0 <m_printf>
    // Check if opcode is a 1-byte or a 2-byte opcode
    if (M_IS_1_OCT_OPCODE(p_env->u5.opcode))
    ab36:	2280      	movs	r2, #128	; 0x80
    ab38:	69a9      	ldr	r1, [r5, #24]
    ab3a:	20ff      	movs	r0, #255	; 0xff
    ab3c:	400a      	ands	r2, r1
    ab3e:	d16b      	bne.n	ac18 <m_fnd_confs_process+0xfc>
    {
        uint8_t opcode_1b = (uint8_t)p_env->u5.opcode;
        switch (opcode_1b)
    ab40:	4008      	ands	r0, r1
    ab42:	2801      	cmp	r0, #1
    ab44:	d903      	bls.n	ab4e <m_fnd_confs_process+0x32>
    ab46:	2803      	cmp	r0, #3
    ab48:	d007      	beq.n	ab5a <m_fnd_confs_process+0x3e>
    ab4a:	f000 ff19 	bl	b980 <m_fnd_confs_process+0xe64>
        {
            case (M_FND_CONFS_OPCODE_APPKEY_ADD)    :
            case (M_FND_CONFS_OPCODE_APPKEY_UPD)    : m_fnd_confs_handler_appkey(p_buf, opcode_1b, false);    break;
    ab4e:	b2c9      	uxtb	r1, r1
    ab50:	0028      	movs	r0, r5
    ab52:	f7ff ff87 	bl	aa64 <m_fnd_confs_handler_appkey>
    ab56:	f000 ff15 	bl	b984 <m_fnd_confs_process+0xe68>
 ****************************************************************************************
 */
__STATIC void m_fnd_confs_handler_model_pub_set(m_tb_buf_t *p_buf)
{
    // Get pointer to data
    uint8_t *p_data = M_TB_BUF_DATA(p_buf);
    ab5a:	0028      	movs	r0, r5
    ab5c:	88ab      	ldrh	r3, [r5, #4]
    ab5e:	3030      	adds	r0, #48	; 0x30
    ab60:	18c0      	adds	r0, r0, r3
 * @return The 16 bits value.
 ****************************************************************************************
 */
__INLINE_S__ uint16_t co_read16p(void const *ptr16)
{
    uint16_t value = ((uint8_t *)ptr16)[0] | ((uint8_t *)ptr16)[1] << 8;
    ab62:	7843      	ldrb	r3, [r0, #1]
    ab64:	7801      	ldrb	r1, [r0, #0]
    ab66:	021b      	lsls	r3, r3, #8
    ab68:	4319      	orrs	r1, r3
    ab6a:	7883      	ldrb	r3, [r0, #2]
    ab6c:	9104      	str	r1, [sp, #16]
    ab6e:	9305      	str	r3, [sp, #20]
    ab70:	78c3      	ldrb	r3, [r0, #3]
    ab72:	7907      	ldrb	r7, [r0, #4]
    ab74:	9306      	str	r3, [sp, #24]

    // Extract received parameters
    p_msg.element_addr = co_read16p(p_data);
    p_msg.publish_addr = co_read16p(p_data + 2);
    p_msg.appkey_id_cred_flag = co_read16p(p_data + 4);
    p_msg.publish_ttl = *(p_data + 6);
    ab76:	7983      	ldrb	r3, [r0, #6]
    ab78:	7944      	ldrb	r4, [r0, #5]
    ab7a:	9307      	str	r3, [sp, #28]
    p_msg.publish_period = *(p_data + 7);
    ab7c:	79c3      	ldrb	r3, [r0, #7]
    ab7e:	9308      	str	r3, [sp, #32]
    p_msg.publish_retx_params = *(p_data + 8);
    ab80:	7a03      	ldrb	r3, [r0, #8]
    ab82:	9309      	str	r3, [sp, #36]	; 0x24

    if (p_buf->data_len == M_FND_CONFS_MODEL_PUB_SET_LEN)
    ab84:	892b      	ldrh	r3, [r5, #8]
    ab86:	2b0b      	cmp	r3, #11
    ab88:	d105      	bne.n	ab96 <m_fnd_confs_process+0x7a>
    {
        p_msg.model_id = co_read16p(p_data + 9);
    ab8a:	7a86      	ldrb	r6, [r0, #10]
    ab8c:	7a43      	ldrb	r3, [r0, #9]
    ab8e:	0236      	lsls	r6, r6, #8
    ab90:	431e      	orrs	r6, r3
        p_msg.vendor = false;
    ab92:	0015      	movs	r5, r2
    ab94:	e004      	b.n	aba0 <m_fnd_confs_process+0x84>

    }
    else
    {
        p_msg.model_id = co_read32p(p_data + 9);
    ab96:	3009      	adds	r0, #9
    ab98:	f7ff fcbc 	bl	a514 <co_read32p>
        p_msg.vendor = true;
    ab9c:	2501      	movs	r5, #1
        p_msg.vendor = false;

    }
    else
    {
        p_msg.model_id = co_read32p(p_data + 9);
    ab9e:	0006      	movs	r6, r0

        // Application key local index
        m_lid_t app_key_lid;

        // Check that element address is well a local address
        if (!m_tb_mio_is_local_addr(p_msg.element_addr))
    aba0:	9804      	ldr	r0, [sp, #16]
    aba2:	f008 ff51 	bl	13a48 <m_tb_mio_is_local_addr>
    aba6:	2800      	cmp	r0, #0
    aba8:	d028      	beq.n	abfc <m_fnd_confs_process+0xe0>
            status = M_ERR_INVALID_ADDR;
            break;
        }

        // Look for model local index
        status = m_tb_mio_get_local_id(p_msg.element_addr, p_msg.model_id, p_msg.vendor, &model_lid);
    abaa:	231e      	movs	r3, #30
    abac:	aa06      	add	r2, sp, #24
    abae:	189b      	adds	r3, r3, r2
    abb0:	0031      	movs	r1, r6
    abb2:	002a      	movs	r2, r5
    abb4:	9804      	ldr	r0, [sp, #16]
    abb6:	f008 fb3f 	bl	13238 <m_tb_mio_get_local_id>

        if (status != M_ERR_NO_ERROR)
    abba:	2800      	cmp	r0, #0
    abbc:	d120      	bne.n	ac00 <m_fnd_confs_process+0xe4>
    abbe:	0224      	lsls	r4, r4, #8
    abc0:	433c      	orrs	r4, r7
        {
            break;
        }

        // Look for indicated application key
        status = m_tb_key_app_find(GETF(p_msg.appkey_id_cred_flag, M_FND_CONFS_APPKEY_ID),
    abc2:	0520      	lsls	r0, r4, #20
    abc4:	af0e      	add	r7, sp, #56	; 0x38
    abc6:	0d00      	lsrs	r0, r0, #20
    abc8:	0039      	movs	r1, r7
    abca:	f007 fe17 	bl	127fc <m_tb_key_app_find>
                                   &app_key_lid);

        if (status != M_ERR_NO_ERROR)
    abce:	2800      	cmp	r0, #0
    abd0:	d116      	bne.n	ac00 <m_fnd_confs_process+0xe4>
        {
            break;
        }

        // Set publication parameters
        status = m_tb_mio_set_publi_param(model_lid, p_msg.publish_addr, NULL,
    abd2:	9a06      	ldr	r2, [sp, #24]
    abd4:	783b      	ldrb	r3, [r7, #0]
    abd6:	0211      	lsls	r1, r2, #8
    abd8:	9a05      	ldr	r2, [sp, #20]
    abda:	04e4      	lsls	r4, r4, #19
    abdc:	4311      	orrs	r1, r2
    abde:	aa06      	add	r2, sp, #24
    abe0:	7f97      	ldrb	r7, [r2, #30]
    abe2:	9a09      	ldr	r2, [sp, #36]	; 0x24
    abe4:	0fe4      	lsrs	r4, r4, #31
    abe6:	9202      	str	r2, [sp, #8]
    abe8:	9a08      	ldr	r2, [sp, #32]
    abea:	9403      	str	r4, [sp, #12]
    abec:	9201      	str	r2, [sp, #4]
    abee:	9a07      	ldr	r2, [sp, #28]
    abf0:	9200      	str	r2, [sp, #0]
    abf2:	0002      	movs	r2, r0
    abf4:	0038      	movs	r0, r7
    abf6:	f008 fbb1 	bl	1335c <m_tb_mio_set_publi_param>
    abfa:	e001      	b.n	ac00 <m_fnd_confs_process+0xe4>
        m_lid_t app_key_lid;

        // Check that element address is well a local address
        if (!m_tb_mio_is_local_addr(p_msg.element_addr))
        {
            status = M_ERR_INVALID_ADDR;
    abfc:	20c0      	movs	r0, #192	; 0xc0
    abfe:	0040      	lsls	r0, r0, #1
                                          p_msg.publish_retx_params,
                                          GETB(p_msg.appkey_id_cred_flag, M_FND_CONFS_CREDENTIAL_FLAG));
    } while (0);

    // Send the status
    m_fnd_confs_send_model_pub_status(status, p_msg.element_addr, p_msg.model_id, p_msg.vendor, model_lid);
    ac00:	231e      	movs	r3, #30
    ac02:	aa06      	add	r2, sp, #24
    ac04:	189b      	adds	r3, r3, r2
    ac06:	781b      	ldrb	r3, [r3, #0]
    ac08:	0032      	movs	r2, r6
    ac0a:	9300      	str	r3, [sp, #0]
    ac0c:	9904      	ldr	r1, [sp, #16]
    ac0e:	002b      	movs	r3, r5
    ac10:	f7ff fd0c 	bl	a62c <m_fnd_confs_send_model_pub_status>
    ac14:	f000 feb6 	bl	b984 <m_fnd_confs_process+0xe68>
            default                                 : m_fnd_confs_process_next();                             break;
        }
    }
    else
    {
        uint8_t opcode_2b = (uint8_t)(p_env->u5.opcode >> 8);
    ac18:	0a09      	lsrs	r1, r1, #8
    ac1a:	b2cb      	uxtb	r3, r1
    ac1c:	9304      	str	r3, [sp, #16]
        switch (opcode_2b)
    ac1e:	4008      	ands	r0, r1
    ac20:	284d      	cmp	r0, #77	; 0x4d
    ac22:	d901      	bls.n	ac28 <m_fnd_confs_process+0x10c>
    ac24:	f000 feac 	bl	b980 <m_fnd_confs_process+0xe64>
    ac28:	f013 f89e 	bl	1dd68 <__gnu_thumb1_case_uhi>
    ac2c:	020a0203 	.word	0x020a0203
    ac30:	06aa06aa 	.word	0x06aa06aa
    ac34:	06aa06aa 	.word	0x06aa06aa
    ac38:	06aa06aa 	.word	0x06aa06aa
    ac3c:	03e0053b 	.word	0x03e0053b
    ac40:	06aa03e0 	.word	0x06aa03e0
    ac44:	04010401 	.word	0x04010401
    ac48:	042606aa 	.word	0x042606aa
    ac4c:	06aa0426 	.word	0x06aa0426
    ac50:	04470447 	.word	0x04470447
    ac54:	04ae06aa 	.word	0x04ae06aa
    ac58:	06aa04ae 	.word	0x06aa04ae
    ac5c:	06aa004e 	.word	0x06aa004e
    ac60:	00880075 	.word	0x00880075
    ac64:	015d0088 	.word	0x015d0088
    ac68:	06aa0088 	.word	0x06aa0088
    ac6c:	01030103 	.word	0x01030103
    ac70:	04680103 	.word	0x04680103
    ac74:	06aa0468 	.word	0x06aa0468
    ac78:	04880488 	.word	0x04880488
    ac7c:	019406aa 	.word	0x019406aa
    ac80:	019406aa 	.word	0x019406aa
    ac84:	06aa06aa 	.word	0x06aa06aa
    ac88:	06aa06aa 	.word	0x06aa06aa
    ac8c:	06aa06aa 	.word	0x06aa06aa
    ac90:	06aa06aa 	.word	0x06aa06aa
    ac94:	06aa06aa 	.word	0x06aa06aa
    ac98:	06aa06aa 	.word	0x06aa06aa
    ac9c:	05c905c9 	.word	0x05c905c9
    aca0:	063e063e 	.word	0x063e063e
    aca4:	02cf06aa 	.word	0x02cf06aa
    aca8:	02cf06aa 	.word	0x02cf06aa
    acac:	02470247 	.word	0x02470247
    acb0:	06aa02b2 	.word	0x06aa02b2
    acb4:	024706aa 	.word	0x024706aa
    acb8:	04f204f2 	.word	0x04f204f2
    acbc:	052c06aa 	.word	0x052c06aa
    acc0:	037406aa 	.word	0x037406aa
    acc4:	037406aa 	.word	0x037406aa
 ****************************************************************************************
 */
__STATIC void m_fnd_confs_handler_model_pub_get(m_tb_buf_t *p_buf)
{
    // Get message content
    m_fnd_confs_model_pub_get_t *p_msg = (m_fnd_confs_model_pub_get_t *)M_TB_BUF_DATA(p_buf);
    acc8:	002c      	movs	r4, r5
    acca:	88ab      	ldrh	r3, [r5, #4]
    accc:	3430      	adds	r4, #48	; 0x30
    acce:	18e4      	adds	r4, r4, r3
    // SIG or vendor model identifier
    bool vendor;
    // Status
    uint16_t status;

    if (p_buf->data_len == sizeof(m_fnd_confs_model_pub_get_t))
    acd0:	892b      	ldrh	r3, [r5, #8]
    acd2:	2b04      	cmp	r3, #4
    acd4:	d102      	bne.n	acdc <m_fnd_confs_process+0x1c0>
    {
        model_id = (uint32_t)p_msg->model_id;
    acd6:	8865      	ldrh	r5, [r4, #2]
        vendor = false;
    acd8:	2600      	movs	r6, #0
    acda:	e004      	b.n	ace6 <m_fnd_confs_process+0x1ca>
    }
    else
    {
        model_id = co_read32p(&p_msg->model_id);
    acdc:	1ca0      	adds	r0, r4, #2
    acde:	f7ff fc19 	bl	a514 <co_read32p>
        vendor = true;
    ace2:	2601      	movs	r6, #1
        model_id = (uint32_t)p_msg->model_id;
        vendor = false;
    }
    else
    {
        model_id = co_read32p(&p_msg->model_id);
    ace4:	0005      	movs	r5, r0
        vendor = true;
    }

    // Check that element address is well a local address
    if (!m_tb_mio_is_local_addr(p_msg->element_addr))
    ace6:	8820      	ldrh	r0, [r4, #0]
    ace8:	f008 feae 	bl	13a48 <m_tb_mio_is_local_addr>
    acec:	af0e      	add	r7, sp, #56	; 0x38
    acee:	2800      	cmp	r0, #0
    acf0:	d006      	beq.n	ad00 <m_fnd_confs_process+0x1e4>
        status = M_ERR_INVALID_ADDR;
    }
    else
    {
        // Look for model local index
        status = m_tb_mio_get_local_id(p_msg->element_addr, model_id, vendor, &model_lid);
    acf2:	8820      	ldrh	r0, [r4, #0]
    acf4:	003b      	movs	r3, r7
    acf6:	0032      	movs	r2, r6
    acf8:	0029      	movs	r1, r5
    acfa:	f008 fa9d 	bl	13238 <m_tb_mio_get_local_id>
    acfe:	e001      	b.n	ad04 <m_fnd_confs_process+0x1e8>
    }

    // Check that element address is well a local address
    if (!m_tb_mio_is_local_addr(p_msg->element_addr))
    {
        status = M_ERR_INVALID_ADDR;
    ad00:	20c0      	movs	r0, #192	; 0xc0
    ad02:	0040      	lsls	r0, r0, #1
        // Look for model local index
        status = m_tb_mio_get_local_id(p_msg->element_addr, model_id, vendor, &model_lid);
    }

    // Send the status
    m_fnd_confs_send_model_pub_status(status, p_msg->element_addr, model_id, vendor, model_lid);
    ad04:	783b      	ldrb	r3, [r7, #0]
    ad06:	8821      	ldrh	r1, [r4, #0]
    ad08:	002a      	movs	r2, r5
    ad0a:	9300      	str	r3, [sp, #0]
    ad0c:	0033      	movs	r3, r6
    ad0e:	f7ff fc8d 	bl	a62c <m_fnd_confs_send_model_pub_status>
    ad12:	f000 fe37 	bl	b984 <m_fnd_confs_process+0xe68>
    // Get pointer to data
    uint8_t *p_data = M_TB_BUF_DATA(p_buf);
    // Label UUID is received MSB->LSB and must be provided LSB->MSB
    uint8_t swap_uuid[M_LABEL_UUID_LEN];

    co_bswap(&swap_uuid[0], p_data + 2, M_LABEL_UUID_LEN);
    ad16:	88ab      	ldrh	r3, [r5, #4]
    ad18:	a80e      	add	r0, sp, #56	; 0x38
    ad1a:	18ed      	adds	r5, r5, r3
    ad1c:	3532      	adds	r5, #50	; 0x32
    ad1e:	0029      	movs	r1, r5
    ad20:	f000 ff36 	bl	bb90 <co_bswap.constprop.7>
    memcpy(p_data + 2, &swap_uuid[0], M_LABEL_UUID_LEN);
    ad24:	a90e      	add	r1, sp, #56	; 0x38
    ad26:	2210      	movs	r2, #16
    ad28:	0028      	movs	r0, r5
    ad2a:	f00a fe51 	bl	159d0 <memcpy>

    // Request generation of virtual address from the received label UUID value
    m_tb_sec_cmac_start(M_TB_SEC_TOKEN_FOUND, m_fnd_confs_cb_sec_cmac_ready,
    ad2e:	4a35      	ldr	r2, [pc, #212]	; (ae04 <m_fnd_confs_process+0x2e8>)
    ad30:	4935      	ldr	r1, [pc, #212]	; (ae08 <m_fnd_confs_process+0x2ec>)
    ad32:	2000      	movs	r0, #0
    ad34:	f009 f935 	bl	13fa2 <m_tb_sec_cmac_start>
    ad38:	f000 fe24 	bl	b984 <m_fnd_confs_process+0xe68>
 * @param[in] opcode    Operation code.
 ****************************************************************************************
 */
__STATIC void m_fnd_confs_handler_model_subs(m_tb_buf_t *p_buf, uint16_t opcode)
{
	M_PRINTF(L_FND, "");
    ad3c:	4b33      	ldr	r3, [pc, #204]	; (ae0c <m_fnd_confs_process+0x2f0>)
    ad3e:	681b      	ldr	r3, [r3, #0]
    ad40:	051b      	lsls	r3, r3, #20
    ad42:	d514      	bpl.n	ad6e <m_fnd_confs_process+0x252>
    ad44:	4c32      	ldr	r4, [pc, #200]	; (ae10 <m_fnd_confs_process+0x2f4>)
    ad46:	003b      	movs	r3, r7
    ad48:	0022      	movs	r2, r4
    ad4a:	0020      	movs	r0, r4
    ad4c:	3355      	adds	r3, #85	; 0x55
    ad4e:	0021      	movs	r1, r4
    ad50:	3253      	adds	r2, #83	; 0x53
    ad52:	9300      	str	r3, [sp, #0]
    ad54:	3061      	adds	r0, #97	; 0x61
    ad56:	4b2f      	ldr	r3, [pc, #188]	; (ae14 <m_fnd_confs_process+0x2f8>)
    ad58:	f7f9 fe28 	bl	49ac <m_print>
    ad5c:	0038      	movs	r0, r7
    ad5e:	3074      	adds	r0, #116	; 0x74
    ad60:	f7f9 fe24 	bl	49ac <m_print>
    ad64:	0038      	movs	r0, r7
    ad66:	1da1      	adds	r1, r4, #6
    ad68:	3022      	adds	r0, #34	; 0x22
    ad6a:	f7f9 fe1f 	bl	49ac <m_print>
    // Get pointer to data
    uint8_t *p_data = M_TB_BUF_DATA(p_buf);
    ad6e:	0028      	movs	r0, r5
    ad70:	88ab      	ldrh	r3, [r5, #4]
    ad72:	3030      	adds	r0, #48	; 0x30
    ad74:	18c0      	adds	r0, r0, r3
    ad76:	7843      	ldrb	r3, [r0, #1]
    ad78:	7802      	ldrb	r2, [r0, #0]
    ad7a:	021b      	lsls	r3, r3, #8
    ad7c:	78c4      	ldrb	r4, [r0, #3]
    ad7e:	431a      	orrs	r2, r3
    ad80:	7883      	ldrb	r3, [r0, #2]
    ad82:	9205      	str	r2, [sp, #20]
    ad84:	0224      	lsls	r4, r4, #8
    ad86:	431c      	orrs	r4, r3
    // SIG or vendor model identifier
    bool vendor;
    // Status
    uint16_t status;

    if (p_buf->data_len != M_FND_CONFS_MODEL_SUBS_LEN)
    ad88:	892b      	ldrh	r3, [r5, #8]
    ad8a:	2b06      	cmp	r3, #6
    ad8c:	d005      	beq.n	ad9a <m_fnd_confs_process+0x27e>
    {
        model_id = co_read32p(p_data + 4);
    ad8e:	3004      	adds	r0, #4
    ad90:	f7ff fbc0 	bl	a514 <co_read32p>
        vendor = true;
    ad94:	2701      	movs	r7, #1
    // Status
    uint16_t status;

    if (p_buf->data_len != M_FND_CONFS_MODEL_SUBS_LEN)
    {
        model_id = co_read32p(p_data + 4);
    ad96:	9006      	str	r0, [sp, #24]
    ad98:	e005      	b.n	ada6 <m_fnd_confs_process+0x28a>
        vendor = true;
    }
    else
    {
        model_id = (uint32_t)co_read16p(p_data + 4);
        vendor = false;
    ad9a:	2700      	movs	r7, #0
        model_id = co_read32p(p_data + 4);
        vendor = true;
    }
    else
    {
        model_id = (uint32_t)co_read16p(p_data + 4);
    ad9c:	7943      	ldrb	r3, [r0, #5]
    ad9e:	7902      	ldrb	r2, [r0, #4]
    ada0:	021b      	lsls	r3, r3, #8
    ada2:	431a      	orrs	r2, r3
    ada4:	9206      	str	r2, [sp, #24]
    {
        // Model local index
        m_lid_t model_lid;

        // Check that element address is well a local address
        if (!m_tb_mio_is_local_addr(element_addr))
    ada6:	9805      	ldr	r0, [sp, #20]
    ada8:	f008 fe4e 	bl	13a48 <m_tb_mio_is_local_addr>
    adac:	2800      	cmp	r0, #0
    adae:	d035      	beq.n	ae1c <m_fnd_confs_process+0x300>
            status = M_ERR_INVALID_ADDR;
            break;
        }

        // Look for model local index
        status = m_tb_mio_get_local_id(element_addr, model_id, vendor, &model_lid);
    adb0:	ae0e      	add	r6, sp, #56	; 0x38
    adb2:	0033      	movs	r3, r6
    adb4:	003a      	movs	r2, r7
    adb6:	9906      	ldr	r1, [sp, #24]
    adb8:	9805      	ldr	r0, [sp, #20]
    adba:	f008 fa3d 	bl	13238 <m_tb_mio_get_local_id>
    adbe:	1e05      	subs	r5, r0, #0

        if (status != M_ERR_NO_ERROR)
    adc0:	d12e      	bne.n	ae20 <m_fnd_confs_process+0x304>
            break;
        }

        // Check address type, address shall not be an unassigned address, unicast address, all-nodes
        // address or virtual address -> should be a group address which is not the all-nodes address.
        if (!M_IS_GROUP_ADDR(addr) || (addr == M_ALL_NODES_ADDR))
    adc2:	0ba3      	lsrs	r3, r4, #14
    adc4:	2b03      	cmp	r3, #3
    adc6:	d129      	bne.n	ae1c <m_fnd_confs_process+0x300>
    adc8:	4b13      	ldr	r3, [pc, #76]	; (ae18 <m_fnd_confs_process+0x2fc>)
    adca:	429c      	cmp	r4, r3
    adcc:	d026      	beq.n	ae1c <m_fnd_confs_process+0x300>
        {
            status = M_ERR_INVALID_ADDR;
            break;
        }

        switch (opcode)
    adce:	9b04      	ldr	r3, [sp, #16]
    add0:	2b1c      	cmp	r3, #28
    add2:	d004      	beq.n	adde <m_fnd_confs_process+0x2c2>
    add4:	2b1e      	cmp	r3, #30
    add6:	d007      	beq.n	ade8 <m_fnd_confs_process+0x2cc>
    add8:	2b1b      	cmp	r3, #27
    adda:	d121      	bne.n	ae20 <m_fnd_confs_process+0x304>
    addc:	e007      	b.n	adee <m_fnd_confs_process+0x2d2>
            } break;

            case (M_FND_CONFS_OPCODE_MODEL_SUBS_DEL):
            {
                // Delete address from the subscription list
                m_tb_mio_delete_subscription(model_lid, addr);
    adde:	7830      	ldrb	r0, [r6, #0]
    ade0:	0021      	movs	r1, r4
    ade2:	f008 fc2b 	bl	1363c <m_tb_mio_delete_subscription>
    ade6:	e01b      	b.n	ae20 <m_fnd_confs_process+0x304>
            } break;

            case (M_FND_CONFS_OPCODE_MODEL_SUBS_OVERWRITE):
            {
                // Delete content of the subscription list
                m_tb_mio_delete_all_subscription(model_lid);
    ade8:	7830      	ldrb	r0, [r6, #0]
    adea:	f008 fc9f 	bl	1372c <m_tb_mio_delete_all_subscription>

                // Add address to the subscription list
                status = m_tb_mio_add_subscription(model_lid, addr);
    adee:	7830      	ldrb	r0, [r6, #0]
    adf0:	0021      	movs	r1, r4
    adf2:	f008 fb5d 	bl	134b0 <m_tb_mio_add_subscription>
    adf6:	0005      	movs	r5, r0
    adf8:	e012      	b.n	ae20 <m_fnd_confs_process+0x304>
    adfa:	46c0      	nop			; (mov r8, r8)
    adfc:	0002165c 	.word	0x0002165c
    ae00:	100126a0 	.word	0x100126a0
    ae04:	0000a829 	.word	0x0000a829
    ae08:	0000a7f9 	.word	0x0000a7f9
    ae0c:	10010514 	.word	0x10010514
    ae10:	000215dc 	.word	0x000215dc
    ae14:	00000709 	.word	0x00000709
    ae18:	0000ffff 	.word	0x0000ffff
        m_lid_t model_lid;

        // Check that element address is well a local address
        if (!m_tb_mio_is_local_addr(element_addr))
        {
            status = M_ERR_INVALID_ADDR;
    ae1c:	25c0      	movs	r5, #192	; 0xc0
    ae1e:	006d      	lsls	r5, r5, #1
            } break;
        }
    } while (0);

    // Send status
    m_fnd_confs_send_model_subs_status(status, element_addr, model_id, vendor, addr);
    ae20:	9400      	str	r4, [sp, #0]
    ae22:	003b      	movs	r3, r7
    ae24:	9a06      	ldr	r2, [sp, #24]
    ae26:	9905      	ldr	r1, [sp, #20]
    ae28:	0028      	movs	r0, r5
    ae2a:	f7ff fbc6 	bl	a5ba <m_fnd_confs_send_model_subs_status>
    ae2e:	f000 fda9 	bl	b984 <m_fnd_confs_process+0xe68>
 ****************************************************************************************
 */
__STATIC void m_fnd_confs_handler_model_subs_vaddr(m_tb_buf_t *p_buf, uint16_t opcode)
{
    // Get pointer to data
    uint8_t *p_data = M_TB_BUF_DATA(p_buf);
    ae32:	002c      	movs	r4, r5
    ae34:	88ab      	ldrh	r3, [r5, #4]
    ae36:	3430      	adds	r4, #48	; 0x30
    ae38:	18e4      	adds	r4, r4, r3
    ae3a:	7863      	ldrb	r3, [r4, #1]
    ae3c:	7822      	ldrb	r2, [r4, #0]
    ae3e:	021b      	lsls	r3, r3, #8
    ae40:	431a      	orrs	r2, r3
    ae42:	9205      	str	r2, [sp, #20]
    // Model identifier
    uint32_t model_id;
    // SIG or vendor model identifier
    bool vendor;
    // Address
    uint16_t addr = M_UNASSIGNED_ADDR;
    ae44:	221e      	movs	r2, #30
    ae46:	2300      	movs	r3, #0
    ae48:	a906      	add	r1, sp, #24
    ae4a:	1852      	adds	r2, r2, r1
    ae4c:	8013      	strh	r3, [r2, #0]
    // Status
    uint16_t status;

    // Read model identifier with the appropriate format
    if (p_buf->data_len != M_FND_CONFS_MODEL_SUBS_VADDR_LEN)
    ae4e:	892a      	ldrh	r2, [r5, #8]
    ae50:	2a14      	cmp	r2, #20
    ae52:	d006      	beq.n	ae62 <m_fnd_confs_process+0x346>
    {
        model_id = co_read32p(p_data + 18);
    ae54:	0020      	movs	r0, r4
    ae56:	3012      	adds	r0, #18
    ae58:	f7ff fb5c 	bl	a514 <co_read32p>
        vendor = true;
    ae5c:	2501      	movs	r5, #1
    uint16_t status;

    // Read model identifier with the appropriate format
    if (p_buf->data_len != M_FND_CONFS_MODEL_SUBS_VADDR_LEN)
    {
        model_id = co_read32p(p_data + 18);
    ae5e:	0007      	movs	r7, r0
    ae60:	e004      	b.n	ae6c <m_fnd_confs_process+0x350>
        vendor = true;
    }
    else
    {
        model_id = (uint32_t)co_read16p(p_data + 18);
        vendor = false;
    ae62:	001d      	movs	r5, r3
        model_id = co_read32p(p_data + 18);
        vendor = true;
    }
    else
    {
        model_id = (uint32_t)co_read16p(p_data + 18);
    ae64:	7ce7      	ldrb	r7, [r4, #19]
    ae66:	7ca2      	ldrb	r2, [r4, #18]
    ae68:	023f      	lsls	r7, r7, #8
    ae6a:	4317      	orrs	r7, r2
        m_lid_t model_lid;
        // Label UUID is received MSB->LSB and must be provided LSB->MSB
        uint8_t swap_uuid[M_LABEL_UUID_LEN];

        // Check that element address is well a local address
        if (!m_tb_mio_is_local_addr(element_addr))
    ae6c:	9805      	ldr	r0, [sp, #20]
    ae6e:	f008 fdeb 	bl	13a48 <m_tb_mio_is_local_addr>
    ae72:	2800      	cmp	r0, #0
    ae74:	d028      	beq.n	aec8 <m_fnd_confs_process+0x3ac>
            status = M_ERR_INVALID_ADDR;
            break;
        }

        // Look for model local index and keep in the environment
        status = m_tb_mio_get_local_id(element_addr, model_id, vendor, &model_lid);
    ae76:	ab0d      	add	r3, sp, #52	; 0x34
    ae78:	002a      	movs	r2, r5
    ae7a:	0039      	movs	r1, r7
    ae7c:	9805      	ldr	r0, [sp, #20]
    ae7e:	f008 f9db 	bl	13238 <m_tb_mio_get_local_id>
    ae82:	1e06      	subs	r6, r0, #0

        if (status != M_ERR_NO_ERROR)
    ae84:	d122      	bne.n	aecc <m_fnd_confs_process+0x3b0>
        {
            break;
        }

        // Label UUID is always right after the element address whose length is 2 bytes
        co_bswap(&swap_uuid[0], p_data + 2, M_LABEL_UUID_LEN);
    ae86:	3402      	adds	r4, #2
    ae88:	0021      	movs	r1, r4
    ae8a:	a80e      	add	r0, sp, #56	; 0x38
    ae8c:	f000 fe80 	bl	bb90 <co_bswap.constprop.7>
        memcpy(p_data + 2, &swap_uuid[0], M_LABEL_UUID_LEN);
    ae90:	2210      	movs	r2, #16
    ae92:	a90e      	add	r1, sp, #56	; 0x38
    ae94:	0020      	movs	r0, r4
    ae96:	f00a fd9b 	bl	159d0 <memcpy>

        if (opcode == M_FND_CONFS_OPCODE_MODEL_SUBS_VADDR_DEL)
    ae9a:	9b04      	ldr	r3, [sp, #16]
    ae9c:	2b21      	cmp	r3, #33	; 0x21
    ae9e:	d107      	bne.n	aeb0 <m_fnd_confs_process+0x394>
        {
            // Delete the virtual address from the subscription list
            m_tb_mio_delete_subscription_virt(model_lid, p_data + 2, &addr);
    aea0:	221e      	movs	r2, #30
    aea2:	ab06      	add	r3, sp, #24
    aea4:	7f18      	ldrb	r0, [r3, #28]
    aea6:	18d2      	adds	r2, r2, r3
    aea8:	0021      	movs	r1, r4
    aeaa:	f008 fbef 	bl	1368c <m_tb_mio_delete_subscription_virt>
    aeae:	e00d      	b.n	aecc <m_fnd_confs_process+0x3b0>
        }
        else
        {
            // Store opcode in the environment
            p_m_fnd_confs_env->opcode = opcode;
    aeb0:	466a      	mov	r2, sp
    aeb2:	4bcf      	ldr	r3, [pc, #828]	; (b1f0 <m_fnd_confs_process+0x6d4>)
    aeb4:	7c12      	ldrb	r2, [r2, #16]
    aeb6:	681b      	ldr	r3, [r3, #0]

            // Register for use of AES-CMAC block in order to generate a virtual address
            m_tb_sec_cmac_start(M_TB_SEC_TOKEN_FOUND, m_fnd_confs_cb_sec_cmac_ready,
    aeb8:	49ce      	ldr	r1, [pc, #824]	; (b1f4 <m_fnd_confs_process+0x6d8>)
            m_tb_mio_delete_subscription_virt(model_lid, p_data + 2, &addr);
        }
        else
        {
            // Store opcode in the environment
            p_m_fnd_confs_env->opcode = opcode;
    aeba:	761a      	strb	r2, [r3, #24]

            // Register for use of AES-CMAC block in order to generate a virtual address
            m_tb_sec_cmac_start(M_TB_SEC_TOKEN_FOUND, m_fnd_confs_cb_sec_cmac_ready,
    aebc:	0030      	movs	r0, r6
    aebe:	4ace      	ldr	r2, [pc, #824]	; (b1f8 <m_fnd_confs_process+0x6dc>)
    aec0:	f009 f86f 	bl	13fa2 <m_tb_sec_cmac_start>
    aec4:	f000 fd5e 	bl	b984 <m_fnd_confs_process+0xe68>
        uint8_t swap_uuid[M_LABEL_UUID_LEN];

        // Check that element address is well a local address
        if (!m_tb_mio_is_local_addr(element_addr))
        {
            status = M_ERR_INVALID_ADDR;
    aec8:	26c0      	movs	r6, #192	; 0xc0
    aeca:	0076      	lsls	r6, r6, #1
    } while (0);

    if ((status != M_ERR_NO_ERROR) || (opcode == M_FND_CONFS_OPCODE_MODEL_SUBS_VADDR_DEL))
    {
        // An error has been raised, send status now
        m_fnd_confs_send_model_subs_status(status, element_addr, model_id, vendor, addr);
    aecc:	231e      	movs	r3, #30
    aece:	aa06      	add	r2, sp, #24
    aed0:	189b      	adds	r3, r3, r2
    aed2:	881b      	ldrh	r3, [r3, #0]
    aed4:	003a      	movs	r2, r7
    aed6:	9300      	str	r3, [sp, #0]
    aed8:	9905      	ldr	r1, [sp, #20]
    aeda:	002b      	movs	r3, r5
    aedc:	0030      	movs	r0, r6
    aede:	f7ff fb6c 	bl	a5ba <m_fnd_confs_send_model_subs_status>
    aee2:	f000 fd4f 	bl	b984 <m_fnd_confs_process+0xe68>
 ****************************************************************************************
 */
__STATIC void m_fnd_confs_handler_model_subs_del_all(m_tb_buf_t *p_buf)
{
    // Get pointer to data
    uint8_t *p_data = M_TB_BUF_DATA(p_buf);
    aee6:	0028      	movs	r0, r5
    aee8:	88ab      	ldrh	r3, [r5, #4]
    aeea:	3030      	adds	r0, #48	; 0x30
    aeec:	18c0      	adds	r0, r0, r3
    aeee:	7843      	ldrb	r3, [r0, #1]
    aef0:	7802      	ldrb	r2, [r0, #0]
    aef2:	021b      	lsls	r3, r3, #8
    aef4:	431a      	orrs	r2, r3
    // SIG or vendor model identifier
    bool vendor;
    // Status
    uint16_t status;

    if (p_buf->data_len != M_FND_CONFS_MODEL_SUBS_DEL_ALL_LEN)
    aef6:	892b      	ldrh	r3, [r5, #8]
    aef8:	0017      	movs	r7, r2
    aefa:	2b04      	cmp	r3, #4
    aefc:	d005      	beq.n	af0a <m_fnd_confs_process+0x3ee>
    {
        model_id = co_read32p(p_data + 2);
    aefe:	3002      	adds	r0, #2
    af00:	f7ff fb08 	bl	a514 <co_read32p>
        vendor = true;
    af04:	2601      	movs	r6, #1
    // Status
    uint16_t status;

    if (p_buf->data_len != M_FND_CONFS_MODEL_SUBS_DEL_ALL_LEN)
    {
        model_id = co_read32p(p_data + 2);
    af06:	0004      	movs	r4, r0
    af08:	e004      	b.n	af14 <m_fnd_confs_process+0x3f8>
        vendor = true;
    }
    else
    {
        model_id = (uint32_t)co_read16p(p_data + 2);
        vendor = false;
    af0a:	2600      	movs	r6, #0
        model_id = co_read32p(p_data + 2);
        vendor = true;
    }
    else
    {
        model_id = (uint32_t)co_read16p(p_data + 2);
    af0c:	78c4      	ldrb	r4, [r0, #3]
    af0e:	7883      	ldrb	r3, [r0, #2]
    af10:	0224      	lsls	r4, r4, #8
    af12:	431c      	orrs	r4, r3
    {
        // Model local index
        m_lid_t model_lid;

        // Check that element address is well a local address
        if (!m_tb_mio_is_local_addr(element_addr))
    af14:	0038      	movs	r0, r7
    af16:	f008 fd97 	bl	13a48 <m_tb_mio_is_local_addr>
    af1a:	2800      	cmp	r0, #0
    af1c:	d00e      	beq.n	af3c <m_fnd_confs_process+0x420>
            status = M_ERR_INVALID_ADDR;
            break;
        }

        // Look for model local index
        status = m_tb_mio_get_local_id(element_addr, model_id, vendor, &model_lid);
    af1e:	ab0e      	add	r3, sp, #56	; 0x38
    af20:	0032      	movs	r2, r6
    af22:	0021      	movs	r1, r4
    af24:	0038      	movs	r0, r7
    af26:	f008 f987 	bl	13238 <m_tb_mio_get_local_id>
    af2a:	1e05      	subs	r5, r0, #0

        if (status != M_ERR_NO_ERROR)
    af2c:	d108      	bne.n	af40 <m_fnd_confs_process+0x424>
        {
            break;
        }

        // Delete content of the subscription list
        m_tb_mio_delete_all_subscription(model_lid);
    af2e:	2220      	movs	r2, #32
    af30:	ab06      	add	r3, sp, #24
    af32:	189b      	adds	r3, r3, r2
    af34:	7818      	ldrb	r0, [r3, #0]
    af36:	f008 fbf9 	bl	1372c <m_tb_mio_delete_all_subscription>
    af3a:	e001      	b.n	af40 <m_fnd_confs_process+0x424>
        m_lid_t model_lid;

        // Check that element address is well a local address
        if (!m_tb_mio_is_local_addr(element_addr))
        {
            status = M_ERR_INVALID_ADDR;
    af3c:	25c0      	movs	r5, #192	; 0xc0
    af3e:	006d      	lsls	r5, r5, #1
        // Delete content of the subscription list
        m_tb_mio_delete_all_subscription(model_lid);
    } while (0);

    // Send status
    m_fnd_confs_send_model_subs_status(status, element_addr, model_id, vendor,
    af40:	2300      	movs	r3, #0
    af42:	0022      	movs	r2, r4
    af44:	9300      	str	r3, [sp, #0]
    af46:	0039      	movs	r1, r7
    af48:	0033      	movs	r3, r6
    af4a:	0028      	movs	r0, r5
    af4c:	f7ff fb35 	bl	a5ba <m_fnd_confs_send_model_subs_status>
    af50:	f000 fd18 	bl	b984 <m_fnd_confs_process+0xe68>
 ****************************************************************************************
 */
__STATIC void m_fnd_confs_handler_model_subs_get(m_tb_buf_t *p_buf, uint16_t opcode)
{
    // Get pointer to data
    uint8_t *p_data = M_TB_BUF_DATA(p_buf);
    af54:	0028      	movs	r0, r5
    af56:	88ab      	ldrh	r3, [r5, #4]
    af58:	3030      	adds	r0, #48	; 0x30
    af5a:	18c0      	adds	r0, r0, r3
    af5c:	7843      	ldrb	r3, [r0, #1]
    af5e:	7802      	ldrb	r2, [r0, #0]
    af60:	021b      	lsls	r3, r3, #8
    af62:	4313      	orrs	r3, r2
    af64:	b21b      	sxth	r3, r3
    af66:	9306      	str	r3, [sp, #24]
    af68:	466b      	mov	r3, sp
    // Model identifier
    uint32_t model_id;
    // SIG or vendor model identifier
    bool vendor;
    // Model local index
    m_lid_t model_lid = M_INVALID_LID;
    af6a:	241e      	movs	r4, #30
    af6c:	8b1b      	ldrh	r3, [r3, #24]
    af6e:	9304      	str	r3, [sp, #16]
    af70:	ab06      	add	r3, sp, #24
    af72:	18e4      	adds	r4, r4, r3
    af74:	23ff      	movs	r3, #255	; 0xff
    af76:	7023      	strb	r3, [r4, #0]
    // Status
    uint16_t status;

    if (p_buf->data_len != M_FND_CONFS_MODEL_SUBS_GET_LEN)
    af78:	892b      	ldrh	r3, [r5, #8]
    af7a:	2b04      	cmp	r3, #4
    af7c:	d005      	beq.n	af8a <m_fnd_confs_process+0x46e>
    {
        model_id = co_read32p(p_data + 2);
    af7e:	3002      	adds	r0, #2
    af80:	f7ff fac8 	bl	a514 <co_read32p>
        vendor = true;
    af84:	2601      	movs	r6, #1
    // Status
    uint16_t status;

    if (p_buf->data_len != M_FND_CONFS_MODEL_SUBS_GET_LEN)
    {
        model_id = co_read32p(p_data + 2);
    af86:	0005      	movs	r5, r0
    af88:	e004      	b.n	af94 <m_fnd_confs_process+0x478>
        vendor = true;
    }
    else
    {
        model_id = (uint32_t)co_read16p(p_data + 2);
        vendor = false;
    af8a:	2600      	movs	r6, #0
        model_id = co_read32p(p_data + 2);
        vendor = true;
    }
    else
    {
        model_id = (uint32_t)co_read16p(p_data + 2);
    af8c:	78c5      	ldrb	r5, [r0, #3]
    af8e:	7883      	ldrb	r3, [r0, #2]
    af90:	022d      	lsls	r5, r5, #8
    af92:	431d      	orrs	r5, r3
        vendor = false;
    }

    // Check that element address is well a local address
    if (!m_tb_mio_is_local_addr(element_addr))
    af94:	9804      	ldr	r0, [sp, #16]
    af96:	f008 fd57 	bl	13a48 <m_tb_mio_is_local_addr>
    af9a:	2800      	cmp	r0, #0
    af9c:	d007      	beq.n	afae <m_fnd_confs_process+0x492>
        status = M_ERR_INVALID_ADDR;
    }
    else
    {
        // Look for model local index
        status = m_tb_mio_get_local_id(element_addr, model_id, vendor, &model_lid);
    af9e:	0023      	movs	r3, r4
    afa0:	0032      	movs	r2, r6
    afa2:	0029      	movs	r1, r5
    afa4:	9804      	ldr	r0, [sp, #16]
    afa6:	f008 f947 	bl	13238 <m_tb_mio_get_local_id>
    afaa:	9005      	str	r0, [sp, #20]
    afac:	e002      	b.n	afb4 <m_fnd_confs_process+0x498>
    }

    // Check that element address is well a local address
    if (!m_tb_mio_is_local_addr(element_addr))
    {
        status = M_ERR_INVALID_ADDR;
    afae:	23c0      	movs	r3, #192	; 0xc0
    afb0:	005b      	lsls	r3, r3, #1
    afb2:	9305      	str	r3, [sp, #20]
    // Pointer to the buffer that will contain the message
    m_tb_buf_t *p_buf_status;
    // Data length
    uint16_t data_length = M_FND_CONFS_MODEL_SUBS_LIST_LEN;
    // Get size of subscription list
    uint8_t nb_addrs = (status == M_ERR_NO_ERROR) ? m_tb_mio_get_subscription_list_size(model_lid) : 0;
    afb4:	2700      	movs	r7, #0
        // Look for model local index
        status = m_tb_mio_get_local_id(element_addr, model_id, vendor, &model_lid);
    }

    // Send status
    m_fnd_confs_send_model_subs_list(status, element_addr, model_id, vendor, model_lid);
    afb6:	7823      	ldrb	r3, [r4, #0]
    afb8:	9307      	str	r3, [sp, #28]
    // Pointer to the buffer that will contain the message
    m_tb_buf_t *p_buf_status;
    // Data length
    uint16_t data_length = M_FND_CONFS_MODEL_SUBS_LIST_LEN;
    // Get size of subscription list
    uint8_t nb_addrs = (status == M_ERR_NO_ERROR) ? m_tb_mio_get_subscription_list_size(model_lid) : 0;
    afba:	9b05      	ldr	r3, [sp, #20]
    afbc:	42bb      	cmp	r3, r7
    afbe:	d103      	bne.n	afc8 <m_fnd_confs_process+0x4ac>
    afc0:	9807      	ldr	r0, [sp, #28]
    afc2:	f008 fbdd 	bl	13780 <m_tb_mio_get_subscription_list_size>
    afc6:	b2c7      	uxtb	r7, r0

    // Update data length
    data_length += (nb_addrs * sizeof(uint16_t));
    afc8:	007b      	lsls	r3, r7, #1

    if (vendor == true)
    {
        data_length += M_FND_CONFS_VENDOR_MODEL_ID_ADD_LEN;
    afca:	1dd9      	adds	r1, r3, #7
    uint8_t nb_addrs = (status == M_ERR_NO_ERROR) ? m_tb_mio_get_subscription_list_size(model_lid) : 0;

    // Update data length
    data_length += (nb_addrs * sizeof(uint16_t));

    if (vendor == true)
    afcc:	2e00      	cmp	r6, #0
    afce:	d100      	bne.n	afd2 <m_fnd_confs_process+0x4b6>
    uint16_t data_length = M_FND_CONFS_MODEL_SUBS_LIST_LEN;
    // Get size of subscription list
    uint8_t nb_addrs = (status == M_ERR_NO_ERROR) ? m_tb_mio_get_subscription_list_size(model_lid) : 0;

    // Update data length
    data_length += (nb_addrs * sizeof(uint16_t));
    afd0:	1d59      	adds	r1, r3, #5
    if (vendor == true)
    {
        data_length += M_FND_CONFS_VENDOR_MODEL_ID_ADD_LEN;
    }

    if (m_fnd_confs_buf_alloc(&p_buf_status, data_length) == M_ERR_NO_ERROR)
    afd2:	a80e      	add	r0, sp, #56	; 0x38
    afd4:	f7ff fab8 	bl	a548 <m_fnd_confs_buf_alloc>
    afd8:	2800      	cmp	r0, #0
    afda:	d001      	beq.n	afe0 <m_fnd_confs_process+0x4c4>
    afdc:	f000 fcd0 	bl	b980 <m_fnd_confs_process+0xe64>
    {
        // Get pointer to data
        uint8_t *p_data = M_TB_BUF_DATA(p_buf_status);
    afe0:	9b0e      	ldr	r3, [sp, #56]	; 0x38
        // Opcode
        uint16_t opcode;

        // Write status
        *p_data = m_fnd_confs_get_air_status(status);
    afe2:	9805      	ldr	r0, [sp, #20]
    }

    if (m_fnd_confs_buf_alloc(&p_buf_status, data_length) == M_ERR_NO_ERROR)
    {
        // Get pointer to data
        uint8_t *p_data = M_TB_BUF_DATA(p_buf_status);
    afe4:	001c      	movs	r4, r3
    afe6:	889b      	ldrh	r3, [r3, #4]
    afe8:	3430      	adds	r4, #48	; 0x30
    afea:	18e4      	adds	r4, r4, r3
        // Opcode
        uint16_t opcode;

        // Write status
        *p_data = m_fnd_confs_get_air_status(status);
    afec:	f7ff fa9d 	bl	a52a <m_fnd_confs_get_air_status>
 */
__INLINE_S__ void co_write16p(void const *ptr16, uint16_t value)
{
    uint8_t *ptr=(uint8_t*)ptr16;

    *ptr++ = value&0xff;
    aff0:	466b      	mov	r3, sp
    aff2:	7e1b      	ldrb	r3, [r3, #24]
    aff4:	7020      	strb	r0, [r4, #0]
    aff6:	7063      	strb	r3, [r4, #1]
    *ptr = (value&0xff00)>>8;
    aff8:	9b04      	ldr	r3, [sp, #16]
 */
__INLINE_S__ void co_write32p(void const *ptr32, uint32_t value)
{
    uint8_t *ptr=(uint8_t*)ptr32;

    *ptr++ = (uint8_t)(value&0xff);
    affa:	70e5      	strb	r5, [r4, #3]
__INLINE_S__ void co_write16p(void const *ptr16, uint16_t value)
{
    uint8_t *ptr=(uint8_t*)ptr16;

    *ptr++ = value&0xff;
    *ptr = (value&0xff00)>>8;
    affc:	0a1b      	lsrs	r3, r3, #8
    affe:	70a3      	strb	r3, [r4, #2]
        // Write element address
        co_write16p(p_data, element_addr);
        p_data += 2;

        // Write model identifier
        if (vendor)
    b000:	2e00      	cmp	r6, #0
    b002:	d009      	beq.n	b018 <m_fnd_confs_process+0x4fc>
__INLINE_S__ void co_write32p(void const *ptr32, uint32_t value)
{
    uint8_t *ptr=(uint8_t*)ptr32;

    *ptr++ = (uint8_t)(value&0xff);
    *ptr++ = (uint8_t)((value&0xff00)>>8);
    b004:	0a2b      	lsrs	r3, r5, #8
    b006:	7123      	strb	r3, [r4, #4]
    *ptr++ = (uint8_t)((value&0xff0000)>>16);
    b008:	0c2b      	lsrs	r3, r5, #16
    *ptr = (uint8_t)((value&0xff000000)>>24);
    b00a:	0e2d      	lsrs	r5, r5, #24
{
    uint8_t *ptr=(uint8_t*)ptr32;

    *ptr++ = (uint8_t)(value&0xff);
    *ptr++ = (uint8_t)((value&0xff00)>>8);
    *ptr++ = (uint8_t)((value&0xff0000)>>16);
    b00c:	7163      	strb	r3, [r4, #5]
    *ptr = (uint8_t)((value&0xff000000)>>24);
    b00e:	71a5      	strb	r5, [r4, #6]
        {
            co_write32p(p_data, model_id);
            opcode = M_FND_CONFS_2B_OPCODE(M_FND_CONFS_OPCODE_VENDOR_MODEL_SUBS_LIST);
            p_data += 4;
    b010:	1de1      	adds	r1, r4, #7

        // Write model identifier
        if (vendor)
        {
            co_write32p(p_data, model_id);
            opcode = M_FND_CONFS_2B_OPCODE(M_FND_CONFS_OPCODE_VENDOR_MODEL_SUBS_LIST);
    b012:	24b2      	movs	r4, #178	; 0xb2
    b014:	01a4      	lsls	r4, r4, #6
    b016:	e004      	b.n	b022 <m_fnd_confs_process+0x506>
__INLINE_S__ void co_write16p(void const *ptr16, uint16_t value)
{
    uint8_t *ptr=(uint8_t*)ptr16;

    *ptr++ = value&0xff;
    *ptr = (value&0xff00)>>8;
    b018:	0a2d      	lsrs	r5, r5, #8
    b01a:	7125      	strb	r5, [r4, #4]
        }
        else
        {
            co_write16p(p_data, (uint16_t)model_id);
            opcode = M_FND_CONFS_2B_OPCODE(M_FND_CONFS_OPCODE_SIG_MODEL_SUBS_LIST);
            p_data += 2;
    b01c:	1d61      	adds	r1, r4, #5
            p_data += 4;
        }
        else
        {
            co_write16p(p_data, (uint16_t)model_id);
            opcode = M_FND_CONFS_2B_OPCODE(M_FND_CONFS_OPCODE_SIG_MODEL_SUBS_LIST);
    b01e:	24aa      	movs	r4, #170	; 0xaa
    b020:	01a4      	lsls	r4, r4, #6
            p_data += 2;
        };

        if (nb_addrs)
    b022:	2f00      	cmp	r7, #0
    b024:	d100      	bne.n	b028 <m_fnd_confs_process+0x50c>
    b026:	e1dc      	b.n	b3e2 <m_fnd_confs_process+0x8c6>
        {
            // Retrieve list content
            m_tb_mio_get_subscription_list(model_lid, p_data, false);
    b028:	2200      	movs	r2, #0
    b02a:	9807      	ldr	r0, [sp, #28]
    b02c:	f008 fbbe 	bl	137ac <m_tb_mio_get_subscription_list>
    b030:	e1d7      	b.n	b3e2 <m_fnd_confs_process+0x8c6>
            case (M_FND_CONFS_OPCODE_MODEL_SUBS_VADDR_DEL)       :
            case (M_FND_CONFS_OPCODE_MODEL_SUBS_VADDR_OVERWRITE) : m_fnd_confs_handler_model_subs_vaddr(p_buf, opcode_2b);  break;
            case (M_FND_CONFS_OPCODE_MODEL_SUBS_DEL_ALL)         : m_fnd_confs_handler_model_subs_del_all(p_buf);           break;
            case (M_FND_CONFS_OPCODE_SIG_MODEL_SUBS_GET)         :
            case (M_FND_CONFS_OPCODE_VENDOR_MODEL_SUBS_GET)      : m_fnd_confs_handler_model_subs_get(p_buf, opcode_2b);    break;
            case (M_FND_CONFS_OPCODE_APPKEY_DEL)                 : m_fnd_confs_handler_appkey(p_buf, opcode_2b, true);      break;
    b032:	2201      	movs	r2, #1
    b034:	9904      	ldr	r1, [sp, #16]
    b036:	0028      	movs	r0, r5
    b038:	f7ff fd14 	bl	aa64 <m_fnd_confs_handler_appkey>
    b03c:	f000 fca2 	bl	b984 <m_fnd_confs_process+0xe68>
 ****************************************************************************************
 */
__STATIC void m_fnd_confs_handler_appkey_get(m_tb_buf_t *p_buf)
{
    // Get message content
    m_fnd_confs_appkey_get_t *p_msg = (m_fnd_confs_appkey_get_t *)M_TB_BUF_DATA(p_buf);
    b040:	002a      	movs	r2, r5
    uint16_t status;
    // Network key local index
    m_lid_t net_key_lid;

    // Look for indicated network key and get its local index
    status = m_tb_key_net_find(p_msg->netkey_id, &net_key_lid);
    b042:	241e      	movs	r4, #30
 ****************************************************************************************
 */
__STATIC void m_fnd_confs_handler_appkey_get(m_tb_buf_t *p_buf)
{
    // Get message content
    m_fnd_confs_appkey_get_t *p_msg = (m_fnd_confs_appkey_get_t *)M_TB_BUF_DATA(p_buf);
    b044:	88ab      	ldrh	r3, [r5, #4]
    b046:	3230      	adds	r2, #48	; 0x30
    b048:	18d3      	adds	r3, r2, r3
    b04a:	9304      	str	r3, [sp, #16]
    uint16_t status;
    // Network key local index
    m_lid_t net_key_lid;

    // Look for indicated network key and get its local index
    status = m_tb_key_net_find(p_msg->netkey_id, &net_key_lid);
    b04c:	ab06      	add	r3, sp, #24
    b04e:	18e4      	adds	r4, r4, r3
    b050:	9b04      	ldr	r3, [sp, #16]
    b052:	0021      	movs	r1, r4
    b054:	8818      	ldrh	r0, [r3, #0]
    b056:	f007 f917 	bl	12288 <m_tb_key_net_find>
 */
__STATIC void m_fnd_confs_send_appkey_list(uint16_t status, m_fnd_confs_appkey_get_t *p_msg,
                                           m_lid_t net_key_lid)
{
    // Get number of application bounded with the provided network key
    uint8_t nb_app_keys = (status == M_ERR_NO_ERROR) ? m_tb_key_get_nb_app_keys(net_key_lid) : 0;
    b05a:	2500      	movs	r5, #0
    uint16_t status;
    // Network key local index
    m_lid_t net_key_lid;

    // Look for indicated network key and get its local index
    status = m_tb_key_net_find(p_msg->netkey_id, &net_key_lid);
    b05c:	0007      	movs	r7, r0

    // Send the status
    m_fnd_confs_send_appkey_list(status, p_msg, net_key_lid);
    b05e:	7826      	ldrb	r6, [r4, #0]
 */
__STATIC void m_fnd_confs_send_appkey_list(uint16_t status, m_fnd_confs_appkey_get_t *p_msg,
                                           m_lid_t net_key_lid)
{
    // Get number of application bounded with the provided network key
    uint8_t nb_app_keys = (status == M_ERR_NO_ERROR) ? m_tb_key_get_nb_app_keys(net_key_lid) : 0;
    b060:	42a8      	cmp	r0, r5
    b062:	d103      	bne.n	b06c <m_fnd_confs_process+0x550>
    b064:	0030      	movs	r0, r6
    b066:	f007 fe19 	bl	12c9c <m_tb_key_get_nb_app_keys>
    b06a:	0005      	movs	r5, r0
    // Compute initial data length for this message
    uint16_t data_len = M_FND_CONFS_APPKEY_LIST_MIN_LEN + m_fnd_confs_get_ids_length(nb_app_keys);
    b06c:	0028      	movs	r0, r5
    b06e:	f7ff fa97 	bl	a5a0 <m_fnd_confs_get_ids_length>
    // Pointer to the buffer that will contain the message
    m_tb_buf_t *p_buf_list;

    if (m_fnd_confs_buf_alloc(&p_buf_list, data_len) == M_ERR_NO_ERROR)
    b072:	3003      	adds	r0, #3
    b074:	b281      	uxth	r1, r0
    b076:	a80e      	add	r0, sp, #56	; 0x38
    b078:	f7ff fa66 	bl	a548 <m_fnd_confs_buf_alloc>
    b07c:	2800      	cmp	r0, #0
    b07e:	d001      	beq.n	b084 <m_fnd_confs_process+0x568>
    b080:	f000 fc7e 	bl	b980 <m_fnd_confs_process+0xe64>
    {
        // Get pointer to data
        uint8_t *p_data = M_TB_BUF_DATA(p_buf_list);
    b084:	9b0e      	ldr	r3, [sp, #56]	; 0x38

        // Write status
        *p_data = m_fnd_confs_get_air_status(status);
    b086:	0038      	movs	r0, r7
    m_tb_buf_t *p_buf_list;

    if (m_fnd_confs_buf_alloc(&p_buf_list, data_len) == M_ERR_NO_ERROR)
    {
        // Get pointer to data
        uint8_t *p_data = M_TB_BUF_DATA(p_buf_list);
    b088:	001c      	movs	r4, r3
    b08a:	889b      	ldrh	r3, [r3, #4]
    b08c:	3430      	adds	r4, #48	; 0x30
    b08e:	18e4      	adds	r4, r4, r3

        // Write status
        *p_data = m_fnd_confs_get_air_status(status);
    b090:	f7ff fa4b 	bl	a52a <m_fnd_confs_get_air_status>
        p_data++;

        // Write NetKey index
        co_write16p(p_data, p_msg->netkey_id);
    b094:	9b04      	ldr	r3, [sp, #16]
    {
        // Get pointer to data
        uint8_t *p_data = M_TB_BUF_DATA(p_buf_list);

        // Write status
        *p_data = m_fnd_confs_get_air_status(status);
    b096:	7020      	strb	r0, [r4, #0]
        p_data++;

        // Write NetKey index
        co_write16p(p_data, p_msg->netkey_id);
    b098:	881b      	ldrh	r3, [r3, #0]
 */
__INLINE_S__ void co_write16p(void const *ptr16, uint16_t value)
{
    uint8_t *ptr=(uint8_t*)ptr16;

    *ptr++ = value&0xff;
    b09a:	7063      	strb	r3, [r4, #1]
    *ptr = (value&0xff00)>>8;
    b09c:	0a1b      	lsrs	r3, r3, #8
    b09e:	70a3      	strb	r3, [r4, #2]
        p_data += 2;

        // Retrieve AppKey indexes of application keys bound with the network key
        if (nb_app_keys)
    b0a0:	2d00      	cmp	r5, #0
    b0a2:	d003      	beq.n	b0ac <m_fnd_confs_process+0x590>
        *p_data = m_fnd_confs_get_air_status(status);
        p_data++;

        // Write NetKey index
        co_write16p(p_data, p_msg->netkey_id);
        p_data += 2;
    b0a4:	1ce1      	adds	r1, r4, #3

        // Retrieve AppKey indexes of application keys bound with the network key
        if (nb_app_keys)
        {
            m_tb_key_app_get_ids(net_key_lid, p_data);
    b0a6:	0030      	movs	r0, r6
    b0a8:	f007 fc06 	bl	128b8 <m_tb_key_app_get_ids>
        }

        // Send the message
        m_fnd_confs_send(p_buf_list, M_FND_CONFS_2B_OPCODE(M_FND_CONFS_OPCODE_APPKEY_LIST));
    b0ac:	21a0      	movs	r1, #160	; 0xa0
    b0ae:	980e      	ldr	r0, [sp, #56]	; 0x38
    b0b0:	0089      	lsls	r1, r1, #2
    b0b2:	f7ff fa50 	bl	a556 <m_fnd_confs_send>
    b0b6:	f000 fc63 	bl	b980 <m_fnd_confs_process+0xe64>
 ****************************************************************************************
 */
__STATIC void m_fnd_confs_handler_netkey(m_tb_buf_t *p_buf, uint8_t opcode)
{
    // Get pointer to data
    uint8_t *p_data = M_TB_BUF_DATA(p_buf);
    b0ba:	002f      	movs	r7, r5
    b0bc:	88ab      	ldrh	r3, [r5, #4]
    b0be:	3730      	adds	r7, #48	; 0x30
    b0c0:	18ff      	adds	r7, r7, r3
 * @return The 16 bits value.
 ****************************************************************************************
 */
__INLINE_S__ uint16_t co_read16p(void const *ptr16)
{
    uint16_t value = ((uint8_t *)ptr16)[0] | ((uint8_t *)ptr16)[1] << 8;
    b0c2:	787d      	ldrb	r5, [r7, #1]
    b0c4:	783b      	ldrb	r3, [r7, #0]
    b0c6:	022d      	lsls	r5, r5, #8
    b0c8:	431d      	orrs	r5, r3
    // Read NetKey index
    uint16_t netkey_id = co_read16p(p_data);
    // Status
    uint16_t status = M_ERR_NO_ERROR;

    if (opcode == M_FND_CONFS_OPCODE_NETKEY_ADD)
    b0ca:	9b04      	ldr	r3, [sp, #16]
    b0cc:	2b40      	cmp	r3, #64	; 0x40
    b0ce:	d10e      	bne.n	b0ee <m_fnd_confs_process+0x5d2>
    {
        // Key is received MSB->LSB and must be swapped
        uint8_t key[M_KEY_LEN];

        co_bswap(&key[0], p_data + 2, M_KEY_LEN);
    b0d0:	1cb9      	adds	r1, r7, #2
    b0d2:	a80e      	add	r0, sp, #56	; 0x38
    b0d4:	f000 fd5c 	bl	bb90 <co_bswap.constprop.7>

        // Inform the key manager about the request
        status = m_tb_key_net_add(netkey_id, &key[0], 0, m_fnd_confs_cb_netkey_added);
    b0d8:	4b48      	ldr	r3, [pc, #288]	; (b1fc <m_fnd_confs_process+0x6e0>)
    b0da:	2200      	movs	r2, #0
    b0dc:	a90e      	add	r1, sp, #56	; 0x38
    b0de:	0028      	movs	r0, r5
    b0e0:	f006 fec4 	bl	11e6c <m_tb_key_net_add>
    b0e4:	1e04      	subs	r4, r0, #0
                status = M_ERR_NO_ERROR;
            }
        }
    }

    if ((status != M_ERR_NO_ERROR) || (opcode == M_FND_CONFS_OPCODE_NETKEY_DEL))
    b0e6:	d101      	bne.n	b0ec <m_fnd_confs_process+0x5d0>
    b0e8:	f000 fc4c 	bl	b984 <m_fnd_confs_process+0xe68>
    b0ec:	e04a      	b.n	b184 <m_fnd_confs_process+0x668>
    {
        // Network key local index
        m_lid_t net_key_lid;

        // Look for indicated network key and get its local index
        status = m_tb_key_net_find(netkey_id, &net_key_lid);
    b0ee:	261e      	movs	r6, #30
    b0f0:	ab06      	add	r3, sp, #24
    b0f2:	18f6      	adds	r6, r6, r3
    b0f4:	0031      	movs	r1, r6
    b0f6:	0028      	movs	r0, r5
    b0f8:	f007 f8c6 	bl	12288 <m_tb_key_net_find>

        if (opcode == M_FND_CONFS_OPCODE_NETKEY_UPD)
    b0fc:	9b04      	ldr	r3, [sp, #16]
    {
        // Network key local index
        m_lid_t net_key_lid;

        // Look for indicated network key and get its local index
        status = m_tb_key_net_find(netkey_id, &net_key_lid);
    b0fe:	0004      	movs	r4, r0
    b100:	9006      	str	r0, [sp, #24]

        if (opcode == M_FND_CONFS_OPCODE_NETKEY_UPD)
    b102:	2b45      	cmp	r3, #69	; 0x45
    b104:	d10c      	bne.n	b120 <m_fnd_confs_process+0x604>
        {
            if (status == M_ERR_NO_ERROR)
    b106:	2800      	cmp	r0, #0
    b108:	d13c      	bne.n	b184 <m_fnd_confs_process+0x668>
            {
                // Key is received MSB->LSB and must be swapped
                uint8_t key[M_KEY_LEN];

                co_bswap(&key[0], p_data + 2, M_KEY_LEN);
    b10a:	1cb9      	adds	r1, r7, #2
    b10c:	a80e      	add	r0, sp, #56	; 0x38
    b10e:	f000 fd3f 	bl	bb90 <co_bswap.constprop.7>

                status = m_tb_key_net_update(net_key_lid, &key[0], m_fnd_confs_cb_netkey_added);
    b112:	7830      	ldrb	r0, [r6, #0]
    b114:	4a39      	ldr	r2, [pc, #228]	; (b1fc <m_fnd_confs_process+0x6e0>)
    b116:	a90e      	add	r1, sp, #56	; 0x38
    b118:	f006 ffa6 	bl	12068 <m_tb_key_net_update>
    b11c:	0004      	movs	r4, r0
    b11e:	e02a      	b.n	b176 <m_fnd_confs_process+0x65a>
            }
        }
        else
        {
            if (status == M_ERR_NO_ERROR)
    b120:	2800      	cmp	r0, #0
    b122:	d122      	bne.n	b16a <m_fnd_confs_process+0x64e>
            {
                // Get number of application keys currently bound with the network key
                uint8_t nb_app_keys = m_tb_key_get_nb_app_keys(net_key_lid);
    b124:	7830      	ldrb	r0, [r6, #0]
    b126:	f007 fdb9 	bl	12c9c <m_tb_key_get_nb_app_keys>
    b12a:	9005      	str	r0, [sp, #20]

                if (nb_app_keys)
    b12c:	2800      	cmp	r0, #0
    b12e:	d012      	beq.n	b156 <m_fnd_confs_process+0x63a>
                    // Get local indexes of key bound with the network key
                    m_lid_t key_lids[M_TB_KEY_MAX_NB_APP];
                    // Counter
                    uint8_t cnt;

                    m_tb_key_app_get_lids(net_key_lid, &key_lids[0]);
    b130:	af0e      	add	r7, sp, #56	; 0x38
    b132:	7830      	ldrb	r0, [r6, #0]
    b134:	0039      	movs	r1, r7
    b136:	f007 fc01 	bl	1293c <m_tb_key_app_get_lids>
    b13a:	9c06      	ldr	r4, [sp, #24]

                    for (cnt = 0; cnt < nb_app_keys; cnt++)
    b13c:	9a05      	ldr	r2, [sp, #20]
    b13e:	b2e3      	uxtb	r3, r4
    b140:	429a      	cmp	r2, r3
    b142:	d908      	bls.n	b156 <m_fnd_confs_process+0x63a>
                    {
                        // Delete application key
                        m_tb_key_app_delete(key_lids[cnt], net_key_lid);
    b144:	7831      	ldrb	r1, [r6, #0]
    b146:	5d38      	ldrb	r0, [r7, r4]
    b148:	f007 fa1e 	bl	12588 <m_tb_key_app_delete>
                        // Inform the Model IO manager that application key has been removed
                        m_tb_mio_app_key_rem_ind(key_lids[cnt]);
    b14c:	5d38      	ldrb	r0, [r7, r4]
    b14e:	f008 fcf7 	bl	13b40 <m_tb_mio_app_key_rem_ind>
    b152:	3401      	adds	r4, #1
    b154:	e7f2      	b.n	b13c <m_fnd_confs_process+0x620>
                    }
                }

                // Delete the key
                status = m_tb_key_net_delete(net_key_lid, false);
    b156:	7830      	ldrb	r0, [r6, #0]
    b158:	2100      	movs	r1, #0
    b15a:	f006 ff17 	bl	11f8c <m_tb_key_net_delete>
    b15e:	1e04      	subs	r4, r0, #0

                if (status == M_ERR_NO_ERROR)
    b160:	d103      	bne.n	b16a <m_fnd_confs_process+0x64e>
                {
                    // Disable publication of heartbeat messages
                    m_tb_state_net_key_rem_ind(net_key_lid);
    b162:	7830      	ldrb	r0, [r6, #0]
    b164:	f009 f9fc 	bl	14560 <m_tb_state_net_key_rem_ind>
    b168:	e007      	b.n	b17a <m_fnd_confs_process+0x65e>
                }
            }

            if (status != M_ERR_CANNOT_REMOVE)
    b16a:	23c8      	movs	r3, #200	; 0xc8
    b16c:	011b      	lsls	r3, r3, #4
    b16e:	429c      	cmp	r4, r3
    b170:	d001      	beq.n	b176 <m_fnd_confs_process+0x65a>
            {
                // Always consider the procedure as successful
                status = M_ERR_NO_ERROR;
    b172:	2400      	movs	r4, #0
    b174:	e001      	b.n	b17a <m_fnd_confs_process+0x65e>
            }
        }
    }

    if ((status != M_ERR_NO_ERROR) || (opcode == M_FND_CONFS_OPCODE_NETKEY_DEL))
    b176:	2c00      	cmp	r4, #0
    b178:	d104      	bne.n	b184 <m_fnd_confs_process+0x668>
    b17a:	9b04      	ldr	r3, [sp, #16]
    b17c:	2b41      	cmp	r3, #65	; 0x41
    b17e:	d001      	beq.n	b184 <m_fnd_confs_process+0x668>
    b180:	f000 fc00 	bl	b984 <m_fnd_confs_process+0xe68>
    {
        // An error has been raised, directly send the status
        m_fnd_confs_send_netkey_status(status, netkey_id);
    b184:	0029      	movs	r1, r5
    b186:	0020      	movs	r0, r4
    b188:	f7ff fad1 	bl	a72e <m_fnd_confs_send_netkey_status>
    b18c:	f000 fbfa 	bl	b984 <m_fnd_confs_process+0xe68>
 ****************************************************************************************
 */
__STATIC void m_fnd_confs_send_netkey_list(void)
{
    // Get number of network keys
    uint8_t nb_keys = m_tb_key_get_nb_net_keys();
    b190:	f007 fd7c 	bl	12c8c <m_tb_key_get_nb_net_keys>
    b194:	0004      	movs	r4, r0
    // Compute initial data length for this message
    uint16_t data_len = m_fnd_confs_get_ids_length(nb_keys);
    b196:	f7ff fa03 	bl	a5a0 <m_fnd_confs_get_ids_length>
    // Pointer to the buffer that will contain the message
    m_tb_buf_t *p_buf_list;

    if (m_fnd_confs_buf_alloc(&p_buf_list, data_len) == M_ERR_NO_ERROR)
    b19a:	b281      	uxth	r1, r0
    b19c:	a80e      	add	r0, sp, #56	; 0x38
    b19e:	f7ff f9d3 	bl	a548 <m_fnd_confs_buf_alloc>
    b1a2:	2800      	cmp	r0, #0
    b1a4:	d001      	beq.n	b1aa <m_fnd_confs_process+0x68e>
    b1a6:	f000 fbeb 	bl	b980 <m_fnd_confs_process+0xe64>
    {
        if (nb_keys != 0)
    b1aa:	2c00      	cmp	r4, #0
    b1ac:	d006      	beq.n	b1bc <m_fnd_confs_process+0x6a0>
        {
            // Get all known NetKey indexes
            m_tb_key_net_get_ids(M_TB_BUF_DATA(p_buf_list));
    b1ae:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    b1b0:	0018      	movs	r0, r3
    b1b2:	889b      	ldrh	r3, [r3, #4]
    b1b4:	3030      	adds	r0, #48	; 0x30
    b1b6:	18c0      	adds	r0, r0, r3
    b1b8:	f007 f906 	bl	123c8 <m_tb_key_net_get_ids>
        }

        // Send the message
        m_fnd_confs_send(p_buf_list, M_FND_CONFS_2B_OPCODE(M_FND_CONFS_OPCODE_NETKEY_LIST));
    b1bc:	2187      	movs	r1, #135	; 0x87
    b1be:	980e      	ldr	r0, [sp, #56]	; 0x38
    b1c0:	01c9      	lsls	r1, r1, #7
    b1c2:	f7ff f9c8 	bl	a556 <m_fnd_confs_send>
    b1c6:	f000 fbdb 	bl	b980 <m_fnd_confs_process+0xe64>
 * @param[in] opcode    Operation code
 ****************************************************************************************
 */
__STATIC void m_fnd_confs_handler_model_app(m_tb_buf_t *p_buf, uint8_t opcode)
{
	m_printf_hex(L_FND, "--model_app", M_TB_BUF_DATA(p_buf), p_buf->data_len);
    b1ca:	002c      	movs	r4, r5
    b1cc:	0039      	movs	r1, r7
    b1ce:	2080      	movs	r0, #128	; 0x80
    b1d0:	88aa      	ldrh	r2, [r5, #4]
    b1d2:	3430      	adds	r4, #48	; 0x30
    b1d4:	892b      	ldrh	r3, [r5, #8]
    b1d6:	18a2      	adds	r2, r4, r2
    b1d8:	3175      	adds	r1, #117	; 0x75
    b1da:	0100      	lsls	r0, r0, #4
    b1dc:	f7f9 fc46 	bl	4a6c <m_printf_hex>
    // Get message content
    m_fnd_confs_model_app_t *p_msg = (m_fnd_confs_model_app_t *)M_TB_BUF_DATA(p_buf);
    b1e0:	88ab      	ldrh	r3, [r5, #4]
    b1e2:	18e4      	adds	r4, r4, r3
    // SIG or vendor model identifier
    bool vendor;
    // Status
    uint16_t status;

    if (p_buf->data_len == sizeof(m_fnd_confs_model_app_t))
    b1e4:	892b      	ldrh	r3, [r5, #8]
    b1e6:	2b08      	cmp	r3, #8
    b1e8:	d10a      	bne.n	b200 <m_fnd_confs_process+0x6e4>
    {
        model_id = p_msg->u.model_id_vendor;
    b1ea:	6865      	ldr	r5, [r4, #4]
        vendor = true;
    b1ec:	2701      	movs	r7, #1
    b1ee:	e009      	b.n	b204 <m_fnd_confs_process+0x6e8>
    b1f0:	100126a0 	.word	0x100126a0
    b1f4:	0000a7f9 	.word	0x0000a7f9
    b1f8:	0000a8f9 	.word	0x0000a8f9
    b1fc:	0000a9a1 	.word	0x0000a9a1
    }
    else
    {
        model_id = (uint32_t)(p_msg->u.model_id_sig);
        vendor = false;
    b200:	2700      	movs	r7, #0
        model_id = p_msg->u.model_id_vendor;
        vendor = true;
    }
    else
    {
        model_id = (uint32_t)(p_msg->u.model_id_sig);
    b202:	88a5      	ldrh	r5, [r4, #4]
        m_lid_t model_lid;
        // Application key local index
        m_lid_t app_key_lid;

        // Check element address is well address of a local element
        if (!m_tb_mio_is_local_addr(p_msg->element_addr))
    b204:	8820      	ldrh	r0, [r4, #0]
    b206:	f008 fc1f 	bl	13a48 <m_tb_mio_is_local_addr>
    b20a:	2800      	cmp	r0, #0
    b20c:	d046      	beq.n	b29c <m_fnd_confs_process+0x780>
            status = M_ERR_INVALID_ADDR;
            break;
        }

        // Cannot bind or unbind Configuration Server model
        if (!vendor
    b20e:	2f00      	cmp	r7, #0
    b210:	d101      	bne.n	b216 <m_fnd_confs_process+0x6fa>
                && (model_id == M_FND_CONFS_MODEL_ID))
    b212:	2d00      	cmp	r5, #0
    b214:	d045      	beq.n	b2a2 <m_fnd_confs_process+0x786>
            status = M_ERR_CANNOT_BIND;
            break;
        }

        // Look for model local index
        status = m_tb_mio_get_local_id(p_msg->element_addr, model_id, vendor, &model_lid);
    b216:	231e      	movs	r3, #30
    b218:	aa06      	add	r2, sp, #24
    b21a:	189b      	adds	r3, r3, r2
    b21c:	0029      	movs	r1, r5
    b21e:	8820      	ldrh	r0, [r4, #0]
    b220:	003a      	movs	r2, r7
    b222:	f008 f809 	bl	13238 <m_tb_mio_get_local_id>
    b226:	4ec4      	ldr	r6, [pc, #784]	; (b538 <m_fnd_confs_process+0xa1c>)
    b228:	1e05      	subs	r5, r0, #0

        if (status != M_ERR_NO_ERROR)
    b22a:	d005      	beq.n	b238 <m_fnd_confs_process+0x71c>
        {
        	m_printf(L_FND, "m_tb_mio_get_local_id error");
    b22c:	2080      	movs	r0, #128	; 0x80
    b22e:	1c71      	adds	r1, r6, #1
    b230:	0100      	lsls	r0, r0, #4
    b232:	f7f9 fbdd 	bl	49f0 <m_printf>
    b236:	e036      	b.n	b2a6 <m_fnd_confs_process+0x78a>
            break;
        }

        // Look for application key local index
        status = m_tb_key_app_find(p_msg->appkey_id, &app_key_lid);
    b238:	8860      	ldrh	r0, [r4, #2]
    b23a:	a90e      	add	r1, sp, #56	; 0x38
    b23c:	f007 fade 	bl	127fc <m_tb_key_app_find>
    b240:	1e05      	subs	r5, r0, #0

        if (status != M_ERR_NO_ERROR)
    b242:	d006      	beq.n	b252 <m_fnd_confs_process+0x736>
        {
        	m_printf(L_FND, "m_tb_key_app_find error");
    b244:	0031      	movs	r1, r6
    b246:	2080      	movs	r0, #128	; 0x80
    b248:	311d      	adds	r1, #29
    b24a:	0100      	lsls	r0, r0, #4
    b24c:	f7f9 fbd0 	bl	49f0 <m_printf>
    b250:	e029      	b.n	b2a6 <m_fnd_confs_process+0x78a>
    b252:	2220      	movs	r2, #32
    b254:	ab06      	add	r3, sp, #24
    b256:	7f99      	ldrb	r1, [r3, #30]
    b258:	189b      	adds	r3, r3, r2
    b25a:	7818      	ldrb	r0, [r3, #0]
            break;
        }

        if (opcode == M_FND_CONFS_OPCODE_MODEL_APP_BIND)
    b25c:	9b04      	ldr	r3, [sp, #16]
    b25e:	2b3d      	cmp	r3, #61	; 0x3d
    b260:	d10e      	bne.n	b280 <m_fnd_confs_process+0x764>
        {
            // Bind the application key with the model
            status = m_tb_key_model_bind(app_key_lid, model_lid);
    b262:	f007 fb97 	bl	12994 <m_tb_key_model_bind>
    b266:	1e06      	subs	r6, r0, #0

            if (status == M_ERR_NO_ERROR)
    b268:	d104      	bne.n	b274 <m_fnd_confs_process+0x758>
            {
                // Inform the Model IO manager
                m_tb_mio_bind(model_lid);
    b26a:	ab06      	add	r3, sp, #24
    b26c:	7f98      	ldrb	r0, [r3, #30]
    b26e:	f008 fb55 	bl	1391c <m_tb_mio_bind>
    b272:	e011      	b.n	b298 <m_fnd_confs_process+0x77c>
            }
			//zjl add for duplicate bind
			else if(status == M_ERR_INVALID_BINDING){
    b274:	238c      	movs	r3, #140	; 0x8c
    b276:	015b      	lsls	r3, r3, #5
    b278:	4298      	cmp	r0, r3
    b27a:	d10d      	bne.n	b298 <m_fnd_confs_process+0x77c>
				status = M_ERR_NO_ERROR;
    b27c:	002e      	movs	r6, r5
    b27e:	e00b      	b.n	b298 <m_fnd_confs_process+0x77c>
			}
        }
        else
        {
            // Unbind the application key from the model
            status = m_tb_key_model_unbind(app_key_lid, model_lid);
    b280:	f007 fc52 	bl	12b28 <m_tb_key_model_unbind>
    b284:	1e06      	subs	r6, r0, #0

            if (status == M_ERR_NO_ERROR)
    b286:	d107      	bne.n	b298 <m_fnd_confs_process+0x77c>
            {
                // Inform the Model IO manager
                m_tb_mio_unbind(model_lid, app_key_lid);
    b288:	2220      	movs	r2, #32
    b28a:	ab06      	add	r3, sp, #24
    b28c:	189b      	adds	r3, r3, r2
    b28e:	7819      	ldrb	r1, [r3, #0]
    b290:	ab06      	add	r3, sp, #24
    b292:	7f98      	ldrb	r0, [r3, #30]
    b294:	f008 fb54 	bl	13940 <m_tb_mio_unbind>
    b298:	0035      	movs	r5, r6
    b29a:	e004      	b.n	b2a6 <m_fnd_confs_process+0x78a>
        m_lid_t app_key_lid;

        // Check element address is well address of a local element
        if (!m_tb_mio_is_local_addr(p_msg->element_addr))
        {
            status = M_ERR_INVALID_ADDR;
    b29c:	25c0      	movs	r5, #192	; 0xc0
    b29e:	006d      	lsls	r5, r5, #1
    b2a0:	e001      	b.n	b2a6 <m_fnd_confs_process+0x78a>

        // Cannot bind or unbind Configuration Server model
        if (!vendor
                && (model_id == M_FND_CONFS_MODEL_ID))
        {
            status = M_ERR_CANNOT_BIND;
    b2a2:	25d8      	movs	r5, #216	; 0xd8
    b2a4:	012d      	lsls	r5, r5, #4
                m_tb_mio_unbind(model_lid, app_key_lid);
            }
        }
    } while (0);
	
	m_printf(L_FND, "error status[%x]", status);
    b2a6:	2080      	movs	r0, #128	; 0x80
    b2a8:	49a3      	ldr	r1, [pc, #652]	; (b538 <m_fnd_confs_process+0xa1c>)
    b2aa:	002a      	movs	r2, r5
    b2ac:	3135      	adds	r1, #53	; 0x35
    b2ae:	0100      	lsls	r0, r0, #4
    b2b0:	f7f9 fb9e 	bl	49f0 <m_printf>
                                                bool vendor)
{
    // Pointer to the buffer that will contain the message
    m_tb_buf_t *p_buf_status;
    // Data length
    uint16_t data_length = M_FND_CONFS_MODEL_APP_STATUS_LEN;
    b2b4:	2107      	movs	r1, #7

    if (vendor)
    b2b6:	2f00      	cmp	r7, #0
    b2b8:	d000      	beq.n	b2bc <m_fnd_confs_process+0x7a0>
    {
        data_length += M_FND_CONFS_VENDOR_MODEL_ID_ADD_LEN;
    b2ba:	3102      	adds	r1, #2
    }

    if (m_fnd_confs_buf_alloc(&p_buf_status, data_length) == M_ERR_NO_ERROR)
    b2bc:	a80e      	add	r0, sp, #56	; 0x38
    b2be:	f7ff f943 	bl	a548 <m_fnd_confs_buf_alloc>
    b2c2:	2800      	cmp	r0, #0
    b2c4:	d000      	beq.n	b2c8 <m_fnd_confs_process+0x7ac>
    b2c6:	e35b      	b.n	b980 <m_fnd_confs_process+0xe64>
    {
        // Get pointer to data
        uint8_t *p_data = M_TB_BUF_DATA(p_buf_status);
    b2c8:	9b0e      	ldr	r3, [sp, #56]	; 0x38

        // Write status
        *p_data = m_fnd_confs_get_air_status(status);
    b2ca:	0028      	movs	r0, r5
    }

    if (m_fnd_confs_buf_alloc(&p_buf_status, data_length) == M_ERR_NO_ERROR)
    {
        // Get pointer to data
        uint8_t *p_data = M_TB_BUF_DATA(p_buf_status);
    b2cc:	001e      	movs	r6, r3
    b2ce:	889b      	ldrh	r3, [r3, #4]
    b2d0:	3630      	adds	r6, #48	; 0x30
    b2d2:	18f6      	adds	r6, r6, r3

        // Write status
        *p_data = m_fnd_confs_get_air_status(status);
    b2d4:	f7ff f929 	bl	a52a <m_fnd_confs_get_air_status>
    b2d8:	7030      	strb	r0, [r6, #0]
        p_data++;

        // Write element address
        co_write16p(p_data, p_msg->element_addr);
    b2da:	8823      	ldrh	r3, [r4, #0]
 */
__INLINE_S__ void co_write16p(void const *ptr16, uint16_t value)
{
    uint8_t *ptr=(uint8_t*)ptr16;

    *ptr++ = value&0xff;
    b2dc:	7073      	strb	r3, [r6, #1]
    *ptr = (value&0xff00)>>8;
    b2de:	0a1b      	lsrs	r3, r3, #8
    b2e0:	70b3      	strb	r3, [r6, #2]
        p_data += 2;

        // Write AppKey index
        co_write16p(p_data, p_msg->appkey_id);
    b2e2:	8863      	ldrh	r3, [r4, #2]
 */
__INLINE_S__ void co_write16p(void const *ptr16, uint16_t value)
{
    uint8_t *ptr=(uint8_t*)ptr16;

    *ptr++ = value&0xff;
    b2e4:	70f3      	strb	r3, [r6, #3]
    *ptr = (value&0xff00)>>8;
    b2e6:	0a1b      	lsrs	r3, r3, #8
    b2e8:	7133      	strb	r3, [r6, #4]
        p_data += 2;

        // Write model identifier
        if (vendor)
    b2ea:	2f00      	cmp	r7, #0
    b2ec:	d008      	beq.n	b300 <m_fnd_confs_process+0x7e4>
        {
            co_write32p(p_data, p_msg->u.model_id_vendor);
    b2ee:	6863      	ldr	r3, [r4, #4]
__INLINE_S__ void co_write32p(void const *ptr32, uint32_t value)
{
    uint8_t *ptr=(uint8_t*)ptr32;

    *ptr++ = (uint8_t)(value&0xff);
    *ptr++ = (uint8_t)((value&0xff00)>>8);
    b2f0:	0a1a      	lsrs	r2, r3, #8
 */
__INLINE_S__ void co_write32p(void const *ptr32, uint32_t value)
{
    uint8_t *ptr=(uint8_t*)ptr32;

    *ptr++ = (uint8_t)(value&0xff);
    b2f2:	7173      	strb	r3, [r6, #5]
    *ptr++ = (uint8_t)((value&0xff00)>>8);
    b2f4:	71b2      	strb	r2, [r6, #6]
    *ptr++ = (uint8_t)((value&0xff0000)>>16);
    b2f6:	0c1a      	lsrs	r2, r3, #16
    *ptr = (uint8_t)((value&0xff000000)>>24);
    b2f8:	0e1b      	lsrs	r3, r3, #24
{
    uint8_t *ptr=(uint8_t*)ptr32;

    *ptr++ = (uint8_t)(value&0xff);
    *ptr++ = (uint8_t)((value&0xff00)>>8);
    *ptr++ = (uint8_t)((value&0xff0000)>>16);
    b2fa:	71f2      	strb	r2, [r6, #7]
    *ptr = (uint8_t)((value&0xff000000)>>24);
    b2fc:	7233      	strb	r3, [r6, #8]
    b2fe:	e003      	b.n	b308 <m_fnd_confs_process+0x7ec>
        }
        else
        {
            co_write16p(p_data, p_msg->u.model_id_sig);
    b300:	88a3      	ldrh	r3, [r4, #4]
 */
__INLINE_S__ void co_write16p(void const *ptr16, uint16_t value)
{
    uint8_t *ptr=(uint8_t*)ptr16;

    *ptr++ = value&0xff;
    b302:	7173      	strb	r3, [r6, #5]
    *ptr = (value&0xff00)>>8;
    b304:	0a1b      	lsrs	r3, r3, #8
    b306:	71b3      	strb	r3, [r6, #6]
        }

        // Send the message
        m_fnd_confs_send(p_buf_status, M_FND_CONFS_2B_OPCODE(M_FND_CONFS_OPCODE_MODEL_APP_STATUS));
    b308:	21fa      	movs	r1, #250	; 0xfa
    b30a:	980e      	ldr	r0, [sp, #56]	; 0x38
    b30c:	0189      	lsls	r1, r1, #6
    b30e:	f7ff f922 	bl	a556 <m_fnd_confs_send>
    b312:	e335      	b.n	b980 <m_fnd_confs_process+0xe64>
 ****************************************************************************************
 */
__STATIC void m_fnd_confs_handler_model_app_get(m_tb_buf_t *p_buf, uint8_t opcode)
{
    // Get message content
    m_fnd_confs_sig_model_app_get_t *p_msg = (m_fnd_confs_sig_model_app_get_t *)M_TB_BUF_DATA(p_buf);
    b314:	002c      	movs	r4, r5
    b316:	88ab      	ldrh	r3, [r5, #4]
    b318:	3430      	adds	r4, #48	; 0x30
    b31a:	18e4      	adds	r4, r4, r3
    // Status
    uint16_t status;
    // Model local index
    m_lid_t model_lid;

    if (p_buf->data_len != sizeof(m_fnd_confs_sig_model_app_get_t))
    b31c:	892b      	ldrh	r3, [r5, #8]
    b31e:	2b04      	cmp	r3, #4
    b320:	d005      	beq.n	b32e <m_fnd_confs_process+0x812>
    {
        model_id = co_read32p(&p_msg->model_id_sig);
    b322:	1ca0      	adds	r0, r4, #2
    b324:	f7ff f8f6 	bl	a514 <co_read32p>
        vendor = true;
    b328:	2701      	movs	r7, #1
    // Model local index
    m_lid_t model_lid;

    if (p_buf->data_len != sizeof(m_fnd_confs_sig_model_app_get_t))
    {
        model_id = co_read32p(&p_msg->model_id_sig);
    b32a:	0005      	movs	r5, r0
    b32c:	e001      	b.n	b332 <m_fnd_confs_process+0x816>
        vendor = true;
    }
    else
    {
        model_id = (uint32_t)(p_msg->model_id_sig);
        vendor = false;
    b32e:	2700      	movs	r7, #0
        model_id = co_read32p(&p_msg->model_id_sig);
        vendor = true;
    }
    else
    {
        model_id = (uint32_t)(p_msg->model_id_sig);
    b330:	8865      	ldrh	r5, [r4, #2]
        vendor = false;
    }

    // Check element address is well address of a local element
    if (m_tb_mio_is_local_addr(p_msg->element_addr))
    b332:	8820      	ldrh	r0, [r4, #0]
    b334:	f008 fb88 	bl	13a48 <m_tb_mio_is_local_addr>
    b338:	261e      	movs	r6, #30
    b33a:	ab06      	add	r3, sp, #24
    b33c:	18f6      	adds	r6, r6, r3
    b33e:	2800      	cmp	r0, #0
    b340:	d007      	beq.n	b352 <m_fnd_confs_process+0x836>
    {
        // Look for model local index
        status = m_tb_mio_get_local_id(p_msg->element_addr, model_id, vendor, &model_lid);
    b342:	8820      	ldrh	r0, [r4, #0]
    b344:	0033      	movs	r3, r6
    b346:	003a      	movs	r2, r7
    b348:	0029      	movs	r1, r5
    b34a:	f007 ff75 	bl	13238 <m_tb_mio_get_local_id>
    b34e:	9004      	str	r0, [sp, #16]
    b350:	e002      	b.n	b358 <m_fnd_confs_process+0x83c>
    }
    else
    {
        status = M_ERR_INVALID_ADDR;
    b352:	23c0      	movs	r3, #192	; 0xc0
    b354:	005b      	lsls	r3, r3, #1
    b356:	9304      	str	r3, [sp, #16]
    }

    // Send the status
    m_fnd_confs_send_model_app_list(status, p_msg->element_addr, model_id, vendor, model_lid);
    b358:	8823      	ldrh	r3, [r4, #0]
    b35a:	9305      	str	r3, [sp, #20]
    b35c:	7833      	ldrb	r3, [r6, #0]
                                              bool vendor, m_lid_t model_lid)
{
    // Pointer to the buffer that will contain the message
    m_tb_buf_t *p_buf_status;
    // Get number of application key bound with the model
    uint8_t nb_bound_app = (status == M_ERR_NO_ERROR) ? m_tb_mio_get_nb_bound_app(model_lid) : 0;
    b35e:	2600      	movs	r6, #0
    {
        status = M_ERR_INVALID_ADDR;
    }

    // Send the status
    m_fnd_confs_send_model_app_list(status, p_msg->element_addr, model_id, vendor, model_lid);
    b360:	9306      	str	r3, [sp, #24]
                                              bool vendor, m_lid_t model_lid)
{
    // Pointer to the buffer that will contain the message
    m_tb_buf_t *p_buf_status;
    // Get number of application key bound with the model
    uint8_t nb_bound_app = (status == M_ERR_NO_ERROR) ? m_tb_mio_get_nb_bound_app(model_lid) : 0;
    b362:	9b04      	ldr	r3, [sp, #16]
    b364:	42b3      	cmp	r3, r6
    b366:	d103      	bne.n	b370 <m_fnd_confs_process+0x854>
    b368:	9806      	ldr	r0, [sp, #24]
    b36a:	f008 fb15 	bl	13998 <m_tb_mio_get_nb_bound_app>
    b36e:	0006      	movs	r6, r0
    // Data length
    uint16_t data_length = M_FND_CONFS_SIG_MODEL_APP_LIST_LEN + m_fnd_confs_get_ids_length(nb_bound_app);
    b370:	0030      	movs	r0, r6
    b372:	f7ff f915 	bl	a5a0 <m_fnd_confs_get_ids_length>
    b376:	b281      	uxth	r1, r0

    if (vendor)
    b378:	2f00      	cmp	r7, #0
    b37a:	d102      	bne.n	b382 <m_fnd_confs_process+0x866>
    // Pointer to the buffer that will contain the message
    m_tb_buf_t *p_buf_status;
    // Get number of application key bound with the model
    uint8_t nb_bound_app = (status == M_ERR_NO_ERROR) ? m_tb_mio_get_nb_bound_app(model_lid) : 0;
    // Data length
    uint16_t data_length = M_FND_CONFS_SIG_MODEL_APP_LIST_LEN + m_fnd_confs_get_ids_length(nb_bound_app);
    b37c:	3105      	adds	r1, #5
    b37e:	b289      	uxth	r1, r1
    b380:	e001      	b.n	b386 <m_fnd_confs_process+0x86a>

    if (vendor)
    {
        data_length += M_FND_CONFS_VENDOR_MODEL_ID_ADD_LEN;
    b382:	3107      	adds	r1, #7
    b384:	b289      	uxth	r1, r1
    }

    // Try to allocate a buffer
    if (m_fnd_confs_buf_alloc(&p_buf_status, data_length) == M_ERR_NO_ERROR)
    b386:	a80e      	add	r0, sp, #56	; 0x38
    b388:	f7ff f8de 	bl	a548 <m_fnd_confs_buf_alloc>
    b38c:	2800      	cmp	r0, #0
    b38e:	d000      	beq.n	b392 <m_fnd_confs_process+0x876>
    b390:	e2f6      	b.n	b980 <m_fnd_confs_process+0xe64>
    {
        // Get pointer to data
        uint8_t *p_data = M_TB_BUF_DATA(p_buf_status);
    b392:	9b0e      	ldr	r3, [sp, #56]	; 0x38
        // Operation code
        uint16_t opcode;

        // Write status
        *p_data = m_fnd_confs_get_air_status(status);
    b394:	9804      	ldr	r0, [sp, #16]

    // Try to allocate a buffer
    if (m_fnd_confs_buf_alloc(&p_buf_status, data_length) == M_ERR_NO_ERROR)
    {
        // Get pointer to data
        uint8_t *p_data = M_TB_BUF_DATA(p_buf_status);
    b396:	001c      	movs	r4, r3
    b398:	889b      	ldrh	r3, [r3, #4]
    b39a:	3430      	adds	r4, #48	; 0x30
    b39c:	18e4      	adds	r4, r4, r3
        // Operation code
        uint16_t opcode;

        // Write status
        *p_data = m_fnd_confs_get_air_status(status);
    b39e:	f7ff f8c4 	bl	a52a <m_fnd_confs_get_air_status>
 */
__INLINE_S__ void co_write16p(void const *ptr16, uint16_t value)
{
    uint8_t *ptr=(uint8_t*)ptr16;

    *ptr++ = value&0xff;
    b3a2:	466b      	mov	r3, sp
    b3a4:	7d1b      	ldrb	r3, [r3, #20]
    b3a6:	7020      	strb	r0, [r4, #0]
    b3a8:	7063      	strb	r3, [r4, #1]
    *ptr = (value&0xff00)>>8;
    b3aa:	9b05      	ldr	r3, [sp, #20]
 */
__INLINE_S__ void co_write32p(void const *ptr32, uint32_t value)
{
    uint8_t *ptr=(uint8_t*)ptr32;

    *ptr++ = (uint8_t)(value&0xff);
    b3ac:	70e5      	strb	r5, [r4, #3]
__INLINE_S__ void co_write16p(void const *ptr16, uint16_t value)
{
    uint8_t *ptr=(uint8_t*)ptr16;

    *ptr++ = value&0xff;
    *ptr = (value&0xff00)>>8;
    b3ae:	0a1b      	lsrs	r3, r3, #8
    b3b0:	70a3      	strb	r3, [r4, #2]
        // Write element address
        co_write16p(p_data, element_addr);
        p_data += 2;

        // Write model identifier
        if (vendor)
    b3b2:	2f00      	cmp	r7, #0
    b3b4:	d009      	beq.n	b3ca <m_fnd_confs_process+0x8ae>
__INLINE_S__ void co_write32p(void const *ptr32, uint32_t value)
{
    uint8_t *ptr=(uint8_t*)ptr32;

    *ptr++ = (uint8_t)(value&0xff);
    *ptr++ = (uint8_t)((value&0xff00)>>8);
    b3b6:	0a2b      	lsrs	r3, r5, #8
    b3b8:	7123      	strb	r3, [r4, #4]
    *ptr++ = (uint8_t)((value&0xff0000)>>16);
    b3ba:	0c2b      	lsrs	r3, r5, #16
    *ptr = (uint8_t)((value&0xff000000)>>24);
    b3bc:	0e2d      	lsrs	r5, r5, #24
{
    uint8_t *ptr=(uint8_t*)ptr32;

    *ptr++ = (uint8_t)(value&0xff);
    *ptr++ = (uint8_t)((value&0xff00)>>8);
    *ptr++ = (uint8_t)((value&0xff0000)>>16);
    b3be:	7163      	strb	r3, [r4, #5]
    *ptr = (uint8_t)((value&0xff000000)>>24);
    b3c0:	71a5      	strb	r5, [r4, #6]
        {
            co_write32p(p_data, model_id);
            p_data += 4;
    b3c2:	1de2      	adds	r2, r4, #7

            // Send a Config Vendor Model App List message
            opcode = M_FND_CONFS_2B_OPCODE(M_FND_CONFS_OPCODE_VENDOR_MODEL_APP_LIST);
    b3c4:	249d      	movs	r4, #157	; 0x9d
    b3c6:	01e4      	lsls	r4, r4, #7
    b3c8:	e004      	b.n	b3d4 <m_fnd_confs_process+0x8b8>
__INLINE_S__ void co_write16p(void const *ptr16, uint16_t value)
{
    uint8_t *ptr=(uint8_t*)ptr16;

    *ptr++ = value&0xff;
    *ptr = (value&0xff00)>>8;
    b3ca:	0a2d      	lsrs	r5, r5, #8
    b3cc:	7125      	strb	r5, [r4, #4]
        }
        else
        {
            co_write16p(p_data, model_id);
            p_data += 2;
    b3ce:	1d62      	adds	r2, r4, #5

            // Send a Config SIG Model App List message
            opcode = M_FND_CONFS_2B_OPCODE(M_FND_CONFS_OPCODE_SIG_MODEL_APP_LIST);
    b3d0:	2499      	movs	r4, #153	; 0x99
    b3d2:	01e4      	lsls	r4, r4, #7
        }

        // Retrieve the list of AppKey indexes of keys bound with the indicated model
        if (nb_bound_app != 0)
    b3d4:	2e00      	cmp	r6, #0
    b3d6:	d004      	beq.n	b3e2 <m_fnd_confs_process+0x8c6>
        {
            m_tb_key_get_model_appkey_ids(model_lid, nb_bound_app, p_data, true);
    b3d8:	2301      	movs	r3, #1
    b3da:	0031      	movs	r1, r6
    b3dc:	9806      	ldr	r0, [sp, #24]
    b3de:	f007 fc67 	bl	12cb0 <m_tb_key_get_model_appkey_ids>
        }

        // Send the message
        m_fnd_confs_send(p_buf_status, opcode);
    b3e2:	0021      	movs	r1, r4
    b3e4:	980e      	ldr	r0, [sp, #56]	; 0x38
    b3e6:	f7ff f8b6 	bl	a556 <m_fnd_confs_send>
    b3ea:	e2c9      	b.n	b980 <m_fnd_confs_process+0xe64>
 */
__STATIC void m_fnd_confs_handler_beacon(m_tb_buf_t *p_buf, uint8_t opcode)
{
    do
    {
        if (opcode == M_FND_CONFS_OPCODE_BEACON_SET)
    b3ec:	9b04      	ldr	r3, [sp, #16]
    b3ee:	2b0a      	cmp	r3, #10
    b3f0:	d108      	bne.n	b404 <m_fnd_confs_process+0x8e8>
        {
            // Get beacon state value indicated by the provisionner
            uint8_t bcn_state = *M_TB_BUF_DATA(p_buf);
    b3f2:	88ab      	ldrh	r3, [r5, #4]
    b3f4:	18ed      	adds	r5, r5, r3
    b3f6:	3530      	adds	r5, #48	; 0x30
    b3f8:	7828      	ldrb	r0, [r5, #0]

            // Check beacon status value
            if (bcn_state > M_CONF_BCN_STATE_BROAD)
    b3fa:	2801      	cmp	r0, #1
    b3fc:	d900      	bls.n	b400 <m_fnd_confs_process+0x8e4>
    b3fe:	e2bf      	b.n	b980 <m_fnd_confs_process+0xe64>
                // Discard the message
                break;
            }

            // Try to set the indicated beacon state value
            m_tb_state_set_beacon_state(bcn_state);
    b400:	f008 feb8 	bl	14174 <m_tb_state_set_beacon_state>
__STATIC void m_fnd_confs_send_beacon_status(void)
{
    // Pointer to the buffer that will contain the message
    m_tb_buf_t *p_buf_status;

    if (m_fnd_confs_buf_alloc(&p_buf_status, M_FND_CONFS_BEACON_STATUS_LEN) == M_ERR_NO_ERROR)
    b404:	2101      	movs	r1, #1
    b406:	a80e      	add	r0, sp, #56	; 0x38
    b408:	f7ff f89e 	bl	a548 <m_fnd_confs_buf_alloc>
    b40c:	2800      	cmp	r0, #0
    b40e:	d000      	beq.n	b412 <m_fnd_confs_process+0x8f6>
    b410:	e2b6      	b.n	b980 <m_fnd_confs_process+0xe64>
    {
        // Get pointer to data
        uint8_t *p_data = M_TB_BUF_DATA(p_buf_status);
    b412:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    b414:	001c      	movs	r4, r3
    b416:	889b      	ldrh	r3, [r3, #4]
    b418:	3430      	adds	r4, #48	; 0x30
    b41a:	18e4      	adds	r4, r4, r3

        // Write current beacon state
        *p_data = m_tb_state_get_beacon_state();
    b41c:	f008 ffe4 	bl	143e8 <m_tb_state_get_beacon_state>
        p_data++;

        // Send the message
        m_fnd_confs_send(p_buf_status, M_FND_CONFS_2B_OPCODE(M_FND_CONFS_OPCODE_BEACON_STATUS));
    b420:	21b8      	movs	r1, #184	; 0xb8
    {
        // Get pointer to data
        uint8_t *p_data = M_TB_BUF_DATA(p_buf_status);

        // Write current beacon state
        *p_data = m_tb_state_get_beacon_state();
    b422:	7020      	strb	r0, [r4, #0]
        p_data++;

        // Send the message
        m_fnd_confs_send(p_buf_status, M_FND_CONFS_2B_OPCODE(M_FND_CONFS_OPCODE_BEACON_STATUS));
    b424:	0109      	lsls	r1, r1, #4
    b426:	980e      	ldr	r0, [sp, #56]	; 0x38
    b428:	f7ff f895 	bl	a556 <m_fnd_confs_send>
    b42c:	e2a8      	b.n	b980 <m_fnd_confs_process+0xe64>
 */
__STATIC void m_fnd_confs_handler_default_ttl(m_tb_buf_t *p_buf, uint8_t opcode)
{
    do
    {
        if (opcode == M_FND_CONFS_OPCODE_DEFAULT_TTL_SET)
    b42e:	9b04      	ldr	r3, [sp, #16]
    b430:	2b0d      	cmp	r3, #13
    b432:	d10c      	bne.n	b44e <m_fnd_confs_process+0x932>
        {
            // Get default TTL value indicated by the provisionner
            uint8_t default_ttl = *M_TB_BUF_DATA(p_buf);
    b434:	88ab      	ldrh	r3, [r5, #4]
    b436:	18ed      	adds	r5, r5, r3
    b438:	3530      	adds	r5, #48	; 0x30
    b43a:	7828      	ldrb	r0, [r5, #0]

            // Check provided value
            // Check that provided value is valid
            if ((default_ttl >= 0x80) || (default_ttl == 0x01))
    b43c:	b243      	sxtb	r3, r0
    b43e:	2b00      	cmp	r3, #0
    b440:	da00      	bge.n	b444 <m_fnd_confs_process+0x928>
    b442:	e29d      	b.n	b980 <m_fnd_confs_process+0xe64>
    b444:	2801      	cmp	r0, #1
    b446:	d100      	bne.n	b44a <m_fnd_confs_process+0x92e>
    b448:	e29a      	b.n	b980 <m_fnd_confs_process+0xe64>
            {
                break;
            }

            // Try to set the indicated Default TTL value
            m_tb_state_set_default_ttl(default_ttl);
    b44a:	f008 fe87 	bl	1415c <m_tb_state_set_default_ttl>
__STATIC void m_fnd_confs_send_default_ttl_status()
{
    // Pointer to the buffer that will contain the message
    m_tb_buf_t *p_buf_status;

    if (m_fnd_confs_buf_alloc(&p_buf_status, M_FND_CONFS_DEFAULT_TTL_STATUS_LEN) == M_ERR_NO_ERROR)
    b44e:	2101      	movs	r1, #1
    b450:	a80e      	add	r0, sp, #56	; 0x38
    b452:	f7ff f879 	bl	a548 <m_fnd_confs_buf_alloc>
    b456:	2800      	cmp	r0, #0
    b458:	d000      	beq.n	b45c <m_fnd_confs_process+0x940>
    b45a:	e291      	b.n	b980 <m_fnd_confs_process+0xe64>
    {
        // Get pointer to data
        uint8_t *p_data = M_TB_BUF_DATA(p_buf_status);
    b45c:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    b45e:	001c      	movs	r4, r3
    b460:	889b      	ldrh	r3, [r3, #4]
    b462:	3430      	adds	r4, #48	; 0x30
    b464:	18e4      	adds	r4, r4, r3

        // Write default TTL value
        *p_data = m_tb_state_get_default_ttl();
    b466:	f008 ffb7 	bl	143d8 <m_tb_state_get_default_ttl>
        p_data++;

        // Send the message
        m_fnd_confs_send(p_buf_status, M_FND_CONFS_2B_OPCODE(M_FND_CONFS_OPCODE_DEFAULT_TTL_STATUS));
    b46a:	21e8      	movs	r1, #232	; 0xe8
    {
        // Get pointer to data
        uint8_t *p_data = M_TB_BUF_DATA(p_buf_status);

        // Write default TTL value
        *p_data = m_tb_state_get_default_ttl();
    b46c:	7020      	strb	r0, [r4, #0]
        p_data++;

        // Send the message
        m_fnd_confs_send(p_buf_status, M_FND_CONFS_2B_OPCODE(M_FND_CONFS_OPCODE_DEFAULT_TTL_STATUS));
    b46e:	0109      	lsls	r1, r1, #4
    b470:	980e      	ldr	r0, [sp, #56]	; 0x38
    b472:	f7ff f870 	bl	a556 <m_fnd_confs_send>
    b476:	e283      	b.n	b980 <m_fnd_confs_process+0xe64>
 */
__STATIC void m_fnd_confs_handler_friend(m_tb_buf_t *p_buf, uint8_t opcode)
{
    do
    {
        if (opcode == M_FND_CONFS_OPCODE_FRIEND_SET)
    b478:	9b04      	ldr	r3, [sp, #16]
    b47a:	2b10      	cmp	r3, #16
    b47c:	d106      	bne.n	b48c <m_fnd_confs_process+0x970>
        {
            // Get Friend state value indicated by the provisionner
            uint8_t friend_state = *M_TB_BUF_DATA(p_buf);
    b47e:	88ab      	ldrh	r3, [r5, #4]
    b480:	18ed      	adds	r5, r5, r3
    b482:	3530      	adds	r5, #48	; 0x30

            // Check provided state
            if (friend_state > M_CONF_FRIEND_STATE_ENABLED)
    b484:	782b      	ldrb	r3, [r5, #0]
    b486:	2b01      	cmp	r3, #1
    b488:	d900      	bls.n	b48c <m_fnd_confs_process+0x970>
    b48a:	e279      	b.n	b980 <m_fnd_confs_process+0xe64>
__STATIC void m_fnd_confs_send_friend_status(void)
{
    // Pointer to the buffer that will contain the message
    m_tb_buf_t *p_buf_status;

    if (m_fnd_confs_buf_alloc(&p_buf_status, M_FND_CONFS_FRIEND_STATUS_LEN) == M_ERR_NO_ERROR)
    b48c:	2101      	movs	r1, #1
    b48e:	a80e      	add	r0, sp, #56	; 0x38
    b490:	f7ff f85a 	bl	a548 <m_fnd_confs_buf_alloc>
    b494:	2800      	cmp	r0, #0
    b496:	d000      	beq.n	b49a <m_fnd_confs_process+0x97e>
    b498:	e272      	b.n	b980 <m_fnd_confs_process+0xe64>
    {
        // Get pointer to data
        uint8_t *p_data = M_TB_BUF_DATA(p_buf_status);
    b49a:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    b49c:	001c      	movs	r4, r3
    b49e:	889b      	ldrh	r3, [r3, #4]
    b4a0:	3430      	adds	r4, #48	; 0x30
    b4a2:	18e4      	adds	r4, r4, r3

        // Write Friend state
        *p_data = m_tb_state_get_friend_state();
    b4a4:	f008 ffc2 	bl	1442c <m_tb_state_get_friend_state>

        // Send the message
        m_fnd_confs_send(p_buf_status, M_FND_CONFS_2B_OPCODE(M_FND_CONFS_OPCODE_FRIEND_STATUS));
    b4a8:	218c      	movs	r1, #140	; 0x8c
    {
        // Get pointer to data
        uint8_t *p_data = M_TB_BUF_DATA(p_buf_status);

        // Write Friend state
        *p_data = m_tb_state_get_friend_state();
    b4aa:	7020      	strb	r0, [r4, #0]

        // Send the message
        m_fnd_confs_send(p_buf_status, M_FND_CONFS_2B_OPCODE(M_FND_CONFS_OPCODE_FRIEND_STATUS));
    b4ac:	0149      	lsls	r1, r1, #5
    b4ae:	980e      	ldr	r0, [sp, #56]	; 0x38
    b4b0:	f7ff f851 	bl	a556 <m_fnd_confs_send>

        // Check if an Heartbeat message must be sent
        m_tb_state_hb_check_features();
    b4b4:	f009 f892 	bl	145dc <m_tb_state_hb_check_features>
    b4b8:	e262      	b.n	b980 <m_fnd_confs_process+0xe64>
__STATIC void m_fnd_confs_handler_gatt_proxy(m_tb_buf_t *p_buf, uint8_t opcode)
{
    do
    {
        // ensure that proxy feature is supported
        if (opcode == M_FND_CONFS_OPCODE_GATT_PROXY_SET)
    b4ba:	9b04      	ldr	r3, [sp, #16]
    b4bc:	2b13      	cmp	r3, #19
    b4be:	d106      	bne.n	b4ce <m_fnd_confs_process+0x9b2>
        {
            // Get GATT proxy state value indicated by the provisionner
            uint8_t gatt_prox_state = *M_TB_BUF_DATA(p_buf);
    b4c0:	88ab      	ldrh	r3, [r5, #4]
    b4c2:	18ed      	adds	r5, r5, r3
    b4c4:	3530      	adds	r5, #48	; 0x30

            // Check received state
            if (gatt_prox_state > M_CONF_GATT_PROXY_STATE_ENABLED)
    b4c6:	782b      	ldrb	r3, [r5, #0]
    b4c8:	2b01      	cmp	r3, #1
    b4ca:	d900      	bls.n	b4ce <m_fnd_confs_process+0x9b2>
    b4cc:	e258      	b.n	b980 <m_fnd_confs_process+0xe64>
__STATIC void m_fnd_confs_send_gatt_proxy_status(void)
{
    // Pointer to the buffer that will contain the message
    m_tb_buf_t *p_buf_status;

    if (m_fnd_confs_buf_alloc(&p_buf_status, M_FND_CONFS_GATT_PROXY_STATUS_LEN) == M_ERR_NO_ERROR)
    b4ce:	2101      	movs	r1, #1
    b4d0:	a80e      	add	r0, sp, #56	; 0x38
    b4d2:	f7ff f839 	bl	a548 <m_fnd_confs_buf_alloc>
    b4d6:	2800      	cmp	r0, #0
    b4d8:	d000      	beq.n	b4dc <m_fnd_confs_process+0x9c0>
    b4da:	e251      	b.n	b980 <m_fnd_confs_process+0xe64>
    {
        // Get pointer to data
        uint8_t *p_data = M_TB_BUF_DATA(p_buf_status);
    b4dc:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    b4de:	001c      	movs	r4, r3
    b4e0:	889b      	ldrh	r3, [r3, #4]
    b4e2:	3430      	adds	r4, #48	; 0x30
    b4e4:	18e4      	adds	r4, r4, r3

        // Write GATT proxy state
        *p_data = m_tb_state_get_gatt_proxy_state();
    b4e6:	f008 ff87 	bl	143f8 <m_tb_state_get_gatt_proxy_state>

        // Send the message
        m_fnd_confs_send(p_buf_status, M_FND_CONFS_2B_OPCODE(M_FND_CONFS_OPCODE_GATT_PROXY_STATUS));
    b4ea:	21a4      	movs	r1, #164	; 0xa4
    {
        // Get pointer to data
        uint8_t *p_data = M_TB_BUF_DATA(p_buf_status);

        // Write GATT proxy state
        *p_data = m_tb_state_get_gatt_proxy_state();
    b4ec:	7020      	strb	r0, [r4, #0]

        // Send the message
        m_fnd_confs_send(p_buf_status, M_FND_CONFS_2B_OPCODE(M_FND_CONFS_OPCODE_GATT_PROXY_STATUS));
    b4ee:	0149      	lsls	r1, r1, #5
    b4f0:	980e      	ldr	r0, [sp, #56]	; 0x38
    b4f2:	f7ff f830 	bl	a556 <m_fnd_confs_send>

        // Check if an Heartbeat message must be sent
        m_tb_state_hb_check_features();
    b4f6:	f009 f871 	bl	145dc <m_tb_state_hb_check_features>
    b4fa:	e241      	b.n	b980 <m_fnd_confs_process+0xe64>
 * @param[in] opcode    Operation code
 ****************************************************************************************
 */
__STATIC void m_fnd_confs_handler_net_tx(m_tb_buf_t *p_buf, uint8_t opcode)
{
    if (opcode == M_FND_CONFS_OPCODE_NET_TX_SET)
    b4fc:	9b04      	ldr	r3, [sp, #16]
    b4fe:	2b24      	cmp	r3, #36	; 0x24
    b500:	d105      	bne.n	b50e <m_fnd_confs_process+0x9f2>
    {
        // Get Network Transmit state value indicated by the provisionner
        uint8_t net_tx_state = *M_TB_BUF_DATA(p_buf);
    b502:	88ab      	ldrh	r3, [r5, #4]
    b504:	18ed      	adds	r5, r5, r3
    b506:	3530      	adds	r5, #48	; 0x30

        // Try to set the indicated Network Transmit state
        m_tb_state_set_net_tx_state(net_tx_state);
    b508:	7828      	ldrb	r0, [r5, #0]
    b50a:	f008 fe71 	bl	141f0 <m_tb_state_set_net_tx_state>
__STATIC void m_fnd_confs_send_net_tx_status(void)
{
    // Pointer to the buffer that will contain the message
    m_tb_buf_t *p_buf_status;

    if (m_fnd_confs_buf_alloc(&p_buf_status, M_FND_CONFS_NET_TX_STATUS_LEN) == M_ERR_NO_ERROR)
    b50e:	2101      	movs	r1, #1
    b510:	a80e      	add	r0, sp, #56	; 0x38
    b512:	f7ff f819 	bl	a548 <m_fnd_confs_buf_alloc>
    b516:	2800      	cmp	r0, #0
    b518:	d000      	beq.n	b51c <m_fnd_confs_process+0xa00>
    b51a:	e231      	b.n	b980 <m_fnd_confs_process+0xe64>
    {
        // Get pointer to data
        uint8_t *p_data = M_TB_BUF_DATA(p_buf_status);
    b51c:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    b51e:	001c      	movs	r4, r3
    b520:	889b      	ldrh	r3, [r3, #4]
    b522:	3430      	adds	r4, #48	; 0x30
    b524:	18e4      	adds	r4, r4, r3

        // Write Network Transmit state
        *p_data = m_tb_state_get_net_tx_state();
    b526:	f008 ff83 	bl	14430 <m_tb_state_get_net_tx_state>

        // Send the message
        m_fnd_confs_send(p_buf_status, M_FND_CONFS_2B_OPCODE(M_FND_CONFS_OPCODE_NET_TX_STATUS));
    b52a:	2196      	movs	r1, #150	; 0x96
    {
        // Get pointer to data
        uint8_t *p_data = M_TB_BUF_DATA(p_buf_status);

        // Write Network Transmit state
        *p_data = m_tb_state_get_net_tx_state();
    b52c:	7020      	strb	r0, [r4, #0]

        // Send the message
        m_fnd_confs_send(p_buf_status, M_FND_CONFS_2B_OPCODE(M_FND_CONFS_OPCODE_NET_TX_STATUS));
    b52e:	0189      	lsls	r1, r1, #6
    b530:	980e      	ldr	r0, [sp, #56]	; 0x38
    b532:	f7ff f810 	bl	a556 <m_fnd_confs_send>
    b536:	e223      	b.n	b980 <m_fnd_confs_process+0xe64>
    b538:	000216dc 	.word	0x000216dc
 */
__STATIC void m_fnd_confs_handler_relay(m_tb_buf_t *p_buf, uint8_t opcode)
{
    do
    {
        if (opcode == M_FND_CONFS_OPCODE_RELAY_SET)
    b53c:	9b04      	ldr	r3, [sp, #16]
    b53e:	2b27      	cmp	r3, #39	; 0x27
    b540:	d10a      	bne.n	b558 <m_fnd_confs_process+0xa3c>
        {
            // Get pointer to data
            uint8_t *p_data = M_TB_BUF_DATA(p_buf);
    b542:	002a      	movs	r2, r5
    b544:	88ab      	ldrh	r3, [r5, #4]
    b546:	3230      	adds	r2, #48	; 0x30
    b548:	18d3      	adds	r3, r2, r3
            // Get relay state value indicated by the provisionner
            uint8_t relay_state = *p_data;
    b54a:	7818      	ldrb	r0, [r3, #0]
            // Retransmit state
            uint8_t relay_retx_state;
            #endif //(BLE_MESH_RELAY)

            // Check state value
            if (relay_state > M_CONF_RELAY_STATE_ENABLED)
    b54c:	2801      	cmp	r0, #1
    b54e:	d900      	bls.n	b552 <m_fnd_confs_process+0xa36>
    b550:	e216      	b.n	b980 <m_fnd_confs_process+0xe64>
            #if (BLE_MESH_RELAY)
            // And retransmit state
            relay_retx_state = *(p_data + 1);

            // Try to set the indicated relay and relay retransmit states
            m_tb_state_set_relay_state(relay_state, relay_retx_state);
    b552:	7859      	ldrb	r1, [r3, #1]
    b554:	f008 fe26 	bl	141a4 <m_tb_state_set_relay_state>
__STATIC void m_fnd_confs_send_relay_status(void)
{
    // Pointer to the buffer that will contain the message
    m_tb_buf_t *p_buf_status;

    if (m_fnd_confs_buf_alloc(&p_buf_status, M_FND_CONFS_RELAY_STATUS_LEN) == M_ERR_NO_ERROR)
    b558:	2102      	movs	r1, #2
    b55a:	a80e      	add	r0, sp, #56	; 0x38
    b55c:	f7fe fff4 	bl	a548 <m_fnd_confs_buf_alloc>
    b560:	2800      	cmp	r0, #0
    b562:	d000      	beq.n	b566 <m_fnd_confs_process+0xa4a>
    b564:	e20c      	b.n	b980 <m_fnd_confs_process+0xe64>
    {
        // Get pointer to data
        uint8_t *p_data = M_TB_BUF_DATA(p_buf_status);
    b566:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    b568:	001c      	movs	r4, r3
    b56a:	889b      	ldrh	r3, [r3, #4]
    b56c:	3430      	adds	r4, #48	; 0x30
    b56e:	18e4      	adds	r4, r4, r3

        // Write relay state and relay retransmit state
        *p_data = m_tb_state_get_relay_state(p_data + 1);
    b570:	1c60      	adds	r0, r4, #1
    b572:	f008 ff43 	bl	143fc <m_tb_state_get_relay_state>

        // Send the message
        m_fnd_confs_send(p_buf_status, M_FND_CONFS_2B_OPCODE(M_FND_CONFS_OPCODE_RELAY_STATUS));
    b576:	21a2      	movs	r1, #162	; 0xa2
    {
        // Get pointer to data
        uint8_t *p_data = M_TB_BUF_DATA(p_buf_status);

        // Write relay state and relay retransmit state
        *p_data = m_tb_state_get_relay_state(p_data + 1);
    b578:	7020      	strb	r0, [r4, #0]

        // Send the message
        m_fnd_confs_send(p_buf_status, M_FND_CONFS_2B_OPCODE(M_FND_CONFS_OPCODE_RELAY_STATUS));
    b57a:	0189      	lsls	r1, r1, #6
    b57c:	980e      	ldr	r0, [sp, #56]	; 0x38
    b57e:	f7fe ffea 	bl	a556 <m_fnd_confs_send>

        // Check if an Heartbeat message must be sent
        m_tb_state_hb_check_features();
    b582:	f009 f82b 	bl	145dc <m_tb_state_hb_check_features>
    b586:	e1fb      	b.n	b980 <m_fnd_confs_process+0xe64>
__STATIC void m_fnd_confs_handler_key_refresh_phase(m_tb_buf_t *p_buf, uint8_t opcode)
{
    do
    {
        // Get pointer to data
        uint8_t *p_data = M_TB_BUF_DATA(p_buf);
    b588:	002a      	movs	r2, r5
        // Get NetKey index
        uint16_t netkey_id = co_read16p(p_data);
        // Network key local index
        uint8_t net_key_lid = M_INVALID_LID;
    b58a:	261e      	movs	r6, #30
__STATIC void m_fnd_confs_handler_key_refresh_phase(m_tb_buf_t *p_buf, uint8_t opcode)
{
    do
    {
        // Get pointer to data
        uint8_t *p_data = M_TB_BUF_DATA(p_buf);
    b58c:	88ab      	ldrh	r3, [r5, #4]
    b58e:	3230      	adds	r2, #48	; 0x30
    b590:	18d5      	adds	r5, r2, r3
 * @return The 16 bits value.
 ****************************************************************************************
 */
__INLINE_S__ uint16_t co_read16p(void const *ptr16)
{
    uint16_t value = ((uint8_t *)ptr16)[0] | ((uint8_t *)ptr16)[1] << 8;
    b592:	786c      	ldrb	r4, [r5, #1]
    b594:	782b      	ldrb	r3, [r5, #0]
    b596:	0224      	lsls	r4, r4, #8
    b598:	431c      	orrs	r4, r3
    b59a:	b224      	sxth	r4, r4
    b59c:	b2a3      	uxth	r3, r4
    b59e:	9305      	str	r3, [sp, #20]
        // Get NetKey index
        uint16_t netkey_id = co_read16p(p_data);
        // Network key local index
        uint8_t net_key_lid = M_INVALID_LID;
    b5a0:	ab06      	add	r3, sp, #24
    b5a2:	18f6      	adds	r6, r6, r3
    b5a4:	23ff      	movs	r3, #255	; 0xff
        // Check that provided network key is known
        uint16_t status = m_tb_key_net_find(netkey_id, &net_key_lid);
    b5a6:	0031      	movs	r1, r6
    b5a8:	b2a0      	uxth	r0, r4
        // Get pointer to data
        uint8_t *p_data = M_TB_BUF_DATA(p_buf);
        // Get NetKey index
        uint16_t netkey_id = co_read16p(p_data);
        // Network key local index
        uint8_t net_key_lid = M_INVALID_LID;
    b5aa:	7033      	strb	r3, [r6, #0]
        // Check that provided network key is known
        uint16_t status = m_tb_key_net_find(netkey_id, &net_key_lid);
    b5ac:	f006 fe6c 	bl	12288 <m_tb_key_net_find>
    b5b0:	1e07      	subs	r7, r0, #0

        if ((status == M_ERR_NO_ERROR) && (opcode == M_FND_CONFS_OPCODE_KEY_REFRESH_PHASE_SET))
    b5b2:	d008      	beq.n	b5c6 <m_fnd_confs_process+0xaaa>
                break;
            }
        }

        // Send Config Key Refresh Phase Status message
        m_fnd_confs_send_key_refresh_phase_status(status, netkey_id, net_key_lid);
    b5b4:	7833      	ldrb	r3, [r6, #0]
                                                        uint8_t net_key_lid)
{
    // Pointer to the buffer that will contain the message
    m_tb_buf_t *p_buf_status;

    if (m_fnd_confs_buf_alloc(&p_buf_status, M_FND_CONFS_KEY_REFRESH_PHASE_STATUS_LEN) == M_ERR_NO_ERROR)
    b5b6:	2104      	movs	r1, #4
    b5b8:	a80e      	add	r0, sp, #56	; 0x38
                break;
            }
        }

        // Send Config Key Refresh Phase Status message
        m_fnd_confs_send_key_refresh_phase_status(status, netkey_id, net_key_lid);
    b5ba:	9304      	str	r3, [sp, #16]
                                                        uint8_t net_key_lid)
{
    // Pointer to the buffer that will contain the message
    m_tb_buf_t *p_buf_status;

    if (m_fnd_confs_buf_alloc(&p_buf_status, M_FND_CONFS_KEY_REFRESH_PHASE_STATUS_LEN) == M_ERR_NO_ERROR)
    b5bc:	f7fe ffc4 	bl	a548 <m_fnd_confs_buf_alloc>
    b5c0:	1e06      	subs	r6, r0, #0
    b5c2:	d00b      	beq.n	b5dc <m_fnd_confs_process+0xac0>
    b5c4:	e1dc      	b.n	b980 <m_fnd_confs_process+0xe64>
        // Network key local index
        uint8_t net_key_lid = M_INVALID_LID;
        // Check that provided network key is known
        uint16_t status = m_tb_key_net_find(netkey_id, &net_key_lid);

        if ((status == M_ERR_NO_ERROR) && (opcode == M_FND_CONFS_OPCODE_KEY_REFRESH_PHASE_SET))
    b5c6:	9b04      	ldr	r3, [sp, #16]
    b5c8:	2b16      	cmp	r3, #22
    b5ca:	d1f3      	bne.n	b5b4 <m_fnd_confs_process+0xa98>
        {
            // Get new key refresh phase transition
            uint8_t transition = *(p_data + 2);

            // Inform the key manager about received transition value
            if (m_tb_key_phase_transition_ind(net_key_lid, transition) != M_ERR_NO_ERROR)
    b5cc:	78a9      	ldrb	r1, [r5, #2]
    b5ce:	7830      	ldrb	r0, [r6, #0]
    b5d0:	f007 fc8a 	bl	12ee8 <m_tb_key_phase_transition_ind>
    b5d4:	2800      	cmp	r0, #0
    b5d6:	d000      	beq.n	b5da <m_fnd_confs_process+0xabe>
    b5d8:	e1d2      	b.n	b980 <m_fnd_confs_process+0xe64>
    b5da:	e7eb      	b.n	b5b4 <m_fnd_confs_process+0xa98>
    m_tb_buf_t *p_buf_status;

    if (m_fnd_confs_buf_alloc(&p_buf_status, M_FND_CONFS_KEY_REFRESH_PHASE_STATUS_LEN) == M_ERR_NO_ERROR)
    {
        // Get pointer to data
        uint8_t *p_data = M_TB_BUF_DATA(p_buf_status);
    b5dc:	9b0e      	ldr	r3, [sp, #56]	; 0x38

        // Write status
        *p_data = m_fnd_confs_get_air_status(status);
    b5de:	0038      	movs	r0, r7
    m_tb_buf_t *p_buf_status;

    if (m_fnd_confs_buf_alloc(&p_buf_status, M_FND_CONFS_KEY_REFRESH_PHASE_STATUS_LEN) == M_ERR_NO_ERROR)
    {
        // Get pointer to data
        uint8_t *p_data = M_TB_BUF_DATA(p_buf_status);
    b5e0:	001d      	movs	r5, r3
    b5e2:	889b      	ldrh	r3, [r3, #4]
    b5e4:	3530      	adds	r5, #48	; 0x30
    b5e6:	18ed      	adds	r5, r5, r3

        // Write status
        *p_data = m_fnd_confs_get_air_status(status);
    b5e8:	f7fe ff9f 	bl	a52a <m_fnd_confs_get_air_status>
__INLINE_S__ void co_write16p(void const *ptr16, uint16_t value)
{
    uint8_t *ptr=(uint8_t*)ptr16;

    *ptr++ = value&0xff;
    *ptr = (value&0xff00)>>8;
    b5ec:	9b05      	ldr	r3, [sp, #20]
    b5ee:	7028      	strb	r0, [r5, #0]
    b5f0:	0a1b      	lsrs	r3, r3, #8
 */
__INLINE_S__ void co_write16p(void const *ptr16, uint16_t value)
{
    uint8_t *ptr=(uint8_t*)ptr16;

    *ptr++ = value&0xff;
    b5f2:	706c      	strb	r4, [r5, #1]
    *ptr = (value&0xff00)>>8;
    b5f4:	70ab      	strb	r3, [r5, #2]
        // Write NetKey index
        co_write16p(p_data + 1, netkey_id);
        // Write current key refresh phase
        *(p_data + 3) = (status == M_ERR_NO_ERROR) ? m_tb_key_get_phase(net_key_lid) : 0;
    b5f6:	0030      	movs	r0, r6
    b5f8:	2f00      	cmp	r7, #0
    b5fa:	d102      	bne.n	b602 <m_fnd_confs_process+0xae6>
    b5fc:	9804      	ldr	r0, [sp, #16]
    b5fe:	f007 fbe5 	bl	12dcc <m_tb_key_get_phase>

        // Send the message
        m_fnd_confs_send(p_buf_status, M_FND_CONFS_2B_OPCODE(M_FND_CONFS_OPCODE_KEY_REFRESH_PHASE_STATUS));
    b602:	21bc      	movs	r1, #188	; 0xbc
        // Write status
        *p_data = m_fnd_confs_get_air_status(status);
        // Write NetKey index
        co_write16p(p_data + 1, netkey_id);
        // Write current key refresh phase
        *(p_data + 3) = (status == M_ERR_NO_ERROR) ? m_tb_key_get_phase(net_key_lid) : 0;
    b604:	70e8      	strb	r0, [r5, #3]

        // Send the message
        m_fnd_confs_send(p_buf_status, M_FND_CONFS_2B_OPCODE(M_FND_CONFS_OPCODE_KEY_REFRESH_PHASE_STATUS));
    b606:	0149      	lsls	r1, r1, #5
    b608:	980e      	ldr	r0, [sp, #56]	; 0x38
    b60a:	f7fe ffa4 	bl	a556 <m_fnd_confs_send>
    b60e:	e1b7      	b.n	b980 <m_fnd_confs_process+0xe64>
__STATIC void m_fnd_confs_handler_node_id(m_tb_buf_t *p_buf, uint8_t opcode)
{
    do
    {
        // Get pointer to data
        uint8_t *p_data = M_TB_BUF_DATA(p_buf);
    b610:	002a      	movs	r2, r5
    b612:	88ab      	ldrh	r3, [r5, #4]
    b614:	3230      	adds	r2, #48	; 0x30
    b616:	18d2      	adds	r2, r2, r3
 * @return The 16 bits value.
 ****************************************************************************************
 */
__INLINE_S__ uint16_t co_read16p(void const *ptr16)
{
    uint16_t value = ((uint8_t *)ptr16)[0] | ((uint8_t *)ptr16)[1] << 8;
    b618:	7853      	ldrb	r3, [r2, #1]
    b61a:	7812      	ldrb	r2, [r2, #0]
    b61c:	021b      	lsls	r3, r3, #8
    b61e:	4313      	orrs	r3, r2
    b620:	b21b      	sxth	r3, r3
    b622:	9304      	str	r3, [sp, #16]
    b624:	466b      	mov	r3, sp
        // Get NetKey index
        uint16_t netkey_id = co_read16p(p_data);
        // Network key local index
        uint8_t net_key_lid = M_INVALID_LID;
    b626:	241e      	movs	r4, #30
    b628:	8a1f      	ldrh	r7, [r3, #16]
    b62a:	ab06      	add	r3, sp, #24
    b62c:	18e4      	adds	r4, r4, r3
    b62e:	23ff      	movs	r3, #255	; 0xff
        // Status
        uint16_t status = M_ERR_NO_ERROR;

        // Check that provided network key is known
        status = m_tb_key_net_find(netkey_id, &net_key_lid);
    b630:	0021      	movs	r1, r4
    b632:	0038      	movs	r0, r7
        // Get pointer to data
        uint8_t *p_data = M_TB_BUF_DATA(p_buf);
        // Get NetKey index
        uint16_t netkey_id = co_read16p(p_data);
        // Network key local index
        uint8_t net_key_lid = M_INVALID_LID;
    b634:	7023      	strb	r3, [r4, #0]
        // Status
        uint16_t status = M_ERR_NO_ERROR;

        // Check that provided network key is known
        status = m_tb_key_net_find(netkey_id, &net_key_lid);
    b636:	f006 fe27 	bl	12288 <m_tb_key_net_find>
__STATIC void m_fnd_confs_send_node_id_status(uint16_t status, uint16_t netkey_id, uint8_t net_key_lid)
{
    // Pointer to the buffer that will contain the message
    m_tb_buf_t *p_buf_status;

    if (m_fnd_confs_buf_alloc(&p_buf_status, M_FND_CONFS_NODE_ID_STATUS_LEN) == M_ERR_NO_ERROR)
    b63a:	2104      	movs	r1, #4
        uint8_t net_key_lid = M_INVALID_LID;
        // Status
        uint16_t status = M_ERR_NO_ERROR;

        // Check that provided network key is known
        status = m_tb_key_net_find(netkey_id, &net_key_lid);
    b63c:	9005      	str	r0, [sp, #20]
__STATIC void m_fnd_confs_send_node_id_status(uint16_t status, uint16_t netkey_id, uint8_t net_key_lid)
{
    // Pointer to the buffer that will contain the message
    m_tb_buf_t *p_buf_status;

    if (m_fnd_confs_buf_alloc(&p_buf_status, M_FND_CONFS_NODE_ID_STATUS_LEN) == M_ERR_NO_ERROR)
    b63e:	a80e      	add	r0, sp, #56	; 0x38
            }
        }
        #endif //(BLE_MESH_GATT_PROXY)

        // Send Config Node Identity Status message
        m_fnd_confs_send_node_id_status(status, netkey_id, net_key_lid);
    b640:	7826      	ldrb	r6, [r4, #0]
__STATIC void m_fnd_confs_send_node_id_status(uint16_t status, uint16_t netkey_id, uint8_t net_key_lid)
{
    // Pointer to the buffer that will contain the message
    m_tb_buf_t *p_buf_status;

    if (m_fnd_confs_buf_alloc(&p_buf_status, M_FND_CONFS_NODE_ID_STATUS_LEN) == M_ERR_NO_ERROR)
    b642:	f7fe ff81 	bl	a548 <m_fnd_confs_buf_alloc>
    b646:	1e05      	subs	r5, r0, #0
    b648:	d000      	beq.n	b64c <m_fnd_confs_process+0xb30>
    b64a:	e199      	b.n	b980 <m_fnd_confs_process+0xe64>
    {
        // Get pointer to data
        uint8_t *p_data = M_TB_BUF_DATA(p_buf_status);
    b64c:	9b0e      	ldr	r3, [sp, #56]	; 0x38

        // Write status
        *p_data = m_fnd_confs_get_air_status(status);
    b64e:	9805      	ldr	r0, [sp, #20]
    m_tb_buf_t *p_buf_status;

    if (m_fnd_confs_buf_alloc(&p_buf_status, M_FND_CONFS_NODE_ID_STATUS_LEN) == M_ERR_NO_ERROR)
    {
        // Get pointer to data
        uint8_t *p_data = M_TB_BUF_DATA(p_buf_status);
    b650:	001c      	movs	r4, r3
    b652:	889b      	ldrh	r3, [r3, #4]
    b654:	3430      	adds	r4, #48	; 0x30
    b656:	18e4      	adds	r4, r4, r3

        // Write status
        *p_data = m_fnd_confs_get_air_status(status);
    b658:	f7fe ff67 	bl	a52a <m_fnd_confs_get_air_status>
 */
__INLINE_S__ void co_write16p(void const *ptr16, uint16_t value)
{
    uint8_t *ptr=(uint8_t*)ptr16;

    *ptr++ = value&0xff;
    b65c:	466b      	mov	r3, sp
    b65e:	7c1b      	ldrb	r3, [r3, #16]
    b660:	7020      	strb	r0, [r4, #0]
    b662:	7063      	strb	r3, [r4, #1]
    *ptr = (value&0xff00)>>8;
    b664:	0a3b      	lsrs	r3, r7, #8
    b666:	70a3      	strb	r3, [r4, #2]
        // Write NetKey index
        co_write16p(p_data + 1, netkey_id);

        // Write current node identity state
        if (net_key_lid != M_INVALID_LID)
    b668:	2eff      	cmp	r6, #255	; 0xff
    b66a:	d004      	beq.n	b676 <m_fnd_confs_process+0xb5a>
        {
            *(p_data + 3) = m_tb_key_get_node_identity(net_key_lid);
    b66c:	0030      	movs	r0, r6
    b66e:	f007 fb73 	bl	12d58 <m_tb_key_get_node_identity>
    b672:	70e0      	strb	r0, [r4, #3]
    b674:	e000      	b.n	b678 <m_fnd_confs_process+0xb5c>
        }
        else
        {
            *(p_data + 3) = 0;
    b676:	70e5      	strb	r5, [r4, #3]
        }

        // Send the message
        m_fnd_confs_send(p_buf_status, M_FND_CONFS_2B_OPCODE(M_FND_CONFS_OPCODE_NODE_ID_STATUS));
    b678:	2191      	movs	r1, #145	; 0x91
    b67a:	980e      	ldr	r0, [sp, #56]	; 0x38
    b67c:	01c9      	lsls	r1, r1, #7
    b67e:	f7fe ff6a 	bl	a556 <m_fnd_confs_send>
    b682:	e17d      	b.n	b980 <m_fnd_confs_process+0xe64>
__STATIC void m_fnd_confs_send_node_reset_status(void)
{
    // Pointer to the buffer that will contain the message
    m_tb_buf_t *p_buf_status;

    if (m_fnd_confs_buf_alloc(&p_buf_status, M_FND_CONFS_NODE_RESET_STATUS_LEN) == M_ERR_NO_ERROR)
    b684:	2100      	movs	r1, #0
    b686:	a80e      	add	r0, sp, #56	; 0x38
    b688:	f7fe ff5e 	bl	a548 <m_fnd_confs_buf_alloc>
    b68c:	2800      	cmp	r0, #0
    b68e:	d000      	beq.n	b692 <m_fnd_confs_process+0xb76>
    b690:	e176      	b.n	b980 <m_fnd_confs_process+0xe64>
    {
        // Keep the buffer pointer
        p_m_fnd_confs_env->p_buf_reset = p_buf_status;

        // Send the message
        m_fnd_confs_send(p_buf_status, M_FND_CONFS_2B_OPCODE(M_FND_CONFS_OPCODE_NODE_RESET_STATUS));
    b692:	2195      	movs	r1, #149	; 0x95
    m_tb_buf_t *p_buf_status;

    if (m_fnd_confs_buf_alloc(&p_buf_status, M_FND_CONFS_NODE_RESET_STATUS_LEN) == M_ERR_NO_ERROR)
    {
        // Keep the buffer pointer
        p_m_fnd_confs_env->p_buf_reset = p_buf_status;
    b694:	980e      	ldr	r0, [sp, #56]	; 0x38
    b696:	6833      	ldr	r3, [r6, #0]

        // Send the message
        m_fnd_confs_send(p_buf_status, M_FND_CONFS_2B_OPCODE(M_FND_CONFS_OPCODE_NODE_RESET_STATUS));
    b698:	01c9      	lsls	r1, r1, #7
    m_tb_buf_t *p_buf_status;

    if (m_fnd_confs_buf_alloc(&p_buf_status, M_FND_CONFS_NODE_RESET_STATUS_LEN) == M_ERR_NO_ERROR)
    {
        // Keep the buffer pointer
        p_m_fnd_confs_env->p_buf_reset = p_buf_status;
    b69a:	6158      	str	r0, [r3, #20]

        // Send the message
        m_fnd_confs_send(p_buf_status, M_FND_CONFS_2B_OPCODE(M_FND_CONFS_OPCODE_NODE_RESET_STATUS));
    b69c:	f7fe ff5b 	bl	a556 <m_fnd_confs_send>
    b6a0:	e16e      	b.n	b980 <m_fnd_confs_process+0xe64>
 * @param[in] p_buf     Pointer to the buffer containing the message.
 ****************************************************************************************
 */
__STATIC void m_fnd_confs_handler_compo_data_get(m_tb_buf_t *p_buf)
{
	M_PRINTF(L_FND, "");
    b6a2:	4bb9      	ldr	r3, [pc, #740]	; (b988 <m_fnd_confs_process+0xe6c>)
    b6a4:	681b      	ldr	r3, [r3, #0]
    b6a6:	051b      	lsls	r3, r3, #20
    b6a8:	d515      	bpl.n	b6d6 <m_fnd_confs_process+0xbba>
    b6aa:	4bb8      	ldr	r3, [pc, #736]	; (b98c <m_fnd_confs_process+0xe70>)
    b6ac:	4cb8      	ldr	r4, [pc, #736]	; (b990 <m_fnd_confs_process+0xe74>)
    b6ae:	3346      	adds	r3, #70	; 0x46
    b6b0:	9300      	str	r3, [sp, #0]
    b6b2:	0022      	movs	r2, r4
    b6b4:	0020      	movs	r0, r4
    b6b6:	23b8      	movs	r3, #184	; 0xb8
    b6b8:	0021      	movs	r1, r4
    b6ba:	3253      	adds	r2, #83	; 0x53
    b6bc:	011b      	lsls	r3, r3, #4
    b6be:	3061      	adds	r0, #97	; 0x61
    b6c0:	f7f9 f974 	bl	49ac <m_print>
    b6c4:	0038      	movs	r0, r7
    b6c6:	3074      	adds	r0, #116	; 0x74
    b6c8:	f7f9 f970 	bl	49ac <m_print>
    b6cc:	0038      	movs	r0, r7
    b6ce:	1da1      	adds	r1, r4, #6
    b6d0:	3022      	adds	r0, #34	; 0x22
    b6d2:	f7f9 f96b 	bl	49ac <m_print>
    // Get requested page
    uint8_t page = *M_TB_BUF_DATA(p_buf);
    b6d6:	88ab      	ldrh	r3, [r5, #4]
    b6d8:	18ed      	adds	r5, r5, r3
    b6da:	3530      	adds	r5, #48	; 0x30
    b6dc:	782d      	ldrb	r5, [r5, #0]
    // Get number of pages in the composition data
    uint8_t nb_cdata_page = m_tb_state_get_nb_cdata_page();
    b6de:	f008 fec9 	bl	14474 <m_tb_state_get_nb_cdata_page>

    // Check page value
    if (page >= nb_cdata_page)
    b6e2:	4285      	cmp	r5, r0
    b6e4:	d301      	bcc.n	b6ea <m_fnd_confs_process+0xbce>
    {
        page = nb_cdata_page - 1;
    b6e6:	3801      	subs	r0, #1
    b6e8:	b2c5      	uxtb	r5, r0
    }

    // Page 0 is generated locally
    if (page != 0)
    b6ea:	2d00      	cmp	r5, #0
    b6ec:	d004      	beq.n	b6f8 <m_fnd_confs_process+0xbdc>
    {
        // Request page of composition data
        m_tb_store_get_compo_data(page, m_fnd_confs_cb_compo_data);
    b6ee:	49a9      	ldr	r1, [pc, #676]	; (b994 <m_fnd_confs_process+0xe78>)
    b6f0:	0028      	movs	r0, r5
    b6f2:	f009 fc5d 	bl	14fb0 <m_tb_store_get_compo_data>
    b6f6:	e145      	b.n	b984 <m_fnd_confs_process+0xe68>
        uint16_t length;
        // Pointer to composition data
        uint8_t *p_data;

        // Get number of registered SIG and Vendor Models
        m_tb_mio_get_nb_models(&nb_sig_models, &nb_vendor_models);
    b6f8:	2617      	movs	r6, #23
    b6fa:	2716      	movs	r7, #22
    b6fc:	ab06      	add	r3, sp, #24
    b6fe:	18ff      	adds	r7, r7, r3
    b700:	18f6      	adds	r6, r6, r3
    b702:	0031      	movs	r1, r6
    b704:	0038      	movs	r0, r7
    b706:	f008 f9cd 	bl	13aa4 <m_tb_mio_get_nb_models>

        // Compute page length
        length = 14 + (nb_sig_models * 2) + (nb_vendor_models * 4);
    b70a:	7839      	ldrb	r1, [r7, #0]
    b70c:	7833      	ldrb	r3, [r6, #0]
    b70e:	3107      	adds	r1, #7
    b710:	005b      	lsls	r3, r3, #1
    b712:	18c9      	adds	r1, r1, r3
    b714:	0049      	lsls	r1, r1, #1
    b716:	b28b      	uxth	r3, r1

        // Allocate memory in order to build composition data
        p_data = m_al_malloc(length);
    b718:	0018      	movs	r0, r3

        // Get number of registered SIG and Vendor Models
        m_tb_mio_get_nb_models(&nb_sig_models, &nb_vendor_models);

        // Compute page length
        length = 14 + (nb_sig_models * 2) + (nb_vendor_models * 4);
    b71a:	9304      	str	r3, [sp, #16]

        // Allocate memory in order to build composition data
        p_data = m_al_malloc(length);
    b71c:	f7f9 ff59 	bl	55d2 <m_al_malloc>
    b720:	1e04      	subs	r4, r0, #0

        if (p_data)
    b722:	d100      	bne.n	b726 <m_fnd_confs_process+0xc0a>
    b724:	e12e      	b.n	b984 <m_fnd_confs_process+0xe68>
        {
            // CID, VID, PID, features and Location values
            uint16_t cid, vid, pid, feat, loc;

            // Get information stored by State Manager
            m_tb_state_get_compo_info(&cid, &pid, &vid, &feat, &loc);
    b726:	ab0e      	add	r3, sp, #56	; 0x38
    b728:	9300      	str	r3, [sp, #0]
    b72a:	231e      	movs	r3, #30
    b72c:	aa06      	add	r2, sp, #24
    b72e:	189b      	adds	r3, r3, r2
    b730:	221a      	movs	r2, #26
    b732:	a906      	add	r1, sp, #24
    b734:	1852      	adds	r2, r2, r1
    b736:	a80c      	add	r0, sp, #48	; 0x30
    b738:	a90d      	add	r1, sp, #52	; 0x34
    b73a:	f008 fea3 	bl	14484 <m_tb_state_get_compo_info>

            // And write these values
            co_write16p(p_data + 0, cid);
    b73e:	ab06      	add	r3, sp, #24
    b740:	8b1b      	ldrh	r3, [r3, #24]
 */
__INLINE_S__ void co_write16p(void const *ptr16, uint16_t value)
{
    uint8_t *ptr=(uint8_t*)ptr16;

    *ptr++ = value&0xff;
    b742:	7023      	strb	r3, [r4, #0]
    *ptr = (value&0xff00)>>8;
    b744:	0a1b      	lsrs	r3, r3, #8
    b746:	7063      	strb	r3, [r4, #1]
            co_write16p(p_data + 2, pid);
    b748:	ab06      	add	r3, sp, #24
    b74a:	8b9b      	ldrh	r3, [r3, #28]
            co_write16p(p_data + 10, loc);
            // Write size of relay protection list
            co_write16p(p_data + 6, M_LAY_NET_MSG_CACHE_SIZE);
            // Write number of Models
            *(p_data + 12) = nb_sig_models;
            *(p_data + 13) = nb_vendor_models;
    b74c:	7832      	ldrb	r2, [r6, #0]
 */
__INLINE_S__ void co_write16p(void const *ptr16, uint16_t value)
{
    uint8_t *ptr=(uint8_t*)ptr16;

    *ptr++ = value&0xff;
    b74e:	70a3      	strb	r3, [r4, #2]
    *ptr = (value&0xff00)>>8;
    b750:	0a1b      	lsrs	r3, r3, #8
    b752:	70e3      	strb	r3, [r4, #3]
            m_tb_state_get_compo_info(&cid, &pid, &vid, &feat, &loc);

            // And write these values
            co_write16p(p_data + 0, cid);
            co_write16p(p_data + 2, pid);
            co_write16p(p_data + 4, vid);
    b754:	ab06      	add	r3, sp, #24
    b756:	8b5b      	ldrh	r3, [r3, #26]
 */
__INLINE_S__ void co_write16p(void const *ptr16, uint16_t value)
{
    uint8_t *ptr=(uint8_t*)ptr16;

    *ptr++ = value&0xff;
    b758:	7123      	strb	r3, [r4, #4]
    *ptr = (value&0xff00)>>8;
    b75a:	0a1b      	lsrs	r3, r3, #8
    b75c:	7163      	strb	r3, [r4, #5]
            co_write16p(p_data + 8, feat);
    b75e:	ab06      	add	r3, sp, #24
    b760:	8bdb      	ldrh	r3, [r3, #30]
 */
__INLINE_S__ void co_write16p(void const *ptr16, uint16_t value)
{
    uint8_t *ptr=(uint8_t*)ptr16;

    *ptr++ = value&0xff;
    b762:	7223      	strb	r3, [r4, #8]
    *ptr = (value&0xff00)>>8;
    b764:	0a1b      	lsrs	r3, r3, #8
    b766:	7263      	strb	r3, [r4, #9]
            co_write16p(p_data + 10, loc);
    b768:	ab06      	add	r3, sp, #24
    b76a:	8c1b      	ldrh	r3, [r3, #32]
    b76c:	71e5      	strb	r5, [r4, #7]
 */
__INLINE_S__ void co_write16p(void const *ptr16, uint16_t value)
{
    uint8_t *ptr=(uint8_t*)ptr16;

    *ptr++ = value&0xff;
    b76e:	72a3      	strb	r3, [r4, #10]
    *ptr = (value&0xff00)>>8;
    b770:	0a1b      	lsrs	r3, r3, #8
    b772:	72e3      	strb	r3, [r4, #11]
 */
__INLINE_S__ void co_write16p(void const *ptr16, uint16_t value)
{
    uint8_t *ptr=(uint8_t*)ptr16;

    *ptr++ = value&0xff;
    b774:	2305      	movs	r3, #5
    b776:	71a3      	strb	r3, [r4, #6]
            // Write size of relay protection list
            co_write16p(p_data + 6, M_LAY_NET_MSG_CACHE_SIZE);
            // Write number of Models
            *(p_data + 12) = nb_sig_models;
    b778:	783b      	ldrb	r3, [r7, #0]
            *(p_data + 13) = nb_vendor_models;
    b77a:	7362      	strb	r2, [r4, #13]
            co_write16p(p_data + 8, feat);
            co_write16p(p_data + 10, loc);
            // Write size of relay protection list
            co_write16p(p_data + 6, M_LAY_NET_MSG_CACHE_SIZE);
            // Write number of Models
            *(p_data + 12) = nb_sig_models;
    b77c:	7323      	strb	r3, [r4, #12]
            *(p_data + 13) = nb_vendor_models;

            if (nb_sig_models)
    b77e:	2b00      	cmp	r3, #0
    b780:	d004      	beq.n	b78c <m_fnd_confs_process+0xc70>
            {
                // Get SIG Model IDs from Model IO Manager
                m_tb_mio_get_model_ids(p_data + 14, false);
    b782:	0020      	movs	r0, r4
    b784:	0029      	movs	r1, r5
    b786:	300e      	adds	r0, #14
    b788:	f008 f9ae 	bl	13ae8 <m_tb_mio_get_model_ids>
            }

            if (nb_vendor_models)
    b78c:	2317      	movs	r3, #23
    b78e:	aa06      	add	r2, sp, #24
    b790:	189b      	adds	r3, r3, r2
    b792:	781b      	ldrb	r3, [r3, #0]
    b794:	2b00      	cmp	r3, #0
    b796:	d008      	beq.n	b7aa <m_fnd_confs_process+0xc8e>
            {
                // Get Vendor Model IDs from Model IO Manager
                m_tb_mio_get_model_ids(p_data + 14 + (nb_sig_models * 2), true);
    b798:	2316      	movs	r3, #22
    b79a:	189b      	adds	r3, r3, r2
    b79c:	7818      	ldrb	r0, [r3, #0]
    b79e:	2101      	movs	r1, #1
    b7a0:	0040      	lsls	r0, r0, #1
    b7a2:	300e      	adds	r0, #14
    b7a4:	1820      	adds	r0, r4, r0
    b7a6:	f008 f99f 	bl	13ae8 <m_tb_mio_get_model_ids>
            }

            // Send Config Composition Data Status
            m_fnd_confs_send_compo_data_status(0, length, p_data);
    b7aa:	466b      	mov	r3, sp
    b7ac:	0022      	movs	r2, r4
    b7ae:	7c19      	ldrb	r1, [r3, #16]
    b7b0:	2000      	movs	r0, #0
    b7b2:	f7ff f805 	bl	a7c0 <m_fnd_confs_send_compo_data_status>

            // Free allocated memory
            m_al_free(p_data);
    b7b6:	0020      	movs	r0, r4
    b7b8:	f7f9 ff10 	bl	55dc <m_al_free>
    b7bc:	e0e2      	b.n	b984 <m_fnd_confs_process+0xe68>
__STATIC void m_fnd_confs_handler_hbeat_pub(m_tb_buf_t *p_buf, uint8_t opcode)
{
    // Status
    uint16_t status = M_ERR_NO_ERROR;

    if (opcode == M_FND_CONFS_OPCODE_HBEAT_PUB_SET)
    b7be:	9b04      	ldr	r3, [sp, #16]
    b7c0:	af0e      	add	r7, sp, #56	; 0x38
 ****************************************************************************************
 */
__STATIC void m_fnd_confs_handler_hbeat_pub(m_tb_buf_t *p_buf, uint8_t opcode)
{
    // Status
    uint16_t status = M_ERR_NO_ERROR;
    b7c2:	2400      	movs	r4, #0

    if (opcode == M_FND_CONFS_OPCODE_HBEAT_PUB_SET)
    b7c4:	2b39      	cmp	r3, #57	; 0x39
    b7c6:	d11d      	bne.n	b804 <m_fnd_confs_process+0xce8>
    {
        // Get pointer to data
        uint8_t *p_data = M_TB_BUF_DATA(p_buf);
    b7c8:	002a      	movs	r2, r5
    b7ca:	88ab      	ldrh	r3, [r5, #4]
    b7cc:	3230      	adds	r2, #48	; 0x30
    b7ce:	18d5      	adds	r5, r2, r3
        uint16_t netkey_id = co_read16p(p_data + 7);
        // Network key local index
        m_lid_t net_key_lid;

        // Look for network key
        status = m_tb_key_net_find(netkey_id, &net_key_lid);
    b7d0:	7a28      	ldrb	r0, [r5, #8]
    b7d2:	79eb      	ldrb	r3, [r5, #7]
    b7d4:	0200      	lsls	r0, r0, #8
    b7d6:	4318      	orrs	r0, r3
    b7d8:	0039      	movs	r1, r7
    b7da:	f006 fd55 	bl	12288 <m_tb_key_net_find>
    b7de:	1e04      	subs	r4, r0, #0

        if (status == M_ERR_NO_ERROR)
    b7e0:	d110      	bne.n	b804 <m_fnd_confs_process+0xce8>
        {
            // Try to set the new parameters
            status = m_tb_state_set_hb_pub_params(co_read16p(p_data), *(p_data + 2), *(p_data + 3),
    b7e2:	7868      	ldrb	r0, [r5, #1]
    b7e4:	782c      	ldrb	r4, [r5, #0]
    b7e6:	0200      	lsls	r0, r0, #8
    b7e8:	4320      	orrs	r0, r4
    b7ea:	783c      	ldrb	r4, [r7, #0]
    b7ec:	792b      	ldrb	r3, [r5, #4]
    b7ee:	78ea      	ldrb	r2, [r5, #3]
    b7f0:	78a9      	ldrb	r1, [r5, #2]
    b7f2:	9401      	str	r4, [sp, #4]
    b7f4:	79ac      	ldrb	r4, [r5, #6]
    b7f6:	796d      	ldrb	r5, [r5, #5]
    b7f8:	0224      	lsls	r4, r4, #8
    b7fa:	432c      	orrs	r4, r5
    b7fc:	9400      	str	r4, [sp, #0]
    b7fe:	f008 fd3b 	bl	14278 <m_tb_state_set_hb_pub_params>
    b802:	0004      	movs	r4, r0
__STATIC void m_fnd_confs_send_hbeat_pub_status(uint16_t status)
{
    // Pointer to the buffer that will contain the message
    m_tb_buf_t *p_buf_status;

    if (m_fnd_confs_buf_alloc(&p_buf_status, M_FND_CONFS_HBEAT_PUB_STATUS_LEN) == M_ERR_NO_ERROR)
    b804:	0038      	movs	r0, r7
    b806:	210a      	movs	r1, #10
    b808:	f7fe fe9e 	bl	a548 <m_fnd_confs_buf_alloc>
    b80c:	1e07      	subs	r7, r0, #0
    b80e:	d000      	beq.n	b812 <m_fnd_confs_process+0xcf6>
    b810:	e0b6      	b.n	b980 <m_fnd_confs_process+0xe64>
    {
        // Get pointer to data
        uint8_t *p_data = M_TB_BUF_DATA(p_buf_status);
    b812:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    b814:	001d      	movs	r5, r3
    b816:	889b      	ldrh	r3, [r3, #4]
    b818:	3530      	adds	r5, #48	; 0x30
    b81a:	18ed      	adds	r5, r5, r3

        if (status == M_ERR_NO_ERROR)
    b81c:	2c00      	cmp	r4, #0
    b81e:	d130      	bne.n	b882 <m_fnd_confs_process+0xd66>
        {
            // Get heartbeat publication parameters
            m_tb_state_hb_pub_t *p_pub_params = m_tb_state_get_hb_pub_params();
    b820:	f008 fe46 	bl	144b0 <m_tb_state_get_hb_pub_params>

            // Destination address
            co_write16p(p_data + 1, p_pub_params->dst_addr);
    b824:	8803      	ldrh	r3, [r0, #0]
        uint8_t *p_data = M_TB_BUF_DATA(p_buf_status);

        if (status == M_ERR_NO_ERROR)
        {
            // Get heartbeat publication parameters
            m_tb_state_hb_pub_t *p_pub_params = m_tb_state_get_hb_pub_params();
    b826:	0006      	movs	r6, r0
    b828:	706b      	strb	r3, [r5, #1]
    *ptr = (value&0xff00)>>8;
    b82a:	0a1b      	lsrs	r3, r3, #8
    b82c:	70ab      	strb	r3, [r5, #2]

            // Destination address
            co_write16p(p_data + 1, p_pub_params->dst_addr);
            // Features
            co_write16p(p_data + 6, p_pub_params->features);
    b82e:	8903      	ldrh	r3, [r0, #8]
 */
__INLINE_S__ void co_write16p(void const *ptr16, uint16_t value)
{
    uint8_t *ptr=(uint8_t*)ptr16;

    *ptr++ = value&0xff;
    b830:	71ab      	strb	r3, [r5, #6]
    *ptr = (value&0xff00)>>8;
    b832:	0a1b      	lsrs	r3, r3, #8
    b834:	71eb      	strb	r3, [r5, #7]
            // Count Log
            if (p_pub_params->count == 0)
    b836:	8840      	ldrh	r0, [r0, #2]
    b838:	2800      	cmp	r0, #0
    b83a:	d101      	bne.n	b840 <m_fnd_confs_process+0xd24>
            {
                *(p_data + 3) = 0x00;
    b83c:	70ec      	strb	r4, [r5, #3]
    b83e:	e00a      	b.n	b856 <m_fnd_confs_process+0xd3a>
            }
            else if (p_pub_params->count == 0xFFFF)
    b840:	4b55      	ldr	r3, [pc, #340]	; (b998 <m_fnd_confs_process+0xe7c>)
    b842:	4298      	cmp	r0, r3
    b844:	d102      	bne.n	b84c <m_fnd_confs_process+0xd30>
            {
                *(p_data + 3) = 0xFF;
    b846:	23ff      	movs	r3, #255	; 0xff
    b848:	70eb      	strb	r3, [r5, #3]
    b84a:	e004      	b.n	b856 <m_fnd_confs_process+0xd3a>
    b84c:	f012 fae0 	bl	1de10 <__clzsi2>
            }
            else
            {
                *(p_data + 3) = 32 - co_clz(p_pub_params->count);
    b850:	2320      	movs	r3, #32
    b852:	1a18      	subs	r0, r3, r0
    b854:	70e8      	strb	r0, [r5, #3]
            }
            // Period Log
            *(p_data + 4) = (p_pub_params->period_s == 0) ? 0 : (32 - co_clz(p_pub_params->period_s));
    b856:	2300      	movs	r3, #0
    b858:	88b0      	ldrh	r0, [r6, #4]
    b85a:	4298      	cmp	r0, r3
    b85c:	d004      	beq.n	b868 <m_fnd_confs_process+0xd4c>
    b85e:	f012 fad7 	bl	1de10 <__clzsi2>
    b862:	2320      	movs	r3, #32
    b864:	1a1b      	subs	r3, r3, r0
    b866:	b2db      	uxtb	r3, r3
    b868:	712b      	strb	r3, [r5, #4]
            // TTL
            *(p_data + 5) = p_pub_params->ttl;
    b86a:	79b3      	ldrb	r3, [r6, #6]
    b86c:	716b      	strb	r3, [r5, #5]
            // NetKey ID
            co_write16p(p_data + 8, (p_pub_params->net_key_lid != M_INVALID_LID)
    b86e:	79f0      	ldrb	r0, [r6, #7]
    b870:	28ff      	cmp	r0, #255	; 0xff
    b872:	d002      	beq.n	b87a <m_fnd_confs_process+0xd5e>
    b874:	f007 fa66 	bl	12d44 <m_tb_key_get_netkey_id>
    b878:	0007      	movs	r7, r0
 */
__INLINE_S__ void co_write16p(void const *ptr16, uint16_t value)
{
    uint8_t *ptr=(uint8_t*)ptr16;

    *ptr++ = value&0xff;
    b87a:	722f      	strb	r7, [r5, #8]
    *ptr = (value&0xff00)>>8;
    b87c:	0a3f      	lsrs	r7, r7, #8
    b87e:	726f      	strb	r7, [r5, #9]
    b880:	e009      	b.n	b896 <m_fnd_confs_process+0xd7a>
    b882:	6833      	ldr	r3, [r6, #0]
            m_tb_buf_t *p_buf_req = (m_tb_buf_t *)co_list_pick(&p_m_fnd_confs_env->process_queue);
            // Get pointer to request data
            uint8_t *p_data_req = M_TB_BUF_DATA(p_buf_req);

            // Put the received parameters
            memcpy(p_data + 1, p_data_req, M_FND_CONFS_HBEAT_PUB_SET_LEN);
    b884:	1c68      	adds	r0, r5, #1
    b886:	681b      	ldr	r3, [r3, #0]
    b888:	2209      	movs	r2, #9
        else
        {
            // Retrieve buffer containing the message for which a response is sent
            m_tb_buf_t *p_buf_req = (m_tb_buf_t *)co_list_pick(&p_m_fnd_confs_env->process_queue);
            // Get pointer to request data
            uint8_t *p_data_req = M_TB_BUF_DATA(p_buf_req);
    b88a:	0019      	movs	r1, r3

            // Put the received parameters
            memcpy(p_data + 1, p_data_req, M_FND_CONFS_HBEAT_PUB_SET_LEN);
    b88c:	889b      	ldrh	r3, [r3, #4]
        else
        {
            // Retrieve buffer containing the message for which a response is sent
            m_tb_buf_t *p_buf_req = (m_tb_buf_t *)co_list_pick(&p_m_fnd_confs_env->process_queue);
            // Get pointer to request data
            uint8_t *p_data_req = M_TB_BUF_DATA(p_buf_req);
    b88e:	3130      	adds	r1, #48	; 0x30

            // Put the received parameters
            memcpy(p_data + 1, p_data_req, M_FND_CONFS_HBEAT_PUB_SET_LEN);
    b890:	18c9      	adds	r1, r1, r3
    b892:	f00a f89d 	bl	159d0 <memcpy>
        }

        // Write status
        *p_data = m_fnd_confs_get_air_status(status);
    b896:	0020      	movs	r0, r4
    b898:	f7fe fe47 	bl	a52a <m_fnd_confs_get_air_status>
    b89c:	7028      	strb	r0, [r5, #0]

        // Send the message
        m_fnd_confs_send(p_buf_status, M_FND_CONFS_OPCODE_HBEAT_PUB_STATUS);
    b89e:	2106      	movs	r1, #6
    b8a0:	980e      	ldr	r0, [sp, #56]	; 0x38
    b8a2:	f7fe fe58 	bl	a556 <m_fnd_confs_send>
    b8a6:	e06b      	b.n	b980 <m_fnd_confs_process+0xe64>
 ****************************************************************************************
 */
__STATIC void m_fnd_confs_handler_hbeat_subs(m_tb_buf_t *p_buf, uint8_t opcode)
{
    // Status
    uint16_t status = M_ERR_NO_ERROR;
    b8a8:	2300      	movs	r3, #0
    b8aa:	9306      	str	r3, [sp, #24]

    if (opcode == M_FND_CONFS_OPCODE_HBEAT_SUBS_SET)
    b8ac:	9b04      	ldr	r3, [sp, #16]
    b8ae:	2b3b      	cmp	r3, #59	; 0x3b
    b8b0:	d113      	bne.n	b8da <m_fnd_confs_process+0xdbe>
    {
        // Get pointer to data
        uint8_t *p_data = M_TB_BUF_DATA(p_buf);
    b8b2:	002a      	movs	r2, r5
    b8b4:	88ab      	ldrh	r3, [r5, #4]
    b8b6:	3230      	adds	r2, #48	; 0x30
    b8b8:	18d3      	adds	r3, r2, r3

        // Try to set the new parameters
        status = m_tb_state_set_hb_subs_params(co_read16p(p_data), co_read16p(p_data + 2), *(p_data + 4));
    b8ba:	78d9      	ldrb	r1, [r3, #3]
    b8bc:	7898      	ldrb	r0, [r3, #2]
    b8be:	0209      	lsls	r1, r1, #8
    b8c0:	4301      	orrs	r1, r0
    b8c2:	7858      	ldrb	r0, [r3, #1]
    b8c4:	791a      	ldrb	r2, [r3, #4]
    b8c6:	781b      	ldrb	r3, [r3, #0]
    b8c8:	0200      	lsls	r0, r0, #8
    b8ca:	4318      	orrs	r0, r3
    b8cc:	f008 fd20 	bl	14310 <m_tb_state_set_hb_subs_params>
    }

    // PTS test impose to drop Config Heartbeat Subscription Set message if destination or source
    // address is invalid
    if (status != M_ERR_INVALID_ADDR)
    b8d0:	23c0      	movs	r3, #192	; 0xc0
    {
        // Get pointer to data
        uint8_t *p_data = M_TB_BUF_DATA(p_buf);

        // Try to set the new parameters
        status = m_tb_state_set_hb_subs_params(co_read16p(p_data), co_read16p(p_data + 2), *(p_data + 4));
    b8d2:	9006      	str	r0, [sp, #24]
    }

    // PTS test impose to drop Config Heartbeat Subscription Set message if destination or source
    // address is invalid
    if (status != M_ERR_INVALID_ADDR)
    b8d4:	005b      	lsls	r3, r3, #1
    b8d6:	4298      	cmp	r0, r3
    b8d8:	d052      	beq.n	b980 <m_fnd_confs_process+0xe64>
__STATIC void m_fnd_confs_send_hbeat_subs_status(uint16_t status, uint8_t opcode)
{
    // Pointer to the buffer that will contain the message
    m_tb_buf_t *p_buf_status;

    if (m_fnd_confs_buf_alloc(&p_buf_status, M_FND_CONFS_HBEAT_SUBS_STATUS_LEN) == M_ERR_NO_ERROR)
    b8da:	2109      	movs	r1, #9
    b8dc:	a80e      	add	r0, sp, #56	; 0x38
    b8de:	f7fe fe33 	bl	a548 <m_fnd_confs_buf_alloc>
    b8e2:	2800      	cmp	r0, #0
    b8e4:	d14c      	bne.n	b980 <m_fnd_confs_process+0xe64>
    {
        // Get subscription parameters
        m_tb_state_hb_subs_t *p_subs_params = m_tb_state_get_hb_subs_params();
    b8e6:	f008 fde9 	bl	144bc <m_tb_state_get_hb_subs_params>
        // Get pointer to data
        uint8_t *p_data = M_TB_BUF_DATA(p_buf_status);
    b8ea:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    m_tb_buf_t *p_buf_status;

    if (m_fnd_confs_buf_alloc(&p_buf_status, M_FND_CONFS_HBEAT_SUBS_STATUS_LEN) == M_ERR_NO_ERROR)
    {
        // Get subscription parameters
        m_tb_state_hb_subs_t *p_subs_params = m_tb_state_get_hb_subs_params();
    b8ec:	0004      	movs	r4, r0
        // Get pointer to data
        uint8_t *p_data = M_TB_BUF_DATA(p_buf_status);
    b8ee:	001d      	movs	r5, r3
    b8f0:	889b      	ldrh	r3, [r3, #4]
    b8f2:	3530      	adds	r5, #48	; 0x30
    b8f4:	18ed      	adds	r5, r5, r3
        // MaxHops
        uint8_t max_hops;

        do
        {
            if (opcode == M_FND_CONFS_OPCODE_HBEAT_SUBS_GET)
    b8f6:	9b04      	ldr	r3, [sp, #16]
    b8f8:	88c6      	ldrh	r6, [r0, #6]
    b8fa:	2b3a      	cmp	r3, #58	; 0x3a
    b8fc:	d104      	bne.n	b908 <m_fnd_confs_process+0xdec>
            {
                if ((p_subs_params->src_addr == M_UNASSIGNED_ADDR)
    b8fe:	2e00      	cmp	r6, #0
    b900:	d01c      	beq.n	b93c <m_fnd_confs_process+0xe20>
                        || (p_subs_params->dst_addr == M_UNASSIGNED_ADDR))
    b902:	8883      	ldrh	r3, [r0, #4]
    b904:	2b00      	cmp	r3, #0
    b906:	d01b      	beq.n	b940 <m_fnd_confs_process+0xe24>
                    break;
                }
            }

            src_addr = p_subs_params->src_addr;
            dst_addr = p_subs_params->dst_addr;
    b908:	88a3      	ldrh	r3, [r4, #4]
            period_log = (p_subs_params->period_s) ? (32 - co_clz(p_subs_params->period_s)) : 0;
    b90a:	6820      	ldr	r0, [r4, #0]
                    break;
                }
            }

            src_addr = p_subs_params->src_addr;
            dst_addr = p_subs_params->dst_addr;
    b90c:	9304      	str	r3, [sp, #16]
            period_log = (p_subs_params->period_s) ? (32 - co_clz(p_subs_params->period_s)) : 0;
    b90e:	2300      	movs	r3, #0
    b910:	9305      	str	r3, [sp, #20]
    b912:	4298      	cmp	r0, r3
    b914:	d005      	beq.n	b922 <m_fnd_confs_process+0xe06>
    b916:	f012 fa7b 	bl	1de10 <__clzsi2>
    b91a:	2320      	movs	r3, #32
    b91c:	1a18      	subs	r0, r3, r0
    b91e:	b2c3      	uxtb	r3, r0
    b920:	9305      	str	r3, [sp, #20]
            count_log = (p_subs_params->count) ? (32 - co_clz(p_subs_params->count)) : 0;
    b922:	2700      	movs	r7, #0
    b924:	8920      	ldrh	r0, [r4, #8]
    b926:	42b8      	cmp	r0, r7
    b928:	d004      	beq.n	b934 <m_fnd_confs_process+0xe18>
    b92a:	f012 fa71 	bl	1de10 <__clzsi2>
    b92e:	2320      	movs	r3, #32
    b930:	1a18      	subs	r0, r3, r0
    b932:	b2c7      	uxtb	r7, r0
            min_hops = p_subs_params->min_hops;
    b934:	7aa3      	ldrb	r3, [r4, #10]
    b936:	9307      	str	r3, [sp, #28]
            max_hops = p_subs_params->max_hops;
    b938:	7ae4      	ldrb	r4, [r4, #11]
    b93a:	e007      	b.n	b94c <m_fnd_confs_process+0xe30>
                    src_addr = M_UNASSIGNED_ADDR;
                    dst_addr = M_UNASSIGNED_ADDR;
                    period_log = 0;
                    count_log = 0;
                    min_hops = 0;
                    max_hops = 0;
    b93c:	0034      	movs	r4, r6
    b93e:	e000      	b.n	b942 <m_fnd_confs_process+0xe26>
    b940:	001c      	movs	r4, r3
                        || (p_subs_params->dst_addr == M_UNASSIGNED_ADDR))
                {
                    src_addr = M_UNASSIGNED_ADDR;
                    dst_addr = M_UNASSIGNED_ADDR;
                    period_log = 0;
                    count_log = 0;
    b942:	0027      	movs	r7, r4
            if (opcode == M_FND_CONFS_OPCODE_HBEAT_SUBS_GET)
            {
                if ((p_subs_params->src_addr == M_UNASSIGNED_ADDR)
                        || (p_subs_params->dst_addr == M_UNASSIGNED_ADDR))
                {
                    src_addr = M_UNASSIGNED_ADDR;
    b944:	0026      	movs	r6, r4
                    dst_addr = M_UNASSIGNED_ADDR;
                    period_log = 0;
                    count_log = 0;
                    min_hops = 0;
    b946:	9407      	str	r4, [sp, #28]
                if ((p_subs_params->src_addr == M_UNASSIGNED_ADDR)
                        || (p_subs_params->dst_addr == M_UNASSIGNED_ADDR))
                {
                    src_addr = M_UNASSIGNED_ADDR;
                    dst_addr = M_UNASSIGNED_ADDR;
                    period_log = 0;
    b948:	9405      	str	r4, [sp, #20]
            {
                if ((p_subs_params->src_addr == M_UNASSIGNED_ADDR)
                        || (p_subs_params->dst_addr == M_UNASSIGNED_ADDR))
                {
                    src_addr = M_UNASSIGNED_ADDR;
                    dst_addr = M_UNASSIGNED_ADDR;
    b94a:	9404      	str	r4, [sp, #16]
            min_hops = p_subs_params->min_hops;
            max_hops = p_subs_params->max_hops;
        } while (0);

        // Write status
        *p_data = m_fnd_confs_get_air_status(status);
    b94c:	9806      	ldr	r0, [sp, #24]
    b94e:	f7fe fdec 	bl	a52a <m_fnd_confs_get_air_status>
 */
__INLINE_S__ void co_write16p(void const *ptr16, uint16_t value)
{
    uint8_t *ptr=(uint8_t*)ptr16;

    *ptr++ = value&0xff;
    b952:	466b      	mov	r3, sp
    b954:	7c1b      	ldrb	r3, [r3, #16]

        // Write Max Hops
        *p_data = max_hops;

        // Send the message
        m_fnd_confs_send(p_buf_status, M_FND_CONFS_2B_OPCODE(M_FND_CONFS_OPCODE_HBEAT_SUBS_STATUS));
    b956:	21f2      	movs	r1, #242	; 0xf2
    b958:	70eb      	strb	r3, [r5, #3]
    *ptr = (value&0xff00)>>8;
    b95a:	9b04      	ldr	r3, [sp, #16]
 */
__INLINE_S__ void co_write16p(void const *ptr16, uint16_t value)
{
    uint8_t *ptr=(uint8_t*)ptr16;

    *ptr++ = value&0xff;
    b95c:	706e      	strb	r6, [r5, #1]
    *ptr = (value&0xff00)>>8;
    b95e:	0a1b      	lsrs	r3, r3, #8
    b960:	712b      	strb	r3, [r5, #4]
        // Write Destination address
        co_write16p(p_data, dst_addr);
        p_data += 2;

        // Write Period Log
        *p_data = period_log;
    b962:	466b      	mov	r3, sp
    b964:	7d1b      	ldrb	r3, [r3, #20]
    b966:	0a36      	lsrs	r6, r6, #8
    b968:	716b      	strb	r3, [r5, #5]
        // Write Count Log
        *p_data = count_log;
        p_data++;

        // Write Min Hops
        *p_data = min_hops;
    b96a:	466b      	mov	r3, sp
    b96c:	7f1b      	ldrb	r3, [r3, #28]
            min_hops = p_subs_params->min_hops;
            max_hops = p_subs_params->max_hops;
        } while (0);

        // Write status
        *p_data = m_fnd_confs_get_air_status(status);
    b96e:	7028      	strb	r0, [r5, #0]
    b970:	70ae      	strb	r6, [r5, #2]
        // Write Period Log
        *p_data = period_log;
        p_data++;

        // Write Count Log
        *p_data = count_log;
    b972:	71af      	strb	r7, [r5, #6]
        p_data++;

        // Write Min Hops
        *p_data = min_hops;
    b974:	71eb      	strb	r3, [r5, #7]
        p_data++;

        // Write Max Hops
        *p_data = max_hops;
    b976:	722c      	strb	r4, [r5, #8]

        // Send the message
        m_fnd_confs_send(p_buf_status, M_FND_CONFS_2B_OPCODE(M_FND_CONFS_OPCODE_HBEAT_SUBS_STATUS));
    b978:	0189      	lsls	r1, r1, #6
    b97a:	980e      	ldr	r0, [sp, #56]	; 0x38
    b97c:	f7fe fdeb 	bl	a556 <m_fnd_confs_send>
            case (M_FND_CONFS_OPCODE_HBEAT_SUBS_GET)             :
            case (M_FND_CONFS_OPCODE_HBEAT_SUBS_SET)             : m_fnd_confs_handler_hbeat_subs(p_buf, opcode_2b);        break;
            #if (BLE_MESH_FRIEND)
            case (M_FND_CONFS_OPCODE_LPN_POLLTIMEOUT_GET)        : m_fnd_confs_handler_lpn_polltimeout(p_buf);              break;
            #endif //(BLE_MESH_FRIEND)
            default                                              : m_fnd_confs_process_next();                              break;
    b980:	f000 f80c 	bl	b99c <m_fnd_confs_process_next>
        }
    }
}
    b984:	b013      	add	sp, #76	; 0x4c
    b986:	bdf0      	pop	{r4, r5, r6, r7, pc}
    b988:	10010514 	.word	0x10010514
    b98c:	000216dc 	.word	0x000216dc
    b990:	000215dc 	.word	0x000215dc
    b994:	0000aa45 	.word	0x0000aa45
    b998:	0000ffff 	.word	0x0000ffff

0000b99c <m_fnd_confs_process_next>:
 * @brief Pop first buffer from the processing queue, release it and start processing of
 * next one in the processing queue.
 ****************************************************************************************
 */
__STATIC void m_fnd_confs_process_next(void)
{
    b99c:	b510      	push	{r4, lr}
    // Remove first buffer in the process queue
    m_tb_buf_t *p_buf = (m_tb_buf_t *)co_list_pop_front(&p_m_fnd_confs_env->process_queue);
    b99e:	4c07      	ldr	r4, [pc, #28]	; (b9bc <m_fnd_confs_process_next+0x20>)
    b9a0:	6820      	ldr	r0, [r4, #0]
    b9a2:	f7f8 fd23 	bl	43ec <co_list_pop_front>

    // Release the buffer
    m_tb_buf_release(p_buf);
    b9a6:	f005 fe79 	bl	1169c <m_tb_buf_release>

    // Check if messages are waiting to be processed
    if (co_list_pick(&p_m_fnd_confs_env->process_queue) != NULL)
    b9aa:	6820      	ldr	r0, [r4, #0]
    b9ac:	6803      	ldr	r3, [r0, #0]
    b9ae:	2b00      	cmp	r3, #0
    b9b0:	d002      	beq.n	b9b8 <m_fnd_confs_process_next+0x1c>
    {
        // Delay handling of received message
        m_al_djob_reg(&(p_m_fnd_confs_env->djob));
    b9b2:	3008      	adds	r0, #8
    b9b4:	f7f9 f96a 	bl	4c8c <m_al_djob_reg>
    }
}
    b9b8:	bd10      	pop	{r4, pc}
    b9ba:	46c0      	nop			; (mov r8, r8)
    b9bc:	100126a0 	.word	0x100126a0

0000b9c0 <m_fnd_confs_cb_rx>:
 *                            False, it can have been relayed.
 ****************************************************************************************
 */
__STATIC void m_fnd_confs_cb_rx(m_lid_t model_lid, uint32_t opcode, m_api_buf_t *p_api_buf, m_lid_t app_key_lid,
                                uint16_t src, int8_t rssi, bool not_relayed)
{
    b9c0:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	M_PRINTF(L_FND, "");
    b9c2:	4b1c      	ldr	r3, [pc, #112]	; (ba34 <m_fnd_confs_cb_rx+0x74>)
 *                            False, it can have been relayed.
 ****************************************************************************************
 */
__STATIC void m_fnd_confs_cb_rx(m_lid_t model_lid, uint32_t opcode, m_api_buf_t *p_api_buf, m_lid_t app_key_lid,
                                uint16_t src, int8_t rssi, bool not_relayed)
{
    b9c4:	0016      	movs	r6, r2
	M_PRINTF(L_FND, "");
    b9c6:	681b      	ldr	r3, [r3, #0]
    b9c8:	051b      	lsls	r3, r3, #20
    b9ca:	d515      	bpl.n	b9f8 <m_fnd_confs_cb_rx+0x38>
    b9cc:	4c1a      	ldr	r4, [pc, #104]	; (ba38 <m_fnd_confs_cb_rx+0x78>)
    b9ce:	4b1b      	ldr	r3, [pc, #108]	; (ba3c <m_fnd_confs_cb_rx+0x7c>)
    b9d0:	0022      	movs	r2, r4
    b9d2:	0020      	movs	r0, r4
    b9d4:	3369      	adds	r3, #105	; 0x69
    b9d6:	0021      	movs	r1, r4
    b9d8:	3253      	adds	r2, #83	; 0x53
    b9da:	9300      	str	r3, [sp, #0]
    b9dc:	3061      	adds	r0, #97	; 0x61
    b9de:	4b18      	ldr	r3, [pc, #96]	; (ba40 <m_fnd_confs_cb_rx+0x80>)
    b9e0:	f7f8 ffe4 	bl	49ac <m_print>
    b9e4:	4d17      	ldr	r5, [pc, #92]	; (ba44 <m_fnd_confs_cb_rx+0x84>)
    b9e6:	0028      	movs	r0, r5
    b9e8:	3074      	adds	r0, #116	; 0x74
    b9ea:	f7f8 ffdf 	bl	49ac <m_print>
    b9ee:	0028      	movs	r0, r5
    b9f0:	1da1      	adds	r1, r4, #6
    b9f2:	3022      	adds	r0, #34	; 0x22
    b9f4:	f7f8 ffda 	bl	49ac <m_print>
    // Data length
    uint16_t data_len = ((m_tb_buf_t *)p_api_buf)->data_len;
    // Allocate a buffer
    m_tb_buf_t *p_buf;
    // Allocate a new buffer
    uint16_t status = m_tb_buf_alloc(&p_buf, 0, data_len, 0);
    b9f8:	2300      	movs	r3, #0
__STATIC void m_fnd_confs_cb_rx(m_lid_t model_lid, uint32_t opcode, m_api_buf_t *p_api_buf, m_lid_t app_key_lid,
                                uint16_t src, int8_t rssi, bool not_relayed)
{
	M_PRINTF(L_FND, "");
    // Data length
    uint16_t data_len = ((m_tb_buf_t *)p_api_buf)->data_len;
    b9fa:	8934      	ldrh	r4, [r6, #8]
    // Allocate a buffer
    m_tb_buf_t *p_buf;
    // Allocate a new buffer
    uint16_t status = m_tb_buf_alloc(&p_buf, 0, data_len, 0);
    b9fc:	0019      	movs	r1, r3
    b9fe:	0022      	movs	r2, r4
    ba00:	a803      	add	r0, sp, #12
    ba02:	f005 fd99 	bl	11538 <m_tb_buf_alloc>

    if (status == M_ERR_NO_ERROR)
    ba06:	2800      	cmp	r0, #0
    ba08:	d112      	bne.n	ba30 <m_fnd_confs_cb_rx+0x70>
    {
        // Copy content of the received buffer in the allocated one
        m_tb_buf_copy((m_tb_buf_t *)p_api_buf, p_buf, data_len, true);
    ba0a:	0022      	movs	r2, r4
    ba0c:	2301      	movs	r3, #1
    ba0e:	9903      	ldr	r1, [sp, #12]
    ba10:	0030      	movs	r0, r6
    ba12:	f005 fe85 	bl	11720 <m_tb_buf_copy>

        // Insert the buffer in the process queue
        co_list_push_back(&p_m_fnd_confs_env->process_queue, &p_buf->hdr);
    ba16:	4c0c      	ldr	r4, [pc, #48]	; (ba48 <m_fnd_confs_cb_rx+0x88>)
    ba18:	9903      	ldr	r1, [sp, #12]
    ba1a:	6820      	ldr	r0, [r4, #0]
    ba1c:	f7f8 fcbb 	bl	4396 <co_list_push_back>

        // Check if buffer can be processed now or if another buffer is currently processed
        if ((m_tb_buf_t *)co_list_pick(&p_m_fnd_confs_env->process_queue) == p_buf)
    ba20:	6820      	ldr	r0, [r4, #0]
    ba22:	9b03      	ldr	r3, [sp, #12]
    ba24:	6802      	ldr	r2, [r0, #0]
    ba26:	4293      	cmp	r3, r2
    ba28:	d102      	bne.n	ba30 <m_fnd_confs_cb_rx+0x70>
        {
            // Delay handling of received message
            m_al_djob_reg(&(p_m_fnd_confs_env->djob));
    ba2a:	3008      	adds	r0, #8
    ba2c:	f7f9 f92e 	bl	4c8c <m_al_djob_reg>
        }
    }
}
    ba30:	bd7f      	pop	{r0, r1, r2, r3, r4, r5, r6, pc}
    ba32:	46c0      	nop			; (mov r8, r8)
    ba34:	10010514 	.word	0x10010514
    ba38:	000215dc 	.word	0x000215dc
    ba3c:	000216dc 	.word	0x000216dc
    ba40:	00000ca8 	.word	0x00000ca8
    ba44:	0002165c 	.word	0x0002165c
    ba48:	100126a0 	.word	0x100126a0

0000ba4c <m_fnd_confs_cb_opcode_check>:
 * @param[in] opcode        Operation code to check
 ****************************************************************************************
 */
__STATIC void m_fnd_confs_cb_opcode_check(m_lid_t model_lid, uint32_t opcode)
{
	M_PRINTF(L_FND, "");
    ba4c:	4b1e      	ldr	r3, [pc, #120]	; (bac8 <m_fnd_confs_cb_opcode_check+0x7c>)
 * @param[in] model_lid     Model local index
 * @param[in] opcode        Operation code to check
 ****************************************************************************************
 */
__STATIC void m_fnd_confs_cb_opcode_check(m_lid_t model_lid, uint32_t opcode)
{
    ba4e:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	M_PRINTF(L_FND, "");
    ba50:	681b      	ldr	r3, [r3, #0]
 * @param[in] model_lid     Model local index
 * @param[in] opcode        Operation code to check
 ****************************************************************************************
 */
__STATIC void m_fnd_confs_cb_opcode_check(m_lid_t model_lid, uint32_t opcode)
{
    ba52:	0005      	movs	r5, r0
    ba54:	000c      	movs	r4, r1
	M_PRINTF(L_FND, "");
    ba56:	051b      	lsls	r3, r3, #20
    ba58:	d515      	bpl.n	ba86 <m_fnd_confs_cb_opcode_check+0x3a>
    ba5a:	4e1c      	ldr	r6, [pc, #112]	; (bacc <m_fnd_confs_cb_opcode_check+0x80>)
    ba5c:	4b1c      	ldr	r3, [pc, #112]	; (bad0 <m_fnd_confs_cb_opcode_check+0x84>)
    ba5e:	0032      	movs	r2, r6
    ba60:	0030      	movs	r0, r6
    ba62:	337b      	adds	r3, #123	; 0x7b
    ba64:	0031      	movs	r1, r6
    ba66:	3253      	adds	r2, #83	; 0x53
    ba68:	9300      	str	r3, [sp, #0]
    ba6a:	3061      	adds	r0, #97	; 0x61
    ba6c:	4b19      	ldr	r3, [pc, #100]	; (bad4 <m_fnd_confs_cb_opcode_check+0x88>)
    ba6e:	f7f8 ff9d 	bl	49ac <m_print>
    ba72:	4f19      	ldr	r7, [pc, #100]	; (bad8 <m_fnd_confs_cb_opcode_check+0x8c>)
    ba74:	0038      	movs	r0, r7
    ba76:	3074      	adds	r0, #116	; 0x74
    ba78:	f7f8 ff98 	bl	49ac <m_print>
    ba7c:	0038      	movs	r0, r7
    ba7e:	1db1      	adds	r1, r6, #6
    ba80:	3022      	adds	r0, #34	; 0x22
    ba82:	f7f8 ff93 	bl	49ac <m_print>
    // Status
    uint16_t status = M_ERR_NOT_SUPPORTED;

    // Check if opcode is a 1-byte or a 2-byte opcode
    if (M_IS_1_OCT_OPCODE(opcode))
    ba86:	2280      	movs	r2, #128	; 0x80
    ba88:	4022      	ands	r2, r4
    ba8a:	d105      	bne.n	ba98 <m_fnd_confs_cb_opcode_check+0x4c>
    {
        uint8_t opcode_1b = (uint8_t)opcode;
    ba8c:	b2e3      	uxtb	r3, r4

        if ((opcode_1b <= M_FND_CONFS_OPCODE_MODEL_PUB_SET) ||
    ba8e:	2b03      	cmp	r3, #3
    ba90:	d914      	bls.n	babc <m_fnd_confs_cb_opcode_check+0x70>
    ba92:	2b06      	cmp	r3, #6
    ba94:	d110      	bne.n	bab8 <m_fnd_confs_cb_opcode_check+0x6c>
    ba96:	e011      	b.n	babc <m_fnd_confs_cb_opcode_check+0x70>
            (opcode_1b == M_FND_CONFS_OPCODE_HBEAT_PUB_STATUS))
        {
            status = M_ERR_NO_ERROR;
        }
    }
    else if (M_IS_2_OCT_OPCODE(opcode))
    ba98:	23c0      	movs	r3, #192	; 0xc0
    ba9a:	4023      	ands	r3, r4
    ba9c:	2b80      	cmp	r3, #128	; 0x80
    ba9e:	d10b      	bne.n	bab8 <m_fnd_confs_cb_opcode_check+0x6c>
    {
        uint8_t opcode_2b = (uint8_t)(opcode >> 8);
    baa0:	0a23      	lsrs	r3, r4, #8
    baa2:	b2db      	uxtb	r3, r3
        uint8_t opcode_1b = (uint8_t)opcode;

        if ((opcode_1b <= M_FND_CONFS_OPCODE_MODEL_PUB_SET) ||
            (opcode_1b == M_FND_CONFS_OPCODE_HBEAT_PUB_STATUS))
        {
            status = M_ERR_NO_ERROR;
    baa4:	2200      	movs	r2, #0
    }
    else if (M_IS_2_OCT_OPCODE(opcode))
    {
        uint8_t opcode_2b = (uint8_t)(opcode >> 8);

        if ((opcode_2b <= M_FND_CONFS_OPCODE_APPKEY_STATUS) ||
    baa6:	2b03      	cmp	r3, #3
    baa8:	d908      	bls.n	babc <m_fnd_confs_cb_opcode_check+0x70>
    baaa:	0019      	movs	r1, r3
    baac:	3908      	subs	r1, #8
    baae:	2926      	cmp	r1, #38	; 0x26
    bab0:	d904      	bls.n	babc <m_fnd_confs_cb_opcode_check+0x70>
            ((opcode_2b >= M_FND_CONFS_OPCODE_COMPO_DATA_GET) &&
             (opcode_2b <= M_FND_CONFS_OPCODE_LPN_POLLTIMEOUT_STATUS)) ||
    bab2:	3b38      	subs	r3, #56	; 0x38
    bab4:	2b16      	cmp	r3, #22
    bab6:	d901      	bls.n	babc <m_fnd_confs_cb_opcode_check+0x70>
 */
__STATIC void m_fnd_confs_cb_opcode_check(m_lid_t model_lid, uint32_t opcode)
{
	M_PRINTF(L_FND, "");
    // Status
    uint16_t status = M_ERR_NOT_SUPPORTED;
    bab8:	22a8      	movs	r2, #168	; 0xa8
    baba:	0112      	lsls	r2, r2, #4
            status = M_ERR_NO_ERROR;
        }
    }
    
    // Indicate if provided operation code is supported or not
    bc_m_model_opcode_status(model_lid, opcode, status);
    babc:	0028      	movs	r0, r5
    babe:	0021      	movs	r1, r4
    bac0:	f7fd f9a0 	bl	8e04 <bc_m_model_opcode_status>
}
    bac4:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
    bac6:	46c0      	nop			; (mov r8, r8)
    bac8:	10010514 	.word	0x10010514
    bacc:	000215dc 	.word	0x000215dc
    bad0:	000216dc 	.word	0x000216dc
    bad4:	00000ccc 	.word	0x00000ccc
    bad8:	0002165c 	.word	0x0002165c

0000badc <m_fnd_confs_cb_sent>:
 * @param[in] status        Transmission status.
 ****************************************************************************************
 */
__STATIC void m_fnd_confs_cb_sent(m_lid_t model_lid, uint8_t tx_hdl, m_api_buf_t *p_api_buf, uint16_t status)
{
	M_PRINTF(L_FND, "");
    badc:	4b13      	ldr	r3, [pc, #76]	; (bb2c <m_fnd_confs_cb_sent+0x50>)
 * @param[in] p_api_buf     Pointer to the buffer containing the transmitted PDU.
 * @param[in] status        Transmission status.
 ****************************************************************************************
 */
__STATIC void m_fnd_confs_cb_sent(m_lid_t model_lid, uint8_t tx_hdl, m_api_buf_t *p_api_buf, uint16_t status)
{
    bade:	b573      	push	{r0, r1, r4, r5, r6, lr}
	M_PRINTF(L_FND, "");
    bae0:	681b      	ldr	r3, [r3, #0]
 * @param[in] p_api_buf     Pointer to the buffer containing the transmitted PDU.
 * @param[in] status        Transmission status.
 ****************************************************************************************
 */
__STATIC void m_fnd_confs_cb_sent(m_lid_t model_lid, uint8_t tx_hdl, m_api_buf_t *p_api_buf, uint16_t status)
{
    bae2:	0016      	movs	r6, r2
	M_PRINTF(L_FND, "");
    bae4:	051b      	lsls	r3, r3, #20
    bae6:	d515      	bpl.n	bb14 <m_fnd_confs_cb_sent+0x38>
    bae8:	4c11      	ldr	r4, [pc, #68]	; (bb30 <m_fnd_confs_cb_sent+0x54>)
    baea:	4b12      	ldr	r3, [pc, #72]	; (bb34 <m_fnd_confs_cb_sent+0x58>)
    baec:	0022      	movs	r2, r4
    baee:	0020      	movs	r0, r4
    baf0:	3317      	adds	r3, #23
    baf2:	0021      	movs	r1, r4
    baf4:	3253      	adds	r2, #83	; 0x53
    baf6:	9300      	str	r3, [sp, #0]
    baf8:	3061      	adds	r0, #97	; 0x61
    bafa:	4b0f      	ldr	r3, [pc, #60]	; (bb38 <m_fnd_confs_cb_sent+0x5c>)
    bafc:	f7f8 ff56 	bl	49ac <m_print>
    bb00:	4d0e      	ldr	r5, [pc, #56]	; (bb3c <m_fnd_confs_cb_sent+0x60>)
    bb02:	0028      	movs	r0, r5
    bb04:	3074      	adds	r0, #116	; 0x74
    bb06:	f7f8 ff51 	bl	49ac <m_print>
    bb0a:	0028      	movs	r0, r5
    bb0c:	1da1      	adds	r1, r4, #6
    bb0e:	3022      	adds	r0, #34	; 0x22
    bb10:	f7f8 ff4c 	bl	49ac <m_print>
    if (p_m_fnd_confs_env->p_buf_reset == (m_tb_buf_t *)p_api_buf)
    bb14:	4b0a      	ldr	r3, [pc, #40]	; (bb40 <m_fnd_confs_cb_sent+0x64>)
    bb16:	681b      	ldr	r3, [r3, #0]
    bb18:	695b      	ldr	r3, [r3, #20]
    bb1a:	42b3      	cmp	r3, r6
    bb1c:	d101      	bne.n	bb22 <m_fnd_confs_cb_sent+0x46>
    {
        // Inform the upper application about node reset request
        bc_m_send_node_reset_ind();
    bb1e:	f7fd fb25 	bl	916c <bc_m_send_node_reset_ind>
    }

    // Release the buffer
    m_tb_buf_release((m_tb_buf_t *)p_api_buf);
    bb22:	0030      	movs	r0, r6
    bb24:	f005 fdba 	bl	1169c <m_tb_buf_release>
}
    bb28:	bd73      	pop	{r0, r1, r4, r5, r6, pc}
    bb2a:	46c0      	nop			; (mov r8, r8)
    bb2c:	10010514 	.word	0x10010514
    bb30:	000215dc 	.word	0x000215dc
    bb34:	0002175c 	.word	0x0002175c
    bb38:	00000cfa 	.word	0x00000cfa
    bb3c:	0002165c 	.word	0x0002165c
    bb40:	100126a0 	.word	0x100126a0

0000bb44 <m_fnd_confs_init>:
 * GLOBAL FUNCTIONS
 ****************************************************************************************
 */

uint16_t m_fnd_confs_init(bool reset, void *p_env, const m_cfg_t* p_cfg)
{
    bb44:	b573      	push	{r0, r1, r4, r5, r6, lr}
    bb46:	0004      	movs	r4, r0
    bb48:	000d      	movs	r5, r1
    bb4a:	4e0d      	ldr	r6, [pc, #52]	; (bb80 <m_fnd_confs_init+0x3c>)
    if (!reset)
    bb4c:	2800      	cmp	r0, #0
    bb4e:	d112      	bne.n	bb76 <m_fnd_confs_init+0x32>
    {
        // Get environment for Foundation model layer
        p_m_fnd_confs_env = (m_fnd_confs_env_t *)p_env;
    bb50:	6031      	str	r1, [r6, #0]

        // Initialize environment
        memset(p_m_fnd_confs_env, 0, sizeof(m_fnd_confs_env_t));
    bb52:	221c      	movs	r2, #28
    bb54:	0001      	movs	r1, r0
    bb56:	0028      	movs	r0, r5
    bb58:	f009 ff78 	bl	15a4c <memset>

        // Register the model
        bc_m_register_model(M_FND_CONFS_MODEL_ID, 0, false, &m_fnd_confs_cb,
    bb5c:	4b09      	ldr	r3, [pc, #36]	; (bb84 <m_fnd_confs_init+0x40>)
    bb5e:	3519      	adds	r5, #25
    bb60:	332c      	adds	r3, #44	; 0x2c
    bb62:	0022      	movs	r2, r4
    bb64:	9500      	str	r5, [sp, #0]
    bb66:	0021      	movs	r1, r4
    bb68:	0020      	movs	r0, r4
    bb6a:	f7fd f94f 	bl	8e0c <bc_m_register_model>
                             &p_m_fnd_confs_env->model_lid);

        // Initialize delayed job
        p_m_fnd_confs_env->djob.cb = m_fnd_confs_process;
    bb6e:	6833      	ldr	r3, [r6, #0]
    bb70:	4a05      	ldr	r2, [pc, #20]	; (bb88 <m_fnd_confs_init+0x44>)
    bb72:	611a      	str	r2, [r3, #16]
    bb74:	e001      	b.n	bb7a <m_fnd_confs_init+0x36>
    }
    else
    {
        p_m_fnd_confs_env = NULL;
    bb76:	2300      	movs	r3, #0
    bb78:	6033      	str	r3, [r6, #0]
    }

    // Return environment size
    return (sizeof(m_fnd_confs_env_t));
}
    bb7a:	201c      	movs	r0, #28
    bb7c:	bd76      	pop	{r1, r2, r4, r5, r6, pc}
    bb7e:	46c0      	nop			; (mov r8, r8)
    bb80:	100126a0 	.word	0x100126a0
    bb84:	0002175c 	.word	0x0002175c
    bb88:	0000ab1d 	.word	0x0000ab1d

0000bb8c <m_fnd_confs_get_env_size>:

uint16_t m_fnd_confs_get_env_size(const m_cfg_t* p_cfg)
{
    // Return environment size
    return (sizeof(m_fnd_confs_env_t));
}
    bb8c:	201c      	movs	r0, #28
    bb8e:	4770      	bx	lr

0000bb90 <co_bswap.constprop.7>:
 * @param[in] p_val_in  The input value.
 *
 * @param[in] len       number of bytes to swap
 ****************************************************************************************
 */
__INLINE_S__ void co_bswap(uint8_t* p_val_out, const uint8_t* p_val_in, uint16_t len)
    bb90:	2310      	movs	r3, #16
{
    while (len > 0)
    {
        len--;
    bb92:	3b01      	subs	r3, #1
    bb94:	b29b      	uxth	r3, r3
        *p_val_out = p_val_in[len];
    bb96:	5cca      	ldrb	r2, [r1, r3]
    bb98:	7002      	strb	r2, [r0, #0]
        p_val_out++;
    bb9a:	3001      	adds	r0, #1
 * @param[in] len       number of bytes to swap
 ****************************************************************************************
 */
__INLINE_S__ void co_bswap(uint8_t* p_val_out, const uint8_t* p_val_in, uint16_t len)
{
    while (len > 0)
    bb9c:	2b00      	cmp	r3, #0
    bb9e:	d1f8      	bne.n	bb92 <co_bswap.constprop.7+0x2>
    {
        len--;
        *p_val_out = p_val_in[len];
        p_val_out++;
    }
}
    bba0:	4770      	bx	lr
    bba2:	46c0      	nop			; (mov r8, r8)

0000bba4 <m_fnd_hlths_send>:
 * @param[in] p_buf     Pointer to the buffer containing the message to send.
 * @param[in] opcode    Operation code
 ****************************************************************************************
 */
__STATIC void m_fnd_hlths_send(m_tb_buf_t *p_buf, uint16_t opcode)
{
    bba4:	b530      	push	{r4, r5, lr}
    // Retrieve buffer containing the message for which a response is sent
    m_tb_buf_t *p_buf_req = (m_tb_buf_t *)co_list_pick(&p_m_fnd_hlths_env->process_queue);
    bba6:	4a08      	ldr	r2, [pc, #32]	; (bbc8 <m_fnd_hlths_send+0x24>)
 * @param[in] p_buf     Pointer to the buffer containing the message to send.
 * @param[in] opcode    Operation code
 ****************************************************************************************
 */
__STATIC void m_fnd_hlths_send(m_tb_buf_t *p_buf, uint16_t opcode)
{
    bba8:	0003      	movs	r3, r0
    // Retrieve buffer containing the message for which a response is sent
    m_tb_buf_t *p_buf_req = (m_tb_buf_t *)co_list_pick(&p_m_fnd_hlths_env->process_queue);
    bbaa:	6812      	ldr	r2, [r2, #0]
 * @param[in] p_buf     Pointer to the buffer containing the message to send.
 * @param[in] opcode    Operation code
 ****************************************************************************************
 */
__STATIC void m_fnd_hlths_send(m_tb_buf_t *p_buf, uint16_t opcode)
{
    bbac:	b085      	sub	sp, #20
    bbae:	6814      	ldr	r4, [r2, #0]
    m_lay_buf_env_t *p_env = (m_lay_buf_env_t *)&p_buf_req->env[0];
    // Use request source address as destination address
    uint16_t dst = p_env->src;

    // Send the provided message
    bc_m_model_rsp_send(p_m_fnd_hlths_env->model_lid, (uint32_t)opcode, 0,
    bbb0:	7a10      	ldrb	r0, [r2, #8]
    bbb2:	2200      	movs	r2, #0
    bbb4:	9203      	str	r2, [sp, #12]
    bbb6:	9202      	str	r2, [sp, #8]
    bbb8:	8ba5      	ldrh	r5, [r4, #28]
    bbba:	9501      	str	r5, [sp, #4]
    bbbc:	7ca4      	ldrb	r4, [r4, #18]
    bbbe:	9400      	str	r4, [sp, #0]
    bbc0:	f7fd f90e 	bl	8de0 <bc_m_model_rsp_send>
                         p_buf, p_env->app_lid, dst, false, false);
}
    bbc4:	b005      	add	sp, #20
    bbc6:	bd30      	pop	{r4, r5, pc}
    bbc8:	100126a4 	.word	0x100126a4

0000bbcc <m_fnd_hlths_send_status>:
 * @param[in] p_fault_array     Pointer to Fault Array content
 ****************************************************************************************
 */
__STATIC void m_fnd_hlths_send_status(uint16_t comp_id, uint8_t test_id, bool solicited, uint8_t length,
                                      uint8_t *p_fault_array)
{
    bbcc:	b5f0      	push	{r4, r5, r6, r7, lr}
    bbce:	b085      	sub	sp, #20
    bbd0:	0005      	movs	r5, r0
    bbd2:	000f      	movs	r7, r1
    bbd4:	0014      	movs	r4, r2
    bbd6:	001e      	movs	r6, r3
 ****************************************************************************************
 */
__STATIC uint16_t m_fnd_hlths_buf_alloc(m_tb_buf_t **pp_buf, uint16_t data_len)
{
    // Try to allocate a buffer and return the status
    return (m_tb_buf_alloc(pp_buf, M_FND_BUF_HEAD_LEN, data_len, 0));
    bbd8:	1cda      	adds	r2, r3, #3
    bbda:	2102      	movs	r1, #2
    bbdc:	2300      	movs	r3, #0
    bbde:	a803      	add	r0, sp, #12
    bbe0:	f005 fcaa 	bl	11538 <m_tb_buf_alloc>
                                      uint8_t *p_fault_array)
{
    // Pointer to the buffer that will contain the message
    m_tb_buf_t *p_buf_status;

    if (m_fnd_hlths_buf_alloc(&p_buf_status, M_FND_HLTHS_STATUS_LEN + length) == M_ERR_NO_ERROR)
    bbe4:	2800      	cmp	r0, #0
    bbe6:	d120      	bne.n	bc2a <m_fnd_hlths_send_status+0x5e>
    {
        // Get pointer to data
        uint8_t *p_data = M_TB_BUF_DATA(p_buf_status);
    bbe8:	9b03      	ldr	r3, [sp, #12]
    bbea:	0018      	movs	r0, r3
    bbec:	889b      	ldrh	r3, [r3, #4]
    bbee:	3030      	adds	r0, #48	; 0x30
    bbf0:	18c0      	adds	r0, r0, r3
 */
__INLINE_S__ void co_write16p(void const *ptr16, uint16_t value)
{
    uint8_t *ptr=(uint8_t*)ptr16;

    *ptr++ = value&0xff;
    bbf2:	7045      	strb	r5, [r0, #1]
    *ptr = (value&0xff00)>>8;
    bbf4:	0a2d      	lsrs	r5, r5, #8

        // Write Test ID
        *p_data = test_id;
    bbf6:	7007      	strb	r7, [r0, #0]
    bbf8:	7085      	strb	r5, [r0, #2]

        // Write Company ID
        co_write16p(p_data + 1, comp_id);

        if (length)
    bbfa:	2e00      	cmp	r6, #0
    bbfc:	d004      	beq.n	bc08 <m_fnd_hlths_send_status+0x3c>
        {
            // Write fault array content
            memcpy(p_data + 3, p_fault_array, length);
    bbfe:	3003      	adds	r0, #3
    bc00:	0032      	movs	r2, r6
    bc02:	990a      	ldr	r1, [sp, #40]	; 0x28
    bc04:	f009 fee4 	bl	159d0 <memcpy>
        }

        // Send the message
        if (solicited)
    bc08:	2c00      	cmp	r4, #0
    bc0a:	d004      	beq.n	bc16 <m_fnd_hlths_send_status+0x4a>
        {
            m_fnd_hlths_send(p_buf_status, M_FND_HLTHS_OPCODE_FAULT_STATUS);
    bc0c:	2105      	movs	r1, #5
    bc0e:	9803      	ldr	r0, [sp, #12]
    bc10:	f7ff ffc8 	bl	bba4 <m_fnd_hlths_send>
    bc14:	e00b      	b.n	bc2e <m_fnd_hlths_send_status+0x62>
 ****************************************************************************************
 */
__STATIC void m_fnd_hlths_publish(m_tb_buf_t *p_buf, uint16_t opcode)
{
    // Send the provided message
    bc_m_model_publish(p_m_fnd_hlths_env->model_lid, (uint32_t)opcode, 0, p_buf, false);
    bc16:	4b08      	ldr	r3, [pc, #32]	; (bc38 <m_fnd_hlths_send_status+0x6c>)
    bc18:	0022      	movs	r2, r4
    bc1a:	681b      	ldr	r3, [r3, #0]
    bc1c:	2104      	movs	r1, #4
    bc1e:	7a18      	ldrb	r0, [r3, #8]
    bc20:	9400      	str	r4, [sp, #0]
    bc22:	9b03      	ldr	r3, [sp, #12]
    bc24:	f7fd f8d5 	bl	8dd2 <bc_m_model_publish>
    bc28:	e003      	b.n	bc32 <m_fnd_hlths_send_status+0x66>
        {
            m_fnd_hlths_publish(p_buf_status, M_FND_HLTHS_OPCODE_CUR_STATUS);
        }
    }

    if (solicited)
    bc2a:	2c00      	cmp	r4, #0
    bc2c:	d001      	beq.n	bc32 <m_fnd_hlths_send_status+0x66>
    {
        // End procedure and process next message
        m_fnd_hlths_process_next();
    bc2e:	f000 f8ab 	bl	bd88 <m_fnd_hlths_process_next>
    }
}
    bc32:	b005      	add	sp, #20
    bc34:	bdf0      	pop	{r4, r5, r6, r7, pc}
    bc36:	46c0      	nop			; (mov r8, r8)
    bc38:	100126a4 	.word	0x100126a4

0000bc3c <m_fnd_hlths_process>:
 *
 * @param[in] p_buf     Buffer to handle.
 ****************************************************************************************
 */
__STATIC void m_fnd_hlths_process(m_api_buf_t *p_buf)
{
    bc3c:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
    bc3e:	0004      	movs	r4, r0
    // Get buffer environment
    m_lay_buf_env_t *p_env = (m_lay_buf_env_t *)(&((m_tb_buf_t *)p_buf)->env[0]);
	m_printf(L_FND, "fnd hlths opcede[%x]", p_env->u5.opcode);
    bc40:	6982      	ldr	r2, [r0, #24]
    bc42:	2080      	movs	r0, #128	; 0x80
    bc44:	494e      	ldr	r1, [pc, #312]	; (bd80 <m_fnd_hlths_process+0x144>)
    bc46:	0100      	lsls	r0, r0, #4
    bc48:	3109      	adds	r1, #9
    bc4a:	f7f8 fed1 	bl	49f0 <m_printf>
    // Check that opcode is a 2-byte opcode
    if (M_IS_2_OCT_OPCODE(p_env->u5.opcode))
    bc4e:	22c0      	movs	r2, #192	; 0xc0
    bc50:	69a3      	ldr	r3, [r4, #24]
    bc52:	401a      	ands	r2, r3
    bc54:	2a80      	cmp	r2, #128	; 0x80
    bc56:	d000      	beq.n	bc5a <m_fnd_hlths_process+0x1e>
    bc58:	e091      	b.n	bd7e <m_fnd_hlths_process+0x142>
    {
        // Get only second byte of the opcode
        uint8_t opcode_2b = (uint8_t)(p_env->u5.opcode >> 8);
    bc5a:	0a1b      	lsrs	r3, r3, #8
    bc5c:	b2dd      	uxtb	r5, r3

        switch (opcode_2b)
    bc5e:	b2db      	uxtb	r3, r3
    bc60:	2b31      	cmp	r3, #49	; 0x31
    bc62:	d805      	bhi.n	bc70 <m_fnd_hlths_process+0x34>
    bc64:	2b2f      	cmp	r3, #47	; 0x2f
    bc66:	d229      	bcs.n	bcbc <m_fnd_hlths_process+0x80>
    bc68:	3b04      	subs	r3, #4
    bc6a:	2b02      	cmp	r3, #2
    bc6c:	d905      	bls.n	bc7a <m_fnd_hlths_process+0x3e>
    bc6e:	e084      	b.n	bd7a <m_fnd_hlths_process+0x13e>
    bc70:	2b33      	cmp	r3, #51	; 0x33
    bc72:	d93f      	bls.n	bcf4 <m_fnd_hlths_process+0xb8>
    bc74:	2b36      	cmp	r3, #54	; 0x36
    bc76:	d950      	bls.n	bd1a <m_fnd_hlths_process+0xde>
    bc78:	e07f      	b.n	bd7a <m_fnd_hlths_process+0x13e>
 * @param[in] opcode    Operation code
 ****************************************************************************************
 */
__STATIC void m_fnd_hlths_handler_attention(m_tb_buf_t *p_buf, uint8_t opcode)
{
    if (opcode != M_FND_HLTHS_OPCODE_ATTENTION_GET)
    bc7a:	2d04      	cmp	r5, #4
    bc7c:	d115      	bne.n	bcaa <m_fnd_hlths_process+0x6e>
 ****************************************************************************************
 */
__STATIC uint16_t m_fnd_hlths_buf_alloc(m_tb_buf_t **pp_buf, uint16_t data_len)
{
    // Try to allocate a buffer and return the status
    return (m_tb_buf_alloc(pp_buf, M_FND_BUF_HEAD_LEN, data_len, 0));
    bc7e:	2300      	movs	r3, #0
    bc80:	2201      	movs	r2, #1
    bc82:	2102      	movs	r1, #2
    bc84:	a803      	add	r0, sp, #12
    bc86:	f005 fc57 	bl	11538 <m_tb_buf_alloc>
__STATIC void m_fnd_hlths_send_attention_status(void)
{
    // Pointer to the buffer that will contain the message
    m_tb_buf_t *p_buf_status;

    if (m_fnd_hlths_buf_alloc(&p_buf_status, M_FND_HLTHS_ATTENTION_STATUS_LEN) == M_ERR_NO_ERROR)
    bc8a:	2800      	cmp	r0, #0
    bc8c:	d175      	bne.n	bd7a <m_fnd_hlths_process+0x13e>
    {
        // Get pointer to data
        uint8_t *p_data = M_TB_BUF_DATA(p_buf_status);
    bc8e:	9b03      	ldr	r3, [sp, #12]
    bc90:	001c      	movs	r4, r3
    bc92:	889b      	ldrh	r3, [r3, #4]
    bc94:	3430      	adds	r4, #48	; 0x30
    bc96:	18e4      	adds	r4, r4, r3

        // Write attention state
        *p_data = m_tb_state_get_attention_state();
    bc98:	f008 fbe4 	bl	14464 <m_tb_state_get_attention_state>

        // Send the message
        m_fnd_hlths_send(p_buf_status, M_FND_HLTHS_2B_OPCODE(M_FND_HLTHS_OPCODE_ATTENTION_STATUS));
    bc9c:	21f0      	movs	r1, #240	; 0xf0
    {
        // Get pointer to data
        uint8_t *p_data = M_TB_BUF_DATA(p_buf_status);

        // Write attention state
        *p_data = m_tb_state_get_attention_state();
    bc9e:	7020      	strb	r0, [r4, #0]

        // Send the message
        m_fnd_hlths_send(p_buf_status, M_FND_HLTHS_2B_OPCODE(M_FND_HLTHS_OPCODE_ATTENTION_STATUS));
    bca0:	00c9      	lsls	r1, r1, #3
    bca2:	9803      	ldr	r0, [sp, #12]
    bca4:	f7ff ff7e 	bl	bba4 <m_fnd_hlths_send>
    bca8:	e067      	b.n	bd7a <m_fnd_hlths_process+0x13e>
__STATIC void m_fnd_hlths_handler_attention(m_tb_buf_t *p_buf, uint8_t opcode)
{
    if (opcode != M_FND_HLTHS_OPCODE_ATTENTION_GET)
    {
        // Read value of the Attention Timer state
        uint8_t attention = *M_TB_BUF_DATA(p_buf);
    bcaa:	88a3      	ldrh	r3, [r4, #4]
    bcac:	18e4      	adds	r4, r4, r3
    bcae:	3430      	adds	r4, #48	; 0x30

        // Set attention timer state value
        m_tb_state_set_attention_state(attention);
    bcb0:	7820      	ldrb	r0, [r4, #0]
    bcb2:	f008 faa9 	bl	14208 <m_tb_state_set_attention_state>
    }

    if (opcode != M_FND_HLTHS_OPCODE_ATTENTION_SET_UNACK)
    bcb6:	2d06      	cmp	r5, #6
    bcb8:	d05f      	beq.n	bd7a <m_fnd_hlths_process+0x13e>
    bcba:	e7e0      	b.n	bc7e <m_fnd_hlths_process+0x42>
 ****************************************************************************************
 */
__STATIC void m_fnd_hlths_handler_fault(m_tb_buf_t *p_buf, uint8_t opcode)
{
    // Read Company ID
    uint16_t comp_id = co_read16p(M_TB_BUF_DATA(p_buf));
    bcbc:	0022      	movs	r2, r4
    bcbe:	88a3      	ldrh	r3, [r4, #4]
    bcc0:	3230      	adds	r2, #48	; 0x30
    bcc2:	18d3      	adds	r3, r2, r3
 * @return The 16 bits value.
 ****************************************************************************************
 */
__INLINE_S__ uint16_t co_read16p(void const *ptr16)
{
    uint16_t value = ((uint8_t *)ptr16)[0] | ((uint8_t *)ptr16)[1] << 8;
    bcc4:	785c      	ldrb	r4, [r3, #1]
    bcc6:	781b      	ldrb	r3, [r3, #0]
    bcc8:	0224      	lsls	r4, r4, #8
    bcca:	431c      	orrs	r4, r3

    // Inform the application about received request
    if (opcode == M_FND_HLTHS_OPCODE_FAULT_GET)
    {
        bc_m_send_fault_get_req_ind(comp_id);
    bccc:	0020      	movs	r0, r4
{
    // Read Company ID
    uint16_t comp_id = co_read16p(M_TB_BUF_DATA(p_buf));

    // Inform the application about received request
    if (opcode == M_FND_HLTHS_OPCODE_FAULT_GET)
    bcce:	2d31      	cmp	r5, #49	; 0x31
    bcd0:	d102      	bne.n	bcd8 <m_fnd_hlths_process+0x9c>
    {
        bc_m_send_fault_get_req_ind(comp_id);
    bcd2:	f7fd f9b7 	bl	9044 <bc_m_send_fault_get_req_ind>
    bcd6:	e052      	b.n	bd7e <m_fnd_hlths_process+0x142>
    }
    else
    {
        bc_m_send_fault_clear_ind(comp_id);
    bcd8:	f7fd f9f8 	bl	90cc <bc_m_send_fault_clear_ind>
    }

    // Check if status has to be sent
    if (opcode == M_FND_HLTHS_OPCODE_FAULT_CLEAR_UNACK)
    bcdc:	2d30      	cmp	r5, #48	; 0x30
    bcde:	d04c      	beq.n	bd7a <m_fnd_hlths_process+0x13e>
    {
        // Process next received message
        m_fnd_hlths_process_next();
    }
    else if (opcode == M_FND_HLTHS_OPCODE_FAULT_CLEAR)
    bce0:	2d2f      	cmp	r5, #47	; 0x2f
    bce2:	d14c      	bne.n	bd7e <m_fnd_hlths_process+0x142>
    {
        // Send Health Fault Status message
        m_fnd_hlths_send_status(comp_id, 0, true, 0, NULL);
    bce4:	2100      	movs	r1, #0
    bce6:	2201      	movs	r2, #1
    bce8:	9100      	str	r1, [sp, #0]
    bcea:	000b      	movs	r3, r1
    bcec:	0020      	movs	r0, r4
    bcee:	f7ff ff6d 	bl	bbcc <m_fnd_hlths_send_status>
    bcf2:	e044      	b.n	bd7e <m_fnd_hlths_process+0x142>
 ****************************************************************************************
 */
__STATIC void m_fnd_hlths_handler_fault_test(m_tb_buf_t *p_buf, uint8_t opcode)
{
    // Get pointer to data
    uint8_t *p_data = M_TB_BUF_DATA(p_buf);
    bcf4:	0022      	movs	r2, r4
    bcf6:	88a3      	ldrh	r3, [r4, #4]
    bcf8:	3230      	adds	r2, #48	; 0x30
    bcfa:	18d3      	adds	r3, r2, r3
    uint8_t test_id = *p_data;
    // Read Company ID
    uint16_t comp_id = co_read16p(p_data + 1);

    // Inform the application that test procedure has to be performed on an element
    bc_m_send_fault_test_req_ind(comp_id, test_id, (opcode == M_FND_HLTHS_OPCODE_FAULT_TEST));
    bcfc:	002a      	movs	r2, r5
    bcfe:	3a32      	subs	r2, #50	; 0x32
    bd00:	4251      	negs	r1, r2
    bd02:	414a      	adcs	r2, r1
    bd04:	7898      	ldrb	r0, [r3, #2]
    bd06:	7819      	ldrb	r1, [r3, #0]
    bd08:	785b      	ldrb	r3, [r3, #1]
    bd0a:	0200      	lsls	r0, r0, #8
    bd0c:	b2d2      	uxtb	r2, r2
    bd0e:	4318      	orrs	r0, r3
    bd10:	f7fd f9ba 	bl	9088 <bc_m_send_fault_test_req_ind>

    // Check if status has to be sent
    if (opcode == M_FND_HLTHS_OPCODE_FAULT_TEST_UNACK)
    bd14:	2d33      	cmp	r5, #51	; 0x33
    bd16:	d132      	bne.n	bd7e <m_fnd_hlths_process+0x142>
    bd18:	e02f      	b.n	bd7a <m_fnd_hlths_process+0x13e>
 * @param[in] opcode    Operation code
 ****************************************************************************************
 */
__STATIC void m_fnd_hlths_handler_period(m_tb_buf_t *p_buf, uint8_t opcode)
{
    if (opcode != M_FND_HLTHS_OPCODE_PERIOD_GET)
    bd1a:	2d34      	cmp	r5, #52	; 0x34
    bd1c:	d115      	bne.n	bd4a <m_fnd_hlths_process+0x10e>
 ****************************************************************************************
 */
__STATIC uint16_t m_fnd_hlths_buf_alloc(m_tb_buf_t **pp_buf, uint16_t data_len)
{
    // Try to allocate a buffer and return the status
    return (m_tb_buf_alloc(pp_buf, M_FND_BUF_HEAD_LEN, data_len, 0));
    bd1e:	2300      	movs	r3, #0
    bd20:	2201      	movs	r2, #1
    bd22:	2102      	movs	r1, #2
    bd24:	a803      	add	r0, sp, #12
    bd26:	f005 fc07 	bl	11538 <m_tb_buf_alloc>
__STATIC void m_fnd_hlths_send_period_status(void)
{
    // Pointer to the buffer that will contain the message
    m_tb_buf_t *p_buf_status;

    if (m_fnd_hlths_buf_alloc(&p_buf_status, M_FND_HLTHS_PERIOD_STATUS_LEN) == M_ERR_NO_ERROR)
    bd2a:	2800      	cmp	r0, #0
    bd2c:	d125      	bne.n	bd7a <m_fnd_hlths_process+0x13e>
    {
        // Get pointer to data
        uint8_t *p_data = M_TB_BUF_DATA(p_buf_status);

        // Write fast period divisor state
        *p_data = p_m_fnd_hlths_env->fast_period_divisor;
    bd2e:	4b15      	ldr	r3, [pc, #84]	; (bd84 <m_fnd_hlths_process+0x148>)
    m_tb_buf_t *p_buf_status;

    if (m_fnd_hlths_buf_alloc(&p_buf_status, M_FND_HLTHS_PERIOD_STATUS_LEN) == M_ERR_NO_ERROR)
    {
        // Get pointer to data
        uint8_t *p_data = M_TB_BUF_DATA(p_buf_status);
    bd30:	9a03      	ldr	r2, [sp, #12]

        // Write fast period divisor state
        *p_data = p_m_fnd_hlths_env->fast_period_divisor;
    bd32:	681b      	ldr	r3, [r3, #0]
    bd34:	7a59      	ldrb	r1, [r3, #9]
    bd36:	8893      	ldrh	r3, [r2, #4]
    bd38:	18d3      	adds	r3, r2, r3
    bd3a:	3330      	adds	r3, #48	; 0x30
    bd3c:	7019      	strb	r1, [r3, #0]

        // Send the message
        m_fnd_hlths_send(p_buf_status, M_FND_HLTHS_2B_OPCODE(M_FND_HLTHS_OPCODE_PERIOD_STATUS));
    bd3e:	21de      	movs	r1, #222	; 0xde
    bd40:	9803      	ldr	r0, [sp, #12]
    bd42:	0189      	lsls	r1, r1, #6
    bd44:	f7ff ff2e 	bl	bba4 <m_fnd_hlths_send>
    bd48:	e017      	b.n	bd7a <m_fnd_hlths_process+0x13e>
__STATIC void m_fnd_hlths_handler_period(m_tb_buf_t *p_buf, uint8_t opcode)
{
    if (opcode != M_FND_HLTHS_OPCODE_PERIOD_GET)
    {
        // Read the fast period divider value
        uint8_t fast_period_div = *M_TB_BUF_DATA(p_buf);
    bd4a:	88a3      	ldrh	r3, [r4, #4]
    bd4c:	18e4      	adds	r4, r4, r3
    bd4e:	3430      	adds	r4, #48	; 0x30
    bd50:	7824      	ldrb	r4, [r4, #0]

        // Check received value
        if (fast_period_div <= M_FND_HLTHS_FAST_PERIOD_DIV_MAX)
    bd52:	2c0f      	cmp	r4, #15
    bd54:	d80f      	bhi.n	bd76 <m_fnd_hlths_process+0x13a>
        {
            // Check if fast period divider value will be modified
            if (fast_period_div != p_m_fnd_hlths_env->fast_period_divisor)
    bd56:	4e0b      	ldr	r6, [pc, #44]	; (bd84 <m_fnd_hlths_process+0x148>)
    bd58:	6833      	ldr	r3, [r6, #0]
    bd5a:	7a5a      	ldrb	r2, [r3, #9]
    bd5c:	42a2      	cmp	r2, r4
    bd5e:	d008      	beq.n	bd72 <m_fnd_hlths_process+0x136>
            {
                // Get current publish period in milliseconds
                uint32_t period_ms = m_tb_mio_get_period(p_m_fnd_hlths_env->model_lid);
    bd60:	7a18      	ldrb	r0, [r3, #8]
    bd62:	f007 fe23 	bl	139ac <m_tb_mio_get_period>

                if (period_ms != 0)
    bd66:	2800      	cmp	r0, #0
    bd68:	d003      	beq.n	bd72 <m_fnd_hlths_process+0x136>
                {
                    // Inform the application about the new publication period
                    bc_m_send_fault_period_ind(period_ms, period_ms >> fast_period_div);
    bd6a:	0001      	movs	r1, r0
    bd6c:	40e1      	lsrs	r1, r4
    bd6e:	f7fd f9cf 	bl	9110 <bc_m_send_fault_period_ind>
                }
            }

            // Set fast period divisor value
            p_m_fnd_hlths_env->fast_period_divisor = fast_period_div;
    bd72:	6833      	ldr	r3, [r6, #0]
    bd74:	725c      	strb	r4, [r3, #9]
        }
    }

    if (opcode != M_FND_HLTHS_OPCODE_PERIOD_SET_UNACK)
    bd76:	2d36      	cmp	r5, #54	; 0x36
    bd78:	d1d1      	bne.n	bd1e <m_fnd_hlths_process+0xe2>
            case (M_FND_HLTHS_OPCODE_FAULT_TEST)          :
            case (M_FND_HLTHS_OPCODE_FAULT_TEST_UNACK)    : m_fnd_hlths_handler_fault_test(p_buf, opcode_2b); break;
            case (M_FND_HLTHS_OPCODE_PERIOD_GET)          :
            case (M_FND_HLTHS_OPCODE_PERIOD_SET)          :
            case (M_FND_HLTHS_OPCODE_PERIOD_SET_UNACK)    : m_fnd_hlths_handler_period(p_buf, opcode_2b);     break;
            default                                       : m_fnd_hlths_process_next();                       break;
    bd7a:	f000 f805 	bl	bd88 <m_fnd_hlths_process_next>
        }
    }
}
    bd7e:	bd7f      	pop	{r0, r1, r2, r3, r4, r5, r6, pc}
    bd80:	00021798 	.word	0x00021798
    bd84:	100126a4 	.word	0x100126a4

0000bd88 <m_fnd_hlths_process_next>:
 * @brief Pop first buffer from the processing queue, release it and start processing of
 * next one in the processing queue.
 ****************************************************************************************
 */
__STATIC void m_fnd_hlths_process_next(void)
{
    bd88:	b510      	push	{r4, lr}
    // Remove first buffer in the process queue
    m_tb_buf_t *p_buf = (m_tb_buf_t *)co_list_pop_front(&p_m_fnd_hlths_env->process_queue);
    bd8a:	4c06      	ldr	r4, [pc, #24]	; (bda4 <m_fnd_hlths_process_next+0x1c>)
    bd8c:	6820      	ldr	r0, [r4, #0]
    bd8e:	f7f8 fb2d 	bl	43ec <co_list_pop_front>

    // Release the buffer
    m_tb_buf_release(p_buf);
    bd92:	f005 fc83 	bl	1169c <m_tb_buf_release>
    bd96:	6823      	ldr	r3, [r4, #0]
    bd98:	6818      	ldr	r0, [r3, #0]

    // Process next buffer
    p_buf = (m_tb_buf_t *)co_list_pick(&p_m_fnd_hlths_env->process_queue);

    if (p_buf != NULL)
    bd9a:	2800      	cmp	r0, #0
    bd9c:	d001      	beq.n	bda2 <m_fnd_hlths_process_next+0x1a>
    {
        m_fnd_hlths_process(p_buf);
    bd9e:	f7ff ff4d 	bl	bc3c <m_fnd_hlths_process>
    }
}
    bda2:	bd10      	pop	{r4, pc}
    bda4:	100126a4 	.word	0x100126a4

0000bda8 <m_fnd_hlths_cb_rx>:
 *                            False, it can have been relayed.
 ****************************************************************************************
 */
__STATIC void m_fnd_hlths_cb_rx(m_lid_t model_lid, uint32_t opcode, m_api_buf_t *p_api_buf, m_lid_t app_key_lid,
                                uint16_t src, int8_t rssi, bool not_relayed)
{
    bda8:	b530      	push	{r4, r5, lr}
	M_PRINTF(L_FND, "");
    bdaa:	4b1b      	ldr	r3, [pc, #108]	; (be18 <m_fnd_hlths_cb_rx+0x70>)
 *                            False, it can have been relayed.
 ****************************************************************************************
 */
__STATIC void m_fnd_hlths_cb_rx(m_lid_t model_lid, uint32_t opcode, m_api_buf_t *p_api_buf, m_lid_t app_key_lid,
                                uint16_t src, int8_t rssi, bool not_relayed)
{
    bdac:	b085      	sub	sp, #20
	M_PRINTF(L_FND, "");
    bdae:	681b      	ldr	r3, [r3, #0]
 *                            False, it can have been relayed.
 ****************************************************************************************
 */
__STATIC void m_fnd_hlths_cb_rx(m_lid_t model_lid, uint32_t opcode, m_api_buf_t *p_api_buf, m_lid_t app_key_lid,
                                uint16_t src, int8_t rssi, bool not_relayed)
{
    bdb0:	0015      	movs	r5, r2
	M_PRINTF(L_FND, "");
    bdb2:	051b      	lsls	r3, r3, #20
    bdb4:	d515      	bpl.n	bde2 <m_fnd_hlths_cb_rx+0x3a>
    bdb6:	4c19      	ldr	r4, [pc, #100]	; (be1c <m_fnd_hlths_cb_rx+0x74>)
    bdb8:	0023      	movs	r3, r4
    bdba:	3353      	adds	r3, #83	; 0x53
    bdbc:	9300      	str	r3, [sp, #0]
    bdbe:	0022      	movs	r2, r4
    bdc0:	0020      	movs	r0, r4
    bdc2:	2381      	movs	r3, #129	; 0x81
    bdc4:	0021      	movs	r1, r4
    bdc6:	3236      	adds	r2, #54	; 0x36
    bdc8:	009b      	lsls	r3, r3, #2
    bdca:	3044      	adds	r0, #68	; 0x44
    bdcc:	f7f8 fdee 	bl	49ac <m_print>
    bdd0:	0020      	movs	r0, r4
    bdd2:	3065      	adds	r0, #101	; 0x65
    bdd4:	f7f8 fdea 	bl	49ac <m_print>
    bdd8:	0020      	movs	r0, r4
    bdda:	1da1      	adds	r1, r4, #6
    bddc:	3066      	adds	r0, #102	; 0x66
    bdde:	f7f8 fde5 	bl	49ac <m_print>
    // Data length
    uint16_t data_len = ((m_tb_buf_t *)p_api_buf)->data_len;
    // Allocate a buffer
    m_tb_buf_t *p_buf;

    m_tb_buf_alloc(&p_buf, 0, data_len, 0);
    bde2:	2300      	movs	r3, #0
__STATIC void m_fnd_hlths_cb_rx(m_lid_t model_lid, uint32_t opcode, m_api_buf_t *p_api_buf, m_lid_t app_key_lid,
                                uint16_t src, int8_t rssi, bool not_relayed)
{
	M_PRINTF(L_FND, "");
    // Data length
    uint16_t data_len = ((m_tb_buf_t *)p_api_buf)->data_len;
    bde4:	892c      	ldrh	r4, [r5, #8]
    // Allocate a buffer
    m_tb_buf_t *p_buf;

    m_tb_buf_alloc(&p_buf, 0, data_len, 0);
    bde6:	0019      	movs	r1, r3
    bde8:	0022      	movs	r2, r4
    bdea:	a803      	add	r0, sp, #12
    bdec:	f005 fba4 	bl	11538 <m_tb_buf_alloc>

    // Copy content of the received buffer in the allocated one
    m_tb_buf_copy((m_tb_buf_t *)p_api_buf, p_buf, data_len, true);
    bdf0:	2301      	movs	r3, #1
    bdf2:	0022      	movs	r2, r4
    bdf4:	9903      	ldr	r1, [sp, #12]
    bdf6:	0028      	movs	r0, r5
    bdf8:	f005 fc92 	bl	11720 <m_tb_buf_copy>

    // Insert the buffer in the process queue
    co_list_push_back(&p_m_fnd_hlths_env->process_queue, &p_buf->hdr);
    bdfc:	4c08      	ldr	r4, [pc, #32]	; (be20 <m_fnd_hlths_cb_rx+0x78>)
    bdfe:	9903      	ldr	r1, [sp, #12]
    be00:	6820      	ldr	r0, [r4, #0]
    be02:	f7f8 fac8 	bl	4396 <co_list_push_back>
    be06:	6823      	ldr	r3, [r4, #0]

    // Check if buffer can be processed now or if another buffer is currently processed
    if ((m_tb_buf_t *)co_list_pick(&p_m_fnd_hlths_env->process_queue) == p_buf)
    be08:	9803      	ldr	r0, [sp, #12]
    be0a:	681b      	ldr	r3, [r3, #0]
    be0c:	4298      	cmp	r0, r3
    be0e:	d101      	bne.n	be14 <m_fnd_hlths_cb_rx+0x6c>
    {
        m_fnd_hlths_process(p_buf);
    be10:	f7ff ff14 	bl	bc3c <m_fnd_hlths_process>
    }
}
    be14:	b005      	add	sp, #20
    be16:	bd30      	pop	{r4, r5, pc}
    be18:	10010514 	.word	0x10010514
    be1c:	00021798 	.word	0x00021798
    be20:	100126a4 	.word	0x100126a4

0000be24 <m_fnd_hlths_cb_opcode_check>:
 * @param[in] opcode        Operation code to check
 ****************************************************************************************
 */
__STATIC void m_fnd_hlths_cb_opcode_check(m_lid_t model_lid, uint32_t opcode)
{
	M_PRINTF(L_FND, "");
    be24:	4b18      	ldr	r3, [pc, #96]	; (be88 <m_fnd_hlths_cb_opcode_check+0x64>)
 * @param[in] model_lid     Model local index
 * @param[in] opcode        Operation code to check
 ****************************************************************************************
 */
__STATIC void m_fnd_hlths_cb_opcode_check(m_lid_t model_lid, uint32_t opcode)
{
    be26:	b573      	push	{r0, r1, r4, r5, r6, lr}
	M_PRINTF(L_FND, "");
    be28:	681b      	ldr	r3, [r3, #0]
 * @param[in] model_lid     Model local index
 * @param[in] opcode        Operation code to check
 ****************************************************************************************
 */
__STATIC void m_fnd_hlths_cb_opcode_check(m_lid_t model_lid, uint32_t opcode)
{
    be2a:	0006      	movs	r6, r0
    be2c:	000d      	movs	r5, r1
	M_PRINTF(L_FND, "");
    be2e:	051b      	lsls	r3, r3, #20
    be30:	d515      	bpl.n	be5e <m_fnd_hlths_cb_opcode_check+0x3a>
    be32:	4c16      	ldr	r4, [pc, #88]	; (be8c <m_fnd_hlths_cb_opcode_check+0x68>)
    be34:	0023      	movs	r3, r4
    be36:	3369      	adds	r3, #105	; 0x69
    be38:	9300      	str	r3, [sp, #0]
    be3a:	0022      	movs	r2, r4
    be3c:	0020      	movs	r0, r4
    be3e:	2389      	movs	r3, #137	; 0x89
    be40:	0021      	movs	r1, r4
    be42:	3236      	adds	r2, #54	; 0x36
    be44:	009b      	lsls	r3, r3, #2
    be46:	3044      	adds	r0, #68	; 0x44
    be48:	f7f8 fdb0 	bl	49ac <m_print>
    be4c:	0020      	movs	r0, r4
    be4e:	3065      	adds	r0, #101	; 0x65
    be50:	f7f8 fdac 	bl	49ac <m_print>
    be54:	0020      	movs	r0, r4
    be56:	1da1      	adds	r1, r4, #6
    be58:	3066      	adds	r0, #102	; 0x66
    be5a:	f7f8 fda7 	bl	49ac <m_print>
    // Status
    uint16_t status = M_ERR_NOT_SUPPORTED;

    // Check that opcode is a 2-byte opcode
    if (M_IS_2_OCT_OPCODE(opcode))
    be5e:	23c0      	movs	r3, #192	; 0xc0
    be60:	402b      	ands	r3, r5
    be62:	2b80      	cmp	r3, #128	; 0x80
    be64:	d108      	bne.n	be78 <m_fnd_hlths_cb_opcode_check+0x54>
    {
        // Get only second byte of the opcode
        uint8_t opcode_2b = (uint8_t)(opcode >> 8);
    be66:	0a2b      	lsrs	r3, r5, #8
    be68:	b2db      	uxtb	r3, r3

        if (((opcode_2b >= M_FND_HLTHS_OPCODE_ATTENTION_GET) &&
    be6a:	1f19      	subs	r1, r3, #4
             (opcode_2b <= M_FND_HLTHS_OPCODE_ATTENTION_STATUS)) ||
            ((opcode_2b >= M_FND_HLTHS_OPCODE_FAULT_CLEAR) &&
             (opcode_2b <= M_FND_HLTHS_OPCODE_PERIOD_STATUS)))
        {
            status = M_ERR_NO_ERROR;
    be6c:	2200      	movs	r2, #0
    if (M_IS_2_OCT_OPCODE(opcode))
    {
        // Get only second byte of the opcode
        uint8_t opcode_2b = (uint8_t)(opcode >> 8);

        if (((opcode_2b >= M_FND_HLTHS_OPCODE_ATTENTION_GET) &&
    be6e:	2903      	cmp	r1, #3
    be70:	d904      	bls.n	be7c <m_fnd_hlths_cb_opcode_check+0x58>
             (opcode_2b <= M_FND_HLTHS_OPCODE_ATTENTION_STATUS)) ||
    be72:	3b2f      	subs	r3, #47	; 0x2f
    be74:	2b08      	cmp	r3, #8
    be76:	d901      	bls.n	be7c <m_fnd_hlths_cb_opcode_check+0x58>
 */
__STATIC void m_fnd_hlths_cb_opcode_check(m_lid_t model_lid, uint32_t opcode)
{
	M_PRINTF(L_FND, "");
    // Status
    uint16_t status = M_ERR_NOT_SUPPORTED;
    be78:	22a8      	movs	r2, #168	; 0xa8
    be7a:	0112      	lsls	r2, r2, #4
            status = M_ERR_NO_ERROR;
        }
    }

    // Indicate if provided operation code is supported or not
    bc_m_model_opcode_status(model_lid, opcode, status);
    be7c:	0029      	movs	r1, r5
    be7e:	0030      	movs	r0, r6
    be80:	f7fc ffc0 	bl	8e04 <bc_m_model_opcode_status>
}
    be84:	bd73      	pop	{r0, r1, r4, r5, r6, pc}
    be86:	46c0      	nop			; (mov r8, r8)
    be88:	10010514 	.word	0x10010514
    be8c:	00021798 	.word	0x00021798

0000be90 <m_fnd_hlths_cb_sent>:
 * @param[in] status        Transmission status.
 ****************************************************************************************
 */
__STATIC void m_fnd_hlths_cb_sent(m_lid_t model_lid, uint8_t tx_hdl, m_api_buf_t *p_api_buf, uint16_t status)
{
	M_PRINTF(L_FND, "");
    be90:	4b0f      	ldr	r3, [pc, #60]	; (bed0 <m_fnd_hlths_cb_sent+0x40>)
 * @param[in] p_api_buf     Pointer to the buffer containing the transmitted PDU.
 * @param[in] status        Transmission status.
 ****************************************************************************************
 */
__STATIC void m_fnd_hlths_cb_sent(m_lid_t model_lid, uint8_t tx_hdl, m_api_buf_t *p_api_buf, uint16_t status)
{
    be92:	b537      	push	{r0, r1, r2, r4, r5, lr}
	M_PRINTF(L_FND, "");
    be94:	681b      	ldr	r3, [r3, #0]
 * @param[in] p_api_buf     Pointer to the buffer containing the transmitted PDU.
 * @param[in] status        Transmission status.
 ****************************************************************************************
 */
__STATIC void m_fnd_hlths_cb_sent(m_lid_t model_lid, uint8_t tx_hdl, m_api_buf_t *p_api_buf, uint16_t status)
{
    be96:	0015      	movs	r5, r2
	M_PRINTF(L_FND, "");
    be98:	051b      	lsls	r3, r3, #20
    be9a:	d515      	bpl.n	bec8 <m_fnd_hlths_cb_sent+0x38>
    be9c:	4b0d      	ldr	r3, [pc, #52]	; (bed4 <m_fnd_hlths_cb_sent+0x44>)
    be9e:	4c0e      	ldr	r4, [pc, #56]	; (bed8 <m_fnd_hlths_cb_sent+0x48>)
    bea0:	3305      	adds	r3, #5
    bea2:	9300      	str	r3, [sp, #0]
    bea4:	0022      	movs	r2, r4
    bea6:	0020      	movs	r0, r4
    bea8:	2392      	movs	r3, #146	; 0x92
    beaa:	0021      	movs	r1, r4
    beac:	3236      	adds	r2, #54	; 0x36
    beae:	009b      	lsls	r3, r3, #2
    beb0:	3044      	adds	r0, #68	; 0x44
    beb2:	f7f8 fd7b 	bl	49ac <m_print>
    beb6:	0020      	movs	r0, r4
    beb8:	3065      	adds	r0, #101	; 0x65
    beba:	f7f8 fd77 	bl	49ac <m_print>
    bebe:	0020      	movs	r0, r4
    bec0:	1da1      	adds	r1, r4, #6
    bec2:	3066      	adds	r0, #102	; 0x66
    bec4:	f7f8 fd72 	bl	49ac <m_print>
    // Release the buffer
    m_tb_buf_release((m_tb_buf_t *)p_api_buf);
    bec8:	0028      	movs	r0, r5
    beca:	f005 fbe7 	bl	1169c <m_tb_buf_release>
}
    bece:	bd37      	pop	{r0, r1, r2, r4, r5, pc}
    bed0:	10010514 	.word	0x10010514
    bed4:	00021818 	.word	0x00021818
    bed8:	00021798 	.word	0x00021798

0000bedc <m_fnd_hlths_cb_publish_period>:
 * @param[in] period_ms     Publish period in milliseconds
 ****************************************************************************************
 */
__STATIC void m_fnd_hlths_cb_publish_period(uint8_t model_lid, uint32_t period_ms)
{
	M_PRINTF(L_FND, "");
    bedc:	4b12      	ldr	r3, [pc, #72]	; (bf28 <m_fnd_hlths_cb_publish_period+0x4c>)
 * @param[in] model_lid     Model local index
 * @param[in] period_ms     Publish period in milliseconds
 ****************************************************************************************
 */
__STATIC void m_fnd_hlths_cb_publish_period(uint8_t model_lid, uint32_t period_ms)
{
    bede:	b537      	push	{r0, r1, r2, r4, r5, lr}
	M_PRINTF(L_FND, "");
    bee0:	681b      	ldr	r3, [r3, #0]
 * @param[in] model_lid     Model local index
 * @param[in] period_ms     Publish period in milliseconds
 ****************************************************************************************
 */
__STATIC void m_fnd_hlths_cb_publish_period(uint8_t model_lid, uint32_t period_ms)
{
    bee2:	000d      	movs	r5, r1
	M_PRINTF(L_FND, "");
    bee4:	051b      	lsls	r3, r3, #20
    bee6:	d515      	bpl.n	bf14 <m_fnd_hlths_cb_publish_period+0x38>
    bee8:	4b10      	ldr	r3, [pc, #64]	; (bf2c <m_fnd_hlths_cb_publish_period+0x50>)
    beea:	4c11      	ldr	r4, [pc, #68]	; (bf30 <m_fnd_hlths_cb_publish_period+0x54>)
    beec:	3319      	adds	r3, #25
    beee:	9300      	str	r3, [sp, #0]
    bef0:	0022      	movs	r2, r4
    bef2:	0020      	movs	r0, r4
    bef4:	2396      	movs	r3, #150	; 0x96
    bef6:	0021      	movs	r1, r4
    bef8:	3236      	adds	r2, #54	; 0x36
    befa:	009b      	lsls	r3, r3, #2
    befc:	3044      	adds	r0, #68	; 0x44
    befe:	f7f8 fd55 	bl	49ac <m_print>
    bf02:	0020      	movs	r0, r4
    bf04:	3065      	adds	r0, #101	; 0x65
    bf06:	f7f8 fd51 	bl	49ac <m_print>
    bf0a:	0020      	movs	r0, r4
    bf0c:	1da1      	adds	r1, r4, #6
    bf0e:	3066      	adds	r0, #102	; 0x66
    bf10:	f7f8 fd4c 	bl	49ac <m_print>
    // Inform the application about the new publication period
    bc_m_send_fault_period_ind(period_ms, period_ms >> p_m_fnd_hlths_env->fast_period_divisor);
    bf14:	0029      	movs	r1, r5
    bf16:	4b07      	ldr	r3, [pc, #28]	; (bf34 <m_fnd_hlths_cb_publish_period+0x58>)
    bf18:	0028      	movs	r0, r5
    bf1a:	681b      	ldr	r3, [r3, #0]
    bf1c:	7a5b      	ldrb	r3, [r3, #9]
    bf1e:	40d9      	lsrs	r1, r3
    bf20:	f7fd f8f6 	bl	9110 <bc_m_send_fault_period_ind>
}
    bf24:	bd37      	pop	{r0, r1, r2, r4, r5, pc}
    bf26:	46c0      	nop			; (mov r8, r8)
    bf28:	10010514 	.word	0x10010514
    bf2c:	00021818 	.word	0x00021818
    bf30:	00021798 	.word	0x00021798
    bf34:	100126a4 	.word	0x100126a4

0000bf38 <m_fnd_hlths_init>:
 * GLOBAL FUNCTIONS
 ****************************************************************************************
 */

uint16_t m_fnd_hlths_init(bool reset, void *p_env, const m_cfg_t* p_cfg)
{
    bf38:	b537      	push	{r0, r1, r2, r4, r5, lr}
    bf3a:	4b0c      	ldr	r3, [pc, #48]	; (bf6c <m_fnd_hlths_init+0x34>)
    bf3c:	0005      	movs	r5, r0
    bf3e:	000c      	movs	r4, r1
    if (!reset)
    bf40:	2800      	cmp	r0, #0
    bf42:	d10f      	bne.n	bf64 <m_fnd_hlths_init+0x2c>
    {
        // Get environment for Health Client model
        p_m_fnd_hlths_env = (m_fnd_hlths_env_t *)p_env;
    bf44:	6019      	str	r1, [r3, #0]

        // Initialize environment
        memset(p_m_fnd_hlths_env, 0, sizeof(m_fnd_hlths_env_t));
    bf46:	220c      	movs	r2, #12
    bf48:	0001      	movs	r1, r0
    bf4a:	0020      	movs	r0, r4
    bf4c:	f009 fd7e 	bl	15a4c <memset>

        // Register the model
        bc_m_register_model(M_FND_HLTHS_MODEL_ID, 0, false, &m_fnd_hlths_cb,
    bf50:	4b07      	ldr	r3, [pc, #28]	; (bf70 <m_fnd_hlths_init+0x38>)
                             &p_m_fnd_hlths_env->model_lid);
    bf52:	3408      	adds	r4, #8

        // Initialize environment
        memset(p_m_fnd_hlths_env, 0, sizeof(m_fnd_hlths_env_t));

        // Register the model
        bc_m_register_model(M_FND_HLTHS_MODEL_ID, 0, false, &m_fnd_hlths_cb,
    bf54:	9400      	str	r4, [sp, #0]
    bf56:	3338      	adds	r3, #56	; 0x38
    bf58:	002a      	movs	r2, r5
    bf5a:	0029      	movs	r1, r5
    bf5c:	2002      	movs	r0, #2
    bf5e:	f7fc ff55 	bl	8e0c <bc_m_register_model>
    bf62:	e001      	b.n	bf68 <m_fnd_hlths_init+0x30>
                             &p_m_fnd_hlths_env->model_lid);
    }
    else
    {
        p_m_fnd_hlths_env = NULL;
    bf64:	2200      	movs	r2, #0
    bf66:	601a      	str	r2, [r3, #0]
    }

    // Return environment size
    return (sizeof(m_fnd_hlths_env_t));
}
    bf68:	200c      	movs	r0, #12
    bf6a:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
    bf6c:	100126a4 	.word	0x100126a4
    bf70:	00021818 	.word	0x00021818

0000bf74 <m_fnd_hlths_get_env_size>:

uint16_t m_fnd_hlths_get_env_size(const m_cfg_t* p_cfg)
{
    // Return environment size
    return (sizeof(m_fnd_hlths_env_t));
}
    bf74:	200c      	movs	r0, #12
    bf76:	4770      	bx	lr

0000bf78 <m_fnd_hlths_status_ind>:

void m_fnd_hlths_status_ind(uint16_t comp_id, uint8_t test_id, uint8_t length, uint8_t *p_fault_array)
{
    bf78:	b507      	push	{r0, r1, r2, lr}
    // Send Health Status
    m_fnd_hlths_send_status(comp_id, test_id, false, length, p_fault_array);
    bf7a:	9300      	str	r3, [sp, #0]
    bf7c:	0013      	movs	r3, r2
    bf7e:	2200      	movs	r2, #0
    bf80:	f7ff fe24 	bl	bbcc <m_fnd_hlths_send_status>
}
    bf84:	bd07      	pop	{r0, r1, r2, pc}

0000bf86 <m_fnd_hlths_cfm>:

void m_fnd_hlths_cfm(bool accept, uint16_t comp_id, uint8_t test_id, uint8_t length,
                     uint8_t *p_fault_array)
{
    bf86:	b513      	push	{r0, r1, r4, lr}
    bf88:	0004      	movs	r4, r0
    bf8a:	0008      	movs	r0, r1
    bf8c:	0011      	movs	r1, r2
    if (accept)
    bf8e:	2c00      	cmp	r4, #0
    bf90:	d005      	beq.n	bf9e <m_fnd_hlths_cfm+0x18>
    {
        // Send Health Status
        m_fnd_hlths_send_status(comp_id, test_id, true, length, p_fault_array);
    bf92:	9a04      	ldr	r2, [sp, #16]
    bf94:	9200      	str	r2, [sp, #0]
    bf96:	2201      	movs	r2, #1
    bf98:	f7ff fe18 	bl	bbcc <m_fnd_hlths_send_status>
    bf9c:	e001      	b.n	bfa2 <m_fnd_hlths_cfm+0x1c>
    }
    else
    {
        // Process next received message
        m_fnd_hlths_process_next();
    bf9e:	f7ff fef3 	bl	bd88 <m_fnd_hlths_process_next>
    }
}
    bfa2:	bd13      	pop	{r0, r1, r4, pc}

0000bfa4 <m_lay_get_env_size>:
 ****************************************************************************************
 */


uint16_t m_lay_get_env_size(const m_cfg_t* p_cfg)
{
    bfa4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    bfa6:	0004      	movs	r4, r0
    uint16_t    total_env_size = 0;

    // Retrieve size of environment variable required for following mesh layers
    total_env_size += CO_ALIGN4_HI(m_lay_net_get_env_size(p_cfg));
    bfa8:	f002 f944 	bl	e234 <m_lay_net_get_env_size>
    bfac:	0007      	movs	r7, r0
    total_env_size += CO_ALIGN4_HI(m_lay_ltrans_get_env_size(p_cfg));
    bfae:	0020      	movs	r0, r4
    bfb0:	2503      	movs	r5, #3
    bfb2:	f001 f9e5 	bl	d380 <m_lay_ltrans_get_env_size>
    bfb6:	3703      	adds	r7, #3
    bfb8:	1940      	adds	r0, r0, r5
    bfba:	43a8      	bics	r0, r5
    bfbc:	43af      	bics	r7, r5
    bfbe:	183f      	adds	r7, r7, r0
    total_env_size += CO_ALIGN4_HI(m_lay_utrans_get_env_size(p_cfg));
    bfc0:	0020      	movs	r0, r4
    bfc2:	f002 fd23 	bl	ea0c <m_lay_utrans_get_env_size>
    bfc6:	1946      	adds	r6, r0, r5
    total_env_size += CO_ALIGN4_HI(m_lay_access_get_env_size(p_cfg));
    bfc8:	0020      	movs	r0, r4
    bfca:	f000 fa0f 	bl	c3ec <m_lay_access_get_env_size>
    bfce:	1944      	adds	r4, r0, r5
    total_env_size += CO_ALIGN4_HI(m_lay_hb_get_env_size());
    bfd0:	f000 fc1e 	bl	c810 <m_lay_hb_get_env_size>
    uint16_t    total_env_size = 0;

    // Retrieve size of environment variable required for following mesh layers
    total_env_size += CO_ALIGN4_HI(m_lay_net_get_env_size(p_cfg));
    total_env_size += CO_ALIGN4_HI(m_lay_ltrans_get_env_size(p_cfg));
    total_env_size += CO_ALIGN4_HI(m_lay_utrans_get_env_size(p_cfg));
    bfd4:	43ae      	bics	r6, r5
{
    uint16_t    total_env_size = 0;

    // Retrieve size of environment variable required for following mesh layers
    total_env_size += CO_ALIGN4_HI(m_lay_net_get_env_size(p_cfg));
    total_env_size += CO_ALIGN4_HI(m_lay_ltrans_get_env_size(p_cfg));
    bfd6:	b2bf      	uxth	r7, r7
    total_env_size += CO_ALIGN4_HI(m_lay_utrans_get_env_size(p_cfg));
    bfd8:	19bf      	adds	r7, r7, r6
    total_env_size += CO_ALIGN4_HI(m_lay_access_get_env_size(p_cfg));
    bfda:	43ac      	bics	r4, r5
    uint16_t    total_env_size = 0;

    // Retrieve size of environment variable required for following mesh layers
    total_env_size += CO_ALIGN4_HI(m_lay_net_get_env_size(p_cfg));
    total_env_size += CO_ALIGN4_HI(m_lay_ltrans_get_env_size(p_cfg));
    total_env_size += CO_ALIGN4_HI(m_lay_utrans_get_env_size(p_cfg));
    bfdc:	b2be      	uxth	r6, r7
    total_env_size += CO_ALIGN4_HI(m_lay_access_get_env_size(p_cfg));
    bfde:	1936      	adds	r6, r6, r4
    #endif //(BLE_MESH_FRIEND)
    #if (BLE_MESH_GATT_PROXY)
    total_env_size += CO_ALIGN4_HI(m_lay_proxy_get_env_size(p_cfg));
    #endif // (BLE_MESH_GATT_PROXY)

    return total_env_size;
    bfe0:	1940      	adds	r0, r0, r5

    // Retrieve size of environment variable required for following mesh layers
    total_env_size += CO_ALIGN4_HI(m_lay_net_get_env_size(p_cfg));
    total_env_size += CO_ALIGN4_HI(m_lay_ltrans_get_env_size(p_cfg));
    total_env_size += CO_ALIGN4_HI(m_lay_utrans_get_env_size(p_cfg));
    total_env_size += CO_ALIGN4_HI(m_lay_access_get_env_size(p_cfg));
    bfe2:	b2b4      	uxth	r4, r6
    #endif //(BLE_MESH_FRIEND)
    #if (BLE_MESH_GATT_PROXY)
    total_env_size += CO_ALIGN4_HI(m_lay_proxy_get_env_size(p_cfg));
    #endif // (BLE_MESH_GATT_PROXY)

    return total_env_size;
    bfe4:	43a8      	bics	r0, r5
    bfe6:	1820      	adds	r0, r4, r0
    bfe8:	b280      	uxth	r0, r0
}
    bfea:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0000bfec <m_lay_init>:

uint16_t m_lay_init(bool reset, void* p_env, const m_cfg_t* p_cfg)
{
    bfec:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    bfee:	0005      	movs	r5, r0
    bff0:	000e      	movs	r6, r1
    // Stack initialization
    uint8_t* p_env_cursor = (uint8_t*) p_env;

    p_env_cursor += CO_ALIGN4_HI(m_lay_net_init(reset, (void*) p_env_cursor));
    bff2:	f002 f909 	bl	e208 <m_lay_net_init>
    bff6:	2403      	movs	r4, #3
    bff8:	1cc7      	adds	r7, r0, #3
    bffa:	43a7      	bics	r7, r4
    bffc:	19f7      	adds	r7, r6, r7
    p_env_cursor += CO_ALIGN4_HI(m_lay_ltrans_init(reset, (void*) p_env_cursor));
    bffe:	0039      	movs	r1, r7
    c000:	0028      	movs	r0, r5
    c002:	f001 f963 	bl	d2cc <m_lay_ltrans_init>
    c006:	1900      	adds	r0, r0, r4
    c008:	43a0      	bics	r0, r4
    c00a:	183f      	adds	r7, r7, r0
    p_env_cursor += CO_ALIGN4_HI(m_lay_utrans_init(reset, (void*) p_env_cursor));
    c00c:	0039      	movs	r1, r7
    c00e:	0028      	movs	r0, r5
    c010:	f002 fce6 	bl	e9e0 <m_lay_utrans_init>
    c014:	1900      	adds	r0, r0, r4
    c016:	43a0      	bics	r0, r4
    c018:	183f      	adds	r7, r7, r0
    p_env_cursor += CO_ALIGN4_HI(m_lay_access_init(reset, (void*) p_env_cursor));
    c01a:	0039      	movs	r1, r7
    c01c:	0028      	movs	r0, r5
    c01e:	f000 f9b5 	bl	c38c <m_lay_access_init>
    c022:	1900      	adds	r0, r0, r4
    c024:	43a0      	bics	r0, r4
    c026:	183f      	adds	r7, r7, r0
    p_env_cursor += CO_ALIGN4_HI(m_lay_hb_init(reset, (void*) p_env_cursor));
    c028:	0039      	movs	r1, r7
    c02a:	0028      	movs	r0, r5
    c02c:	f000 fbd6 	bl	c7dc <m_lay_hb_init>
    c030:	1900      	adds	r0, r0, r4
    c032:	43a0      	bics	r0, r4
    c034:	183c      	adds	r4, r7, r0
    p_env_cursor += CO_ALIGN4_HI(m_lay_proxy_init(reset, (void*) p_env_cursor, p_cfg));
    #endif // (BLE_MESH_GATT_PROXY)


    // Connect the mesh block together
    if(!reset)
    c036:	2d00      	cmp	r5, #0
    c038:	d128      	bne.n	c08c <m_lay_init+0xa0>
    {
        // Connect bearer layer to Advertising abstraction layer API functions
        m_bearer_adv_connect_api_al(&m_al_adv_api);
    c03a:	4816      	ldr	r0, [pc, #88]	; (c094 <m_lay_init+0xa8>)
    c03c:	f7fe fa3c 	bl	a4b8 <m_bearer_adv_connect_api_al>
        #if (BLE_MESH_GATT_BEARER)
        // Connect bearer layer to Connection abstraction layer API functions
        m_bearer_gatt_connect_api_al(&m_al_con_api);
        #endif // (BLE_MESH_GATT_BEARER)
        // Connect network layer to bearer layer API functions
        m_lay_net_connect_api_bearer(&m_bearer_api);
    c040:	4815      	ldr	r0, [pc, #84]	; (c098 <m_lay_init+0xac>)
    c042:	f002 f8f9 	bl	e238 <m_lay_net_connect_api_bearer>

        // Connect bearer layer to network layer CB functions
        m_bearer_connect_client_cb(M_BEARER_CLI_NET, &m_lay_net_cb);
    c046:	0028      	movs	r0, r5
    c048:	4914      	ldr	r1, [pc, #80]	; (c09c <m_lay_init+0xb0>)
    c04a:	f7fd fee5 	bl	9e18 <m_bearer_connect_client_cb>
        // Connect network layer to lower transport layer CB functions
        m_lay_net_connect_cb(&m_lay_ltrans_cb, M_LAY_NET_INTF_TYPE_LTRANS);
    c04e:	0029      	movs	r1, r5
    c050:	4813      	ldr	r0, [pc, #76]	; (c0a0 <m_lay_init+0xb4>)
    c052:	f002 f8f7 	bl	e244 <m_lay_net_connect_cb>

        // Connect lower transport layer to network layer API functions
        m_lay_ltrans_connect_api_net(&m_lay_net_api);
    c056:	4813      	ldr	r0, [pc, #76]	; (c0a4 <m_lay_init+0xb8>)
    c058:	f001 f995 	bl	d386 <m_lay_ltrans_connect_api_net>
        // Connect Lower Transport Layer to Upper Transport Layer callback functions
        m_lay_ltrans_connect_cb(&m_lay_utrans_cb);
    c05c:	4812      	ldr	r0, [pc, #72]	; (c0a8 <m_lay_init+0xbc>)
    c05e:	f001 f999 	bl	d394 <m_lay_ltrans_connect_cb>

        // Connect upper transport layer to lower transport layer API functions
        m_lay_utrans_connect_api_ltrans(&m_lay_ltrans_api);
    c062:	4812      	ldr	r0, [pc, #72]	; (c0ac <m_lay_init+0xc0>)
    c064:	f002 fcd4 	bl	ea10 <m_lay_utrans_connect_api_ltrans>
        // Connect upper transport layer to access layer CB functions
        m_lay_utrans_connect_cb(&m_lay_access_cb, M_LAY_UTRANS_INTF_TYPE_ACCESS);
    c068:	0029      	movs	r1, r5
    c06a:	4811      	ldr	r0, [pc, #68]	; (c0b0 <m_lay_init+0xc4>)
    c06c:	f002 fcd6 	bl	ea1c <m_lay_utrans_connect_cb>
        // Connect upper transport layer to heartbeat module CB functions
        m_lay_utrans_connect_cb(&m_lay_hb_cb, M_LAY_UTRANS_INTF_TYPE_HB);
    c070:	2101      	movs	r1, #1
    c072:	4810      	ldr	r0, [pc, #64]	; (c0b4 <m_lay_init+0xc8>)
    c074:	f002 fcd2 	bl	ea1c <m_lay_utrans_connect_cb>
        // Connect heartbeat layer to upper transport layer API functions
        m_lay_hb_connect_api_utrans(&m_lay_utrans_api);
    c078:	4d0f      	ldr	r5, [pc, #60]	; (c0b8 <m_lay_init+0xcc>)
    c07a:	0028      	movs	r0, r5
    c07c:	f000 fbca 	bl	c814 <m_lay_hb_connect_api_utrans>
        // Connect heartbeat layer to State Manager callback functions
        m_tb_state_set_hb_cb(&m_lay_hb_state_cb);
    c080:	480e      	ldr	r0, [pc, #56]	; (c0bc <m_lay_init+0xd0>)
    c082:	f008 f827 	bl	140d4 <m_tb_state_set_hb_cb>
            m_lay_proxy_bearer_connect_api(&m_bearer_api);
        }
        #endif //(BLE_MESH_GATT_PROXY)

        // Connect access layer to upper transport layer API functions
        m_lay_access_connect_api_utrans(&m_lay_utrans_api);
    c086:	0028      	movs	r0, r5
    c088:	f000 f9b2 	bl	c3f0 <m_lay_access_connect_api_utrans>
    }

    // Return size of te environment used
    return (((uint32_t) p_env_cursor) - ((uint32_t) p_env));
    c08c:	1ba0      	subs	r0, r4, r6
    c08e:	b280      	uxth	r0, r0
}
    c090:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    c092:	46c0      	nop			; (mov r8, r8)
    c094:	000206e0 	.word	0x000206e0
    c098:	000214e8 	.word	0x000214e8
    c09c:	00021c18 	.word	0x00021c18
    c0a0:	000219a0 	.word	0x000219a0
    c0a4:	00021c14 	.word	0x00021c14
    c0a8:	00021d40 	.word	0x00021d40
    c0ac:	0002199c 	.word	0x0002199c
    c0b0:	000218d0 	.word	0x000218d0
    c0b4:	00021918 	.word	0x00021918
    c0b8:	00021d3c 	.word	0x00021d3c
    c0bc:	00021920 	.word	0x00021920

0000c0c0 <m_lay_access_opcode_set>:
 *
 * @return Execution status
 ****************************************************************************************
 */
__STATIC uint16_t m_lay_access_opcode_set(m_tb_buf_t *p_buf, uint32_t opcode)
{
    c0c0:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
 */
__INLINE_S__ void co_write32p(void const *ptr32, uint32_t value)
{
    uint8_t *ptr=(uint8_t*)ptr32;

    *ptr++ = (uint8_t)(value&0xff);
    c0c2:	466b      	mov	r3, sp
    *ptr++ = (uint8_t)((value&0xff00)>>8);
    c0c4:	466a      	mov	r2, sp
 */
__INLINE_S__ void co_write32p(void const *ptr32, uint32_t value)
{
    uint8_t *ptr=(uint8_t*)ptr32;

    *ptr++ = (uint8_t)(value&0xff);
    c0c6:	7019      	strb	r1, [r3, #0]
    *ptr++ = (uint8_t)((value&0xff00)>>8);
    c0c8:	0a0b      	lsrs	r3, r1, #8
    c0ca:	7053      	strb	r3, [r2, #1]
    *ptr++ = (uint8_t)((value&0xff0000)>>16);
    c0cc:	0c0b      	lsrs	r3, r1, #16
    *ptr = (uint8_t)((value&0xff000000)>>24);
    c0ce:	0e09      	lsrs	r1, r1, #24
{
    uint8_t *ptr=(uint8_t*)ptr32;

    *ptr++ = (uint8_t)(value&0xff);
    *ptr++ = (uint8_t)((value&0xff00)>>8);
    *ptr++ = (uint8_t)((value&0xff0000)>>16);
    c0d0:	7093      	strb	r3, [r2, #2]
    *ptr = (uint8_t)((value&0xff000000)>>24);
    c0d2:	70d1      	strb	r1, [r2, #3]
    uint16_t status;

    co_write32p(tx_opcode, co_htobl(opcode));

    // Get length of operation code
    if (M_IS_1_OCT_OPCODE(tx_opcode[0]))
    c0d4:	9a00      	ldr	r2, [sp, #0]
 *
 * @return Execution status
 ****************************************************************************************
 */
__STATIC uint16_t m_lay_access_opcode_set(m_tb_buf_t *p_buf, uint32_t opcode)
{
    c0d6:	0004      	movs	r4, r0
    co_write32p(tx_opcode, co_htobl(opcode));

    // Get length of operation code
    if (M_IS_1_OCT_OPCODE(tx_opcode[0]))
    {
        opcode_size = 1;
    c0d8:	2501      	movs	r5, #1
    uint16_t status;

    co_write32p(tx_opcode, co_htobl(opcode));

    // Get length of operation code
    if (M_IS_1_OCT_OPCODE(tx_opcode[0]))
    c0da:	0613      	lsls	r3, r2, #24
    c0dc:	d506      	bpl.n	c0ec <m_lay_access_opcode_set+0x2c>
    {
        opcode_size = 1;
    }
    else if (M_IS_2_OCT_OPCODE(tx_opcode[0]))
    c0de:	23c0      	movs	r3, #192	; 0xc0
    c0e0:	4013      	ands	r3, r2
    {
        opcode_size = 2;
    }
    else
    {
        opcode_size = 3;
    c0e2:	3b80      	subs	r3, #128	; 0x80
    c0e4:	425a      	negs	r2, r3
    c0e6:	4153      	adcs	r3, r2
    c0e8:	3502      	adds	r5, #2
    c0ea:	1aed      	subs	r5, r5, r3
    }

    // Reserve length of operation code
    status = m_tb_buf_head_reserve(p_buf, opcode_size);
    c0ec:	b2a9      	uxth	r1, r5
    c0ee:	0020      	movs	r0, r4
    c0f0:	f005 fa98 	bl	11624 <m_tb_buf_head_reserve>
    c0f4:	1e06      	subs	r6, r0, #0

    if (status == M_ERR_NO_ERROR)
    c0f6:	d107      	bne.n	c108 <m_lay_access_opcode_set+0x48>
    {
        // Fill operation code
        memcpy(M_TB_BUF_DATA(p_buf), tx_opcode, opcode_size);
    c0f8:	0020      	movs	r0, r4
    c0fa:	88a3      	ldrh	r3, [r4, #4]
    c0fc:	3030      	adds	r0, #48	; 0x30
    c0fe:	18c0      	adds	r0, r0, r3
    c100:	002a      	movs	r2, r5
    c102:	4669      	mov	r1, sp
    c104:	f009 fc64 	bl	159d0 <memcpy>
    }

    return (status);
}
    c108:	0030      	movs	r0, r6
    c10a:	b004      	add	sp, #16
    c10c:	bd70      	pop	{r4, r5, r6, pc}

0000c10e <m_lay_access_retx_timer_cb>:
 *
 * @param[in] p_tx_elt      Transmission element for which timer has expired
 ****************************************************************************************
 */
__STATIC void m_lay_access_retx_timer_cb(m_lay_access_tx_elt_t *p_tx_elt)
{
    c10e:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    // Handling status
    uint16_t status;
    // Buffer to retransmit
    m_tb_buf_t *p_buf = p_tx_elt->p_buf;
    c110:	6844      	ldr	r4, [r0, #4]
 *
 * @param[in] p_tx_elt      Transmission element for which timer has expired
 ****************************************************************************************
 */
__STATIC void m_lay_access_retx_timer_cb(m_lay_access_tx_elt_t *p_tx_elt)
{
    c112:	0005      	movs	r5, r0
    do
    {
        // Get application key
        const m_tb_key_app_t *p_app_key;

        status = m_tb_key_app_get(p_buf_env->app_lid, &p_app_key, true);
    c114:	2201      	movs	r2, #1
    c116:	7ca0      	ldrb	r0, [r4, #18]
    c118:	a901      	add	r1, sp, #4
    c11a:	f006 fb3b 	bl	12794 <m_tb_key_app_get>
    c11e:	1e06      	subs	r6, r0, #0

        if (status != M_ERR_NO_ERROR)
    c120:	d115      	bne.n	c14e <m_lay_access_retx_timer_cb+0x40>
        }

        // Set network key local index
        p_buf_env->net_lid = p_app_key->net_key_lid;
        // Set IV and sequence number
        m_tb_key_get_iv_seq(&p_buf_env->seq, &p_buf_env->u5.iv);
    c122:	0021      	movs	r1, r4
    c124:	0020      	movs	r0, r4
        {
            break;
        }

        // Set network key local index
        p_buf_env->net_lid = p_app_key->net_key_lid;
    c126:	9b01      	ldr	r3, [sp, #4]
        // Set IV and sequence number
        m_tb_key_get_iv_seq(&p_buf_env->seq, &p_buf_env->u5.iv);
    c128:	3118      	adds	r1, #24
        {
            break;
        }

        // Set network key local index
        p_buf_env->net_lid = p_app_key->net_key_lid;
    c12a:	7d9b      	ldrb	r3, [r3, #22]
        // Set IV and sequence number
        m_tb_key_get_iv_seq(&p_buf_env->seq, &p_buf_env->u5.iv);
    c12c:	3014      	adds	r0, #20
        {
            break;
        }

        // Set network key local index
        p_buf_env->net_lid = p_app_key->net_key_lid;
    c12e:	7463      	strb	r3, [r4, #17]
        // Set IV and sequence number
        m_tb_key_get_iv_seq(&p_buf_env->seq, &p_buf_env->u5.iv);
    c130:	f006 fd86 	bl	12c40 <m_tb_key_get_iv_seq>

        // Push the buffer for transmission
        status = p_m_lay_access_env->p_utrans_api->send(p_buf, M_LAY_UTRANS_INTF_TYPE_ACCESS);
    c134:	4b16      	ldr	r3, [pc, #88]	; (c190 <m_lay_access_retx_timer_cb+0x82>)
    c136:	0031      	movs	r1, r6
    c138:	681b      	ldr	r3, [r3, #0]
    c13a:	0020      	movs	r0, r4
    c13c:	681b      	ldr	r3, [r3, #0]
    c13e:	681b      	ldr	r3, [r3, #0]
    c140:	4798      	blx	r3
    c142:	1e06      	subs	r6, r0, #0

        if (status != M_ERR_NO_ERROR)
    c144:	d103      	bne.n	c14e <m_lay_access_retx_timer_cb+0x40>
        {
            break;
        }

        // Decrease number of remaining transmissions
        p_tx_elt->nb_tx_remain--;
    c146:	7f2b      	ldrb	r3, [r5, #28]
    c148:	3b01      	subs	r3, #1
    c14a:	772b      	strb	r3, [r5, #28]
    c14c:	e015      	b.n	c17a <m_lay_access_retx_timer_cb+0x6c>
    if (status != M_ERR_NO_ERROR)
    {
        // Model callback functions
        const m_api_model_cb_t *p_model_cb;

        if (m_tb_mio_cb_get(p_buf_env->model_lid, &p_model_cb) == M_ERR_NO_ERROR)
    c14e:	7ce0      	ldrb	r0, [r4, #19]
    c150:	a901      	add	r1, sp, #4
    c152:	f007 f8ef 	bl	13334 <m_tb_mio_cb_get>
    c156:	1e07      	subs	r7, r0, #0
    c158:	d10e      	bne.n	c178 <m_lay_access_retx_timer_cb+0x6a>
        {
            p_model_cb->cb_sent(p_buf_env->model_lid, p_buf_env->u9.tx_hdl, (m_api_buf_t *)p_buf, status);
    c15a:	1ca3      	adds	r3, r4, #2
    c15c:	7fd9      	ldrb	r1, [r3, #31]
    c15e:	9b01      	ldr	r3, [sp, #4]
    c160:	7ce0      	ldrb	r0, [r4, #19]
    c162:	685b      	ldr	r3, [r3, #4]
    c164:	0022      	movs	r2, r4
    c166:	469c      	mov	ip, r3
    c168:	0033      	movs	r3, r6
    c16a:	4666      	mov	r6, ip
    c16c:	47b0      	blx	r6
        {
            ASSERT_INFO(0, p_buf_env->model_lid, status);
        }

        // Release buffer
        m_tb_buf_release(p_buf);
    c16e:	0020      	movs	r0, r4
    c170:	f005 fa94 	bl	1169c <m_tb_buf_release>

        // Stop retransmission of this buffer
        p_tx_elt->nb_tx_remain = 0;
    c174:	772f      	strb	r7, [r5, #28]
    c176:	e000      	b.n	c17a <m_lay_access_retx_timer_cb+0x6c>
    c178:	e7fe      	b.n	c178 <m_lay_access_retx_timer_cb+0x6a>
    }

    // Check if all retransmission have been done
    if (p_tx_elt->nb_tx_remain == 0)
    c17a:	7f2b      	ldrb	r3, [r5, #28]
    c17c:	2b00      	cmp	r3, #0
    c17e:	d106      	bne.n	c18e <m_lay_access_retx_timer_cb+0x80>
    {
        // TX element is now available
        p_tx_elt->p_buf = NULL;
    c180:	606b      	str	r3, [r5, #4]
        co_list_push_back(&p_m_lay_access_env->tx_free, &p_tx_elt->hdr);
    c182:	4b03      	ldr	r3, [pc, #12]	; (c190 <m_lay_access_retx_timer_cb+0x82>)
    c184:	0029      	movs	r1, r5
    c186:	6818      	ldr	r0, [r3, #0]
    c188:	3010      	adds	r0, #16
    c18a:	f7f8 f904 	bl	4396 <co_list_push_back>
    }
}
    c18e:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
    c190:	100126a8 	.word	0x100126a8

0000c194 <m_lay_access_sent>:
 * @param[in] p_buf             Pointer to the buffer containing the sent PDU.
 * @param[in] status            Transmission status.
 ****************************************************************************************
 */
__STATIC void m_lay_access_sent(m_tb_buf_t *p_buf, uint16_t status)
{
    c194:	b5f0      	push	{r4, r5, r6, r7, lr}
    m_lay_buf_env_t *p_buf_env = (m_lay_buf_env_t *)&p_buf->env;

    // Check if buffer need to be retransmitted
    for (i = 0; i < M_LAY_ACCESS_TX_POOL_SIZE; i++)
    {
        if (p_m_lay_access_env->tx_pool[i].p_buf == p_buf)
    c196:	4a22      	ldr	r2, [pc, #136]	; (c220 <m_lay_access_sent+0x8c>)
 * @param[in] p_buf             Pointer to the buffer containing the sent PDU.
 * @param[in] status            Transmission status.
 ****************************************************************************************
 */
__STATIC void m_lay_access_sent(m_tb_buf_t *p_buf, uint16_t status)
{
    c198:	b085      	sub	sp, #20
    m_lay_buf_env_t *p_buf_env = (m_lay_buf_env_t *)&p_buf->env;

    // Check if buffer need to be retransmitted
    for (i = 0; i < M_LAY_ACCESS_TX_POOL_SIZE; i++)
    {
        if (p_m_lay_access_env->tx_pool[i].p_buf == p_buf)
    c19a:	6813      	ldr	r3, [r2, #0]
    c19c:	9201      	str	r2, [sp, #4]
    c19e:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 * @param[in] p_buf             Pointer to the buffer containing the sent PDU.
 * @param[in] status            Transmission status.
 ****************************************************************************************
 */
__STATIC void m_lay_access_sent(m_tb_buf_t *p_buf, uint16_t status)
{
    c1a0:	0005      	movs	r5, r0
    c1a2:	000e      	movs	r6, r1
    m_lay_buf_env_t *p_buf_env = (m_lay_buf_env_t *)&p_buf->env;

    // Check if buffer need to be retransmitted
    for (i = 0; i < M_LAY_ACCESS_TX_POOL_SIZE; i++)
    {
        if (p_m_lay_access_env->tx_pool[i].p_buf == p_buf)
    c1a4:	4282      	cmp	r2, r0
    c1a6:	d008      	beq.n	c1ba <m_lay_access_sent+0x26>
    c1a8:	6c5a      	ldr	r2, [r3, #68]	; 0x44
    c1aa:	4290      	cmp	r0, r2
    c1ac:	d007      	beq.n	c1be <m_lay_access_sent+0x2a>
    c1ae:	6e5a      	ldr	r2, [r3, #100]	; 0x64
__STATIC void m_lay_access_sent(m_tb_buf_t *p_buf, uint16_t status)
{
    // Counter
    uint8_t i;
    // Transmission element
    m_lay_access_tx_elt_t *p_tx_elt = NULL;
    c1b0:	2400      	movs	r4, #0
    m_lay_buf_env_t *p_buf_env = (m_lay_buf_env_t *)&p_buf->env;

    // Check if buffer need to be retransmitted
    for (i = 0; i < M_LAY_ACCESS_TX_POOL_SIZE; i++)
    {
        if (p_m_lay_access_env->tx_pool[i].p_buf == p_buf)
    c1b2:	4290      	cmp	r0, r2
    c1b4:	d109      	bne.n	c1ca <m_lay_access_sent+0x36>
    c1b6:	3402      	adds	r4, #2
    c1b8:	e002      	b.n	c1c0 <m_lay_access_sent+0x2c>
    c1ba:	2400      	movs	r4, #0
    c1bc:	e000      	b.n	c1c0 <m_lay_access_sent+0x2c>
    c1be:	2401      	movs	r4, #1
        {
            p_tx_elt = &p_m_lay_access_env->tx_pool[i];
    c1c0:	3401      	adds	r4, #1
    c1c2:	0164      	lsls	r4, r4, #5
    c1c4:	191c      	adds	r4, r3, r4
            break;
        }
    }

    if ((p_tx_elt == NULL) || (status != M_ERR_NO_ERROR))
    c1c6:	2e00      	cmp	r6, #0
    c1c8:	d021      	beq.n	c20e <m_lay_access_sent+0x7a>
    {
        // Model callback functions
        const m_api_model_cb_t* p_model_cb;

        if (m_tb_mio_cb_get(p_buf_env->model_lid, &p_model_cb) == M_ERR_NO_ERROR)
    c1ca:	7ce8      	ldrb	r0, [r5, #19]
    c1cc:	a903      	add	r1, sp, #12
    c1ce:	f007 f8b1 	bl	13334 <m_tb_mio_cb_get>
    c1d2:	2800      	cmp	r0, #0
    c1d4:	d10a      	bne.n	c1ec <m_lay_access_sent+0x58>
        {
            if (p_model_cb->cb_sent != NULL)
    c1d6:	9b03      	ldr	r3, [sp, #12]
    c1d8:	685f      	ldr	r7, [r3, #4]
    c1da:	2f00      	cmp	r7, #0
    c1dc:	d007      	beq.n	c1ee <m_lay_access_sent+0x5a>
            {
                // Inform the model that message has been sent
                p_model_cb->cb_sent(p_buf_env->model_lid, p_buf_env->u9.tx_hdl,
    c1de:	1cab      	adds	r3, r5, #2
    c1e0:	7fd9      	ldrb	r1, [r3, #31]
    c1e2:	7ce8      	ldrb	r0, [r5, #19]
    c1e4:	0033      	movs	r3, r6
    c1e6:	002a      	movs	r2, r5
    c1e8:	47b8      	blx	r7
    c1ea:	e000      	b.n	c1ee <m_lay_access_sent+0x5a>
    c1ec:	e7fe      	b.n	c1ec <m_lay_access_sent+0x58>
        {
            ASSERT_INFO(0, p_buf_env->model_lid, status);
        }

        // Release buffer
        m_tb_buf_release(p_buf);
    c1ee:	0028      	movs	r0, r5
    c1f0:	f005 fa54 	bl	1169c <m_tb_buf_release>
    }

    if (p_tx_elt != NULL)
    c1f4:	2c00      	cmp	r4, #0
    c1f6:	d011      	beq.n	c21c <m_lay_access_sent+0x88>
    {
        if (status != M_ERR_NO_ERROR)
    c1f8:	2e00      	cmp	r6, #0
    c1fa:	d008      	beq.n	c20e <m_lay_access_sent+0x7a>
        {
            // TX element is now available
            p_tx_elt->p_buf = NULL;
    c1fc:	2300      	movs	r3, #0
    c1fe:	6063      	str	r3, [r4, #4]
            co_list_push_back(&p_m_lay_access_env->tx_free, &p_tx_elt->hdr);
    c200:	9b01      	ldr	r3, [sp, #4]
    c202:	0021      	movs	r1, r4
    c204:	6818      	ldr	r0, [r3, #0]
    c206:	3010      	adds	r0, #16
    c208:	f7f8 f8c5 	bl	4396 <co_list_push_back>
    c20c:	e006      	b.n	c21c <m_lay_access_sent+0x88>
        }
        else
        {
            // Set the retransmission timer
            m_tb_timer_set(&p_tx_elt->timer_retx, 50 * p_tx_elt->retx_delay);
    c20e:	2332      	movs	r3, #50	; 0x32
    c210:	0020      	movs	r0, r4
    c212:	7f61      	ldrb	r1, [r4, #29]
    c214:	3008      	adds	r0, #8
    c216:	4359      	muls	r1, r3
    c218:	f009 f874 	bl	15304 <m_tb_timer_set>
        }
    }
}
    c21c:	b005      	add	sp, #20
    c21e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    c220:	100126a8 	.word	0x100126a8

0000c224 <m_lay_access_model_check>:
 *
 * @param[in] p_env             Not used
 ****************************************************************************************
 */
__STATIC void m_lay_access_model_check(void *p_env)
{
    c224:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	M_PRINTF(L_ACCESS, "");
    c226:	4b2d      	ldr	r3, [pc, #180]	; (c2dc <m_lay_access_model_check+0xb8>)
    c228:	681b      	ldr	r3, [r3, #0]
    c22a:	055b      	lsls	r3, r3, #21
    c22c:	d515      	bpl.n	c25a <m_lay_access_model_check+0x36>
    c22e:	4c2c      	ldr	r4, [pc, #176]	; (c2e0 <m_lay_access_model_check+0xbc>)
    c230:	0023      	movs	r3, r4
    c232:	333f      	adds	r3, #63	; 0x3f
    c234:	9300      	str	r3, [sp, #0]
    c236:	0022      	movs	r2, r4
    c238:	0020      	movs	r0, r4
    c23a:	234a      	movs	r3, #74	; 0x4a
    c23c:	0021      	movs	r1, r4
    c23e:	3221      	adds	r2, #33	; 0x21
    c240:	33ff      	adds	r3, #255	; 0xff
    c242:	3030      	adds	r0, #48	; 0x30
    c244:	f7f8 fbb2 	bl	49ac <m_print>
    c248:	0020      	movs	r0, r4
    c24a:	3058      	adds	r0, #88	; 0x58
    c24c:	f7f8 fbae 	bl	49ac <m_print>
    c250:	0020      	movs	r0, r4
    c252:	1da1      	adds	r1, r4, #6
    c254:	3059      	adds	r0, #89	; 0x59
    c256:	f7f8 fba9 	bl	49ac <m_print>
    // Get buffer to handle
    m_tb_buf_t *p_buf = (m_tb_buf_t *)co_list_pick(&p_m_lay_access_env->rx_queue);
    c25a:	4d22      	ldr	r5, [pc, #136]	; (c2e4 <m_lay_access_model_check+0xc0>)
    c25c:	682b      	ldr	r3, [r5, #0]
    c25e:	699c      	ldr	r4, [r3, #24]

    if (p_buf)
    c260:	2c00      	cmp	r4, #0
    c262:	d03a      	beq.n	c2da <m_lay_access_model_check+0xb6>
    {
        // Get buffer environment
        m_lay_buf_env_t *p_buf_env = (m_lay_buf_env_t *) p_buf->env;

        // Check if model can be interested by the message
        for ( ; p_buf_env->model_lid < m_tb_mio_get_nb_model(); p_buf_env->model_lid++)
    c264:	7ce6      	ldrb	r6, [r4, #19]
    c266:	f006 ffdd 	bl	13224 <m_tb_mio_get_nb_model>
    c26a:	4286      	cmp	r6, r0
    c26c:	d222      	bcs.n	c2b4 <m_lay_access_model_check+0x90>
        {
            // Check that model is bound with the application key used to decrypt the message and that
            // destination address is used by this model
            if ((m_tb_key_model_bind_check(p_buf_env->app_lid,
    c26e:	7ce1      	ldrb	r1, [r4, #19]
    c270:	7ca0      	ldrb	r0, [r4, #18]
    c272:	f006 fcb9 	bl	12be8 <m_tb_key_model_bind_check>
    c276:	2800      	cmp	r0, #0
    c278:	d118      	bne.n	c2ac <m_lay_access_model_check+0x88>
                                           p_buf_env->model_lid) == M_ERR_NO_ERROR)
                    && (m_tb_mio_is_dest_addr(p_buf_env->model_lid, p_buf_env->dst, p_buf_env->va_lid)))
    c27a:	1ce3      	adds	r3, r4, #3
    c27c:	7fda      	ldrb	r2, [r3, #31]
    c27e:	8be1      	ldrh	r1, [r4, #30]
    c280:	7ce0      	ldrb	r0, [r4, #19]
    c282:	f007 fad9 	bl	13838 <m_tb_mio_is_dest_addr>
    c286:	2800      	cmp	r0, #0
    c288:	d010      	beq.n	c2ac <m_lay_access_model_check+0x88>
            {
                // Get model callback functions
                const m_api_model_cb_t *p_model_cb;

                if (m_tb_mio_cb_get(p_buf_env->model_lid, &p_model_cb) == M_ERR_NO_ERROR)
    c28a:	7ce0      	ldrb	r0, [r4, #19]
    c28c:	a903      	add	r1, sp, #12
    c28e:	f007 f851 	bl	13334 <m_tb_mio_cb_get>
    c292:	2800      	cmp	r0, #0
    c294:	d10a      	bne.n	c2ac <m_lay_access_model_check+0x88>
                {
                    // Check that model support the received operation code
                    if ((p_model_cb->cb_opcode_check != NULL) && (p_model_cb->cb_rx != NULL))
    c296:	9a03      	ldr	r2, [sp, #12]
    c298:	6893      	ldr	r3, [r2, #8]
    c29a:	2b00      	cmp	r3, #0
    c29c:	d006      	beq.n	c2ac <m_lay_access_model_check+0x88>
    c29e:	6812      	ldr	r2, [r2, #0]
    c2a0:	2a00      	cmp	r2, #0
    c2a2:	d003      	beq.n	c2ac <m_lay_access_model_check+0x88>
                    {
                        p_model_cb->cb_opcode_check(p_buf_env->model_lid, p_buf_env->u5.opcode);
    c2a4:	7ce0      	ldrb	r0, [r4, #19]
    c2a6:	69a1      	ldr	r1, [r4, #24]
    c2a8:	4798      	blx	r3
    c2aa:	e003      	b.n	c2b4 <m_lay_access_model_check+0x90>
    {
        // Get buffer environment
        m_lay_buf_env_t *p_buf_env = (m_lay_buf_env_t *) p_buf->env;

        // Check if model can be interested by the message
        for ( ; p_buf_env->model_lid < m_tb_mio_get_nb_model(); p_buf_env->model_lid++)
    c2ac:	7ce3      	ldrb	r3, [r4, #19]
    c2ae:	3301      	adds	r3, #1
    c2b0:	74e3      	strb	r3, [r4, #19]
    c2b2:	e7d7      	b.n	c264 <m_lay_access_model_check+0x40>
                }
            }
        }

        // Check if all models have been parsed
        if (p_buf_env->model_lid == m_tb_mio_get_nb_model())
    c2b4:	7ce6      	ldrb	r6, [r4, #19]
    c2b6:	f006 ffb5 	bl	13224 <m_tb_mio_get_nb_model>
    c2ba:	4286      	cmp	r6, r0
    c2bc:	d10d      	bne.n	c2da <m_lay_access_model_check+0xb6>
        {
            // Remove buffer from the reception queue
            co_list_pop_front(&p_m_lay_access_env->rx_queue);
    c2be:	6828      	ldr	r0, [r5, #0]
    c2c0:	3018      	adds	r0, #24
    c2c2:	f7f8 f893 	bl	43ec <co_list_pop_front>

            // Release buffer
            m_tb_buf_release(p_buf);
    c2c6:	0020      	movs	r0, r4
    c2c8:	f005 f9e8 	bl	1169c <m_tb_buf_release>

            // Check if another message must be handled
            if (!co_list_is_empty(&p_m_lay_access_env->rx_queue))
    c2cc:	6828      	ldr	r0, [r5, #0]
    c2ce:	6983      	ldr	r3, [r0, #24]
    c2d0:	2b00      	cmp	r3, #0
    c2d2:	d002      	beq.n	c2da <m_lay_access_model_check+0xb6>
            {
                m_al_djob_reg(&p_m_lay_access_env->rx_djob);
    c2d4:	3004      	adds	r0, #4
    c2d6:	f7f8 fcd9 	bl	4c8c <m_al_djob_reg>
            }
        }
    }
}
    c2da:	bd7f      	pop	{r0, r1, r2, r3, r4, r5, r6, pc}
    c2dc:	10010514 	.word	0x10010514
    c2e0:	00021860 	.word	0x00021860
    c2e4:	100126a8 	.word	0x100126a8

0000c2e8 <m_lay_access_rx>:
 *
 * @param[in] p_buf             Pointer to the buffer containing the received PDU.
 ****************************************************************************************
 */
__STATIC void m_lay_access_rx(m_tb_buf_t *p_buf)
{
    c2e8:	b530      	push	{r4, r5, lr}
	m_printf_hex(L_ACCESS, "recv access data", M_TB_BUF_DATA(p_buf), p_buf->data_len);
    c2ea:	0005      	movs	r5, r0
    c2ec:	8903      	ldrh	r3, [r0, #8]
    c2ee:	8882      	ldrh	r2, [r0, #4]
 *
 * @param[in] p_buf             Pointer to the buffer containing the received PDU.
 ****************************************************************************************
 */
__STATIC void m_lay_access_rx(m_tb_buf_t *p_buf)
{
    c2f0:	0004      	movs	r4, r0
	m_printf_hex(L_ACCESS, "recv access data", M_TB_BUF_DATA(p_buf), p_buf->data_len);
    c2f2:	2080      	movs	r0, #128	; 0x80
    c2f4:	4923      	ldr	r1, [pc, #140]	; (c384 <m_lay_access_rx+0x9c>)
    c2f6:	3530      	adds	r5, #48	; 0x30
 *
 * @param[in] p_buf             Pointer to the buffer containing the received PDU.
 ****************************************************************************************
 */
__STATIC void m_lay_access_rx(m_tb_buf_t *p_buf)
{
    c2f8:	b085      	sub	sp, #20
	m_printf_hex(L_ACCESS, "recv access data", M_TB_BUF_DATA(p_buf), p_buf->data_len);
    c2fa:	18aa      	adds	r2, r5, r2
    c2fc:	315c      	adds	r1, #92	; 0x5c
    c2fe:	00c0      	lsls	r0, r0, #3
    c300:	f7f8 fbb4 	bl	4a6c <m_printf_hex>
 ****************************************************************************************
 */
__STATIC uint16_t m_lay_access_opcode_get(m_tb_buf_t *p_buf, uint32_t *p_opcode)
{
    // Read opcode
    uint32_t rx_opcode[4] = {0, 0, 0, 0};
    c304:	2210      	movs	r2, #16
    c306:	2100      	movs	r1, #0
    c308:	4668      	mov	r0, sp
    c30a:	f009 fb9f 	bl	15a4c <memset>
    uint8_t opcode_size;
    // Pointer to received data
    uint8_t *p_data = M_TB_BUF_DATA(p_buf);
    c30e:	88a1      	ldrh	r1, [r4, #4]
    c310:	1869      	adds	r1, r5, r1
    // Returned status
    uint16_t status;

    // Get length of operation code
    if (M_IS_1_OCT_OPCODE(p_data[0]))
    c312:	780b      	ldrb	r3, [r1, #0]
    {
        opcode_size = 1;
    c314:	2501      	movs	r5, #1
    uint8_t *p_data = M_TB_BUF_DATA(p_buf);
    // Returned status
    uint16_t status;

    // Get length of operation code
    if (M_IS_1_OCT_OPCODE(p_data[0]))
    c316:	b25a      	sxtb	r2, r3
    c318:	2a00      	cmp	r2, #0
    c31a:	da07      	bge.n	c32c <m_lay_access_rx+0x44>
    {
        opcode_size = 1;
    }
    else if (M_IS_2_OCT_OPCODE(p_data[0]))
    c31c:	223f      	movs	r2, #63	; 0x3f
    c31e:	4393      	bics	r3, r2
    {
        opcode_size = 2;
    }
    else
    {
        opcode_size = 3;
    c320:	3b80      	subs	r3, #128	; 0x80
    c322:	001a      	movs	r2, r3
    c324:	4250      	negs	r0, r2
    c326:	4150      	adcs	r0, r2
    c328:	3502      	adds	r5, #2
    c32a:	1a2d      	subs	r5, r5, r0
    }

    // Extract operation code
    memcpy(rx_opcode, p_data, opcode_size);
    c32c:	002a      	movs	r2, r5
    c32e:	4668      	mov	r0, sp
    c330:	f009 fb4e 	bl	159d0 <memcpy>

    // Put operation code into a 32 bits format
    *p_opcode = co_btohl(co_read32p(rx_opcode));
    c334:	466b      	mov	r3, sp
    c336:	466a      	mov	r2, sp
    c338:	78db      	ldrb	r3, [r3, #3]
    c33a:	7891      	ldrb	r1, [r2, #2]
    c33c:	021b      	lsls	r3, r3, #8
    c33e:	430b      	orrs	r3, r1
    c340:	0419      	lsls	r1, r3, #16
    c342:	466b      	mov	r3, sp
    c344:	7852      	ldrb	r2, [r2, #1]
    c346:	781b      	ldrb	r3, [r3, #0]
    c348:	0212      	lsls	r2, r2, #8
    c34a:	4313      	orrs	r3, r2
    c34c:	430b      	orrs	r3, r1
    c34e:	61a3      	str	r3, [r4, #24]

    // Release opcode part
    status = m_tb_buf_head_release(p_buf, opcode_size);
    c350:	b2a9      	uxth	r1, r5
    c352:	0020      	movs	r0, r4
    c354:	f005 f974 	bl	11640 <m_tb_buf_head_release>
{
	m_printf_hex(L_ACCESS, "recv access data", M_TB_BUF_DATA(p_buf), p_buf->data_len);
    // Retrieve environment
    m_lay_buf_env_t *p_buf_env = (m_lay_buf_env_t *)p_buf->env;

    if (m_lay_access_opcode_get(p_buf, &p_buf_env->u5.opcode) == M_ERR_NO_ERROR)
    c358:	2800      	cmp	r0, #0
    c35a:	d110      	bne.n	c37e <m_lay_access_rx+0x96>
    {
        // Initialize model local identifier
        p_buf_env->model_lid = 0;

        // Put buffer in the reception queue for a later processing
        co_list_push_back(&p_m_lay_access_env->rx_queue, &p_buf->hdr);
    c35c:	4d0a      	ldr	r5, [pc, #40]	; (c388 <m_lay_access_rx+0xa0>)
    m_lay_buf_env_t *p_buf_env = (m_lay_buf_env_t *)p_buf->env;

    if (m_lay_access_opcode_get(p_buf, &p_buf_env->u5.opcode) == M_ERR_NO_ERROR)
    {
        // Initialize model local identifier
        p_buf_env->model_lid = 0;
    c35e:	74e0      	strb	r0, [r4, #19]

        // Put buffer in the reception queue for a later processing
        co_list_push_back(&p_m_lay_access_env->rx_queue, &p_buf->hdr);
    c360:	6828      	ldr	r0, [r5, #0]
    c362:	0021      	movs	r1, r4
    c364:	3018      	adds	r0, #24
    c366:	f7f8 f816 	bl	4396 <co_list_push_back>

        // Acquire buffer
        m_tb_buf_acquire(p_buf);
    c36a:	0020      	movs	r0, r4
    c36c:	f005 f992 	bl	11694 <m_tb_buf_acquire>

        // Check if message can be checked by model immediately
        if ((m_tb_buf_t *)co_list_pick(&p_m_lay_access_env->rx_queue) == p_buf)
    c370:	6828      	ldr	r0, [r5, #0]
    c372:	6983      	ldr	r3, [r0, #24]
    c374:	429c      	cmp	r4, r3
    c376:	d102      	bne.n	c37e <m_lay_access_rx+0x96>
        {
            m_al_djob_reg(&p_m_lay_access_env->rx_djob);
    c378:	3004      	adds	r0, #4
    c37a:	f7f8 fc87 	bl	4c8c <m_al_djob_reg>
        }
    }
}
    c37e:	b005      	add	sp, #20
    c380:	bd30      	pop	{r4, r5, pc}
    c382:	46c0      	nop			; (mov r8, r8)
    c384:	00021860 	.word	0x00021860
    c388:	100126a8 	.word	0x100126a8

0000c38c <m_lay_access_init>:
 * FUNCTIONS
 ****************************************************************************************
 */

uint16_t m_lay_access_init(bool reset, void *p_env)
{
    c38c:	b570      	push	{r4, r5, r6, lr}
    c38e:	1e04      	subs	r4, r0, #0
    c390:	4d13      	ldr	r5, [pc, #76]	; (c3e0 <m_lay_access_init+0x54>)
    if (!reset)
    c392:	d120      	bne.n	c3d6 <m_lay_access_init+0x4a>
    {
        // Counter
        uint8_t i;

        // Keep address of environment for Access Layer
        p_m_lay_access_env = (m_lay_access_env_t *)p_env;
    c394:	6029      	str	r1, [r5, #0]

        // Initialize pool of TX elements
        co_list_init(&p_m_lay_access_env->tx_free);
    c396:	3110      	adds	r1, #16
    c398:	0008      	movs	r0, r1
    c39a:	f7f7 ffc1 	bl	4320 <co_list_init>
    c39e:	0020      	movs	r0, r4
        // Initialize TX elements
        for (i = 0 ; i < M_LAY_ACCESS_TX_POOL_SIZE ; i++)
        {
            m_lay_access_tx_elt_t *p_tx_elt = &p_m_lay_access_env->tx_pool[i];

            p_tx_elt->p_buf = NULL;
    c3a0:	2400      	movs	r4, #0
        co_list_init(&p_m_lay_access_env->tx_free);

        // Initialize TX elements
        for (i = 0 ; i < M_LAY_ACCESS_TX_POOL_SIZE ; i++)
        {
            m_lay_access_tx_elt_t *p_tx_elt = &p_m_lay_access_env->tx_pool[i];
    c3a2:	682b      	ldr	r3, [r5, #0]
    c3a4:	1c46      	adds	r6, r0, #1

            p_tx_elt->p_buf = NULL;
            p_tx_elt->timer_retx.p_env = (void *)p_tx_elt;
            p_tx_elt->timer_retx.cb = (m_tb_timer_cb_t)m_lay_access_retx_timer_cb;
    c3a6:	4a0f      	ldr	r2, [pc, #60]	; (c3e4 <m_lay_access_init+0x58>)
        co_list_init(&p_m_lay_access_env->tx_free);

        // Initialize TX elements
        for (i = 0 ; i < M_LAY_ACCESS_TX_POOL_SIZE ; i++)
        {
            m_lay_access_tx_elt_t *p_tx_elt = &p_m_lay_access_env->tx_pool[i];
    c3a8:	0171      	lsls	r1, r6, #5

            p_tx_elt->p_buf = NULL;
            p_tx_elt->timer_retx.p_env = (void *)p_tx_elt;
    c3aa:	0140      	lsls	r0, r0, #5
        co_list_init(&p_m_lay_access_env->tx_free);

        // Initialize TX elements
        for (i = 0 ; i < M_LAY_ACCESS_TX_POOL_SIZE ; i++)
        {
            m_lay_access_tx_elt_t *p_tx_elt = &p_m_lay_access_env->tx_pool[i];
    c3ac:	1859      	adds	r1, r3, r1

            p_tx_elt->p_buf = NULL;
            p_tx_elt->timer_retx.p_env = (void *)p_tx_elt;
    c3ae:	1818      	adds	r0, r3, r0
            p_tx_elt->timer_retx.cb = (m_tb_timer_cb_t)m_lay_access_retx_timer_cb;

            co_list_push_back(&p_m_lay_access_env->tx_free, &(p_tx_elt->hdr));
    c3b0:	3310      	adds	r3, #16
        // Initialize TX elements
        for (i = 0 ; i < M_LAY_ACCESS_TX_POOL_SIZE ; i++)
        {
            m_lay_access_tx_elt_t *p_tx_elt = &p_m_lay_access_env->tx_pool[i];

            p_tx_elt->p_buf = NULL;
    c3b2:	604c      	str	r4, [r1, #4]
            p_tx_elt->timer_retx.p_env = (void *)p_tx_elt;
    c3b4:	6301      	str	r1, [r0, #48]	; 0x30
            p_tx_elt->timer_retx.cb = (m_tb_timer_cb_t)m_lay_access_retx_timer_cb;
    c3b6:	62c2      	str	r2, [r0, #44]	; 0x2c

            co_list_push_back(&p_m_lay_access_env->tx_free, &(p_tx_elt->hdr));
    c3b8:	0018      	movs	r0, r3
    c3ba:	f7f7 ffec 	bl	4396 <co_list_push_back>
    c3be:	0030      	movs	r0, r6

        // Initialize pool of TX elements
        co_list_init(&p_m_lay_access_env->tx_free);

        // Initialize TX elements
        for (i = 0 ; i < M_LAY_ACCESS_TX_POOL_SIZE ; i++)
    c3c0:	2e03      	cmp	r6, #3
    c3c2:	d1ed      	bne.n	c3a0 <m_lay_access_init+0x14>

            co_list_push_back(&p_m_lay_access_env->tx_free, &(p_tx_elt->hdr));
        }

        // Initialize RX queue
        co_list_init(&p_m_lay_access_env->rx_queue);
    c3c4:	6828      	ldr	r0, [r5, #0]
    c3c6:	3018      	adds	r0, #24
    c3c8:	f7f7 ffaa 	bl	4320 <co_list_init>

        // Initialize delayed job
        p_m_lay_access_env->rx_djob.cb = m_lay_access_model_check;
    c3cc:	682b      	ldr	r3, [r5, #0]
    c3ce:	4a06      	ldr	r2, [pc, #24]	; (c3e8 <m_lay_access_init+0x5c>)
        p_m_lay_access_env->rx_djob.p_env = NULL;
    c3d0:	609c      	str	r4, [r3, #8]

        // Initialize RX queue
        co_list_init(&p_m_lay_access_env->rx_queue);

        // Initialize delayed job
        p_m_lay_access_env->rx_djob.cb = m_lay_access_model_check;
    c3d2:	60da      	str	r2, [r3, #12]
    c3d4:	e001      	b.n	c3da <m_lay_access_init+0x4e>
        p_m_lay_access_env->rx_djob.p_env = NULL;
    }
    else
    {
        p_m_lay_access_env = NULL;
    c3d6:	2300      	movs	r3, #0
    c3d8:	602b      	str	r3, [r5, #0]
    }

    return (sizeof(m_lay_access_env_t));
}
    c3da:	2080      	movs	r0, #128	; 0x80
    c3dc:	bd70      	pop	{r4, r5, r6, pc}
    c3de:	46c0      	nop			; (mov r8, r8)
    c3e0:	100126a8 	.word	0x100126a8
    c3e4:	0000c10f 	.word	0x0000c10f
    c3e8:	0000c225 	.word	0x0000c225

0000c3ec <m_lay_access_get_env_size>:

uint16_t m_lay_access_get_env_size(const m_cfg_t* p_cfg)
{
    return (sizeof(m_lay_access_env_t));
}
    c3ec:	2080      	movs	r0, #128	; 0x80
    c3ee:	4770      	bx	lr

0000c3f0 <m_lay_access_connect_api_utrans>:

void m_lay_access_connect_api_utrans(const m_lay_utrans_api_t *p_api)
{
    p_m_lay_access_env->p_utrans_api = p_api;
    c3f0:	4b01      	ldr	r3, [pc, #4]	; (c3f8 <m_lay_access_connect_api_utrans+0x8>)
    c3f2:	681b      	ldr	r3, [r3, #0]
    c3f4:	6018      	str	r0, [r3, #0]
}
    c3f6:	4770      	bx	lr
    c3f8:	100126a8 	.word	0x100126a8

0000c3fc <m_lay_access_publish>:

uint16_t m_lay_access_publish(m_lid_t model_lid, uint32_t opcode, uint8_t tx_hdl,
                              m_tb_buf_t *p_buf, bool trans_mic_64)
{
    c3fc:	b5f0      	push	{r4, r5, r6, r7, lr}
    c3fe:	b089      	sub	sp, #36	; 0x24
    c400:	001c      	movs	r4, r3
    c402:	ab0e      	add	r3, sp, #56	; 0x38
    c404:	0006      	movs	r6, r0
    c406:	9105      	str	r1, [sp, #20]
    c408:	781b      	ldrb	r3, [r3, #0]
        uint8_t retx_param;
        uint8_t friend_cred;
        uint8_t ttl;

        // Sanity check
        if (p_buf == NULL)
    c40a:	2c00      	cmp	r4, #0
    c40c:	d065      	beq.n	c4da <m_lay_access_publish+0xde>

        // Prepare buffer environment
        p_buf_env = (m_lay_buf_env_t *)p_buf->env;

        p_buf_env->model_lid = model_lid;
        p_buf_env->u9.tx_hdl = tx_hdl;
    c40e:	1ca1      	adds	r1, r4, #2
        p_buf_env->flags = 0;
        SETB(p_buf_env->flags, M_LAY_BUF_SIZE_MIC, trans_mic_64);
    c410:	005b      	lsls	r3, r3, #1
        }

        // Prepare buffer environment
        p_buf_env = (m_lay_buf_env_t *)p_buf->env;

        p_buf_env->model_lid = model_lid;
    c412:	74e0      	strb	r0, [r4, #19]
        p_buf_env->u9.tx_hdl = tx_hdl;
        p_buf_env->flags = 0;
        SETB(p_buf_env->flags, M_LAY_BUF_SIZE_MIC, trans_mic_64);

        // Retrieve address of element the model belongs to and use it as source address
        status = m_tb_mio_get_element_addr(model_lid, &p_buf_env->src);
    c414:	311a      	adds	r1, #26

        // Prepare buffer environment
        p_buf_env = (m_lay_buf_env_t *)p_buf->env;

        p_buf_env->model_lid = model_lid;
        p_buf_env->u9.tx_hdl = tx_hdl;
    c416:	714a      	strb	r2, [r1, #5]
        p_buf_env->flags = 0;
        SETB(p_buf_env->flags, M_LAY_BUF_SIZE_MIC, trans_mic_64);
    c418:	7423      	strb	r3, [r4, #16]

        // Retrieve address of element the model belongs to and use it as source address
        status = m_tb_mio_get_element_addr(model_lid, &p_buf_env->src);
    c41a:	f006 ff73 	bl	13304 <m_tb_mio_get_element_addr>
    c41e:	1e05      	subs	r5, r0, #0

        if (status != M_ERR_NO_ERROR)
    c420:	d15d      	bne.n	c4de <m_lay_access_publish+0xe2>
        {
            break;
        }

        // Get publication parameters for the model
        status = m_tb_mio_get_publi_param(model_lid, &p_buf_env->dst, &p_buf_env->va_lid,
    c422:	2312      	movs	r3, #18
    c424:	aa02      	add	r2, sp, #8
    c426:	189b      	adds	r3, r3, r2
    c428:	9303      	str	r3, [sp, #12]
    c42a:	2311      	movs	r3, #17
    c42c:	2713      	movs	r7, #19
    c42e:	189b      	adds	r3, r3, r2
    c430:	9302      	str	r3, [sp, #8]
    c432:	ab06      	add	r3, sp, #24
    c434:	9301      	str	r3, [sp, #4]
    c436:	18bf      	adds	r7, r7, r2
    c438:	0023      	movs	r3, r4
    c43a:	0022      	movs	r2, r4
    c43c:	0021      	movs	r1, r4
    c43e:	3312      	adds	r3, #18
    c440:	3222      	adds	r2, #34	; 0x22
    c442:	9700      	str	r7, [sp, #0]
    c444:	311e      	adds	r1, #30
    c446:	0030      	movs	r0, r6
    c448:	f007 f806 	bl	13458 <m_tb_mio_get_publi_param>
            p_buf_env->friend_lid = 0;
        }
        else
        #endif //(BLE_MESH_LPN)
        {
            p_buf_env->friend_lid = M_INVALID_LID;
    c44c:	22ff      	movs	r2, #255	; 0xff
    c44e:	1d23      	adds	r3, r4, #4
        {
            break;
        }

        // Get publication parameters for the model
        status = m_tb_mio_get_publi_param(model_lid, &p_buf_env->dst, &p_buf_env->va_lid,
    c450:	1e05      	subs	r5, r0, #0
            p_buf_env->friend_lid = 0;
        }
        else
        #endif //(BLE_MESH_LPN)
        {
            p_buf_env->friend_lid = M_INVALID_LID;
    c452:	77da      	strb	r2, [r3, #31]
        }

        if (status != M_ERR_NO_ERROR)
    c454:	d143      	bne.n	c4de <m_lay_access_publish+0xe2>
        {
            break;
        }

        // Set TTL value
        p_buf_env->ttl_ctl = (ttl == 0xFF) ? M_TTL_DEFAULT : ttl;
    c456:	783b      	ldrb	r3, [r7, #0]
    c458:	4293      	cmp	r3, r2
    c45a:	d100      	bne.n	c45e <m_lay_access_publish+0x62>
    c45c:	230b      	movs	r3, #11
    c45e:	1c62      	adds	r2, r4, #1
    c460:	77d3      	strb	r3, [r2, #31]

        // Check that model is well bound with application key
        status = m_tb_key_model_bind_check(p_buf_env->app_lid, model_lid);
    c462:	7ca0      	ldrb	r0, [r4, #18]
    c464:	0031      	movs	r1, r6
    c466:	f006 fbbf 	bl	12be8 <m_tb_key_model_bind_check>
    c46a:	1e05      	subs	r5, r0, #0

        if (status != M_ERR_NO_ERROR)
    c46c:	d137      	bne.n	c4de <m_lay_access_publish+0xe2>
        {
            break;
        }

        // Get application key to be use for transmission
        status = m_tb_key_app_get(p_buf_env->app_lid, &p_app_key, true);
    c46e:	7ca0      	ldrb	r0, [r4, #18]
    c470:	2201      	movs	r2, #1
    c472:	a907      	add	r1, sp, #28
    c474:	f006 f98e 	bl	12794 <m_tb_key_app_get>
    c478:	1e05      	subs	r5, r0, #0

        if (status != M_ERR_NO_ERROR)
    c47a:	d130      	bne.n	c4de <m_lay_access_publish+0xe2>
        }

        // Get local index of network key to use
        p_buf_env->net_lid = p_app_key->net_key_lid;
        // Retrieve IV and sequence number
        m_tb_key_get_iv_seq(&p_buf_env->seq, &p_buf_env->u5.iv);
    c47c:	0021      	movs	r1, r4
    c47e:	0020      	movs	r0, r4
        {
            break;
        }

        // Get local index of network key to use
        p_buf_env->net_lid = p_app_key->net_key_lid;
    c480:	9b07      	ldr	r3, [sp, #28]
        // Retrieve IV and sequence number
        m_tb_key_get_iv_seq(&p_buf_env->seq, &p_buf_env->u5.iv);
    c482:	3118      	adds	r1, #24
        {
            break;
        }

        // Get local index of network key to use
        p_buf_env->net_lid = p_app_key->net_key_lid;
    c484:	7d9b      	ldrb	r3, [r3, #22]
        // Retrieve IV and sequence number
        m_tb_key_get_iv_seq(&p_buf_env->seq, &p_buf_env->u5.iv);
    c486:	3014      	adds	r0, #20
        {
            break;
        }

        // Get local index of network key to use
        p_buf_env->net_lid = p_app_key->net_key_lid;
    c488:	7463      	strb	r3, [r4, #17]
        // Retrieve IV and sequence number
        m_tb_key_get_iv_seq(&p_buf_env->seq, &p_buf_env->u5.iv);
    c48a:	f006 fbd9 	bl	12c40 <m_tb_key_get_iv_seq>

        // Put operation code in PDU
        status = m_lay_access_opcode_set(p_buf, opcode);
    c48e:	9905      	ldr	r1, [sp, #20]
    c490:	0020      	movs	r0, r4
    c492:	f7ff fe15 	bl	c0c0 <m_lay_access_opcode_set>
    c496:	1e05      	subs	r5, r0, #0

        if (status != M_ERR_NO_ERROR)
    c498:	d121      	bne.n	c4de <m_lay_access_publish+0xe2>
        {
            break;
        }

        // Push the buffer for transmission
        status = p_m_lay_access_env->p_utrans_api->send(p_buf, M_LAY_UTRANS_INTF_TYPE_ACCESS);
    c49a:	4f12      	ldr	r7, [pc, #72]	; (c4e4 <m_lay_access_publish+0xe8>)
    c49c:	0001      	movs	r1, r0
    c49e:	683b      	ldr	r3, [r7, #0]
    c4a0:	0020      	movs	r0, r4
    c4a2:	681b      	ldr	r3, [r3, #0]
    c4a4:	681b      	ldr	r3, [r3, #0]
    c4a6:	4798      	blx	r3
    c4a8:	1e05      	subs	r5, r0, #0

        if (status != M_ERR_NO_ERROR)
    c4aa:	d118      	bne.n	c4de <m_lay_access_publish+0xe2>
        {
            break;
        }

        // TX must be handled by a specific element, remove it from free list
        if ((GETF(retx_param, M_RETX_NB) > 0)
    c4ac:	2607      	movs	r6, #7
    c4ae:	ab02      	add	r3, sp, #8
    c4b0:	7c5b      	ldrb	r3, [r3, #17]
    c4b2:	4233      	tst	r3, r6
    c4b4:	d00d      	beq.n	c4d2 <m_lay_access_publish+0xd6>
                && co_list_pick(&p_m_lay_access_env->tx_free))
    c4b6:	6838      	ldr	r0, [r7, #0]
    c4b8:	6903      	ldr	r3, [r0, #16]
    c4ba:	2b00      	cmp	r3, #0
    c4bc:	d009      	beq.n	c4d2 <m_lay_access_publish+0xd6>
        {
            // Retransmission element
            m_lay_access_tx_elt_t *p_tx_elt
                    = (m_lay_access_tx_elt_t *)co_list_pop_front(&p_m_lay_access_env->tx_free);
    c4be:	3010      	adds	r0, #16
        // TX must be handled by a specific element, remove it from free list
        if ((GETF(retx_param, M_RETX_NB) > 0)
                && co_list_pick(&p_m_lay_access_env->tx_free))
        {
            // Retransmission element
            m_lay_access_tx_elt_t *p_tx_elt
    c4c0:	f7f7 ff94 	bl	43ec <co_list_pop_front>
                    = (m_lay_access_tx_elt_t *)co_list_pop_front(&p_m_lay_access_env->tx_free);

            // store information about the buffer
            p_tx_elt->p_buf = p_buf;
            p_tx_elt->retx_delay = GETF(retx_param, M_RETX_STEP);
    c4c4:	ab02      	add	r3, sp, #8
    c4c6:	7c5b      	ldrb	r3, [r3, #17]
            // Retransmission element
            m_lay_access_tx_elt_t *p_tx_elt
                    = (m_lay_access_tx_elt_t *)co_list_pop_front(&p_m_lay_access_env->tx_free);

            // store information about the buffer
            p_tx_elt->p_buf = p_buf;
    c4c8:	6044      	str	r4, [r0, #4]
            p_tx_elt->retx_delay = GETF(retx_param, M_RETX_STEP);
    c4ca:	08da      	lsrs	r2, r3, #3
            p_tx_elt->nb_tx_remain = GETF(retx_param, M_RETX_NB);
    c4cc:	401e      	ands	r6, r3
            m_lay_access_tx_elt_t *p_tx_elt
                    = (m_lay_access_tx_elt_t *)co_list_pop_front(&p_m_lay_access_env->tx_free);

            // store information about the buffer
            p_tx_elt->p_buf = p_buf;
            p_tx_elt->retx_delay = GETF(retx_param, M_RETX_STEP);
    c4ce:	7742      	strb	r2, [r0, #29]
            p_tx_elt->nb_tx_remain = GETF(retx_param, M_RETX_NB);
    c4d0:	7706      	strb	r6, [r0, #28]
        }

        // Acquire buffer
        m_tb_buf_acquire(p_buf);
    c4d2:	0020      	movs	r0, r4
    c4d4:	f005 f8de 	bl	11694 <m_tb_buf_acquire>
    c4d8:	e001      	b.n	c4de <m_lay_access_publish+0xe2>
        uint8_t ttl;

        // Sanity check
        if (p_buf == NULL)
        {
            status = M_ERR_INVALID_PARAM;
    c4da:	25c1      	movs	r5, #193	; 0xc1
    c4dc:	006d      	lsls	r5, r5, #1
        // Acquire buffer
        m_tb_buf_acquire(p_buf);
    } while(0);

    return (status);
}
    c4de:	0028      	movs	r0, r5
    c4e0:	b009      	add	sp, #36	; 0x24
    c4e2:	bdf0      	pop	{r4, r5, r6, r7, pc}
    c4e4:	100126a8 	.word	0x100126a8

0000c4e8 <m_lay_access_rsp_send>:

uint16_t m_lay_access_rsp_send(m_lid_t model_lid, uint32_t opcode, uint8_t tx_hdl, m_tb_buf_t *p_buf,
                               m_lid_t key_lid, uint16_t dst, bool trans_mic_64, bool not_relay)
{
    c4e8:	b5f0      	push	{r4, r5, r6, r7, lr}
    c4ea:	b085      	sub	sp, #20
    c4ec:	001c      	movs	r4, r3
    c4ee:	ab0a      	add	r3, sp, #40	; 0x28
    c4f0:	781e      	ldrb	r6, [r3, #0]
    c4f2:	ab0b      	add	r3, sp, #44	; 0x2c
    c4f4:	9101      	str	r1, [sp, #4]
    c4f6:	8819      	ldrh	r1, [r3, #0]
    c4f8:	ab0c      	add	r3, sp, #48	; 0x30
    c4fa:	0007      	movs	r7, r0
    c4fc:	781b      	ldrb	r3, [r3, #0]
    {
        // Buffer environment
        m_lay_buf_env_t *p_buf_env;

        // Sanity check
        if (p_buf == NULL)
    c4fe:	2c00      	cmp	r4, #0
    c500:	d04d      	beq.n	c59e <m_lay_access_rsp_send+0xb6>
            status = M_ERR_INVALID_PARAM;
            break;
        }

        // Destination address must be a unicast address
        if (!M_IS_UNICAST_ADDR(dst)
    c502:	b208      	sxth	r0, r1
    c504:	2800      	cmp	r0, #0
    c506:	dd4d      	ble.n	c5a4 <m_lay_access_rsp_send+0xbc>
        p_buf_env = (m_lay_buf_env_t *)p_buf->env;

        p_buf_env->model_lid = model_lid;
        p_buf_env->flags = 0;
        SETB(p_buf_env->flags, M_LAY_BUF_SIZE_MIC, trans_mic_64);
        SETB(p_buf_env->flags, M_LAY_BUF_RESP, true);
    c508:	2004      	movs	r0, #4
    c50a:	005b      	lsls	r3, r3, #1
    c50c:	4303      	orrs	r3, r0
    c50e:	7423      	strb	r3, [r4, #16]
        p_buf_env->dst = dst;
        p_buf_env->app_lid = (key_lid & 0x80) ? M_TB_KEY_DEVICE_LID : (key_lid & 0x7F);
    c510:	b273      	sxtb	r3, r6
    c512:	43db      	mvns	r3, r3

        p_buf_env->model_lid = model_lid;
        p_buf_env->flags = 0;
        SETB(p_buf_env->flags, M_LAY_BUF_SIZE_MIC, trans_mic_64);
        SETB(p_buf_env->flags, M_LAY_BUF_RESP, true);
        p_buf_env->dst = dst;
    c514:	83e1      	strh	r1, [r4, #30]
        p_buf_env->app_lid = (key_lid & 0x80) ? M_TB_KEY_DEVICE_LID : (key_lid & 0x7F);
        p_buf_env->ttl_ctl = M_TTL_DEFAULT;
    c516:	210b      	movs	r1, #11
        p_buf_env->model_lid = model_lid;
        p_buf_env->flags = 0;
        SETB(p_buf_env->flags, M_LAY_BUF_SIZE_MIC, trans_mic_64);
        SETB(p_buf_env->flags, M_LAY_BUF_RESP, true);
        p_buf_env->dst = dst;
        p_buf_env->app_lid = (key_lid & 0x80) ? M_TB_KEY_DEVICE_LID : (key_lid & 0x7F);
    c518:	17db      	asrs	r3, r3, #31
    c51a:	4033      	ands	r3, r6
    c51c:	74a3      	strb	r3, [r4, #18]
        p_buf_env->ttl_ctl = M_TTL_DEFAULT;
    c51e:	1c63      	adds	r3, r4, #1
        }

        // Prepare buffer environment
        p_buf_env = (m_lay_buf_env_t *)p_buf->env;

        p_buf_env->model_lid = model_lid;
    c520:	74e7      	strb	r7, [r4, #19]
        p_buf_env->flags = 0;
        SETB(p_buf_env->flags, M_LAY_BUF_SIZE_MIC, trans_mic_64);
        SETB(p_buf_env->flags, M_LAY_BUF_RESP, true);
        p_buf_env->dst = dst;
        p_buf_env->app_lid = (key_lid & 0x80) ? M_TB_KEY_DEVICE_LID : (key_lid & 0x7F);
        p_buf_env->ttl_ctl = M_TTL_DEFAULT;
    c522:	77d9      	strb	r1, [r3, #31]
        p_buf_env->u9.tx_hdl = tx_hdl;
    c524:	1ca3      	adds	r3, r4, #2
    c526:	77da      	strb	r2, [r3, #31]
        p_buf_env->va_lid = M_INVALID_LID;
    c528:	22ff      	movs	r2, #255	; 0xff
        p_buf_env->friend_lid = M_INVALID_LID;

        // Retrieve address of element the model belongs to and use it as source address
        status = m_tb_mio_get_element_addr(model_lid, &p_buf_env->src);
    c52a:	0021      	movs	r1, r4
        SETB(p_buf_env->flags, M_LAY_BUF_RESP, true);
        p_buf_env->dst = dst;
        p_buf_env->app_lid = (key_lid & 0x80) ? M_TB_KEY_DEVICE_LID : (key_lid & 0x7F);
        p_buf_env->ttl_ctl = M_TTL_DEFAULT;
        p_buf_env->u9.tx_hdl = tx_hdl;
        p_buf_env->va_lid = M_INVALID_LID;
    c52c:	1ce3      	adds	r3, r4, #3
    c52e:	77da      	strb	r2, [r3, #31]
        p_buf_env->friend_lid = M_INVALID_LID;
    c530:	1823      	adds	r3, r4, r0
    c532:	77da      	strb	r2, [r3, #31]

        // Retrieve address of element the model belongs to and use it as source address
        status = m_tb_mio_get_element_addr(model_lid, &p_buf_env->src);
    c534:	311c      	adds	r1, #28
    c536:	0038      	movs	r0, r7
    c538:	f006 fee4 	bl	13304 <m_tb_mio_get_element_addr>
    c53c:	1e05      	subs	r5, r0, #0

        if (status != M_ERR_NO_ERROR)
    c53e:	d133      	bne.n	c5a8 <m_lay_access_rsp_send+0xc0>
        {
            break;
        }

        // Check that model is well bound with application key
        status = m_tb_key_model_bind_check(p_buf_env->app_lid, model_lid);
    c540:	7ca0      	ldrb	r0, [r4, #18]
    c542:	0039      	movs	r1, r7
    c544:	f006 fb50 	bl	12be8 <m_tb_key_model_bind_check>
    c548:	1e05      	subs	r5, r0, #0

        if (status != M_ERR_NO_ERROR)
    c54a:	d12d      	bne.n	c5a8 <m_lay_access_rsp_send+0xc0>
        {
            break;
        }

        if (p_buf_env->app_lid == M_TB_KEY_DEVICE_LID)
    c54c:	7ca0      	ldrb	r0, [r4, #18]
    c54e:	2800      	cmp	r0, #0
    c550:	d103      	bne.n	c55a <m_lay_access_rsp_send+0x72>
        {
            // Set network key local index
            p_buf_env->net_lid = key_lid & 0x7F;
    c552:	237f      	movs	r3, #127	; 0x7f
    c554:	401e      	ands	r6, r3
    c556:	7466      	strb	r6, [r4, #17]
    c558:	e008      	b.n	c56c <m_lay_access_rsp_send+0x84>
        {
            // Application key
            const m_tb_key_app_t *p_app_key;

            // Get application key to be used for transmission
            status = m_tb_key_app_get(p_buf_env->app_lid, &p_app_key, true);
    c55a:	2201      	movs	r2, #1
    c55c:	a903      	add	r1, sp, #12
    c55e:	f006 f919 	bl	12794 <m_tb_key_app_get>
    c562:	1e05      	subs	r5, r0, #0

            if (status != M_ERR_NO_ERROR)
    c564:	d120      	bne.n	c5a8 <m_lay_access_rsp_send+0xc0>
            {
                break;
            }

            // Set network key local index
            p_buf_env->net_lid = p_app_key->net_key_lid;
    c566:	9b03      	ldr	r3, [sp, #12]
    c568:	7d9b      	ldrb	r3, [r3, #22]
    c56a:	7463      	strb	r3, [r4, #17]
        }

        // Retrieve IV and sequence number
        m_tb_key_get_iv_seq(&p_buf_env->seq, &p_buf_env->u5.iv);
    c56c:	0021      	movs	r1, r4
    c56e:	0020      	movs	r0, r4
    c570:	3118      	adds	r1, #24
    c572:	3014      	adds	r0, #20
    c574:	f006 fb64 	bl	12c40 <m_tb_key_get_iv_seq>

        // Put operation code in PDU
        status = m_lay_access_opcode_set(p_buf, opcode);
    c578:	9901      	ldr	r1, [sp, #4]
    c57a:	0020      	movs	r0, r4
    c57c:	f7ff fda0 	bl	c0c0 <m_lay_access_opcode_set>
    c580:	1e05      	subs	r5, r0, #0

        if (status != M_ERR_NO_ERROR)
    c582:	d111      	bne.n	c5a8 <m_lay_access_rsp_send+0xc0>
        {
            break;
        }

        // Push the buffer for transmission
        status = p_m_lay_access_env->p_utrans_api->send(p_buf, M_LAY_UTRANS_INTF_TYPE_ACCESS);
    c584:	4b0a      	ldr	r3, [pc, #40]	; (c5b0 <m_lay_access_rsp_send+0xc8>)
    c586:	0001      	movs	r1, r0
    c588:	681b      	ldr	r3, [r3, #0]
    c58a:	0020      	movs	r0, r4
    c58c:	681b      	ldr	r3, [r3, #0]
    c58e:	681b      	ldr	r3, [r3, #0]
    c590:	4798      	blx	r3
    c592:	1e05      	subs	r5, r0, #0

        if (status != M_ERR_NO_ERROR)
    c594:	d108      	bne.n	c5a8 <m_lay_access_rsp_send+0xc0>
        {
            break;
        }

        // Acquire buffer
        m_tb_buf_acquire(p_buf);
    c596:	0020      	movs	r0, r4
    c598:	f005 f87c 	bl	11694 <m_tb_buf_acquire>
    c59c:	e004      	b.n	c5a8 <m_lay_access_rsp_send+0xc0>
        m_lay_buf_env_t *p_buf_env;

        // Sanity check
        if (p_buf == NULL)
        {
            status = M_ERR_INVALID_PARAM;
    c59e:	25c1      	movs	r5, #193	; 0xc1
    c5a0:	006d      	lsls	r5, r5, #1
    c5a2:	e001      	b.n	c5a8 <m_lay_access_rsp_send+0xc0>

        // Destination address must be a unicast address
        if (!M_IS_UNICAST_ADDR(dst)
                || (dst == M_UNASSIGNED_ADDR))
        {
            status = M_ERR_INVALID_ADDR;
    c5a4:	25c0      	movs	r5, #192	; 0xc0
    c5a6:	006d      	lsls	r5, r5, #1
        // Acquire buffer
        m_tb_buf_acquire(p_buf);
    } while(0);

    return (status);
}
    c5a8:	0028      	movs	r0, r5
    c5aa:	b005      	add	sp, #20
    c5ac:	bdf0      	pop	{r4, r5, r6, r7, pc}
    c5ae:	46c0      	nop			; (mov r8, r8)
    c5b0:	100126a8 	.word	0x100126a8

0000c5b4 <m_lay_access_opcode_status>:
    do
    {
        // Buffer environment
        m_lay_buf_env_t *p_buf_env;
        // Get buffer for which status is provided
        m_tb_buf_t *p_buf = (m_tb_buf_t *)co_list_pick(&p_m_lay_access_env->rx_queue);
    c5b4:	4b19      	ldr	r3, [pc, #100]	; (c61c <m_lay_access_opcode_status+0x68>)

    return (status);
}

void m_lay_access_opcode_status(m_lid_t model_lid, uint32_t opcode, uint16_t status)
{
    c5b6:	b5f0      	push	{r4, r5, r6, r7, lr}
    do
    {
        // Buffer environment
        m_lay_buf_env_t *p_buf_env;
        // Get buffer for which status is provided
        m_tb_buf_t *p_buf = (m_tb_buf_t *)co_list_pick(&p_m_lay_access_env->rx_queue);
    c5b8:	681b      	ldr	r3, [r3, #0]

    return (status);
}

void m_lay_access_opcode_status(m_lid_t model_lid, uint32_t opcode, uint16_t status)
{
    c5ba:	b087      	sub	sp, #28
    c5bc:	699c      	ldr	r4, [r3, #24]
    c5be:	0017      	movs	r7, r2
        m_tb_buf_t *p_buf = (m_tb_buf_t *)co_list_pick(&p_m_lay_access_env->rx_queue);
        // Model callbacks
        const m_api_model_cb_t* p_model_cb;

        // Sanity checks
        if (p_buf == NULL)
    c5c0:	2c00      	cmp	r4, #0
    c5c2:	d100      	bne.n	c5c6 <m_lay_access_opcode_status+0x12>
    c5c4:	e7fe      	b.n	c5c4 <m_lay_access_opcode_status+0x10>

        // Retrieve buffer environment
        p_buf_env = (m_lay_buf_env_t *)p_buf->env;

        // Sanity check
        if ((p_buf_env->model_lid != model_lid) || (p_buf_env->u5.opcode != opcode))
    c5c6:	7ce5      	ldrb	r5, [r4, #19]
    c5c8:	4285      	cmp	r5, r0
    c5ca:	d102      	bne.n	c5d2 <m_lay_access_opcode_status+0x1e>
    c5cc:	69a6      	ldr	r6, [r4, #24]
    c5ce:	428e      	cmp	r6, r1
    c5d0:	d000      	beq.n	c5d4 <m_lay_access_opcode_status+0x20>
    c5d2:	e7fe      	b.n	c5d2 <m_lay_access_opcode_status+0x1e>
            ASSERT_INFO(0, model_lid, opcode);
            break;
        }

        // Increment Model LID
        p_buf_env->model_lid++;
    c5d4:	1c6a      	adds	r2, r5, #1
    c5d6:	74e2      	strb	r2, [r4, #19]

        // Prepare delayed job to continue message handling in background queue
        m_al_djob_reg(&p_m_lay_access_env->rx_djob);
    c5d8:	1d18      	adds	r0, r3, #4
    c5da:	f7f8 fb57 	bl	4c8c <m_al_djob_reg>

        // Check that operation code is supported
        if (status != M_ERR_NO_ERROR)
    c5de:	2f00      	cmp	r7, #0
    c5e0:	d119      	bne.n	c616 <m_lay_access_opcode_status+0x62>
        {
            break;
        }

        // Load callback for the model
        if (m_tb_mio_cb_get(model_lid, &p_model_cb) == M_ERR_NO_ERROR)
    c5e2:	a905      	add	r1, sp, #20
    c5e4:	0028      	movs	r0, r5
    c5e6:	f006 fea5 	bl	13334 <m_tb_mio_cb_get>
    c5ea:	2800      	cmp	r0, #0
    c5ec:	d113      	bne.n	c616 <m_lay_access_opcode_status+0x62>
        {
            // Inform model about received message
            p_model_cb->cb_rx(model_lid, opcode, (m_api_buf_t *)p_buf, p_buf_env->app_lid, p_buf_env->src,
                              p_buf_env->u9.rssi, GETF(p_buf_env->ttl_ctl, M_MSG_TTL) == 0);
    c5ee:	1c62      	adds	r2, r4, #1

        // Load callback for the model
        if (m_tb_mio_cb_get(model_lid, &p_model_cb) == M_ERR_NO_ERROR)
        {
            // Inform model about received message
            p_model_cb->cb_rx(model_lid, opcode, (m_api_buf_t *)p_buf, p_buf_env->app_lid, p_buf_env->src,
    c5f0:	7fd1      	ldrb	r1, [r2, #31]
    c5f2:	227f      	movs	r2, #127	; 0x7f
    c5f4:	400a      	ands	r2, r1
    c5f6:	4251      	negs	r1, r2
    c5f8:	414a      	adcs	r2, r1
    c5fa:	7ca3      	ldrb	r3, [r4, #18]
    c5fc:	9202      	str	r2, [sp, #8]
    c5fe:	1ca2      	adds	r2, r4, #2
    c600:	7fd2      	ldrb	r2, [r2, #31]
    c602:	0031      	movs	r1, r6
    c604:	b252      	sxtb	r2, r2
    c606:	9201      	str	r2, [sp, #4]
    c608:	8ba2      	ldrh	r2, [r4, #28]
    c60a:	0028      	movs	r0, r5
    c60c:	9200      	str	r2, [sp, #0]
    c60e:	9a05      	ldr	r2, [sp, #20]
    c610:	6817      	ldr	r7, [r2, #0]
    c612:	0022      	movs	r2, r4
    c614:	47b8      	blx	r7
                              p_buf_env->u9.rssi, GETF(p_buf_env->ttl_ctl, M_MSG_TTL) == 0);
        }

    } while(0);
}
    c616:	b007      	add	sp, #28
    c618:	bdf0      	pop	{r4, r5, r6, r7, pc}
    c61a:	46c0      	nop			; (mov r8, r8)
    c61c:	100126a8 	.word	0x100126a8

0000c620 <m_lay_hb_send>:
 ****************************************************************************************
 * @brief Prepare and push an heartbeat message for transmission
 ****************************************************************************************
 */
__STATIC void m_lay_hb_send(bool feature)
{
    c620:	b5f0      	push	{r4, r5, r6, r7, lr}
    c622:	b085      	sub	sp, #20
    c624:	0007      	movs	r7, r0
    // Get publication parameters
    m_tb_state_hb_pub_t *p_pub_params = m_tb_state_get_hb_pub_params();
    c626:	f007 ff43 	bl	144b0 <m_tb_state_get_hb_pub_params>
    c62a:	0005      	movs	r5, r0
    uint16_t features = 0;
    // Allocate a buffer
    m_tb_buf_t *p_buf;

    #if (BLE_MESH_RELAY)
    if (m_tb_state_get_relay_state(NULL) == M_CONF_RELAY_STATE_ENABLED)
    c62c:	2000      	movs	r0, #0
    c62e:	f007 fee5 	bl	143fc <m_tb_state_get_relay_state>
    c632:	3801      	subs	r0, #1
    c634:	4243      	negs	r3, r0
    c636:	4158      	adcs	r0, r3
    c638:	b2c3      	uxtb	r3, r0
    c63a:	9301      	str	r3, [sp, #4]
    {
        SETB(features, M_LAY_HB_FEAT_LPN, 1);
    }
    #endif //(BLE_MESH_LPN)

    if (m_tb_buf_alloc(&p_buf, M_LAY_TRANS_BUF_HEADER_LEN + 5, M_LAY_HB_LEN,
    c63c:	2203      	movs	r2, #3
    c63e:	2308      	movs	r3, #8
    c640:	210e      	movs	r1, #14
    c642:	a803      	add	r0, sp, #12
    c644:	f004 ff78 	bl	11538 <m_tb_buf_alloc>
    c648:	1e06      	subs	r6, r0, #0
    c64a:	d133      	bne.n	c6b4 <m_lay_hb_send+0x94>
                       M_NMIC_CTL_LEN) == M_ERR_NO_ERROR)
    {
        // Get pointer to data
        uint8_t *p_data = M_TB_BUF_DATA(p_buf);
    c64c:	9c03      	ldr	r4, [sp, #12]
    c64e:	0022      	movs	r2, r4
    c650:	88a3      	ldrh	r3, [r4, #4]
    c652:	3230      	adds	r2, #48	; 0x30
    c654:	18d3      	adds	r3, r2, r3
        // Get buffer environment
        m_lay_buf_env_t *p_env = (m_lay_buf_env_t *)&p_buf->env[0];

        // Write init ttl value
        *(p_data + M_LAY_HB_INIT_TTL_POS) = p_pub_params->ttl;
    c656:	79aa      	ldrb	r2, [r5, #6]
__INLINE_S__ void co_write16p(void const *ptr16, uint16_t value)
{
    uint8_t *ptr=(uint8_t*)ptr16;

    *ptr++ = value&0xff;
    *ptr = (value&0xff00)>>8;
    c658:	7098      	strb	r0, [r3, #2]
    c65a:	701a      	strb	r2, [r3, #0]
 */
__INLINE_S__ void co_write16p(void const *ptr16, uint16_t value)
{
    uint8_t *ptr=(uint8_t*)ptr16;

    *ptr++ = value&0xff;
    c65c:	466a      	mov	r2, sp
    c65e:	7912      	ldrb	r2, [r2, #4]
    c660:	705a      	strb	r2, [r3, #1]
        // Write features value
        co_write16p(p_data + M_LAY_HB_FEAT_POS, features);

        // Prepare environment
        p_env->net_lid = p_pub_params->net_key_lid;
    c662:	79eb      	ldrb	r3, [r5, #7]
        p_env->app_lid = M_INVALID_LID;
        p_env->va_lid = M_INVALID_LID;
    c664:	1ce2      	adds	r2, r4, #3
        *(p_data + M_LAY_HB_INIT_TTL_POS) = p_pub_params->ttl;
        // Write features value
        co_write16p(p_data + M_LAY_HB_FEAT_POS, features);

        // Prepare environment
        p_env->net_lid = p_pub_params->net_key_lid;
    c666:	7463      	strb	r3, [r4, #17]
        p_env->app_lid = M_INVALID_LID;
    c668:	23ff      	movs	r3, #255	; 0xff
    c66a:	74a3      	strb	r3, [r4, #18]
        p_env->va_lid = M_INVALID_LID;
    c66c:	77d3      	strb	r3, [r2, #31]
        p_env->friend_lid = M_INVALID_LID;
    c66e:	1d22      	adds	r2, r4, #4
    c670:	77d3      	strb	r3, [r2, #31]
        p_env->src = m_tb_mio_get_prim_addr();
    c672:	f007 f9e1 	bl	13a38 <m_tb_mio_get_prim_addr>
        p_env->dst = p_pub_params->dst_addr;
        p_env->ttl_ctl = p_pub_params->ttl | M_MSG_CTL_BIT;
    c676:	2280      	movs	r2, #128	; 0x80
        // Prepare environment
        p_env->net_lid = p_pub_params->net_key_lid;
        p_env->app_lid = M_INVALID_LID;
        p_env->va_lid = M_INVALID_LID;
        p_env->friend_lid = M_INVALID_LID;
        p_env->src = m_tb_mio_get_prim_addr();
    c678:	83a0      	strh	r0, [r4, #28]
        p_env->dst = p_pub_params->dst_addr;
        p_env->ttl_ctl = p_pub_params->ttl | M_MSG_CTL_BIT;
        p_env->flags = 0;
        m_tb_key_get_iv_seq(&p_env->seq, &p_env->u5.iv);
    c67a:	0021      	movs	r1, r4
    c67c:	0020      	movs	r0, r4
        p_env->net_lid = p_pub_params->net_key_lid;
        p_env->app_lid = M_INVALID_LID;
        p_env->va_lid = M_INVALID_LID;
        p_env->friend_lid = M_INVALID_LID;
        p_env->src = m_tb_mio_get_prim_addr();
        p_env->dst = p_pub_params->dst_addr;
    c67e:	882b      	ldrh	r3, [r5, #0]
        p_env->ttl_ctl = p_pub_params->ttl | M_MSG_CTL_BIT;
    c680:	4252      	negs	r2, r2
        p_env->net_lid = p_pub_params->net_key_lid;
        p_env->app_lid = M_INVALID_LID;
        p_env->va_lid = M_INVALID_LID;
        p_env->friend_lid = M_INVALID_LID;
        p_env->src = m_tb_mio_get_prim_addr();
        p_env->dst = p_pub_params->dst_addr;
    c682:	83e3      	strh	r3, [r4, #30]
        p_env->ttl_ctl = p_pub_params->ttl | M_MSG_CTL_BIT;
    c684:	79ab      	ldrb	r3, [r5, #6]
        p_env->flags = 0;
        m_tb_key_get_iv_seq(&p_env->seq, &p_env->u5.iv);
    c686:	3118      	adds	r1, #24
        p_env->app_lid = M_INVALID_LID;
        p_env->va_lid = M_INVALID_LID;
        p_env->friend_lid = M_INVALID_LID;
        p_env->src = m_tb_mio_get_prim_addr();
        p_env->dst = p_pub_params->dst_addr;
        p_env->ttl_ctl = p_pub_params->ttl | M_MSG_CTL_BIT;
    c688:	4313      	orrs	r3, r2
    c68a:	1c62      	adds	r2, r4, #1
    c68c:	77d3      	strb	r3, [r2, #31]
        p_env->flags = 0;
        m_tb_key_get_iv_seq(&p_env->seq, &p_env->u5.iv);
    c68e:	3014      	adds	r0, #20
        p_env->va_lid = M_INVALID_LID;
        p_env->friend_lid = M_INVALID_LID;
        p_env->src = m_tb_mio_get_prim_addr();
        p_env->dst = p_pub_params->dst_addr;
        p_env->ttl_ctl = p_pub_params->ttl | M_MSG_CTL_BIT;
        p_env->flags = 0;
    c690:	7426      	strb	r6, [r4, #16]
        m_tb_key_get_iv_seq(&p_env->seq, &p_env->u5.iv);
    c692:	f006 fad5 	bl	12c40 <m_tb_key_get_iv_seq>
        p_env->u14.opcode_aid_afk = M_LAY_UTRANS_OPCODE_HEARTBEAT;
    c696:	230a      	movs	r3, #10
    c698:	342c      	adds	r4, #44	; 0x2c
    c69a:	7023      	strb	r3, [r4, #0]

        // Push the message
        if (p_m_lay_hb_env->p_utrans_api->send(p_buf, M_LAY_UTRANS_INTF_TYPE_HB) != M_ERR_NO_ERROR)
    c69c:	4b08      	ldr	r3, [pc, #32]	; (c6c0 <m_lay_hb_send+0xa0>)
    c69e:	2101      	movs	r1, #1
    c6a0:	681b      	ldr	r3, [r3, #0]
    c6a2:	9803      	ldr	r0, [sp, #12]
    c6a4:	681b      	ldr	r3, [r3, #0]
    c6a6:	681b      	ldr	r3, [r3, #0]
    c6a8:	4798      	blx	r3
    c6aa:	2800      	cmp	r0, #0
    c6ac:	d002      	beq.n	c6b4 <m_lay_hb_send+0x94>
        {
            // Release the buffer
            m_tb_buf_release(p_buf);
    c6ae:	9803      	ldr	r0, [sp, #12]
    c6b0:	f004 fff4 	bl	1169c <m_tb_buf_release>
        }
    }

    // Decrease count value if needed
    if (!feature)
    c6b4:	2f00      	cmp	r7, #0
    c6b6:	d101      	bne.n	c6bc <m_lay_hb_send+0x9c>
    {
        // Inform State Manager about transmission of an heartbeat message
        m_tb_state_hb_tx_ind();
    c6b8:	f007 ff82 	bl	145c0 <m_tb_state_hb_tx_ind>
    }
}
    c6bc:	b005      	add	sp, #20
    c6be:	bdf0      	pop	{r4, r5, r6, r7, pc}
    c6c0:	100126ac 	.word	0x100126ac

0000c6c4 <m_lay_hb_cb_timer_subs>:
 ****************************************************************************************
 * @brief Handle heartbeat subscription timer expiration
 ****************************************************************************************
 */
__STATIC void m_lay_hb_cb_timer_subs(void *p_env)
{
    c6c4:	b510      	push	{r4, lr}
    // Get subscription parameters
    m_tb_state_hb_subs_t *p_subs_params = m_tb_state_get_hb_subs_params();
    c6c6:	f007 fef9 	bl	144bc <m_tb_state_get_hb_subs_params>

    // Decrease remaining duration
    p_subs_params->period_s--;
    c6ca:	6803      	ldr	r3, [r0, #0]
    c6cc:	3b01      	subs	r3, #1
    c6ce:	6003      	str	r3, [r0, #0]

    if (p_subs_params->period_s)
    c6d0:	2b00      	cmp	r3, #0
    c6d2:	d006      	beq.n	c6e2 <m_lay_hb_cb_timer_subs+0x1e>
    {
        // Restart the timer
        m_tb_timer_set(&p_m_lay_hb_env->timer_hbeat_subs, 1000);
    c6d4:	21fa      	movs	r1, #250	; 0xfa
    c6d6:	4b03      	ldr	r3, [pc, #12]	; (c6e4 <m_lay_hb_cb_timer_subs+0x20>)
    c6d8:	0089      	lsls	r1, r1, #2
    c6da:	6818      	ldr	r0, [r3, #0]
    c6dc:	3004      	adds	r0, #4
    c6de:	f008 fe11 	bl	15304 <m_tb_timer_set>
    }
}
    c6e2:	bd10      	pop	{r4, pc}
    c6e4:	100126ac 	.word	0x100126ac

0000c6e8 <m_lay_hb_cb_timer_pub>:
 ****************************************************************************************
 * @brief Handle heartbeat publication timer expiration
 ****************************************************************************************
 */
__STATIC void m_lay_hb_cb_timer_pub(void *p_env)
{
    c6e8:	b510      	push	{r4, lr}
    // Get publication parameters
    m_tb_state_hb_pub_t *p_pub_params = m_tb_state_get_hb_pub_params();
    c6ea:	f007 fee1 	bl	144b0 <m_tb_state_get_hb_pub_params>

    // Restart publication timer if needed
    if (p_pub_params->count)
    c6ee:	8843      	ldrh	r3, [r0, #2]
    c6f0:	2b00      	cmp	r3, #0
    c6f2:	d008      	beq.n	c706 <m_lay_hb_cb_timer_pub+0x1e>
    {
        m_tb_timer_set(&p_m_lay_hb_env->timer_hbeat_pub, 1000 * p_pub_params->period_s);
    c6f4:	23fa      	movs	r3, #250	; 0xfa
    c6f6:	8881      	ldrh	r1, [r0, #4]
    c6f8:	009b      	lsls	r3, r3, #2
    c6fa:	4359      	muls	r1, r3
    c6fc:	4b04      	ldr	r3, [pc, #16]	; (c710 <m_lay_hb_cb_timer_pub+0x28>)
    c6fe:	6818      	ldr	r0, [r3, #0]
    c700:	3018      	adds	r0, #24
    c702:	f008 fdff 	bl	15304 <m_tb_timer_set>
    }

    // Send an heartbeat message
    m_lay_hb_send(false);
    c706:	2000      	movs	r0, #0
    c708:	f7ff ff8a 	bl	c620 <m_lay_hb_send>
}
    c70c:	bd10      	pop	{r4, pc}
    c70e:	46c0      	nop			; (mov r8, r8)
    c710:	100126ac 	.word	0x100126ac

0000c714 <m_lay_hb_cb_state_updated>:
 * @brief Callback function callbed by State Manager each time heartbeat publication or
 * subscription parameters are updated
 ****************************************************************************************
 */
void m_lay_hb_cb_state_updated(uint8_t upd_type)
{
    c714:	b510      	push	{r4, lr}
	m_printf(L_HB, "---------m_lay_hb_cb_state_updated type[%x]-----", upd_type);
    c716:	0002      	movs	r2, r0
 * @brief Callback function callbed by State Manager each time heartbeat publication or
 * subscription parameters are updated
 ****************************************************************************************
 */
void m_lay_hb_cb_state_updated(uint8_t upd_type)
{
    c718:	0004      	movs	r4, r0
	m_printf(L_HB, "---------m_lay_hb_cb_state_updated type[%x]-----", upd_type);
    c71a:	2080      	movs	r0, #128	; 0x80
    c71c:	4914      	ldr	r1, [pc, #80]	; (c770 <m_lay_hb_cb_state_updated+0x5c>)
    c71e:	0080      	lsls	r0, r0, #2
    c720:	f7f8 f966 	bl	49f0 <m_printf>
    switch (upd_type)
    c724:	2c01      	cmp	r4, #1
    c726:	d013      	beq.n	c750 <m_lay_hb_cb_state_updated+0x3c>
    c728:	2c00      	cmp	r4, #0
    c72a:	d005      	beq.n	c738 <m_lay_hb_cb_state_updated+0x24>
    c72c:	2c02      	cmp	r4, #2
    c72e:	d11e      	bne.n	c76e <m_lay_hb_cb_state_updated+0x5a>

        // State of a feature has been updated
        case (M_TB_STATE_UPDATE_HB_FEATURE):
        {
            // Send an heartbeat message
            m_lay_hb_send(true);
    c730:	2001      	movs	r0, #1
    c732:	f7ff ff75 	bl	c620 <m_lay_hb_send>
        default:
        {
            // Should not happen
        } break;
    }
}
    c736:	e01a      	b.n	c76e <m_lay_hb_cb_state_updated+0x5a>
    {
        // Heartbeat publication parameters have been updated
        case (M_TB_STATE_UPDATE_HB_PUB):
        {
            // Get publication parameters
            m_tb_state_hb_pub_t *p_pub = m_tb_state_get_hb_pub_params();
    c738:	f007 feba 	bl	144b0 <m_tb_state_get_hb_pub_params>
    c73c:	4b0d      	ldr	r3, [pc, #52]	; (c774 <m_lay_hb_cb_state_updated+0x60>)

            if (p_pub->count == 0)
    c73e:	8842      	ldrh	r2, [r0, #2]
            {
                // Stop timer
                m_tb_timer_clear(&p_m_lay_hb_env->timer_hbeat_pub);
    c740:	6818      	ldr	r0, [r3, #0]
    c742:	3018      	adds	r0, #24
        case (M_TB_STATE_UPDATE_HB_PUB):
        {
            // Get publication parameters
            m_tb_state_hb_pub_t *p_pub = m_tb_state_get_hb_pub_params();

            if (p_pub->count == 0)
    c744:	2a00      	cmp	r2, #0
    c746:	d010      	beq.n	c76a <m_lay_hb_cb_state_updated+0x56>
                m_tb_timer_clear(&p_m_lay_hb_env->timer_hbeat_pub);
            }
            else
            {
                // Delay transmission of first heartbeat
                m_tb_timer_set(&p_m_lay_hb_env->timer_hbeat_pub, 20);
    c748:	2114      	movs	r1, #20
    c74a:	f008 fddb 	bl	15304 <m_tb_timer_set>
    c74e:	e00e      	b.n	c76e <m_lay_hb_cb_state_updated+0x5a>

        // Heartbeat subscription parameters have been updated
        case (M_TB_STATE_UPDATE_HB_SUBS):
        {
            // Get subscription parameters
            m_tb_state_hb_subs_t *p_subs = m_tb_state_get_hb_subs_params();
    c750:	f007 feb4 	bl	144bc <m_tb_state_get_hb_subs_params>
    c754:	4b07      	ldr	r3, [pc, #28]	; (c774 <m_lay_hb_cb_state_updated+0x60>)

            // Start heartbeat subscription timer
            if (p_subs->period_s)
    c756:	6802      	ldr	r2, [r0, #0]
            {
                // Restart the timer
                m_tb_timer_set(&p_m_lay_hb_env->timer_hbeat_subs, 1000);
    c758:	6818      	ldr	r0, [r3, #0]
    c75a:	3004      	adds	r0, #4
        {
            // Get subscription parameters
            m_tb_state_hb_subs_t *p_subs = m_tb_state_get_hb_subs_params();

            // Start heartbeat subscription timer
            if (p_subs->period_s)
    c75c:	2a00      	cmp	r2, #0
    c75e:	d004      	beq.n	c76a <m_lay_hb_cb_state_updated+0x56>
            {
                // Restart the timer
                m_tb_timer_set(&p_m_lay_hb_env->timer_hbeat_subs, 1000);
    c760:	21fa      	movs	r1, #250	; 0xfa
    c762:	0089      	lsls	r1, r1, #2
    c764:	f008 fdce 	bl	15304 <m_tb_timer_set>
    c768:	e001      	b.n	c76e <m_lay_hb_cb_state_updated+0x5a>
            }
            else
            {
                // Stop timer
                m_tb_timer_clear(&p_m_lay_hb_env->timer_hbeat_subs);
    c76a:	f008 fe15 	bl	15398 <m_tb_timer_clear>
        default:
        {
            // Should not happen
        } break;
    }
}
    c76e:	bd10      	pop	{r4, pc}
    c770:	000218d8 	.word	0x000218d8
    c774:	100126ac 	.word	0x100126ac

0000c778 <m_lay_hb_cb_sent>:
 * @param[in] p_buf_utrans      Pointer to buffer containing the upper transport PDU.
 * @param[in] status            Transmission status
 ****************************************************************************************
 */
__STATIC void m_lay_hb_cb_sent(m_tb_buf_t *p_buf, uint16_t status)
{
    c778:	b510      	push	{r4, lr}
    // Release the buffer
    m_tb_buf_release(p_buf);
    c77a:	f004 ff8f 	bl	1169c <m_tb_buf_release>
}
    c77e:	bd10      	pop	{r4, pc}

0000c780 <m_lay_hb_cb_rx>:
 *
 * @param[in] p_buf_utrans      Pointer to buffer containing the upper transport PDU.
 ****************************************************************************************
 */
__STATIC void m_lay_hb_cb_rx(m_tb_buf_t *p_buf)
{
    c780:	b570      	push	{r4, r5, r6, lr}
	m_printf_hex(L_HB, "recv hbs data", M_TB_BUF_DATA(p_buf), p_buf->data_len);
    c782:	0005      	movs	r5, r0
    c784:	8903      	ldrh	r3, [r0, #8]
    c786:	8882      	ldrh	r2, [r0, #4]
 *
 * @param[in] p_buf_utrans      Pointer to buffer containing the upper transport PDU.
 ****************************************************************************************
 */
__STATIC void m_lay_hb_cb_rx(m_tb_buf_t *p_buf)
{
    c788:	0004      	movs	r4, r0
	m_printf_hex(L_HB, "recv hbs data", M_TB_BUF_DATA(p_buf), p_buf->data_len);
    c78a:	2080      	movs	r0, #128	; 0x80
    c78c:	4912      	ldr	r1, [pc, #72]	; (c7d8 <m_lay_hb_cb_rx+0x58>)
    c78e:	3530      	adds	r5, #48	; 0x30
    c790:	18aa      	adds	r2, r5, r2
    c792:	3131      	adds	r1, #49	; 0x31
    c794:	0080      	lsls	r0, r0, #2
    c796:	f7f8 f969 	bl	4a6c <m_printf_hex>
    do
    {
        // Get buffer environment
        m_lay_buf_env_t *p_env = (m_lay_buf_env_t *)&p_buf->env[0];
        // Get heartbeat subscription parameters
        m_tb_state_hb_subs_t *p_subs_params = m_tb_state_get_hb_subs_params();
    c79a:	f007 fe8f 	bl	144bc <m_tb_state_get_hb_subs_params>

        // Check that reception of heartbeat messages is enabled
        if ((p_subs_params->src_addr == M_UNASSIGNED_ADDR)
    c79e:	88c2      	ldrh	r2, [r0, #6]
    c7a0:	2a00      	cmp	r2, #0
    c7a2:	d018      	beq.n	c7d6 <m_lay_hb_cb_rx+0x56>
                || (p_subs_params->dst_addr == M_UNASSIGNED_ADDR)
    c7a4:	8883      	ldrh	r3, [r0, #4]
    c7a6:	2b00      	cmp	r3, #0
    c7a8:	d015      	beq.n	c7d6 <m_lay_hb_cb_rx+0x56>
                || !p_subs_params->period_s)
    c7aa:	6801      	ldr	r1, [r0, #0]
    c7ac:	2900      	cmp	r1, #0
    c7ae:	d012      	beq.n	c7d6 <m_lay_hb_cb_rx+0x56>
        {
            break;
        }

        // Check source address and destination address
        if ((p_env->src == p_subs_params->src_addr)
    c7b0:	8ba1      	ldrh	r1, [r4, #28]
    c7b2:	4291      	cmp	r1, r2
    c7b4:	d10f      	bne.n	c7d6 <m_lay_hb_cb_rx+0x56>
                && (p_env->dst == p_subs_params->dst_addr))
    c7b6:	8be2      	ldrh	r2, [r4, #30]
    c7b8:	429a      	cmp	r2, r3
    c7ba:	d10c      	bne.n	c7d6 <m_lay_hb_cb_rx+0x56>
        {
            // Get pointer to data
            uint8_t *p_data = M_TB_BUF_DATA(p_buf);
            // Get Init TTL value
            uint8_t init_ttl = *(p_data + M_LAY_HB_INIT_TTL_POS) & M_MSG_TTL_MASK;
    c7bc:	88a3      	ldrh	r3, [r4, #4]
            // Compute number of hops
            uint8_t hops = init_ttl - GETF(p_env->ttl_ctl, M_MSG_TTL) + 1;

            // Inform State Manager about reception of a valid heartbeat message
            m_tb_state_hb_rx_ind(hops);
    c7be:	227f      	movs	r2, #127	; 0x7f
    c7c0:	5ce8      	ldrb	r0, [r5, r3]
            // Get pointer to data
            uint8_t *p_data = M_TB_BUF_DATA(p_buf);
            // Get Init TTL value
            uint8_t init_ttl = *(p_data + M_LAY_HB_INIT_TTL_POS) & M_MSG_TTL_MASK;
            // Compute number of hops
            uint8_t hops = init_ttl - GETF(p_env->ttl_ctl, M_MSG_TTL) + 1;
    c7c2:	3401      	adds	r4, #1

            // Inform State Manager about reception of a valid heartbeat message
            m_tb_state_hb_rx_ind(hops);
    c7c4:	0003      	movs	r3, r0
    c7c6:	7fe0      	ldrb	r0, [r4, #31]
    c7c8:	4013      	ands	r3, r2
    c7ca:	4002      	ands	r2, r0
    c7cc:	1a98      	subs	r0, r3, r2
    c7ce:	3001      	adds	r0, #1
    c7d0:	b2c0      	uxtb	r0, r0
    c7d2:	f007 fed9 	bl	14588 <m_tb_state_hb_rx_ind>
        }
    } while (0);
}
    c7d6:	bd70      	pop	{r4, r5, r6, pc}
    c7d8:	000218d8 	.word	0x000218d8

0000c7dc <m_lay_hb_init>:
 * GLOBAL FUNCTIONS
 ****************************************************************************************
 */

uint16_t m_lay_hb_init(bool reset, void *p_env)
{
    c7dc:	b510      	push	{r4, lr}
    c7de:	4b09      	ldr	r3, [pc, #36]	; (c804 <m_lay_hb_init+0x28>)
    c7e0:	000c      	movs	r4, r1
    if (!reset)
    c7e2:	2800      	cmp	r0, #0
    c7e4:	d10a      	bne.n	c7fc <m_lay_hb_init+0x20>
    {
        // Get environment for Heartbeat module
        p_m_lay_hb_env = (m_lay_hb_env_t *)p_env;
    c7e6:	6019      	str	r1, [r3, #0]

        // Initialize environment
        memset(p_env, 0, sizeof(m_lay_hb_env_t));
    c7e8:	222c      	movs	r2, #44	; 0x2c
    c7ea:	0001      	movs	r1, r0
    c7ec:	0020      	movs	r0, r4
    c7ee:	f009 f92d 	bl	15a4c <memset>

        // Set heartbeat subscription timer callback
        p_m_lay_hb_env->timer_hbeat_subs.cb = m_lay_hb_cb_timer_subs;
    c7f2:	4b05      	ldr	r3, [pc, #20]	; (c808 <m_lay_hb_init+0x2c>)
    c7f4:	60a3      	str	r3, [r4, #8]
        // Set heartbeat publication timer callback
        p_m_lay_hb_env->timer_hbeat_pub.cb = m_lay_hb_cb_timer_pub;
    c7f6:	4b05      	ldr	r3, [pc, #20]	; (c80c <m_lay_hb_init+0x30>)
    c7f8:	61e3      	str	r3, [r4, #28]
    c7fa:	e001      	b.n	c800 <m_lay_hb_init+0x24>
    }
    else
    {
        p_m_lay_hb_env = NULL;
    c7fc:	2200      	movs	r2, #0
    c7fe:	601a      	str	r2, [r3, #0]
    }

    return (sizeof(m_lay_hb_env_t));
}
    c800:	202c      	movs	r0, #44	; 0x2c
    c802:	bd10      	pop	{r4, pc}
    c804:	100126ac 	.word	0x100126ac
    c808:	0000c6c5 	.word	0x0000c6c5
    c80c:	0000c6e9 	.word	0x0000c6e9

0000c810 <m_lay_hb_get_env_size>:

uint16_t m_lay_hb_get_env_size(void)
{
    return (sizeof(m_lay_hb_env_t));
}
    c810:	202c      	movs	r0, #44	; 0x2c
    c812:	4770      	bx	lr

0000c814 <m_lay_hb_connect_api_utrans>:

void m_lay_hb_connect_api_utrans(const m_lay_utrans_api_t *p_api)
{
    p_m_lay_hb_env->p_utrans_api = p_api;
    c814:	4b01      	ldr	r3, [pc, #4]	; (c81c <m_lay_hb_connect_api_utrans+0x8>)
    c816:	681b      	ldr	r3, [r3, #0]
    c818:	6018      	str	r0, [r3, #0]
}
    c81a:	4770      	bx	lr
    c81c:	100126ac 	.word	0x100126ac

0000c820 <co_bswap32>:
 * @param[in] val32 The 32 bits value to swap.
 * @return The 32 bit swapped value.
 ****************************************************************************************
 */
__INLINE_S__ uint32_t co_bswap32(uint32_t val32)
{
    c820:	ba00      	rev	r0, r0
    return (val32<<24) | ((val32<<8)&0xFF0000) | ((val32>>8)&0xFF00) | ((val32>>24)&0xFF);
}
    c822:	4770      	bx	lr

0000c824 <m_lay_ltrans_seg_finished>:
__STATIC void m_lay_ltrans_seg_finished(m_tb_buf_t *p_buf, uint16_t status, bool on_tx_queue)
{
    // Retrieve buffer environment
    m_lay_buf_env_t *p_buf_env = (m_lay_buf_env_t *)p_buf->env;
    // Retrieve segmentation procedure information structure
    m_lay_ltrans_segment_t *p_seg = &p_m_lay_ltrans_env->segment[p_buf_env->u16.seg_idx];
    c824:	0003      	movs	r3, r0
 * @param[in] status      Status of the transmission
 * @param[in] on_tx_queue Buffer into the TX queue
 ****************************************************************************************
 */
__STATIC void m_lay_ltrans_seg_finished(m_tb_buf_t *p_buf, uint16_t status, bool on_tx_queue)
{
    c826:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    // Retrieve buffer environment
    m_lay_buf_env_t *p_buf_env = (m_lay_buf_env_t *)p_buf->env;
    // Retrieve segmentation procedure information structure
    m_lay_ltrans_segment_t *p_seg = &p_m_lay_ltrans_env->segment[p_buf_env->u16.seg_idx];
    c828:	332e      	adds	r3, #46	; 0x2e
 * @param[in] status      Status of the transmission
 * @param[in] on_tx_queue Buffer into the TX queue
 ****************************************************************************************
 */
__STATIC void m_lay_ltrans_seg_finished(m_tb_buf_t *p_buf, uint16_t status, bool on_tx_queue)
{
    c82a:	9100      	str	r1, [sp, #0]
    c82c:	9201      	str	r2, [sp, #4]
    // Retrieve buffer environment
    m_lay_buf_env_t *p_buf_env = (m_lay_buf_env_t *)p_buf->env;
    // Retrieve segmentation procedure information structure
    m_lay_ltrans_segment_t *p_seg = &p_m_lay_ltrans_env->segment[p_buf_env->u16.seg_idx];
    c82e:	4c0f      	ldr	r4, [pc, #60]	; (c86c <m_lay_ltrans_seg_finished+0x48>)
    c830:	781b      	ldrb	r3, [r3, #0]
    c832:	6826      	ldr	r6, [r4, #0]

    // Stop TX Timer
    m_tb_timer_clear(&(p_seg->timer_tx));
    c834:	015f      	lsls	r7, r3, #5
 * @param[in] status      Status of the transmission
 * @param[in] on_tx_queue Buffer into the TX queue
 ****************************************************************************************
 */
__STATIC void m_lay_ltrans_seg_finished(m_tb_buf_t *p_buf, uint16_t status, bool on_tx_queue)
{
    c836:	0005      	movs	r5, r0
    m_lay_buf_env_t *p_buf_env = (m_lay_buf_env_t *)p_buf->env;
    // Retrieve segmentation procedure information structure
    m_lay_ltrans_segment_t *p_seg = &p_m_lay_ltrans_env->segment[p_buf_env->u16.seg_idx];

    // Stop TX Timer
    m_tb_timer_clear(&(p_seg->timer_tx));
    c838:	19f0      	adds	r0, r6, r7
    c83a:	30b8      	adds	r0, #184	; 0xb8
    c83c:	f008 fdac 	bl	15398 <m_tb_timer_clear>
    // Free segmentation information structure
    p_seg->p_buf = NULL;
    c840:	2300      	movs	r3, #0
    c842:	19f6      	adds	r6, r6, r7
    c844:	36b4      	adds	r6, #180	; 0xb4
    c846:	6033      	str	r3, [r6, #0]

    if (on_tx_queue)
    c848:	9b01      	ldr	r3, [sp, #4]
    c84a:	2b00      	cmp	r3, #0
    c84c:	d004      	beq.n	c858 <m_lay_ltrans_seg_finished+0x34>
    {
        CO_LIST_POP_ELT(p_m_lay_ltrans_env->proc_queue, p_buf);
    c84e:	6820      	ldr	r0, [r4, #0]
    c850:	0029      	movs	r1, r5
    c852:	3010      	adds	r0, #16
    c854:	f7f7 fdd4 	bl	4400 <co_list_extract>
    }

    // Inform upper layers that an error has occurred
    p_m_lay_ltrans_env->p_cb->sent(p_buf, status);
    c858:	6823      	ldr	r3, [r4, #0]
    c85a:	0028      	movs	r0, r5
    c85c:	681b      	ldr	r3, [r3, #0]
    c85e:	9900      	ldr	r1, [sp, #0]
    c860:	681b      	ldr	r3, [r3, #0]
    c862:	4798      	blx	r3

    // remove reference usage of the buffer
    m_tb_buf_release(p_buf);
    c864:	0028      	movs	r0, r5
    c866:	f004 ff19 	bl	1169c <m_tb_buf_release>
}
    c86a:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
    c86c:	100126b0 	.word	0x100126b0

0000c870 <m_lay_ltrans_block_ack_send>:
 * @return status of the execution
 ****************************************************************************************
 */
__STATIC uint16_t m_lay_ltrans_block_ack_send(m_tb_buf_t* p_buf, m_lid_t net_lid, uint16_t src, uint16_t dst,
                                              uint16_t seq_zero, uint32_t block_ack, uint8_t tx_ttl)
{
    c870:	b5f0      	push	{r4, r5, r6, r7, lr}
    c872:	b087      	sub	sp, #28
    c874:	9301      	str	r3, [sp, #4]
    c876:	ab0c      	add	r3, sp, #48	; 0x30
    c878:	881b      	ldrh	r3, [r3, #0]
    c87a:	9200      	str	r2, [sp, #0]
    c87c:	9302      	str	r3, [sp, #8]
    c87e:	ab0e      	add	r3, sp, #56	; 0x38
    c880:	781b      	ldrb	r3, [r3, #0]
    c882:	000f      	movs	r7, r1
    c884:	9303      	str	r3, [sp, #12]

    do
    {
        uint8_t* p_data;
        m_lay_buf_env_t *p_buf_env  = (m_lay_buf_env_t *)p_buf->env;
        uint32_t header = 0;
    c886:	2300      	movs	r3, #0
            break;
        }
        #endif //(BLE_MESH_LPN)

        // Initialize buffer
        status = m_tb_buf_reuse(p_buf, M_LAY_TRANS_BUF_HEADER_LEN,
    c888:	2207      	movs	r2, #7

    do
    {
        uint8_t* p_data;
        m_lay_buf_env_t *p_buf_env  = (m_lay_buf_env_t *)p_buf->env;
        uint32_t header = 0;
    c88a:	9305      	str	r3, [sp, #20]
            break;
        }
        #endif //(BLE_MESH_LPN)

        // Initialize buffer
        status = m_tb_buf_reuse(p_buf, M_LAY_TRANS_BUF_HEADER_LEN,
    c88c:	2109      	movs	r1, #9
    c88e:	3308      	adds	r3, #8
 * @return status of the execution
 ****************************************************************************************
 */
__STATIC uint16_t m_lay_ltrans_block_ack_send(m_tb_buf_t* p_buf, m_lid_t net_lid, uint16_t src, uint16_t dst,
                                              uint16_t seq_zero, uint32_t block_ack, uint8_t tx_ttl)
{
    c890:	0004      	movs	r4, r0
            break;
        }
        #endif //(BLE_MESH_LPN)

        // Initialize buffer
        status = m_tb_buf_reuse(p_buf, M_LAY_TRANS_BUF_HEADER_LEN,
    c892:	f004 ff7f 	bl	11794 <m_tb_buf_reuse>
    c896:	0006      	movs	r6, r0
    c898:	1e05      	subs	r5, r0, #0
                                M_LAY_TRANS_BLOCK_ACK_LEN, M_LAY_TRANS_BUF_TAIL_CTL_LEN);

        if(status != M_ERR_NO_ERROR)
    c89a:	d13d      	bne.n	c918 <m_lay_ltrans_block_ack_send+0xa8>
        {
            break;
        }

        // Get a valid sequence number
        m_tb_key_get_iv_seq(&p_buf_env->seq, &p_buf_env->u5.iv);
    c89c:	0021      	movs	r1, r4
    c89e:	0020      	movs	r0, r4
    c8a0:	3118      	adds	r1, #24
    c8a2:	3014      	adds	r0, #20
    c8a4:	f006 f9cc 	bl	12c40 <m_tb_key_get_iv_seq>

        // Set Network local identifier
        p_buf_env->net_lid   = net_lid;
        // Change the application and model LID
        p_buf_env->app_lid   = M_INVALID_LID;
    c8a8:	23ff      	movs	r3, #255	; 0xff
        p_buf_env->model_lid = M_INVALID_LID;
        p_buf_env->ttl_ctl = tx_ttl;
        p_buf_env->flags = 0;

        // Mark that control message must be transmitted
        SETB(p_buf_env->ttl_ctl, M_MSG_CTL, 1);
    c8aa:	9a03      	ldr	r2, [sp, #12]
        m_tb_key_get_iv_seq(&p_buf_env->seq, &p_buf_env->u5.iv);

        // Set Network local identifier
        p_buf_env->net_lid   = net_lid;
        // Change the application and model LID
        p_buf_env->app_lid   = M_INVALID_LID;
    c8ac:	74a3      	strb	r3, [r4, #18]
        p_buf_env->model_lid = M_INVALID_LID;
    c8ae:	74e3      	strb	r3, [r4, #19]
        p_buf_env->ttl_ctl = tx_ttl;
        p_buf_env->flags = 0;

        // Mark that control message must be transmitted
        SETB(p_buf_env->ttl_ctl, M_MSG_CTL, 1);
    c8b0:	3b80      	subs	r3, #128	; 0x80
    c8b2:	3bff      	subs	r3, #255	; 0xff
    c8b4:	4313      	orrs	r3, r2
    c8b6:	1c62      	adds	r2, r4, #1
        p_buf_env->net_lid   = net_lid;
        // Change the application and model LID
        p_buf_env->app_lid   = M_INVALID_LID;
        p_buf_env->model_lid = M_INVALID_LID;
        p_buf_env->ttl_ctl = tx_ttl;
        p_buf_env->flags = 0;
    c8b8:	7426      	strb	r6, [r4, #16]

        // Get a valid sequence number
        m_tb_key_get_iv_seq(&p_buf_env->seq, &p_buf_env->u5.iv);

        // Set Network local identifier
        p_buf_env->net_lid   = net_lid;
    c8ba:	7467      	strb	r7, [r4, #17]
        p_buf_env->model_lid = M_INVALID_LID;
        p_buf_env->ttl_ctl = tx_ttl;
        p_buf_env->flags = 0;

        // Mark that control message must be transmitted
        SETB(p_buf_env->ttl_ctl, M_MSG_CTL, 1);
    c8bc:	77d3      	strb	r3, [r2, #31]

        // Fill destination and source addresses
        p_buf_env->dst = dst;
    c8be:	466b      	mov	r3, sp
    c8c0:	889b      	ldrh	r3, [r3, #4]

        // Prepare Header
        SETB(header, M_HEAD_SEG, false);
        SETF(header, M_HEAD_OPCODE, M_OPCODE_BLOCK_ACK);
        SETB(header, M_HEAD_OBO, obo);
        SETF(header, M_HEAD_SEQ_ZERO, seq_zero);
    c8c2:	4e17      	ldr	r6, [pc, #92]	; (c920 <m_lay_ltrans_block_ack_send+0xb0>)

        // Mark that control message must be transmitted
        SETB(p_buf_env->ttl_ctl, M_MSG_CTL, 1);

        // Fill destination and source addresses
        p_buf_env->dst = dst;
    c8c4:	83e3      	strh	r3, [r4, #30]
            p_buf_env->src = m_tb_mio_get_prim_addr();
        }
        else
        #endif //(BLE_MESH_FRIEND)
        {
            p_buf_env->src = src;
    c8c6:	466b      	mov	r3, sp
    c8c8:	881b      	ldrh	r3, [r3, #0]
    c8ca:	83a3      	strh	r3, [r4, #28]

        // Prepare Header
        SETB(header, M_HEAD_SEG, false);
        SETF(header, M_HEAD_OPCODE, M_OPCODE_BLOCK_ACK);
        SETB(header, M_HEAD_OBO, obo);
        SETF(header, M_HEAD_SEQ_ZERO, seq_zero);
    c8cc:	9b02      	ldr	r3, [sp, #8]
    c8ce:	0298      	lsls	r0, r3, #10
    c8d0:	4006      	ands	r6, r0
    c8d2:	2e00      	cmp	r6, #0
    c8d4:	d1fd      	bne.n	c8d2 <m_lay_ltrans_block_ack_send+0x62>

        // Fill Block ACK Buffer
        p_data = M_TB_BUF_DATA(p_buf);
    c8d6:	0023      	movs	r3, r4
    c8d8:	88a5      	ldrh	r5, [r4, #4]
    c8da:	3330      	adds	r3, #48	; 0x30
    c8dc:	195d      	adds	r5, r3, r5
__INLINE_S__ uint32_t co_htonl(uint32_t hostlong)
{
    #if (!CPU_LE)
        return hostlong;
    #else
        return co_bswap32(hostlong);
    c8de:	f7ff ff9f 	bl	c820 <co_bswap32>

        // Put header in network format
        header = co_htonl(header);
        memcpy(p_data, &header, M_LAY_TRANS_BLOCK_HEADER_LEN);
    c8e2:	2203      	movs	r2, #3
    c8e4:	a905      	add	r1, sp, #20

        // Fill Block ACK Buffer
        p_data = M_TB_BUF_DATA(p_buf);

        // Put header in network format
        header = co_htonl(header);
    c8e6:	9005      	str	r0, [sp, #20]
        memcpy(p_data, &header, M_LAY_TRANS_BLOCK_HEADER_LEN);
    c8e8:	0028      	movs	r0, r5
    c8ea:	f009 f871 	bl	159d0 <memcpy>
    c8ee:	980d      	ldr	r0, [sp, #52]	; 0x34
    c8f0:	f7ff ff96 	bl	c820 <co_bswap32>
        p_data += M_LAY_TRANS_BLOCK_HEADER_LEN;
        // Block ACK - value
        block_ack = co_htonl(block_ack);
        memcpy(p_data, &block_ack, 4);
    c8f4:	2204      	movs	r2, #4
        // Put header in network format
        header = co_htonl(header);
        memcpy(p_data, &header, M_LAY_TRANS_BLOCK_HEADER_LEN);
        p_data += M_LAY_TRANS_BLOCK_HEADER_LEN;
        // Block ACK - value
        block_ack = co_htonl(block_ack);
    c8f6:	900d      	str	r0, [sp, #52]	; 0x34
        memcpy(p_data, &block_ack, 4);
    c8f8:	a90d      	add	r1, sp, #52	; 0x34
    c8fa:	1ce8      	adds	r0, r5, #3
    c8fc:	f009 f868 	bl	159d0 <memcpy>

        // Send packet to network layer
        status = p_m_lay_ltrans_env->p_net_api->send(p_buf, M_LAY_NET_INTF_TYPE_LTRANS);
    c900:	4b08      	ldr	r3, [pc, #32]	; (c924 <m_lay_ltrans_block_ack_send+0xb4>)
    c902:	0031      	movs	r1, r6
    c904:	681b      	ldr	r3, [r3, #0]
    c906:	0020      	movs	r0, r4
    c908:	685b      	ldr	r3, [r3, #4]
    c90a:	681b      	ldr	r3, [r3, #0]
    c90c:	4798      	blx	r3
    c90e:	1e05      	subs	r5, r0, #0
        if(status != M_ERR_NO_ERROR)
    c910:	d102      	bne.n	c918 <m_lay_ltrans_block_ack_send+0xa8>
        {
            break;
        }

        // Increment buffer acquisition
        m_tb_buf_acquire(p_buf);
    c912:	0020      	movs	r0, r4
    c914:	f004 febe 	bl	11694 <m_tb_buf_acquire>

    } while(0);

    return (status);
}
    c918:	0028      	movs	r0, r5
    c91a:	b007      	add	sp, #28
    c91c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    c91e:	46c0      	nop			; (mov r8, r8)
    c920:	ff8003ff 	.word	0xff8003ff
    c924:	100126b0 	.word	0x100126b0

0000c928 <m_lay_ltrans_tx_handler>:
 ****************************************************************************************
 * @brief Handle execution of TX procedure
 ****************************************************************************************
 */
__STATIC void m_lay_ltrans_tx_handler(void)
{
    c928:	b5f0      	push	{r4, r5, r6, r7, lr}
    c92a:	b08f      	sub	sp, #60	; 0x3c
    // Check that something can be transmitted
    while (!co_list_is_empty(&p_m_lay_ltrans_env->tx_buf_avail)
    c92c:	4c9b      	ldr	r4, [pc, #620]	; (cb9c <m_lay_ltrans_tx_handler+0x274>)
    c92e:	6823      	ldr	r3, [r4, #0]
    c930:	689d      	ldr	r5, [r3, #8]
    c932:	9305      	str	r3, [sp, #20]
    c934:	2d00      	cmp	r5, #0
    c936:	d100      	bne.n	c93a <m_lay_ltrans_tx_handler+0x12>
    c938:	e12e      	b.n	cb98 <m_lay_ltrans_tx_handler+0x270>
    c93a:	691e      	ldr	r6, [r3, #16]
                && !co_list_is_empty(&p_m_lay_ltrans_env->proc_queue))
    c93c:	2e00      	cmp	r6, #0
    c93e:	d100      	bne.n	c942 <m_lay_ltrans_tx_handler+0x1a>
    c940:	e12a      	b.n	cb98 <m_lay_ltrans_tx_handler+0x270>
        m_lay_buf_env_t *p_buf_env = (m_lay_buf_env_t *)p_buf->env;
        // Transmission status
        uint16_t status;

        // Reassemble packets
        if (GETB(p_buf_env->flags, M_LAY_BUF_RX))
    c942:	2201      	movs	r2, #1
    c944:	7c33      	ldrb	r3, [r6, #16]
    c946:	4213      	tst	r3, r2
    c948:	d028      	beq.n	c99c <m_lay_ltrans_tx_handler+0x74>
        {
            // TTL
            uint8_t tx_ttl = M_TTL_DEFAULT;
            // Get reassembly structure
            m_lay_ltrans_reassembly_t *p_reas = &p_m_lay_ltrans_env->reassembly[p_buf_env->u15.reas_idx];
    c94a:	0033      	movs	r3, r6

            // Send a Block ACK message
            p_tx_buf = (m_tb_buf_t *)co_list_pick(&(p_m_lay_ltrans_env->tx_buf_avail));

            status = m_lay_ltrans_block_ack_send(p_tx_buf, p_buf_env->net_lid, p_buf_env->dst,
    c94c:	270b      	movs	r7, #11
        if (GETB(p_buf_env->flags, M_LAY_BUF_RX))
        {
            // TTL
            uint8_t tx_ttl = M_TTL_DEFAULT;
            // Get reassembly structure
            m_lay_ltrans_reassembly_t *p_reas = &p_m_lay_ltrans_env->reassembly[p_buf_env->u15.reas_idx];
    c94e:	332d      	adds	r3, #45	; 0x2d
    c950:	7818      	ldrb	r0, [r3, #0]

            // Send a Block ACK message
            p_tx_buf = (m_tb_buf_t *)co_list_pick(&(p_m_lay_ltrans_env->tx_buf_avail));

            status = m_lay_ltrans_block_ack_send(p_tx_buf, p_buf_env->net_lid, p_buf_env->dst,
    c952:	8bf2      	ldrh	r2, [r6, #30]
    c954:	8bb3      	ldrh	r3, [r6, #28]
    c956:	7c71      	ldrb	r1, [r6, #17]
    c958:	9702      	str	r7, [sp, #8]
    c95a:	3729      	adds	r7, #41	; 0x29
    c95c:	4347      	muls	r7, r0
    c95e:	9805      	ldr	r0, [sp, #20]
    c960:	19c0      	adds	r0, r0, r7
    c962:	6c40      	ldr	r0, [r0, #68]	; 0x44
    c964:	9001      	str	r0, [sp, #4]
    c966:	6970      	ldr	r0, [r6, #20]
    c968:	04c0      	lsls	r0, r0, #19
    c96a:	0cc0      	lsrs	r0, r0, #19
    c96c:	9000      	str	r0, [sp, #0]
    c96e:	0028      	movs	r0, r5
    c970:	f7ff ff7e 	bl	c870 <m_lay_ltrans_block_ack_send>
                                                 p_buf_env->src, (p_buf_env->seq & M_LTRANS_SEQ_ZERO_MASK),
                                                 p_reas->block_ack, tx_ttl);

            if (status == M_ERR_NO_ERROR)
    c974:	2800      	cmp	r0, #0
    c976:	d10b      	bne.n	c990 <m_lay_ltrans_tx_handler+0x68>
            {
                // Restart acknowledgment timer
                m_tb_timer_set(&p_reas->timer_ack, M_LAY_LTRANS_TIMER_COMPUTE(ACK, tx_ttl));
    c978:	0038      	movs	r0, r7
    c97a:	21af      	movs	r1, #175	; 0xaf
    c97c:	9b05      	ldr	r3, [sp, #20]
    c97e:	3030      	adds	r0, #48	; 0x30
    c980:	1818      	adds	r0, r3, r0
    c982:	0089      	lsls	r1, r1, #2
    c984:	f008 fcbe 	bl	15304 <m_tb_timer_set>

                // Pop TX buffer
                co_list_pop_front(&p_m_lay_ltrans_env->tx_buf_avail);
    c988:	6820      	ldr	r0, [r4, #0]
    c98a:	3008      	adds	r0, #8
    c98c:	f7f7 fd2e 	bl	43ec <co_list_pop_front>
            }

            // Pop reference buffer
            co_list_pop_front(&p_m_lay_ltrans_env->proc_queue);
    c990:	4b82      	ldr	r3, [pc, #520]	; (cb9c <m_lay_ltrans_tx_handler+0x274>)
    c992:	6818      	ldr	r0, [r3, #0]
    c994:	3010      	adds	r0, #16
    c996:	f7f7 fd29 	bl	43ec <co_list_pop_front>
    c99a:	e7c7      	b.n	c92c <m_lay_ltrans_tx_handler+0x4>
    {
        // Point to reference buffer environment
        m_lay_buf_env_t *p_env = (m_lay_buf_env_t *)&p_ref_buf->env[0];
        m_lay_buf_env_t *p_seg_env;
        // Get segmentation information structure
        m_lay_ltrans_segment_t *p_seg = &p_m_lay_ltrans_env->segment[p_env->u16.seg_idx];
    c99c:	0033      	movs	r3, r6
    c99e:	332e      	adds	r3, #46	; 0x2e
    c9a0:	781f      	ldrb	r7, [r3, #0]
        uint8_t* p_tx_data;
        uint8_t* p_src_data = M_TB_BUF_DATA(p_ref_buf);
    c9a2:	88b3      	ldrh	r3, [r6, #4]
    c9a4:	930b      	str	r3, [sp, #44]	; 0x2c
        uint8_t seg_len = GETB(p_env->ttl_ctl, M_MSG_CTL)
    c9a6:	1c73      	adds	r3, r6, #1
                        ? M_LAY_TRANS_CTL_SEG_SIZE : M_LAY_TRANS_ACCESS_SEG_SIZE;
    c9a8:	7fdb      	ldrb	r3, [r3, #31]
    c9aa:	b25b      	sxtb	r3, r3
    c9ac:	9307      	str	r3, [sp, #28]
        m_lay_buf_env_t *p_seg_env;
        // Get segmentation information structure
        m_lay_ltrans_segment_t *p_seg = &p_m_lay_ltrans_env->segment[p_env->u16.seg_idx];
        uint8_t* p_tx_data;
        uint8_t* p_src_data = M_TB_BUF_DATA(p_ref_buf);
        uint8_t seg_len = GETB(p_env->ttl_ctl, M_MSG_CTL)
    c9ae:	2308      	movs	r3, #8
    c9b0:	9306      	str	r3, [sp, #24]
    c9b2:	9b07      	ldr	r3, [sp, #28]
    c9b4:	2b00      	cmp	r3, #0
    c9b6:	db01      	blt.n	c9bc <m_lay_ltrans_tx_handler+0x94>
    c9b8:	230c      	movs	r3, #12
    c9ba:	9306      	str	r3, [sp, #24]
                        ? M_LAY_TRANS_CTL_SEG_SIZE : M_LAY_TRANS_ACCESS_SEG_SIZE;
        uint8_t seg_off = co_ctz(M_LAY_LTRANS_BLOCK_REMAIN_MASK(p_seg));
    c9bc:	9a05      	ldr	r2, [sp, #20]
    c9be:	017b      	lsls	r3, r7, #5
    c9c0:	18d3      	adds	r3, r2, r3
    c9c2:	001a      	movs	r2, r3
 ****************************************************************************************
 */
__INLINE_S__ uint32_t co_ctz(uint32_t val)
{
    #if defined(__arm__)
    return __builtin_ctz(val);
    c9c4:	2001      	movs	r0, #1
    c9c6:	32d0      	adds	r2, #208	; 0xd0
    c9c8:	7814      	ldrb	r4, [r2, #0]
    c9ca:	3a04      	subs	r2, #4
    c9cc:	40a0      	lsls	r0, r4
    c9ce:	6812      	ldr	r2, [r2, #0]
    c9d0:	3801      	subs	r0, #1
    c9d2:	4050      	eors	r0, r2
    c9d4:	2201      	movs	r2, #1
    c9d6:	33d3      	adds	r3, #211	; 0xd3
    c9d8:	781b      	ldrb	r3, [r3, #0]
    c9da:	4252      	negs	r2, r2
    c9dc:	409a      	lsls	r2, r3
    c9de:	4010      	ands	r0, r2
    c9e0:	f011 fa34 	bl	1de4c <__ctzsi2>
        uint16_t data_offset = (seg_off * seg_len);
    c9e4:	0001      	movs	r1, r0
    c9e6:	9b06      	ldr	r3, [sp, #24]
        uint16_t seq_zero = (p_env->seq & M_LTRANS_SEQ_ZERO_MASK);
        uint32_t header = 0;

        // Check if last segment must be transmitted
        if (seg_off == (p_seg->nb_seg - 1))
    c9e8:	3c01      	subs	r4, #1
        uint8_t* p_tx_data;
        uint8_t* p_src_data = M_TB_BUF_DATA(p_ref_buf);
        uint8_t seg_len = GETB(p_env->ttl_ctl, M_MSG_CTL)
                        ? M_LAY_TRANS_CTL_SEG_SIZE : M_LAY_TRANS_ACCESS_SEG_SIZE;
        uint8_t seg_off = co_ctz(M_LAY_LTRANS_BLOCK_REMAIN_MASK(p_seg));
        uint16_t data_offset = (seg_off * seg_len);
    c9ea:	4359      	muls	r1, r3
    c9ec:	b28b      	uxth	r3, r1
    c9ee:	930a      	str	r3, [sp, #40]	; 0x28
        uint16_t seq_zero = (p_env->seq & M_LTRANS_SEQ_ZERO_MASK);
    c9f0:	6973      	ldr	r3, [r6, #20]
    c9f2:	9008      	str	r0, [sp, #32]
    c9f4:	9309      	str	r3, [sp, #36]	; 0x24
        uint32_t header = 0;
    c9f6:	2300      	movs	r3, #0
    c9f8:	930d      	str	r3, [sp, #52]	; 0x34

        // Check if last segment must be transmitted
        if (seg_off == (p_seg->nb_seg - 1))
    c9fa:	42a0      	cmp	r0, r4
    c9fc:	d104      	bne.n	ca08 <m_lay_ltrans_tx_handler+0xe0>
        {
            // Last segment is shorter than others
            seg_len = p_ref_buf->data_len - data_offset;
    c9fe:	8933      	ldrh	r3, [r6, #8]
    ca00:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    ca02:	1a9b      	subs	r3, r3, r2
    ca04:	b2db      	uxtb	r3, r3
    ca06:	9306      	str	r3, [sp, #24]

        // Load segment buffer
        p_tx_buf = (m_tb_buf_t*) co_list_pick(&(p_m_lay_ltrans_env->tx_buf_avail));

        // Initialize buffer
        status = m_tb_buf_reuse(p_tx_buf, M_LAY_TRANS_BUF_HEADER_LEN, seg_len + M_LAY_TRANS_SEG_HEADER_LEN,
    ca08:	9b06      	ldr	r3, [sp, #24]
    ca0a:	9907      	ldr	r1, [sp, #28]
    ca0c:	1d1a      	adds	r2, r3, #4
    ca0e:	2308      	movs	r3, #8
    ca10:	2900      	cmp	r1, #0
    ca12:	db00      	blt.n	ca16 <m_lay_ltrans_tx_handler+0xee>
    ca14:	3b04      	subs	r3, #4
    ca16:	2109      	movs	r1, #9
    ca18:	0028      	movs	r0, r5
    ca1a:	f004 febb 	bl	11794 <m_tb_buf_reuse>
    ca1e:	9007      	str	r0, [sp, #28]
                                GETB(p_env->ttl_ctl, M_MSG_CTL) ? M_LAY_TRANS_BUF_TAIL_CTL_LEN
                                                                : M_LAY_TRANS_BUF_TAIL_ACCESS_LEN);

        if (status != M_ERR_NO_ERROR)
    ca20:	2800      	cmp	r0, #0
    ca22:	d000      	beq.n	ca26 <m_lay_ltrans_tx_handler+0xfe>
    ca24:	e0ad      	b.n	cb82 <m_lay_ltrans_tx_handler+0x25a>

        // Point to TX buffer environment
        p_seg_env = (m_lay_buf_env_t *)p_tx_buf->env;

        // Copy information of base buffer
        memcpy(p_seg_env, p_env, sizeof(m_lay_buf_env_t));
    ca26:	0031      	movs	r1, r6
    ca28:	0028      	movs	r0, r5
    ca2a:	2220      	movs	r2, #32
    ca2c:	3110      	adds	r1, #16
    ca2e:	3010      	adds	r0, #16
    ca30:	f008 ffce 	bl	159d0 <memcpy>

        // Get a valid sequence number and associated IV
        m_tb_key_get_iv_seq(&p_seg_env->seq, &p_seg_env->u5.iv);
    ca34:	0029      	movs	r1, r5
    ca36:	0028      	movs	r0, r5
    ca38:	3118      	adds	r1, #24
    ca3a:	3014      	adds	r0, #20
    ca3c:	f006 f900 	bl	12c40 <m_tb_key_get_iv_seq>

        // Check that we didn't wrap the sequence number
        if ((p_seg_env->seq - p_env->seq) > M_LTRANS_SEQ_ZERO_MASK)
    ca40:	6972      	ldr	r2, [r6, #20]
    ca42:	696b      	ldr	r3, [r5, #20]
    ca44:	1a9b      	subs	r3, r3, r2
    ca46:	4a56      	ldr	r2, [pc, #344]	; (cba0 <m_lay_ltrans_tx_handler+0x278>)
    ca48:	4293      	cmp	r3, r2
    ca4a:	d875      	bhi.n	cb38 <m_lay_ltrans_tx_handler+0x210>
            status = M_ERR_SEQ_ERROR;
            break;
        }

        // Retrieve data pointer
        p_tx_data = M_TB_BUF_DATA(p_tx_buf);
    ca4c:	002b      	movs	r3, r5
    ca4e:	88ac      	ldrh	r4, [r5, #4]
    ca50:	3330      	adds	r3, #48	; 0x30
    ca52:	191c      	adds	r4, r3, r4

        // Prepare Header
        SETB(header, M_HEAD_SEG, true);
        SETF(header, M_HEAD_OPCODE, p_env->u14.opcode_aid_afk);
    ca54:	0033      	movs	r3, r6
    ca56:	332c      	adds	r3, #44	; 0x2c
    ca58:	7818      	ldrb	r0, [r3, #0]
    ca5a:	4b52      	ldr	r3, [pc, #328]	; (cba4 <m_lay_ltrans_tx_handler+0x27c>)
    ca5c:	0600      	lsls	r0, r0, #24
    ca5e:	4003      	ands	r3, r0
    ca60:	2b00      	cmp	r3, #0
    ca62:	d1fd      	bne.n	ca60 <m_lay_ltrans_tx_handler+0x138>
        SETB(header, M_HEAD_SZMIC, GETB(p_env->flags, M_LAY_BUF_SIZE_MIC));
        SETF(header, M_HEAD_SEQ_ZERO, seq_zero);
        SETF(header, M_HEAD_SEG_O, seg_off);
    ca64:	2180      	movs	r1, #128	; 0x80
    ca66:	7c33      	ldrb	r3, [r6, #16]
    ca68:	0409      	lsls	r1, r1, #16
    ca6a:	059b      	lsls	r3, r3, #22
    ca6c:	400b      	ands	r3, r1
    ca6e:	001a      	movs	r2, r3
    ca70:	2380      	movs	r3, #128	; 0x80
    ca72:	061b      	lsls	r3, r3, #24
    ca74:	4313      	orrs	r3, r2
    ca76:	9a09      	ldr	r2, [sp, #36]	; 0x24
    ca78:	4303      	orrs	r3, r0
    ca7a:	04d2      	lsls	r2, r2, #19
    ca7c:	0a52      	lsrs	r2, r2, #9
    ca7e:	4313      	orrs	r3, r2
    ca80:	9a08      	ldr	r2, [sp, #32]
        SETF(header, M_HEAD_SEG_N, p_seg->nb_seg - 1);
    ca82:	017f      	lsls	r7, r7, #5
        // Prepare Header
        SETB(header, M_HEAD_SEG, true);
        SETF(header, M_HEAD_OPCODE, p_env->u14.opcode_aid_afk);
        SETB(header, M_HEAD_SZMIC, GETB(p_env->flags, M_LAY_BUF_SIZE_MIC));
        SETF(header, M_HEAD_SEQ_ZERO, seq_zero);
        SETF(header, M_HEAD_SEG_O, seg_off);
    ca84:	0150      	lsls	r0, r2, #5
    ca86:	22ff      	movs	r2, #255	; 0xff
    ca88:	0152      	lsls	r2, r2, #5
    ca8a:	4010      	ands	r0, r2
    ca8c:	4318      	orrs	r0, r3
        SETF(header, M_HEAD_SEG_N, p_seg->nb_seg - 1);
    ca8e:	9b05      	ldr	r3, [sp, #20]
    ca90:	19db      	adds	r3, r3, r7
    ca92:	33d0      	adds	r3, #208	; 0xd0
    ca94:	7819      	ldrb	r1, [r3, #0]
    ca96:	231f      	movs	r3, #31
    ca98:	1e4a      	subs	r2, r1, #1
    ca9a:	0011      	movs	r1, r2
    ca9c:	4399      	bics	r1, r3
    ca9e:	9109      	str	r1, [sp, #36]	; 0x24
    caa0:	9b09      	ldr	r3, [sp, #36]	; 0x24
    caa2:	2b00      	cmp	r3, #0
    caa4:	d1fc      	bne.n	caa0 <m_lay_ltrans_tx_handler+0x178>
    caa6:	4310      	orrs	r0, r2
    caa8:	f7ff feba 	bl	c820 <co_bswap32>

        // Put header in network format
        header = co_htonl(header);
        memcpy(p_tx_data, &header, M_LAY_TRANS_SEG_HEADER_LEN);
    caac:	2204      	movs	r2, #4
        SETF(header, M_HEAD_SEQ_ZERO, seq_zero);
        SETF(header, M_HEAD_SEG_O, seg_off);
        SETF(header, M_HEAD_SEG_N, p_seg->nb_seg - 1);

        // Put header in network format
        header = co_htonl(header);
    caae:	900d      	str	r0, [sp, #52]	; 0x34
        memcpy(p_tx_data, &header, M_LAY_TRANS_SEG_HEADER_LEN);
    cab0:	a90d      	add	r1, sp, #52	; 0x34
    cab2:	0020      	movs	r0, r4
    cab4:	f008 ff8c 	bl	159d0 <memcpy>
        p_tx_data += M_LAY_TRANS_SEG_HEADER_LEN;

        // Copy segment data
        memcpy(p_tx_data, &(p_src_data[data_offset]), seg_len);
    cab8:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    caba:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    cabc:	4694      	mov	ip, r2
    cabe:	4463      	add	r3, ip
    cac0:	0019      	movs	r1, r3
    cac2:	0033      	movs	r3, r6
    cac4:	3330      	adds	r3, #48	; 0x30
    cac6:	1859      	adds	r1, r3, r1
    cac8:	1d20      	adds	r0, r4, #4
    caca:	9a06      	ldr	r2, [sp, #24]
    cacc:	f008 ff80 	bl	159d0 <memcpy>

        // Send packet to network layer
        status = p_m_lay_ltrans_env->p_net_api->send(p_tx_buf, M_LAY_NET_INTF_TYPE_LTRANS);
    cad0:	4c32      	ldr	r4, [pc, #200]	; (cb9c <m_lay_ltrans_tx_handler+0x274>)
    cad2:	9909      	ldr	r1, [sp, #36]	; 0x24
    cad4:	6823      	ldr	r3, [r4, #0]
    cad6:	0028      	movs	r0, r5
    cad8:	685b      	ldr	r3, [r3, #4]
    cada:	681b      	ldr	r3, [r3, #0]
    cadc:	4798      	blx	r3
    cade:	9007      	str	r0, [sp, #28]

        if (status != M_ERR_NO_ERROR)
    cae0:	2800      	cmp	r0, #0
    cae2:	d14e      	bne.n	cb82 <m_lay_ltrans_tx_handler+0x25a>
        {
            break;
        }

        // Acquire transmission buffer
        m_tb_buf_acquire(p_tx_buf);
    cae4:	0028      	movs	r0, r5
    cae6:	f004 fdd5 	bl	11694 <m_tb_buf_acquire>

        // Mark buffer sent
        p_seg->tx_cursor = seg_off + 1;
    caea:	9b05      	ldr	r3, [sp, #20]
            // Send Segment
            status = m_lay_ltrans_send_seg(p_buf, p_tx_buf);

            if (status == M_ERR_NO_ERROR)
            {
                m_lay_ltrans_segment_t *p_seg = &p_m_lay_ltrans_env->segment[p_buf_env->u16.seg_idx];
    caec:	6825      	ldr	r5, [r4, #0]

        // Acquire transmission buffer
        m_tb_buf_acquire(p_tx_buf);

        // Mark buffer sent
        p_seg->tx_cursor = seg_off + 1;
    caee:	19df      	adds	r7, r3, r7
    caf0:	9b08      	ldr	r3, [sp, #32]
    caf2:	37d3      	adds	r7, #211	; 0xd3
    caf4:	3301      	adds	r3, #1
    caf6:	703b      	strb	r3, [r7, #0]
            // Send Segment
            status = m_lay_ltrans_send_seg(p_buf, p_tx_buf);

            if (status == M_ERR_NO_ERROR)
            {
                m_lay_ltrans_segment_t *p_seg = &p_m_lay_ltrans_env->segment[p_buf_env->u16.seg_idx];
    caf8:	0033      	movs	r3, r6

                // Pop TX Buffer
                co_list_pop_front(&(p_m_lay_ltrans_env->tx_buf_avail));
    cafa:	0028      	movs	r0, r5
            // Send Segment
            status = m_lay_ltrans_send_seg(p_buf, p_tx_buf);

            if (status == M_ERR_NO_ERROR)
            {
                m_lay_ltrans_segment_t *p_seg = &p_m_lay_ltrans_env->segment[p_buf_env->u16.seg_idx];
    cafc:	332e      	adds	r3, #46	; 0x2e
    cafe:	781f      	ldrb	r7, [r3, #0]

                // Pop TX Buffer
                co_list_pop_front(&(p_m_lay_ltrans_env->tx_buf_avail));
    cb00:	3008      	adds	r0, #8

                // All segment waiting to be transmitted are sent
                if(M_LAY_LTRANS_BLOCK_REMAIN_MASK(p_seg) == 0)
    cb02:	017f      	lsls	r7, r7, #5
            if (status == M_ERR_NO_ERROR)
            {
                m_lay_ltrans_segment_t *p_seg = &p_m_lay_ltrans_env->segment[p_buf_env->u16.seg_idx];

                // Pop TX Buffer
                co_list_pop_front(&(p_m_lay_ltrans_env->tx_buf_avail));
    cb04:	f7f7 fc72 	bl	43ec <co_list_pop_front>

                // All segment waiting to be transmitted are sent
                if(M_LAY_LTRANS_BLOCK_REMAIN_MASK(p_seg) == 0)
    cb08:	19eb      	adds	r3, r5, r7
    cb0a:	001a      	movs	r2, r3
    cb0c:	2101      	movs	r1, #1
    cb0e:	32d0      	adds	r2, #208	; 0xd0
    cb10:	7812      	ldrb	r2, [r2, #0]
    cb12:	4091      	lsls	r1, r2
    cb14:	000a      	movs	r2, r1
    cb16:	0019      	movs	r1, r3
    cb18:	31cc      	adds	r1, #204	; 0xcc
    cb1a:	6809      	ldr	r1, [r1, #0]
    cb1c:	3a01      	subs	r2, #1
    cb1e:	404a      	eors	r2, r1
    cb20:	0019      	movs	r1, r3
    cb22:	4694      	mov	ip, r2
    cb24:	2201      	movs	r2, #1
    cb26:	31d3      	adds	r1, #211	; 0xd3
    cb28:	7808      	ldrb	r0, [r1, #0]
    cb2a:	4252      	negs	r2, r2
    cb2c:	4082      	lsls	r2, r0
    cb2e:	0010      	movs	r0, r2
    cb30:	4662      	mov	r2, ip
    cb32:	4210      	tst	r0, r2
    cb34:	d003      	beq.n	cb3e <m_lay_ltrans_tx_handler+0x216>
    cb36:	e6f9      	b.n	c92c <m_lay_ltrans_tx_handler+0x4>
        m_tb_key_get_iv_seq(&p_seg_env->seq, &p_seg_env->u5.iv);

        // Check that we didn't wrap the sequence number
        if ((p_seg_env->seq - p_env->seq) > M_LTRANS_SEQ_ZERO_MASK)
        {
            status = M_ERR_SEQ_ERROR;
    cb38:	4b1b      	ldr	r3, [pc, #108]	; (cba8 <m_lay_ltrans_tx_handler+0x280>)
    cb3a:	9307      	str	r3, [sp, #28]
    cb3c:	e021      	b.n	cb82 <m_lay_ltrans_tx_handler+0x25a>

                // All segment waiting to be transmitted are sent
                if(M_LAY_LTRANS_BLOCK_REMAIN_MASK(p_seg) == 0)
                {
                    // Increment number of packet transmission performed
                    p_seg->nb_done++;
    cb3e:	33d1      	adds	r3, #209	; 0xd1
    cb40:	781a      	ldrb	r2, [r3, #0]
    cb42:	3201      	adds	r2, #1
    cb44:	b2d2      	uxtb	r2, r2
    cb46:	701a      	strb	r2, [r3, #0]

                    // if a group or virtual address is targetted
                    if (!M_IS_UNICAST_ADDR(p_buf_env->dst))
    cb48:	201e      	movs	r0, #30
    cb4a:	5e33      	ldrsh	r3, [r6, r0]
    cb4c:	2b00      	cmp	r3, #0
    cb4e:	da07      	bge.n	cb60 <m_lay_ltrans_tx_handler+0x238>
                    {
                        // Check if all transmission ar performed
                        if(p_seg->nb_done < M_LAY_LTRANS_NB_SEG_PACKET_RETRANS)
    cb50:	2a02      	cmp	r2, #2
    cb52:	d816      	bhi.n	cb82 <m_lay_ltrans_tx_handler+0x25a>
                        {
                            // restart transmission of all segments
                            p_seg->tx_cursor = 0;
    cb54:	466b      	mov	r3, sp
    cb56:	2224      	movs	r2, #36	; 0x24
    cb58:	189b      	adds	r3, r3, r2
    cb5a:	781b      	ldrb	r3, [r3, #0]
    cb5c:	700b      	strb	r3, [r1, #0]
    cb5e:	e6e5      	b.n	c92c <m_lay_ltrans_tx_handler+0x4>
                        }
                    }
                    else
                    {
                        // pop reference buffer
                        co_list_pop_front(&(p_m_lay_ltrans_env->proc_queue));
    cb60:	6820      	ldr	r0, [r4, #0]

                        // Restart segment TX timer
                        m_tb_timer_set(&(p_seg->timer_tx),
    cb62:	19ef      	adds	r7, r5, r7
                        }
                    }
                    else
                    {
                        // pop reference buffer
                        co_list_pop_front(&(p_m_lay_ltrans_env->proc_queue));
    cb64:	3010      	adds	r0, #16
    cb66:	f7f7 fc41 	bl	43ec <co_list_pop_front>

                        // Restart segment TX timer
                        m_tb_timer_set(&(p_seg->timer_tx),
                                       M_LAY_LTRANS_TIMER_COMPUTE(SEG_TX,
    cb6a:	1c73      	adds	r3, r6, #1
                    {
                        // pop reference buffer
                        co_list_pop_front(&(p_m_lay_ltrans_env->proc_queue));

                        // Restart segment TX timer
                        m_tb_timer_set(&(p_seg->timer_tx),
    cb6c:	7fd9      	ldrb	r1, [r3, #31]
    cb6e:	237f      	movs	r3, #127	; 0x7f
    cb70:	0038      	movs	r0, r7
    cb72:	4019      	ands	r1, r3
    cb74:	3b4d      	subs	r3, #77	; 0x4d
    cb76:	4359      	muls	r1, r3
    cb78:	30b8      	adds	r0, #184	; 0xb8
    cb7a:	31c8      	adds	r1, #200	; 0xc8
    cb7c:	f008 fbc2 	bl	15304 <m_tb_timer_set>
    cb80:	e6d4      	b.n	c92c <m_lay_ltrans_tx_handler+0x4>
            }

            if(finished)
            {
                // pop reference buffer
                co_list_pop_front(&(p_m_lay_ltrans_env->proc_queue));
    cb82:	4b06      	ldr	r3, [pc, #24]	; (cb9c <m_lay_ltrans_tx_handler+0x274>)
    cb84:	6818      	ldr	r0, [r3, #0]
    cb86:	3010      	adds	r0, #16
    cb88:	f7f7 fc30 	bl	43ec <co_list_pop_front>
                // clean-up segment
                m_lay_ltrans_seg_finished(p_buf, status, false);
    cb8c:	2200      	movs	r2, #0
    cb8e:	9907      	ldr	r1, [sp, #28]
    cb90:	0030      	movs	r0, r6
    cb92:	f7ff fe47 	bl	c824 <m_lay_ltrans_seg_finished>
    cb96:	e6c9      	b.n	c92c <m_lay_ltrans_tx_handler+0x4>
            }
        }
    }
}
    cb98:	b00f      	add	sp, #60	; 0x3c
    cb9a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    cb9c:	100126b0 	.word	0x100126b0
    cba0:	00001fff 	.word	0x00001fff
    cba4:	80ffffff 	.word	0x80ffffff
    cba8:	00000782 	.word	0x00000782

0000cbac <m_lay_ltrans_filt_add>:
 *
 * @param[in] p_segment Pointer to the segment information
 ****************************************************************************************
 */
__STATIC void m_lay_ltrans_filt_add(uint16_t src, uint32_t seq_auth, uint32_t iv, bool complete)
{
    cbac:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    // Insert new info in filtering list
    m_lay_ltrans_filter_t *p_filt = &p_m_lay_ltrans_env->rx_filter[p_m_lay_ltrans_env->rx_filter_cursor];
    cbae:	2692      	movs	r6, #146	; 0x92
    cbb0:	4c11      	ldr	r4, [pc, #68]	; (cbf8 <m_lay_ltrans_filt_add+0x4c>)
 *
 * @param[in] p_segment Pointer to the segment information
 ****************************************************************************************
 */
__STATIC void m_lay_ltrans_filt_add(uint16_t src, uint32_t seq_auth, uint32_t iv, bool complete)
{
    cbb2:	9301      	str	r3, [sp, #4]
    // Insert new info in filtering list
    m_lay_ltrans_filter_t *p_filt = &p_m_lay_ltrans_env->rx_filter[p_m_lay_ltrans_env->rx_filter_cursor];
    cbb4:	6825      	ldr	r5, [r4, #0]
    cbb6:	0076      	lsls	r6, r6, #1
    cbb8:	5dac      	ldrb	r4, [r5, r6]

    co_write24p(p_filt->seq_auth, seq_auth);
    cbba:	0027      	movs	r7, r4
    cbbc:	371e      	adds	r7, #30
    cbbe:	00ff      	lsls	r7, r7, #3
    cbc0:	19ef      	adds	r7, r5, r7
 */
__INLINE_S__ void co_write24p(void const *ptr24, uint32_t value)
{
    uint8_t *ptr=(uint8_t*)ptr24;

    *ptr++ = (uint8_t)(value&0xff);
    cbc2:	71b9      	strb	r1, [r7, #6]
    cbc4:	1dbb      	adds	r3, r7, #6
    *ptr++ = (uint8_t)((value&0xff00)>>8);
    cbc6:	0a0f      	lsrs	r7, r1, #8
    *ptr++ = (uint8_t)((value&0xff0000)>>16);
    cbc8:	0c09      	lsrs	r1, r1, #16
    cbca:	7099      	strb	r1, [r3, #2]
    cbcc:	00e1      	lsls	r1, r4, #3
    cbce:	1869      	adds	r1, r5, r1
    p_filt->iv_lsb = iv;
    cbd0:	000c      	movs	r4, r1
__INLINE_S__ void co_write24p(void const *ptr24, uint32_t value)
{
    uint8_t *ptr=(uint8_t*)ptr24;

    *ptr++ = (uint8_t)(value&0xff);
    *ptr++ = (uint8_t)((value&0xff00)>>8);
    cbd2:	705f      	strb	r7, [r3, #1]
    cbd4:	34f9      	adds	r4, #249	; 0xf9
    p_filt->src = src;
    p_filt->complete = complete;
    cbd6:	466b      	mov	r3, sp
{
    // Insert new info in filtering list
    m_lay_ltrans_filter_t *p_filt = &p_m_lay_ltrans_env->rx_filter[p_m_lay_ltrans_env->rx_filter_cursor];

    co_write24p(p_filt->seq_auth, seq_auth);
    p_filt->iv_lsb = iv;
    cbd8:	7022      	strb	r2, [r4, #0]
    p_filt->src = src;
    cbda:	000a      	movs	r2, r1
    p_filt->complete = complete;
    cbdc:	791b      	ldrb	r3, [r3, #4]
    // Insert new info in filtering list
    m_lay_ltrans_filter_t *p_filt = &p_m_lay_ltrans_env->rx_filter[p_m_lay_ltrans_env->rx_filter_cursor];

    co_write24p(p_filt->seq_auth, seq_auth);
    p_filt->iv_lsb = iv;
    p_filt->src = src;
    cbde:	32f4      	adds	r2, #244	; 0xf4
    p_filt->complete = complete;
    cbe0:	31fa      	adds	r1, #250	; 0xfa
    // Insert new info in filtering list
    m_lay_ltrans_filter_t *p_filt = &p_m_lay_ltrans_env->rx_filter[p_m_lay_ltrans_env->rx_filter_cursor];

    co_write24p(p_filt->seq_auth, seq_auth);
    p_filt->iv_lsb = iv;
    p_filt->src = src;
    cbe2:	8010      	strh	r0, [r2, #0]
    p_filt->complete = complete;
    cbe4:	700b      	strb	r3, [r1, #0]

    // Increment filter cursor
    p_m_lay_ltrans_env->rx_filter_cursor++;
    cbe6:	5dab      	ldrb	r3, [r5, r6]
    cbe8:	3301      	adds	r3, #1
    cbea:	b2db      	uxtb	r3, r3

    // Check if cursor value must wrap
    if (p_m_lay_ltrans_env->rx_filter_cursor >= M_LAY_LTRANS_NB_SEGMENT_FILTER)
    cbec:	2b05      	cmp	r3, #5
    cbee:	d900      	bls.n	cbf2 <m_lay_ltrans_filt_add+0x46>
    {
        p_m_lay_ltrans_env->rx_filter_cursor = 0;
    cbf0:	2300      	movs	r3, #0
    cbf2:	55ab      	strb	r3, [r5, r6]
    }
}
    cbf4:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
    cbf6:	46c0      	nop			; (mov r8, r8)
    cbf8:	100126b0 	.word	0x100126b0

0000cbfc <m_lay_trans_seg_timer>:
 *
 * @param[in] p_seg Pointer to the segment information
 ****************************************************************************************
 */
__STATIC void m_lay_trans_seg_timer(m_lay_ltrans_segment_t *p_seg)
{
    cbfc:	0003      	movs	r3, r0
    cbfe:	b510      	push	{r4, lr}
    // Buffer containing the message to segment
    m_tb_buf_t *p_buf_seg = p_seg->p_buf;

    // Check if all retransmissions have been done (if destination is a group or a virtual address)
    if (p_seg->nb_done < M_LAY_LTRANS_NB_SEG_PACKET_RETRANS)
    cc00:	7f5a      	ldrb	r2, [r3, #29]
 ****************************************************************************************
 */
__STATIC void m_lay_trans_seg_timer(m_lay_ltrans_segment_t *p_seg)
{
    // Buffer containing the message to segment
    m_tb_buf_t *p_buf_seg = p_seg->p_buf;
    cc02:	6800      	ldr	r0, [r0, #0]

    // Check if all retransmissions have been done (if destination is a group or a virtual address)
    if (p_seg->nb_done < M_LAY_LTRANS_NB_SEG_PACKET_RETRANS)
    cc04:	2a02      	cmp	r2, #2
    cc06:	d80f      	bhi.n	cc28 <m_lay_trans_seg_timer+0x2c>
    {
        // Go back to the first segment
        p_seg->tx_cursor = 0;
    cc08:	2200      	movs	r2, #0

        // Put the complete buffer again in TX queue
        co_list_push_back(&p_m_lay_ltrans_env->proc_queue, &p_buf_seg->hdr);
    cc0a:	4c0a      	ldr	r4, [pc, #40]	; (cc34 <m_lay_trans_seg_timer+0x38>)

    // Check if all retransmissions have been done (if destination is a group or a virtual address)
    if (p_seg->nb_done < M_LAY_LTRANS_NB_SEG_PACKET_RETRANS)
    {
        // Go back to the first segment
        p_seg->tx_cursor = 0;
    cc0c:	77da      	strb	r2, [r3, #31]

        // Put the complete buffer again in TX queue
        co_list_push_back(&p_m_lay_ltrans_env->proc_queue, &p_buf_seg->hdr);
    cc0e:	6823      	ldr	r3, [r4, #0]
    cc10:	0001      	movs	r1, r0
    cc12:	3310      	adds	r3, #16
    cc14:	0018      	movs	r0, r3
    cc16:	f7f7 fbbe 	bl	4396 <co_list_push_back>
    cc1a:	6823      	ldr	r3, [r4, #0]

        // Check if a segment can be transmitted
        if (!co_list_is_empty(&p_m_lay_ltrans_env->tx_buf_avail))
    cc1c:	689b      	ldr	r3, [r3, #8]
    cc1e:	2b00      	cmp	r3, #0
    cc20:	d006      	beq.n	cc30 <m_lay_trans_seg_timer+0x34>
        {
            m_lay_ltrans_tx_handler();
    cc22:	f7ff fe81 	bl	c928 <m_lay_ltrans_tx_handler>
    cc26:	e003      	b.n	cc30 <m_lay_trans_seg_timer+0x34>
        }
    }
    else
    {
        // Stop segmentation
        m_lay_ltrans_seg_finished(p_buf_seg, M_ERR_TIME_PAST, false);
    cc28:	2200      	movs	r2, #0
    cc2a:	4903      	ldr	r1, [pc, #12]	; (cc38 <m_lay_trans_seg_timer+0x3c>)
    cc2c:	f7ff fdfa 	bl	c824 <m_lay_ltrans_seg_finished>
    }
}
    cc30:	bd10      	pop	{r4, pc}
    cc32:	46c0      	nop			; (mov r8, r8)
    cc34:	100126b0 	.word	0x100126b0
    cc38:	00000582 	.word	0x00000582

0000cc3c <m_lay_trans_incomp_timer>:
 *
 * @param[in] p_reas Pointer to the reassembly information
 ****************************************************************************************
 */
__STATIC void m_lay_trans_incomp_timer(m_lay_ltrans_reassembly_t *p_reas)
{
    cc3c:	b570      	push	{r4, r5, r6, lr}
    // Get buffer containing received segment
    m_tb_buf_t *p_buf_reas = p_reas->p_buf;
    cc3e:	6804      	ldr	r4, [r0, #0]
 *
 * @param[in] p_reas Pointer to the reassembly information
 ****************************************************************************************
 */
__STATIC void m_lay_trans_incomp_timer(m_lay_ltrans_reassembly_t *p_reas)
{
    cc40:	0005      	movs	r5, r0
    #if (BLE_MESH_FRIEND)
    uint8_t read_lid = (p_reas - &p_m_lay_ltrans_env->reassembly[0]) / sizeof(m_lay_ltrans_reassembly_t);
    #endif //(BLE_MESH_FRIEND)

    // Stop acknowledgment timer
    m_tb_timer_clear(&p_reas->timer_ack);
    cc42:	3018      	adds	r0, #24
    cc44:	f008 fba8 	bl	15398 <m_tb_timer_clear>
    // Inform Friend module that reassembly procedure has failed
    p_m_lay_ltrans_env->p_cb_friend->rx(NULL, false, read_lid, 0);
    #endif //(BLE_MESH_FRIEND)

    // Add new element in filtering info
    m_lay_ltrans_filt_add(p_buf_env->src, p_buf_env->seq, p_buf_env->u5.iv, false);
    cc48:	69a2      	ldr	r2, [r4, #24]
    cc4a:	8ba0      	ldrh	r0, [r4, #28]
    cc4c:	6961      	ldr	r1, [r4, #20]
    cc4e:	2300      	movs	r3, #0
    cc50:	f7ff ffac 	bl	cbac <m_lay_ltrans_filt_add>

    // Remove buffer form processing queue
    CO_LIST_POP_ELT(p_m_lay_ltrans_env->proc_queue, p_buf_reas);
    cc54:	4b05      	ldr	r3, [pc, #20]	; (cc6c <m_lay_trans_incomp_timer+0x30>)
    cc56:	0021      	movs	r1, r4
    cc58:	6818      	ldr	r0, [r3, #0]
    cc5a:	3010      	adds	r0, #16
    cc5c:	f7f7 fbd0 	bl	4400 <co_list_extract>

    // Release the buffer
    m_tb_buf_release(p_buf_reas);
    cc60:	0020      	movs	r0, r4
    cc62:	f004 fd1b 	bl	1169c <m_tb_buf_release>

    // Make reassembly structure available
    p_reas->p_buf = NULL;
    cc66:	2300      	movs	r3, #0
    cc68:	602b      	str	r3, [r5, #0]
}
    cc6a:	bd70      	pop	{r4, r5, r6, pc}
    cc6c:	100126b0 	.word	0x100126b0

0000cc70 <m_lay_trans_ack_timer>:
 *
 * @param[in] p_reas Pointer to the reassembly information
 ****************************************************************************************
 */
__STATIC void m_lay_trans_ack_timer(m_lay_ltrans_reassembly_t *p_reas)
{
    cc70:	b510      	push	{r4, lr}
    co_list_push_back(&p_m_lay_ltrans_env->proc_queue, &p_reas->p_buf->hdr);
    cc72:	4c07      	ldr	r4, [pc, #28]	; (cc90 <m_lay_trans_ack_timer+0x20>)
    cc74:	6801      	ldr	r1, [r0, #0]
    cc76:	6823      	ldr	r3, [r4, #0]
    cc78:	3310      	adds	r3, #16
    cc7a:	0018      	movs	r0, r3
    cc7c:	f7f7 fb8b 	bl	4396 <co_list_push_back>
    cc80:	6823      	ldr	r3, [r4, #0]

    // Check if segment transmission can be performed
    if (!co_list_is_empty(&p_m_lay_ltrans_env->tx_buf_avail))
    cc82:	689b      	ldr	r3, [r3, #8]
    cc84:	2b00      	cmp	r3, #0
    cc86:	d001      	beq.n	cc8c <m_lay_trans_ack_timer+0x1c>
    {
        // Transmit next segment
        m_lay_ltrans_tx_handler();
    cc88:	f7ff fe4e 	bl	c928 <m_lay_ltrans_tx_handler>
    }
}
    cc8c:	bd10      	pop	{r4, pc}
    cc8e:	46c0      	nop			; (mov r8, r8)
    cc90:	100126b0 	.word	0x100126b0

0000cc94 <m_lay_ltrans_send>:
 *
 * @return Function execution status
 ****************************************************************************************
 */
__STATIC uint16_t m_lay_ltrans_send(m_tb_buf_t *p_buf)
{
    cc94:	b5f0      	push	{r4, r5, r6, r7, lr}
	M_PRINTF(L_LTARNS, "");
    cc96:	4b45      	ldr	r3, [pc, #276]	; (cdac <m_lay_ltrans_send+0x118>)
 *
 * @return Function execution status
 ****************************************************************************************
 */
__STATIC uint16_t m_lay_ltrans_send(m_tb_buf_t *p_buf)
{
    cc98:	b087      	sub	sp, #28
	M_PRINTF(L_LTARNS, "");
    cc9a:	681b      	ldr	r3, [r3, #0]
 *
 * @return Function execution status
 ****************************************************************************************
 */
__STATIC uint16_t m_lay_ltrans_send(m_tb_buf_t *p_buf)
{
    cc9c:	0004      	movs	r4, r0
    cc9e:	4d44      	ldr	r5, [pc, #272]	; (cdb0 <m_lay_ltrans_send+0x11c>)
	M_PRINTF(L_LTARNS, "");
    cca0:	065b      	lsls	r3, r3, #25
    cca2:	d514      	bpl.n	ccce <m_lay_ltrans_send+0x3a>
    cca4:	002b      	movs	r3, r5
    cca6:	333f      	adds	r3, #63	; 0x3f
    cca8:	9300      	str	r3, [sp, #0]
    ccaa:	002a      	movs	r2, r5
    ccac:	0028      	movs	r0, r5
    ccae:	23ab      	movs	r3, #171	; 0xab
    ccb0:	0029      	movs	r1, r5
    ccb2:	3221      	adds	r2, #33	; 0x21
    ccb4:	009b      	lsls	r3, r3, #2
    ccb6:	3030      	adds	r0, #48	; 0x30
    ccb8:	f7f7 fe78 	bl	49ac <m_print>
    ccbc:	0028      	movs	r0, r5
    ccbe:	3051      	adds	r0, #81	; 0x51
    ccc0:	f7f7 fe74 	bl	49ac <m_print>
    ccc4:	0028      	movs	r0, r5
    ccc6:	1da9      	adds	r1, r5, #6
    ccc8:	3052      	adds	r0, #82	; 0x52
    ccca:	f7f7 fe6f 	bl	49ac <m_print>
	m_printf_hex(L_NET, "m_lay_ltrans_send", M_TB_BUF_DATA(p_buf), p_buf->data_len);
    ccce:	0026      	movs	r6, r4
    ccd0:	0029      	movs	r1, r5
    ccd2:	88a2      	ldrh	r2, [r4, #4]
    ccd4:	3630      	adds	r6, #48	; 0x30
    ccd6:	8923      	ldrh	r3, [r4, #8]
    ccd8:	18b2      	adds	r2, r6, r2
    ccda:	3155      	adds	r1, #85	; 0x55
    ccdc:	2010      	movs	r0, #16
    // Returned status
    uint16_t status = M_ERR_NO_ERROR;
    // Get buffer environment
    m_lay_buf_env_t *p_buf_env = (m_lay_buf_env_t *)p_buf->env;
    // Compute max length accepted for an unsegmented message
    uint16_t max_unseg_size = (GETB(p_buf_env->ttl_ctl, M_MSG_CTL)
    ccde:	1c65      	adds	r5, r4, #1
 ****************************************************************************************
 */
__STATIC uint16_t m_lay_ltrans_send(m_tb_buf_t *p_buf)
{
	M_PRINTF(L_LTARNS, "");
	m_printf_hex(L_NET, "m_lay_ltrans_send", M_TB_BUF_DATA(p_buf), p_buf->data_len);
    cce0:	f7f7 fec4 	bl	4a6c <m_printf_hex>
    // Returned status
    uint16_t status = M_ERR_NO_ERROR;
    // Get buffer environment
    m_lay_buf_env_t *p_buf_env = (m_lay_buf_env_t *)p_buf->env;
    // Compute max length accepted for an unsegmented message
    uint16_t max_unseg_size = (GETB(p_buf_env->ttl_ctl, M_MSG_CTL)
    cce4:	7feb      	ldrb	r3, [r5, #31]
    cce6:	270b      	movs	r7, #11
    cce8:	2b7f      	cmp	r3, #127	; 0x7f
    ccea:	d800      	bhi.n	ccee <m_lay_ltrans_send+0x5a>
    ccec:	3704      	adds	r7, #4
                                    ? M_LAY_TRANS_CTL_UNSEG_SIZE : M_LAY_TRANS_ACCESS_UNSEG_SIZE);
    // Get pointer to data
    uint8_t *p_data = M_TB_BUF_DATA(p_buf);

    // Acquire message
    m_tb_buf_acquire(p_buf);
    ccee:	0020      	movs	r0, r4
    ccf0:	f004 fcd0 	bl	11694 <m_tb_buf_acquire>

    do
    {
        // Unsegmented message
        if (p_buf->data_len <= max_unseg_size)
    ccf4:	8920      	ldrh	r0, [r4, #8]
    ccf6:	4287      	cmp	r7, r0
    ccf8:	d31e      	bcc.n	cd38 <m_lay_ltrans_send+0xa4>
        {
            // Header field value
            uint32_t header = 0;
    ccfa:	2300      	movs	r3, #0
    ccfc:	9305      	str	r3, [sp, #20]

            // Check that SZMIC is well equal to zero
            if (GETB(p_buf_env->flags, M_LAY_BUF_SIZE_MIC))
    ccfe:	7c23      	ldrb	r3, [r4, #16]
    cd00:	079b      	lsls	r3, r3, #30
    cd02:	d44d      	bmi.n	cda0 <m_lay_ltrans_send+0x10c>
                status = M_ERR_INVALID_PARAM;
                break;
            }

            // Reserve bytes for the header
            m_tb_buf_head_reserve(p_buf, M_LAY_TRANS_UNSEG_HEADER_LEN);
    cd04:	2101      	movs	r1, #1
    cd06:	0020      	movs	r0, r4
    cd08:	f004 fc8c 	bl	11624 <m_tb_buf_head_reserve>
            // Move pointer at beginning of header field
            p_data  = M_TB_BUF_DATA(p_buf);
    cd0c:	88a3      	ldrh	r3, [r4, #4]

            // Build header
            SETB(header, M_HEAD_SEG, false);
            SETF(header, M_HEAD_OPCODE, p_buf_env->u14.opcode_aid_afk);
    cd0e:	4d29      	ldr	r5, [pc, #164]	; (cdb4 <m_lay_ltrans_send+0x120>)
            }

            // Reserve bytes for the header
            m_tb_buf_head_reserve(p_buf, M_LAY_TRANS_UNSEG_HEADER_LEN);
            // Move pointer at beginning of header field
            p_data  = M_TB_BUF_DATA(p_buf);
    cd10:	18f6      	adds	r6, r6, r3

            // Build header
            SETB(header, M_HEAD_SEG, false);
            SETF(header, M_HEAD_OPCODE, p_buf_env->u14.opcode_aid_afk);
    cd12:	0023      	movs	r3, r4
    cd14:	332c      	adds	r3, #44	; 0x2c
    cd16:	7818      	ldrb	r0, [r3, #0]
    cd18:	0600      	lsls	r0, r0, #24
    cd1a:	4005      	ands	r5, r0
    cd1c:	2d00      	cmp	r5, #0
    cd1e:	d1fd      	bne.n	cd1c <m_lay_ltrans_send+0x88>
    cd20:	f7ff fd7e 	bl	c820 <co_bswap32>
            // if needed (act as if the message had been received)
            p_m_lay_ltrans_env->p_cb_friend->rx(p_buf, false, 0, 0);
            #endif //(BLE_MESH_FRIEND)

            // Just forward message to the Network Layer
            p_m_lay_ltrans_env->p_net_api->send(p_buf, M_LAY_NET_INTF_TYPE_LTRANS);
    cd24:	4b24      	ldr	r3, [pc, #144]	; (cdb8 <m_lay_ltrans_send+0x124>)
            SETF(header, M_HEAD_OPCODE, p_buf_env->u14.opcode_aid_afk);

            // Put header in network format
            header = co_htonl(header);
            // And copy it in the buffer
            memcpy(p_data, &header, M_LAY_TRANS_UNSEG_HEADER_LEN);
    cd26:	7030      	strb	r0, [r6, #0]
            // if needed (act as if the message had been received)
            p_m_lay_ltrans_env->p_cb_friend->rx(p_buf, false, 0, 0);
            #endif //(BLE_MESH_FRIEND)

            // Just forward message to the Network Layer
            p_m_lay_ltrans_env->p_net_api->send(p_buf, M_LAY_NET_INTF_TYPE_LTRANS);
    cd28:	681b      	ldr	r3, [r3, #0]
            // Build header
            SETB(header, M_HEAD_SEG, false);
            SETF(header, M_HEAD_OPCODE, p_buf_env->u14.opcode_aid_afk);

            // Put header in network format
            header = co_htonl(header);
    cd2a:	9005      	str	r0, [sp, #20]
            // if needed (act as if the message had been received)
            p_m_lay_ltrans_env->p_cb_friend->rx(p_buf, false, 0, 0);
            #endif //(BLE_MESH_FRIEND)

            // Just forward message to the Network Layer
            p_m_lay_ltrans_env->p_net_api->send(p_buf, M_LAY_NET_INTF_TYPE_LTRANS);
    cd2c:	685b      	ldr	r3, [r3, #4]
    cd2e:	0029      	movs	r1, r5
    cd30:	681b      	ldr	r3, [r3, #0]
    cd32:	0020      	movs	r0, r4
    cd34:	4798      	blx	r3
    cd36:	e031      	b.n	cd9c <m_lay_ltrans_send+0x108>
            // Counter
            uint8_t i;
            // Structure for segmentation procedure
            m_lay_ltrans_segment_t *p_seg = NULL;
            // Get size of segments to send
            uint16_t seg_size = (GETB(p_buf_env->ttl_ctl, M_MSG_CTL)
    cd38:	7feb      	ldrb	r3, [r5, #31]
    cd3a:	2b7f      	cmp	r3, #127	; 0x7f
    cd3c:	d812      	bhi.n	cd64 <m_lay_ltrans_send+0xd0>
    cd3e:	210c      	movs	r1, #12
            }

            // Check a new segmentation can be started
            for (i = 0; i < M_LAY_LTRANS_NB_SEGMENTATION; i++)
            {
                p_seg = &p_m_lay_ltrans_env->segment[i];
    cd40:	4b1d      	ldr	r3, [pc, #116]	; (cdb8 <m_lay_ltrans_send+0x124>)
    cd42:	681e      	ldr	r6, [r3, #0]
    cd44:	9303      	str	r3, [sp, #12]

                if (p_seg->p_buf == NULL)
    cd46:	0035      	movs	r5, r6
    cd48:	35b4      	adds	r5, #180	; 0xb4
    cd4a:	682f      	ldr	r7, [r5, #0]
    cd4c:	2f00      	cmp	r7, #0
    cd4e:	d00e      	beq.n	cd6e <m_lay_ltrans_send+0xda>
    cd50:	3520      	adds	r5, #32
    cd52:	682b      	ldr	r3, [r5, #0]
                status = M_ERR_INVALID_PARAM;
                break;
            }

            // Check a new segmentation can be started
            for (i = 0; i < M_LAY_LTRANS_NB_SEGMENTATION; i++)
    cd54:	2701      	movs	r7, #1
            {
                p_seg = &p_m_lay_ltrans_env->segment[i];

                if (p_seg->p_buf == NULL)
    cd56:	2b00      	cmp	r3, #0
    cd58:	d009      	beq.n	cd6e <m_lay_ltrans_send+0xda>
            }

            // No available resources
            if (i == M_LAY_LTRANS_NB_SEGMENTATION)
            {
                status = M_ERR_CANNOT_FRAGMENT;
    cd5a:	4d18      	ldr	r5, [pc, #96]	; (cdbc <m_lay_ltrans_send+0x128>)
    } while(0);

    // An error occurs, release the message
    if (status != M_ERR_NO_ERROR)
    {
        m_tb_buf_release(p_buf);
    cd5c:	0020      	movs	r0, r4
    cd5e:	f004 fc9d 	bl	1169c <m_tb_buf_release>
    cd62:	e020      	b.n	cda6 <m_lay_ltrans_send+0x112>
            uint16_t seg_size = (GETB(p_buf_env->ttl_ctl, M_MSG_CTL)
                                      ? M_LAY_TRANS_CTL_SEG_SIZE : M_LAY_TRANS_ACCESS_SEG_SIZE);

            // Check that SZMIC is well equal to zero if message is a control message.
            if (GETB(p_buf_env->ttl_ctl, M_MSG_CTL)
                    && GETB(p_buf_env->flags, M_LAY_BUF_SIZE_MIC))
    cd64:	7c23      	ldrb	r3, [r4, #16]
            // Counter
            uint8_t i;
            // Structure for segmentation procedure
            m_lay_ltrans_segment_t *p_seg = NULL;
            // Get size of segments to send
            uint16_t seg_size = (GETB(p_buf_env->ttl_ctl, M_MSG_CTL)
    cd66:	2108      	movs	r1, #8
                                      ? M_LAY_TRANS_CTL_SEG_SIZE : M_LAY_TRANS_ACCESS_SEG_SIZE);

            // Check that SZMIC is well equal to zero if message is a control message.
            if (GETB(p_buf_env->ttl_ctl, M_MSG_CTL)
                    && GETB(p_buf_env->flags, M_LAY_BUF_SIZE_MIC))
    cd68:	079b      	lsls	r3, r3, #30
    cd6a:	d419      	bmi.n	cda0 <m_lay_ltrans_send+0x10c>
    cd6c:	e7e8      	b.n	cd40 <m_lay_ltrans_send+0xac>
                break;
            }

            // Prepare segmentation execution
            p_seg->p_buf = p_buf;
            p_seg->nb_seg = (p_buf->data_len + (seg_size - 1)) / seg_size;
    cd6e:	1e4b      	subs	r3, r1, #1
    cd70:	1818      	adds	r0, r3, r0
                status = M_ERR_CANNOT_FRAGMENT;
                break;
            }

            // Prepare segmentation execution
            p_seg->p_buf = p_buf;
    cd72:	602c      	str	r4, [r5, #0]
            p_seg->nb_seg = (p_buf->data_len + (seg_size - 1)) / seg_size;
    cd74:	f7f7 fa93 	bl	429e <__aeabi_idiv>
            p_seg->block_ack = 0;
    cd78:	2300      	movs	r3, #0
                break;
            }

            // Prepare segmentation execution
            p_seg->p_buf = p_buf;
            p_seg->nb_seg = (p_buf->data_len + (seg_size - 1)) / seg_size;
    cd7a:	7728      	strb	r0, [r5, #28]
            p_seg->nb_done = 0;
            p_seg->idx = i;
            p_seg->tx_cursor = 0;

            // Put buffer in list of buffer to process
            co_list_push_back(&p_m_lay_ltrans_env->proc_queue, &p_buf->hdr);
    cd7c:	0030      	movs	r0, r6
            }

            // Prepare segmentation execution
            p_seg->p_buf = p_buf;
            p_seg->nb_seg = (p_buf->data_len + (seg_size - 1)) / seg_size;
            p_seg->block_ack = 0;
    cd7e:	61ab      	str	r3, [r5, #24]
            p_seg->nb_done = 0;
    cd80:	776b      	strb	r3, [r5, #29]
            p_seg->idx = i;
            p_seg->tx_cursor = 0;
    cd82:	77eb      	strb	r3, [r5, #31]
            // Prepare segmentation execution
            p_seg->p_buf = p_buf;
            p_seg->nb_seg = (p_buf->data_len + (seg_size - 1)) / seg_size;
            p_seg->block_ack = 0;
            p_seg->nb_done = 0;
            p_seg->idx = i;
    cd84:	77af      	strb	r7, [r5, #30]
            p_seg->tx_cursor = 0;

            // Put buffer in list of buffer to process
            co_list_push_back(&p_m_lay_ltrans_env->proc_queue, &p_buf->hdr);
    cd86:	3010      	adds	r0, #16
    cd88:	0021      	movs	r1, r4
    cd8a:	f7f7 fb04 	bl	4396 <co_list_push_back>
    cd8e:	9b03      	ldr	r3, [sp, #12]
    cd90:	681b      	ldr	r3, [r3, #0]

            // Check if first segment can be transmitted
            if (!co_list_is_empty(&p_m_lay_ltrans_env->tx_buf_avail))
    cd92:	689b      	ldr	r3, [r3, #8]
    cd94:	2b00      	cmp	r3, #0
    cd96:	d001      	beq.n	cd9c <m_lay_ltrans_send+0x108>
            {
                m_lay_ltrans_tx_handler();
    cd98:	f7ff fdc6 	bl	c928 <m_lay_ltrans_tx_handler>
            }

            // No available resources
            if (i == M_LAY_LTRANS_NB_SEGMENTATION)
            {
                status = M_ERR_CANNOT_FRAGMENT;
    cd9c:	2500      	movs	r5, #0
    if (status != M_ERR_NO_ERROR)
    {
        m_tb_buf_release(p_buf);
    }

    return (status);
    cd9e:	e002      	b.n	cda6 <m_lay_ltrans_send+0x112>
            }

            // No available resources
            if (i == M_LAY_LTRANS_NB_SEGMENTATION)
            {
                status = M_ERR_CANNOT_FRAGMENT;
    cda0:	25c1      	movs	r5, #193	; 0xc1
    cda2:	006d      	lsls	r5, r5, #1
    cda4:	e7da      	b.n	cd5c <m_lay_ltrans_send+0xc8>
    {
        m_tb_buf_release(p_buf);
    }

    return (status);
}
    cda6:	0028      	movs	r0, r5
    cda8:	b007      	add	sp, #28
    cdaa:	bdf0      	pop	{r4, r5, r6, r7, pc}
    cdac:	10010514 	.word	0x10010514
    cdb0:	00021924 	.word	0x00021924
    cdb4:	80ffffff 	.word	0x80ffffff
    cdb8:	100126b0 	.word	0x100126b0
    cdbc:	00000d82 	.word	0x00000d82

0000cdc0 <m_lay_ltrans_sent>:
 * @param[in] p_buf             Pointer to the buffer containing the sent PDU.
 * @param[in] status            Transmission status.
 ****************************************************************************************
 */
__STATIC void m_lay_ltrans_sent(m_tb_buf_t *p_buf, uint16_t status)
{
    cdc0:	b510      	push	{r4, lr}
    // Buffer transmitted by Lower Transport Layer
    if (p_buf->block_id == M_LAY_LTRANS_TX_BUF_BLOCK_ID)
    cdc2:	7b03      	ldrb	r3, [r0, #12]
 * @param[in] p_buf             Pointer to the buffer containing the sent PDU.
 * @param[in] status            Transmission status.
 ****************************************************************************************
 */
__STATIC void m_lay_ltrans_sent(m_tb_buf_t *p_buf, uint16_t status)
{
    cdc4:	0004      	movs	r4, r0
    // Buffer transmitted by Lower Transport Layer
    if (p_buf->block_id == M_LAY_LTRANS_TX_BUF_BLOCK_ID)
    cdc6:	2bfe      	cmp	r3, #254	; 0xfe
    cdc8:	d108      	bne.n	cddc <m_lay_ltrans_sent+0x1c>
    {
        // Push buffer in TX queue
        co_list_push_back(&p_m_lay_ltrans_env->tx_buf_avail, &p_buf->hdr);
    cdca:	4b0a      	ldr	r3, [pc, #40]	; (cdf4 <m_lay_ltrans_sent+0x34>)
    cdcc:	0021      	movs	r1, r4
    cdce:	6818      	ldr	r0, [r3, #0]
    cdd0:	3008      	adds	r0, #8
    cdd2:	f7f7 fae0 	bl	4396 <co_list_push_back>

        // Check transmission queue
        m_lay_ltrans_tx_handler();
    cdd6:	f7ff fda7 	bl	c928 <m_lay_ltrans_tx_handler>
    cdda:	e007      	b.n	cdec <m_lay_ltrans_sent+0x2c>
    else
    {
        m_lay_buf_env_t *p_buf_env = (m_lay_buf_env_t *)p_buf->env;

        // Unsegmented message pushed by Upper Transport layer
        if (p_buf_env->app_lid != M_INVALID_LID)
    cddc:	7c83      	ldrb	r3, [r0, #18]
    cdde:	2bff      	cmp	r3, #255	; 0xff
    cde0:	d004      	beq.n	cdec <m_lay_ltrans_sent+0x2c>
        {
            p_m_lay_ltrans_env->p_cb->sent(p_buf, status);
    cde2:	4b04      	ldr	r3, [pc, #16]	; (cdf4 <m_lay_ltrans_sent+0x34>)
    cde4:	681b      	ldr	r3, [r3, #0]
    cde6:	681b      	ldr	r3, [r3, #0]
    cde8:	681b      	ldr	r3, [r3, #0]
    cdea:	4798      	blx	r3
        }
    }

    // Release transmitted buffer
    m_tb_buf_release(p_buf);
    cdec:	0020      	movs	r0, r4
    cdee:	f004 fc55 	bl	1169c <m_tb_buf_release>
}
    cdf2:	bd10      	pop	{r4, pc}
    cdf4:	100126b0 	.word	0x100126b0

0000cdf8 <m_lay_ltrans_rx>:
 * @param[in] p_buf             Pointer to the buffer containing the received PDU.
 ****************************************************************************************
 */
__STATIC void m_lay_ltrans_rx(m_tb_buf_t *p_buf)
{
	m_printf_hex(L_LTARNS, "recv ltrans data", M_TB_BUF_DATA(p_buf), p_buf->data_len);
    cdf8:	0003      	movs	r3, r0
 *
 * @param[in] p_buf             Pointer to the buffer containing the received PDU.
 ****************************************************************************************
 */
__STATIC void m_lay_ltrans_rx(m_tb_buf_t *p_buf)
{
    cdfa:	b5f0      	push	{r4, r5, r6, r7, lr}
    cdfc:	0007      	movs	r7, r0
    cdfe:	b095      	sub	sp, #84	; 0x54
	m_printf_hex(L_LTARNS, "recv ltrans data", M_TB_BUF_DATA(p_buf), p_buf->data_len);
    ce00:	3330      	adds	r3, #48	; 0x30
    ce02:	930d      	str	r3, [sp, #52]	; 0x34
    ce04:	8882      	ldrh	r2, [r0, #4]
    ce06:	990d      	ldr	r1, [sp, #52]	; 0x34
    ce08:	8903      	ldrh	r3, [r0, #8]
    ce0a:	188a      	adds	r2, r1, r2
    ce0c:	49c4      	ldr	r1, [pc, #784]	; (d120 <m_lay_ltrans_rx+0x328>)
    ce0e:	2040      	movs	r0, #64	; 0x40
    ce10:	3167      	adds	r1, #103	; 0x67
    ce12:	f7f7 fe2b 	bl	4a6c <m_printf_hex>
    // Counter
    uint8_t i;
    // Get buffer environment
    m_lay_buf_env_t *p_buf_env = (m_lay_buf_env_t *)p_buf->env;
    // And data pointer
    uint8_t *p_data = M_TB_BUF_DATA(p_buf);
    ce16:	88bb      	ldrh	r3, [r7, #4]
    // Extract CTL and TTL values
    bool ctl = GETB(p_buf_env->ttl_ctl, M_MSG_CTL);
    uint8_t ttl = (GETF(p_buf_env->ttl_ctl, M_MSG_TTL) == 0) ? 0 : M_TTL_DEFAULT;

    // Retrieve header and put it in host format
    memcpy(&header, p_data, M_LAY_TRANS_SEG_HEADER_LEN);
    ce18:	a813      	add	r0, sp, #76	; 0x4c
    // Counter
    uint8_t i;
    // Get buffer environment
    m_lay_buf_env_t *p_buf_env = (m_lay_buf_env_t *)p_buf->env;
    // And data pointer
    uint8_t *p_data = M_TB_BUF_DATA(p_buf);
    ce1a:	9311      	str	r3, [sp, #68]	; 0x44
    ce1c:	9a11      	ldr	r2, [sp, #68]	; 0x44
    ce1e:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    ce20:	4694      	mov	ip, r2
    ce22:	4463      	add	r3, ip
    ce24:	930a      	str	r3, [sp, #40]	; 0x28
    // PDU header
    uint32_t header;
    // Extract CTL and TTL values
    bool ctl = GETB(p_buf_env->ttl_ctl, M_MSG_CTL);
    ce26:	1c7b      	adds	r3, r7, #1
    ce28:	7fda      	ldrb	r2, [r3, #31]
    uint8_t ttl = (GETF(p_buf_env->ttl_ctl, M_MSG_TTL) == 0) ? 0 : M_TTL_DEFAULT;

    // Retrieve header and put it in host format
    memcpy(&header, p_data, M_LAY_TRANS_SEG_HEADER_LEN);
    ce2a:	990a      	ldr	r1, [sp, #40]	; 0x28
    // And data pointer
    uint8_t *p_data = M_TB_BUF_DATA(p_buf);
    // PDU header
    uint32_t header;
    // Extract CTL and TTL values
    bool ctl = GETB(p_buf_env->ttl_ctl, M_MSG_CTL);
    ce2c:	09d3      	lsrs	r3, r2, #7
    ce2e:	930f      	str	r3, [sp, #60]	; 0x3c
    uint8_t ttl = (GETF(p_buf_env->ttl_ctl, M_MSG_TTL) == 0) ? 0 : M_TTL_DEFAULT;
    ce30:	237f      	movs	r3, #127	; 0x7f
    ce32:	4013      	ands	r3, r2
    ce34:	1e5a      	subs	r2, r3, #1
    ce36:	4193      	sbcs	r3, r2
    ce38:	220b      	movs	r2, #11
    ce3a:	425b      	negs	r3, r3
    ce3c:	401a      	ands	r2, r3
    ce3e:	920e      	str	r2, [sp, #56]	; 0x38

    // Retrieve header and put it in host format
    memcpy(&header, p_data, M_LAY_TRANS_SEG_HEADER_LEN);
    ce40:	2204      	movs	r2, #4
    ce42:	f008 fdc5 	bl	159d0 <memcpy>
    ce46:	9813      	ldr	r0, [sp, #76]	; 0x4c
    ce48:	f7ff fcea 	bl	c820 <co_bswap32>
    ce4c:	9005      	str	r0, [sp, #20]
    header = co_ntohl(header);
    ce4e:	9013      	str	r0, [sp, #76]	; 0x4c

    if (GETB(header, M_HEAD_SEG))
    ce50:	2800      	cmp	r0, #0
    ce52:	da49      	bge.n	cee8 <m_lay_ltrans_rx+0xf0>
        // Buffer environment of buffer that will contain all the received segments
        m_lay_buf_env_t *p_reas_env = (m_lay_buf_env_t *)p_buf->env;
        // Reject segment of not
        bool reject_packet = false;
        // Load segment information
        uint16_t seq_zero = GETF(header, M_HEAD_SEQ_ZERO);
    ce54:	0243      	lsls	r3, r0, #9
    ce56:	0cdb      	lsrs	r3, r3, #19
    ce58:	930b      	str	r3, [sp, #44]	; 0x2c
        uint8_t seg_nb = GETF(header, M_HEAD_SEG_N) + 1;
    ce5a:	0002      	movs	r2, r0
    ce5c:	231f      	movs	r3, #31
    ce5e:	401a      	ands	r2, r3
    ce60:	3201      	adds	r2, #1
    ce62:	9209      	str	r2, [sp, #36]	; 0x24
        uint8_t seg_off = GETF(header, M_HEAD_SEG_O);
    ce64:	0942      	lsrs	r2, r0, #5
    ce66:	401a      	ands	r2, r3
        uint16_t seg_size = ctl ? M_LAY_TRANS_CTL_SEG_SIZE : M_LAY_TRANS_ACCESS_SEG_SIZE;
    ce68:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
        // Reject segment of not
        bool reject_packet = false;
        // Load segment information
        uint16_t seq_zero = GETF(header, M_HEAD_SEQ_ZERO);
        uint8_t seg_nb = GETF(header, M_HEAD_SEG_N) + 1;
        uint8_t seg_off = GETF(header, M_HEAD_SEG_O);
    ce6a:	9206      	str	r2, [sp, #24]
        uint16_t seg_size = ctl ? M_LAY_TRANS_CTL_SEG_SIZE : M_LAY_TRANS_ACCESS_SEG_SIZE;
    ce6c:	2b00      	cmp	r3, #0
    ce6e:	d100      	bne.n	ce72 <m_lay_ltrans_rx+0x7a>
    ce70:	e085      	b.n	cf7e <m_lay_ltrans_rx+0x186>
    ce72:	2308      	movs	r3, #8
    ce74:	9307      	str	r3, [sp, #28]
        bool szmic = ctl ? 0 : GETB(header, M_HEAD_SZMIC);
    ce76:	2300      	movs	r3, #0
    ce78:	9310      	str	r3, [sp, #64]	; 0x40
        // Compute SeqAuth from received packet
        uint32_t seq = p_buf_env->seq;
    ce7a:	697b      	ldr	r3, [r7, #20]
        uint32_t seq_auth = ((seq & M_LTRANS_SEQ_ZERO_MASK) >= seq_zero)
                          ? ((seq & ~M_LTRANS_SEQ_ZERO_MASK) | seq_zero) // No Wrap detected
                          : (((seq - M_LTRANS_SEQ_ZERO_WRAP) & ~M_LTRANS_SEQ_ZERO_MASK) | seq_zero); // Wrap detected
    ce7c:	990b      	ldr	r1, [sp, #44]	; 0x2c
    ce7e:	04da      	lsls	r2, r3, #19
    ce80:	0cd2      	lsrs	r2, r2, #19
    ce82:	428a      	cmp	r2, r1
    ce84:	d305      	bcc.n	ce92 <m_lay_ltrans_rx+0x9a>
    ce86:	000a      	movs	r2, r1
    ce88:	0b5b      	lsrs	r3, r3, #13
    ce8a:	035b      	lsls	r3, r3, #13
    ce8c:	431a      	orrs	r2, r3
    ce8e:	9208      	str	r2, [sp, #32]
    ce90:	e006      	b.n	cea0 <m_lay_ltrans_rx+0xa8>
    ce92:	4aa4      	ldr	r2, [pc, #656]	; (d124 <m_lay_ltrans_rx+0x32c>)
    ce94:	189b      	adds	r3, r3, r2
    ce96:	0b5b      	lsrs	r3, r3, #13
    ce98:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    ce9a:	035b      	lsls	r3, r3, #13
    ce9c:	431a      	orrs	r2, r3
    ce9e:	9208      	str	r2, [sp, #32]
        p_data += M_LAY_TRANS_SEG_HEADER_LEN;

        // Check if received segment is a segment of a new PDU or a new segment
        for (i = 0 ; i < M_LAY_LTRANS_NB_REASSEMBLY ; i++)
        {
            p_reas = &p_m_lay_ltrans_env->reassembly[i];
    cea0:	2600      	movs	r6, #0

            if (p_reas->p_buf != NULL)
    cea2:	2134      	movs	r1, #52	; 0x34
        p_data += M_LAY_TRANS_SEG_HEADER_LEN;

        // Check if received segment is a segment of a new PDU or a new segment
        for (i = 0 ; i < M_LAY_LTRANS_NB_REASSEMBLY ; i++)
        {
            p_reas = &p_m_lay_ltrans_env->reassembly[i];
    cea4:	4ba0      	ldr	r3, [pc, #640]	; (d128 <m_lay_ltrans_rx+0x330>)
    cea6:	681b      	ldr	r3, [r3, #0]
    cea8:	930c      	str	r3, [sp, #48]	; 0x30

            if (p_reas->p_buf != NULL)
    ceaa:	000b      	movs	r3, r1
    ceac:	4373      	muls	r3, r6
    ceae:	9a0c      	ldr	r2, [sp, #48]	; 0x30
    ceb0:	18d2      	adds	r2, r2, r3
    ceb2:	6994      	ldr	r4, [r2, #24]
    ceb4:	2c00      	cmp	r4, #0
    ceb6:	d013      	beq.n	cee0 <m_lay_ltrans_rx+0xe8>
            {
                p_reas_env = (m_lay_buf_env_t *)p_reas->p_buf->env;

                // check that source message is already known
                if (p_reas_env->src == p_buf_env->src)
    ceb8:	8ba5      	ldrh	r5, [r4, #28]
    ceba:	8bb8      	ldrh	r0, [r7, #28]
    cebc:	4285      	cmp	r5, r0
    cebe:	d10f      	bne.n	cee0 <m_lay_ltrans_rx+0xe8>
        p_data += M_LAY_TRANS_SEG_HEADER_LEN;

        // Check if received segment is a segment of a new PDU or a new segment
        for (i = 0 ; i < M_LAY_LTRANS_NB_REASSEMBLY ; i++)
        {
            p_reas = &p_m_lay_ltrans_env->reassembly[i];
    cec0:	990c      	ldr	r1, [sp, #48]	; 0x30
    cec2:	3318      	adds	r3, #24
    cec4:	18cd      	adds	r5, r1, r3
                p_reas_env = (m_lay_buf_env_t *)p_reas->p_buf->env;

                // check that source message is already known
                if (p_reas_env->src == p_buf_env->src)
                {
                    uint32_t reas_seq_auth = p_reas_env->seq;
    cec6:	6963      	ldr	r3, [r4, #20]

                    // Check that received SEQ_AUTH equals to packet under reconstruction
                    if (seq_auth > reas_seq_auth)
    cec8:	9908      	ldr	r1, [sp, #32]
    ceca:	4299      	cmp	r1, r3
    cecc:	d903      	bls.n	ced6 <m_lay_ltrans_rx+0xde>
                    {
                        // Consider reassembly has failed
                        m_lay_trans_incomp_timer(p_reas);
    cece:	0028      	movs	r0, r5
    ced0:	f7ff feb4 	bl	cc3c <m_lay_trans_incomp_timer>
    ced4:	e0b5      	b.n	d042 <m_lay_ltrans_rx+0x24a>

                        // Start a new reassembly
                        i = M_LAY_LTRANS_NB_REASSEMBLY;
                    }
                    else if (seq_auth < reas_seq_auth)
    ced6:	9908      	ldr	r1, [sp, #32]
    ced8:	4299      	cmp	r1, r3
    ceda:	d200      	bcs.n	cede <m_lay_ltrans_rx+0xe6>
    cedc:	e1f0      	b.n	d2c0 <m_lay_ltrans_rx+0x4c8>
    cede:	e055      	b.n	cf8c <m_lay_ltrans_rx+0x194>
    cee0:	3601      	adds	r6, #1

        // Move data cursor
        p_data += M_LAY_TRANS_SEG_HEADER_LEN;

        // Check if received segment is a segment of a new PDU or a new segment
        for (i = 0 ; i < M_LAY_LTRANS_NB_REASSEMBLY ; i++)
    cee2:	2e03      	cmp	r6, #3
    cee4:	d1e1      	bne.n	ceaa <m_lay_ltrans_rx+0xb2>
    cee6:	e0ac      	b.n	d042 <m_lay_ltrans_rx+0x24a>
    cee8:	9b05      	ldr	r3, [sp, #20]
    ceea:	4e8f      	ldr	r6, [pc, #572]	; (d128 <m_lay_ltrans_rx+0x330>)
    ceec:	0e1c      	lsrs	r4, r3, #24
        }
    }
    else
    {
        // Handle reception Block Ack message
        if (ctl && (GETF(header, M_HEAD_OPCODE) == M_OPCODE_BLOCK_ACK))
    ceee:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    cef0:	2b00      	cmp	r3, #0
    cef2:	d035      	beq.n	cf60 <m_lay_ltrans_rx+0x168>
    cef4:	2c00      	cmp	r4, #0
    cef6:	d133      	bne.n	cf60 <m_lay_ltrans_rx+0x168>
                // Buffer containing packet to segment
                m_tb_buf_t *p_seg_buf = NULL;
                // Buffer environment
                m_lay_buf_env_t *p_seg_env = NULL;
                // Extract SeqZero value
                uint16_t seq_zero = GETF(header, M_HEAD_SEQ_ZERO);
    cef8:	9b05      	ldr	r3, [sp, #20]
    cefa:	990a      	ldr	r1, [sp, #40]	; 0x28
    cefc:	025d      	lsls	r5, r3, #9
    cefe:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    cf00:	0ced      	lsrs	r5, r5, #19
    cf02:	7998      	ldrb	r0, [r3, #6]
    cf04:	795a      	ldrb	r2, [r3, #5]
    cf06:	0200      	lsls	r0, r0, #8
    cf08:	4310      	orrs	r0, r2
    cf0a:	791b      	ldrb	r3, [r3, #4]
    cf0c:	0402      	lsls	r2, r0, #16
    cf0e:	78c8      	ldrb	r0, [r1, #3]
    cf10:	021b      	lsls	r3, r3, #8
    cf12:	4318      	orrs	r0, r3
    cf14:	4310      	orrs	r0, r2
    cf16:	f7ff fc83 	bl	c820 <co_bswap32>
                uint32_t block_ack = co_ntohl(co_read32p(&(p_data[3])));

                // Find targeted segmented packet
                for (i = 0; i < M_LAY_LTRANS_NB_SEGMENTATION; i++)
                {
                    p_seg = &p_m_lay_ltrans_env->segment[i];
    cf1a:	6832      	ldr	r2, [r6, #0]
                    p_seg_buf = p_seg->p_buf;
    cf1c:	0013      	movs	r3, r2
    cf1e:	33b4      	adds	r3, #180	; 0xb4
    cf20:	681e      	ldr	r6, [r3, #0]

                    if (p_seg_buf != NULL)
    cf22:	2e00      	cmp	r6, #0
    cf24:	d009      	beq.n	cf3a <m_lay_ltrans_rx+0x142>
                    {
                        p_seg_env = (m_lay_buf_env_t *)p_seg_buf->env;

                        if (((p_seg_env->seq & M_LTRANS_SEQ_ZERO_MASK) == seq_zero)
    cf26:	6973      	ldr	r3, [r6, #20]
    cf28:	04db      	lsls	r3, r3, #19
    cf2a:	0cdb      	lsrs	r3, r3, #19
    cf2c:	429d      	cmp	r5, r3
    cf2e:	d104      	bne.n	cf3a <m_lay_ltrans_rx+0x142>
                                && (M_IS_UNICAST_ADDR(p_seg_env->dst)))
    cf30:	211e      	movs	r1, #30
    cf32:	5e73      	ldrsh	r3, [r6, r1]
    cf34:	2b00      	cmp	r3, #0
    cf36:	db00      	blt.n	cf3a <m_lay_ltrans_rx+0x142>
    cf38:	e181      	b.n	d23e <m_lay_ltrans_rx+0x446>

                // Find targeted segmented packet
                for (i = 0; i < M_LAY_LTRANS_NB_SEGMENTATION; i++)
                {
                    p_seg = &p_m_lay_ltrans_env->segment[i];
                    p_seg_buf = p_seg->p_buf;
    cf3a:	0013      	movs	r3, r2
    cf3c:	33d4      	adds	r3, #212	; 0xd4
    cf3e:	681e      	ldr	r6, [r3, #0]

                    if (p_seg_buf != NULL)
    cf40:	2e00      	cmp	r6, #0
    cf42:	d100      	bne.n	cf46 <m_lay_ltrans_rx+0x14e>
    cf44:	e1bc      	b.n	d2c0 <m_lay_ltrans_rx+0x4c8>
                    {
                        p_seg_env = (m_lay_buf_env_t *)p_seg_buf->env;

                        if (((p_seg_env->seq & M_LTRANS_SEQ_ZERO_MASK) == seq_zero)
    cf46:	6973      	ldr	r3, [r6, #20]
    cf48:	04db      	lsls	r3, r3, #19
    cf4a:	0cdb      	lsrs	r3, r3, #19
    cf4c:	42ab      	cmp	r3, r5
    cf4e:	d000      	beq.n	cf52 <m_lay_ltrans_rx+0x15a>
    cf50:	e1b6      	b.n	d2c0 <m_lay_ltrans_rx+0x4c8>
                                && (M_IS_UNICAST_ADDR(p_seg_env->dst)))
    cf52:	211e      	movs	r1, #30
    cf54:	5e73      	ldrsh	r3, [r6, r1]
    cf56:	2b00      	cmp	r3, #0
    cf58:	da00      	bge.n	cf5c <m_lay_ltrans_rx+0x164>
    cf5a:	e1b1      	b.n	d2c0 <m_lay_ltrans_rx+0x4c8>
                uint32_t block_ack = co_ntohl(co_read32p(&(p_data[3])));

                // Find targeted segmented packet
                for (i = 0; i < M_LAY_LTRANS_NB_SEGMENTATION; i++)
                {
                    p_seg = &p_m_lay_ltrans_env->segment[i];
    cf5c:	2401      	movs	r4, #1
    cf5e:	e16e      	b.n	d23e <m_lay_ltrans_rx+0x446>
            // Inform Friend module about received message
            p_m_lay_ltrans_env->p_cb_friend->rx(p_buf, false, 0, 0);
            #endif //(BLE_MESH_FRIEND)

            // move buffer cursor
            m_tb_buf_head_release(p_buf, M_LAY_TRANS_UNSEG_HEADER_LEN);
    cf60:	2101      	movs	r1, #1
    cf62:	0038      	movs	r0, r7
    cf64:	f004 fb6c 	bl	11640 <m_tb_buf_head_release>

            // Save Packet header
            p_buf_env_rx->u14.opcode_aid_afk = GETF(header, M_HEAD_OPCODE);
    cf68:	003b      	movs	r3, r7
    cf6a:	332c      	adds	r3, #44	; 0x2c
    cf6c:	701c      	strb	r4, [r3, #0]
            // Update environment flag
            p_buf_env_rx->flags = 0;
            SETB(p_buf_env_rx->flags, M_LAY_BUF_RX, true);
    cf6e:	2301      	movs	r3, #1
    cf70:	743b      	strb	r3, [r7, #16]
            SETB(p_buf_env_rx->flags, M_LAY_BUF_SIZE_MIC, false);

            // Forward packet to the upper transport layer
            p_m_lay_ltrans_env->p_cb->rx(p_buf);
    cf72:	6833      	ldr	r3, [r6, #0]
    cf74:	0038      	movs	r0, r7
    cf76:	681b      	ldr	r3, [r3, #0]
    cf78:	685b      	ldr	r3, [r3, #4]
    cf7a:	4798      	blx	r3
        }
    }
}
    cf7c:	e1a0      	b.n	d2c0 <m_lay_ltrans_rx+0x4c8>
        // Load segment information
        uint16_t seq_zero = GETF(header, M_HEAD_SEQ_ZERO);
        uint8_t seg_nb = GETF(header, M_HEAD_SEG_N) + 1;
        uint8_t seg_off = GETF(header, M_HEAD_SEG_O);
        uint16_t seg_size = ctl ? M_LAY_TRANS_CTL_SEG_SIZE : M_LAY_TRANS_ACCESS_SEG_SIZE;
        bool szmic = ctl ? 0 : GETB(header, M_HEAD_SZMIC);
    cf7e:	9b05      	ldr	r3, [sp, #20]
    cf80:	021b      	lsls	r3, r3, #8
    cf82:	0fdb      	lsrs	r3, r3, #31
    cf84:	9310      	str	r3, [sp, #64]	; 0x40
        bool reject_packet = false;
        // Load segment information
        uint16_t seq_zero = GETF(header, M_HEAD_SEQ_ZERO);
        uint8_t seg_nb = GETF(header, M_HEAD_SEG_N) + 1;
        uint8_t seg_off = GETF(header, M_HEAD_SEG_O);
        uint16_t seg_size = ctl ? M_LAY_TRANS_CTL_SEG_SIZE : M_LAY_TRANS_ACCESS_SEG_SIZE;
    cf86:	230c      	movs	r3, #12
    cf88:	9307      	str	r3, [sp, #28]
    cf8a:	e776      	b.n	ce7a <m_lay_ltrans_rx+0x82>
            if (i < M_LAY_LTRANS_NB_REASSEMBLY)
            {
                uint8_t *p_reas_data = M_TB_BUF_DATA(p_reas->p_buf);

                // Sanity check - same type of message and same AID / OP_CODE  - same number of segment
                if ((GETB(p_reas_env->ttl_ctl, M_MSG_CTL) == ctl)
    cf8c:	1c63      	adds	r3, r4, #1
    cf8e:	7fdb      	ldrb	r3, [r3, #31]
    cf90:	990f      	ldr	r1, [sp, #60]	; 0x3c
    cf92:	09db      	lsrs	r3, r3, #7
    cf94:	4299      	cmp	r1, r3
    cf96:	d000      	beq.n	cf9a <m_lay_ltrans_rx+0x1a2>
    cf98:	e192      	b.n	d2c0 <m_lay_ltrans_rx+0x4c8>
                        && (p_reas_env->u14.opcode_aid_afk == GETF(header, M_HEAD_OPCODE))
    cf9a:	0023      	movs	r3, r4
    cf9c:	332c      	adds	r3, #44	; 0x2c
    cf9e:	7819      	ldrb	r1, [r3, #0]
    cfa0:	9b05      	ldr	r3, [sp, #20]
    cfa2:	005b      	lsls	r3, r3, #1
    cfa4:	0e5b      	lsrs	r3, r3, #25
    cfa6:	4299      	cmp	r1, r3
    cfa8:	d000      	beq.n	cfac <m_lay_ltrans_rx+0x1b4>
    cfaa:	e189      	b.n	d2c0 <m_lay_ltrans_rx+0x4c8>
                        && (seg_nb == p_reas->nb_seg)
    cfac:	0013      	movs	r3, r2
    cfae:	3348      	adds	r3, #72	; 0x48
    cfb0:	781b      	ldrb	r3, [r3, #0]
    cfb2:	9909      	ldr	r1, [sp, #36]	; 0x24
    cfb4:	428b      	cmp	r3, r1
    cfb6:	d000      	beq.n	cfba <m_lay_ltrans_rx+0x1c2>
    cfb8:	e182      	b.n	d2c0 <m_lay_ltrans_rx+0x4c8>
                        && (seg_off < seg_nb))
    cfba:	000b      	movs	r3, r1
    cfbc:	9906      	ldr	r1, [sp, #24]
    cfbe:	428b      	cmp	r3, r1
    cfc0:	d800      	bhi.n	cfc4 <m_lay_ltrans_rx+0x1cc>
    cfc2:	e17d      	b.n	d2c0 <m_lay_ltrans_rx+0x4c8>
                {
                    // Check if segment not already received
                    if ((CO_BIT(seg_off) & p_reas->block_ack) == 0)
    cfc4:	6c53      	ldr	r3, [r2, #68]	; 0x44
    cfc6:	40cb      	lsrs	r3, r1
    cfc8:	07db      	lsls	r3, r3, #31
    cfca:	d500      	bpl.n	cfce <m_lay_ltrans_rx+0x1d6>
    cfcc:	e178      	b.n	d2c0 <m_lay_ltrans_rx+0x4c8>
                    {
                        // Insert segment into the reassembled packet
                        uint8_t *p_seg_data  = M_TB_BUF_DATA(p_buf);
                        // Copy segment data
                        memcpy(&(p_reas_data[(seg_off * seg_size)]), &(p_seg_data[M_LAY_TRANS_SEG_HEADER_LEN]), seg_size);
    cfce:	000b      	movs	r3, r1
            reject_packet = true;

            // Packet found, we can process the message
            if (i < M_LAY_LTRANS_NB_REASSEMBLY)
            {
                uint8_t *p_reas_data = M_TB_BUF_DATA(p_reas->p_buf);
    cfd0:	0022      	movs	r2, r4
                    if ((CO_BIT(seg_off) & p_reas->block_ack) == 0)
                    {
                        // Insert segment into the reassembled packet
                        uint8_t *p_seg_data  = M_TB_BUF_DATA(p_buf);
                        // Copy segment data
                        memcpy(&(p_reas_data[(seg_off * seg_size)]), &(p_seg_data[M_LAY_TRANS_SEG_HEADER_LEN]), seg_size);
    cfd2:	9907      	ldr	r1, [sp, #28]
    cfd4:	88a0      	ldrh	r0, [r4, #4]
    cfd6:	434b      	muls	r3, r1
    cfd8:	9911      	ldr	r1, [sp, #68]	; 0x44
    cfda:	18c0      	adds	r0, r0, r3
    cfdc:	9b0d      	ldr	r3, [sp, #52]	; 0x34
            reject_packet = true;

            // Packet found, we can process the message
            if (i < M_LAY_LTRANS_NB_REASSEMBLY)
            {
                uint8_t *p_reas_data = M_TB_BUF_DATA(p_reas->p_buf);
    cfde:	3230      	adds	r2, #48	; 0x30
                    if ((CO_BIT(seg_off) & p_reas->block_ack) == 0)
                    {
                        // Insert segment into the reassembled packet
                        uint8_t *p_seg_data  = M_TB_BUF_DATA(p_buf);
                        // Copy segment data
                        memcpy(&(p_reas_data[(seg_off * seg_size)]), &(p_seg_data[M_LAY_TRANS_SEG_HEADER_LEN]), seg_size);
    cfe0:	3104      	adds	r1, #4
    cfe2:	1810      	adds	r0, r2, r0
    cfe4:	1859      	adds	r1, r3, r1
    cfe6:	9a07      	ldr	r2, [sp, #28]
    cfe8:	f008 fcf2 	bl	159d0 <memcpy>

                        // Keep last RSSI information received
                        p_reas_env->u9.rssi = p_buf_env->u9.rssi;
    cfec:	1cbb      	adds	r3, r7, #2
    cfee:	7fdb      	ldrb	r3, [r3, #31]
    cff0:	3402      	adds	r4, #2
    cff2:	b25b      	sxtb	r3, r3
    cff4:	77e3      	strb	r3, [r4, #31]

                        // Last segment of data received / change length of the reassembled packet
                        if (seg_off == (seg_nb - 1))
    cff6:	9b09      	ldr	r3, [sp, #36]	; 0x24
    cff8:	9a06      	ldr	r2, [sp, #24]
    cffa:	3b01      	subs	r3, #1
    cffc:	429a      	cmp	r2, r3
    cffe:	d10b      	bne.n	d018 <m_lay_ltrans_rx+0x220>
                        {
                            p_reas->p_buf->data_len -= (seg_size - (p_buf->data_len - M_LAY_TRANS_SEG_HEADER_LEN));
    d000:	2334      	movs	r3, #52	; 0x34
    d002:	4373      	muls	r3, r6
    d004:	9a0c      	ldr	r2, [sp, #48]	; 0x30
    d006:	18d3      	adds	r3, r2, r3
    d008:	699a      	ldr	r2, [r3, #24]
    d00a:	893b      	ldrh	r3, [r7, #8]
    d00c:	8911      	ldrh	r1, [r2, #8]
    d00e:	18cb      	adds	r3, r1, r3
    d010:	9907      	ldr	r1, [sp, #28]
    d012:	3b04      	subs	r3, #4
    d014:	1a5b      	subs	r3, r3, r1
    d016:	8113      	strh	r3, [r2, #8]
                        }
                        // Restart incomplete timer
                        m_tb_timer_set(&p_reas->timer_incomp, M_LAY_TRANS_INCOMPLETE_TIMER_DUR);
    d018:	2334      	movs	r3, #52	; 0x34
    d01a:	435e      	muls	r6, r3
    d01c:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    d01e:	4943      	ldr	r1, [pc, #268]	; (d12c <m_lay_ltrans_rx+0x334>)
    d020:	1998      	adds	r0, r3, r6
    d022:	301c      	adds	r0, #28
    d024:	f008 f96e 	bl	15304 <m_tb_timer_set>

                        // Mark segment as received
                        p_reas->block_ack |= CO_BIT(seg_off);
    d028:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    d02a:	9a06      	ldr	r2, [sp, #24]
    d02c:	199e      	adds	r6, r3, r6
    d02e:	2301      	movs	r3, #1
    d030:	4093      	lsls	r3, r2
    d032:	6c72      	ldr	r2, [r6, #68]	; 0x44
    d034:	4313      	orrs	r3, r2
    d036:	6473      	str	r3, [r6, #68]	; 0x44
                        p_reas->nb_done++;
    d038:	3649      	adds	r6, #73	; 0x49
    d03a:	7833      	ldrb	r3, [r6, #0]
    d03c:	3301      	adds	r3, #1
    d03e:	7033      	strb	r3, [r6, #0]
    d040:	e0d4      	b.n	d1ec <m_lay_ltrans_rx+0x3f4>
    uint8_t i;

    // Parse the filtering queue
    for (i = 0; i < M_LAY_LTRANS_NB_SEGMENT_FILTER; i++)
    {
        m_lay_ltrans_filter_t *p_filt = &p_m_lay_ltrans_env->rx_filter[i];
    d042:	4a39      	ldr	r2, [pc, #228]	; (d128 <m_lay_ltrans_rx+0x330>)
                // Boolean indicating if all segments have been received - valid only if segment is present
                // in filtering queue
                bool complete;

                // Check if segment info not present in filtering queue
                if (!m_lay_ltrans_filt_check(p_buf_env->src, seq_auth, p_buf_env->u5.iv, &complete))
    d044:	8bbb      	ldrh	r3, [r7, #28]
    uint8_t i;

    // Parse the filtering queue
    for (i = 0; i < M_LAY_LTRANS_NB_SEGMENT_FILTER; i++)
    {
        m_lay_ltrans_filter_t *p_filt = &p_m_lay_ltrans_env->rx_filter[i];
    d046:	6816      	ldr	r6, [r2, #0]
    d048:	2200      	movs	r2, #0
    d04a:	0031      	movs	r1, r6

        // Search if segment already present in filtering queue
        if ((p_filt->src == src) && (p_filt->iv_lsb == (iv & 0xFF)))
    d04c:	7e3d      	ldrb	r5, [r7, #24]
    d04e:	31f4      	adds	r1, #244	; 0xf4
    d050:	8808      	ldrh	r0, [r1, #0]
    d052:	4298      	cmp	r0, r3
    d054:	d113      	bne.n	d07e <m_lay_ltrans_rx+0x286>
    d056:	7948      	ldrb	r0, [r1, #5]
    d058:	42a8      	cmp	r0, r5
    d05a:	d110      	bne.n	d07e <m_lay_ltrans_rx+0x286>
        {
            uint32_t filt_seq_auth = co_read24p(p_filt->seq_auth);

            if (filt_seq_auth == seq_auth)
    d05c:	78cc      	ldrb	r4, [r1, #3]
    d05e:	7888      	ldrb	r0, [r1, #2]
    d060:	0224      	lsls	r4, r4, #8
    d062:	4304      	orrs	r4, r0
    d064:	7908      	ldrb	r0, [r1, #4]
    d066:	0400      	lsls	r0, r0, #16
    d068:	4320      	orrs	r0, r4
    d06a:	9c08      	ldr	r4, [sp, #32]
    d06c:	4284      	cmp	r4, r0
    d06e:	d106      	bne.n	d07e <m_lay_ltrans_rx+0x286>
            {
                *p_complete = p_filt->complete;
    d070:	321e      	adds	r2, #30
    d072:	00d2      	lsls	r2, r2, #3
    d074:	18b2      	adds	r2, r6, r2
                {
                    // If the lower transport layer receives another segment for the sequence authentication value,
                    // and the message has already been fully received, then it shall send a Segment Acknowledgment
                    // message immediately with the BlockAck field set to the block authentication value for that
                    // SeqAuth
                    if (complete
    d076:	7a92      	ldrb	r2, [r2, #10]
    d078:	2a00      	cmp	r2, #0
    d07a:	d134      	bne.n	d0e6 <m_lay_ltrans_rx+0x2ee>
    d07c:	e120      	b.n	d2c0 <m_lay_ltrans_rx+0x4c8>
    d07e:	3201      	adds	r2, #1
    d080:	3108      	adds	r1, #8
{
    // Counter
    uint8_t i;

    // Parse the filtering queue
    for (i = 0; i < M_LAY_LTRANS_NB_SEGMENT_FILTER; i++)
    d082:	2a06      	cmp	r2, #6
    d084:	d1e4      	bne.n	d050 <m_lay_ltrans_rx+0x258>
                    for (i = 0; i < M_LAY_LTRANS_NB_REASSEMBLY ; i++)
                    {
                        p_reas = &(p_m_lay_ltrans_env->reassembly[i]);

                        // Check that slot is available
                        if(p_reas->p_buf == NULL)
    d086:	69b3      	ldr	r3, [r6, #24]
    d088:	2b00      	cmp	r3, #0
    d08a:	d047      	beq.n	d11c <m_lay_ltrans_rx+0x324>
    d08c:	6cf3      	ldr	r3, [r6, #76]	; 0x4c
    d08e:	2b00      	cmp	r3, #0
    d090:	d004      	beq.n	d09c <m_lay_ltrans_rx+0x2a4>
    d092:	1d33      	adds	r3, r6, #4
    d094:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
    d096:	2b00      	cmp	r3, #0
    d098:	d114      	bne.n	d0c4 <m_lay_ltrans_rx+0x2cc>
    d09a:	e03e      	b.n	d11a <m_lay_ltrans_rx+0x322>
                if (!m_lay_ltrans_filt_check(p_buf_env->src, seq_auth, p_buf_env->u5.iv, &complete))
                {
                    // Find a slot to reassemble the buffer
                    for (i = 0; i < M_LAY_LTRANS_NB_REASSEMBLY ; i++)
                    {
                        p_reas = &(p_m_lay_ltrans_env->reassembly[i]);
    d09c:	2301      	movs	r3, #1
    d09e:	930d      	str	r3, [sp, #52]	; 0x34
    d0a0:	2434      	movs	r4, #52	; 0x34
    d0a2:	9b0d      	ldr	r3, [sp, #52]	; 0x34

                    if(i < M_LAY_LTRANS_NB_REASSEMBLY)
                    {
                        // Allocate a new buffer with enough
                        uint16_t size = (seg_size * seg_nb);
                        uint16_t status = m_tb_buf_alloc(&(p_reas->p_buf), 0, size, 0);
    d0a4:	9a09      	ldr	r2, [sp, #36]	; 0x24
                if (!m_lay_ltrans_filt_check(p_buf_env->src, seq_auth, p_buf_env->u5.iv, &complete))
                {
                    // Find a slot to reassemble the buffer
                    for (i = 0; i < M_LAY_LTRANS_NB_REASSEMBLY ; i++)
                    {
                        p_reas = &(p_m_lay_ltrans_env->reassembly[i]);
    d0a6:	435c      	muls	r4, r3
    d0a8:	0023      	movs	r3, r4
    d0aa:	3318      	adds	r3, #24
    d0ac:	18f5      	adds	r5, r6, r3

                    if(i < M_LAY_LTRANS_NB_REASSEMBLY)
                    {
                        // Allocate a new buffer with enough
                        uint16_t size = (seg_size * seg_nb);
                        uint16_t status = m_tb_buf_alloc(&(p_reas->p_buf), 0, size, 0);
    d0ae:	9b07      	ldr	r3, [sp, #28]
    d0b0:	0028      	movs	r0, r5
    d0b2:	435a      	muls	r2, r3
    d0b4:	2300      	movs	r3, #0
    d0b6:	b292      	uxth	r2, r2
    d0b8:	0019      	movs	r1, r3
    d0ba:	f004 fa3d 	bl	11538 <m_tb_buf_alloc>
    d0be:	900f      	str	r0, [sp, #60]	; 0x3c

                        if (status == M_ERR_NO_ERROR)
    d0c0:	2800      	cmp	r0, #0
    d0c2:	d035      	beq.n	d130 <m_lay_ltrans_rx+0x338>

                    // Send block ACK Message to inform that segment cannot be processed
                    if (reject_packet)
                    {
                        // Add received segment in filtering info
                        m_lay_ltrans_filt_add(p_buf_env->src, seq_auth, p_buf_env->u5.iv, false);
    d0c4:	2300      	movs	r3, #0
    d0c6:	69ba      	ldr	r2, [r7, #24]
    d0c8:	8bb8      	ldrh	r0, [r7, #28]
    d0ca:	9908      	ldr	r1, [sp, #32]
    d0cc:	f7ff fd6e 	bl	cbac <m_lay_ltrans_filt_add>

                        // Send Block ACK message
                        if (M_IS_UNICAST_ADDR(p_buf_env->dst))
    d0d0:	8bfa      	ldrh	r2, [r7, #30]
    d0d2:	b213      	sxth	r3, r2
    d0d4:	2b00      	cmp	r3, #0
    d0d6:	da00      	bge.n	d0da <m_lay_ltrans_rx+0x2e2>
    d0d8:	e0f2      	b.n	d2c0 <m_lay_ltrans_rx+0x4c8>
                        {
                            m_lay_ltrans_block_ack_send(p_buf, p_buf_env->net_lid, p_buf_env->dst,
    d0da:	980e      	ldr	r0, [sp, #56]	; 0x38
    d0dc:	8bbb      	ldrh	r3, [r7, #28]
    d0de:	7c79      	ldrb	r1, [r7, #17]
    d0e0:	9002      	str	r0, [sp, #8]
    d0e2:	2000      	movs	r0, #0
    d0e4:	e012      	b.n	d10c <m_lay_ltrans_rx+0x314>
                    // If the lower transport layer receives another segment for the sequence authentication value,
                    // and the message has already been fully received, then it shall send a Segment Acknowledgment
                    // message immediately with the BlockAck field set to the block authentication value for that
                    // SeqAuth
                    if (complete
                            && M_IS_UNICAST_ADDR(p_buf_env->dst))
    d0e6:	8bfa      	ldrh	r2, [r7, #30]
    d0e8:	b211      	sxth	r1, r2
    d0ea:	2900      	cmp	r1, #0
    d0ec:	da00      	bge.n	d0f0 <m_lay_ltrans_rx+0x2f8>
    d0ee:	e0e7      	b.n	d2c0 <m_lay_ltrans_rx+0x4c8>
    d0f0:	2100      	movs	r1, #0
                        // Counter
                        uint8_t i;

                        for (i = 0; i < seg_nb; i++)
                        {
                            block_ack |= CO_BIT(i);
    d0f2:	2501      	movs	r5, #1
    d0f4:	0008      	movs	r0, r1
    d0f6:	002c      	movs	r4, r5
    d0f8:	408c      	lsls	r4, r1
                        // Generate block ack value
                        uint32_t block_ack = 0;
                        // Counter
                        uint8_t i;

                        for (i = 0; i < seg_nb; i++)
    d0fa:	9e09      	ldr	r6, [sp, #36]	; 0x24
    d0fc:	3101      	adds	r1, #1
                        {
                            block_ack |= CO_BIT(i);
    d0fe:	4320      	orrs	r0, r4
                        // Generate block ack value
                        uint32_t block_ack = 0;
                        // Counter
                        uint8_t i;

                        for (i = 0; i < seg_nb; i++)
    d100:	b2cc      	uxtb	r4, r1
    d102:	42a6      	cmp	r6, r4
    d104:	d8f7      	bhi.n	d0f6 <m_lay_ltrans_rx+0x2fe>
                        {
                            block_ack |= CO_BIT(i);
                        }

                        m_lay_ltrans_block_ack_send(p_buf, p_buf_env->net_lid, p_buf_env->dst,
    d106:	9c0e      	ldr	r4, [sp, #56]	; 0x38
    d108:	7c79      	ldrb	r1, [r7, #17]
    d10a:	9402      	str	r4, [sp, #8]
    d10c:	9001      	str	r0, [sp, #4]
    d10e:	980b      	ldr	r0, [sp, #44]	; 0x2c
    d110:	9000      	str	r0, [sp, #0]
    d112:	0038      	movs	r0, r7
    d114:	f7ff fbac 	bl	c870 <m_lay_ltrans_block_ack_send>
    d118:	e0d2      	b.n	d2c0 <m_lay_ltrans_rx+0x4c8>
                if (!m_lay_ltrans_filt_check(p_buf_env->src, seq_auth, p_buf_env->u5.iv, &complete))
                {
                    // Find a slot to reassemble the buffer
                    for (i = 0; i < M_LAY_LTRANS_NB_REASSEMBLY ; i++)
                    {
                        p_reas = &(p_m_lay_ltrans_env->reassembly[i]);
    d11a:	2302      	movs	r3, #2
    d11c:	930d      	str	r3, [sp, #52]	; 0x34
    d11e:	e7bf      	b.n	d0a0 <m_lay_ltrans_rx+0x2a8>
    d120:	00021924 	.word	0x00021924
    d124:	ffffe000 	.word	0xffffe000
    d128:	100126b0 	.word	0x100126b0
    d12c:	00002710 	.word	0x00002710
                            uint8_t *p_reas_data = M_TB_BUF_DATA(p_reas->p_buf);

                            p_reas_env = (m_lay_buf_env_t *)p_reas->p_buf->env;

                            // Fill buffer environment
                            memcpy(p_reas_env, p_buf_env, sizeof(m_lay_buf_env_t));
    d130:	0039      	movs	r1, r7
                        uint16_t size = (seg_size * seg_nb);
                        uint16_t status = m_tb_buf_alloc(&(p_reas->p_buf), 0, size, 0);

                        if (status == M_ERR_NO_ERROR)
                        {
                            uint8_t *p_reas_data = M_TB_BUF_DATA(p_reas->p_buf);
    d132:	1934      	adds	r4, r6, r4
    d134:	69a3      	ldr	r3, [r4, #24]

                            p_reas_env = (m_lay_buf_env_t *)p_reas->p_buf->env;

                            // Fill buffer environment
                            memcpy(p_reas_env, p_buf_env, sizeof(m_lay_buf_env_t));
    d136:	2220      	movs	r2, #32
                        uint16_t size = (seg_size * seg_nb);
                        uint16_t status = m_tb_buf_alloc(&(p_reas->p_buf), 0, size, 0);

                        if (status == M_ERR_NO_ERROR)
                        {
                            uint8_t *p_reas_data = M_TB_BUF_DATA(p_reas->p_buf);
    d138:	930c      	str	r3, [sp, #48]	; 0x30

                            p_reas_env = (m_lay_buf_env_t *)p_reas->p_buf->env;

                            // Fill buffer environment
                            memcpy(p_reas_env, p_buf_env, sizeof(m_lay_buf_env_t));
    d13a:	980c      	ldr	r0, [sp, #48]	; 0x30
                        uint16_t size = (seg_size * seg_nb);
                        uint16_t status = m_tb_buf_alloc(&(p_reas->p_buf), 0, size, 0);

                        if (status == M_ERR_NO_ERROR)
                        {
                            uint8_t *p_reas_data = M_TB_BUF_DATA(p_reas->p_buf);
    d13c:	889b      	ldrh	r3, [r3, #4]

                            p_reas_env = (m_lay_buf_env_t *)p_reas->p_buf->env;

                            // Fill buffer environment
                            memcpy(p_reas_env, p_buf_env, sizeof(m_lay_buf_env_t));
    d13e:	3110      	adds	r1, #16
    d140:	3010      	adds	r0, #16
                        uint16_t size = (seg_size * seg_nb);
                        uint16_t status = m_tb_buf_alloc(&(p_reas->p_buf), 0, size, 0);

                        if (status == M_ERR_NO_ERROR)
                        {
                            uint8_t *p_reas_data = M_TB_BUF_DATA(p_reas->p_buf);
    d142:	9311      	str	r3, [sp, #68]	; 0x44

                            p_reas_env = (m_lay_buf_env_t *)p_reas->p_buf->env;

                            // Fill buffer environment
                            memcpy(p_reas_env, p_buf_env, sizeof(m_lay_buf_env_t));
    d144:	f008 fc44 	bl	159d0 <memcpy>

                            // Copy computed seq_auth
                            p_reas_env->seq  = seq_auth;
    d148:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    d14a:	9a08      	ldr	r2, [sp, #32]

                            // Create reassemble parameter environment
                            p_reas->block_ack = 0;
                            p_reas->nb_seg = seg_nb;
    d14c:	2124      	movs	r1, #36	; 0x24

                            // Fill buffer environment
                            memcpy(p_reas_env, p_buf_env, sizeof(m_lay_buf_env_t));

                            // Copy computed seq_auth
                            p_reas_env->seq  = seq_auth;
    d14e:	615a      	str	r2, [r3, #20]

                            // Create reassemble parameter environment
                            p_reas->block_ack = 0;
    d150:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
                            p_reas->nb_seg = seg_nb;
    d152:	466a      	mov	r2, sp

                            // Copy computed seq_auth
                            p_reas_env->seq  = seq_auth;

                            // Create reassemble parameter environment
                            p_reas->block_ack = 0;
    d154:	6463      	str	r3, [r4, #68]	; 0x44
                            p_reas->nb_seg = seg_nb;
    d156:	0023      	movs	r3, r4
    d158:	1852      	adds	r2, r2, r1
    d15a:	7812      	ldrb	r2, [r2, #0]
    d15c:	3348      	adds	r3, #72	; 0x48
    d15e:	701a      	strb	r2, [r3, #0]
                            p_reas->nb_done = 1;
    d160:	2201      	movs	r2, #1
    d162:	705a      	strb	r2, [r3, #1]

                            // Copy AID/AFK or OPCODE
                            p_reas_env->u14.opcode_aid_afk = GETF(header, M_HEAD_OPCODE);
    d164:	9b05      	ldr	r3, [sp, #20]
                            p_reas_env->flags = 0;
                            SETB(p_reas_env->flags, M_LAY_BUF_RX, true);
                            SETB(p_reas_env->flags, M_LAY_BUF_SIZE_MIC, szmic);

                            // Copy segment data
                            memcpy(&p_reas_data[seg_off * seg_size], p_data, seg_size);
    d166:	9806      	ldr	r0, [sp, #24]
                            p_reas->block_ack = 0;
                            p_reas->nb_seg = seg_nb;
                            p_reas->nb_done = 1;

                            // Copy AID/AFK or OPCODE
                            p_reas_env->u14.opcode_aid_afk = GETF(header, M_HEAD_OPCODE);
    d168:	4093      	lsls	r3, r2
    d16a:	0e59      	lsrs	r1, r3, #25
    d16c:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    d16e:	332c      	adds	r3, #44	; 0x2c
    d170:	7019      	strb	r1, [r3, #0]

                            // Update environment flag
                            p_reas_env->flags = 0;
                            SETB(p_reas_env->flags, M_LAY_BUF_RX, true);
                            SETB(p_reas_env->flags, M_LAY_BUF_SIZE_MIC, szmic);
    d172:	9b10      	ldr	r3, [sp, #64]	; 0x40

                            // Copy segment data
                            memcpy(&p_reas_data[seg_off * seg_size], p_data, seg_size);
    d174:	990a      	ldr	r1, [sp, #40]	; 0x28
                            p_reas_env->u14.opcode_aid_afk = GETF(header, M_HEAD_OPCODE);

                            // Update environment flag
                            p_reas_env->flags = 0;
                            SETB(p_reas_env->flags, M_LAY_BUF_RX, true);
                            SETB(p_reas_env->flags, M_LAY_BUF_SIZE_MIC, szmic);
    d176:	4093      	lsls	r3, r2
    d178:	4313      	orrs	r3, r2
    d17a:	9a0c      	ldr	r2, [sp, #48]	; 0x30

                            // Copy segment data
                            memcpy(&p_reas_data[seg_off * seg_size], p_data, seg_size);
    d17c:	3104      	adds	r1, #4
                            p_reas_env->u14.opcode_aid_afk = GETF(header, M_HEAD_OPCODE);

                            // Update environment flag
                            p_reas_env->flags = 0;
                            SETB(p_reas_env->flags, M_LAY_BUF_RX, true);
                            SETB(p_reas_env->flags, M_LAY_BUF_SIZE_MIC, szmic);
    d17e:	7413      	strb	r3, [r2, #16]
                        uint16_t size = (seg_size * seg_nb);
                        uint16_t status = m_tb_buf_alloc(&(p_reas->p_buf), 0, size, 0);

                        if (status == M_ERR_NO_ERROR)
                        {
                            uint8_t *p_reas_data = M_TB_BUF_DATA(p_reas->p_buf);
    d180:	0013      	movs	r3, r2
                            p_reas_env->flags = 0;
                            SETB(p_reas_env->flags, M_LAY_BUF_RX, true);
                            SETB(p_reas_env->flags, M_LAY_BUF_SIZE_MIC, szmic);

                            // Copy segment data
                            memcpy(&p_reas_data[seg_off * seg_size], p_data, seg_size);
    d182:	9a07      	ldr	r2, [sp, #28]
                        uint16_t size = (seg_size * seg_nb);
                        uint16_t status = m_tb_buf_alloc(&(p_reas->p_buf), 0, size, 0);

                        if (status == M_ERR_NO_ERROR)
                        {
                            uint8_t *p_reas_data = M_TB_BUF_DATA(p_reas->p_buf);
    d184:	3330      	adds	r3, #48	; 0x30
                            p_reas_env->flags = 0;
                            SETB(p_reas_env->flags, M_LAY_BUF_RX, true);
                            SETB(p_reas_env->flags, M_LAY_BUF_SIZE_MIC, szmic);

                            // Copy segment data
                            memcpy(&p_reas_data[seg_off * seg_size], p_data, seg_size);
    d186:	4350      	muls	r0, r2
    d188:	9a11      	ldr	r2, [sp, #68]	; 0x44
    d18a:	1880      	adds	r0, r0, r2
    d18c:	1818      	adds	r0, r3, r0
    d18e:	9a07      	ldr	r2, [sp, #28]
    d190:	f008 fc1e 	bl	159d0 <memcpy>

                            // last segment of data received / change length of the reassembled packet
                            if (seg_off == (seg_nb - 1))
    d194:	9b09      	ldr	r3, [sp, #36]	; 0x24
    d196:	9a06      	ldr	r2, [sp, #24]
    d198:	3b01      	subs	r3, #1
    d19a:	429a      	cmp	r2, r3
    d19c:	d107      	bne.n	d1ae <m_lay_ltrans_rx+0x3b6>
                            {
                                p_reas->p_buf->data_len -= (seg_size - (p_buf->data_len - M_LAY_TRANS_SEG_HEADER_LEN));
    d19e:	69a2      	ldr	r2, [r4, #24]
    d1a0:	893b      	ldrh	r3, [r7, #8]
    d1a2:	8911      	ldrh	r1, [r2, #8]
    d1a4:	18cb      	adds	r3, r1, r3
    d1a6:	9907      	ldr	r1, [sp, #28]
    d1a8:	3b04      	subs	r3, #4
    d1aa:	1a5b      	subs	r3, r3, r1
    d1ac:	8113      	strh	r3, [r2, #8]
                            }

                            // Start imcomplete timer
                            m_tb_timer_set(&p_reas->timer_incomp, M_LAY_TRANS_INCOMPLETE_TIMER_DUR);
    d1ae:	2434      	movs	r4, #52	; 0x34
    d1b0:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    d1b2:	4944      	ldr	r1, [pc, #272]	; (d2c4 <m_lay_ltrans_rx+0x4cc>)
    d1b4:	435c      	muls	r4, r3
    d1b6:	1930      	adds	r0, r6, r4
    d1b8:	301c      	adds	r0, #28
    d1ba:	f008 f8a3 	bl	15304 <m_tb_timer_set>

                            // Start acknowledgment timer only if destination address is an unicast address
                            if (M_IS_UNICAST_ADDR(p_buf_env->dst))
    d1be:	221e      	movs	r2, #30
    d1c0:	5ebb      	ldrsh	r3, [r7, r2]
    d1c2:	2b00      	cmp	r3, #0
    d1c4:	db08      	blt.n	d1d8 <m_lay_ltrans_rx+0x3e0>
                            {
                                m_tb_timer_set(&(p_reas->timer_ack), M_LAY_LTRANS_TIMER_COMPUTE(ACK, ttl));
    d1c6:	2132      	movs	r1, #50	; 0x32
    d1c8:	0020      	movs	r0, r4
    d1ca:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    d1cc:	3030      	adds	r0, #48	; 0x30
    d1ce:	4359      	muls	r1, r3
    d1d0:	1830      	adds	r0, r6, r0
    d1d2:	3196      	adds	r1, #150	; 0x96
    d1d4:	f008 f896 	bl	15304 <m_tb_timer_set>
                            }

                            // Mark segment as received
                            p_reas->block_ack |= CO_BIT(seg_off);
    d1d8:	2334      	movs	r3, #52	; 0x34
    d1da:	9a0d      	ldr	r2, [sp, #52]	; 0x34
    d1dc:	9906      	ldr	r1, [sp, #24]
    d1de:	4353      	muls	r3, r2
    d1e0:	2201      	movs	r2, #1
    d1e2:	408a      	lsls	r2, r1
    d1e4:	18f3      	adds	r3, r6, r3
    d1e6:	6c59      	ldr	r1, [r3, #68]	; 0x44
    d1e8:	430a      	orrs	r2, r1
    d1ea:	645a      	str	r2, [r3, #68]	; 0x44
                #if (BLE_MESH_FRIEND)
                // Inform Friend module about received segment
                p_m_lay_ltrans_env->p_cb_friend->rx(p_buf, true, i, p_reas->nb_seg);
                #endif //(BLE_MESH_FRIEND)

                if (all_rx)
    d1ec:	002b      	movs	r3, r5
    d1ee:	3330      	adds	r3, #48	; 0x30
    d1f0:	781a      	ldrb	r2, [r3, #0]
    d1f2:	3301      	adds	r3, #1
    d1f4:	781b      	ldrb	r3, [r3, #0]
    d1f6:	429a      	cmp	r2, r3
    d1f8:	d162      	bne.n	d2c0 <m_lay_ltrans_rx+0x4c8>
                {
                    // Stop Timers
                    m_tb_timer_clear(&p_reas->timer_ack);
    d1fa:	0028      	movs	r0, r5
    d1fc:	3018      	adds	r0, #24
    d1fe:	f008 f8cb 	bl	15398 <m_tb_timer_clear>
                    m_tb_timer_clear(&p_reas->timer_incomp);
    d202:	1d28      	adds	r0, r5, #4
    d204:	f008 f8c8 	bl	15398 <m_tb_timer_clear>

                    // Send complete packet to Upper Transport Layer
                    p_m_lay_ltrans_env->p_cb->rx(p_reas->p_buf);
    d208:	4b2f      	ldr	r3, [pc, #188]	; (d2c8 <m_lay_ltrans_rx+0x4d0>)
    d20a:	6828      	ldr	r0, [r5, #0]
    d20c:	681b      	ldr	r3, [r3, #0]
    d20e:	681b      	ldr	r3, [r3, #0]
    d210:	685b      	ldr	r3, [r3, #4]
    d212:	4798      	blx	r3
                    m_tb_buf_release(p_reas->p_buf);
    d214:	6828      	ldr	r0, [r5, #0]
    d216:	f004 fa41 	bl	1169c <m_tb_buf_release>

                    // Clean-up the reassembly structure so that a new procedure can be started
                    p_reas->p_buf = NULL;
    d21a:	2300      	movs	r3, #0
    d21c:	602b      	str	r3, [r5, #0]

                    // Add new element in filtering info
                    m_lay_ltrans_filt_add(p_buf_env->src, seq_auth, p_buf_env->u5.iv, true);
    d21e:	69ba      	ldr	r2, [r7, #24]
    d220:	3301      	adds	r3, #1
    d222:	8bb8      	ldrh	r0, [r7, #28]
    d224:	9908      	ldr	r1, [sp, #32]
    d226:	f7ff fcc1 	bl	cbac <m_lay_ltrans_filt_add>

                    // Send a Block ACK message to confirm that all data has been received
                    if (M_IS_UNICAST_ADDR(p_buf_env->dst))
    d22a:	8bfa      	ldrh	r2, [r7, #30]
    d22c:	b213      	sxth	r3, r2
    d22e:	2b00      	cmp	r3, #0
    d230:	db46      	blt.n	d2c0 <m_lay_ltrans_rx+0x4c8>
                    {
                        m_lay_ltrans_block_ack_send(p_buf, p_buf_env->net_lid, p_buf_env->dst,
    d232:	980e      	ldr	r0, [sp, #56]	; 0x38
    d234:	8bbb      	ldrh	r3, [r7, #28]
    d236:	7c79      	ldrb	r1, [r7, #17]
    d238:	9002      	str	r0, [sp, #8]
    d23a:	6ae8      	ldr	r0, [r5, #44]	; 0x2c
    d23c:	e766      	b.n	d10c <m_lay_ltrans_rx+0x314>

                if (i < M_LAY_LTRANS_NB_SEGMENTATION)
                {
                    uint16_t status = M_ERR_NO_ERROR;
                    bool finished = false;
                    uint32_t block_mask = (CO_BIT(p_seg->nb_seg) - 1);
    d23e:	0164      	lsls	r4, r4, #5
    d240:	1913      	adds	r3, r2, r4
    d242:	0019      	movs	r1, r3
    d244:	31d0      	adds	r1, #208	; 0xd0
    d246:	780d      	ldrb	r5, [r1, #0]
                    bool under_tx = (M_LAY_LTRANS_BLOCK_REMAIN_MASK(p_seg) != 0);
    d248:	2101      	movs	r1, #1
    d24a:	40a9      	lsls	r1, r5
    d24c:	25cc      	movs	r5, #204	; 0xcc
    d24e:	46ac      	mov	ip, r5
    d250:	449c      	add	ip, r3
    d252:	4665      	mov	r5, ip
    d254:	682d      	ldr	r5, [r5, #0]
    d256:	3901      	subs	r1, #1
    d258:	404d      	eors	r5, r1
    d25a:	9506      	str	r5, [sp, #24]
    d25c:	001d      	movs	r5, r3
    d25e:	35d3      	adds	r5, #211	; 0xd3
    d260:	782f      	ldrb	r7, [r5, #0]
    d262:	9505      	str	r5, [sp, #20]
    d264:	2501      	movs	r5, #1
    d266:	426d      	negs	r5, r5
    d268:	40bd      	lsls	r5, r7
    d26a:	9f06      	ldr	r7, [sp, #24]
    d26c:	403d      	ands	r5, r7

                    if (block_ack == 0)
    d26e:	2800      	cmp	r0, #0
    d270:	d01c      	beq.n	d2ac <m_lay_ltrans_rx+0x4b4>
    d272:	2700      	movs	r7, #0
                    {
                        // Destination node cannot receive the segments, stop transmission
                        finished = true;
                        status = M_ERR_INSUFFICIENT_RESOURCES;
                    }
                    else if(block_ack == block_mask)
    d274:	4288      	cmp	r0, r1
    d276:	d01c      	beq.n	d2b2 <m_lay_ltrans_rx+0x4ba>
                        finished = true;
                    }
                    else
                    {
                        // Update block acknowledgment
                        p_seg->block_ack = block_ack;
    d278:	4661      	mov	r1, ip
                        p_seg->nb_done = 0;

                        // Stop segment transmission timer
                        m_tb_timer_clear(&p_seg->timer_tx);
    d27a:	1914      	adds	r4, r2, r4
                        finished = true;
                    }
                    else
                    {
                        // Update block acknowledgment
                        p_seg->block_ack = block_ack;
    d27c:	6008      	str	r0, [r1, #0]
                        p_seg->nb_done = 0;

                        // Stop segment transmission timer
                        m_tb_timer_clear(&p_seg->timer_tx);
    d27e:	0020      	movs	r0, r4
                    }
                    else
                    {
                        // Update block acknowledgment
                        p_seg->block_ack = block_ack;
                        p_seg->nb_done = 0;
    d280:	33d1      	adds	r3, #209	; 0xd1
    d282:	701f      	strb	r7, [r3, #0]

                        // Stop segment transmission timer
                        m_tb_timer_clear(&p_seg->timer_tx);
    d284:	30b8      	adds	r0, #184	; 0xb8
    d286:	f008 f887 	bl	15398 <m_tb_timer_clear>
                        p_seg->tx_cursor = 0;
    d28a:	9b05      	ldr	r3, [sp, #20]
    d28c:	701f      	strb	r7, [r3, #0]

                        // Reference buffer is not on the TX queue
                        if (!under_tx)
    d28e:	42bd      	cmp	r5, r7
    d290:	d116      	bne.n	d2c0 <m_lay_ltrans_rx+0x4c8>
                        {
                            // Put the reference buffer again in TX queue
                            co_list_push_back(&p_m_lay_ltrans_env->proc_queue, &p_seg_buf->hdr);
    d292:	4c0d      	ldr	r4, [pc, #52]	; (d2c8 <m_lay_ltrans_rx+0x4d0>)
    d294:	0031      	movs	r1, r6
    d296:	6820      	ldr	r0, [r4, #0]
    d298:	3010      	adds	r0, #16
    d29a:	f7f7 f87c 	bl	4396 <co_list_push_back>
    d29e:	6823      	ldr	r3, [r4, #0]

                            // Check if segment transmission can be performed
                            if (!co_list_is_empty(&p_m_lay_ltrans_env->tx_buf_avail))
    d2a0:	689b      	ldr	r3, [r3, #8]
    d2a2:	42bb      	cmp	r3, r7
    d2a4:	d00c      	beq.n	d2c0 <m_lay_ltrans_rx+0x4c8>
                            {
                                // Transmit a segment
                                m_lay_ltrans_tx_handler();
    d2a6:	f7ff fb3f 	bl	c928 <m_lay_ltrans_tx_handler>
    d2aa:	e009      	b.n	d2c0 <m_lay_ltrans_rx+0x4c8>

                    if (block_ack == 0)
                    {
                        // Destination node cannot receive the segments, stop transmission
                        finished = true;
                        status = M_ERR_INSUFFICIENT_RESOURCES;
    d2ac:	21b0      	movs	r1, #176	; 0xb0
    d2ae:	00c9      	lsls	r1, r1, #3
    d2b0:	e000      	b.n	d2b4 <m_lay_ltrans_rx+0x4bc>
                    }
                }

                if (i < M_LAY_LTRANS_NB_SEGMENTATION)
                {
                    uint16_t status = M_ERR_NO_ERROR;
    d2b2:	0039      	movs	r1, r7

                    // Buffer usage is finished
                    if (finished)
                    {
                        // Stop Packet transmission - with corresponding status code
                        m_lay_ltrans_seg_finished(p_seg->p_buf, status, under_tx);
    d2b4:	1e6a      	subs	r2, r5, #1
    d2b6:	4195      	sbcs	r5, r2
    d2b8:	0030      	movs	r0, r6
    d2ba:	b2ea      	uxtb	r2, r5
    d2bc:	f7ff fab2 	bl	c824 <m_lay_ltrans_seg_finished>

            // Forward packet to the upper transport layer
            p_m_lay_ltrans_env->p_cb->rx(p_buf);
        }
    }
}
    d2c0:	b015      	add	sp, #84	; 0x54
    d2c2:	bdf0      	pop	{r4, r5, r6, r7, pc}
    d2c4:	00002710 	.word	0x00002710
    d2c8:	100126b0 	.word	0x100126b0

0000d2cc <m_lay_ltrans_init>:
 * FUNCTIONS
 ****************************************************************************************
 */

uint16_t m_lay_ltrans_init(bool reset, void *p_env)
{
    d2cc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    d2ce:	000c      	movs	r4, r1
    d2d0:	4d27      	ldr	r5, [pc, #156]	; (d370 <m_lay_ltrans_init+0xa4>)
    if (!reset)
    d2d2:	2800      	cmp	r0, #0
    d2d4:	d147      	bne.n	d366 <m_lay_ltrans_init+0x9a>
        // Initialize structures for segmentation procedures
        for (i = 0 ; i < M_LAY_LTRANS_NB_SEGMENTATION; i++)
        {
            m_lay_ltrans_segment_t *p_seg = &p_m_lay_ltrans_env->segment[i];

            p_seg->p_buf = NULL;
    d2d6:	000a      	movs	r2, r1
            p_seg->timer_tx.p_env = (void*) p_seg;
    d2d8:	000b      	movs	r3, r1
    d2da:	0026      	movs	r6, r4
    d2dc:	33c0      	adds	r3, #192	; 0xc0
        // Initialize structures for segmentation procedures
        for (i = 0 ; i < M_LAY_LTRANS_NB_SEGMENTATION; i++)
        {
            m_lay_ltrans_segment_t *p_seg = &p_m_lay_ltrans_env->segment[i];

            p_seg->p_buf = NULL;
    d2de:	32b4      	adds	r2, #180	; 0xb4
        // Counter
        uint8_t i;
        uint8_t *p_env_cursor = (uint8_t *)p_env;

        // Keep address of environment for Lower Transport Layer
        p_m_lay_ltrans_env = (m_lay_ltrans_env_t *)p_env_cursor;
    d2e0:	6029      	str	r1, [r5, #0]
        {
            m_lay_ltrans_segment_t *p_seg = &p_m_lay_ltrans_env->segment[i];

            p_seg->p_buf = NULL;
            p_seg->timer_tx.p_env = (void*) p_seg;
            p_seg->timer_tx.cb = (m_tb_timer_cb_t)m_lay_trans_seg_timer;
    d2e2:	4924      	ldr	r1, [pc, #144]	; (d374 <m_lay_ltrans_init+0xa8>)
        // Initialize structures for segmentation procedures
        for (i = 0 ; i < M_LAY_LTRANS_NB_SEGMENTATION; i++)
        {
            m_lay_ltrans_segment_t *p_seg = &p_m_lay_ltrans_env->segment[i];

            p_seg->p_buf = NULL;
    d2e4:	6010      	str	r0, [r2, #0]
            p_seg->timer_tx.p_env = (void*) p_seg;
            p_seg->timer_tx.cb = (m_tb_timer_cb_t)m_lay_trans_seg_timer;
    d2e6:	3b04      	subs	r3, #4
        for (i = 0 ; i < M_LAY_LTRANS_NB_SEGMENTATION; i++)
        {
            m_lay_ltrans_segment_t *p_seg = &p_m_lay_ltrans_env->segment[i];

            p_seg->p_buf = NULL;
            p_seg->timer_tx.p_env = (void*) p_seg;
    d2e8:	605a      	str	r2, [r3, #4]
        // Initialize structures for segmentation procedures
        for (i = 0 ; i < M_LAY_LTRANS_NB_SEGMENTATION; i++)
        {
            m_lay_ltrans_segment_t *p_seg = &p_m_lay_ltrans_env->segment[i];

            p_seg->p_buf = NULL;
    d2ea:	6198      	str	r0, [r3, #24]
            p_seg->timer_tx.p_env = (void*) p_seg;
            p_seg->timer_tx.cb = (m_tb_timer_cb_t)m_lay_trans_seg_timer;
    d2ec:	6019      	str	r1, [r3, #0]
        for (i = 0 ; i < M_LAY_LTRANS_NB_SEGMENTATION; i++)
        {
            m_lay_ltrans_segment_t *p_seg = &p_m_lay_ltrans_env->segment[i];

            p_seg->p_buf = NULL;
            p_seg->timer_tx.p_env = (void*) p_seg;
    d2ee:	36e0      	adds	r6, #224	; 0xe0
        // Initialize structures for segmentation procedures
        for (i = 0 ; i < M_LAY_LTRANS_NB_SEGMENTATION; i++)
        {
            m_lay_ltrans_segment_t *p_seg = &p_m_lay_ltrans_env->segment[i];

            p_seg->p_buf = NULL;
    d2f0:	3318      	adds	r3, #24
            p_seg->timer_tx.p_env = (void*) p_seg;
    d2f2:	6033      	str	r3, [r6, #0]
        {
            m_lay_ltrans_reassembly_t *p_reas =  &p_m_lay_ltrans_env->reassembly[i];

            p_reas->p_buf = NULL;
            p_reas->timer_ack.p_env = (void *)p_reas;
            p_reas->timer_ack.cb = (m_tb_timer_cb_t)m_lay_trans_ack_timer;
    d2f4:	4f20      	ldr	r7, [pc, #128]	; (d378 <m_lay_ltrans_init+0xac>)
        {
            m_lay_ltrans_segment_t *p_seg = &p_m_lay_ltrans_env->segment[i];

            p_seg->p_buf = NULL;
            p_seg->timer_tx.p_env = (void*) p_seg;
            p_seg->timer_tx.cb = (m_tb_timer_cb_t)m_lay_trans_seg_timer;
    d2f6:	6099      	str	r1, [r3, #8]

            p_reas->p_buf = NULL;
            p_reas->timer_ack.p_env = (void *)p_reas;
            p_reas->timer_ack.cb = (m_tb_timer_cb_t)m_lay_trans_ack_timer;
            p_reas->timer_incomp.p_env = (void *)p_reas;
            p_reas->timer_incomp.cb = (m_tb_timer_cb_t)m_lay_trans_incomp_timer;
    d2f8:	4920      	ldr	r1, [pc, #128]	; (d37c <m_lay_ltrans_init+0xb0>)
    d2fa:	3bbc      	subs	r3, #188	; 0xbc
        // Initialize structures for reassembly procedures
        for (i = 0 ; i < M_LAY_LTRANS_NB_REASSEMBLY; i++)
        {
            m_lay_ltrans_reassembly_t *p_reas =  &p_m_lay_ltrans_env->reassembly[i];

            p_reas->p_buf = NULL;
    d2fc:	6018      	str	r0, [r3, #0]
            p_reas->timer_ack.p_env = (void *)p_reas;
    d2fe:	621b      	str	r3, [r3, #32]
            p_reas->timer_ack.cb = (m_tb_timer_cb_t)m_lay_trans_ack_timer;
    d300:	61df      	str	r7, [r3, #28]
            p_reas->timer_incomp.p_env = (void *)p_reas;
    d302:	60db      	str	r3, [r3, #12]
            p_reas->timer_incomp.cb = (m_tb_timer_cb_t)m_lay_trans_incomp_timer;
    d304:	6099      	str	r1, [r3, #8]
    d306:	3334      	adds	r3, #52	; 0x34
        // Initialize structures for reassembly procedures
        for (i = 0 ; i < M_LAY_LTRANS_NB_REASSEMBLY; i++)
        {
            m_lay_ltrans_reassembly_t *p_reas =  &p_m_lay_ltrans_env->reassembly[i];

            p_reas->p_buf = NULL;
    d308:	2600      	movs	r6, #0
            p_seg->timer_tx.p_env = (void*) p_seg;
            p_seg->timer_tx.cb = (m_tb_timer_cb_t)m_lay_trans_seg_timer;
        }

        // Initialize structures for reassembly procedures
        for (i = 0 ; i < M_LAY_LTRANS_NB_REASSEMBLY; i++)
    d30a:	429a      	cmp	r2, r3
    d30c:	d1f6      	bne.n	d2fc <m_lay_ltrans_init+0x30>
            p_reas->timer_incomp.p_env = (void *)p_reas;
            p_reas->timer_incomp.cb = (m_tb_timer_cb_t)m_lay_trans_incomp_timer;
        }

        // Initialize filtering list
        memset(p_m_lay_ltrans_env->rx_filter, 0xFF,
    d30e:	0020      	movs	r0, r4
    d310:	2230      	movs	r2, #48	; 0x30
    d312:	21ff      	movs	r1, #255	; 0xff
    d314:	30f4      	adds	r0, #244	; 0xf4
    d316:	f008 fb99 	bl	15a4c <memset>
               sizeof(m_lay_ltrans_filter_t) * M_LAY_LTRANS_NB_SEGMENT_FILTER);
        p_m_lay_ltrans_env->rx_filter_cursor = 0;
    d31a:	2392      	movs	r3, #146	; 0x92

        // Initialize procedure queue
        co_list_init(&p_m_lay_ltrans_env->proc_queue);
    d31c:	0020      	movs	r0, r4
        }

        // Initialize filtering list
        memset(p_m_lay_ltrans_env->rx_filter, 0xFF,
               sizeof(m_lay_ltrans_filter_t) * M_LAY_LTRANS_NB_SEGMENT_FILTER);
        p_m_lay_ltrans_env->rx_filter_cursor = 0;
    d31e:	005b      	lsls	r3, r3, #1
    d320:	54e6      	strb	r6, [r4, r3]

        // Initialize procedure queue
        co_list_init(&p_m_lay_ltrans_env->proc_queue);
    d322:	3010      	adds	r0, #16
    d324:	f7f6 fffc 	bl	4320 <co_list_init>

        // Initialize buffers
        co_list_init(&p_m_lay_ltrans_env->tx_buf_avail);
    d328:	6828      	ldr	r0, [r5, #0]
        {
            m_tb_buf_t *p_buf = (m_tb_buf_t *)p_env_cursor;
            p_env_cursor += CO_ALIGN4_HI(sizeof(m_tb_buf_t) + M_TB_BUF_SMALL_SIZE);

            // Initialize buffers
            p_buf->block_id = M_LAY_LTRANS_TX_BUF_BLOCK_ID;
    d32a:	27fe      	movs	r7, #254	; 0xfe

        // Initialize procedure queue
        co_list_init(&p_m_lay_ltrans_env->proc_queue);

        // Initialize buffers
        co_list_init(&p_m_lay_ltrans_env->tx_buf_avail);
    d32c:	3008      	adds	r0, #8
    d32e:	f7f6 fff7 	bl	4320 <co_list_init>
        {
            m_tb_buf_t *p_buf = (m_tb_buf_t *)p_env_cursor;
            p_env_cursor += CO_ALIGN4_HI(sizeof(m_tb_buf_t) + M_TB_BUF_SMALL_SIZE);

            // Initialize buffers
            p_buf->block_id = M_LAY_LTRANS_TX_BUF_BLOCK_ID;
    d332:	0021      	movs	r1, r4
            p_buf->buf_id = i;
            p_buf->buf_len = M_TB_BUF_SMALL_SIZE;
    d334:	2320      	movs	r3, #32
        {
            m_tb_buf_t *p_buf = (m_tb_buf_t *)p_env_cursor;
            p_env_cursor += CO_ALIGN4_HI(sizeof(m_tb_buf_t) + M_TB_BUF_SMALL_SIZE);

            // Initialize buffers
            p_buf->block_id = M_LAY_LTRANS_TX_BUF_BLOCK_ID;
    d336:	3129      	adds	r1, #41	; 0x29
    d338:	31ff      	adds	r1, #255	; 0xff
            p_buf->pattern = M_TB_BUF_DBG_PATTERN;
            #endif //(BLE_MESH_DBG)
            p_buf->acq_cnt = 1;

            // put buffer in TX queue
            co_list_push_back(&p_m_lay_ltrans_env->tx_buf_avail,&p_buf->hdr);
    d33a:	6828      	ldr	r0, [r5, #0]
            m_tb_buf_t *p_buf = (m_tb_buf_t *)p_env_cursor;
            p_env_cursor += CO_ALIGN4_HI(sizeof(m_tb_buf_t) + M_TB_BUF_SMALL_SIZE);

            // Initialize buffers
            p_buf->block_id = M_LAY_LTRANS_TX_BUF_BLOCK_ID;
            p_buf->buf_id = i;
    d33c:	734e      	strb	r6, [r1, #13]
            p_buf->buf_len = M_TB_BUF_SMALL_SIZE;
            #if (BLE_MESH_DBG)
            p_buf->pattern = M_TB_BUF_DBG_PATTERN;
            #endif //(BLE_MESH_DBG)
            p_buf->acq_cnt = 1;
    d33e:	3601      	adds	r6, #1
        {
            m_tb_buf_t *p_buf = (m_tb_buf_t *)p_env_cursor;
            p_env_cursor += CO_ALIGN4_HI(sizeof(m_tb_buf_t) + M_TB_BUF_SMALL_SIZE);

            // Initialize buffers
            p_buf->block_id = M_LAY_LTRANS_TX_BUF_BLOCK_ID;
    d340:	730f      	strb	r7, [r1, #12]
            p_buf->buf_id = i;
            p_buf->buf_len = M_TB_BUF_SMALL_SIZE;
    d342:	814b      	strh	r3, [r1, #10]
            #if (BLE_MESH_DBG)
            p_buf->pattern = M_TB_BUF_DBG_PATTERN;
            #endif //(BLE_MESH_DBG)
            p_buf->acq_cnt = 1;
    d344:	738e      	strb	r6, [r1, #14]

            // put buffer in TX queue
            co_list_push_back(&p_m_lay_ltrans_env->tx_buf_avail,&p_buf->hdr);
    d346:	3008      	adds	r0, #8
    d348:	f7f7 f825 	bl	4396 <co_list_push_back>
        {
            m_tb_buf_t *p_buf = (m_tb_buf_t *)p_env_cursor;
            p_env_cursor += CO_ALIGN4_HI(sizeof(m_tb_buf_t) + M_TB_BUF_SMALL_SIZE);

            // Initialize buffers
            p_buf->block_id = M_LAY_LTRANS_TX_BUF_BLOCK_ID;
    d34c:	0021      	movs	r1, r4
            p_buf->buf_id = i;
            p_buf->buf_len = M_TB_BUF_SMALL_SIZE;
    d34e:	2320      	movs	r3, #32
            p_buf->pattern = M_TB_BUF_DBG_PATTERN;
            #endif //(BLE_MESH_DBG)
            p_buf->acq_cnt = 1;

            // put buffer in TX queue
            co_list_push_back(&p_m_lay_ltrans_env->tx_buf_avail,&p_buf->hdr);
    d350:	6828      	ldr	r0, [r5, #0]
        {
            m_tb_buf_t *p_buf = (m_tb_buf_t *)p_env_cursor;
            p_env_cursor += CO_ALIGN4_HI(sizeof(m_tb_buf_t) + M_TB_BUF_SMALL_SIZE);

            // Initialize buffers
            p_buf->block_id = M_LAY_LTRANS_TX_BUF_BLOCK_ID;
    d352:	3179      	adds	r1, #121	; 0x79
    d354:	31ff      	adds	r1, #255	; 0xff
    d356:	730f      	strb	r7, [r1, #12]
            p_buf->buf_id = i;
    d358:	734e      	strb	r6, [r1, #13]
            p_buf->buf_len = M_TB_BUF_SMALL_SIZE;
    d35a:	814b      	strh	r3, [r1, #10]
            #if (BLE_MESH_DBG)
            p_buf->pattern = M_TB_BUF_DBG_PATTERN;
            #endif //(BLE_MESH_DBG)
            p_buf->acq_cnt = 1;
    d35c:	738e      	strb	r6, [r1, #14]

            // put buffer in TX queue
            co_list_push_back(&p_m_lay_ltrans_env->tx_buf_avail,&p_buf->hdr);
    d35e:	3008      	adds	r0, #8
    d360:	f7f7 f819 	bl	4396 <co_list_push_back>
    d364:	e001      	b.n	d36a <m_lay_ltrans_init+0x9e>
        }
    }
    else
    {
        p_m_lay_ltrans_env = NULL;
    d366:	2300      	movs	r3, #0
    d368:	602b      	str	r3, [r5, #0]
    }

    return (sizeof(m_lay_ltrans_env_t)
            + CO_ALIGN4_HI(sizeof(m_tb_buf_t) + M_TB_BUF_SMALL_SIZE) * M_LAY_LTRANS_NB_TX_BUFFER);
}
    d36a:	20e4      	movs	r0, #228	; 0xe4
    d36c:	0040      	lsls	r0, r0, #1
    d36e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    d370:	100126b0 	.word	0x100126b0
    d374:	0000cbfd 	.word	0x0000cbfd
    d378:	0000cc71 	.word	0x0000cc71
    d37c:	0000cc3d 	.word	0x0000cc3d

0000d380 <m_lay_ltrans_get_env_size>:

uint16_t m_lay_ltrans_get_env_size(const m_cfg_t* p_cfg)
{
    return (sizeof(m_lay_ltrans_env_t)
            + CO_ALIGN4_HI(sizeof(m_tb_buf_t) + M_TB_BUF_SMALL_SIZE) * M_LAY_LTRANS_NB_TX_BUFFER);
}
    d380:	20e4      	movs	r0, #228	; 0xe4
    d382:	0040      	lsls	r0, r0, #1
    d384:	4770      	bx	lr

0000d386 <m_lay_ltrans_connect_api_net>:

void m_lay_ltrans_connect_api_net(const m_lay_net_api_t *p_api)
{
    p_m_lay_ltrans_env->p_net_api = p_api;
    d386:	4b02      	ldr	r3, [pc, #8]	; (d390 <m_lay_ltrans_connect_api_net+0xa>)
    d388:	681b      	ldr	r3, [r3, #0]
    d38a:	6058      	str	r0, [r3, #4]
}
    d38c:	4770      	bx	lr
    d38e:	46c0      	nop			; (mov r8, r8)
    d390:	100126b0 	.word	0x100126b0

0000d394 <m_lay_ltrans_connect_cb>:

void m_lay_ltrans_connect_cb(const m_lay_ltrans_cb_t *p_cb)
{
    p_m_lay_ltrans_env->p_cb = p_cb;
    d394:	4b01      	ldr	r3, [pc, #4]	; (d39c <m_lay_ltrans_connect_cb+0x8>)
    d396:	681b      	ldr	r3, [r3, #0]
    d398:	6018      	str	r0, [r3, #0]
}
    d39a:	4770      	bx	lr
    d39c:	100126b0 	.word	0x100126b0

0000d3a0 <co_bswap24>:
 * @return The 24 bit swapped value.
 ****************************************************************************************
 */
__INLINE_S__ uint32_t co_bswap24(uint32_t val24)
{
    return ((val24<<16)&0xFF0000) | ((val24)&0xFF00) | ((val24>>16)&0xFF);
    d3a0:	23ff      	movs	r3, #255	; 0xff
    d3a2:	0402      	lsls	r2, r0, #16
    d3a4:	041b      	lsls	r3, r3, #16
    d3a6:	401a      	ands	r2, r3
    d3a8:	0c03      	lsrs	r3, r0, #16
    d3aa:	b2db      	uxtb	r3, r3
    d3ac:	431a      	orrs	r2, r3
    d3ae:	23ff      	movs	r3, #255	; 0xff
    d3b0:	021b      	lsls	r3, r3, #8
    d3b2:	4018      	ands	r0, r3
    d3b4:	4310      	orrs	r0, r2
}
    d3b6:	4770      	bx	lr

0000d3b8 <m_lay_net_check_encrypt_queue>:
 * start either encryption or desobfuscation depending on buffer processing type.
 ****************************************************************************************
 */
__STATIC void m_lay_net_check_encrypt_queue(void)
{
	M_PRINTF(L_NET, "");
    d3b8:	4b17      	ldr	r3, [pc, #92]	; (d418 <m_lay_net_check_encrypt_queue+0x60>)
 * @brief Take first entry in the encryption queue and push security token in order to
 * start either encryption or desobfuscation depending on buffer processing type.
 ****************************************************************************************
 */
__STATIC void m_lay_net_check_encrypt_queue(void)
{
    d3ba:	b513      	push	{r0, r1, r4, lr}
	M_PRINTF(L_NET, "");
    d3bc:	681b      	ldr	r3, [r3, #0]
    d3be:	06db      	lsls	r3, r3, #27
    d3c0:	d515      	bpl.n	d3ee <m_lay_net_check_encrypt_queue+0x36>
    d3c2:	4c16      	ldr	r4, [pc, #88]	; (d41c <m_lay_net_check_encrypt_queue+0x64>)
    d3c4:	0023      	movs	r3, r4
    d3c6:	333c      	adds	r3, #60	; 0x3c
    d3c8:	9300      	str	r3, [sp, #0]
    d3ca:	0022      	movs	r2, r4
    d3cc:	0020      	movs	r0, r4
    d3ce:	239c      	movs	r3, #156	; 0x9c
    d3d0:	0021      	movs	r1, r4
    d3d2:	3221      	adds	r2, #33	; 0x21
    d3d4:	33ff      	adds	r3, #255	; 0xff
    d3d6:	302d      	adds	r0, #45	; 0x2d
    d3d8:	f7f7 fae8 	bl	49ac <m_print>
    d3dc:	0020      	movs	r0, r4
    d3de:	305a      	adds	r0, #90	; 0x5a
    d3e0:	f7f7 fae4 	bl	49ac <m_print>
    d3e4:	0020      	movs	r0, r4
    d3e6:	1da1      	adds	r1, r4, #6
    d3e8:	305b      	adds	r0, #91	; 0x5b
    d3ea:	f7f7 fadf 	bl	49ac <m_print>
    // Get first buffer in the encryption queue
    m_tb_buf_t *p_buf = (m_tb_buf_t *)co_list_pick(&p_m_lay_net_env->encrypt_queue);
    d3ee:	4b0c      	ldr	r3, [pc, #48]	; (d420 <m_lay_net_check_encrypt_queue+0x68>)
    d3f0:	681b      	ldr	r3, [r3, #0]
    d3f2:	689b      	ldr	r3, [r3, #8]

    if (p_buf)
    d3f4:	2b00      	cmp	r3, #0
    d3f6:	d00d      	beq.n	d414 <m_lay_net_check_encrypt_queue+0x5c>
        // Can take either m_lay_net_buf_env_t or m_lay_buf_env_t as flags value has the same
        // position
        m_lay_buf_env_t *p_env = (m_lay_buf_env_t *)&p_buf->env[0];

        // Push the security token
        if (!GETB(p_env->flags, M_LAY_BUF_RX))
    d3f8:	7c1b      	ldrb	r3, [r3, #16]
    d3fa:	07db      	lsls	r3, r3, #31
    d3fc:	d405      	bmi.n	d40a <m_lay_net_check_encrypt_queue+0x52>
        {
            // Request to start encryption
            m_tb_sec_ccm_enc_start(M_TB_SEC_TOKEN_NETWORK, m_lay_net_ccm_enc_ready_cb,
    d3fe:	4a09      	ldr	r2, [pc, #36]	; (d424 <m_lay_net_check_encrypt_queue+0x6c>)
    d400:	4909      	ldr	r1, [pc, #36]	; (d428 <m_lay_net_check_encrypt_queue+0x70>)
    d402:	2003      	movs	r0, #3
    d404:	f006 fe00 	bl	14008 <m_tb_sec_ccm_enc_start>
    d408:	e004      	b.n	d414 <m_lay_net_check_encrypt_queue+0x5c>
                                                           m_lay_net_ccm_enc_finished_cb);
        }
        else
        {
            // Request to start desobfuscation
            m_tb_sec_aes_start(M_TB_SEC_TOKEN_NETWORK, m_lay_net_desobfusc_ready_cb,
    d40a:	4a08      	ldr	r2, [pc, #32]	; (d42c <m_lay_net_check_encrypt_queue+0x74>)
    d40c:	4908      	ldr	r1, [pc, #32]	; (d430 <m_lay_net_check_encrypt_queue+0x78>)
    d40e:	2003      	movs	r0, #3
    d410:	f006 fdc0 	bl	13f94 <m_tb_sec_aes_start>
                                                       m_lay_net_desobfusc_finished_cb);
        }
    }
}
    d414:	bd13      	pop	{r0, r1, r4, pc}
    d416:	46c0      	nop			; (mov r8, r8)
    d418:	10010514 	.word	0x10010514
    d41c:	000219b0 	.word	0x000219b0
    d420:	100126b4 	.word	0x100126b4
    d424:	0000d641 	.word	0x0000d641
    d428:	0000d53d 	.word	0x0000d53d
    d42c:	0000d995 	.word	0x0000d995
    d430:	0000d901 	.word	0x0000d901

0000d434 <m_lay_net_encrypt_err>:
 * @param[in] status        Error status
 ****************************************************************************************
 */
__STATIC void m_lay_net_encrypt_err(m_tb_buf_t *p_buf_ltrans, uint16_t status)
{
	M_PRINTF(L_NET, "----encryot error----");
    d434:	4b1a      	ldr	r3, [pc, #104]	; (d4a0 <m_lay_net_encrypt_err+0x6c>)
 * @param[in] p_buf_ltrans  Pointer to buffer containing lower transport PDU
 * @param[in] status        Error status
 ****************************************************************************************
 */
__STATIC void m_lay_net_encrypt_err(m_tb_buf_t *p_buf_ltrans, uint16_t status)
{
    d436:	b573      	push	{r0, r1, r4, r5, r6, lr}
	M_PRINTF(L_NET, "----encryot error----");
    d438:	681b      	ldr	r3, [r3, #0]
 * @param[in] p_buf_ltrans  Pointer to buffer containing lower transport PDU
 * @param[in] status        Error status
 ****************************************************************************************
 */
__STATIC void m_lay_net_encrypt_err(m_tb_buf_t *p_buf_ltrans, uint16_t status)
{
    d43a:	0005      	movs	r5, r0
    d43c:	000e      	movs	r6, r1
	M_PRINTF(L_NET, "----encryot error----");
    d43e:	06db      	lsls	r3, r3, #27
    d440:	d515      	bpl.n	d46e <m_lay_net_encrypt_err+0x3a>
    d442:	4c18      	ldr	r4, [pc, #96]	; (d4a4 <m_lay_net_encrypt_err+0x70>)
    d444:	0023      	movs	r3, r4
    d446:	335e      	adds	r3, #94	; 0x5e
    d448:	9300      	str	r3, [sp, #0]
    d44a:	0022      	movs	r2, r4
    d44c:	0020      	movs	r0, r4
    d44e:	23c4      	movs	r3, #196	; 0xc4
    d450:	0021      	movs	r1, r4
    d452:	3221      	adds	r2, #33	; 0x21
    d454:	33ff      	adds	r3, #255	; 0xff
    d456:	302d      	adds	r0, #45	; 0x2d
    d458:	f7f7 faa8 	bl	49ac <m_print>
    d45c:	0020      	movs	r0, r4
    d45e:	3074      	adds	r0, #116	; 0x74
    d460:	f7f7 faa4 	bl	49ac <m_print>
    d464:	0020      	movs	r0, r4
    d466:	1da1      	adds	r1, r4, #6
    d468:	305b      	adds	r0, #91	; 0x5b
    d46a:	f7f7 fa9f 	bl	49ac <m_print>
    // Get pointer to buffer environment
    m_lay_buf_env_t *p_env_ltrans = (m_lay_buf_env_t *)&p_buf_ltrans->env[0];

    if (p_env_ltrans->p_buf_2)
    d46e:	6aa8      	ldr	r0, [r5, #40]	; 0x28
    d470:	2800      	cmp	r0, #0
    d472:	d001      	beq.n	d478 <m_lay_net_encrypt_err+0x44>
    {
        // Release the buffer containing the network PDU
        m_tb_buf_release(p_env_ltrans->p_buf_2);
    d474:	f004 f912 	bl	1169c <m_tb_buf_release>
    }

    #if (BLE_MESH_RELAY)
    // Check if message was a relayed message
    if (!GETB(p_env_ltrans->flags, M_LAY_BUF_RELAY))
    d478:	7c2b      	ldrb	r3, [r5, #16]
    d47a:	071b      	lsls	r3, r3, #28
    d47c:	d40a      	bmi.n	d494 <m_lay_net_encrypt_err+0x60>
    #endif //(BLE_MESH_RELAY)
    {
        // Inform the lower transport layer that its PDU has not been transmitted
        p_m_lay_net_env->p_cb[p_env_ltrans->u14.intf_idx_net]->sent(p_buf_ltrans, status);
    d47e:	4b0a      	ldr	r3, [pc, #40]	; (d4a8 <m_lay_net_encrypt_err+0x74>)
    d480:	0031      	movs	r1, r6
    d482:	681a      	ldr	r2, [r3, #0]
    d484:	002b      	movs	r3, r5
    d486:	332c      	adds	r3, #44	; 0x2c
    d488:	781b      	ldrb	r3, [r3, #0]
    d48a:	0028      	movs	r0, r5
    d48c:	009b      	lsls	r3, r3, #2
    d48e:	589b      	ldr	r3, [r3, r2]
    d490:	681b      	ldr	r3, [r3, #0]
    d492:	4798      	blx	r3
    }

    // Release the buffer containing the lower transport PDU
    m_tb_buf_release(p_buf_ltrans);
    d494:	0028      	movs	r0, r5
    d496:	f004 f901 	bl	1169c <m_tb_buf_release>

    // Handle next buffer in the encryption queue
    m_lay_net_check_encrypt_queue();
    d49a:	f7ff ff8d 	bl	d3b8 <m_lay_net_check_encrypt_queue>
}
    d49e:	bd73      	pop	{r0, r1, r4, r5, r6, pc}
    d4a0:	10010514 	.word	0x10010514
    d4a4:	000219b0 	.word	0x000219b0
    d4a8:	100126b4 	.word	0x100126b4

0000d4ac <m_lay_net_decrypt_err>:
 * @param[in] p_buf_net  Pointer to buffer containing network PDU
 ****************************************************************************************
 */
__STATIC void m_lay_net_decrypt_err(m_tb_buf_t *p_buf_net)
{
	M_PRINTF(L_NET, "----decryot error----");
    d4ac:	4b1f      	ldr	r3, [pc, #124]	; (d52c <m_lay_net_decrypt_err+0x80>)
 *
 * @param[in] p_buf_net  Pointer to buffer containing network PDU
 ****************************************************************************************
 */
__STATIC void m_lay_net_decrypt_err(m_tb_buf_t *p_buf_net)
{
    d4ae:	b573      	push	{r0, r1, r4, r5, r6, lr}
	M_PRINTF(L_NET, "----decryot error----");
    d4b0:	681b      	ldr	r3, [r3, #0]
 *
 * @param[in] p_buf_net  Pointer to buffer containing network PDU
 ****************************************************************************************
 */
__STATIC void m_lay_net_decrypt_err(m_tb_buf_t *p_buf_net)
{
    d4b2:	0005      	movs	r5, r0
	M_PRINTF(L_NET, "----decryot error----");
    d4b4:	06db      	lsls	r3, r3, #27
    d4b6:	d516      	bpl.n	d4e6 <m_lay_net_decrypt_err+0x3a>
    d4b8:	4e1d      	ldr	r6, [pc, #116]	; (d530 <m_lay_net_decrypt_err+0x84>)
    d4ba:	4c1e      	ldr	r4, [pc, #120]	; (d534 <m_lay_net_decrypt_err+0x88>)
    d4bc:	0033      	movs	r3, r6
    d4be:	330a      	adds	r3, #10
    d4c0:	9300      	str	r3, [sp, #0]
    d4c2:	0022      	movs	r2, r4
    d4c4:	0020      	movs	r0, r4
    d4c6:	23f3      	movs	r3, #243	; 0xf3
    d4c8:	0021      	movs	r1, r4
    d4ca:	3221      	adds	r2, #33	; 0x21
    d4cc:	005b      	lsls	r3, r3, #1
    d4ce:	302d      	adds	r0, #45	; 0x2d
    d4d0:	f7f7 fa6c 	bl	49ac <m_print>
    d4d4:	0030      	movs	r0, r6
    d4d6:	3020      	adds	r0, #32
    d4d8:	f7f7 fa68 	bl	49ac <m_print>
    d4dc:	0020      	movs	r0, r4
    d4de:	1da1      	adds	r1, r4, #6
    d4e0:	305b      	adds	r0, #91	; 0x5b
    d4e2:	f7f7 fa63 	bl	49ac <m_print>
    // Get pointer to buffer environment in the network buffer
    m_lay_bearer_buf_env_t *p_env_net = (m_lay_bearer_buf_env_t *)&p_buf_net->env[0];
    // Extract NID value
    uint8_t nid = GETF(*(M_TB_BUF_DATA(p_buf_net) + M_LAY_NET_HEAD_IVI_NID_POS), M_LAY_NET_IVI_NID_NID);
    d4e6:	88ab      	ldrh	r3, [r5, #4]
    // Friend node (decrypted using friendship security credential) are accepted
    if (!m_tb_state_get_lpn_state())
    #endif //(BLE_MESH_LPN)
    {
        // Check if NID is known (master security credentials)
        p_env_net->u9.net_key_lid = m_tb_key_net_lid_from_nid(nid, p_env_net->nb_dec_attempts);
    d4e8:	1cac      	adds	r4, r5, #2
{
	M_PRINTF(L_NET, "----decryot error----");
    // Get pointer to buffer environment in the network buffer
    m_lay_bearer_buf_env_t *p_env_net = (m_lay_bearer_buf_env_t *)&p_buf_net->env[0];
    // Extract NID value
    uint8_t nid = GETF(*(M_TB_BUF_DATA(p_buf_net) + M_LAY_NET_HEAD_IVI_NID_POS), M_LAY_NET_IVI_NID_NID);
    d4ea:	18eb      	adds	r3, r5, r3
    d4ec:	3330      	adds	r3, #48	; 0x30
    // Friend node (decrypted using friendship security credential) are accepted
    if (!m_tb_state_get_lpn_state())
    #endif //(BLE_MESH_LPN)
    {
        // Check if NID is known (master security credentials)
        p_env_net->u9.net_key_lid = m_tb_key_net_lid_from_nid(nid, p_env_net->nb_dec_attempts);
    d4ee:	7818      	ldrb	r0, [r3, #0]
    d4f0:	237f      	movs	r3, #127	; 0x7f
    d4f2:	7fe1      	ldrb	r1, [r4, #31]
    d4f4:	4018      	ands	r0, r3
    d4f6:	f004 ff93 	bl	12420 <m_tb_key_net_lid_from_nid>
    d4fa:	1ceb      	adds	r3, r5, #3
    d4fc:	77d8      	strb	r0, [r3, #31]
        p_env_net->u9.net_key_lid = m_tb_key_friend_net_lid_from_nid(nid, p_env_net->nb_dec_attempts,
                                                                     &p_env_net->friend_lid);
    }
    #endif //(BLE_MESH_FRIEND || BLE_MESH_LPN)

    if (p_env_net->u9.net_key_lid != M_INVALID_LID)
    d4fe:	28ff      	cmp	r0, #255	; 0xff
    d500:	d003      	beq.n	d50a <m_lay_net_decrypt_err+0x5e>
    {
        // Increase number of decryption attempts
        p_env_net->nb_dec_attempts++;
    d502:	7fe3      	ldrb	r3, [r4, #31]
    d504:	3301      	adds	r3, #1
    d506:	77e3      	strb	r3, [r4, #31]
    d508:	e00c      	b.n	d524 <m_lay_net_decrypt_err+0x78>
    }
    else
    {
        // Remove the buffer from the encryption queue
        co_list_pop_front(&p_m_lay_net_env->encrypt_queue);
    d50a:	4b0b      	ldr	r3, [pc, #44]	; (d538 <m_lay_net_decrypt_err+0x8c>)
    d50c:	6818      	ldr	r0, [r3, #0]
    d50e:	3008      	adds	r0, #8
    d510:	f7f6 ff6c 	bl	43ec <co_list_pop_front>

        if (p_env_net->p_buf)
    d514:	6968      	ldr	r0, [r5, #20]
    d516:	2800      	cmp	r0, #0
    d518:	d001      	beq.n	d51e <m_lay_net_decrypt_err+0x72>
        {
            // Release the buffer containing the lower transport PDU
            m_tb_buf_release(p_env_net->p_buf);
    d51a:	f004 f8bf 	bl	1169c <m_tb_buf_release>
        }

        // Release the buffer containing the network PDU
        m_tb_buf_release(p_buf_net);
    d51e:	0028      	movs	r0, r5
    d520:	f004 f8bc 	bl	1169c <m_tb_buf_release>
    }

    // Handle next buffer in the encryption queue
    m_lay_net_check_encrypt_queue();
    d524:	f7ff ff48 	bl	d3b8 <m_lay_net_check_encrypt_queue>
}
    d528:	bd73      	pop	{r0, r1, r4, r5, r6, pc}
    d52a:	46c0      	nop			; (mov r8, r8)
    d52c:	10010514 	.word	0x10010514
    d530:	00021a30 	.word	0x00021a30
    d534:	000219b0 	.word	0x000219b0
    d538:	100126b4 	.word	0x100126b4

0000d53c <m_lay_net_ccm_enc_ready_cb>:
 */
__STATIC uint16_t m_lay_net_ccm_enc_ready_cb(uint8_t token_id, const uint8_t **pp_key, const uint8_t **pp_nonce,
                                            const uint8_t **pp_msg, uint8_t **pp_cipher, uint16_t *p_msg_len,
                                            uint8_t *p_mic_len, const uint8_t **pp_auth_data,
                                            uint8_t *p_auth_data_len)
{
    d53c:	b5f0      	push	{r4, r5, r6, r7, lr}
    d53e:	b089      	sub	sp, #36	; 0x24
    d540:	9305      	str	r3, [sp, #20]
    // Status
    uint16_t status;

    // Sanity check
    ASSERT_INFO(co_list_pick(&p_m_lay_net_env->encrypt_queue), 0, 0);
    d542:	4b3e      	ldr	r3, [pc, #248]	; (d63c <m_lay_net_ccm_enc_ready_cb+0x100>)
 */
__STATIC uint16_t m_lay_net_ccm_enc_ready_cb(uint8_t token_id, const uint8_t **pp_key, const uint8_t **pp_nonce,
                                            const uint8_t **pp_msg, uint8_t **pp_cipher, uint16_t *p_msg_len,
                                            uint8_t *p_mic_len, const uint8_t **pp_auth_data,
                                            uint8_t *p_auth_data_len)
{
    d544:	9103      	str	r1, [sp, #12]
    // Status
    uint16_t status;

    // Sanity check
    ASSERT_INFO(co_list_pick(&p_m_lay_net_env->encrypt_queue), 0, 0);
    d546:	681b      	ldr	r3, [r3, #0]
 */
__STATIC uint16_t m_lay_net_ccm_enc_ready_cb(uint8_t token_id, const uint8_t **pp_key, const uint8_t **pp_nonce,
                                            const uint8_t **pp_msg, uint8_t **pp_cipher, uint16_t *p_msg_len,
                                            uint8_t *p_mic_len, const uint8_t **pp_auth_data,
                                            uint8_t *p_auth_data_len)
{
    d548:	9204      	str	r2, [sp, #16]
    d54a:	689c      	ldr	r4, [r3, #8]
    // Status
    uint16_t status;

    // Sanity check
    ASSERT_INFO(co_list_pick(&p_m_lay_net_env->encrypt_queue), 0, 0);
    d54c:	2c00      	cmp	r4, #0
    d54e:	d100      	bne.n	d552 <m_lay_net_ccm_enc_ready_cb+0x16>
    d550:	e7fe      	b.n	d550 <m_lay_net_ccm_enc_ready_cb+0x14>
        // New buffer that will contain the network PDU
        m_tb_buf_t *p_buf_net;
        // Pointer to network layer related environment in the network buffer
        m_lay_bearer_buf_env_t *p_env_net;
        // Network MIC length, depends on packet type (access or control message)
        uint8_t mic_len = (p_env_ltrans->ttl_ctl & CO_BIT(M_MSG_CTL_POS))
    d552:	1c62      	adds	r2, r4, #1
    d554:	7fd2      	ldrb	r2, [r2, #31]
    d556:	2704      	movs	r7, #4
    d558:	2a7f      	cmp	r2, #127	; 0x7f
    d55a:	d900      	bls.n	d55e <m_lay_net_ccm_enc_ready_cb+0x22>
    d55c:	19ff      	adds	r7, r7, r7
                                            ? M_NMIC_CTL_LEN : M_NMIC_ACC_LEN;
        // Pointer to encryption key
        uint8_t *p_enc_key;
        // Setup bearer used for transmission
        m_lid_t bearer_lid = p_m_lay_net_env->adv_bearer_lid;
    d55e:	3380      	adds	r3, #128	; 0x80
    d560:	781b      	ldrb	r3, [r3, #0]
        #endif //(BLE_MESH_FRIEND || BLE_MESH_LPN)
        {
            // Network key information
            const m_tb_key_net_t *p_net_key;

            status = m_tb_key_net_get(p_env_ltrans->net_lid, &p_net_key, true);
    d562:	2201      	movs	r2, #1
        uint8_t mic_len = (p_env_ltrans->ttl_ctl & CO_BIT(M_MSG_CTL_POS))
                                            ? M_NMIC_CTL_LEN : M_NMIC_ACC_LEN;
        // Pointer to encryption key
        uint8_t *p_enc_key;
        // Setup bearer used for transmission
        m_lid_t bearer_lid = p_m_lay_net_env->adv_bearer_lid;
    d564:	9301      	str	r3, [sp, #4]
        #endif //(BLE_MESH_FRIEND || BLE_MESH_LPN)
        {
            // Network key information
            const m_tb_key_net_t *p_net_key;

            status = m_tb_key_net_get(p_env_ltrans->net_lid, &p_net_key, true);
    d566:	7c60      	ldrb	r0, [r4, #17]
    d568:	a907      	add	r1, sp, #28
    d56a:	f004 fed3 	bl	12314 <m_tb_key_net_get>
    d56e:	1e06      	subs	r6, r0, #0

            if (status != M_ERR_NO_ERROR)
    d570:	d160      	bne.n	d634 <m_lay_net_ccm_enc_ready_cb+0xf8>
            {
                break;
            }

            p_enc_key = (uint8_t *)&p_net_key->enc_key[0];
    d572:	9b07      	ldr	r3, [sp, #28]
        }

        // Allocate a new buffer
        status = m_tb_buf_alloc(&p_buf_net, M_BEARER_ADV_HEAD_LEN, p_buf_ltrans->data_len + mic_len, 0);
    d574:	2102      	movs	r1, #2
            if (status != M_ERR_NO_ERROR)
            {
                break;
            }

            p_enc_key = (uint8_t *)&p_net_key->enc_key[0];
    d576:	9302      	str	r3, [sp, #8]
        }

        // Allocate a new buffer
        status = m_tb_buf_alloc(&p_buf_net, M_BEARER_ADV_HEAD_LEN, p_buf_ltrans->data_len + mic_len, 0);
    d578:	8922      	ldrh	r2, [r4, #8]
    d57a:	0003      	movs	r3, r0
    d57c:	19d2      	adds	r2, r2, r7
    d57e:	b292      	uxth	r2, r2
    d580:	a807      	add	r0, sp, #28
    d582:	f003 ffd9 	bl	11538 <m_tb_buf_alloc>
    d586:	1e06      	subs	r6, r0, #0

        if (status != M_ERR_NO_ERROR)
    d588:	d154      	bne.n	d634 <m_lay_net_ccm_enc_ready_cb+0xf8>
            // Could be informed by buffer toolbox if a buffer becomes available
            break;
        }

        // Copy data from lower transport buffer in the network buffer
        m_tb_buf_copy(p_buf_ltrans, p_buf_net, p_buf_ltrans->data_len, false);
    d58a:	0003      	movs	r3, r0
    d58c:	9907      	ldr	r1, [sp, #28]
    d58e:	8922      	ldrh	r2, [r4, #8]
    d590:	0020      	movs	r0, r4
    d592:	f004 f8c5 	bl	11720 <m_tb_buf_copy>
        }
        else
        #endif // (BLE_MESH_GATT_PROXY)
        // Compute nonce value
        {
            p_m_lay_net_env->sec_buf[0] = 0;
    d596:	4b29      	ldr	r3, [pc, #164]	; (d63c <m_lay_net_ccm_enc_ready_cb+0x100>)
    d598:	681d      	ldr	r5, [r3, #0]
    d59a:	002b      	movs	r3, r5
    d59c:	3370      	adds	r3, #112	; 0x70
    d59e:	701e      	strb	r6, [r3, #0]
    d5a0:	9300      	str	r3, [sp, #0]
            p_m_lay_net_env->sec_buf[1] = p_env_ltrans->ttl_ctl;
    d5a2:	1c63      	adds	r3, r4, #1
    d5a4:	7fda      	ldrb	r2, [r3, #31]
    d5a6:	002b      	movs	r3, r5
    d5a8:	3371      	adds	r3, #113	; 0x71
    d5aa:	701a      	strb	r2, [r3, #0]
__INLINE_S__ uint32_t co_hton24(uint32_t host24)
{
    #if (!CPU_LE)
        return host24;
    #else
        return co_bswap24(host24);
    d5ac:	6960      	ldr	r0, [r4, #20]
    d5ae:	f7ff fef7 	bl	d3a0 <co_bswap24>
 */
__INLINE_S__ void co_write24p(void const *ptr24, uint32_t value)
{
    uint8_t *ptr=(uint8_t*)ptr24;

    *ptr++ = (uint8_t)(value&0xff);
    d5b2:	002b      	movs	r3, r5
    d5b4:	3372      	adds	r3, #114	; 0x72
    d5b6:	7018      	strb	r0, [r3, #0]
    *ptr++ = (uint8_t)((value&0xff00)>>8);
    d5b8:	0a02      	lsrs	r2, r0, #8
    *ptr++ = (uint8_t)((value&0xff0000)>>16);
    d5ba:	0c00      	lsrs	r0, r0, #16
__INLINE_S__ void co_write24p(void const *ptr24, uint32_t value)
{
    uint8_t *ptr=(uint8_t*)ptr24;

    *ptr++ = (uint8_t)(value&0xff);
    *ptr++ = (uint8_t)((value&0xff00)>>8);
    d5bc:	705a      	strb	r2, [r3, #1]
    *ptr++ = (uint8_t)((value&0xff0000)>>16);
    d5be:	7098      	strb	r0, [r3, #2]
        }
        co_write24p(&p_m_lay_net_env->sec_buf[2], co_hton24(p_env_ltrans->seq));
        co_write16p(&p_m_lay_net_env->sec_buf[5], co_htons(p_env_ltrans->src));
    d5c0:	8ba2      	ldrh	r2, [r4, #28]
 * @return The 16 bit swapped value.
 ****************************************************************************************
 */
__INLINE_S__ uint16_t co_bswap16(uint16_t val16)
{
    return ((val16<<8)&0xFF00) | ((val16>>8)&0xFF);
    d5c2:	0213      	lsls	r3, r2, #8
    d5c4:	0a12      	lsrs	r2, r2, #8
    d5c6:	431a      	orrs	r2, r3
    d5c8:	b213      	sxth	r3, r2
 */
__INLINE_S__ void co_write16p(void const *ptr16, uint16_t value)
{
    uint8_t *ptr=(uint8_t*)ptr16;

    *ptr++ = value&0xff;
    d5ca:	002a      	movs	r2, r5
    d5cc:	3275      	adds	r2, #117	; 0x75
    d5ce:	7013      	strb	r3, [r2, #0]
    *ptr = (value&0xff00)>>8;
    d5d0:	0a1b      	lsrs	r3, r3, #8
    d5d2:	7053      	strb	r3, [r2, #1]
        p_m_lay_net_env->sec_buf[7] = 0;
    d5d4:	002b      	movs	r3, r5
    d5d6:	3377      	adds	r3, #119	; 0x77
    d5d8:	701e      	strb	r6, [r3, #0]
        p_m_lay_net_env->sec_buf[8] = 0;
    d5da:	705e      	strb	r6, [r3, #1]
    d5dc:	69a3      	ldr	r3, [r4, #24]
    uint8_t *ptr=(uint8_t*)ptr32;

    *ptr++ = (uint8_t)(value&0xff);
    *ptr++ = (uint8_t)((value&0xff00)>>8);
    *ptr++ = (uint8_t)((value&0xff0000)>>16);
    *ptr = (uint8_t)((value&0xff000000)>>24);
    d5de:	357c      	adds	r5, #124	; 0x7c
    d5e0:	ba1b      	rev	r3, r3
__INLINE_S__ void co_write32p(void const *ptr32, uint32_t value)
{
    uint8_t *ptr=(uint8_t*)ptr32;

    *ptr++ = (uint8_t)(value&0xff);
    *ptr++ = (uint8_t)((value&0xff00)>>8);
    d5e2:	0a19      	lsrs	r1, r3, #8
 */
__INLINE_S__ void co_write32p(void const *ptr32, uint32_t value)
{
    uint8_t *ptr=(uint8_t*)ptr32;

    *ptr++ = (uint8_t)(value&0xff);
    d5e4:	7113      	strb	r3, [r2, #4]
    *ptr++ = (uint8_t)((value&0xff00)>>8);
    d5e6:	7151      	strb	r1, [r2, #5]
    *ptr++ = (uint8_t)((value&0xff0000)>>16);
    d5e8:	0c19      	lsrs	r1, r3, #16
    *ptr = (uint8_t)((value&0xff000000)>>24);
    d5ea:	0e1b      	lsrs	r3, r3, #24
{
    uint8_t *ptr=(uint8_t*)ptr32;

    *ptr++ = (uint8_t)(value&0xff);
    *ptr++ = (uint8_t)((value&0xff00)>>8);
    *ptr++ = (uint8_t)((value&0xff0000)>>16);
    d5ec:	7191      	strb	r1, [r2, #6]
    *ptr = (uint8_t)((value&0xff000000)>>24);
    d5ee:	702b      	strb	r3, [r5, #0]
            if (status != M_ERR_NO_ERROR)
            {
                break;
            }

            p_enc_key = (uint8_t *)&p_net_key->enc_key[0];
    d5f0:	9b02      	ldr	r3, [sp, #8]
        p_m_lay_net_env->sec_buf[7] = 0;
        p_m_lay_net_env->sec_buf[8] = 0;
        co_write32p(&p_m_lay_net_env->sec_buf[9], co_htonl(p_env_ltrans->u5.iv));

        // Provide the requested information
        *pp_key = p_enc_key;
    d5f2:	9a03      	ldr	r2, [sp, #12]
            if (status != M_ERR_NO_ERROR)
            {
                break;
            }

            p_enc_key = (uint8_t *)&p_net_key->enc_key[0];
    d5f4:	3312      	adds	r3, #18
        p_m_lay_net_env->sec_buf[7] = 0;
        p_m_lay_net_env->sec_buf[8] = 0;
        co_write32p(&p_m_lay_net_env->sec_buf[9], co_htonl(p_env_ltrans->u5.iv));

        // Provide the requested information
        *pp_key = p_enc_key;
    d5f6:	6013      	str	r3, [r2, #0]
        *pp_msg = M_TB_BUF_DATA(p_buf_ltrans) + M_LAY_NET_HEAD_DST_POS;
    d5f8:	88a3      	ldrh	r3, [r4, #4]
    d5fa:	9a05      	ldr	r2, [sp, #20]
    d5fc:	18e3      	adds	r3, r4, r3
    d5fe:	3337      	adds	r3, #55	; 0x37
    d600:	6013      	str	r3, [r2, #0]
        *pp_cipher = M_TB_BUF_DATA(p_buf_net) + M_LAY_NET_HEAD_DST_POS;
    d602:	9b07      	ldr	r3, [sp, #28]
    d604:	990e      	ldr	r1, [sp, #56]	; 0x38
    d606:	889a      	ldrh	r2, [r3, #4]
    d608:	189a      	adds	r2, r3, r2
    d60a:	3237      	adds	r2, #55	; 0x37
    d60c:	600a      	str	r2, [r1, #0]
        *pp_nonce = &p_m_lay_net_env->sec_buf[0];
    d60e:	9a04      	ldr	r2, [sp, #16]
    d610:	9900      	ldr	r1, [sp, #0]
    d612:	6011      	str	r1, [r2, #0]
        *p_msg_len = p_buf_ltrans->data_len - M_LAY_NET_HEAD_DST_POS;
    d614:	8922      	ldrh	r2, [r4, #8]
    d616:	990f      	ldr	r1, [sp, #60]	; 0x3c
    d618:	3a07      	subs	r2, #7
    d61a:	800a      	strh	r2, [r1, #0]
        *p_mic_len = mic_len;
    d61c:	9a10      	ldr	r2, [sp, #64]	; 0x40
    d61e:	7017      	strb	r7, [r2, #0]
        *pp_auth_data = NULL;
    d620:	9a11      	ldr	r2, [sp, #68]	; 0x44
    d622:	6016      	str	r6, [r2, #0]
        *p_auth_data_len = 0;
    d624:	9a12      	ldr	r2, [sp, #72]	; 0x48
    d626:	7016      	strb	r6, [r2, #0]

        // Link the two buffers together
        p_env_ltrans->p_buf_2 = p_buf_net;
        p_env_net = (m_lay_bearer_buf_env_t *)&p_buf_net->env[0];
        p_env_net->p_buf = p_buf_ltrans;
        p_env_net->bearer_lid = bearer_lid;
    d628:	466a      	mov	r2, sp
    d62a:	7912      	ldrb	r2, [r2, #4]
        *p_mic_len = mic_len;
        *pp_auth_data = NULL;
        *p_auth_data_len = 0;

        // Link the two buffers together
        p_env_ltrans->p_buf_2 = p_buf_net;
    d62c:	62a3      	str	r3, [r4, #40]	; 0x28
        p_env_net = (m_lay_bearer_buf_env_t *)&p_buf_net->env[0];
        p_env_net->p_buf = p_buf_ltrans;
    d62e:	615c      	str	r4, [r3, #20]
        p_env_net->bearer_lid = bearer_lid;
    d630:	745a      	strb	r2, [r3, #17]
        p_env_net->msg_type = msg_type;
    d632:	749e      	strb	r6, [r3, #18]
    } while (0);

    return (status);
}
    d634:	0030      	movs	r0, r6
    d636:	b009      	add	sp, #36	; 0x24
    d638:	bdf0      	pop	{r4, r5, r6, r7, pc}
    d63a:	46c0      	nop			; (mov r8, r8)
    d63c:	100126b4 	.word	0x100126b4

0000d640 <m_lay_net_ccm_enc_finished_cb>:
 * @param[in] p_auth_val        Pointer to computed authentication value
 ****************************************************************************************
 */
__STATIC void m_lay_net_ccm_enc_finished_cb(uint8_t token_id, uint16_t status, const uint8_t *p_auth_val)
{
	M_PRINTF(L_NET, "status = %d", status);
    d640:	4b16      	ldr	r3, [pc, #88]	; (d69c <m_lay_net_ccm_enc_finished_cb+0x5c>)
 * @param[in] status            Encryption status
 * @param[in] p_auth_val        Pointer to computed authentication value
 ****************************************************************************************
 */
__STATIC void m_lay_net_ccm_enc_finished_cb(uint8_t token_id, uint16_t status, const uint8_t *p_auth_val)
{
    d642:	b573      	push	{r0, r1, r4, r5, r6, lr}
	M_PRINTF(L_NET, "status = %d", status);
    d644:	681b      	ldr	r3, [r3, #0]
 * @param[in] status            Encryption status
 * @param[in] p_auth_val        Pointer to computed authentication value
 ****************************************************************************************
 */
__STATIC void m_lay_net_ccm_enc_finished_cb(uint8_t token_id, uint16_t status, const uint8_t *p_auth_val)
{
    d646:	000e      	movs	r6, r1
	M_PRINTF(L_NET, "status = %d", status);
    d648:	06db      	lsls	r3, r3, #27
    d64a:	d516      	bpl.n	d67a <m_lay_net_ccm_enc_finished_cb+0x3a>
    d64c:	4d14      	ldr	r5, [pc, #80]	; (d6a0 <m_lay_net_ccm_enc_finished_cb+0x60>)
    d64e:	4c15      	ldr	r4, [pc, #84]	; (d6a4 <m_lay_net_ccm_enc_finished_cb+0x64>)
    d650:	002b      	movs	r3, r5
    d652:	0022      	movs	r2, r4
    d654:	0020      	movs	r0, r4
    d656:	3336      	adds	r3, #54	; 0x36
    d658:	3221      	adds	r2, #33	; 0x21
    d65a:	9300      	str	r3, [sp, #0]
    d65c:	0021      	movs	r1, r4
    d65e:	4b12      	ldr	r3, [pc, #72]	; (d6a8 <m_lay_net_ccm_enc_finished_cb+0x68>)
    d660:	302d      	adds	r0, #45	; 0x2d
    d662:	f7f7 f9a3 	bl	49ac <m_print>
    d666:	0028      	movs	r0, r5
    d668:	0031      	movs	r1, r6
    d66a:	3054      	adds	r0, #84	; 0x54
    d66c:	f7f7 f99e 	bl	49ac <m_print>
    d670:	0020      	movs	r0, r4
    d672:	1da1      	adds	r1, r4, #6
    d674:	305b      	adds	r0, #91	; 0x5b
    d676:	f7f7 f999 	bl	49ac <m_print>
    if (status == M_ERR_NO_ERROR)
    d67a:	2e00      	cmp	r6, #0
    d67c:	d105      	bne.n	d68a <m_lay_net_ccm_enc_finished_cb+0x4a>
    {
        // Now push token for first part of obfuscation
        m_tb_sec_aes_start(M_TB_SEC_TOKEN_NETWORK, m_lay_net_obfusc_ready_cb,
    d67e:	4a0b      	ldr	r2, [pc, #44]	; (d6ac <m_lay_net_ccm_enc_finished_cb+0x6c>)
    d680:	490b      	ldr	r1, [pc, #44]	; (d6b0 <m_lay_net_ccm_enc_finished_cb+0x70>)
    d682:	2003      	movs	r0, #3
    d684:	f006 fc86 	bl	13f94 <m_tb_sec_aes_start>
    d688:	e007      	b.n	d69a <m_lay_net_ccm_enc_finished_cb+0x5a>
                                                   m_lay_net_obfusc_finished_cb);
    }
    else
    {
        // Retrieve buffer containing the lower transport PDU
        m_tb_buf_t *p_buf_ltrans = (m_tb_buf_t *)co_list_pop_front(&p_m_lay_net_env->encrypt_queue);
    d68a:	4b0a      	ldr	r3, [pc, #40]	; (d6b4 <m_lay_net_ccm_enc_finished_cb+0x74>)
    d68c:	6818      	ldr	r0, [r3, #0]
    d68e:	3008      	adds	r0, #8
    d690:	f7f6 feac 	bl	43ec <co_list_pop_front>

        // End encryption procedure
        m_lay_net_encrypt_err(p_buf_ltrans, status);
    d694:	0031      	movs	r1, r6
    d696:	f7ff fecd 	bl	d434 <m_lay_net_encrypt_err>
    }
}
    d69a:	bd73      	pop	{r0, r1, r4, r5, r6, pc}
    d69c:	10010514 	.word	0x10010514
    d6a0:	00021a30 	.word	0x00021a30
    d6a4:	000219b0 	.word	0x000219b0
    d6a8:	000002b6 	.word	0x000002b6
    d6ac:	0000d7dd 	.word	0x0000d7dd
    d6b0:	0000d6b9 	.word	0x0000d6b9
    d6b4:	100126b4 	.word	0x100126b4

0000d6b8 <m_lay_net_obfusc_ready_cb>:
 * @return Status. If returned status is M_ERR_NO_ERROR, m_lay_net_sec_finished_cb function
 * will be called once the encryption has been performed.
 ****************************************************************************************
 */
__STATIC uint16_t m_lay_net_obfusc_ready_cb(uint8_t token_id, const uint8_t **pp_key, const uint8_t **pp_val)
{
    d6b8:	b5f0      	push	{r4, r5, r6, r7, lr}
    uint16_t status;

    do
    {
        // Retrieve buffer containing the lower transport PDU
        m_tb_buf_t *p_buf_ltrans = (m_tb_buf_t *)co_list_pick(&p_m_lay_net_env->encrypt_queue);
    d6ba:	4b41      	ldr	r3, [pc, #260]	; (d7c0 <m_lay_net_obfusc_ready_cb+0x108>)
 * @return Status. If returned status is M_ERR_NO_ERROR, m_lay_net_sec_finished_cb function
 * will be called once the encryption has been performed.
 ****************************************************************************************
 */
__STATIC uint16_t m_lay_net_obfusc_ready_cb(uint8_t token_id, const uint8_t **pp_key, const uint8_t **pp_val)
{
    d6bc:	b089      	sub	sp, #36	; 0x24
    d6be:	9204      	str	r2, [sp, #16]
    d6c0:	681a      	ldr	r2, [r3, #0]
    d6c2:	000f      	movs	r7, r1
    d6c4:	6895      	ldr	r5, [r2, #8]
    d6c6:	9305      	str	r3, [sp, #20]

    do
    {
        // Retrieve buffer containing the lower transport PDU
        m_tb_buf_t *p_buf_ltrans = (m_tb_buf_t *)co_list_pick(&p_m_lay_net_env->encrypt_queue);
		if(p_buf_ltrans == NULL){
    d6c8:	2d00      	cmp	r5, #0
    d6ca:	d074      	beq.n	d7b6 <m_lay_net_obfusc_ready_cb+0xfe>
			return M_ERR_INVALID_PARAM;
		}
		M_PRINTF(L_NET, "p_buf_ltrans = %p", p_buf_ltrans);
    d6cc:	4b3d      	ldr	r3, [pc, #244]	; (d7c4 <m_lay_net_obfusc_ready_cb+0x10c>)
    d6ce:	681b      	ldr	r3, [r3, #0]
    d6d0:	06db      	lsls	r3, r3, #27
    d6d2:	d516      	bpl.n	d702 <m_lay_net_obfusc_ready_cb+0x4a>
    d6d4:	4e3c      	ldr	r6, [pc, #240]	; (d7c8 <m_lay_net_obfusc_ready_cb+0x110>)
    d6d6:	4c3d      	ldr	r4, [pc, #244]	; (d7cc <m_lay_net_obfusc_ready_cb+0x114>)
    d6d8:	0033      	movs	r3, r6
    d6da:	0022      	movs	r2, r4
    d6dc:	0020      	movs	r0, r4
    d6de:	3360      	adds	r3, #96	; 0x60
    d6e0:	3221      	adds	r2, #33	; 0x21
    d6e2:	9300      	str	r3, [sp, #0]
    d6e4:	0021      	movs	r1, r4
    d6e6:	4b3a      	ldr	r3, [pc, #232]	; (d7d0 <m_lay_net_obfusc_ready_cb+0x118>)
    d6e8:	302d      	adds	r0, #45	; 0x2d
    d6ea:	f7f7 f95f 	bl	49ac <m_print>
    d6ee:	0030      	movs	r0, r6
    d6f0:	0029      	movs	r1, r5
    d6f2:	307a      	adds	r0, #122	; 0x7a
    d6f4:	f7f7 f95a 	bl	49ac <m_print>
    d6f8:	0020      	movs	r0, r4
    d6fa:	1da1      	adds	r1, r4, #6
    d6fc:	305b      	adds	r0, #91	; 0x5b
    d6fe:	f7f7 f955 	bl	49ac <m_print>
		// Get pointer to buffer environment in the lower transport buffer
        m_lay_buf_env_t *p_env_ltrans = (m_lay_buf_env_t *)&p_buf_ltrans->env[0];
        // Get buffer containing network PDU
        m_tb_buf_t *p_buf_net = p_env_ltrans->p_buf_2;
    d702:	6aae      	ldr	r6, [r5, #40]	; 0x28
        // Pointer to start of encrypted data, 7 first bytes to be copied in privacy random value
        uint8_t *p_enc_data = M_TB_BUF_DATA(p_buf_net) + M_LAY_NET_HEAD_DST_POS;
    d704:	88b3      	ldrh	r3, [r6, #4]
    d706:	9303      	str	r3, [sp, #12]
        // Pointer to privacy key
        uint8_t *p_priv_key;
		M_PRINTF(L_NET, "p_env_ltrans->net_lid = %d", p_env_ltrans->net_lid);
    d708:	4b2e      	ldr	r3, [pc, #184]	; (d7c4 <m_lay_net_obfusc_ready_cb+0x10c>)
    d70a:	681b      	ldr	r3, [r3, #0]
    d70c:	06db      	lsls	r3, r3, #27
    d70e:	d515      	bpl.n	d73c <m_lay_net_obfusc_ready_cb+0x84>
    d710:	4c2e      	ldr	r4, [pc, #184]	; (d7cc <m_lay_net_obfusc_ready_cb+0x114>)
    d712:	4b2d      	ldr	r3, [pc, #180]	; (d7c8 <m_lay_net_obfusc_ready_cb+0x110>)
    d714:	0022      	movs	r2, r4
    d716:	0020      	movs	r0, r4
    d718:	3360      	adds	r3, #96	; 0x60
    d71a:	3221      	adds	r2, #33	; 0x21
    d71c:	9300      	str	r3, [sp, #0]
    d71e:	0021      	movs	r1, r4
    d720:	4b2c      	ldr	r3, [pc, #176]	; (d7d4 <m_lay_net_obfusc_ready_cb+0x11c>)
    d722:	302d      	adds	r0, #45	; 0x2d
    d724:	f7f7 f942 	bl	49ac <m_print>
    d728:	482b      	ldr	r0, [pc, #172]	; (d7d8 <m_lay_net_obfusc_ready_cb+0x120>)
    d72a:	7c69      	ldrb	r1, [r5, #17]
    d72c:	300c      	adds	r0, #12
    d72e:	f7f7 f93d 	bl	49ac <m_print>
    d732:	0020      	movs	r0, r4
    d734:	1da1      	adds	r1, r4, #6
    d736:	305b      	adds	r0, #91	; 0x5b
    d738:	f7f7 f938 	bl	49ac <m_print>
        #endif //(BLE_MESH_FRIEND || BLE_MESH_LPN)
        {
            // Network key information
            const m_tb_key_net_t *p_net_key;

            status = m_tb_key_net_get(p_env_ltrans->net_lid, &p_net_key, true);
    d73c:	7c68      	ldrb	r0, [r5, #17]
    d73e:	2201      	movs	r2, #1
    d740:	a907      	add	r1, sp, #28
    d742:	f004 fde7 	bl	12314 <m_tb_key_net_get>

            if (status != M_ERR_NO_ERROR)
    d746:	2800      	cmp	r0, #0
    d748:	d137      	bne.n	d7ba <m_lay_net_obfusc_ready_cb+0x102>
		// Get pointer to buffer environment in the lower transport buffer
        m_lay_buf_env_t *p_env_ltrans = (m_lay_buf_env_t *)&p_buf_ltrans->env[0];
        // Get buffer containing network PDU
        m_tb_buf_t *p_buf_net = p_env_ltrans->p_buf_2;
        // Pointer to start of encrypted data, 7 first bytes to be copied in privacy random value
        uint8_t *p_enc_data = M_TB_BUF_DATA(p_buf_net) + M_LAY_NET_HEAD_DST_POS;
    d74a:	9b03      	ldr	r3, [sp, #12]
            if (status != M_ERR_NO_ERROR)
            {
                break;
            }

            p_priv_key = (uint8_t *)&p_net_key->priv_key[0];
    d74c:	9a07      	ldr	r2, [sp, #28]
		// Get pointer to buffer environment in the lower transport buffer
        m_lay_buf_env_t *p_env_ltrans = (m_lay_buf_env_t *)&p_buf_ltrans->env[0];
        // Get buffer containing network PDU
        m_tb_buf_t *p_buf_net = p_env_ltrans->p_buf_2;
        // Pointer to start of encrypted data, 7 first bytes to be copied in privacy random value
        uint8_t *p_enc_data = M_TB_BUF_DATA(p_buf_net) + M_LAY_NET_HEAD_DST_POS;
    d74e:	18f6      	adds	r6, r6, r3

            p_priv_key = (uint8_t *)&p_net_key->priv_key[0];
        }

        // Compute privacy random value
        p_m_lay_net_env->sec_buf[15] = 0;
    d750:	9b05      	ldr	r3, [sp, #20]
		// Get pointer to buffer environment in the lower transport buffer
        m_lay_buf_env_t *p_env_ltrans = (m_lay_buf_env_t *)&p_buf_ltrans->env[0];
        // Get buffer containing network PDU
        m_tb_buf_t *p_buf_net = p_env_ltrans->p_buf_2;
        // Pointer to start of encrypted data, 7 first bytes to be copied in privacy random value
        uint8_t *p_enc_data = M_TB_BUF_DATA(p_buf_net) + M_LAY_NET_HEAD_DST_POS;
    d752:	3637      	adds	r6, #55	; 0x37

            p_priv_key = (uint8_t *)&p_net_key->priv_key[0];
        }

        // Compute privacy random value
        p_m_lay_net_env->sec_buf[15] = 0;
    d754:	681b      	ldr	r3, [r3, #0]
            if (status != M_ERR_NO_ERROR)
            {
                break;
            }

            p_priv_key = (uint8_t *)&p_net_key->priv_key[0];
    d756:	3222      	adds	r2, #34	; 0x22
        }

        // Compute privacy random value
        p_m_lay_net_env->sec_buf[15] = 0;
    d758:	0019      	movs	r1, r3
 */
__INLINE_S__ void co_write32p(void const *ptr32, uint32_t value)
{
    uint8_t *ptr=(uint8_t*)ptr32;

    *ptr++ = (uint8_t)(value&0xff);
    d75a:	001c      	movs	r4, r3
    d75c:	317f      	adds	r1, #127	; 0x7f
    d75e:	7008      	strb	r0, [r1, #0]
        p_m_lay_net_env->sec_buf[14] = 0;
    d760:	3901      	subs	r1, #1
    d762:	7008      	strb	r0, [r1, #0]
        p_m_lay_net_env->sec_buf[13] = 0;
    d764:	3901      	subs	r1, #1
    d766:	7008      	strb	r0, [r1, #0]
        p_m_lay_net_env->sec_buf[12] = 0;
    d768:	3901      	subs	r1, #1
    d76a:	7008      	strb	r0, [r1, #0]
        p_m_lay_net_env->sec_buf[11] = 0;
    d76c:	3901      	subs	r1, #1
    d76e:	7008      	strb	r0, [r1, #0]
        co_write32p(&p_m_lay_net_env->sec_buf[7], p_env_ltrans->u5.iv);
    d770:	69a9      	ldr	r1, [r5, #24]
    d772:	3477      	adds	r4, #119	; 0x77
    *ptr++ = (uint8_t)((value&0xff00)>>8);
    d774:	0a0d      	lsrs	r5, r1, #8
 */
__INLINE_S__ void co_write32p(void const *ptr32, uint32_t value)
{
    uint8_t *ptr=(uint8_t*)ptr32;

    *ptr++ = (uint8_t)(value&0xff);
    d776:	7021      	strb	r1, [r4, #0]
    *ptr++ = (uint8_t)((value&0xff00)>>8);
    d778:	7065      	strb	r5, [r4, #1]
    *ptr++ = (uint8_t)((value&0xff0000)>>16);
    d77a:	0c0d      	lsrs	r5, r1, #16
    *ptr = (uint8_t)((value&0xff000000)>>24);
    d77c:	0e09      	lsrs	r1, r1, #24
    d77e:	70e1      	strb	r1, [r4, #3]
        p_m_lay_net_env->sec_buf[6] = *p_enc_data;
    d780:	0019      	movs	r1, r3
{
    uint8_t *ptr=(uint8_t*)ptr32;

    *ptr++ = (uint8_t)(value&0xff);
    *ptr++ = (uint8_t)((value&0xff00)>>8);
    *ptr++ = (uint8_t)((value&0xff0000)>>16);
    d782:	70a5      	strb	r5, [r4, #2]
    d784:	7834      	ldrb	r4, [r6, #0]
    d786:	3176      	adds	r1, #118	; 0x76
    d788:	700c      	strb	r4, [r1, #0]
        p_m_lay_net_env->sec_buf[5] = *(p_enc_data + 1);
    d78a:	7874      	ldrb	r4, [r6, #1]
    d78c:	3901      	subs	r1, #1
    d78e:	700c      	strb	r4, [r1, #0]
        p_m_lay_net_env->sec_buf[4] = *(p_enc_data + 2);
    d790:	78b4      	ldrb	r4, [r6, #2]
    d792:	3901      	subs	r1, #1
    d794:	700c      	strb	r4, [r1, #0]
        p_m_lay_net_env->sec_buf[3] = *(p_enc_data + 3);
    d796:	78f4      	ldrb	r4, [r6, #3]
    d798:	3901      	subs	r1, #1
    d79a:	700c      	strb	r4, [r1, #0]
        p_m_lay_net_env->sec_buf[2] = *(p_enc_data + 4);
    d79c:	7934      	ldrb	r4, [r6, #4]
    d79e:	3901      	subs	r1, #1
    d7a0:	700c      	strb	r4, [r1, #0]
        p_m_lay_net_env->sec_buf[1] = *(p_enc_data + 5);
    d7a2:	7974      	ldrb	r4, [r6, #5]
    d7a4:	3901      	subs	r1, #1
    d7a6:	700c      	strb	r4, [r1, #0]
        p_m_lay_net_env->sec_buf[0] = *(p_enc_data + 6);
    d7a8:	79b1      	ldrb	r1, [r6, #6]
    d7aa:	3370      	adds	r3, #112	; 0x70
    d7ac:	7019      	strb	r1, [r3, #0]

        // Provide the needed information
        *pp_key = p_priv_key;
    d7ae:	603a      	str	r2, [r7, #0]
        *pp_val = &p_m_lay_net_env->sec_buf[0];
    d7b0:	9a04      	ldr	r2, [sp, #16]
    d7b2:	6013      	str	r3, [r2, #0]
    d7b4:	e001      	b.n	d7ba <m_lay_net_obfusc_ready_cb+0x102>
    do
    {
        // Retrieve buffer containing the lower transport PDU
        m_tb_buf_t *p_buf_ltrans = (m_tb_buf_t *)co_list_pick(&p_m_lay_net_env->encrypt_queue);
		if(p_buf_ltrans == NULL){
			return M_ERR_INVALID_PARAM;
    d7b6:	20c1      	movs	r0, #193	; 0xc1
    d7b8:	0040      	lsls	r0, r0, #1
        *pp_key = p_priv_key;
        *pp_val = &p_m_lay_net_env->sec_buf[0];
    } while (0);

    return (status);
}
    d7ba:	b009      	add	sp, #36	; 0x24
    d7bc:	bdf0      	pop	{r4, r5, r6, r7, pc}
    d7be:	46c0      	nop			; (mov r8, r8)
    d7c0:	100126b4 	.word	0x100126b4
    d7c4:	10010514 	.word	0x10010514
    d7c8:	00021a30 	.word	0x00021a30
    d7cc:	000219b0 	.word	0x000219b0
    d7d0:	000002e1 	.word	0x000002e1
    d7d4:	000002ea 	.word	0x000002ea
    d7d8:	00021ab0 	.word	0x00021ab0

0000d7dc <m_lay_net_obfusc_finished_cb>:
 * @param[in] status            Encryption status
 * @param[in] p_auth_val        Pointer to computed authentication value
 ****************************************************************************************
 */
__STATIC void m_lay_net_obfusc_finished_cb(uint8_t token_id, uint16_t status, const uint8_t *p_auth_val)
{
    d7dc:	b5f0      	push	{r4, r5, r6, r7, lr}
    // Retrieve buffer containing the lower transport PDU
    m_tb_buf_t *p_buf_ltrans = (m_tb_buf_t *)co_list_pop_front(&p_m_lay_net_env->encrypt_queue);
    d7de:	4b42      	ldr	r3, [pc, #264]	; (d8e8 <m_lay_net_obfusc_finished_cb+0x10c>)
 * @param[in] status            Encryption status
 * @param[in] p_auth_val        Pointer to computed authentication value
 ****************************************************************************************
 */
__STATIC void m_lay_net_obfusc_finished_cb(uint8_t token_id, uint16_t status, const uint8_t *p_auth_val)
{
    d7e0:	b085      	sub	sp, #20
    // Retrieve buffer containing the lower transport PDU
    m_tb_buf_t *p_buf_ltrans = (m_tb_buf_t *)co_list_pop_front(&p_m_lay_net_env->encrypt_queue);
    d7e2:	6818      	ldr	r0, [r3, #0]
 * @param[in] status            Encryption status
 * @param[in] p_auth_val        Pointer to computed authentication value
 ****************************************************************************************
 */
__STATIC void m_lay_net_obfusc_finished_cb(uint8_t token_id, uint16_t status, const uint8_t *p_auth_val)
{
    d7e4:	000c      	movs	r4, r1
    // Retrieve buffer containing the lower transport PDU
    m_tb_buf_t *p_buf_ltrans = (m_tb_buf_t *)co_list_pop_front(&p_m_lay_net_env->encrypt_queue);
    d7e6:	3008      	adds	r0, #8
 * @param[in] status            Encryption status
 * @param[in] p_auth_val        Pointer to computed authentication value
 ****************************************************************************************
 */
__STATIC void m_lay_net_obfusc_finished_cb(uint8_t token_id, uint16_t status, const uint8_t *p_auth_val)
{
    d7e8:	0016      	movs	r6, r2
    // Retrieve buffer containing the lower transport PDU
    m_tb_buf_t *p_buf_ltrans = (m_tb_buf_t *)co_list_pop_front(&p_m_lay_net_env->encrypt_queue);
    d7ea:	f7f6 fdff 	bl	43ec <co_list_pop_front>
    d7ee:	0007      	movs	r7, r0

    if (status == M_ERR_NO_ERROR)
    d7f0:	2c00      	cmp	r4, #0
    d7f2:	d151      	bne.n	d898 <m_lay_net_obfusc_finished_cb+0xbc>
        // Counter
        uint8_t cnt;
        // Get pointer to buffer environment in the lower transport buffer
        m_lay_buf_env_t *p_env_ltrans = (m_lay_buf_env_t *)&p_buf_ltrans->env[0];
        // Get buffer containing network PDU
        m_tb_buf_t *p_buf_net = p_env_ltrans->p_buf_2;
    d7f4:	6a85      	ldr	r5, [r0, #40]	; 0x28
        // Pointer to buffer environment in the network buffer
        m_lay_bearer_buf_env_t *p_env_net = (m_lay_bearer_buf_env_t *)&p_buf_net->env[0];
        // Pointer to data to obfuscate
        uint8_t *p_data = M_TB_BUF_DATA(p_buf_net) + M_LAY_NET_HEAD_CTL_TTL_POS;
    d7f6:	002b      	movs	r3, r5
    d7f8:	3330      	adds	r3, #48	; 0x30
    d7fa:	9302      	str	r3, [sp, #8]
    d7fc:	88ab      	ldrh	r3, [r5, #4]
    d7fe:	3301      	adds	r3, #1
    d800:	9303      	str	r3, [sp, #12]
		M_PRINTF(L_AL, "");
    d802:	4b3a      	ldr	r3, [pc, #232]	; (d8ec <m_lay_net_obfusc_finished_cb+0x110>)
    d804:	681b      	ldr	r3, [r3, #0]
    d806:	07db      	lsls	r3, r3, #31
    d808:	d514      	bpl.n	d834 <m_lay_net_obfusc_finished_cb+0x58>
    d80a:	4c39      	ldr	r4, [pc, #228]	; (d8f0 <m_lay_net_obfusc_finished_cb+0x114>)
    d80c:	4b39      	ldr	r3, [pc, #228]	; (d8f4 <m_lay_net_obfusc_finished_cb+0x118>)
    d80e:	0022      	movs	r2, r4
    d810:	0020      	movs	r0, r4
    d812:	3327      	adds	r3, #39	; 0x27
    d814:	0021      	movs	r1, r4
    d816:	3221      	adds	r2, #33	; 0x21
    d818:	9300      	str	r3, [sp, #0]
    d81a:	302d      	adds	r0, #45	; 0x2d
    d81c:	4b36      	ldr	r3, [pc, #216]	; (d8f8 <m_lay_net_obfusc_finished_cb+0x11c>)
    d81e:	f7f7 f8c5 	bl	49ac <m_print>
    d822:	0020      	movs	r0, r4
    d824:	305a      	adds	r0, #90	; 0x5a
    d826:	f7f7 f8c1 	bl	49ac <m_print>
    d82a:	0020      	movs	r0, r4
    d82c:	1da1      	adds	r1, r4, #6
    d82e:	305b      	adds	r0, #91	; 0x5b
    d830:	f7f7 f8bc 	bl	49ac <m_print>
    d834:	9a03      	ldr	r2, [sp, #12]
    d836:	9b02      	ldr	r3, [sp, #8]
    d838:	4694      	mov	ip, r2
    d83a:	0032      	movs	r2, r6
    d83c:	4463      	add	r3, ip
    d83e:	320f      	adds	r2, #15
    d840:	3609      	adds	r6, #9
        // Apply Obfuscation using the XOR operation
        for (cnt = 0; cnt < M_LAY_NET_OBFUSC_LEN; cnt++)
        {
            *(p_data + cnt) ^= p_auth_val[15 - cnt];
    d842:	7818      	ldrb	r0, [r3, #0]
    d844:	7811      	ldrb	r1, [r2, #0]
    d846:	3a01      	subs	r2, #1
    d848:	4041      	eors	r1, r0
    d84a:	7019      	strb	r1, [r3, #0]
    d84c:	3301      	adds	r3, #1
        m_lay_bearer_buf_env_t *p_env_net = (m_lay_bearer_buf_env_t *)&p_buf_net->env[0];
        // Pointer to data to obfuscate
        uint8_t *p_data = M_TB_BUF_DATA(p_buf_net) + M_LAY_NET_HEAD_CTL_TTL_POS;
		M_PRINTF(L_AL, "");
        // Apply Obfuscation using the XOR operation
        for (cnt = 0; cnt < M_LAY_NET_OBFUSC_LEN; cnt++)
    d84e:	4296      	cmp	r6, r2
    d850:	d1f7      	bne.n	d842 <m_lay_net_obfusc_finished_cb+0x66>
        {
            *(p_data + cnt) ^= p_auth_val[15 - cnt];
        }

        if (p_env_net->bearer_lid != M_INVALID_LID)
    d852:	7c6b      	ldrb	r3, [r5, #17]
    d854:	2bff      	cmp	r3, #255	; 0xff
    d856:	d023      	beq.n	d8a0 <m_lay_net_obfusc_finished_cb+0xc4>
        {
            // Pointer to interface
            m_lay_net_intf_t *p_intf = &p_m_lay_net_env->intfs[p_env_net->bearer_lid];
    d858:	4a23      	ldr	r2, [pc, #140]	; (d8e8 <m_lay_net_obfusc_finished_cb+0x10c>)
    d85a:	6811      	ldr	r1, [r2, #0]
                p_buf_net->dummy_tag = M_LAY_PROXY_MSG_ADV_TX;
                p_m_lay_net_env->p_cb[M_LAY_NET_INTF_GATT_PROXY]->rx(p_buf_net);
            }
            #endif // (BLE_MESH_GATT_PROXY)

            if (GETB(p_intf->state, M_LAY_NET_INTF_OPEN))
    d85c:	220c      	movs	r2, #12
    d85e:	4353      	muls	r3, r2
    d860:	18cc      	adds	r4, r1, r3
    d862:	3454      	adds	r4, #84	; 0x54
    d864:	7822      	ldrb	r2, [r4, #0]
    d866:	07d0      	lsls	r0, r2, #31
    d868:	d51a      	bpl.n	d8a0 <m_lay_net_obfusc_finished_cb+0xc4>
            {
                // Check if transmission can be performed
                if (!GETB(p_intf->state, M_LAY_NET_INTF_IN_TX))
    d86a:	2602      	movs	r6, #2
    d86c:	0010      	movs	r0, r2
    d86e:	4030      	ands	r0, r6
    d870:	d10b      	bne.n	d88a <m_lay_net_obfusc_finished_cb+0xae>
                {
                    SETB(p_intf->state, M_LAY_NET_INTF_IN_TX, 1);
    d872:	4332      	orrs	r2, r6
    d874:	7022      	strb	r2, [r4, #0]

                    // Push the buffer
                    status = p_m_lay_net_env->p_bearer_api->send(M_BEARER_CLI_NET, p_buf_net);
    d876:	684b      	ldr	r3, [r1, #4]
    d878:	0029      	movs	r1, r5
    d87a:	681b      	ldr	r3, [r3, #0]
    d87c:	4798      	blx	r3
    d87e:	1e01      	subs	r1, r0, #0

                    if (status != M_ERR_NO_ERROR)
    d880:	d013      	beq.n	d8aa <m_lay_net_obfusc_finished_cb+0xce>
                    {
                        SETB(p_intf->state, M_LAY_NET_INTF_IN_TX, 0);
    d882:	7823      	ldrb	r3, [r4, #0]
    d884:	43b3      	bics	r3, r6
    d886:	7023      	strb	r3, [r4, #0]
    d888:	e00b      	b.n	d8a2 <m_lay_net_obfusc_finished_cb+0xc6>
                    }
                }
                else
                {
                    co_list_push_back(&(p_intf->tx_queue), &(p_buf_net->hdr));
    d88a:	18cb      	adds	r3, r1, r3
    d88c:	334c      	adds	r3, #76	; 0x4c
    d88e:	0018      	movs	r0, r3
    d890:	0029      	movs	r1, r5
    d892:	f7f6 fd80 	bl	4396 <co_list_push_back>
    d896:	e008      	b.n	d8aa <m_lay_net_obfusc_finished_cb+0xce>
            m_lay_net_check_encrypt_queue();
        }
    }
    else
    {
        m_lay_net_encrypt_err(p_buf_ltrans, status);
    d898:	0021      	movs	r1, r4
    d89a:	f7ff fdcb 	bl	d434 <m_lay_net_encrypt_err>
    }
}
    d89e:	e021      	b.n	d8e4 <m_lay_net_obfusc_finished_cb+0x108>
    // Retrieve buffer containing the lower transport PDU
    m_tb_buf_t *p_buf_ltrans = (m_tb_buf_t *)co_list_pop_front(&p_m_lay_net_env->encrypt_queue);

    if (status == M_ERR_NO_ERROR)
    {
        uint16_t status = M_ERR_BEARER_CLOSED;
    d8a0:	4916      	ldr	r1, [pc, #88]	; (d8fc <m_lay_net_obfusc_finished_cb+0x120>)
        }

        if (status != M_ERR_NO_ERROR)
        {
            // No bearer is opened for transmission
            m_lay_net_encrypt_err(p_buf_ltrans, status);
    d8a2:	0038      	movs	r0, r7
    d8a4:	f7ff fdc6 	bl	d434 <m_lay_net_encrypt_err>
    d8a8:	e01c      	b.n	d8e4 <m_lay_net_obfusc_finished_cb+0x108>
        }
        else
        {
            // Handle next buffer in the encryption queue
            M_PRINTF(L_NET, "net encrpy data");
    d8aa:	4b10      	ldr	r3, [pc, #64]	; (d8ec <m_lay_net_obfusc_finished_cb+0x110>)
    d8ac:	681b      	ldr	r3, [r3, #0]
    d8ae:	06db      	lsls	r3, r3, #27
    d8b0:	d516      	bpl.n	d8e0 <m_lay_net_obfusc_finished_cb+0x104>
    d8b2:	4d10      	ldr	r5, [pc, #64]	; (d8f4 <m_lay_net_obfusc_finished_cb+0x118>)
    d8b4:	4c0e      	ldr	r4, [pc, #56]	; (d8f0 <m_lay_net_obfusc_finished_cb+0x114>)
    d8b6:	002b      	movs	r3, r5
    d8b8:	3327      	adds	r3, #39	; 0x27
    d8ba:	9300      	str	r3, [sp, #0]
    d8bc:	0022      	movs	r2, r4
    d8be:	0020      	movs	r0, r4
    d8c0:	23dc      	movs	r3, #220	; 0xdc
    d8c2:	0021      	movs	r1, r4
    d8c4:	3221      	adds	r2, #33	; 0x21
    d8c6:	009b      	lsls	r3, r3, #2
    d8c8:	302d      	adds	r0, #45	; 0x2d
    d8ca:	f7f7 f86f 	bl	49ac <m_print>
    d8ce:	0028      	movs	r0, r5
    d8d0:	3044      	adds	r0, #68	; 0x44
    d8d2:	f7f7 f86b 	bl	49ac <m_print>
    d8d6:	0020      	movs	r0, r4
    d8d8:	1da1      	adds	r1, r4, #6
    d8da:	305b      	adds	r0, #91	; 0x5b
    d8dc:	f7f7 f866 	bl	49ac <m_print>
            m_lay_net_check_encrypt_queue();
    d8e0:	f7ff fd6a 	bl	d3b8 <m_lay_net_check_encrypt_queue>
    }
    else
    {
        m_lay_net_encrypt_err(p_buf_ltrans, status);
    }
}
    d8e4:	b005      	add	sp, #20
    d8e6:	bdf0      	pop	{r4, r5, r6, r7, pc}
    d8e8:	100126b4 	.word	0x100126b4
    d8ec:	10010514 	.word	0x10010514
    d8f0:	000219b0 	.word	0x000219b0
    d8f4:	00021ab0 	.word	0x00021ab0
    d8f8:	0000033b 	.word	0x0000033b
    d8fc:	00000882 	.word	0x00000882

0000d900 <m_lay_net_desobfusc_ready_cb>:
 * @return Status. If returned status is M_ERR_NO_ERROR, m_lay_net_desobfusc_finished_cb function
 * will be called once the encryption has been performed.
 ****************************************************************************************
 */
__STATIC uint16_t m_lay_net_desobfusc_ready_cb(uint8_t token_id, const uint8_t **pp_key, const uint8_t **pp_val)
{
    d900:	b5f0      	push	{r4, r5, r6, r7, lr}
    uint16_t status;

    do
    {
        // Retrieve buffer containing the network PDU
        m_tb_buf_t *p_buf_net = (m_tb_buf_t *)co_list_pick(&p_m_lay_net_env->encrypt_queue);
    d902:	4d23      	ldr	r5, [pc, #140]	; (d990 <m_lay_net_desobfusc_ready_cb+0x90>)
 * @return Status. If returned status is M_ERR_NO_ERROR, m_lay_net_desobfusc_finished_cb function
 * will be called once the encryption has been performed.
 ****************************************************************************************
 */
__STATIC uint16_t m_lay_net_desobfusc_ready_cb(uint8_t token_id, const uint8_t **pp_key, const uint8_t **pp_val)
{
    d904:	b085      	sub	sp, #20
    d906:	682b      	ldr	r3, [r5, #0]
    d908:	000f      	movs	r7, r1
    d90a:	689c      	ldr	r4, [r3, #8]
    d90c:	0016      	movs	r6, r2
        // Retrieve buffer containing the network PDU
        m_tb_buf_t *p_buf_net = (m_tb_buf_t *)co_list_pick(&p_m_lay_net_env->encrypt_queue);
        // Get pointer to buffer environment in the network buffer
        m_lay_bearer_buf_env_t *p_env_net = (m_lay_bearer_buf_env_t *)&p_buf_net->env[0];
        // Pointer to start of encrypted data, 7 first bytes to be copied in privacy random value
        uint8_t *p_enc_data = M_TB_BUF_DATA(p_buf_net) + M_LAY_NET_HEAD_DST_POS;
    d90e:	88a3      	ldrh	r3, [r4, #4]
        {
            // Network key information
            const m_tb_key_net_t *p_net_key;

            // Retrieve network key information
            status = m_tb_key_net_get(p_env_net->u9.net_key_lid, &p_net_key, false);
    d910:	2200      	movs	r2, #0
        // Retrieve buffer containing the network PDU
        m_tb_buf_t *p_buf_net = (m_tb_buf_t *)co_list_pick(&p_m_lay_net_env->encrypt_queue);
        // Get pointer to buffer environment in the network buffer
        m_lay_bearer_buf_env_t *p_env_net = (m_lay_bearer_buf_env_t *)&p_buf_net->env[0];
        // Pointer to start of encrypted data, 7 first bytes to be copied in privacy random value
        uint8_t *p_enc_data = M_TB_BUF_DATA(p_buf_net) + M_LAY_NET_HEAD_DST_POS;
    d912:	9301      	str	r3, [sp, #4]
        {
            // Network key information
            const m_tb_key_net_t *p_net_key;

            // Retrieve network key information
            status = m_tb_key_net_get(p_env_net->u9.net_key_lid, &p_net_key, false);
    d914:	1ce3      	adds	r3, r4, #3
    d916:	7fd8      	ldrb	r0, [r3, #31]
    d918:	a903      	add	r1, sp, #12
    d91a:	f004 fcfb 	bl	12314 <m_tb_key_net_get>

            if (status != M_ERR_NO_ERROR)
    d91e:	2800      	cmp	r0, #0
    d920:	d133      	bne.n	d98a <m_lay_net_desobfusc_ready_cb+0x8a>
        // Retrieve buffer containing the network PDU
        m_tb_buf_t *p_buf_net = (m_tb_buf_t *)co_list_pick(&p_m_lay_net_env->encrypt_queue);
        // Get pointer to buffer environment in the network buffer
        m_lay_bearer_buf_env_t *p_env_net = (m_lay_bearer_buf_env_t *)&p_buf_net->env[0];
        // Pointer to start of encrypted data, 7 first bytes to be copied in privacy random value
        uint8_t *p_enc_data = M_TB_BUF_DATA(p_buf_net) + M_LAY_NET_HEAD_DST_POS;
    d922:	9b01      	ldr	r3, [sp, #4]
            if (status != M_ERR_NO_ERROR)
            {
                break;
            }

            p_priv_key = (uint8_t *)&p_net_key->priv_key[0];
    d924:	9903      	ldr	r1, [sp, #12]
        // Retrieve buffer containing the network PDU
        m_tb_buf_t *p_buf_net = (m_tb_buf_t *)co_list_pick(&p_m_lay_net_env->encrypt_queue);
        // Get pointer to buffer environment in the network buffer
        m_lay_bearer_buf_env_t *p_env_net = (m_lay_bearer_buf_env_t *)&p_buf_net->env[0];
        // Pointer to start of encrypted data, 7 first bytes to be copied in privacy random value
        uint8_t *p_enc_data = M_TB_BUF_DATA(p_buf_net) + M_LAY_NET_HEAD_DST_POS;
    d926:	18e2      	adds	r2, r4, r3

            p_priv_key = (uint8_t *)&p_net_key->priv_key[0];
        }

        // Compute privacy random value
        p_m_lay_net_env->sec_buf[15] = 0;
    d928:	682b      	ldr	r3, [r5, #0]
            if (status != M_ERR_NO_ERROR)
            {
                break;
            }

            p_priv_key = (uint8_t *)&p_net_key->priv_key[0];
    d92a:	3122      	adds	r1, #34	; 0x22
        }

        // Compute privacy random value
        p_m_lay_net_env->sec_buf[15] = 0;
    d92c:	001d      	movs	r5, r3
    d92e:	357f      	adds	r5, #127	; 0x7f
    d930:	7028      	strb	r0, [r5, #0]
        p_m_lay_net_env->sec_buf[14] = 0;
    d932:	3d01      	subs	r5, #1
    d934:	7028      	strb	r0, [r5, #0]
        p_m_lay_net_env->sec_buf[13] = 0;
    d936:	3d01      	subs	r5, #1
    d938:	7028      	strb	r0, [r5, #0]
        p_m_lay_net_env->sec_buf[12] = 0;
    d93a:	3d01      	subs	r5, #1
    d93c:	7028      	strb	r0, [r5, #0]
        p_m_lay_net_env->sec_buf[11] = 0;
    d93e:	3d01      	subs	r5, #1
    d940:	7028      	strb	r0, [r5, #0]
        co_write32p(&p_m_lay_net_env->sec_buf[7], p_env_net->iv);
    d942:	69a4      	ldr	r4, [r4, #24]
 */
__INLINE_S__ void co_write32p(void const *ptr32, uint32_t value)
{
    uint8_t *ptr=(uint8_t*)ptr32;

    *ptr++ = (uint8_t)(value&0xff);
    d944:	3d04      	subs	r5, #4
            if (status != M_ERR_NO_ERROR)
            {
                break;
            }

            p_priv_key = (uint8_t *)&p_net_key->priv_key[0];
    d946:	9101      	str	r1, [sp, #4]
    *ptr++ = (uint8_t)((value&0xff00)>>8);
    d948:	0a21      	lsrs	r1, r4, #8
 */
__INLINE_S__ void co_write32p(void const *ptr32, uint32_t value)
{
    uint8_t *ptr=(uint8_t*)ptr32;

    *ptr++ = (uint8_t)(value&0xff);
    d94a:	702c      	strb	r4, [r5, #0]
    *ptr++ = (uint8_t)((value&0xff00)>>8);
    d94c:	7069      	strb	r1, [r5, #1]
    *ptr++ = (uint8_t)((value&0xff0000)>>16);
    d94e:	0c21      	lsrs	r1, r4, #16
    *ptr = (uint8_t)((value&0xff000000)>>24);
    d950:	0e24      	lsrs	r4, r4, #24
    d952:	70ec      	strb	r4, [r5, #3]
        p_m_lay_net_env->sec_buf[14] = 0;
        p_m_lay_net_env->sec_buf[13] = 0;
        p_m_lay_net_env->sec_buf[12] = 0;
        p_m_lay_net_env->sec_buf[11] = 0;
        co_write32p(&p_m_lay_net_env->sec_buf[7], p_env_net->iv);
        p_m_lay_net_env->sec_buf[6] = *p_enc_data;
    d954:	001c      	movs	r4, r3
{
    uint8_t *ptr=(uint8_t*)ptr32;

    *ptr++ = (uint8_t)(value&0xff);
    *ptr++ = (uint8_t)((value&0xff00)>>8);
    *ptr++ = (uint8_t)((value&0xff0000)>>16);
    d956:	70a9      	strb	r1, [r5, #2]
        // Retrieve buffer containing the network PDU
        m_tb_buf_t *p_buf_net = (m_tb_buf_t *)co_list_pick(&p_m_lay_net_env->encrypt_queue);
        // Get pointer to buffer environment in the network buffer
        m_lay_bearer_buf_env_t *p_env_net = (m_lay_bearer_buf_env_t *)&p_buf_net->env[0];
        // Pointer to start of encrypted data, 7 first bytes to be copied in privacy random value
        uint8_t *p_enc_data = M_TB_BUF_DATA(p_buf_net) + M_LAY_NET_HEAD_DST_POS;
    d958:	3237      	adds	r2, #55	; 0x37
        p_m_lay_net_env->sec_buf[14] = 0;
        p_m_lay_net_env->sec_buf[13] = 0;
        p_m_lay_net_env->sec_buf[12] = 0;
        p_m_lay_net_env->sec_buf[11] = 0;
        co_write32p(&p_m_lay_net_env->sec_buf[7], p_env_net->iv);
        p_m_lay_net_env->sec_buf[6] = *p_enc_data;
    d95a:	7815      	ldrb	r5, [r2, #0]
    d95c:	3476      	adds	r4, #118	; 0x76
    d95e:	7025      	strb	r5, [r4, #0]
        p_m_lay_net_env->sec_buf[5] = *(p_enc_data + 1);
    d960:	7855      	ldrb	r5, [r2, #1]
    d962:	3c01      	subs	r4, #1
    d964:	7025      	strb	r5, [r4, #0]
        p_m_lay_net_env->sec_buf[4] = *(p_enc_data + 2);
    d966:	7895      	ldrb	r5, [r2, #2]
    d968:	3c01      	subs	r4, #1
    d96a:	7025      	strb	r5, [r4, #0]
        p_m_lay_net_env->sec_buf[3] = *(p_enc_data + 3);
    d96c:	78d5      	ldrb	r5, [r2, #3]
    d96e:	3c01      	subs	r4, #1
    d970:	7025      	strb	r5, [r4, #0]
        p_m_lay_net_env->sec_buf[2] = *(p_enc_data + 4);
    d972:	7915      	ldrb	r5, [r2, #4]
    d974:	3c01      	subs	r4, #1
    d976:	7025      	strb	r5, [r4, #0]
        p_m_lay_net_env->sec_buf[1] = *(p_enc_data + 5);
    d978:	7955      	ldrb	r5, [r2, #5]
    d97a:	3c01      	subs	r4, #1
    d97c:	7025      	strb	r5, [r4, #0]
        p_m_lay_net_env->sec_buf[0] = *(p_enc_data + 6);
    d97e:	7992      	ldrb	r2, [r2, #6]
    d980:	3370      	adds	r3, #112	; 0x70
    d982:	701a      	strb	r2, [r3, #0]

        // Provide the needed information
        *pp_key = p_priv_key;
    d984:	9a01      	ldr	r2, [sp, #4]
    d986:	603a      	str	r2, [r7, #0]
        *pp_val = &p_m_lay_net_env->sec_buf[0];
    d988:	6033      	str	r3, [r6, #0]
    } while (0);

    return (status);
}
    d98a:	b005      	add	sp, #20
    d98c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    d98e:	46c0      	nop			; (mov r8, r8)
    d990:	100126b4 	.word	0x100126b4

0000d994 <m_lay_net_desobfusc_finished_cb>:
 * @param[in] status            Encryption status
 * @param[in] p_auth_val        Pointer to computed authentication value
 ****************************************************************************************
 */
__STATIC void m_lay_net_desobfusc_finished_cb(uint8_t token_id, uint16_t status, const uint8_t *p_auth_val)
{
    d994:	b5f0      	push	{r4, r5, r6, r7, lr}
	M_PRINTF(L_NET, "token_id = %d status = %d", token_id, status);
    d996:	4b67      	ldr	r3, [pc, #412]	; (db34 <m_lay_net_desobfusc_finished_cb+0x1a0>)
 * @param[in] status            Encryption status
 * @param[in] p_auth_val        Pointer to computed authentication value
 ****************************************************************************************
 */
__STATIC void m_lay_net_desobfusc_finished_cb(uint8_t token_id, uint16_t status, const uint8_t *p_auth_val)
{
    d998:	b087      	sub	sp, #28
	M_PRINTF(L_NET, "token_id = %d status = %d", token_id, status);
    d99a:	681b      	ldr	r3, [r3, #0]
 * @param[in] status            Encryption status
 * @param[in] p_auth_val        Pointer to computed authentication value
 ****************************************************************************************
 */
__STATIC void m_lay_net_desobfusc_finished_cb(uint8_t token_id, uint16_t status, const uint8_t *p_auth_val)
{
    d99c:	0007      	movs	r7, r0
    d99e:	000d      	movs	r5, r1
    d9a0:	9202      	str	r2, [sp, #8]
	M_PRINTF(L_NET, "token_id = %d status = %d", token_id, status);
    d9a2:	06db      	lsls	r3, r3, #27
    d9a4:	d518      	bpl.n	d9d8 <m_lay_net_desobfusc_finished_cb+0x44>
    d9a6:	4e64      	ldr	r6, [pc, #400]	; (db38 <m_lay_net_desobfusc_finished_cb+0x1a4>)
    d9a8:	4c64      	ldr	r4, [pc, #400]	; (db3c <m_lay_net_desobfusc_finished_cb+0x1a8>)
    d9aa:	0033      	movs	r3, r6
    d9ac:	3354      	adds	r3, #84	; 0x54
    d9ae:	9300      	str	r3, [sp, #0]
    d9b0:	0022      	movs	r2, r4
    d9b2:	0020      	movs	r0, r4
    d9b4:	23f6      	movs	r3, #246	; 0xf6
    d9b6:	3221      	adds	r2, #33	; 0x21
    d9b8:	009b      	lsls	r3, r3, #2
    d9ba:	0021      	movs	r1, r4
    d9bc:	302d      	adds	r0, #45	; 0x2d
    d9be:	f7f6 fff5 	bl	49ac <m_print>
    d9c2:	0030      	movs	r0, r6
    d9c4:	0039      	movs	r1, r7
    d9c6:	3074      	adds	r0, #116	; 0x74
    d9c8:	002a      	movs	r2, r5
    d9ca:	f7f6 ffef 	bl	49ac <m_print>
    d9ce:	0020      	movs	r0, r4
    d9d0:	1da1      	adds	r1, r4, #6
    d9d2:	305b      	adds	r0, #91	; 0x5b
    d9d4:	f7f6 ffea 	bl	49ac <m_print>

    // Retrieve buffer containing the net PDU
    m_tb_buf_t *p_buf_net = (m_tb_buf_t *)co_list_pick(&p_m_lay_net_env->encrypt_queue);
    d9d8:	4e59      	ldr	r6, [pc, #356]	; (db40 <m_lay_net_desobfusc_finished_cb+0x1ac>)
    d9da:	6833      	ldr	r3, [r6, #0]
    d9dc:	689c      	ldr	r4, [r3, #8]

    if (status == M_ERR_NO_ERROR)
    d9de:	2d00      	cmp	r5, #0
    d9e0:	d000      	beq.n	d9e4 <m_lay_net_desobfusc_finished_cb+0x50>
    d9e2:	e0a2      	b.n	db2a <m_lay_net_desobfusc_finished_cb+0x196>
            // Pointer to data to desobfuscate
            uint8_t *p_data;
            // Counter
            uint8_t cnt;

            if (p_env_net->p_buf == NULL)
    d9e4:	6963      	ldr	r3, [r4, #20]
    d9e6:	2b00      	cmp	r3, #0
    d9e8:	d109      	bne.n	d9fe <m_lay_net_desobfusc_finished_cb+0x6a>
            {
                // Allocate a new buffer
                status = m_tb_buf_alloc(&p_buf_ltrans, 0, p_buf_net->data_len, 0);
    d9ea:	8922      	ldrh	r2, [r4, #8]
    d9ec:	002b      	movs	r3, r5
    d9ee:	0029      	movs	r1, r5
    d9f0:	a805      	add	r0, sp, #20
    d9f2:	f003 fda1 	bl	11538 <m_tb_buf_alloc>

                if (status != M_ERR_NO_ERROR)
    d9f6:	2800      	cmp	r0, #0
    d9f8:	d000      	beq.n	d9fc <m_lay_net_desobfusc_finished_cb+0x68>
    d9fa:	e096      	b.n	db2a <m_lay_net_desobfusc_finished_cb+0x196>
    d9fc:	e000      	b.n	da00 <m_lay_net_desobfusc_finished_cb+0x6c>
                }
            }
            else
            {
                // Reuse the buffer allocated during previous decryption attempt
                p_buf_ltrans = p_env_net->p_buf;
    d9fe:	9305      	str	r3, [sp, #20]
            }

            // Copy data from network buffer in the lower transport buffer
            m_tb_buf_copy(p_buf_net, p_buf_ltrans, M_LAY_NET_OBFUSC_LEN + 1, false);
    da00:	2300      	movs	r3, #0
    da02:	2207      	movs	r2, #7
    da04:	9905      	ldr	r1, [sp, #20]
    da06:	0020      	movs	r0, r4
    da08:	f003 fe8a 	bl	11720 <m_tb_buf_copy>

            // Link the two buffers together
            p_env_net->p_buf = p_buf_ltrans;
    da0c:	9b05      	ldr	r3, [sp, #20]
    da0e:	9902      	ldr	r1, [sp, #8]
    da10:	6163      	str	r3, [r4, #20]

            // Apply the XOR operation
            p_data = M_TB_BUF_DATA(p_buf_ltrans) + M_LAY_NET_HEAD_CTL_TTL_POS;
    da12:	889a      	ldrh	r2, [r3, #4]
    da14:	310f      	adds	r1, #15
    da16:	189a      	adds	r2, r3, r2
    da18:	3231      	adds	r2, #49	; 0x31
    da1a:	0013      	movs	r3, r2
    da1c:	1d95      	adds	r5, r2, #6
            for (cnt = 0; cnt < M_LAY_NET_OBFUSC_LEN; cnt++)
            {
                *(p_data + cnt) ^= p_auth_val[15 - cnt];
    da1e:	781f      	ldrb	r7, [r3, #0]
    da20:	7808      	ldrb	r0, [r1, #0]
    da22:	3901      	subs	r1, #1
    da24:	4078      	eors	r0, r7
    da26:	7018      	strb	r0, [r3, #0]
    da28:	3301      	adds	r3, #1
            // Link the two buffers together
            p_env_net->p_buf = p_buf_ltrans;

            // Apply the XOR operation
            p_data = M_TB_BUF_DATA(p_buf_ltrans) + M_LAY_NET_HEAD_CTL_TTL_POS;
            for (cnt = 0; cnt < M_LAY_NET_OBFUSC_LEN; cnt++)
    da2a:	429d      	cmp	r5, r3
    da2c:	d1f7      	bne.n	da1e <m_lay_net_desobfusc_finished_cb+0x8a>
            {
                *(p_data + cnt) ^= p_auth_val[15 - cnt];
            }
			m_printf_hex(L_NET, "recv desobfusc data", p_data, M_LAY_NET_OBFUSC_LEN);
    da2e:	4945      	ldr	r1, [pc, #276]	; (db44 <m_lay_net_desobfusc_finished_cb+0x1b0>)
    da30:	2306      	movs	r3, #6
    da32:	310e      	adds	r1, #14
    da34:	2010      	movs	r0, #16
    da36:	f7f7 f819 	bl	4a6c <m_printf_hex>
            // Fill buffer environment in the lower transport buffer
            p_data = M_TB_BUF_DATA(p_buf_ltrans);
    da3a:	9d05      	ldr	r5, [sp, #20]
    da3c:	002f      	movs	r7, r5
    da3e:	88ab      	ldrh	r3, [r5, #4]
    da40:	3730      	adds	r7, #48	; 0x30
    da42:	18ff      	adds	r7, r7, r3
            p_env_ltrans = (m_lay_buf_env_t *)&p_buf_ltrans->env[0];
            p_env_ltrans->net_lid = p_env_net->u9.net_key_lid;
    da44:	1ce3      	adds	r3, r4, #3
    da46:	7fdb      	ldrb	r3, [r3, #31]
    da48:	746b      	strb	r3, [r5, #17]
            #if (BLE_MESH_LPN || BLE_MESH_FRIEND)
            p_env_ltrans->friend_lid = p_env_net->friend_lid;
            #endif //(BLE_MESH_LPN || BLE_MESH_FRIEND)
            p_env_ltrans->app_lid = M_INVALID_LID;
    da4a:	23ff      	movs	r3, #255	; 0xff
    da4c:	74ab      	strb	r3, [r5, #18]
            p_env_ltrans->model_lid = M_INVALID_LID;
    da4e:	74eb      	strb	r3, [r5, #19]
            p_env_ltrans->ttl_ctl = *(p_data + M_LAY_NET_HEAD_CTL_TTL_POS);
    da50:	787a      	ldrb	r2, [r7, #1]
    da52:	1c6b      	adds	r3, r5, #1
    da54:	77da      	strb	r2, [r3, #31]
__INLINE_S__ uint32_t co_hton24(uint32_t host24)
{
    #if (!CPU_LE)
        return host24;
    #else
        return co_bswap24(host24);
    da56:	78f8      	ldrb	r0, [r7, #3]
    da58:	78bb      	ldrb	r3, [r7, #2]
    da5a:	0200      	lsls	r0, r0, #8
    da5c:	4318      	orrs	r0, r3
    da5e:	793b      	ldrb	r3, [r7, #4]
    da60:	041b      	lsls	r3, r3, #16
    da62:	4318      	orrs	r0, r3
    da64:	f7ff fc9c 	bl	d3a0 <co_bswap24>
            p_env_ltrans->seq = co_ntoh24(co_read24p(p_data + M_LAY_NET_HEAD_SEQ_POS));
            p_env_ltrans->src = co_ntohs(co_read16p(p_data + M_LAY_NET_HEAD_SRC_POS));
            p_env_ltrans->u5.iv = p_env_net->iv;
            p_env_ltrans->u9.rssi = p_env_net->rssi;
    da68:	211f      	movs	r1, #31
            p_env_ltrans->friend_lid = p_env_net->friend_lid;
            #endif //(BLE_MESH_LPN || BLE_MESH_FRIEND)
            p_env_ltrans->app_lid = M_INVALID_LID;
            p_env_ltrans->model_lid = M_INVALID_LID;
            p_env_ltrans->ttl_ctl = *(p_data + M_LAY_NET_HEAD_CTL_TTL_POS);
            p_env_ltrans->seq = co_ntoh24(co_read24p(p_data + M_LAY_NET_HEAD_SEQ_POS));
    da6a:	6168      	str	r0, [r5, #20]
 * @return The 16 bits value.
 ****************************************************************************************
 */
__INLINE_S__ uint16_t co_read16p(void const *ptr16)
{
    uint16_t value = ((uint8_t *)ptr16)[0] | ((uint8_t *)ptr16)[1] << 8;
    da6c:	79ba      	ldrb	r2, [r7, #6]
    da6e:	797b      	ldrb	r3, [r7, #5]
    da70:	0212      	lsls	r2, r2, #8
    da72:	431a      	orrs	r2, r3
 * @return The 16 bit swapped value.
 ****************************************************************************************
 */
__INLINE_S__ uint16_t co_bswap16(uint16_t val16)
{
    return ((val16<<8)&0xFF00) | ((val16>>8)&0xFF);
    da74:	0213      	lsls	r3, r2, #8
    da76:	0a12      	lsrs	r2, r2, #8
    da78:	431a      	orrs	r2, r3
    da7a:	b213      	sxth	r3, r2
            p_env_ltrans->src = co_ntohs(co_read16p(p_data + M_LAY_NET_HEAD_SRC_POS));
            p_env_ltrans->u5.iv = p_env_net->iv;
    da7c:	69a2      	ldr	r2, [r4, #24]
    da7e:	b298      	uxth	r0, r3
    da80:	61aa      	str	r2, [r5, #24]
            #endif //(BLE_MESH_LPN || BLE_MESH_FRIEND)
            p_env_ltrans->app_lid = M_INVALID_LID;
            p_env_ltrans->model_lid = M_INVALID_LID;
            p_env_ltrans->ttl_ctl = *(p_data + M_LAY_NET_HEAD_CTL_TTL_POS);
            p_env_ltrans->seq = co_ntoh24(co_read24p(p_data + M_LAY_NET_HEAD_SEQ_POS));
            p_env_ltrans->src = co_ntohs(co_read16p(p_data + M_LAY_NET_HEAD_SRC_POS));
    da82:	83a8      	strh	r0, [r5, #28]
            p_env_ltrans->u5.iv = p_env_net->iv;
            p_env_ltrans->u9.rssi = p_env_net->rssi;
    da84:	1c62      	adds	r2, r4, #1
    da86:	5651      	ldrsb	r1, [r2, r1]
    da88:	1caa      	adds	r2, r5, #2
    da8a:	77d1      	strb	r1, [r2, #31]
            p_env_ltrans->flags = 0;
            SETB(p_env_ltrans->flags, M_LAY_BUF_RX, 1);
    da8c:	2201      	movs	r2, #1
    da8e:	742a      	strb	r2, [r5, #16]
{
    // Boolean indicating if the address is valid
    bool addr_valid = false;

    // Unassigned address is not valid
    if (addr != M_UNASSIGNED_ADDR)
    da90:	2b00      	cmp	r3, #0
    da92:	dd4a      	ble.n	db2a <m_lay_net_desobfusc_finished_cb+0x196>
            SETB(p_env_ltrans->flags, M_LAY_BUF_RX, 1);

            // Check validity of source address and if lower transport PDU is not in the network message cache
            if (m_lay_net_is_addr_valid(p_env_ltrans->src, true,
                                        p_env_ltrans->ttl_ctl >> M_MSG_CTL_POS)
                    && !m_tb_mio_is_local_addr(p_env_ltrans->src)
    da94:	f005 ffd8 	bl	13a48 <m_tb_mio_is_local_addr>
    da98:	2800      	cmp	r0, #0
    da9a:	d146      	bne.n	db2a <m_lay_net_desobfusc_finished_cb+0x196>
                    && !m_lay_net_is_in_cache(p_buf_ltrans))
    da9c:	9a05      	ldr	r2, [sp, #20]
    uint32_t cnt;
    // Boolean indicating if the PDU has already been received
    bool in_cache = false;

    // Loop over message cache entries
    for (cnt = 0; cnt < p_m_lay_net_env->cache_nb; cnt++)
    da9e:	6836      	ldr	r6, [r6, #0]
__STATIC bool m_lay_net_is_in_cache(m_tb_buf_t *p_buf_ltrans)
{
    // Get pointer to mesh buffer environment in the lower transport buffer
    m_lay_buf_env_t *p_env = (m_lay_buf_env_t *)&p_buf_ltrans->env[0];
    // Extract NID value
    uint8_t nid = *(M_TB_BUF_DATA(p_buf_ltrans) + M_LAY_NET_HEAD_IVI_NID_POS) & 0x7F;
    daa0:	8893      	ldrh	r3, [r2, #4]
    daa2:	18d3      	adds	r3, r2, r3
    daa4:	3330      	adds	r3, #48	; 0x30
    daa6:	781d      	ldrb	r5, [r3, #0]
    daa8:	237f      	movs	r3, #127	; 0x7f
    daaa:	401d      	ands	r5, r3
    uint32_t cnt;
    // Boolean indicating if the PDU has already been received
    bool in_cache = false;

    // Loop over message cache entries
    for (cnt = 0; cnt < p_m_lay_net_env->cache_nb; cnt++)
    daac:	0033      	movs	r3, r6
    daae:	3349      	adds	r3, #73	; 0x49
__STATIC bool m_lay_net_is_in_cache(m_tb_buf_t *p_buf_ltrans)
{
    // Get pointer to mesh buffer environment in the lower transport buffer
    m_lay_buf_env_t *p_env = (m_lay_buf_env_t *)&p_buf_ltrans->env[0];
    // Extract NID value
    uint8_t nid = *(M_TB_BUF_DATA(p_buf_ltrans) + M_LAY_NET_HEAD_IVI_NID_POS) & 0x7F;
    dab0:	9502      	str	r5, [sp, #8]
    uint32_t cnt;
    // Boolean indicating if the PDU has already been received
    bool in_cache = false;

    // Loop over message cache entries
    for (cnt = 0; cnt < p_m_lay_net_env->cache_nb; cnt++)
    dab2:	9303      	str	r3, [sp, #12]
    dab4:	7819      	ldrb	r1, [r3, #0]
    dab6:	0033      	movs	r3, r6
    dab8:	8b97      	ldrh	r7, [r2, #28]
    daba:	3348      	adds	r3, #72	; 0x48
    dabc:	4288      	cmp	r0, r1
    dabe:	d218      	bcs.n	daf2 <m_lay_net_desobfusc_finished_cb+0x15e>
    {
        // Cache entry
        m_lay_net_cache_t *p_entry;
        // Position in the list
        uint32_t pos = (p_m_lay_net_env->cache_pos - cnt - 1);
    dac0:	781b      	ldrb	r3, [r3, #0]
    dac2:	1a1b      	subs	r3, r3, r0
    dac4:	3b01      	subs	r3, #1

        if (pos > M_LAY_NET_MSG_CACHE_SIZE)
    dac6:	2b05      	cmp	r3, #5
    dac8:	d900      	bls.n	dacc <m_lay_net_desobfusc_finished_cb+0x138>
        {
            pos += M_LAY_NET_MSG_CACHE_SIZE;
    daca:	3305      	adds	r3, #5
    dacc:	00db      	lsls	r3, r3, #3
    dace:	18f3      	adds	r3, r6, r3
        }

        // Read hash value at computed position
        p_entry = &p_m_lay_net_env->cache[pos];

        if ((p_entry->src == p_env->src) &&
    dad0:	8add      	ldrh	r5, [r3, #22]
    dad2:	42bd      	cmp	r5, r7
    dad4:	d10b      	bne.n	daee <m_lay_net_desobfusc_finished_cb+0x15a>
    dad6:	7d5f      	ldrb	r7, [r3, #21]
    dad8:	9d02      	ldr	r5, [sp, #8]
    dada:	42af      	cmp	r7, r5
    dadc:	d107      	bne.n	daee <m_lay_net_desobfusc_finished_cb+0x15a>
            (p_entry->nid == nid) &&
    dade:	7d1d      	ldrb	r5, [r3, #20]
    dae0:	7e17      	ldrb	r7, [r2, #24]
    dae2:	42bd      	cmp	r5, r7
    dae4:	d103      	bne.n	daee <m_lay_net_desobfusc_finished_cb+0x15a>
            (p_entry->iv_lsb == (uint8_t)p_env->u5.iv) &&
    dae6:	691b      	ldr	r3, [r3, #16]
    dae8:	6955      	ldr	r5, [r2, #20]
    daea:	42ab      	cmp	r3, r5
    daec:	d01d      	beq.n	db2a <m_lay_net_desobfusc_finished_cb+0x196>
    uint32_t cnt;
    // Boolean indicating if the PDU has already been received
    bool in_cache = false;

    // Loop over message cache entries
    for (cnt = 0; cnt < p_m_lay_net_env->cache_nb; cnt++)
    daee:	3001      	adds	r0, #1
    daf0:	e7e1      	b.n	dab6 <m_lay_net_desobfusc_finished_cb+0x122>
    }

    if (!in_cache)
    {
        // Add the message in the cache
        m_lay_net_cache_t *p_entry = &p_m_lay_net_env->cache[p_m_lay_net_env->cache_pos];
    daf2:	7818      	ldrb	r0, [r3, #0]
    daf4:	00c4      	lsls	r4, r0, #3
    daf6:	1936      	adds	r6, r6, r4

        p_entry->src = p_env->src;
        p_entry->nid = nid;
    daf8:	466c      	mov	r4, sp
    dafa:	7a24      	ldrb	r4, [r4, #8]
    if (!in_cache)
    {
        // Add the message in the cache
        m_lay_net_cache_t *p_entry = &p_m_lay_net_env->cache[p_m_lay_net_env->cache_pos];

        p_entry->src = p_env->src;
    dafc:	82f7      	strh	r7, [r6, #22]
        p_entry->nid = nid;
    dafe:	7574      	strb	r4, [r6, #21]
        p_entry->iv_lsb = (uint8_t)p_env->u5.iv;
    db00:	7e14      	ldrb	r4, [r2, #24]
        p_entry->seq = p_env->seq;

        // Update cache information
        if ((++p_m_lay_net_env->cache_pos) == M_LAY_NET_MSG_CACHE_SIZE)
    db02:	3001      	adds	r0, #1
        // Add the message in the cache
        m_lay_net_cache_t *p_entry = &p_m_lay_net_env->cache[p_m_lay_net_env->cache_pos];

        p_entry->src = p_env->src;
        p_entry->nid = nid;
        p_entry->iv_lsb = (uint8_t)p_env->u5.iv;
    db04:	7534      	strb	r4, [r6, #20]
        p_entry->seq = p_env->seq;
    db06:	6952      	ldr	r2, [r2, #20]
    db08:	6132      	str	r2, [r6, #16]

        // Update cache information
        if ((++p_m_lay_net_env->cache_pos) == M_LAY_NET_MSG_CACHE_SIZE)
    db0a:	b2c2      	uxtb	r2, r0
    db0c:	2a05      	cmp	r2, #5
    db0e:	d100      	bne.n	db12 <m_lay_net_desobfusc_finished_cb+0x17e>
        {
            p_m_lay_net_env->cache_pos = 0;
    db10:	2200      	movs	r2, #0
    db12:	701a      	strb	r2, [r3, #0]
        }

        if (p_m_lay_net_env->cache_nb != M_LAY_NET_MSG_CACHE_SIZE)
    db14:	2905      	cmp	r1, #5
    db16:	d002      	beq.n	db1e <m_lay_net_desobfusc_finished_cb+0x18a>
        {
            p_m_lay_net_env->cache_nb++;
    db18:	9b03      	ldr	r3, [sp, #12]
    db1a:	3101      	adds	r1, #1
    db1c:	7019      	strb	r1, [r3, #0]
                                        p_env_ltrans->ttl_ctl >> M_MSG_CTL_POS)
                    && !m_tb_mio_is_local_addr(p_env_ltrans->src)
                    && !m_lay_net_is_in_cache(p_buf_ltrans))
            {
                // Now push token for decryption
                m_tb_sec_ccm_dec_start(M_TB_SEC_TOKEN_NETWORK, m_lay_net_ccm_dec_ready_cb,
    db1e:	4a0a      	ldr	r2, [pc, #40]	; (db48 <m_lay_net_desobfusc_finished_cb+0x1b4>)
    db20:	490a      	ldr	r1, [pc, #40]	; (db4c <m_lay_net_desobfusc_finished_cb+0x1b8>)
    db22:	2003      	movs	r0, #3
    db24:	f006 fa77 	bl	14016 <m_tb_sec_ccm_dec_start>
    db28:	e002      	b.n	db30 <m_lay_net_desobfusc_finished_cb+0x19c>
        } while (0);
    }

    if (status != M_ERR_NO_ERROR)
    {
        m_lay_net_decrypt_err(p_buf_net);
    db2a:	0020      	movs	r0, r4
    db2c:	f7ff fcbe 	bl	d4ac <m_lay_net_decrypt_err>
    }
}
    db30:	b007      	add	sp, #28
    db32:	bdf0      	pop	{r4, r5, r6, r7, pc}
    db34:	10010514 	.word	0x10010514
    db38:	00021ab0 	.word	0x00021ab0
    db3c:	000219b0 	.word	0x000219b0
    db40:	100126b4 	.word	0x100126b4
    db44:	00021b30 	.word	0x00021b30
    db48:	0000dc1d 	.word	0x0000dc1d
    db4c:	0000db51 	.word	0x0000db51

0000db50 <m_lay_net_ccm_dec_ready_cb>:
 */
__STATIC uint16_t m_lay_net_ccm_dec_ready_cb(uint8_t token_id, const uint8_t **pp_key, const uint8_t **pp_nonce,
                                             const uint8_t **pp_msg, uint8_t **pp_cipher, uint16_t *p_msg_len,
                                             uint8_t *p_mic_len, const uint8_t **pp_auth_data,
                                             uint8_t *p_auth_data_len)
{
    db50:	b5f0      	push	{r4, r5, r6, r7, lr}
    uint16_t status;

    do
    {
        // Retrieve buffer containing the network PDU
        m_tb_buf_t *p_buf_net = (m_tb_buf_t *)co_list_pick(&p_m_lay_net_env->encrypt_queue);
    db52:	4f31      	ldr	r7, [pc, #196]	; (dc18 <m_lay_net_ccm_dec_ready_cb+0xc8>)
 */
__STATIC uint16_t m_lay_net_ccm_dec_ready_cb(uint8_t token_id, const uint8_t **pp_key, const uint8_t **pp_nonce,
                                             const uint8_t **pp_msg, uint8_t **pp_cipher, uint16_t *p_msg_len,
                                             uint8_t *p_mic_len, const uint8_t **pp_auth_data,
                                             uint8_t *p_auth_data_len)
{
    db54:	b087      	sub	sp, #28
    db56:	9303      	str	r3, [sp, #12]
    db58:	683b      	ldr	r3, [r7, #0]
    db5a:	9101      	str	r1, [sp, #4]
    db5c:	689d      	ldr	r5, [r3, #8]
    db5e:	9202      	str	r2, [sp, #8]
        // Retrieve buffer containing the network PDU
        m_tb_buf_t *p_buf_net = (m_tb_buf_t *)co_list_pick(&p_m_lay_net_env->encrypt_queue);
        // Get pointer to buffer environment in the network buffer
        m_lay_bearer_buf_env_t *p_env_net = (m_lay_bearer_buf_env_t *)&p_buf_net->env[0];
        // Get pointer to lower transport buffer
        m_tb_buf_t *p_buf_ltrans = p_env_net->p_buf;
    db60:	696e      	ldr	r6, [r5, #20]
        {
            // Network key information
            const m_tb_key_net_t *p_net_key;

            // Retrieve network key information
            status = m_tb_key_net_get(p_env_net->u9.net_key_lid, &p_net_key, false);
    db62:	1ceb      	adds	r3, r5, #3
    db64:	7fd8      	ldrb	r0, [r3, #31]
    db66:	2200      	movs	r2, #0
    db68:	a905      	add	r1, sp, #20
        // Get pointer to buffer environment in the network buffer
        m_lay_bearer_buf_env_t *p_env_net = (m_lay_bearer_buf_env_t *)&p_buf_net->env[0];
        // Get pointer to lower transport buffer
        m_tb_buf_t *p_buf_ltrans = p_env_net->p_buf;
        // Pointer to data
        uint8_t *p_data = M_TB_BUF_DATA(p_buf_ltrans);
    db6a:	88b4      	ldrh	r4, [r6, #4]
        {
            // Network key information
            const m_tb_key_net_t *p_net_key;

            // Retrieve network key information
            status = m_tb_key_net_get(p_env_net->u9.net_key_lid, &p_net_key, false);
    db6c:	f004 fbd2 	bl	12314 <m_tb_key_net_get>

            if (status != M_ERR_NO_ERROR)
    db70:	2800      	cmp	r0, #0
    db72:	d14e      	bne.n	dc12 <m_lay_net_ccm_dec_ready_cb+0xc2>
        }
        else
        #endif // (BLE_MESH_GATT_PROXY)
        // Compute nonce value
        {
            p_m_lay_net_env->sec_buf[0] = 0;
    db74:	2270      	movs	r2, #112	; 0x70
    db76:	4694      	mov	ip, r2
            if (status != M_ERR_NO_ERROR)
            {
                break;
            }

            p_enc_key = (uint8_t *)&p_net_key->enc_key[0];
    db78:	9b05      	ldr	r3, [sp, #20]
        // Get pointer to buffer environment in the network buffer
        m_lay_bearer_buf_env_t *p_env_net = (m_lay_bearer_buf_env_t *)&p_buf_net->env[0];
        // Get pointer to lower transport buffer
        m_tb_buf_t *p_buf_ltrans = p_env_net->p_buf;
        // Pointer to data
        uint8_t *p_data = M_TB_BUF_DATA(p_buf_ltrans);
    db7a:	0031      	movs	r1, r6
            if (status != M_ERR_NO_ERROR)
            {
                break;
            }

            p_enc_key = (uint8_t *)&p_net_key->enc_key[0];
    db7c:	3312      	adds	r3, #18
    db7e:	9300      	str	r3, [sp, #0]
        }
        else
        #endif // (BLE_MESH_GATT_PROXY)
        // Compute nonce value
        {
            p_m_lay_net_env->sec_buf[0] = 0;
    db80:	683b      	ldr	r3, [r7, #0]
        // Get pointer to buffer environment in the network buffer
        m_lay_bearer_buf_env_t *p_env_net = (m_lay_bearer_buf_env_t *)&p_buf_net->env[0];
        // Get pointer to lower transport buffer
        m_tb_buf_t *p_buf_ltrans = p_env_net->p_buf;
        // Pointer to data
        uint8_t *p_data = M_TB_BUF_DATA(p_buf_ltrans);
    db82:	3130      	adds	r1, #48	; 0x30
        }
        else
        #endif // (BLE_MESH_GATT_PROXY)
        // Compute nonce value
        {
            p_m_lay_net_env->sec_buf[0] = 0;
    db84:	449c      	add	ip, r3
    db86:	4662      	mov	r2, ip
    db88:	7010      	strb	r0, [r2, #0]
            p_m_lay_net_env->sec_buf[1] = *(p_data + M_LAY_NET_HEAD_CTL_TTL_POS);
    db8a:	001a      	movs	r2, r3
        // Get pointer to buffer environment in the network buffer
        m_lay_bearer_buf_env_t *p_env_net = (m_lay_bearer_buf_env_t *)&p_buf_net->env[0];
        // Get pointer to lower transport buffer
        m_tb_buf_t *p_buf_ltrans = p_env_net->p_buf;
        // Pointer to data
        uint8_t *p_data = M_TB_BUF_DATA(p_buf_ltrans);
    db8c:	190c      	adds	r4, r1, r4
        else
        #endif // (BLE_MESH_GATT_PROXY)
        // Compute nonce value
        {
            p_m_lay_net_env->sec_buf[0] = 0;
            p_m_lay_net_env->sec_buf[1] = *(p_data + M_LAY_NET_HEAD_CTL_TTL_POS);
    db8e:	7867      	ldrb	r7, [r4, #1]
    db90:	3271      	adds	r2, #113	; 0x71
    db92:	7017      	strb	r7, [r2, #0]
        }

        // Rest of nonce is common
        p_m_lay_net_env->sec_buf[2] = *(p_data + M_LAY_NET_HEAD_SEQ_POS);
    db94:	78a7      	ldrb	r7, [r4, #2]
    db96:	7057      	strb	r7, [r2, #1]
        p_m_lay_net_env->sec_buf[3] = *(p_data + M_LAY_NET_HEAD_SEQ_POS + 1);
    db98:	78e7      	ldrb	r7, [r4, #3]
    db9a:	7097      	strb	r7, [r2, #2]
        p_m_lay_net_env->sec_buf[4] = *(p_data + M_LAY_NET_HEAD_SEQ_POS + 2);
    db9c:	7927      	ldrb	r7, [r4, #4]
    db9e:	70d7      	strb	r7, [r2, #3]
        p_m_lay_net_env->sec_buf[5] = *(p_data + M_LAY_NET_HEAD_SRC_POS);
    dba0:	7967      	ldrb	r7, [r4, #5]
    dba2:	7117      	strb	r7, [r2, #4]
        p_m_lay_net_env->sec_buf[6] = *(p_data + M_LAY_NET_HEAD_SRC_POS + 1);
    dba4:	79a4      	ldrb	r4, [r4, #6]
        p_m_lay_net_env->sec_buf[7] = 0;
    dba6:	7190      	strb	r0, [r2, #6]
        // Rest of nonce is common
        p_m_lay_net_env->sec_buf[2] = *(p_data + M_LAY_NET_HEAD_SEQ_POS);
        p_m_lay_net_env->sec_buf[3] = *(p_data + M_LAY_NET_HEAD_SEQ_POS + 1);
        p_m_lay_net_env->sec_buf[4] = *(p_data + M_LAY_NET_HEAD_SEQ_POS + 2);
        p_m_lay_net_env->sec_buf[5] = *(p_data + M_LAY_NET_HEAD_SRC_POS);
        p_m_lay_net_env->sec_buf[6] = *(p_data + M_LAY_NET_HEAD_SRC_POS + 1);
    dba8:	7154      	strb	r4, [r2, #5]
 */
__INLINE_S__ void co_write32p(void const *ptr32, uint32_t value)
{
    uint8_t *ptr=(uint8_t*)ptr32;

    *ptr++ = (uint8_t)(value&0xff);
    dbaa:	001c      	movs	r4, r3
        p_m_lay_net_env->sec_buf[7] = 0;
        p_m_lay_net_env->sec_buf[8] = 0;
    dbac:	71d0      	strb	r0, [r2, #7]
    dbae:	69aa      	ldr	r2, [r5, #24]
    dbb0:	3479      	adds	r4, #121	; 0x79
    dbb2:	ba12      	rev	r2, r2
    *ptr++ = (uint8_t)((value&0xff00)>>8);
    dbb4:	0a17      	lsrs	r7, r2, #8
 */
__INLINE_S__ void co_write32p(void const *ptr32, uint32_t value)
{
    uint8_t *ptr=(uint8_t*)ptr32;

    *ptr++ = (uint8_t)(value&0xff);
    dbb6:	7022      	strb	r2, [r4, #0]
    *ptr++ = (uint8_t)((value&0xff00)>>8);
    dbb8:	7067      	strb	r7, [r4, #1]
    *ptr++ = (uint8_t)((value&0xff0000)>>16);
    *ptr = (uint8_t)((value&0xff000000)>>24);
    dbba:	337c      	adds	r3, #124	; 0x7c
{
    uint8_t *ptr=(uint8_t*)ptr32;

    *ptr++ = (uint8_t)(value&0xff);
    *ptr++ = (uint8_t)((value&0xff00)>>8);
    *ptr++ = (uint8_t)((value&0xff0000)>>16);
    dbbc:	0c17      	lsrs	r7, r2, #16
    *ptr = (uint8_t)((value&0xff000000)>>24);
    dbbe:	0e12      	lsrs	r2, r2, #24
{
    uint8_t *ptr=(uint8_t*)ptr32;

    *ptr++ = (uint8_t)(value&0xff);
    *ptr++ = (uint8_t)((value&0xff00)>>8);
    *ptr++ = (uint8_t)((value&0xff0000)>>16);
    dbc0:	70a7      	strb	r7, [r4, #2]
    *ptr = (uint8_t)((value&0xff000000)>>24);
    dbc2:	701a      	strb	r2, [r3, #0]
        co_write32p(&p_m_lay_net_env->sec_buf[9], co_htonl(p_env_net->iv));

        // Network MIC length, depends on packet type (access or control message)
        p_env_net->mic_len = (*(M_TB_BUF_DATA(p_buf_ltrans) + M_LAY_NET_HEAD_CTL_TTL_POS) & CO_BIT(M_MSG_CTL_POS))
    dbc4:	88b3      	ldrh	r3, [r6, #4]
    dbc6:	2204      	movs	r2, #4
    dbc8:	18cb      	adds	r3, r1, r3
    dbca:	785b      	ldrb	r3, [r3, #1]
    dbcc:	2b7f      	cmp	r3, #127	; 0x7f
    dbce:	d900      	bls.n	dbd2 <m_lay_net_ccm_dec_ready_cb+0x82>
    dbd0:	1892      	adds	r2, r2, r2
    dbd2:	1d2b      	adds	r3, r5, #4
    dbd4:	77da      	strb	r2, [r3, #31]
                                                    ? M_NMIC_CTL_LEN : M_NMIC_ACC_LEN;

        // Provide the requested information
        *pp_key = p_enc_key;
    dbd6:	9c00      	ldr	r4, [sp, #0]
    dbd8:	9a01      	ldr	r2, [sp, #4]
    dbda:	6014      	str	r4, [r2, #0]
        *pp_msg = M_TB_BUF_DATA(p_buf_net) + M_LAY_NET_HEAD_DST_POS;
    dbdc:	88aa      	ldrh	r2, [r5, #4]
    dbde:	9c03      	ldr	r4, [sp, #12]
    dbe0:	18aa      	adds	r2, r5, r2
    dbe2:	3237      	adds	r2, #55	; 0x37
    dbe4:	6022      	str	r2, [r4, #0]
        *pp_cipher = M_TB_BUF_DATA(p_buf_ltrans) + M_LAY_NET_HEAD_DST_POS;
    dbe6:	88b2      	ldrh	r2, [r6, #4]
    dbe8:	3207      	adds	r2, #7
    dbea:	1889      	adds	r1, r1, r2
    dbec:	9a0c      	ldr	r2, [sp, #48]	; 0x30
    dbee:	6011      	str	r1, [r2, #0]
        *pp_nonce = &p_m_lay_net_env->sec_buf[0];
    dbf0:	4661      	mov	r1, ip
    dbf2:	9a02      	ldr	r2, [sp, #8]
    dbf4:	6011      	str	r1, [r2, #0]
        *p_msg_len = p_buf_net->data_len - M_LAY_NET_HEAD_DST_POS - p_env_net->mic_len;
    dbf6:	892a      	ldrh	r2, [r5, #8]
    dbf8:	7fd9      	ldrb	r1, [r3, #31]
    dbfa:	3a07      	subs	r2, #7
    dbfc:	1a52      	subs	r2, r2, r1
    dbfe:	990d      	ldr	r1, [sp, #52]	; 0x34
    dc00:	800a      	strh	r2, [r1, #0]
        *p_mic_len = p_env_net->mic_len;
    dc02:	7fdb      	ldrb	r3, [r3, #31]
    dc04:	9a0e      	ldr	r2, [sp, #56]	; 0x38
    dc06:	7013      	strb	r3, [r2, #0]
        *pp_auth_data = NULL;
    dc08:	2300      	movs	r3, #0
    dc0a:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
    dc0c:	6013      	str	r3, [r2, #0]
        *p_auth_data_len = 0;
    dc0e:	9a10      	ldr	r2, [sp, #64]	; 0x40
    dc10:	7013      	strb	r3, [r2, #0]
    } while (0);

    return (status);
}
    dc12:	b007      	add	sp, #28
    dc14:	bdf0      	pop	{r4, r5, r6, r7, pc}
    dc16:	46c0      	nop			; (mov r8, r8)
    dc18:	100126b4 	.word	0x100126b4

0000dc1c <m_lay_net_ccm_dec_finished_cb>:
 * @param[in] status            Encryption status
 * @param[in] p_auth_val        Pointer to computed authentication value
 ****************************************************************************************
 */
__STATIC void m_lay_net_ccm_dec_finished_cb(uint8_t token_id, uint16_t status, const uint8_t *p_auth_val)
{
    dc1c:	b5f0      	push	{r4, r5, r6, r7, lr}
	M_PRINTF(L_NET, "token_id = %d status = %d", token_id, status);
    dc1e:	4e84      	ldr	r6, [pc, #528]	; (de30 <m_lay_net_ccm_dec_finished_cb+0x214>)
 * @param[in] status            Encryption status
 * @param[in] p_auth_val        Pointer to computed authentication value
 ****************************************************************************************
 */
__STATIC void m_lay_net_ccm_dec_finished_cb(uint8_t token_id, uint16_t status, const uint8_t *p_auth_val)
{
    dc20:	b087      	sub	sp, #28
	M_PRINTF(L_NET, "token_id = %d status = %d", token_id, status);
    dc22:	6833      	ldr	r3, [r6, #0]
 * @param[in] status            Encryption status
 * @param[in] p_auth_val        Pointer to computed authentication value
 ****************************************************************************************
 */
__STATIC void m_lay_net_ccm_dec_finished_cb(uint8_t token_id, uint16_t status, const uint8_t *p_auth_val)
{
    dc24:	0007      	movs	r7, r0
    dc26:	000d      	movs	r5, r1
	M_PRINTF(L_NET, "token_id = %d status = %d", token_id, status);
    dc28:	06db      	lsls	r3, r3, #27
    dc2a:	d516      	bpl.n	dc5a <m_lay_net_ccm_dec_finished_cb+0x3e>
    dc2c:	4c81      	ldr	r4, [pc, #516]	; (de34 <m_lay_net_ccm_dec_finished_cb+0x218>)
    dc2e:	4b82      	ldr	r3, [pc, #520]	; (de38 <m_lay_net_ccm_dec_finished_cb+0x21c>)
    dc30:	0022      	movs	r2, r4
    dc32:	0020      	movs	r0, r4
    dc34:	3322      	adds	r3, #34	; 0x22
    dc36:	3221      	adds	r2, #33	; 0x21
    dc38:	9300      	str	r3, [sp, #0]
    dc3a:	0021      	movs	r1, r4
    dc3c:	4b7f      	ldr	r3, [pc, #508]	; (de3c <m_lay_net_ccm_dec_finished_cb+0x220>)
    dc3e:	302d      	adds	r0, #45	; 0x2d
    dc40:	f7f6 feb4 	bl	49ac <m_print>
    dc44:	487e      	ldr	r0, [pc, #504]	; (de40 <m_lay_net_ccm_dec_finished_cb+0x224>)
    dc46:	0039      	movs	r1, r7
    dc48:	002a      	movs	r2, r5
    dc4a:	3074      	adds	r0, #116	; 0x74
    dc4c:	f7f6 feae 	bl	49ac <m_print>
    dc50:	0020      	movs	r0, r4
    dc52:	1da1      	adds	r1, r4, #6
    dc54:	305b      	adds	r0, #91	; 0x5b
    dc56:	f7f6 fea9 	bl	49ac <m_print>
    // Retrieve buffer containing the network PDU
    m_tb_buf_t *p_buf_net = (m_tb_buf_t *)co_list_pick(&p_m_lay_net_env->encrypt_queue);
    dc5a:	4b7a      	ldr	r3, [pc, #488]	; (de44 <m_lay_net_ccm_dec_finished_cb+0x228>)
    dc5c:	6818      	ldr	r0, [r3, #0]
    dc5e:	6887      	ldr	r7, [r0, #8]

    if (status == M_ERR_NO_ERROR)
    dc60:	2d00      	cmp	r5, #0
    dc62:	d000      	beq.n	dc66 <m_lay_net_ccm_dec_finished_cb+0x4a>
    dc64:	e0c7      	b.n	ddf6 <m_lay_net_ccm_dec_finished_cb+0x1da>
    {
        // Get pointer to buffer environment in the network buffer
        m_lay_bearer_buf_env_t *p_env_net = (m_lay_bearer_buf_env_t *)&p_buf_net->env[0];
        // Get pointer to lower transport buffer
        m_tb_buf_t *p_buf_ltrans = p_env_net->p_buf;
    dc66:	697c      	ldr	r4, [r7, #20]
        // Pointer to mesh buffer environment in the lower transport buffer
        m_lay_buf_env_t *p_env = (m_lay_buf_env_t *)&p_buf_ltrans->env[0];

        // Remove the buffer from the encryption queue
        co_list_pop_front(&p_m_lay_net_env->encrypt_queue);
    dc68:	3008      	adds	r0, #8
    dc6a:	f7f6 fbbf 	bl	43ec <co_list_pop_front>

        // Set destination address in the mesh buffer environment
        p_env->dst = co_ntohs(co_read16p(M_TB_BUF_DATA(p_buf_ltrans) + M_LAY_NET_HEAD_DST_POS));
    dc6e:	88a2      	ldrh	r2, [r4, #4]

        // Release head part
        m_tb_buf_head_release(p_buf_ltrans, M_LAY_NET_HEAD_LEN);
    dc70:	2109      	movs	r1, #9

        // Remove the buffer from the encryption queue
        co_list_pop_front(&p_m_lay_net_env->encrypt_queue);

        // Set destination address in the mesh buffer environment
        p_env->dst = co_ntohs(co_read16p(M_TB_BUF_DATA(p_buf_ltrans) + M_LAY_NET_HEAD_DST_POS));
    dc72:	18a2      	adds	r2, r4, r2
    dc74:	3237      	adds	r2, #55	; 0x37
 * @return The 16 bits value.
 ****************************************************************************************
 */
__INLINE_S__ uint16_t co_read16p(void const *ptr16)
{
    uint16_t value = ((uint8_t *)ptr16)[0] | ((uint8_t *)ptr16)[1] << 8;
    dc76:	7853      	ldrb	r3, [r2, #1]
    dc78:	7812      	ldrb	r2, [r2, #0]
    dc7a:	021b      	lsls	r3, r3, #8
    dc7c:	4313      	orrs	r3, r2
    dc7e:	021a      	lsls	r2, r3, #8
    dc80:	0a1b      	lsrs	r3, r3, #8
    dc82:	4313      	orrs	r3, r2
    dc84:	83e3      	strh	r3, [r4, #30]

        // Release head part
        m_tb_buf_head_release(p_buf_ltrans, M_LAY_NET_HEAD_LEN);
    dc86:	0020      	movs	r0, r4
    dc88:	f003 fcda 	bl	11640 <m_tb_buf_head_release>
        // Release tail part
        m_tb_buf_tail_release(p_buf_ltrans, p_env_net->mic_len);
    dc8c:	1d3b      	adds	r3, r7, #4
    dc8e:	7fd9      	ldrb	r1, [r3, #31]
    dc90:	0020      	movs	r0, r4
    dc92:	f003 fcf1 	bl	11678 <m_tb_buf_tail_release>
            }
        }
        else
        #endif // (BLE_MESH_GATT_PROXY)
        // Check validity of destination address
        if (m_lay_net_is_addr_valid(p_env->dst, false, GETB(p_env->ttl_ctl,M_MSG_CTL)))
    dc96:	8be0      	ldrh	r0, [r4, #30]
{
    // Boolean indicating if the address is valid
    bool addr_valid = false;

    // Unassigned address is not valid
    if (addr != M_UNASSIGNED_ADDR)
    dc98:	2800      	cmp	r0, #0
    dc9a:	d100      	bne.n	dc9e <m_lay_net_ccm_dec_finished_cb+0x82>
    dc9c:	e088      	b.n	ddb0 <m_lay_net_ccm_dec_finished_cb+0x194>
    {
        // Unicast addresses are always valid
        if (M_IS_UNICAST_ADDR(addr))
    dc9e:	b203      	sxth	r3, r0
    dca0:	2b00      	cmp	r3, #0
    dca2:	da07      	bge.n	dcb4 <m_lay_net_ccm_dec_finished_cb+0x98>
            }
        }
        else
        #endif // (BLE_MESH_GATT_PROXY)
        // Check validity of destination address
        if (m_lay_net_is_addr_valid(p_env->dst, false, GETB(p_env->ttl_ctl,M_MSG_CTL)))
    dca4:	1c63      	adds	r3, r4, #1
            addr_valid = true;
        }
        else if (!src)
        {
            // Virtual address not valid for a control message
            if (!(ctl && M_IS_VIRTUAL_ADDR(addr)))
    dca6:	7fdb      	ldrb	r3, [r3, #31]
    dca8:	09db      	lsrs	r3, r3, #7
    dcaa:	d006      	beq.n	dcba <m_lay_net_ccm_dec_finished_cb+0x9e>
    dcac:	0b80      	lsrs	r0, r0, #14
    dcae:	2802      	cmp	r0, #2
    dcb0:	d103      	bne.n	dcba <m_lay_net_ccm_dec_finished_cb+0x9e>
    dcb2:	e07d      	b.n	ddb0 <m_lay_net_ccm_dec_finished_cb+0x194>
    #endif //(BLE_MESH_DBG)

    if (M_IS_UNICAST_ADDR(dst_addr))
    {
        // Check that the address is well the address of an element
        valid = m_tb_mio_is_local_addr(dst_addr);
    dcb4:	f005 fec8 	bl	13a48 <m_tb_mio_is_local_addr>
    dcb8:	0005      	movs	r5, r0
        if (m_lay_net_is_addr_valid(p_env->dst, false, GETB(p_env->ttl_ctl,M_MSG_CTL)))
        {
            // Boolean indicating if destination is a local element or element of a Low Power Node
            // with which friendship is established
            bool is_local_dst = m_lay_net_is_local_addr(p_env->dst);
			M_PRINTF(L_NET, "is_local_dst[%d] p_env->dst[%x]", is_local_dst, p_env->dst);
    dcba:	6833      	ldr	r3, [r6, #0]
    dcbc:	06db      	lsls	r3, r3, #27
    dcbe:	d516      	bpl.n	dcee <m_lay_net_ccm_dec_finished_cb+0xd2>
    dcc0:	4e5c      	ldr	r6, [pc, #368]	; (de34 <m_lay_net_ccm_dec_finished_cb+0x218>)
    dcc2:	4b5d      	ldr	r3, [pc, #372]	; (de38 <m_lay_net_ccm_dec_finished_cb+0x21c>)
    dcc4:	0032      	movs	r2, r6
    dcc6:	0030      	movs	r0, r6
    dcc8:	3322      	adds	r3, #34	; 0x22
    dcca:	3221      	adds	r2, #33	; 0x21
    dccc:	9300      	str	r3, [sp, #0]
    dcce:	0031      	movs	r1, r6
    dcd0:	4b5d      	ldr	r3, [pc, #372]	; (de48 <m_lay_net_ccm_dec_finished_cb+0x22c>)
    dcd2:	302d      	adds	r0, #45	; 0x2d
    dcd4:	f7f6 fe6a 	bl	49ac <m_print>
    dcd8:	4857      	ldr	r0, [pc, #348]	; (de38 <m_lay_net_ccm_dec_finished_cb+0x21c>)
    dcda:	0029      	movs	r1, r5
    dcdc:	8be2      	ldrh	r2, [r4, #30]
    dcde:	3040      	adds	r0, #64	; 0x40
    dce0:	f7f6 fe64 	bl	49ac <m_print>
    dce4:	0030      	movs	r0, r6
    dce6:	1db1      	adds	r1, r6, #6
    dce8:	305b      	adds	r0, #91	; 0x5b
    dcea:	f7f6 fe5f 	bl	49ac <m_print>
            #if (BLE_MESH_RELAY)
            // Do not relay message targeting a local element or element of a LPN
            if (!is_local_dst)
    dcee:	2d00      	cmp	r5, #0
    dcf0:	d158      	bne.n	dda4 <m_lay_net_ccm_dec_finished_cb+0x188>
 ****************************************************************************************
 */
__STATIC void m_lay_net_check_relay(m_tb_buf_t *p_buf_ltrans)
{
    // Check if relay state is enabled
    if ((m_tb_state_get_relay_state(NULL) == M_CONF_RELAY_STATE_ENABLED))
    dcf2:	0028      	movs	r0, r5
    dcf4:	f006 fb82 	bl	143fc <m_tb_state_get_relay_state>
    dcf8:	2801      	cmp	r0, #1
    dcfa:	d142      	bne.n	dd82 <m_lay_net_ccm_dec_finished_cb+0x166>
    {
        // Get lower transport buffer environment
        m_lay_buf_env_t *p_env_ltrans = (m_lay_buf_env_t *)&p_buf_ltrans->env[0];
        // Get TTL value from the lower transport buffer
        uint8_t ttl = GETF(p_env_ltrans->ttl_ctl, M_MSG_TTL);
    dcfc:	1c63      	adds	r3, r4, #1
    dcfe:	7fda      	ldrb	r2, [r3, #31]
    dd00:	237f      	movs	r3, #127	; 0x7f
    dd02:	401a      	ands	r2, r3
		M_PRINTF(L_NET, "ttl[%x]", ttl);
    dd04:	4b4a      	ldr	r3, [pc, #296]	; (de30 <m_lay_net_ccm_dec_finished_cb+0x214>)
    if ((m_tb_state_get_relay_state(NULL) == M_CONF_RELAY_STATE_ENABLED))
    {
        // Get lower transport buffer environment
        m_lay_buf_env_t *p_env_ltrans = (m_lay_buf_env_t *)&p_buf_ltrans->env[0];
        // Get TTL value from the lower transport buffer
        uint8_t ttl = GETF(p_env_ltrans->ttl_ctl, M_MSG_TTL);
    dd06:	9203      	str	r2, [sp, #12]
		M_PRINTF(L_NET, "ttl[%x]", ttl);
    dd08:	681b      	ldr	r3, [r3, #0]
    dd0a:	06db      	lsls	r3, r3, #27
    dd0c:	d517      	bpl.n	dd3e <m_lay_net_ccm_dec_finished_cb+0x122>
    dd0e:	4e4a      	ldr	r6, [pc, #296]	; (de38 <m_lay_net_ccm_dec_finished_cb+0x21c>)
    dd10:	4d48      	ldr	r5, [pc, #288]	; (de34 <m_lay_net_ccm_dec_finished_cb+0x218>)
    dd12:	0033      	movs	r3, r6
    dd14:	3360      	adds	r3, #96	; 0x60
    dd16:	9300      	str	r3, [sp, #0]
    dd18:	002a      	movs	r2, r5
    dd1a:	0028      	movs	r0, r5
    dd1c:	23b9      	movs	r3, #185	; 0xb9
    dd1e:	3221      	adds	r2, #33	; 0x21
    dd20:	005b      	lsls	r3, r3, #1
    dd22:	0029      	movs	r1, r5
    dd24:	302d      	adds	r0, #45	; 0x2d
    dd26:	f7f6 fe41 	bl	49ac <m_print>
    dd2a:	0030      	movs	r0, r6
    dd2c:	9903      	ldr	r1, [sp, #12]
    dd2e:	3076      	adds	r0, #118	; 0x76
    dd30:	f7f6 fe3c 	bl	49ac <m_print>
    dd34:	0028      	movs	r0, r5
    dd36:	1da9      	adds	r1, r5, #6
    dd38:	305b      	adds	r0, #91	; 0x5b
    dd3a:	f7f6 fe37 	bl	49ac <m_print>
        // Check if PDU can be relayed
        if (ttl >= M_LAY_NET_MIN_TTL_RELAY)
    dd3e:	9b03      	ldr	r3, [sp, #12]
    dd40:	2b01      	cmp	r3, #1
    dd42:	d91e      	bls.n	dd82 <m_lay_net_ccm_dec_finished_cb+0x166>
        {
            // Allocate a new buffer in order to copy content of lower transport buffer
            m_tb_buf_t *p_buf_ltrans_cpy;

            if (m_tb_buf_alloc(&p_buf_ltrans_cpy, p_buf_ltrans->head_len,
    dd44:	88e3      	ldrh	r3, [r4, #6]
    dd46:	8922      	ldrh	r2, [r4, #8]
    dd48:	88a1      	ldrh	r1, [r4, #4]
    dd4a:	a805      	add	r0, sp, #20
    dd4c:	f003 fbf4 	bl	11538 <m_tb_buf_alloc>
    dd50:	1e06      	subs	r6, r0, #0
    dd52:	d116      	bne.n	dd82 <m_lay_net_ccm_dec_finished_cb+0x166>
                               p_buf_ltrans->data_len, p_buf_ltrans->tail_len) == M_ERR_NO_ERROR)
            {
                // Get copied lower transport buffer environment
                m_lay_buf_env_t *p_env_ltrans_cpy
                                = (m_lay_buf_env_t *)&p_buf_ltrans_cpy->env[0];
    dd54:	9d05      	ldr	r5, [sp, #20]

                // Copy content of lower transport buffer
                m_tb_buf_copy(p_buf_ltrans, p_buf_ltrans_cpy, p_buf_ltrans->data_len, true);
    dd56:	8922      	ldrh	r2, [r4, #8]
    dd58:	2301      	movs	r3, #1
    dd5a:	0029      	movs	r1, r5
    dd5c:	0020      	movs	r0, r4
    dd5e:	f003 fcdf 	bl	11720 <m_tb_buf_copy>

                // Decrement TTL
                ttl--;

                // Update TTL in the environment
                SETF(p_env_ltrans_cpy->ttl_ctl, M_MSG_TTL, ttl);
    dd62:	227f      	movs	r2, #127	; 0x7f
    dd64:	1c69      	adds	r1, r5, #1
    dd66:	7fcb      	ldrb	r3, [r1, #31]
                // Mark the buffer as relayed
                SETB(p_env_ltrans_cpy->flags, M_LAY_BUF_RELAY, 1);

                // Push the buffer for transmission
                m_lay_net_send(p_buf_ltrans_cpy, M_LAY_NET_INTF_TYPE_LTRANS);
    dd68:	9805      	ldr	r0, [sp, #20]

                // Decrement TTL
                ttl--;

                // Update TTL in the environment
                SETF(p_env_ltrans_cpy->ttl_ctl, M_MSG_TTL, ttl);
    dd6a:	4393      	bics	r3, r2
    dd6c:	9a03      	ldr	r2, [sp, #12]
    dd6e:	3a01      	subs	r2, #1
    dd70:	4313      	orrs	r3, r2
                // Mark the buffer as relayed
                SETB(p_env_ltrans_cpy->flags, M_LAY_BUF_RELAY, 1);
    dd72:	2208      	movs	r2, #8

                // Decrement TTL
                ttl--;

                // Update TTL in the environment
                SETF(p_env_ltrans_cpy->ttl_ctl, M_MSG_TTL, ttl);
    dd74:	77cb      	strb	r3, [r1, #31]
                // Mark the buffer as relayed
                SETB(p_env_ltrans_cpy->flags, M_LAY_BUF_RELAY, 1);
    dd76:	7c2b      	ldrb	r3, [r5, #16]

                // Push the buffer for transmission
                m_lay_net_send(p_buf_ltrans_cpy, M_LAY_NET_INTF_TYPE_LTRANS);
    dd78:	0031      	movs	r1, r6
                ttl--;

                // Update TTL in the environment
                SETF(p_env_ltrans_cpy->ttl_ctl, M_MSG_TTL, ttl);
                // Mark the buffer as relayed
                SETB(p_env_ltrans_cpy->flags, M_LAY_BUF_RELAY, 1);
    dd7a:	4313      	orrs	r3, r2
    dd7c:	742b      	strb	r3, [r5, #16]

                // Push the buffer for transmission
                m_lay_net_send(p_buf_ltrans_cpy, M_LAY_NET_INTF_TYPE_LTRANS);
    dd7e:	f000 f86b 	bl	de58 <m_lay_net_send>
                p_m_lay_net_env->p_cb[M_LAY_NET_INTF_GATT_PROXY]->rx(p_buf_net);
            }
            #endif // (BLE_MESH_GATT_PROXY)

            if (is_local_dst ||
                    (!M_IS_UNICAST_ADDR(p_env->dst) && m_lay_net_check_group_dst(p_env->dst)))
    dd82:	8be0      	ldrh	r0, [r4, #30]
                p_buf_net->dummy_tag = M_LAY_PROXY_MSG_RX;
                p_m_lay_net_env->p_cb[M_LAY_NET_INTF_GATT_PROXY]->rx(p_buf_net);
            }
            #endif // (BLE_MESH_GATT_PROXY)

            if (is_local_dst ||
    dd84:	b203      	sxth	r3, r0
    dd86:	2b00      	cmp	r3, #0
    dd88:	da12      	bge.n	ddb0 <m_lay_net_ccm_dec_finished_cb+0x194>
    {
        valid = true;
    }
    #endif //(BLE_MESH_FRIEND)
    {
        if (M_IS_FIXED_GROUP_ADDR(dst_addr))
    dd8a:	23ff      	movs	r3, #255	; 0xff
    dd8c:	0002      	movs	r2, r0
    dd8e:	439a      	bics	r2, r3
    dd90:	23ff      	movs	r3, #255	; 0xff
    dd92:	021b      	lsls	r3, r3, #8
    dd94:	429a      	cmp	r2, r3
    dd96:	d13a      	bne.n	de0e <m_lay_net_ccm_dec_finished_cb+0x1f2>
        {
            switch (dst_addr)
    dd98:	4b2c      	ldr	r3, [pc, #176]	; (de4c <m_lay_net_ccm_dec_finished_cb+0x230>)
    dd9a:	4298      	cmp	r0, r3
    dd9c:	d02f      	beq.n	ddfe <m_lay_net_ccm_dec_finished_cb+0x1e2>
    dd9e:	4b2c      	ldr	r3, [pc, #176]	; (de50 <m_lay_net_ccm_dec_finished_cb+0x234>)
    dda0:	4298      	cmp	r0, r3
    dda2:	d105      	bne.n	ddb0 <m_lay_net_ccm_dec_finished_cb+0x194>

            if (is_local_dst ||
                    (!M_IS_UNICAST_ADDR(p_env->dst) && m_lay_net_check_group_dst(p_env->dst)))
            {
                // Inform the lower transport layer about reception
                p_m_lay_net_env->p_cb[M_LAY_NET_INTF_LTRANS]->rx(p_buf_ltrans);
    dda4:	4b27      	ldr	r3, [pc, #156]	; (de44 <m_lay_net_ccm_dec_finished_cb+0x228>)
    dda6:	0020      	movs	r0, r4
    dda8:	681b      	ldr	r3, [r3, #0]
    ddaa:	681b      	ldr	r3, [r3, #0]
    ddac:	685b      	ldr	r3, [r3, #4]
    ddae:	4798      	blx	r3
            }
        }

        // Release the buffers
        m_tb_buf_release(p_buf_ltrans);
    ddb0:	0020      	movs	r0, r4
    ddb2:	f003 fc73 	bl	1169c <m_tb_buf_release>
        m_tb_buf_release(p_buf_net);
    ddb6:	0038      	movs	r0, r7
    ddb8:	f003 fc70 	bl	1169c <m_tb_buf_release>

        // Handle next buffer in the encryption queue
        M_PRINTF(L_NET, "check next decrypt");
    ddbc:	4b1c      	ldr	r3, [pc, #112]	; (de30 <m_lay_net_ccm_dec_finished_cb+0x214>)
    ddbe:	681b      	ldr	r3, [r3, #0]
    ddc0:	06db      	lsls	r3, r3, #27
    ddc2:	d515      	bpl.n	ddf0 <m_lay_net_ccm_dec_finished_cb+0x1d4>
    ddc4:	4d1c      	ldr	r5, [pc, #112]	; (de38 <m_lay_net_ccm_dec_finished_cb+0x21c>)
    ddc6:	4c1b      	ldr	r4, [pc, #108]	; (de34 <m_lay_net_ccm_dec_finished_cb+0x218>)
    ddc8:	002b      	movs	r3, r5
    ddca:	0022      	movs	r2, r4
    ddcc:	0020      	movs	r0, r4
    ddce:	3322      	adds	r3, #34	; 0x22
    ddd0:	0021      	movs	r1, r4
    ddd2:	3221      	adds	r2, #33	; 0x21
    ddd4:	9300      	str	r3, [sp, #0]
    ddd6:	302d      	adds	r0, #45	; 0x2d
    ddd8:	4b1e      	ldr	r3, [pc, #120]	; (de54 <m_lay_net_ccm_dec_finished_cb+0x238>)
    ddda:	f7f6 fde7 	bl	49ac <m_print>
    ddde:	0028      	movs	r0, r5
    dde0:	307e      	adds	r0, #126	; 0x7e
    dde2:	f7f6 fde3 	bl	49ac <m_print>
    dde6:	0020      	movs	r0, r4
    dde8:	1da1      	adds	r1, r4, #6
    ddea:	305b      	adds	r0, #91	; 0x5b
    ddec:	f7f6 fdde 	bl	49ac <m_print>
        m_lay_net_check_encrypt_queue();
    ddf0:	f7ff fae2 	bl	d3b8 <m_lay_net_check_encrypt_queue>
    ddf4:	e019      	b.n	de2a <m_lay_net_ccm_dec_finished_cb+0x20e>
    }
    else
    {
        // Handle decryption error
        m_lay_net_decrypt_err(p_buf_net);
    ddf6:	0038      	movs	r0, r7
    ddf8:	f7ff fb58 	bl	d4ac <m_lay_net_decrypt_err>
    }
}
    ddfc:	e015      	b.n	de2a <m_lay_net_ccm_dec_finished_cb+0x20e>

                #if (BLE_MESH_RELAY)
                case (M_ALL_RELAYS_ADDR):
                {
                    // Check if relay feature is enabled
                    valid = (m_tb_state_get_relay_state(NULL) == M_CONF_RELAY_STATE_ENABLED);
    ddfe:	2000      	movs	r0, #0
    de00:	f006 fafc 	bl	143fc <m_tb_state_get_relay_state>
    de04:	3801      	subs	r0, #1
    de06:	4243      	negs	r3, r0
    de08:	4158      	adcs	r0, r3
    de0a:	b2c0      	uxtb	r0, r0
    de0c:	e00a      	b.n	de24 <m_lay_net_ccm_dec_finished_cb+0x208>
                {
                    valid = false;
                } break;
            }
        }
        else if (M_IS_VIRTUAL_ADDR(dst_addr))
    de0e:	0b83      	lsrs	r3, r0, #14
    de10:	2b02      	cmp	r3, #2
    de12:	d1c7      	bne.n	dda4 <m_lay_net_ccm_dec_finished_cb+0x188>
        {
            valid = (m_tb_mio_get_label_uuid(dst_addr, 0, NULL) != M_INVALID_LID);
    de14:	2200      	movs	r2, #0
    de16:	0011      	movs	r1, r2
    de18:	f005 fd5c 	bl	138d4 <m_tb_mio_get_label_uuid>
    de1c:	38ff      	subs	r0, #255	; 0xff
    de1e:	1e43      	subs	r3, r0, #1
    de20:	4198      	sbcs	r0, r3
    de22:	b2c0      	uxtb	r0, r0
                p_m_lay_net_env->p_cb[M_LAY_NET_INTF_GATT_PROXY]->rx(p_buf_net);
            }
            #endif // (BLE_MESH_GATT_PROXY)

            if (is_local_dst ||
                    (!M_IS_UNICAST_ADDR(p_env->dst) && m_lay_net_check_group_dst(p_env->dst)))
    de24:	2800      	cmp	r0, #0
    de26:	d0c3      	beq.n	ddb0 <m_lay_net_ccm_dec_finished_cb+0x194>
    de28:	e7bc      	b.n	dda4 <m_lay_net_ccm_dec_finished_cb+0x188>
    else
    {
        // Handle decryption error
        m_lay_net_decrypt_err(p_buf_net);
    }
}
    de2a:	b007      	add	sp, #28
    de2c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    de2e:	46c0      	nop			; (mov r8, r8)
    de30:	10010514 	.word	0x10010514
    de34:	000219b0 	.word	0x000219b0
    de38:	00021b30 	.word	0x00021b30
    de3c:	000004b2 	.word	0x000004b2
    de40:	00021ab0 	.word	0x00021ab0
    de44:	100126b4 	.word	0x100126b4
    de48:	000004eb 	.word	0x000004eb
    de4c:	0000fffe 	.word	0x0000fffe
    de50:	0000ffff 	.word	0x0000ffff
    de54:	0000050b 	.word	0x0000050b

0000de58 <m_lay_net_send>:
 *
 * @return M_ERR_NO_ERROR if PDU has been properly pushed.
 ****************************************************************************************
 */
__STATIC uint16_t m_lay_net_send(m_tb_buf_t *p_buf, uint8_t intf_type)
{
    de58:	b5f0      	push	{r4, r5, r6, r7, lr}
	M_PRINTF(L_NET, "intf_type = %d", intf_type);
    de5a:	4b49      	ldr	r3, [pc, #292]	; (df80 <m_lay_net_send+0x128>)
 *
 * @return M_ERR_NO_ERROR if PDU has been properly pushed.
 ****************************************************************************************
 */
__STATIC uint16_t m_lay_net_send(m_tb_buf_t *p_buf, uint8_t intf_type)
{
    de5c:	b089      	sub	sp, #36	; 0x24
	M_PRINTF(L_NET, "intf_type = %d", intf_type);
    de5e:	681a      	ldr	r2, [r3, #0]
 *
 * @return M_ERR_NO_ERROR if PDU has been properly pushed.
 ****************************************************************************************
 */
__STATIC uint16_t m_lay_net_send(m_tb_buf_t *p_buf, uint8_t intf_type)
{
    de60:	0004      	movs	r4, r0
    de62:	9103      	str	r1, [sp, #12]
    de64:	9305      	str	r3, [sp, #20]
	M_PRINTF(L_NET, "intf_type = %d", intf_type);
    de66:	06d3      	lsls	r3, r2, #27
    de68:	d516      	bpl.n	de98 <m_lay_net_send+0x40>
    de6a:	4e46      	ldr	r6, [pc, #280]	; (df84 <m_lay_net_send+0x12c>)
    de6c:	4d46      	ldr	r5, [pc, #280]	; (df88 <m_lay_net_send+0x130>)
    de6e:	0033      	movs	r3, r6
    de70:	002a      	movs	r2, r5
    de72:	0028      	movs	r0, r5
    de74:	3311      	adds	r3, #17
    de76:	3221      	adds	r2, #33	; 0x21
    de78:	9300      	str	r3, [sp, #0]
    de7a:	0029      	movs	r1, r5
    de7c:	4b43      	ldr	r3, [pc, #268]	; (df8c <m_lay_net_send+0x134>)
    de7e:	302d      	adds	r0, #45	; 0x2d
    de80:	f7f6 fd94 	bl	49ac <m_print>
    de84:	0030      	movs	r0, r6
    de86:	9903      	ldr	r1, [sp, #12]
    de88:	3020      	adds	r0, #32
    de8a:	f7f6 fd8f 	bl	49ac <m_print>
    de8e:	0028      	movs	r0, r5
    de90:	1da9      	adds	r1, r5, #6
    de92:	305b      	adds	r0, #91	; 0x5b
    de94:	f7f6 fd8a 	bl	49ac <m_print>
	m_printf_hex(L_NET, "m_lay_net_send", M_TB_BUF_DATA(p_buf), p_buf->data_len);
    de98:	4f3a      	ldr	r7, [pc, #232]	; (df84 <m_lay_net_send+0x12c>)
    de9a:	0025      	movs	r5, r4
    de9c:	0039      	movs	r1, r7
    de9e:	88a2      	ldrh	r2, [r4, #4]
    dea0:	3530      	adds	r5, #48	; 0x30
    dea2:	8923      	ldrh	r3, [r4, #8]
    dea4:	18aa      	adds	r2, r5, r2
    dea6:	312f      	adds	r1, #47	; 0x2f
    dea8:	2010      	movs	r0, #16
    deaa:	f7f6 fddf 	bl	4a6c <m_printf_hex>
            // Get pointer to buffer environment
            m_lay_buf_env_t *p_env = (m_lay_buf_env_t *)&p_buf->env[0];
            // Retrieve network key information
            const m_tb_key_net_t *p_net_key;

            status = m_tb_key_net_get(p_env->net_lid, &p_net_key, true);
    deae:	7c60      	ldrb	r0, [r4, #17]
    deb0:	2201      	movs	r2, #1
    deb2:	a907      	add	r1, sp, #28
    deb4:	f004 fa2e 	bl	12314 <m_tb_key_net_get>
    deb8:	1e06      	subs	r6, r0, #0

            if (status != M_ERR_NO_ERROR)
    deba:	d15d      	bne.n	df78 <m_lay_net_send+0x120>
            {
                break;
            }

            // Add network header
            status = m_lay_net_add_header(p_buf, p_net_key);
    debc:	9b07      	ldr	r3, [sp, #28]
 ****************************************************************************************
 */
__STATIC uint16_t m_lay_net_add_header(m_tb_buf_t *p_buf_ltrans, const m_tb_key_net_t *p_net_key)
{
    // Reserve bytes for network header
    uint16_t status = m_tb_buf_head_reserve(p_buf_ltrans, M_LAY_NET_HEAD_LEN);
    debe:	2109      	movs	r1, #9
    dec0:	0020      	movs	r0, r4
            {
                break;
            }

            // Add network header
            status = m_lay_net_add_header(p_buf, p_net_key);
    dec2:	9304      	str	r3, [sp, #16]
 ****************************************************************************************
 */
__STATIC uint16_t m_lay_net_add_header(m_tb_buf_t *p_buf_ltrans, const m_tb_key_net_t *p_net_key)
{
    // Reserve bytes for network header
    uint16_t status = m_tb_buf_head_reserve(p_buf_ltrans, M_LAY_NET_HEAD_LEN);
    dec4:	f003 fbae 	bl	11624 <m_tb_buf_head_reserve>
    dec8:	1e06      	subs	r6, r0, #0

    if (status == M_ERR_NO_ERROR)
    deca:	d155      	bne.n	df78 <m_lay_net_send+0x120>
    {
        // Pointer to data
        uint8_t *p_data = M_TB_BUF_DATA(p_buf_ltrans);
    decc:	88a3      	ldrh	r3, [r4, #4]
    dece:	18ed      	adds	r5, r5, r3
        #if (BLE_MESH_LPN || BLE_MESH_FRIEND)
        if (status == M_ERR_NO_ERROR)
        #endif //(BLE_MESH_LPN || BLE_MESH_FRIEND)
        {
            // IVI and NID
            *(p_data + M_LAY_NET_HEAD_IVI_NID_POS) = nid | ((p_env->u5.iv & 0x01) << 7);
    ded0:	69a3      	ldr	r3, [r4, #24]
    ded2:	01da      	lsls	r2, r3, #7
            status = m_tb_key_friend_get_nid(p_env->net_lid, p_env->friend_lid, &nid, true);
        }
        else
        #endif //(BLE_MESH_LPN || BLE_MESH_FRIEND)
        {
            nid = p_net_key->nid;
    ded4:	9b04      	ldr	r3, [sp, #16]
    ded6:	3342      	adds	r3, #66	; 0x42
        #if (BLE_MESH_LPN || BLE_MESH_FRIEND)
        if (status == M_ERR_NO_ERROR)
        #endif //(BLE_MESH_LPN || BLE_MESH_FRIEND)
        {
            // IVI and NID
            *(p_data + M_LAY_NET_HEAD_IVI_NID_POS) = nid | ((p_env->u5.iv & 0x01) << 7);
    ded8:	781b      	ldrb	r3, [r3, #0]
    deda:	4313      	orrs	r3, r2
    dedc:	702b      	strb	r3, [r5, #0]
            // CTL and TTL
            *(p_data + M_LAY_NET_HEAD_CTL_TTL_POS) = p_env->ttl_ctl;
    dede:	1c63      	adds	r3, r4, #1
    dee0:	7fdb      	ldrb	r3, [r3, #31]
    dee2:	706b      	strb	r3, [r5, #1]
__INLINE_S__ uint32_t co_hton24(uint32_t host24)
{
    #if (!CPU_LE)
        return host24;
    #else
        return co_bswap24(host24);
    dee4:	6960      	ldr	r0, [r4, #20]
    dee6:	f7ff fa5b 	bl	d3a0 <co_bswap24>
 */
__INLINE_S__ void co_write24p(void const *ptr24, uint32_t value)
{
    uint8_t *ptr=(uint8_t*)ptr24;

    *ptr++ = (uint8_t)(value&0xff);
    deea:	70a8      	strb	r0, [r5, #2]
    *ptr++ = (uint8_t)((value&0xff00)>>8);
    deec:	0a03      	lsrs	r3, r0, #8
    *ptr++ = (uint8_t)((value&0xff0000)>>16);
    deee:	0c00      	lsrs	r0, r0, #16
__INLINE_S__ void co_write24p(void const *ptr24, uint32_t value)
{
    uint8_t *ptr=(uint8_t*)ptr24;

    *ptr++ = (uint8_t)(value&0xff);
    *ptr++ = (uint8_t)((value&0xff00)>>8);
    def0:	70eb      	strb	r3, [r5, #3]
    *ptr++ = (uint8_t)((value&0xff0000)>>16);
    def2:	7128      	strb	r0, [r5, #4]
            // Sequence Number
            co_write24p(p_data + M_LAY_NET_HEAD_SEQ_POS, co_hton24(p_env->seq));
            // Source Address
            co_write16p(p_data + M_LAY_NET_HEAD_SRC_POS, co_htons(p_env->src));
    def4:	8ba2      	ldrh	r2, [r4, #28]

            // Keep index of interface that has pushed the message
            p_env->u14.intf_idx_net = m_lay_net_intf_type_to_idx(intf_type);

            // Acquire the buffer
            m_tb_buf_acquire(p_buf);
    def6:	0020      	movs	r0, r4
 * @return The 16 bit swapped value.
 ****************************************************************************************
 */
__INLINE_S__ uint16_t co_bswap16(uint16_t val16)
{
    return ((val16<<8)&0xFF00) | ((val16>>8)&0xFF);
    def8:	0213      	lsls	r3, r2, #8
    defa:	0a12      	lsrs	r2, r2, #8
    defc:	431a      	orrs	r2, r3
    defe:	b213      	sxth	r3, r2
 */
__INLINE_S__ void co_write16p(void const *ptr16, uint16_t value)
{
    uint8_t *ptr=(uint8_t*)ptr16;

    *ptr++ = value&0xff;
    df00:	716b      	strb	r3, [r5, #5]
    *ptr = (value&0xff00)>>8;
    df02:	0a1b      	lsrs	r3, r3, #8
    df04:	71ab      	strb	r3, [r5, #6]
            // Sequence Number
            co_write24p(p_data + M_LAY_NET_HEAD_SEQ_POS, co_hton24(p_env->seq));
            // Source Address
            co_write16p(p_data + M_LAY_NET_HEAD_SRC_POS, co_htons(p_env->src));
            // Destination Address
            co_write16p(p_data + M_LAY_NET_HEAD_DST_POS, co_htons(p_env->dst));
    df06:	8be2      	ldrh	r2, [r4, #30]
    df08:	0213      	lsls	r3, r2, #8
    df0a:	0a12      	lsrs	r2, r2, #8
    df0c:	431a      	orrs	r2, r3
    df0e:	b213      	sxth	r3, r2
 */
__INLINE_S__ void co_write16p(void const *ptr16, uint16_t value)
{
    uint8_t *ptr=(uint8_t*)ptr16;

    *ptr++ = value&0xff;
    df10:	71eb      	strb	r3, [r5, #7]
    *ptr = (value&0xff00)>>8;
    df12:	0a1b      	lsrs	r3, r3, #8
    df14:	722b      	strb	r3, [r5, #8]
 ****************************************************************************************
 */
__STATIC uint8_t m_lay_net_intf_type_to_idx(uint8_t intf_type)
{
    // Interface index
    uint8_t intf_idx = M_LAY_NET_INTF_NB;
    df16:	9b03      	ldr	r3, [sp, #12]
    df18:	1e5a      	subs	r2, r3, #1
    df1a:	4193      	sbcs	r3, r2
            {
                break;
            }

            // Keep index of interface that has pushed the message
            p_env->u14.intf_idx_net = m_lay_net_intf_type_to_idx(intf_type);
    df1c:	0022      	movs	r2, r4
    df1e:	322c      	adds	r2, #44	; 0x2c
    df20:	7013      	strb	r3, [r2, #0]

            // Acquire the buffer
            m_tb_buf_acquire(p_buf);
    df22:	f003 fbb7 	bl	11694 <m_tb_buf_acquire>

            // Initialize pointer to buffer that will contain the encrypted PDU
            p_env->p_buf_2 = NULL;

            // Push the buffer in the encryption queue
            co_list_push_back(&p_m_lay_net_env->encrypt_queue, &p_buf->hdr);
    df26:	4d1a      	ldr	r5, [pc, #104]	; (df90 <m_lay_net_send+0x138>)

            // Acquire the buffer
            m_tb_buf_acquire(p_buf);

            // Initialize pointer to buffer that will contain the encrypted PDU
            p_env->p_buf_2 = NULL;
    df28:	62a6      	str	r6, [r4, #40]	; 0x28

            // Push the buffer in the encryption queue
            co_list_push_back(&p_m_lay_net_env->encrypt_queue, &p_buf->hdr);
    df2a:	6828      	ldr	r0, [r5, #0]
    df2c:	0021      	movs	r1, r4
    df2e:	3008      	adds	r0, #8
    df30:	f7f6 fa31 	bl	4396 <co_list_push_back>
    df34:	682b      	ldr	r3, [r5, #0]

            // If buffer is the first element in the encryption queue, get a token for encryption
            if ((m_tb_buf_t *)co_list_pick(&p_m_lay_net_env->encrypt_queue) == p_buf)
    df36:	689b      	ldr	r3, [r3, #8]
    df38:	429c      	cmp	r4, r3
    df3a:	d11d      	bne.n	df78 <m_lay_net_send+0x120>
            {
            	M_PRINTF(L_NET, "ccm enc");
    df3c:	9b05      	ldr	r3, [sp, #20]
    df3e:	681b      	ldr	r3, [r3, #0]
    df40:	06db      	lsls	r3, r3, #27
    df42:	d514      	bpl.n	df6e <m_lay_net_send+0x116>
    df44:	4c10      	ldr	r4, [pc, #64]	; (df88 <m_lay_net_send+0x130>)
    df46:	003b      	movs	r3, r7
    df48:	0022      	movs	r2, r4
    df4a:	0020      	movs	r0, r4
    df4c:	3311      	adds	r3, #17
    df4e:	0021      	movs	r1, r4
    df50:	3221      	adds	r2, #33	; 0x21
    df52:	9300      	str	r3, [sp, #0]
    df54:	302d      	adds	r0, #45	; 0x2d
    df56:	4b0f      	ldr	r3, [pc, #60]	; (df94 <m_lay_net_send+0x13c>)
    df58:	f7f6 fd28 	bl	49ac <m_print>
    df5c:	0038      	movs	r0, r7
    df5e:	303e      	adds	r0, #62	; 0x3e
    df60:	f7f6 fd24 	bl	49ac <m_print>
    df64:	0020      	movs	r0, r4
    df66:	1da1      	adds	r1, r4, #6
    df68:	305b      	adds	r0, #91	; 0x5b
    df6a:	f7f6 fd1f 	bl	49ac <m_print>
                m_tb_sec_ccm_enc_start(M_TB_SEC_TOKEN_NETWORK, m_lay_net_ccm_enc_ready_cb,
    df6e:	4a0a      	ldr	r2, [pc, #40]	; (df98 <m_lay_net_send+0x140>)
    df70:	490a      	ldr	r1, [pc, #40]	; (df9c <m_lay_net_send+0x144>)
    df72:	2003      	movs	r0, #3
    df74:	f006 f848 	bl	14008 <m_tb_sec_ccm_enc_start>
            }
        }
    } while (0);

    return (status);
}
    df78:	0030      	movs	r0, r6
    df7a:	b009      	add	sp, #36	; 0x24
    df7c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    df7e:	46c0      	nop			; (mov r8, r8)
    df80:	10010514 	.word	0x10010514
    df84:	00021bb0 	.word	0x00021bb0
    df88:	000219b0 	.word	0x000219b0
    df8c:	00000654 	.word	0x00000654
    df90:	100126b4 	.word	0x100126b4
    df94:	000006ac 	.word	0x000006ac
    df98:	0000d641 	.word	0x0000d641
    df9c:	0000d53d 	.word	0x0000d53d

0000dfa0 <m_lay_net_sent>:
 * @param[in] p_buf_net         Pointer to buffer containing the network PDU.
 * @param[in] status            Transmission status
 ****************************************************************************************
 */
__STATIC void m_lay_net_sent(m_tb_buf_t *p_buf_net, uint16_t status)
{
    dfa0:	b5f0      	push	{r4, r5, r6, r7, lr}
	M_PRINTF(L_NET, "");
    dfa2:	4b30      	ldr	r3, [pc, #192]	; (e064 <m_lay_net_sent+0xc4>)
 * @param[in] p_buf_net         Pointer to buffer containing the network PDU.
 * @param[in] status            Transmission status
 ****************************************************************************************
 */
__STATIC void m_lay_net_sent(m_tb_buf_t *p_buf_net, uint16_t status)
{
    dfa4:	b085      	sub	sp, #20
	M_PRINTF(L_NET, "");
    dfa6:	681b      	ldr	r3, [r3, #0]
 * @param[in] p_buf_net         Pointer to buffer containing the network PDU.
 * @param[in] status            Transmission status
 ****************************************************************************************
 */
__STATIC void m_lay_net_sent(m_tb_buf_t *p_buf_net, uint16_t status)
{
    dfa8:	0005      	movs	r5, r0
    dfaa:	000f      	movs	r7, r1
	M_PRINTF(L_NET, "");
    dfac:	06db      	lsls	r3, r3, #27
    dfae:	d514      	bpl.n	dfda <m_lay_net_sent+0x3a>
    dfb0:	4c2d      	ldr	r4, [pc, #180]	; (e068 <m_lay_net_sent+0xc8>)
    dfb2:	4b2e      	ldr	r3, [pc, #184]	; (e06c <m_lay_net_sent+0xcc>)
    dfb4:	0022      	movs	r2, r4
    dfb6:	0020      	movs	r0, r4
    dfb8:	3346      	adds	r3, #70	; 0x46
    dfba:	0021      	movs	r1, r4
    dfbc:	3221      	adds	r2, #33	; 0x21
    dfbe:	9300      	str	r3, [sp, #0]
    dfc0:	302d      	adds	r0, #45	; 0x2d
    dfc2:	4b2b      	ldr	r3, [pc, #172]	; (e070 <m_lay_net_sent+0xd0>)
    dfc4:	f7f6 fcf2 	bl	49ac <m_print>
    dfc8:	0020      	movs	r0, r4
    dfca:	305a      	adds	r0, #90	; 0x5a
    dfcc:	f7f6 fcee 	bl	49ac <m_print>
    dfd0:	0020      	movs	r0, r4
    dfd2:	1da1      	adds	r1, r4, #6
    dfd4:	305b      	adds	r0, #91	; 0x5b
    dfd6:	f7f6 fce9 	bl	49ac <m_print>
        // Point to buffer environment (buffer containing network PDU)
        m_lay_bearer_buf_env_t *p_env_net = (m_lay_bearer_buf_env_t *)&p_buf_net->env[0];
        // Bearer local identifier
        m_lid_t bearer_lid = p_env_net->bearer_lid;
        // Get interface information
        m_lay_net_intf_t *p_intf = &p_m_lay_net_env->intfs[bearer_lid];
    dfda:	4e26      	ldr	r6, [pc, #152]	; (e074 <m_lay_net_sent+0xd4>)
        // Get buffer containing the lower transport PDU
        m_tb_buf_t *p_buf_ltrans = p_env_net->p_buf;
    dfdc:	696c      	ldr	r4, [r5, #20]
        // Point to buffer environment (buffer containing network PDU)
        m_lay_bearer_buf_env_t *p_env_net = (m_lay_bearer_buf_env_t *)&p_buf_net->env[0];
        // Bearer local identifier
        m_lid_t bearer_lid = p_env_net->bearer_lid;
        // Get interface information
        m_lay_net_intf_t *p_intf = &p_m_lay_net_env->intfs[bearer_lid];
    dfde:	6833      	ldr	r3, [r6, #0]
    dfe0:	9302      	str	r3, [sp, #8]
    dfe2:	7c6b      	ldrb	r3, [r5, #17]
    dfe4:	9303      	str	r3, [sp, #12]
        // Get buffer containing the lower transport PDU
        m_tb_buf_t *p_buf_ltrans = p_env_net->p_buf;

        if (p_buf_ltrans != NULL)
    dfe6:	2c00      	cmp	r4, #0
    dfe8:	d018      	beq.n	e01c <m_lay_net_sent+0x7c>
            // Point to buffer environment (buffer containing lower transport PDU)
            m_lay_buf_env_t *p_env_ltrans = (m_lay_buf_env_t *)&p_buf_ltrans->env[0];

            #if (BLE_MESH_RELAY)
            // Check if message was a relayed message
            if (!GETB(p_env_ltrans->flags, M_LAY_BUF_RELAY))
    dfea:	2208      	movs	r2, #8
    dfec:	7c23      	ldrb	r3, [r4, #16]
    dfee:	4213      	tst	r3, r2
    dff0:	d10e      	bne.n	e010 <m_lay_net_sent+0x70>
            #endif //(BLE_MESH_RELAY)
            {
                // Release header
                m_tb_buf_head_release(p_buf_ltrans, M_LAY_NET_HEAD_LEN);
    dff2:	2109      	movs	r1, #9
    dff4:	0020      	movs	r0, r4
    dff6:	f003 fb23 	bl	11640 <m_tb_buf_head_release>
                    p_buf_ltrans->dummy_tag = M_LAY_PROXY_MSG_PROTOCOL;
                }
                #endif //(BLE_MESH_GATT_PROXY)

                // Forward the transmission status to the layer that pushed the message
                p_m_lay_net_env->p_cb[p_env_ltrans->u14.intf_idx_net]->sent(p_buf_ltrans, status);
    dffa:	0023      	movs	r3, r4
    dffc:	332c      	adds	r3, #44	; 0x2c
    dffe:	781b      	ldrb	r3, [r3, #0]
    e000:	6832      	ldr	r2, [r6, #0]
    e002:	009b      	lsls	r3, r3, #2
    e004:	589b      	ldr	r3, [r3, r2]
    e006:	0039      	movs	r1, r7
    e008:	681b      	ldr	r3, [r3, #0]
    e00a:	0020      	movs	r0, r4
    e00c:	4798      	blx	r3
    e00e:	e002      	b.n	e016 <m_lay_net_sent+0x76>
            }
			#if (BLE_MESH_RELAY)
			else{
				 m_tb_buf_release(p_buf_ltrans);
    e010:	0020      	movs	r0, r4
    e012:	f003 fb43 	bl	1169c <m_tb_buf_release>
			}
            #endif //(BLE_MESH_RELAY)

            // Release the buffer
            m_tb_buf_release(p_buf_ltrans);
    e016:	0020      	movs	r0, r4
    e018:	f003 fb40 	bl	1169c <m_tb_buf_release>
            p_m_lay_net_env->p_cb[M_LAY_NET_INTF_GATT_PROXY]->sent(p_buf_net, status);
        }
        #endif //(BLE_MESH_GATT_PROXY)

        // Release the buffer
        m_tb_buf_release(p_buf_net);
    e01c:	0028      	movs	r0, r5
    e01e:	f003 fb3d 	bl	1169c <m_tb_buf_release>
        p_buf_net = NULL;

        // Keep in mind that no more packet is being transmitted on this interface
        SETB(p_intf->state, M_LAY_NET_INTF_IN_TX, 0);
    e022:	230c      	movs	r3, #12
    e024:	9803      	ldr	r0, [sp, #12]
    e026:	2702      	movs	r7, #2
    e028:	4358      	muls	r0, r3
    e02a:	9b02      	ldr	r3, [sp, #8]
    e02c:	181c      	adds	r4, r3, r0
    e02e:	3454      	adds	r4, #84	; 0x54
    e030:	7823      	ldrb	r3, [r4, #0]
    e032:	001a      	movs	r2, r3
    e034:	43ba      	bics	r2, r7
    e036:	7022      	strb	r2, [r4, #0]

        if (GETB(p_intf->state, M_LAY_NET_INTF_OPEN))
    e038:	07db      	lsls	r3, r3, #31
    e03a:	d511      	bpl.n	e060 <m_lay_net_sent+0xc0>
        {
            // Check if another buffer can be pushed
            p_buf_net = (m_tb_buf_t *)co_list_pop_front(&p_intf->tx_queue);
    e03c:	9b02      	ldr	r3, [sp, #8]
    e03e:	1818      	adds	r0, r3, r0
    e040:	304c      	adds	r0, #76	; 0x4c
    e042:	f7f6 f9d3 	bl	43ec <co_list_pop_front>
    e046:	1e05      	subs	r5, r0, #0

            if (p_buf_net)
    e048:	d00a      	beq.n	e060 <m_lay_net_sent+0xc0>
            {
                // Push the buffer
                SETB(p_intf->state, M_LAY_NET_INTF_IN_TX, 1);
    e04a:	7823      	ldrb	r3, [r4, #0]
                status = p_m_lay_net_env->p_bearer_api->send(M_BEARER_CLI_NET, p_buf_net);
    e04c:	0001      	movs	r1, r0
            p_buf_net = (m_tb_buf_t *)co_list_pop_front(&p_intf->tx_queue);

            if (p_buf_net)
            {
                // Push the buffer
                SETB(p_intf->state, M_LAY_NET_INTF_IN_TX, 1);
    e04e:	431f      	orrs	r7, r3
                status = p_m_lay_net_env->p_bearer_api->send(M_BEARER_CLI_NET, p_buf_net);
    e050:	6833      	ldr	r3, [r6, #0]
            p_buf_net = (m_tb_buf_t *)co_list_pop_front(&p_intf->tx_queue);

            if (p_buf_net)
            {
                // Push the buffer
                SETB(p_intf->state, M_LAY_NET_INTF_IN_TX, 1);
    e052:	7027      	strb	r7, [r4, #0]
                status = p_m_lay_net_env->p_bearer_api->send(M_BEARER_CLI_NET, p_buf_net);
    e054:	685b      	ldr	r3, [r3, #4]
    e056:	2000      	movs	r0, #0
    e058:	681b      	ldr	r3, [r3, #0]
    e05a:	4798      	blx	r3
    e05c:	1e07      	subs	r7, r0, #0

                if (status == M_ERR_NO_ERROR)
    e05e:	d1bc      	bne.n	dfda <m_lay_net_sent+0x3a>
                }
            }
        }
    // Loop if an error has occurred on transmitted packet
    } while (p_buf_net != NULL);
}
    e060:	b005      	add	sp, #20
    e062:	bdf0      	pop	{r4, r5, r6, r7, pc}
    e064:	10010514 	.word	0x10010514
    e068:	000219b0 	.word	0x000219b0
    e06c:	00021bb0 	.word	0x00021bb0
    e070:	000006c1 	.word	0x000006c1
    e074:	100126b4 	.word	0x100126b4

0000e078 <m_lay_net_rx>:
 *
 * @param[in] p_buf_net        Pointer to the buffer containing the received network PDU.
 ****************************************************************************************
 */
__STATIC void m_lay_net_rx(m_tb_buf_t *p_buf_net)
{
    e078:	b5f0      	push	{r4, r5, r6, r7, lr}
	m_printf_hex(L_NET, "recv net data", M_TB_BUF_DATA(p_buf_net), p_buf_net->data_len);
    e07a:	0005      	movs	r5, r0
 *
 * @param[in] p_buf_net        Pointer to the buffer containing the received network PDU.
 ****************************************************************************************
 */
__STATIC void m_lay_net_rx(m_tb_buf_t *p_buf_net)
{
    e07c:	0004      	movs	r4, r0
	m_printf_hex(L_NET, "recv net data", M_TB_BUF_DATA(p_buf_net), p_buf_net->data_len);
    e07e:	8882      	ldrh	r2, [r0, #4]
    e080:	493a      	ldr	r1, [pc, #232]	; (e16c <m_lay_net_rx+0xf4>)
    e082:	3530      	adds	r5, #48	; 0x30
 *
 * @param[in] p_buf_net        Pointer to the buffer containing the received network PDU.
 ****************************************************************************************
 */
__STATIC void m_lay_net_rx(m_tb_buf_t *p_buf_net)
{
    e084:	b087      	sub	sp, #28
	m_printf_hex(L_NET, "recv net data", M_TB_BUF_DATA(p_buf_net), p_buf_net->data_len);
    e086:	8903      	ldrh	r3, [r0, #8]
    e088:	18aa      	adds	r2, r5, r2
    e08a:	3155      	adds	r1, #85	; 0x55
    e08c:	2010      	movs	r0, #16
    e08e:	f7f6 fced 	bl	4a6c <m_printf_hex>
    // Friend node (decrypted using friendship security credential) are accepted
    if (!m_tb_state_get_lpn_state())
    #endif //(BLE_MESH_LPN)
    {
        // Check if NID is known (master security credentials)
        p_env_net->u9.net_key_lid = m_tb_key_net_lid_from_nid(nid, 0);
    e092:	207f      	movs	r0, #127	; 0x7f
{
	m_printf_hex(L_NET, "recv net data", M_TB_BUF_DATA(p_buf_net), p_buf_net->data_len);
    // Get pointer to buffer environment in the network buffer
    m_lay_bearer_buf_env_t *p_env_net = (m_lay_bearer_buf_env_t *)&p_buf_net->env[0];
    // Read NID/IVI value
    uint8_t nid_ivi = *(M_TB_BUF_DATA(p_buf_net) + M_LAY_NET_HEAD_IVI_NID_POS);
    e094:	88a3      	ldrh	r3, [r4, #4]
    // Friend node (decrypted using friendship security credential) are accepted
    if (!m_tb_state_get_lpn_state())
    #endif //(BLE_MESH_LPN)
    {
        // Check if NID is known (master security credentials)
        p_env_net->u9.net_key_lid = m_tb_key_net_lid_from_nid(nid, 0);
    e096:	2100      	movs	r1, #0
{
	m_printf_hex(L_NET, "recv net data", M_TB_BUF_DATA(p_buf_net), p_buf_net->data_len);
    // Get pointer to buffer environment in the network buffer
    m_lay_bearer_buf_env_t *p_env_net = (m_lay_bearer_buf_env_t *)&p_buf_net->env[0];
    // Read NID/IVI value
    uint8_t nid_ivi = *(M_TB_BUF_DATA(p_buf_net) + M_LAY_NET_HEAD_IVI_NID_POS);
    e098:	5ceb      	ldrb	r3, [r5, r3]
    // Friend node (decrypted using friendship security credential) are accepted
    if (!m_tb_state_get_lpn_state())
    #endif //(BLE_MESH_LPN)
    {
        // Check if NID is known (master security credentials)
        p_env_net->u9.net_key_lid = m_tb_key_net_lid_from_nid(nid, 0);
    e09a:	4018      	ands	r0, r3
{
	m_printf_hex(L_NET, "recv net data", M_TB_BUF_DATA(p_buf_net), p_buf_net->data_len);
    // Get pointer to buffer environment in the network buffer
    m_lay_bearer_buf_env_t *p_env_net = (m_lay_bearer_buf_env_t *)&p_buf_net->env[0];
    // Read NID/IVI value
    uint8_t nid_ivi = *(M_TB_BUF_DATA(p_buf_net) + M_LAY_NET_HEAD_IVI_NID_POS);
    e09c:	9303      	str	r3, [sp, #12]
    // Friend node (decrypted using friendship security credential) are accepted
    if (!m_tb_state_get_lpn_state())
    #endif //(BLE_MESH_LPN)
    {
        // Check if NID is known (master security credentials)
        p_env_net->u9.net_key_lid = m_tb_key_net_lid_from_nid(nid, 0);
    e09e:	f004 f9bf 	bl	12420 <m_tb_key_net_lid_from_nid>
    e0a2:	1ce3      	adds	r3, r4, #3
    e0a4:	77d8      	strb	r0, [r3, #31]
        // Check if NID is known (friendship security credentials)
        p_env_net->u9.net_key_lid = m_tb_key_friend_net_lid_from_nid(nid, 0, &p_env_net->friend_lid);
    }
    #endif //(BLE_MESH_FRIEND || BLE_MESH_LPN)

    if (p_env_net->u9.net_key_lid != M_INVALID_LID)
    e0a6:	28ff      	cmp	r0, #255	; 0xff
    e0a8:	d05e      	beq.n	e168 <m_lay_net_rx+0xf0>
    uint32_t cnt;
    // Boolean indicating if the PDU has already been received
    bool in_pre_filt = false;

    // Compute hash value
    for (cnt = 0; cnt < M_LAY_NET_HASH_LEN; cnt++)
    e0aa:	2300      	movs	r3, #0
 ****************************************************************************************
 */
__STATIC bool m_lay_net_is_in_pre_filt(m_tb_buf_t *p_buf_net)
{
    // Get pointer to network PDU
    uint8_t *p_data = M_TB_BUF_DATA(p_buf_net);
    e0ac:	88a2      	ldrh	r2, [r4, #4]
    e0ae:	18aa      	adds	r2, r5, r2
    {
        hash.val[cnt] = *(p_data + cnt);
        // Make a XOR with first four bytes of encrypted part of the PDU
        hash.val[cnt] ^= *(p_data + M_LAY_NET_HEAD_DST_POS + cnt);
        // Make a XOR with last four bytes of the PDU
        hash.val[cnt] ^= *(p_data + p_buf_net->data_len - cnt - 1);
    e0b0:	8925      	ldrh	r5, [r4, #8]
    // Compute hash value
    for (cnt = 0; cnt < M_LAY_NET_HASH_LEN; cnt++)
    {
        hash.val[cnt] = *(p_data + cnt);
        // Make a XOR with first four bytes of encrypted part of the PDU
        hash.val[cnt] ^= *(p_data + M_LAY_NET_HEAD_DST_POS + cnt);
    e0b2:	18d1      	adds	r1, r2, r3
    e0b4:	1ae8      	subs	r0, r5, r3
        // Make a XOR with last four bytes of the PDU
        hash.val[cnt] ^= *(p_data + p_buf_net->data_len - cnt - 1);
    e0b6:	79ce      	ldrb	r6, [r1, #7]
    e0b8:	3801      	subs	r0, #1
    e0ba:	5cd1      	ldrb	r1, [r2, r3]
    e0bc:	5c10      	ldrb	r0, [r2, r0]
    e0be:	4071      	eors	r1, r6
    e0c0:	4041      	eors	r1, r0
    e0c2:	a805      	add	r0, sp, #20
    e0c4:	54c1      	strb	r1, [r0, r3]
    uint32_t cnt;
    // Boolean indicating if the PDU has already been received
    bool in_pre_filt = false;

    // Compute hash value
    for (cnt = 0; cnt < M_LAY_NET_HASH_LEN; cnt++)
    e0c6:	3301      	adds	r3, #1
    e0c8:	2b04      	cmp	r3, #4
    e0ca:	d1f2      	bne.n	e0b2 <m_lay_net_rx+0x3a>
        // Make a XOR with last four bytes of the PDU
        hash.val[cnt] ^= *(p_data + p_buf_net->data_len - cnt - 1);
    }

    // Look for this hash value in the pre-filtering list
    for (cnt = 0; cnt < p_m_lay_net_env->pre_filt_nb; cnt++)
    e0cc:	4e28      	ldr	r6, [pc, #160]	; (e170 <m_lay_net_rx+0xf8>)
    e0ce:	2700      	movs	r7, #0
    e0d0:	6835      	ldr	r5, [r6, #0]
    e0d2:	002b      	movs	r3, r5
    e0d4:	334b      	adds	r3, #75	; 0x4b
    e0d6:	781b      	ldrb	r3, [r3, #0]
    e0d8:	9302      	str	r3, [sp, #8]
    e0da:	002b      	movs	r3, r5
    e0dc:	334a      	adds	r3, #74	; 0x4a
    e0de:	9301      	str	r3, [sp, #4]
    e0e0:	9b02      	ldr	r3, [sp, #8]
    e0e2:	429f      	cmp	r7, r3
    e0e4:	d211      	bcs.n	e10a <m_lay_net_rx+0x92>
    {
        // Hash value in the list
        m_lay_net_hash_t *p_rd_hash;
        // Position in the list
        uint32_t pos = (p_m_lay_net_env->pre_filt_pos - cnt - 1);
    e0e6:	9b01      	ldr	r3, [sp, #4]
    e0e8:	781b      	ldrb	r3, [r3, #0]
    e0ea:	1bdb      	subs	r3, r3, r7
    e0ec:	1e59      	subs	r1, r3, #1

        if (pos > M_LAY_NET_PRE_FILT_SIZE)
    e0ee:	2904      	cmp	r1, #4
    e0f0:	d900      	bls.n	e0f4 <m_lay_net_rx+0x7c>
        {
            pos += M_LAY_NET_PRE_FILT_SIZE;
    e0f2:	1cd9      	adds	r1, r3, #3
        }

        // Read hash value at computed position
        p_rd_hash = &p_m_lay_net_env->pre_filt[pos];

        if (!memcmp(&hash, p_rd_hash, M_LAY_NET_HASH_LEN))
    e0f4:	310e      	adds	r1, #14
    e0f6:	0089      	lsls	r1, r1, #2
    e0f8:	1869      	adds	r1, r5, r1
    e0fa:	2204      	movs	r2, #4
    e0fc:	a805      	add	r0, sp, #20
    e0fe:	f007 fc3f 	bl	15980 <memcmp>
    e102:	2800      	cmp	r0, #0
    e104:	d030      	beq.n	e168 <m_lay_net_rx+0xf0>
        // Make a XOR with last four bytes of the PDU
        hash.val[cnt] ^= *(p_data + p_buf_net->data_len - cnt - 1);
    }

    // Look for this hash value in the pre-filtering list
    for (cnt = 0; cnt < p_m_lay_net_env->pre_filt_nb; cnt++)
    e106:	3701      	adds	r7, #1
    e108:	e7ea      	b.n	e0e0 <m_lay_net_rx+0x68>
    }

    if (!in_pre_filt)
    {
        // Insert the computed hash value in the pre-filtering list and update list information
        memcpy(&p_m_lay_net_env->pre_filt[p_m_lay_net_env->pre_filt_pos], &hash, M_LAY_NET_HASH_LEN);
    e10a:	9b01      	ldr	r3, [sp, #4]
    e10c:	9905      	ldr	r1, [sp, #20]
    e10e:	781b      	ldrb	r3, [r3, #0]
    e110:	001a      	movs	r2, r3

        if ((++p_m_lay_net_env->pre_filt_pos) == M_LAY_NET_PRE_FILT_SIZE)
    e112:	3301      	adds	r3, #1
    }

    if (!in_pre_filt)
    {
        // Insert the computed hash value in the pre-filtering list and update list information
        memcpy(&p_m_lay_net_env->pre_filt[p_m_lay_net_env->pre_filt_pos], &hash, M_LAY_NET_HASH_LEN);
    e114:	320e      	adds	r2, #14
    e116:	0092      	lsls	r2, r2, #2

        if ((++p_m_lay_net_env->pre_filt_pos) == M_LAY_NET_PRE_FILT_SIZE)
    e118:	b2db      	uxtb	r3, r3
    }

    if (!in_pre_filt)
    {
        // Insert the computed hash value in the pre-filtering list and update list information
        memcpy(&p_m_lay_net_env->pre_filt[p_m_lay_net_env->pre_filt_pos], &hash, M_LAY_NET_HASH_LEN);
    e11a:	5151      	str	r1, [r2, r5]

        if ((++p_m_lay_net_env->pre_filt_pos) == M_LAY_NET_PRE_FILT_SIZE)
    e11c:	2b04      	cmp	r3, #4
    e11e:	d100      	bne.n	e122 <m_lay_net_rx+0xaa>
        {
            p_m_lay_net_env->pre_filt_pos = 0;
    e120:	2300      	movs	r3, #0
    e122:	9a01      	ldr	r2, [sp, #4]
    // Hash value
    m_lay_net_hash_t hash;
    // Counter
    uint32_t cnt;
    // Boolean indicating if the PDU has already been received
    bool in_pre_filt = false;
    e124:	2700      	movs	r7, #0
        // Insert the computed hash value in the pre-filtering list and update list information
        memcpy(&p_m_lay_net_env->pre_filt[p_m_lay_net_env->pre_filt_pos], &hash, M_LAY_NET_HASH_LEN);

        if ((++p_m_lay_net_env->pre_filt_pos) == M_LAY_NET_PRE_FILT_SIZE)
        {
            p_m_lay_net_env->pre_filt_pos = 0;
    e126:	7013      	strb	r3, [r2, #0]
        }

        if (p_m_lay_net_env->pre_filt_nb != M_LAY_NET_PRE_FILT_SIZE)
    e128:	9b02      	ldr	r3, [sp, #8]
    e12a:	2b04      	cmp	r3, #4
    e12c:	d002      	beq.n	e134 <m_lay_net_rx+0xbc>
        {
            p_m_lay_net_env->pre_filt_nb++;
    e12e:	3301      	adds	r3, #1
    e130:	354b      	adds	r5, #75	; 0x4b
    e132:	702b      	strb	r3, [r5, #0]
    {
        // Check if message has already been received (pre-filtering)
        if (!m_lay_net_is_in_pre_filt(p_buf_net))
        {
            // Acquire buffer
            m_tb_buf_acquire(p_buf_net);
    e134:	0020      	movs	r0, r4
    e136:	f003 faad 	bl	11694 <m_tb_buf_acquire>

            // Initialize buffer environment
            p_env_net->p_buf = NULL;
            p_env_net->nb_dec_attempts = 1;
    e13a:	2201      	movs	r2, #1
    e13c:	1ca3      	adds	r3, r4, #2
        {
            // Acquire buffer
            m_tb_buf_acquire(p_buf_net);

            // Initialize buffer environment
            p_env_net->p_buf = NULL;
    e13e:	6167      	str	r7, [r4, #20]
            p_env_net->nb_dec_attempts = 1;
    e140:	77da      	strb	r2, [r3, #31]
            // Get IV value to be used for decryption
            p_env_net->iv = m_tb_key_get_iv_rx(GETB(nid_ivi, M_LAY_NET_IVI_NID_IVI));
    e142:	9b03      	ldr	r3, [sp, #12]
    e144:	09d8      	lsrs	r0, r3, #7
    e146:	f004 fd93 	bl	12c70 <m_tb_key_get_iv_rx>
    e14a:	61a0      	str	r0, [r4, #24]

            // Push the buffer in the encryption queue
            co_list_push_back(&p_m_lay_net_env->encrypt_queue, &p_buf_net->hdr);
    e14c:	6830      	ldr	r0, [r6, #0]
    e14e:	0021      	movs	r1, r4
    e150:	3008      	adds	r0, #8
    e152:	f7f6 f920 	bl	4396 <co_list_push_back>
    e156:	6833      	ldr	r3, [r6, #0]

            // If buffer is the first element in the encryption queue, request to start AES-128
            if ((m_tb_buf_t *)co_list_pick(&p_m_lay_net_env->encrypt_queue) == p_buf_net)
    e158:	689b      	ldr	r3, [r3, #8]
    e15a:	429c      	cmp	r4, r3
    e15c:	d104      	bne.n	e168 <m_lay_net_rx+0xf0>
            {
                m_tb_sec_aes_start(M_TB_SEC_TOKEN_NETWORK, m_lay_net_desobfusc_ready_cb,
    e15e:	4a05      	ldr	r2, [pc, #20]	; (e174 <m_lay_net_rx+0xfc>)
    e160:	4905      	ldr	r1, [pc, #20]	; (e178 <m_lay_net_rx+0x100>)
    e162:	2003      	movs	r0, #3
    e164:	f005 ff16 	bl	13f94 <m_tb_sec_aes_start>
                                                           m_lay_net_desobfusc_finished_cb);
            }
        }
    }
    // else discard the PDU
}
    e168:	b007      	add	sp, #28
    e16a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    e16c:	00021bb0 	.word	0x00021bb0
    e170:	100126b4 	.word	0x100126b4
    e174:	0000d995 	.word	0x0000d995
    e178:	0000d901 	.word	0x0000d901

0000e17c <m_lay_net_opened>:
 ****************************************************************************************
 */
__STATIC void m_lay_net_opened(uint8_t bearer_lid, uint8_t type)
{
    // Get interface information
    m_lay_net_intf_t *p_intf = &p_m_lay_net_env->intfs[bearer_lid];
    e17c:	4b0b      	ldr	r3, [pc, #44]	; (e1ac <m_lay_net_opened+0x30>)
 * @param[in] bearer_lid          Bearer instance local index
 * @param[in] type                Bearer type
 ****************************************************************************************
 */
__STATIC void m_lay_net_opened(uint8_t bearer_lid, uint8_t type)
{
    e17e:	b570      	push	{r4, r5, r6, lr}
    // Get interface information
    m_lay_net_intf_t *p_intf = &p_m_lay_net_env->intfs[bearer_lid];
    e180:	681c      	ldr	r4, [r3, #0]

    // Bearer instance is now opened
    SETB(p_intf->state, M_LAY_NET_INTF_OPEN, 1);
    e182:	230c      	movs	r3, #12
    e184:	001a      	movs	r2, r3
    e186:	2601      	movs	r6, #1
    e188:	4342      	muls	r2, r0
    e18a:	18a2      	adds	r2, r4, r2
    e18c:	3254      	adds	r2, #84	; 0x54
    e18e:	7815      	ldrb	r5, [r2, #0]
    e190:	4335      	orrs	r5, r6
    e192:	7015      	strb	r5, [r2, #0]

    // Keep local index of advertising bearer
    if (type == M_BEARER_TYPE_ADV)
    e194:	2900      	cmp	r1, #0
    e196:	d102      	bne.n	e19e <m_lay_net_opened+0x22>
    {
        p_m_lay_net_env->adv_bearer_lid = bearer_lid;
    e198:	0022      	movs	r2, r4
    e19a:	3280      	adds	r2, #128	; 0x80
    e19c:	7010      	strb	r0, [r2, #0]
        p_m_lay_net_env->p_cb[M_LAY_NET_INTF_GATT_PROXY]->opened(bearer_lid, type);
    }
    #endif //(BLE_MESH_GATT_PROXY)

    // Sanity check
    ASSERT_INFO(co_list_is_empty(&p_intf->tx_queue), 0, 0);
    e19e:	4358      	muls	r0, r3
    e1a0:	1820      	adds	r0, r4, r0
    e1a2:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
    e1a4:	2b00      	cmp	r3, #0
    e1a6:	d1fd      	bne.n	e1a4 <m_lay_net_opened+0x28>
}
    e1a8:	bd70      	pop	{r4, r5, r6, pc}
    e1aa:	46c0      	nop			; (mov r8, r8)
    e1ac:	100126b4 	.word	0x100126b4

0000e1b0 <m_lay_net_closed>:
 ****************************************************************************************
 */
__STATIC void m_lay_net_closed(uint8_t bearer_lid)
{
    // Get interface information
    m_lay_net_intf_t *p_intf = &p_m_lay_net_env->intfs[bearer_lid];
    e1b0:	4b13      	ldr	r3, [pc, #76]	; (e200 <m_lay_net_closed+0x50>)
 *
 * @param[in] bearer_lid          Bearer instance local index
 ****************************************************************************************
 */
__STATIC void m_lay_net_closed(uint8_t bearer_lid)
{
    e1b2:	b570      	push	{r4, r5, r6, lr}
    // Get interface information
    m_lay_net_intf_t *p_intf = &p_m_lay_net_env->intfs[bearer_lid];
    e1b4:	681d      	ldr	r5, [r3, #0]

    // Close the interface
    SETB(p_intf->state, M_LAY_NET_INTF_OPEN, 0);
    e1b6:	230c      	movs	r3, #12
    e1b8:	2101      	movs	r1, #1
    e1ba:	4343      	muls	r3, r0
    e1bc:	18eb      	adds	r3, r5, r3
    e1be:	3354      	adds	r3, #84	; 0x54
    e1c0:	781a      	ldrb	r2, [r3, #0]
    e1c2:	438a      	bics	r2, r1
    e1c4:	701a      	strb	r2, [r3, #0]

    // Store advertising bearer local index
    if (bearer_lid == p_m_lay_net_env->adv_bearer_lid)
    e1c6:	002b      	movs	r3, r5
    e1c8:	3380      	adds	r3, #128	; 0x80
    e1ca:	781a      	ldrb	r2, [r3, #0]
    e1cc:	4282      	cmp	r2, r0
    e1ce:	d101      	bne.n	e1d4 <m_lay_net_closed+0x24>
    {
        p_m_lay_net_env->adv_bearer_lid = M_INVALID_LID;
    e1d0:	22ff      	movs	r2, #255	; 0xff
    e1d2:	701a      	strb	r2, [r3, #0]
    }

    // Consider all pending PDUs as sent
    while (co_list_pick(&p_intf->tx_queue))
    e1d4:	240c      	movs	r4, #12
    e1d6:	4344      	muls	r4, r0
    e1d8:	192e      	adds	r6, r5, r4
    e1da:	364c      	adds	r6, #76	; 0x4c
    e1dc:	6833      	ldr	r3, [r6, #0]
    e1de:	2b00      	cmp	r3, #0
    e1e0:	d006      	beq.n	e1f0 <m_lay_net_closed+0x40>
    {
        // Extract buffer from the queue
        m_tb_buf_t *p_buf = (m_tb_buf_t *)co_list_pop_front(&p_intf->tx_queue);
    e1e2:	0030      	movs	r0, r6
    e1e4:	f7f6 f902 	bl	43ec <co_list_pop_front>

        // Call the sent callback
        m_lay_net_sent(p_buf, M_ERR_BEARER_CLOSED);
    e1e8:	4906      	ldr	r1, [pc, #24]	; (e204 <m_lay_net_closed+0x54>)
    e1ea:	f7ff fed9 	bl	dfa0 <m_lay_net_sent>
    e1ee:	e7f5      	b.n	e1dc <m_lay_net_closed+0x2c>
    }

    SETB(p_intf->state, M_LAY_NET_INTF_IN_TX, 0);
    e1f0:	2202      	movs	r2, #2
    e1f2:	192c      	adds	r4, r5, r4
    e1f4:	3454      	adds	r4, #84	; 0x54
    e1f6:	7823      	ldrb	r3, [r4, #0]
    e1f8:	4393      	bics	r3, r2
    e1fa:	7023      	strb	r3, [r4, #0]
    if (p_m_lay_net_env->p_cb[M_LAY_NET_INTF_GATT_PROXY] != NULL)
    {
        p_m_lay_net_env->p_cb[M_LAY_NET_INTF_GATT_PROXY]->closed(bearer_lid);
    }
    #endif //(BLE_MESH_GATT_PROXY)
}
    e1fc:	bd70      	pop	{r4, r5, r6, pc}
    e1fe:	46c0      	nop			; (mov r8, r8)
    e200:	100126b4 	.word	0x100126b4
    e204:	00000882 	.word	0x00000882

0000e208 <m_lay_net_init>:
 * GLOBAL FUNCTIONS
 ****************************************************************************************
 */

uint16_t m_lay_net_init(bool reset, void *p_env)
{
    e208:	b510      	push	{r4, lr}
    e20a:	4b09      	ldr	r3, [pc, #36]	; (e230 <m_lay_net_init+0x28>)
    e20c:	000c      	movs	r4, r1
    if (!reset)
    e20e:	2800      	cmp	r0, #0
    e210:	d109      	bne.n	e226 <m_lay_net_init+0x1e>
    {
        // Get environment for Network Layer
        p_m_lay_net_env = (m_lay_net_env_t *)p_env;
    e212:	6019      	str	r1, [r3, #0]

        // Initialize environment content
        memset(p_m_lay_net_env, 0, sizeof(m_lay_net_env_t));
    e214:	2284      	movs	r2, #132	; 0x84
    e216:	0001      	movs	r1, r0
    e218:	0020      	movs	r0, r4
    e21a:	f007 fc17 	bl	15a4c <memset>

        // Initialize advertising bearer information
        p_m_lay_net_env->adv_bearer_lid = M_INVALID_LID;
    e21e:	23ff      	movs	r3, #255	; 0xff
    e220:	3480      	adds	r4, #128	; 0x80
    e222:	7023      	strb	r3, [r4, #0]
    e224:	e001      	b.n	e22a <m_lay_net_init+0x22>
    }
    else
    {
        p_m_lay_net_env = NULL;
    e226:	2200      	movs	r2, #0
    e228:	601a      	str	r2, [r3, #0]
    }

    return (sizeof(m_lay_net_env_t));
}
    e22a:	2084      	movs	r0, #132	; 0x84
    e22c:	bd10      	pop	{r4, pc}
    e22e:	46c0      	nop			; (mov r8, r8)
    e230:	100126b4 	.word	0x100126b4

0000e234 <m_lay_net_get_env_size>:

uint16_t m_lay_net_get_env_size(const m_cfg_t* p_cfg)
{
    return (sizeof(m_lay_net_env_t));
}
    e234:	2084      	movs	r0, #132	; 0x84
    e236:	4770      	bx	lr

0000e238 <m_lay_net_connect_api_bearer>:

void m_lay_net_connect_api_bearer(const m_bearer_api_t *p_api)
{
    p_m_lay_net_env->p_bearer_api = p_api;
    e238:	4b01      	ldr	r3, [pc, #4]	; (e240 <m_lay_net_connect_api_bearer+0x8>)
    e23a:	681b      	ldr	r3, [r3, #0]
    e23c:	6058      	str	r0, [r3, #4]
}
    e23e:	4770      	bx	lr
    e240:	100126b4 	.word	0x100126b4

0000e244 <m_lay_net_connect_cb>:
 ****************************************************************************************
 */
__STATIC uint8_t m_lay_net_intf_type_to_idx(uint8_t intf_type)
{
    // Interface index
    uint8_t intf_idx = M_LAY_NET_INTF_NB;
    e244:	1e4b      	subs	r3, r1, #1
    e246:	4199      	sbcs	r1, r3
void m_lay_net_connect_cb(const m_lay_net_cb_t *p_cb, uint8_t intf_type)
{
    // Interface index
    uint8_t intf_idx = m_lay_net_intf_type_to_idx(intf_type);

    p_m_lay_net_env->p_cb[intf_idx] = p_cb;
    e248:	4b02      	ldr	r3, [pc, #8]	; (e254 <m_lay_net_connect_cb+0x10>)
    e24a:	0089      	lsls	r1, r1, #2
    e24c:	681b      	ldr	r3, [r3, #0]
    e24e:	50c8      	str	r0, [r1, r3]
}
    e250:	4770      	bx	lr
    e252:	46c0      	nop			; (mov r8, r8)
    e254:	100126b4 	.word	0x100126b4

0000e258 <m_lay_utrans_check_decrypt_queue>:
 ****************************************************************************************
 */
__STATIC void m_lay_utrans_check_decrypt_queue(void)
{
    // Get first buffer in the encryption queue
    m_tb_buf_t *p_buf = (m_tb_buf_t *)co_list_pick(&p_m_lay_utrans_env->decrypt_queue);
    e258:	4b05      	ldr	r3, [pc, #20]	; (e270 <m_lay_utrans_check_decrypt_queue+0x18>)
 * @brief Check content of decryption queue and push security token for decryption of content
 * of front buffer.
 ****************************************************************************************
 */
__STATIC void m_lay_utrans_check_decrypt_queue(void)
{
    e25a:	b510      	push	{r4, lr}
    e25c:	681b      	ldr	r3, [r3, #0]
    // Get first buffer in the encryption queue
    m_tb_buf_t *p_buf = (m_tb_buf_t *)co_list_pick(&p_m_lay_utrans_env->decrypt_queue);

    if (p_buf)
    e25e:	6a1b      	ldr	r3, [r3, #32]
    e260:	2b00      	cmp	r3, #0
    e262:	d004      	beq.n	e26e <m_lay_utrans_check_decrypt_queue+0x16>
    {
        // Request to start decryption
        m_tb_sec_ccm_dec_start(M_TB_SEC_TOKEN_UTRANS_DEC, m_lay_utrans_ccm_dec_ready_cb,
    e264:	4a03      	ldr	r2, [pc, #12]	; (e274 <m_lay_utrans_check_decrypt_queue+0x1c>)
    e266:	4904      	ldr	r1, [pc, #16]	; (e278 <m_lay_utrans_check_decrypt_queue+0x20>)
    e268:	2002      	movs	r0, #2
    e26a:	f005 fed4 	bl	14016 <m_tb_sec_ccm_dec_start>
                                                          m_lay_utrans_ccm_dec_finished_cb);
    }
}
    e26e:	bd10      	pop	{r4, pc}
    e270:	100126b8 	.word	0x100126b8
    e274:	0000e6a9 	.word	0x0000e6a9
    e278:	0000e491 	.word	0x0000e491

0000e27c <m_lay_utrans_ccm_enc_ready_cb>:
 */
__STATIC uint16_t m_lay_utrans_ccm_enc_ready_cb(uint8_t token_id, const uint8_t **pp_key, const uint8_t **pp_nonce,
                                                const uint8_t **pp_msg, uint8_t **pp_cipher, uint16_t *p_msg_len,
                                                uint8_t *p_mic_len, const uint8_t **pp_auth_data,
                                                uint8_t *p_auth_data_len)
{
    e27c:	b5f0      	push	{r4, r5, r6, r7, lr}
    e27e:	b087      	sub	sp, #28
    e280:	9303      	str	r3, [sp, #12]
    uint16_t status;

    do
    {
        // Retrieve buffer containing the access PDU
        m_tb_buf_t *p_buf_access = (m_tb_buf_t *)co_list_pick(&p_m_lay_utrans_env->tx_queue);
    e282:	4b66      	ldr	r3, [pc, #408]	; (e41c <m_lay_utrans_ccm_enc_ready_cb+0x1a0>)
 */
__STATIC uint16_t m_lay_utrans_ccm_enc_ready_cb(uint8_t token_id, const uint8_t **pp_key, const uint8_t **pp_nonce,
                                                const uint8_t **pp_msg, uint8_t **pp_cipher, uint16_t *p_msg_len,
                                                uint8_t *p_mic_len, const uint8_t **pp_auth_data,
                                                uint8_t *p_auth_data_len)
{
    e284:	9202      	str	r2, [sp, #8]
    uint16_t status;

    do
    {
        // Retrieve buffer containing the access PDU
        m_tb_buf_t *p_buf_access = (m_tb_buf_t *)co_list_pick(&p_m_lay_utrans_env->tx_queue);
    e286:	681c      	ldr	r4, [r3, #0]
 */
__STATIC uint16_t m_lay_utrans_ccm_enc_ready_cb(uint8_t token_id, const uint8_t **pp_key, const uint8_t **pp_nonce,
                                                const uint8_t **pp_msg, uint8_t **pp_cipher, uint16_t *p_msg_len,
                                                uint8_t *p_mic_len, const uint8_t **pp_auth_data,
                                                uint8_t *p_auth_data_len)
{
    e288:	9101      	str	r1, [sp, #4]
    e28a:	69a5      	ldr	r5, [r4, #24]
 ****************************************************************************************
 */
__STATIC uint8_t m_lay_utrans_get_mic_len(uint16_t pdu_len, uint8_t mic_size)
{
    // MIC length, 4 by default
    uint8_t mic_len = 4;
    e28c:	2704      	movs	r7, #4
        // New buffer that will contain the upper transport PDU
        m_tb_buf_t *p_buf_utrans;
        // Pointer to buffer environment in the upper transport buffer
        m_lay_buf_env_t *p_env_utrans;
        // Transport MIC length
        uint8_t mic_len = m_lay_utrans_get_mic_len(p_buf_access->data_len,
    e28e:	7c2a      	ldrb	r2, [r5, #16]
    e290:	892b      	ldrh	r3, [r5, #8]
    e292:	0792      	lsls	r2, r2, #30
    e294:	d500      	bpl.n	e298 <m_lay_utrans_ccm_enc_ready_cb+0x1c>
    e296:	e0b4      	b.n	e402 <m_lay_utrans_ccm_enc_ready_cb+0x186>
                                                   GETB(p_env_access->flags, M_LAY_BUF_SIZE_MIC) ? 8 : 4);
        // Header length for allocated buffer
        uint16_t head_len = m_lay_utrans_get_head_len(p_buf_access->data_len + mic_len, false);
    e298:	b2ba      	uxth	r2, r7
        // TODO
    }
    else
    {
        // Check if PDU will be segmented
        if (pdu_len <= M_LAY_TRANS_ACCESS_UNSEG_SIZE)
    e29a:	189b      	adds	r3, r3, r2
        {
            head_len = M_LAY_TRANS_UNSEG_HEADER_LEN + 9;
    e29c:	220a      	movs	r2, #10
        // TODO
    }
    else
    {
        // Check if PDU will be segmented
        if (pdu_len <= M_LAY_TRANS_ACCESS_UNSEG_SIZE)
    e29e:	b29b      	uxth	r3, r3
        {
            head_len = M_LAY_TRANS_UNSEG_HEADER_LEN + 9;
    e2a0:	9200      	str	r2, [sp, #0]
        // TODO
    }
    else
    {
        // Check if PDU will be segmented
        if (pdu_len <= M_LAY_TRANS_ACCESS_UNSEG_SIZE)
    e2a2:	2b0f      	cmp	r3, #15
    e2a4:	d901      	bls.n	e2aa <m_lay_utrans_ccm_enc_ready_cb+0x2e>
 ****************************************************************************************
 */
__STATIC uint16_t m_lay_utrans_get_head_len(uint16_t pdu_len, bool ctl)
{
    // Header length
    uint16_t head_len = 0;
    e2a6:	2300      	movs	r3, #0
    e2a8:	9300      	str	r3, [sp, #0]
        // Application key information
        const m_tb_key_app_t *p_app_key;
        // Pointer to nonce value buffer
        uint8_t *p_nonce = &p_m_lay_utrans_env->nonce[0];

        if (p_env_access->app_lid == M_TB_KEY_DEVICE_LID)
    e2aa:	7ca8      	ldrb	r0, [r5, #18]
    e2ac:	2800      	cmp	r0, #0
    e2ae:	d104      	bne.n	e2ba <m_lay_utrans_ccm_enc_ready_cb+0x3e>
        {
            // Retrieve device key information
            status = m_tb_key_dev_get((const m_tb_key_dev_t **)&p_app_key);
    e2b0:	a805      	add	r0, sp, #20
    e2b2:	f003 fdcd 	bl	11e50 <m_tb_key_dev_get>
    e2b6:	0006      	movs	r6, r0
    e2b8:	e004      	b.n	e2c4 <m_lay_utrans_ccm_enc_ready_cb+0x48>
        }
        else
        {
            // Retrieve application key information
            status = m_tb_key_app_get(p_env_access->app_lid, &p_app_key, true);
    e2ba:	2201      	movs	r2, #1
    e2bc:	a905      	add	r1, sp, #20
    e2be:	f004 fa69 	bl	12794 <m_tb_key_app_get>
    e2c2:	0006      	movs	r6, r0
        }

        if (status != M_ERR_NO_ERROR)
    e2c4:	2e00      	cmp	r6, #0
    e2c6:	d000      	beq.n	e2ca <m_lay_utrans_ccm_enc_ready_cb+0x4e>
    e2c8:	e0a4      	b.n	e414 <m_lay_utrans_ccm_enc_ready_cb+0x198>
        {
            break;
        }

        // Allocate a new buffer
        status = m_tb_buf_alloc(&p_buf_utrans, head_len, p_buf_access->data_len + mic_len, 0);
    e2ca:	892a      	ldrh	r2, [r5, #8]
    e2cc:	b2bb      	uxth	r3, r7
    e2ce:	189b      	adds	r3, r3, r2
    e2d0:	b29a      	uxth	r2, r3
    e2d2:	9900      	ldr	r1, [sp, #0]
    e2d4:	0033      	movs	r3, r6
    e2d6:	a804      	add	r0, sp, #16
    e2d8:	f003 f92e 	bl	11538 <m_tb_buf_alloc>
    e2dc:	1e06      	subs	r6, r0, #0

        if (status != M_ERR_NO_ERROR)
    e2de:	d000      	beq.n	e2e2 <m_lay_utrans_ccm_enc_ready_cb+0x66>
    e2e0:	e098      	b.n	e414 <m_lay_utrans_ccm_enc_ready_cb+0x198>
            // Could be informed by buffer toolbox if a buffer becomes available
            break;
        }

        // Copy environment from access buffer in the lower transport buffer
        m_tb_buf_copy(p_buf_access, p_buf_utrans, 0, true);
    e2e2:	0002      	movs	r2, r0
    e2e4:	2301      	movs	r3, #1
    e2e6:	9904      	ldr	r1, [sp, #16]
    e2e8:	0028      	movs	r0, r5
    e2ea:	f003 fa19 	bl	11720 <m_tb_buf_copy>

        // Link the two buffers together
        p_env_utrans = (m_lay_buf_env_t *)&p_buf_utrans->env[0];
    e2ee:	9904      	ldr	r1, [sp, #16]
        p_env_access->p_buf_1 = p_buf_utrans;
        p_env_utrans->p_buf_1 = p_buf_access;

        // Update environment
        p_env_utrans->u14.opcode_aid_afk = (p_env_access->app_lid == M_TB_KEY_DEVICE_LID)
    e2f0:	0032      	movs	r2, r6
        // Copy environment from access buffer in the lower transport buffer
        m_tb_buf_copy(p_buf_access, p_buf_utrans, 0, true);

        // Link the two buffers together
        p_env_utrans = (m_lay_buf_env_t *)&p_buf_utrans->env[0];
        p_env_access->p_buf_1 = p_buf_utrans;
    e2f2:	6269      	str	r1, [r5, #36]	; 0x24
        p_env_utrans->p_buf_1 = p_buf_access;
    e2f4:	624d      	str	r5, [r1, #36]	; 0x24

        // Update environment
        p_env_utrans->u14.opcode_aid_afk = (p_env_access->app_lid == M_TB_KEY_DEVICE_LID)
    e2f6:	7cab      	ldrb	r3, [r5, #18]
    e2f8:	2b00      	cmp	r3, #0
    e2fa:	d003      	beq.n	e304 <m_lay_utrans_ccm_enc_ready_cb+0x88>
    e2fc:	2040      	movs	r0, #64	; 0x40
    e2fe:	9a05      	ldr	r2, [sp, #20]
    e300:	7cd2      	ldrb	r2, [r2, #19]
    e302:	4302      	orrs	r2, r0
    e304:	0008      	movs	r0, r1
    e306:	302c      	adds	r0, #44	; 0x2c
    e308:	7002      	strb	r2, [r0, #0]
                                                    ? 0x00 : (p_app_key->aid | M_MSG_AFK_BIT);
        if (mic_len == 8)
    e30a:	2f08      	cmp	r7, #8
    e30c:	d10a      	bne.n	e324 <m_lay_utrans_ccm_enc_ready_cb+0xa8>
        {
            SETB(p_env_utrans->flags, M_LAY_BUF_SIZE_MIC, true);
    e30e:	2002      	movs	r0, #2
    e310:	7c0a      	ldrb	r2, [r1, #16]
    e312:	4302      	orrs	r2, r0
    e314:	740a      	strb	r2, [r1, #16]
    e316:	0022      	movs	r2, r4
    e318:	3230      	adds	r2, #48	; 0x30
        }

        // Compute nonce value
        p_nonce[0] = (p_env_access->app_lid == M_TB_KEY_DEVICE_LID)
    e31a:	2b00      	cmp	r3, #0
    e31c:	d176      	bne.n	e40c <m_lay_utrans_ccm_enc_ready_cb+0x190>
    e31e:	7010      	strb	r0, [r2, #0]
                        ? M_LAY_UTRANS_NONCE_TYPE_DEV : M_LAY_UTRANS_NONCE_TYPE_APP;
        p_nonce[1] = (mic_len == 4) ? 0 : 0x80;
    e320:	2380      	movs	r3, #128	; 0x80
    e322:	e00a      	b.n	e33a <m_lay_utrans_ccm_enc_ready_cb+0xbe>
        {
            SETB(p_env_utrans->flags, M_LAY_BUF_SIZE_MIC, true);
        }

        // Compute nonce value
        p_nonce[0] = (p_env_access->app_lid == M_TB_KEY_DEVICE_LID)
    e324:	1e5a      	subs	r2, r3, #1
    e326:	4193      	sbcs	r3, r2
    e328:	2202      	movs	r2, #2
    e32a:	1ad3      	subs	r3, r2, r3
    e32c:	0022      	movs	r2, r4
    e32e:	3230      	adds	r2, #48	; 0x30
    e330:	7013      	strb	r3, [r2, #0]
                        ? M_LAY_UTRANS_NONCE_TYPE_DEV : M_LAY_UTRANS_NONCE_TYPE_APP;
        p_nonce[1] = (mic_len == 4) ? 0 : 0x80;
    e332:	1f3b      	subs	r3, r7, #4
    e334:	1e5a      	subs	r2, r3, #1
    e336:	4193      	sbcs	r3, r2
    e338:	01db      	lsls	r3, r3, #7
    e33a:	0022      	movs	r2, r4
    e33c:	3231      	adds	r2, #49	; 0x31
    e33e:	7013      	strb	r3, [r2, #0]
 * @return The 24 bit swapped value.
 ****************************************************************************************
 */
__INLINE_S__ uint32_t co_bswap24(uint32_t val24)
{
    return ((val24<<16)&0xFF0000) | ((val24)&0xFF00) | ((val24>>16)&0xFF);
    e340:	696b      	ldr	r3, [r5, #20]
    e342:	041a      	lsls	r2, r3, #16
    e344:	23ff      	movs	r3, #255	; 0xff
    e346:	041b      	lsls	r3, r3, #16
    e348:	4013      	ands	r3, r2
    e34a:	696a      	ldr	r2, [r5, #20]
    e34c:	0c10      	lsrs	r0, r2, #16
    e34e:	b2c0      	uxtb	r0, r0
    e350:	4303      	orrs	r3, r0
    e352:	001a      	movs	r2, r3
    e354:	23ff      	movs	r3, #255	; 0xff
    e356:	6968      	ldr	r0, [r5, #20]
    e358:	021b      	lsls	r3, r3, #8
    e35a:	4003      	ands	r3, r0
    e35c:	4313      	orrs	r3, r2
 */
__INLINE_S__ void co_write24p(void const *ptr24, uint32_t value)
{
    uint8_t *ptr=(uint8_t*)ptr24;

    *ptr++ = (uint8_t)(value&0xff);
    e35e:	0022      	movs	r2, r4
    e360:	3232      	adds	r2, #50	; 0x32
    e362:	7013      	strb	r3, [r2, #0]
    *ptr++ = (uint8_t)((value&0xff00)>>8);
    e364:	0a18      	lsrs	r0, r3, #8
    *ptr++ = (uint8_t)((value&0xff0000)>>16);
    e366:	0c1b      	lsrs	r3, r3, #16
__INLINE_S__ void co_write24p(void const *ptr24, uint32_t value)
{
    uint8_t *ptr=(uint8_t*)ptr24;

    *ptr++ = (uint8_t)(value&0xff);
    *ptr++ = (uint8_t)((value&0xff00)>>8);
    e368:	7050      	strb	r0, [r2, #1]
    *ptr++ = (uint8_t)((value&0xff0000)>>16);
    e36a:	7093      	strb	r3, [r2, #2]
        co_write24p(&p_nonce[2], co_hton24(p_env_access->seq));
        co_write16p(&p_nonce[5], co_htons(p_env_access->src));
    e36c:	8baa      	ldrh	r2, [r5, #28]
 * @return The 16 bit swapped value.
 ****************************************************************************************
 */
__INLINE_S__ uint16_t co_bswap16(uint16_t val16)
{
    return ((val16<<8)&0xFF00) | ((val16>>8)&0xFF);
    e36e:	0213      	lsls	r3, r2, #8
    e370:	0a12      	lsrs	r2, r2, #8
    e372:	431a      	orrs	r2, r3
    e374:	b213      	sxth	r3, r2
 */
__INLINE_S__ void co_write16p(void const *ptr16, uint16_t value)
{
    uint8_t *ptr=(uint8_t*)ptr16;

    *ptr++ = value&0xff;
    e376:	0022      	movs	r2, r4
    e378:	3235      	adds	r2, #53	; 0x35
    e37a:	7013      	strb	r3, [r2, #0]
    *ptr = (value&0xff00)>>8;
    e37c:	0a1b      	lsrs	r3, r3, #8
    e37e:	7053      	strb	r3, [r2, #1]
        co_write16p(&p_nonce[7], co_htons(p_env_access->dst));
    e380:	8bea      	ldrh	r2, [r5, #30]
    e382:	0213      	lsls	r3, r2, #8
    e384:	0a12      	lsrs	r2, r2, #8
    e386:	431a      	orrs	r2, r3
    e388:	b213      	sxth	r3, r2
 */
__INLINE_S__ void co_write16p(void const *ptr16, uint16_t value)
{
    uint8_t *ptr=(uint8_t*)ptr16;

    *ptr++ = value&0xff;
    e38a:	0022      	movs	r2, r4
    e38c:	3237      	adds	r2, #55	; 0x37
    e38e:	7013      	strb	r3, [r2, #0]
    *ptr = (value&0xff00)>>8;
    e390:	0a1b      	lsrs	r3, r3, #8
    e392:	7053      	strb	r3, [r2, #1]
    e394:	69ab      	ldr	r3, [r5, #24]
        // Header length for allocated buffer
        uint16_t head_len = m_lay_utrans_get_head_len(p_buf_access->data_len + mic_len, false);
        // Application key information
        const m_tb_key_app_t *p_app_key;
        // Pointer to nonce value buffer
        uint8_t *p_nonce = &p_m_lay_utrans_env->nonce[0];
    e396:	3430      	adds	r4, #48	; 0x30
    e398:	ba1b      	rev	r3, r3
__INLINE_S__ void co_write32p(void const *ptr32, uint32_t value)
{
    uint8_t *ptr=(uint8_t*)ptr32;

    *ptr++ = (uint8_t)(value&0xff);
    *ptr++ = (uint8_t)((value&0xff00)>>8);
    e39a:	0a18      	lsrs	r0, r3, #8
 */
__INLINE_S__ void co_write32p(void const *ptr32, uint32_t value)
{
    uint8_t *ptr=(uint8_t*)ptr32;

    *ptr++ = (uint8_t)(value&0xff);
    e39c:	7093      	strb	r3, [r2, #2]
    *ptr++ = (uint8_t)((value&0xff00)>>8);
    e39e:	70d0      	strb	r0, [r2, #3]
    *ptr++ = (uint8_t)((value&0xff0000)>>16);
    e3a0:	0c18      	lsrs	r0, r3, #16
    *ptr = (uint8_t)((value&0xff000000)>>24);
    e3a2:	0e1b      	lsrs	r3, r3, #24
    e3a4:	7153      	strb	r3, [r2, #5]
        co_write16p(&p_nonce[5], co_htons(p_env_access->src));
        co_write16p(&p_nonce[7], co_htons(p_env_access->dst));
        co_write32p(&p_nonce[9], co_htonl(p_env_access->u5.iv));

        // Provide the requested information
        *pp_key = &p_app_key->key[0];
    e3a6:	9b05      	ldr	r3, [sp, #20]
{
    uint8_t *ptr=(uint8_t*)ptr32;

    *ptr++ = (uint8_t)(value&0xff);
    *ptr++ = (uint8_t)((value&0xff00)>>8);
    *ptr++ = (uint8_t)((value&0xff0000)>>16);
    e3a8:	7110      	strb	r0, [r2, #4]
    e3aa:	9a01      	ldr	r2, [sp, #4]
    e3ac:	3302      	adds	r3, #2
    e3ae:	6013      	str	r3, [r2, #0]
        *pp_msg = M_TB_BUF_DATA(p_buf_access);
    e3b0:	002a      	movs	r2, r5
    e3b2:	88ab      	ldrh	r3, [r5, #4]
    e3b4:	3230      	adds	r2, #48	; 0x30
    e3b6:	18d3      	adds	r3, r2, r3
    e3b8:	9a03      	ldr	r2, [sp, #12]
    e3ba:	6013      	str	r3, [r2, #0]
        *pp_cipher = M_TB_BUF_DATA(p_buf_utrans);
    e3bc:	000a      	movs	r2, r1
    e3be:	888b      	ldrh	r3, [r1, #4]
    e3c0:	3230      	adds	r2, #48	; 0x30
    e3c2:	18d3      	adds	r3, r2, r3
    e3c4:	9a0c      	ldr	r2, [sp, #48]	; 0x30
    e3c6:	6013      	str	r3, [r2, #0]
        *pp_nonce = &p_nonce[0];
    e3c8:	9b02      	ldr	r3, [sp, #8]
        *p_msg_len = p_buf_access->data_len;
    e3ca:	9a0d      	ldr	r2, [sp, #52]	; 0x34

        // Provide the requested information
        *pp_key = &p_app_key->key[0];
        *pp_msg = M_TB_BUF_DATA(p_buf_access);
        *pp_cipher = M_TB_BUF_DATA(p_buf_utrans);
        *pp_nonce = &p_nonce[0];
    e3cc:	601c      	str	r4, [r3, #0]
        *p_msg_len = p_buf_access->data_len;
    e3ce:	892b      	ldrh	r3, [r5, #8]
    e3d0:	8013      	strh	r3, [r2, #0]
        *p_mic_len = mic_len;
    e3d2:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    e3d4:	701f      	strb	r7, [r3, #0]

        if (M_IS_VIRTUAL_ADDR(p_env_access->dst))
    e3d6:	8be8      	ldrh	r0, [r5, #30]
    e3d8:	0b83      	lsrs	r3, r0, #14
    e3da:	2b02      	cmp	r3, #2
    e3dc:	d109      	bne.n	e3f2 <m_lay_utrans_ccm_enc_ready_cb+0x176>
        {
            m_lid_t va_lid = m_tb_mio_get_label_uuid(p_env_access->dst, 0,
    e3de:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
    e3e0:	2100      	movs	r1, #0
    e3e2:	f005 fa77 	bl	138d4 <m_tb_mio_get_label_uuid>
                                                     (uint8_t **)pp_auth_data);

            if (va_lid == M_INVALID_LID)
    e3e6:	28ff      	cmp	r0, #255	; 0xff
    e3e8:	d009      	beq.n	e3fe <m_lay_utrans_ccm_enc_ready_cb+0x182>
            {
                status = M_ERR_COMMAND_DISALLOWED;
                break;
            }

            *p_auth_data_len = M_LABEL_UUID_LEN;
    e3ea:	2310      	movs	r3, #16
    e3ec:	9a10      	ldr	r2, [sp, #64]	; 0x40
    e3ee:	7013      	strb	r3, [r2, #0]
    e3f0:	e010      	b.n	e414 <m_lay_utrans_ccm_enc_ready_cb+0x198>
        }
        else
        {
            *pp_auth_data = NULL;
    e3f2:	2300      	movs	r3, #0
    e3f4:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
    e3f6:	6013      	str	r3, [r2, #0]
            *p_auth_data_len = 0;
    e3f8:	9a10      	ldr	r2, [sp, #64]	; 0x40
    e3fa:	7013      	strb	r3, [r2, #0]
    e3fc:	e00a      	b.n	e414 <m_lay_utrans_ccm_enc_ready_cb+0x198>
            m_lid_t va_lid = m_tb_mio_get_label_uuid(p_env_access->dst, 0,
                                                     (uint8_t **)pp_auth_data);

            if (va_lid == M_INVALID_LID)
            {
                status = M_ERR_COMMAND_DISALLOWED;
    e3fe:	4e08      	ldr	r6, [pc, #32]	; (e420 <m_lay_utrans_ccm_enc_ready_cb+0x1a4>)
            *pp_auth_data = NULL;
            *p_auth_data_len = 0;
        }
    } while (0);

    return (status);
    e400:	e008      	b.n	e414 <m_lay_utrans_ccm_enc_ready_cb+0x198>
    uint8_t mic_len = 4;

    if (mic_size == 8)
    {
        // Need to find if packet will be segmented by the lower transport layer.
        if ((pdu_len + 8) > M_LAY_TRANS_ACCESS_UNSEG_SIZE)
    e402:	2b07      	cmp	r3, #7
    e404:	dc00      	bgt.n	e408 <m_lay_utrans_ccm_enc_ready_cb+0x18c>
    e406:	e747      	b.n	e298 <m_lay_utrans_ccm_enc_ready_cb+0x1c>
    e408:	19ff      	adds	r7, r7, r7
    e40a:	e745      	b.n	e298 <m_lay_utrans_ccm_enc_ready_cb+0x1c>
        {
            SETB(p_env_utrans->flags, M_LAY_BUF_SIZE_MIC, true);
        }

        // Compute nonce value
        p_nonce[0] = (p_env_access->app_lid == M_TB_KEY_DEVICE_LID)
    e40c:	2301      	movs	r3, #1
    e40e:	7013      	strb	r3, [r2, #0]
                        ? M_LAY_UTRANS_NONCE_TYPE_DEV : M_LAY_UTRANS_NONCE_TYPE_APP;
        p_nonce[1] = (mic_len == 4) ? 0 : 0x80;
    e410:	337f      	adds	r3, #127	; 0x7f
    e412:	e792      	b.n	e33a <m_lay_utrans_ccm_enc_ready_cb+0xbe>
            *p_auth_data_len = 0;
        }
    } while (0);

    return (status);
}
    e414:	0030      	movs	r0, r6
    e416:	b007      	add	sp, #28
    e418:	bdf0      	pop	{r4, r5, r6, r7, pc}
    e41a:	46c0      	nop			; (mov r8, r8)
    e41c:	100126b8 	.word	0x100126b8
    e420:	00000282 	.word	0x00000282

0000e424 <m_lay_utrans_ccm_enc_finished_cb>:
 * @param[in] status            Encryption status
 * @param[in] p_auth_val        Pointer to computed authentication value
 ****************************************************************************************
 */
__STATIC void m_lay_utrans_ccm_enc_finished_cb(uint8_t token_id, uint16_t status, const uint8_t *p_auth_val)
{
    e424:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    // Retrieve buffer containing the access PDU
    m_tb_buf_t *p_buf_access = (m_tb_buf_t *)co_list_pick(&p_m_lay_utrans_env->tx_queue);
    e426:	4c18      	ldr	r4, [pc, #96]	; (e488 <m_lay_utrans_ccm_enc_finished_cb+0x64>)
 * @param[in] status            Encryption status
 * @param[in] p_auth_val        Pointer to computed authentication value
 ****************************************************************************************
 */
__STATIC void m_lay_utrans_ccm_enc_finished_cb(uint8_t token_id, uint16_t status, const uint8_t *p_auth_val)
{
    e428:	1e0d      	subs	r5, r1, #0
    // Retrieve buffer containing the access PDU
    m_tb_buf_t *p_buf_access = (m_tb_buf_t *)co_list_pick(&p_m_lay_utrans_env->tx_queue);
    e42a:	6820      	ldr	r0, [r4, #0]
    e42c:	6986      	ldr	r6, [r0, #24]

    if (status == M_ERR_NO_ERROR)
    e42e:	d114      	bne.n	e45a <m_lay_utrans_ccm_enc_finished_cb+0x36>
        m_lay_buf_env_t *p_env_access = (m_lay_buf_env_t *)&p_buf_access->env[0];
        // Get pointer to the upper transport PDU
        m_tb_buf_t *p_buf_utrans = p_env_access->p_buf_1;

        // Remove the buffer from the encryption queue
        co_list_pop_front(&p_m_lay_utrans_env->tx_queue);
    e430:	3018      	adds	r0, #24
    if (status == M_ERR_NO_ERROR)
    {
        // Get pointer to buffer environment
        m_lay_buf_env_t *p_env_access = (m_lay_buf_env_t *)&p_buf_access->env[0];
        // Get pointer to the upper transport PDU
        m_tb_buf_t *p_buf_utrans = p_env_access->p_buf_1;
    e432:	6a77      	ldr	r7, [r6, #36]	; 0x24

        // Remove the buffer from the encryption queue
        co_list_pop_front(&p_m_lay_utrans_env->tx_queue);
    e434:	f7f5 ffda 	bl	43ec <co_list_pop_front>

        // Try to push the buffer for transmission
        status = p_m_lay_utrans_env->p_ltrans_api->send(p_buf_utrans);
    e438:	6823      	ldr	r3, [r4, #0]
    e43a:	0038      	movs	r0, r7
    e43c:	689b      	ldr	r3, [r3, #8]
    e43e:	681b      	ldr	r3, [r3, #0]
    e440:	4798      	blx	r3

        if (status == M_ERR_CANNOT_FRAGMENT)
    e442:	4b12      	ldr	r3, [pc, #72]	; (e48c <m_lay_utrans_ccm_enc_finished_cb+0x68>)

        // Remove the buffer from the encryption queue
        co_list_pop_front(&p_m_lay_utrans_env->tx_queue);

        // Try to push the buffer for transmission
        status = p_m_lay_utrans_env->p_ltrans_api->send(p_buf_utrans);
    e444:	0005      	movs	r5, r0

        if (status == M_ERR_CANNOT_FRAGMENT)
    e446:	4298      	cmp	r0, r3
    e448:	d105      	bne.n	e456 <m_lay_utrans_ccm_enc_finished_cb+0x32>
        {
            // Insert the buffer in the waiting queue
            co_list_push_back(&p_m_lay_utrans_env->wait_queue, &p_buf_utrans->hdr);
    e44a:	6820      	ldr	r0, [r4, #0]
    e44c:	0039      	movs	r1, r7
    e44e:	3028      	adds	r0, #40	; 0x28
    e450:	f7f5 ffa1 	bl	4396 <co_list_push_back>
    e454:	e013      	b.n	e47e <m_lay_utrans_ccm_enc_finished_cb+0x5a>
            // Consider there is no error
            status = M_ERR_NO_ERROR;
        }
    }

    if (status == M_ERR_NO_ERROR)
    e456:	2800      	cmp	r0, #0
    e458:	d011      	beq.n	e47e <m_lay_utrans_ccm_enc_finished_cb+0x5a>
__STATIC void m_lay_utrans_encrypt_err(m_tb_buf_t *p_buf_access, uint16_t status)
{
    // Get pointer to buffer environment
    m_lay_buf_env_t *p_env_access = (m_lay_buf_env_t *)&p_buf_access->env[0];

    if (p_env_access->p_buf_1)
    e45a:	6a70      	ldr	r0, [r6, #36]	; 0x24
    e45c:	2800      	cmp	r0, #0
    e45e:	d001      	beq.n	e464 <m_lay_utrans_ccm_enc_finished_cb+0x40>
    {
        // Release the buffer containing the Transport PDU
        m_tb_buf_release(p_env_access->p_buf_1);
    e460:	f003 f91c 	bl	1169c <m_tb_buf_release>
    }

    // Remove the buffer from the encryption queue
    co_list_pop_front(&p_m_lay_utrans_env->tx_queue);
    e464:	6820      	ldr	r0, [r4, #0]
    e466:	3018      	adds	r0, #24
    e468:	f7f5 ffc0 	bl	43ec <co_list_pop_front>

    // Inform the access layer that its PDU has not been transmitted
    p_m_lay_utrans_env->p_cb[M_LAY_UTRANS_INTF_ACCESS]->sent(p_buf_access, status);
    e46c:	6823      	ldr	r3, [r4, #0]
    e46e:	0030      	movs	r0, r6
    e470:	681b      	ldr	r3, [r3, #0]
    e472:	0029      	movs	r1, r5
    e474:	681b      	ldr	r3, [r3, #0]
    e476:	4798      	blx	r3

    // Release the buffer containing the access PDU
    m_tb_buf_release(p_buf_access);
    e478:	0030      	movs	r0, r6
    e47a:	f003 f90f 	bl	1169c <m_tb_buf_release>

    // Delay transmission of next message
    m_al_djob_reg(&(p_m_lay_utrans_env->djob));
    e47e:	6820      	ldr	r0, [r4, #0]
    e480:	300c      	adds	r0, #12
    e482:	f7f6 fc03 	bl	4c8c <m_al_djob_reg>
    else
    {
        // End encryption procedure
        m_lay_utrans_encrypt_err(p_buf_access, status);
    }
}
    e486:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    e488:	100126b8 	.word	0x100126b8
    e48c:	00000d82 	.word	0x00000d82

0000e490 <m_lay_utrans_ccm_dec_ready_cb>:
 */
__STATIC uint16_t m_lay_utrans_ccm_dec_ready_cb(uint8_t token_id, const uint8_t **pp_key, const uint8_t **pp_nonce,
                                                const uint8_t **pp_msg, uint8_t **pp_cipher, uint16_t *p_msg_len,
                                                uint8_t *p_mic_len, const uint8_t **pp_auth_data,
                                                uint8_t *p_auth_data_len)
{
    e490:	b5f0      	push	{r4, r5, r6, r7, lr}
    e492:	b08b      	sub	sp, #44	; 0x2c
    e494:	9206      	str	r2, [sp, #24]
        // Retrieve buffer containing the upper transport PDU
        m_tb_buf_t *p_buf_utrans = (m_tb_buf_t *)co_list_pick(&p_m_lay_utrans_env->decrypt_queue);
        // Pointer to buffer environment
        m_lay_buf_env_t *p_env_utrans = (m_lay_buf_env_t *)&p_buf_utrans->env[0];
        // Get MIC length
        uint8_t mic_len = GETB(p_env_utrans->flags, M_LAY_BUF_SIZE_MIC) ? 8 : 4;
    e496:	2204      	movs	r2, #4
 */
__STATIC uint16_t m_lay_utrans_ccm_dec_ready_cb(uint8_t token_id, const uint8_t **pp_key, const uint8_t **pp_nonce,
                                                const uint8_t **pp_msg, uint8_t **pp_cipher, uint16_t *p_msg_len,
                                                uint8_t *p_mic_len, const uint8_t **pp_auth_data,
                                                uint8_t *p_auth_data_len)
{
    e498:	9307      	str	r3, [sp, #28]
    uint16_t status;

    do
    {
        // Retrieve buffer containing the upper transport PDU
        m_tb_buf_t *p_buf_utrans = (m_tb_buf_t *)co_list_pick(&p_m_lay_utrans_env->decrypt_queue);
    e49a:	4b7c      	ldr	r3, [pc, #496]	; (e68c <m_lay_utrans_ccm_dec_ready_cb+0x1fc>)
 */
__STATIC uint16_t m_lay_utrans_ccm_dec_ready_cb(uint8_t token_id, const uint8_t **pp_key, const uint8_t **pp_nonce,
                                                const uint8_t **pp_msg, uint8_t **pp_cipher, uint16_t *p_msg_len,
                                                uint8_t *p_mic_len, const uint8_t **pp_auth_data,
                                                uint8_t *p_auth_data_len)
{
    e49c:	9105      	str	r1, [sp, #20]
    uint16_t status;

    do
    {
        // Retrieve buffer containing the upper transport PDU
        m_tb_buf_t *p_buf_utrans = (m_tb_buf_t *)co_list_pick(&p_m_lay_utrans_env->decrypt_queue);
    e49e:	681d      	ldr	r5, [r3, #0]
        // Pointer to buffer environment
        m_lay_buf_env_t *p_env_utrans = (m_lay_buf_env_t *)&p_buf_utrans->env[0];
        // Get MIC length
        uint8_t mic_len = GETB(p_env_utrans->flags, M_LAY_BUF_SIZE_MIC) ? 8 : 4;
    e4a0:	9203      	str	r2, [sp, #12]
    e4a2:	6a2c      	ldr	r4, [r5, #32]
    e4a4:	7c23      	ldrb	r3, [r4, #16]
    e4a6:	079b      	lsls	r3, r3, #30
    e4a8:	d501      	bpl.n	e4ae <m_lay_utrans_ccm_dec_ready_cb+0x1e>
    e4aa:	2308      	movs	r3, #8
    e4ac:	9303      	str	r3, [sp, #12]
    e4ae:	2380      	movs	r3, #128	; 0x80
    e4b0:	4a77      	ldr	r2, [pc, #476]	; (e690 <m_lay_utrans_ccm_dec_ready_cb+0x200>)
        // Application key information
        const m_tb_key_app_t *p_app_key;
        // Pointer to nonce value buffer
        uint8_t *p_nonce = &p_m_lay_utrans_env->nonce[0];

        if (p_env_utrans->app_lid == M_TB_KEY_DEVICE_LID)
    e4b2:	7ca1      	ldrb	r1, [r4, #18]
    e4b4:	005b      	lsls	r3, r3, #1
        {
            // Retrieve device key information
            M_PRINTF(L_UTARNS, "get dev key");
    e4b6:	6812      	ldr	r2, [r2, #0]
        // Application key information
        const m_tb_key_app_t *p_app_key;
        // Pointer to nonce value buffer
        uint8_t *p_nonce = &p_m_lay_utrans_env->nonce[0];

        if (p_env_utrans->app_lid == M_TB_KEY_DEVICE_LID)
    e4b8:	2900      	cmp	r1, #0
    e4ba:	d11c      	bne.n	e4f6 <m_lay_utrans_ccm_dec_ready_cb+0x66>
        {
            // Retrieve device key information
            M_PRINTF(L_UTARNS, "get dev key");
    e4bc:	421a      	tst	r2, r3
    e4be:	d015      	beq.n	e4ec <m_lay_utrans_ccm_dec_ready_cb+0x5c>
    e4c0:	4e74      	ldr	r6, [pc, #464]	; (e694 <m_lay_utrans_ccm_dec_ready_cb+0x204>)
    e4c2:	0033      	movs	r3, r6
    e4c4:	333f      	adds	r3, #63	; 0x3f
    e4c6:	9300      	str	r3, [sp, #0]
    e4c8:	0032      	movs	r2, r6
    e4ca:	0030      	movs	r0, r6
    e4cc:	2385      	movs	r3, #133	; 0x85
    e4ce:	0031      	movs	r1, r6
    e4d0:	3221      	adds	r2, #33	; 0x21
    e4d2:	009b      	lsls	r3, r3, #2
    e4d4:	3030      	adds	r0, #48	; 0x30
    e4d6:	f7f6 fa69 	bl	49ac <m_print>
    e4da:	0030      	movs	r0, r6
    e4dc:	305d      	adds	r0, #93	; 0x5d
    e4de:	f7f6 fa65 	bl	49ac <m_print>
    e4e2:	0030      	movs	r0, r6
    e4e4:	1db1      	adds	r1, r6, #6
    e4e6:	3069      	adds	r0, #105	; 0x69
    e4e8:	f7f6 fa60 	bl	49ac <m_print>
            status = m_tb_key_dev_get((const m_tb_key_dev_t **)&p_app_key);
    e4ec:	a809      	add	r0, sp, #36	; 0x24
    e4ee:	f003 fcaf 	bl	11e50 <m_tb_key_dev_get>
    e4f2:	0006      	movs	r6, r0
    e4f4:	e01d      	b.n	e532 <m_lay_utrans_ccm_dec_ready_cb+0xa2>
        }
        else
        {
            // Retrieve application key information
            M_PRINTF(L_UTARNS, "get app key app_lid = %d", p_env_utrans->app_lid);
    e4f6:	421a      	tst	r2, r3
    e4f8:	d015      	beq.n	e526 <m_lay_utrans_ccm_dec_ready_cb+0x96>
    e4fa:	4e66      	ldr	r6, [pc, #408]	; (e694 <m_lay_utrans_ccm_dec_ready_cb+0x204>)
    e4fc:	0033      	movs	r3, r6
    e4fe:	0032      	movs	r2, r6
    e500:	0030      	movs	r0, r6
    e502:	333f      	adds	r3, #63	; 0x3f
    e504:	3221      	adds	r2, #33	; 0x21
    e506:	9300      	str	r3, [sp, #0]
    e508:	0031      	movs	r1, r6
    e50a:	4b63      	ldr	r3, [pc, #396]	; (e698 <m_lay_utrans_ccm_dec_ready_cb+0x208>)
    e50c:	3030      	adds	r0, #48	; 0x30
    e50e:	f7f6 fa4d 	bl	49ac <m_print>
    e512:	0030      	movs	r0, r6
    e514:	7ca1      	ldrb	r1, [r4, #18]
    e516:	306c      	adds	r0, #108	; 0x6c
    e518:	f7f6 fa48 	bl	49ac <m_print>
    e51c:	0030      	movs	r0, r6
    e51e:	1db1      	adds	r1, r6, #6
    e520:	3069      	adds	r0, #105	; 0x69
    e522:	f7f6 fa43 	bl	49ac <m_print>
            status = m_tb_key_app_get(p_env_utrans->app_lid, &p_app_key, false);
    e526:	7ca0      	ldrb	r0, [r4, #18]
    e528:	2200      	movs	r2, #0
    e52a:	a909      	add	r1, sp, #36	; 0x24
    e52c:	f004 f932 	bl	12794 <m_tb_key_app_get>
    e530:	0006      	movs	r6, r0
        }

        if (status != M_ERR_NO_ERROR)
    e532:	2e00      	cmp	r6, #0
    e534:	d000      	beq.n	e538 <m_lay_utrans_ccm_dec_ready_cb+0xa8>
    e536:	e0a5      	b.n	e684 <m_lay_utrans_ccm_dec_ready_cb+0x1f4>
        {
            break;
        }

        // Allocate a new buffer
        status = m_tb_buf_alloc(&p_buf_access, 0, p_buf_utrans->data_len - mic_len, 0);
    e538:	466b      	mov	r3, sp
    e53a:	899b      	ldrh	r3, [r3, #12]
    e53c:	0031      	movs	r1, r6
    e53e:	9304      	str	r3, [sp, #16]
    e540:	8922      	ldrh	r2, [r4, #8]
    e542:	a808      	add	r0, sp, #32
    e544:	1ad2      	subs	r2, r2, r3
    e546:	b292      	uxth	r2, r2
    e548:	0033      	movs	r3, r6
    e54a:	f002 fff5 	bl	11538 <m_tb_buf_alloc>
		M_PRINTF(L_UTARNS, "status[%x]", status);
    e54e:	4b50      	ldr	r3, [pc, #320]	; (e690 <m_lay_utrans_ccm_dec_ready_cb+0x200>)
        {
            break;
        }

        // Allocate a new buffer
        status = m_tb_buf_alloc(&p_buf_access, 0, p_buf_utrans->data_len - mic_len, 0);
    e550:	0006      	movs	r6, r0
		M_PRINTF(L_UTARNS, "status[%x]", status);
    e552:	681b      	ldr	r3, [r3, #0]
    e554:	05db      	lsls	r3, r3, #23
    e556:	d515      	bpl.n	e584 <m_lay_utrans_ccm_dec_ready_cb+0xf4>
    e558:	4f4e      	ldr	r7, [pc, #312]	; (e694 <m_lay_utrans_ccm_dec_ready_cb+0x204>)
    e55a:	003b      	movs	r3, r7
    e55c:	003a      	movs	r2, r7
    e55e:	0038      	movs	r0, r7
    e560:	333f      	adds	r3, #63	; 0x3f
    e562:	3221      	adds	r2, #33	; 0x21
    e564:	9300      	str	r3, [sp, #0]
    e566:	0039      	movs	r1, r7
    e568:	4b4c      	ldr	r3, [pc, #304]	; (e69c <m_lay_utrans_ccm_dec_ready_cb+0x20c>)
    e56a:	3030      	adds	r0, #48	; 0x30
    e56c:	f7f6 fa1e 	bl	49ac <m_print>
    e570:	484b      	ldr	r0, [pc, #300]	; (e6a0 <m_lay_utrans_ccm_dec_ready_cb+0x210>)
    e572:	0031      	movs	r1, r6
    e574:	3005      	adds	r0, #5
    e576:	f7f6 fa19 	bl	49ac <m_print>
    e57a:	0038      	movs	r0, r7
    e57c:	1db9      	adds	r1, r7, #6
    e57e:	3069      	adds	r0, #105	; 0x69
    e580:	f7f6 fa14 	bl	49ac <m_print>
        if (status != M_ERR_NO_ERROR)
    e584:	2e00      	cmp	r6, #0
    e586:	d000      	beq.n	e58a <m_lay_utrans_ccm_dec_ready_cb+0xfa>
    e588:	e07c      	b.n	e684 <m_lay_utrans_ccm_dec_ready_cb+0x1f4>
            // Could be informed by buffer toolbox if a buffer becomes available
            break;
        }

        // Copy environment from upper transport buffer in the access buffer
        m_tb_buf_copy(p_buf_utrans, p_buf_access, 0, true);
    e58a:	0032      	movs	r2, r6
    e58c:	2301      	movs	r3, #1
    e58e:	9908      	ldr	r1, [sp, #32]
    e590:	0020      	movs	r0, r4
    e592:	f003 f8c5 	bl	11720 <m_tb_buf_copy>

        // Link the two buffers together
        p_env_utrans->p_buf_1 = p_buf_access;

        // Compute nonce value in the network buffer environment
        p_nonce[0] = (p_env_utrans->app_lid == M_TB_KEY_DEVICE_LID)
    e596:	7ca3      	ldrb	r3, [r4, #18]
    e598:	0028      	movs	r0, r5
    e59a:	1e5a      	subs	r2, r3, #1
    e59c:	4193      	sbcs	r3, r2
    e59e:	2202      	movs	r2, #2

        // Copy environment from upper transport buffer in the access buffer
        m_tb_buf_copy(p_buf_utrans, p_buf_access, 0, true);

        // Link the two buffers together
        p_env_utrans->p_buf_1 = p_buf_access;
    e5a0:	9908      	ldr	r1, [sp, #32]

        // Compute nonce value in the network buffer environment
        p_nonce[0] = (p_env_utrans->app_lid == M_TB_KEY_DEVICE_LID)
    e5a2:	1ad3      	subs	r3, r2, r3
    e5a4:	3030      	adds	r0, #48	; 0x30

        // Copy environment from upper transport buffer in the access buffer
        m_tb_buf_copy(p_buf_utrans, p_buf_access, 0, true);

        // Link the two buffers together
        p_env_utrans->p_buf_1 = p_buf_access;
    e5a6:	6261      	str	r1, [r4, #36]	; 0x24

        // Compute nonce value in the network buffer environment
        p_nonce[0] = (p_env_utrans->app_lid == M_TB_KEY_DEVICE_LID)
    e5a8:	7003      	strb	r3, [r0, #0]
                        ? M_LAY_UTRANS_NONCE_TYPE_DEV : M_LAY_UTRANS_NONCE_TYPE_APP;
        p_nonce[1] = (mic_len == 4) ? 0 : 0x80;
    e5aa:	9b03      	ldr	r3, [sp, #12]
    e5ac:	3b04      	subs	r3, #4
    e5ae:	1e5a      	subs	r2, r3, #1
    e5b0:	4193      	sbcs	r3, r2
    e5b2:	002a      	movs	r2, r5
    e5b4:	01db      	lsls	r3, r3, #7
    e5b6:	3231      	adds	r2, #49	; 0x31
    e5b8:	7013      	strb	r3, [r2, #0]
 * @return The 24 bit swapped value.
 ****************************************************************************************
 */
__INLINE_S__ uint32_t co_bswap24(uint32_t val24)
{
    return ((val24<<16)&0xFF0000) | ((val24)&0xFF00) | ((val24>>16)&0xFF);
    e5ba:	23ff      	movs	r3, #255	; 0xff
        co_write24p(&p_nonce[2], co_hton24(p_env_utrans->seq));
    e5bc:	6962      	ldr	r2, [r4, #20]
    e5be:	041b      	lsls	r3, r3, #16
    e5c0:	0417      	lsls	r7, r2, #16
    e5c2:	403b      	ands	r3, r7
    e5c4:	0c17      	lsrs	r7, r2, #16
    e5c6:	b2ff      	uxtb	r7, r7
    e5c8:	431f      	orrs	r7, r3
    e5ca:	23ff      	movs	r3, #255	; 0xff
    e5cc:	021b      	lsls	r3, r3, #8
    e5ce:	401a      	ands	r2, r3
    e5d0:	003b      	movs	r3, r7
    e5d2:	4313      	orrs	r3, r2
 */
__INLINE_S__ void co_write24p(void const *ptr24, uint32_t value)
{
    uint8_t *ptr=(uint8_t*)ptr24;

    *ptr++ = (uint8_t)(value&0xff);
    e5d4:	002a      	movs	r2, r5
    e5d6:	3232      	adds	r2, #50	; 0x32
    e5d8:	7013      	strb	r3, [r2, #0]
    *ptr++ = (uint8_t)((value&0xff00)>>8);
    e5da:	0a1f      	lsrs	r7, r3, #8
    *ptr++ = (uint8_t)((value&0xff0000)>>16);
    e5dc:	0c1b      	lsrs	r3, r3, #16
__INLINE_S__ void co_write24p(void const *ptr24, uint32_t value)
{
    uint8_t *ptr=(uint8_t*)ptr24;

    *ptr++ = (uint8_t)(value&0xff);
    *ptr++ = (uint8_t)((value&0xff00)>>8);
    e5de:	7057      	strb	r7, [r2, #1]
    *ptr++ = (uint8_t)((value&0xff0000)>>16);
    e5e0:	7093      	strb	r3, [r2, #2]
        co_write16p(&p_nonce[5], co_htons(p_env_utrans->src));
    e5e2:	8ba2      	ldrh	r2, [r4, #28]
 * @return The 16 bit swapped value.
 ****************************************************************************************
 */
__INLINE_S__ uint16_t co_bswap16(uint16_t val16)
{
    return ((val16<<8)&0xFF00) | ((val16>>8)&0xFF);
    e5e4:	0213      	lsls	r3, r2, #8
    e5e6:	0a12      	lsrs	r2, r2, #8
    e5e8:	431a      	orrs	r2, r3
    e5ea:	b213      	sxth	r3, r2
 */
__INLINE_S__ void co_write16p(void const *ptr16, uint16_t value)
{
    uint8_t *ptr=(uint8_t*)ptr16;

    *ptr++ = value&0xff;
    e5ec:	002a      	movs	r2, r5
    e5ee:	3235      	adds	r2, #53	; 0x35
    e5f0:	7013      	strb	r3, [r2, #0]
    *ptr = (value&0xff00)>>8;
    e5f2:	0a1b      	lsrs	r3, r3, #8
    e5f4:	7053      	strb	r3, [r2, #1]
        co_write16p(&p_nonce[7], co_htons(p_env_utrans->dst));
    e5f6:	8be2      	ldrh	r2, [r4, #30]
    e5f8:	0213      	lsls	r3, r2, #8
    e5fa:	0a12      	lsrs	r2, r2, #8
    e5fc:	431a      	orrs	r2, r3
    e5fe:	b213      	sxth	r3, r2
 */
__INLINE_S__ void co_write16p(void const *ptr16, uint16_t value)
{
    uint8_t *ptr=(uint8_t*)ptr16;

    *ptr++ = value&0xff;
    e600:	002a      	movs	r2, r5
    e602:	3237      	adds	r2, #55	; 0x37
    e604:	7013      	strb	r3, [r2, #0]
    *ptr = (value&0xff00)>>8;
    e606:	0a1b      	lsrs	r3, r3, #8
    e608:	7053      	strb	r3, [r2, #1]
    e60a:	69a3      	ldr	r3, [r4, #24]
    uint8_t *ptr=(uint8_t*)ptr32;

    *ptr++ = (uint8_t)(value&0xff);
    *ptr++ = (uint8_t)((value&0xff00)>>8);
    *ptr++ = (uint8_t)((value&0xff0000)>>16);
    *ptr = (uint8_t)((value&0xff000000)>>24);
    e60c:	353c      	adds	r5, #60	; 0x3c
    e60e:	ba1b      	rev	r3, r3
__INLINE_S__ void co_write32p(void const *ptr32, uint32_t value)
{
    uint8_t *ptr=(uint8_t*)ptr32;

    *ptr++ = (uint8_t)(value&0xff);
    *ptr++ = (uint8_t)((value&0xff00)>>8);
    e610:	0a1f      	lsrs	r7, r3, #8
 */
__INLINE_S__ void co_write32p(void const *ptr32, uint32_t value)
{
    uint8_t *ptr=(uint8_t*)ptr32;

    *ptr++ = (uint8_t)(value&0xff);
    e612:	7093      	strb	r3, [r2, #2]
    *ptr++ = (uint8_t)((value&0xff00)>>8);
    e614:	70d7      	strb	r7, [r2, #3]
    *ptr++ = (uint8_t)((value&0xff0000)>>16);
    e616:	0c1f      	lsrs	r7, r3, #16
    *ptr = (uint8_t)((value&0xff000000)>>24);
    e618:	0e1b      	lsrs	r3, r3, #24
{
    uint8_t *ptr=(uint8_t*)ptr32;

    *ptr++ = (uint8_t)(value&0xff);
    *ptr++ = (uint8_t)((value&0xff00)>>8);
    *ptr++ = (uint8_t)((value&0xff0000)>>16);
    e61a:	7117      	strb	r7, [r2, #4]
    *ptr = (uint8_t)((value&0xff000000)>>24);
    e61c:	702b      	strb	r3, [r5, #0]
        co_write32p(&p_nonce[9], co_htonl(p_env_utrans->u5.iv));

        // Provide the requested information
        *pp_key = &p_app_key->key[0];
    e61e:	9b09      	ldr	r3, [sp, #36]	; 0x24
    e620:	9a05      	ldr	r2, [sp, #20]
    e622:	3302      	adds	r3, #2
    e624:	6013      	str	r3, [r2, #0]
        *pp_msg = M_TB_BUF_DATA(p_buf_utrans);
    e626:	0022      	movs	r2, r4
    e628:	88a3      	ldrh	r3, [r4, #4]
    e62a:	3230      	adds	r2, #48	; 0x30
    e62c:	18d3      	adds	r3, r2, r3
    e62e:	9a07      	ldr	r2, [sp, #28]
    e630:	6013      	str	r3, [r2, #0]
        *pp_cipher = M_TB_BUF_DATA(p_buf_access);
    e632:	000a      	movs	r2, r1
    e634:	888b      	ldrh	r3, [r1, #4]
    e636:	3230      	adds	r2, #48	; 0x30
    e638:	18d3      	adds	r3, r2, r3
    e63a:	9a10      	ldr	r2, [sp, #64]	; 0x40
    e63c:	6013      	str	r3, [r2, #0]
        *pp_nonce = &p_nonce[0];
    e63e:	9b06      	ldr	r3, [sp, #24]
    e640:	6018      	str	r0, [r3, #0]
        *p_msg_len = p_buf_utrans->data_len - mic_len;
    e642:	8923      	ldrh	r3, [r4, #8]
    e644:	9a04      	ldr	r2, [sp, #16]
    e646:	1a9b      	subs	r3, r3, r2
    e648:	9a11      	ldr	r2, [sp, #68]	; 0x44
    e64a:	8013      	strh	r3, [r2, #0]
        *p_mic_len = mic_len;
    e64c:	466a      	mov	r2, sp
    e64e:	9b12      	ldr	r3, [sp, #72]	; 0x48
    e650:	7b12      	ldrb	r2, [r2, #12]
    e652:	701a      	strb	r2, [r3, #0]

        if (M_IS_VIRTUAL_ADDR(p_env_utrans->dst))
    e654:	8be0      	ldrh	r0, [r4, #30]
    e656:	0b83      	lsrs	r3, r0, #14
    e658:	2b02      	cmp	r3, #2
    e65a:	d10d      	bne.n	e678 <m_lay_utrans_ccm_dec_ready_cb+0x1e8>
        {
            p_env_utrans->va_lid = m_tb_mio_get_label_uuid(p_env_utrans->dst,
    e65c:	0023      	movs	r3, r4
    e65e:	332e      	adds	r3, #46	; 0x2e
    e660:	7819      	ldrb	r1, [r3, #0]
    e662:	9a13      	ldr	r2, [sp, #76]	; 0x4c
    e664:	f005 f936 	bl	138d4 <m_tb_mio_get_label_uuid>
    e668:	3403      	adds	r4, #3
    e66a:	77e0      	strb	r0, [r4, #31]
                                                           p_env_utrans->u16.nb_dec_attemps_va,
                                                           (uint8_t **)pp_auth_data);

            if (p_env_utrans->va_lid == M_INVALID_LID)
    e66c:	28ff      	cmp	r0, #255	; 0xff
    e66e:	d008      	beq.n	e682 <m_lay_utrans_ccm_dec_ready_cb+0x1f2>
            {
                status = M_ERR_COMMAND_DISALLOWED;
                break;
            }

            *p_auth_data_len = M_LABEL_UUID_LEN;
    e670:	2310      	movs	r3, #16
    e672:	9a14      	ldr	r2, [sp, #80]	; 0x50
    e674:	7013      	strb	r3, [r2, #0]
    e676:	e005      	b.n	e684 <m_lay_utrans_ccm_dec_ready_cb+0x1f4>
        }
        else
        {
            *pp_auth_data = NULL;
    e678:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    e67a:	601e      	str	r6, [r3, #0]
            *p_auth_data_len = 0;
    e67c:	9b14      	ldr	r3, [sp, #80]	; 0x50
    e67e:	701e      	strb	r6, [r3, #0]
    e680:	e000      	b.n	e684 <m_lay_utrans_ccm_dec_ready_cb+0x1f4>
                                                           p_env_utrans->u16.nb_dec_attemps_va,
                                                           (uint8_t **)pp_auth_data);

            if (p_env_utrans->va_lid == M_INVALID_LID)
            {
                status = M_ERR_COMMAND_DISALLOWED;
    e682:	4e08      	ldr	r6, [pc, #32]	; (e6a4 <m_lay_utrans_ccm_dec_ready_cb+0x214>)
            *p_auth_data_len = 0;
        }
    } while (0);

    return (status);
}
    e684:	0030      	movs	r0, r6
    e686:	b00b      	add	sp, #44	; 0x2c
    e688:	bdf0      	pop	{r4, r5, r6, r7, pc}
    e68a:	46c0      	nop			; (mov r8, r8)
    e68c:	100126b8 	.word	0x100126b8
    e690:	10010514 	.word	0x10010514
    e694:	00021c28 	.word	0x00021c28
    e698:	0000021a 	.word	0x0000021a
    e69c:	00000225 	.word	0x00000225
    e6a0:	00021ca8 	.word	0x00021ca8
    e6a4:	00000282 	.word	0x00000282

0000e6a8 <m_lay_utrans_ccm_dec_finished_cb>:
 * @param[in] p_auth_val        Pointer to computed authentication value
 ****************************************************************************************
 */
__STATIC void m_lay_utrans_ccm_dec_finished_cb(uint8_t token_id, uint16_t status, const uint8_t *p_auth_val)
{
	M_PRINTF(L_UTARNS, "token_id = %d status = %d", token_id, status);
    e6a8:	4b3e      	ldr	r3, [pc, #248]	; (e7a4 <m_lay_utrans_ccm_dec_finished_cb+0xfc>)
 * @param[in] status            Encryption status
 * @param[in] p_auth_val        Pointer to computed authentication value
 ****************************************************************************************
 */
__STATIC void m_lay_utrans_ccm_dec_finished_cb(uint8_t token_id, uint16_t status, const uint8_t *p_auth_val)
{
    e6aa:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	M_PRINTF(L_UTARNS, "token_id = %d status = %d", token_id, status);
    e6ac:	681b      	ldr	r3, [r3, #0]
 * @param[in] status            Encryption status
 * @param[in] p_auth_val        Pointer to computed authentication value
 ****************************************************************************************
 */
__STATIC void m_lay_utrans_ccm_dec_finished_cb(uint8_t token_id, uint16_t status, const uint8_t *p_auth_val)
{
    e6ae:	0007      	movs	r7, r0
    e6b0:	000d      	movs	r5, r1
	M_PRINTF(L_UTARNS, "token_id = %d status = %d", token_id, status);
    e6b2:	05db      	lsls	r3, r3, #23
    e6b4:	d518      	bpl.n	e6e8 <m_lay_utrans_ccm_dec_finished_cb+0x40>
    e6b6:	4e3c      	ldr	r6, [pc, #240]	; (e7a8 <m_lay_utrans_ccm_dec_finished_cb+0x100>)
    e6b8:	4c3c      	ldr	r4, [pc, #240]	; (e7ac <m_lay_utrans_ccm_dec_finished_cb+0x104>)
    e6ba:	0033      	movs	r3, r6
    e6bc:	3310      	adds	r3, #16
    e6be:	9300      	str	r3, [sp, #0]
    e6c0:	0022      	movs	r2, r4
    e6c2:	0020      	movs	r0, r4
    e6c4:	239a      	movs	r3, #154	; 0x9a
    e6c6:	3221      	adds	r2, #33	; 0x21
    e6c8:	009b      	lsls	r3, r3, #2
    e6ca:	0021      	movs	r1, r4
    e6cc:	3030      	adds	r0, #48	; 0x30
    e6ce:	f7f6 f96d 	bl	49ac <m_print>
    e6d2:	0030      	movs	r0, r6
    e6d4:	0039      	movs	r1, r7
    e6d6:	3031      	adds	r0, #49	; 0x31
    e6d8:	002a      	movs	r2, r5
    e6da:	f7f6 f967 	bl	49ac <m_print>
    e6de:	0020      	movs	r0, r4
    e6e0:	1da1      	adds	r1, r4, #6
    e6e2:	3069      	adds	r0, #105	; 0x69
    e6e4:	f7f6 f962 	bl	49ac <m_print>
    // Retrieve buffer containing the upper transport PDU
    m_tb_buf_t *p_buf_utrans = (m_tb_buf_t *)co_list_pick(&p_m_lay_utrans_env->decrypt_queue);
    e6e8:	4e31      	ldr	r6, [pc, #196]	; (e7b0 <m_lay_utrans_ccm_dec_finished_cb+0x108>)
    e6ea:	6833      	ldr	r3, [r6, #0]
    e6ec:	0037      	movs	r7, r6
    e6ee:	6a1c      	ldr	r4, [r3, #32]

    if (status == M_ERR_NO_ERROR)
    e6f0:	2d00      	cmp	r5, #0
    e6f2:	d121      	bne.n	e738 <m_lay_utrans_ccm_dec_finished_cb+0x90>
    {
        // Pointer to buffer environment
        m_lay_buf_env_t *p_env_utrans = (m_lay_buf_env_t *)&p_buf_utrans->env[0];
        // Get pointer to access buffer
        m_tb_buf_t *p_buf_access = p_env_utrans->p_buf_1;
    e6f4:	6a65      	ldr	r5, [r4, #36]	; 0x24
		m_printf_hex(L_UTARNS, "get utrans dec data", M_TB_BUF_DATA(p_buf_access), p_buf_access->data_len);
    e6f6:	2080      	movs	r0, #128	; 0x80
    e6f8:	0029      	movs	r1, r5
    e6fa:	88aa      	ldrh	r2, [r5, #4]
    e6fc:	3130      	adds	r1, #48	; 0x30
    e6fe:	188a      	adds	r2, r1, r2
    e700:	4929      	ldr	r1, [pc, #164]	; (e7a8 <m_lay_utrans_ccm_dec_finished_cb+0x100>)
    e702:	892b      	ldrh	r3, [r5, #8]
    e704:	314b      	adds	r1, #75	; 0x4b
    e706:	0040      	lsls	r0, r0, #1
    e708:	f7f6 f9b0 	bl	4a6c <m_printf_hex>
        // Get access buffer environment
        m_lay_buf_env_t *p_env_access = (m_lay_buf_env_t *)&p_buf_access->env[0];

        // Update access buffer environment
        p_env_access->va_lid = p_env_utrans->va_lid;
    e70c:	1ce3      	adds	r3, r4, #3
    e70e:	7fda      	ldrb	r2, [r3, #31]

        // Remove the buffer from the decryption queue
        co_list_pop_front(&p_m_lay_utrans_env->decrypt_queue);
    e710:	6830      	ldr	r0, [r6, #0]
		m_printf_hex(L_UTARNS, "get utrans dec data", M_TB_BUF_DATA(p_buf_access), p_buf_access->data_len);
        // Get access buffer environment
        m_lay_buf_env_t *p_env_access = (m_lay_buf_env_t *)&p_buf_access->env[0];

        // Update access buffer environment
        p_env_access->va_lid = p_env_utrans->va_lid;
    e712:	1ceb      	adds	r3, r5, #3
    e714:	77da      	strb	r2, [r3, #31]

        // Remove the buffer from the decryption queue
        co_list_pop_front(&p_m_lay_utrans_env->decrypt_queue);
    e716:	3020      	adds	r0, #32
    e718:	f7f5 fe68 	bl	43ec <co_list_pop_front>

        // Inform the access layer about reception
        p_m_lay_utrans_env->p_cb[M_LAY_UTRANS_INTF_ACCESS]->rx(p_buf_access);
    e71c:	6833      	ldr	r3, [r6, #0]
    e71e:	0028      	movs	r0, r5
    e720:	681b      	ldr	r3, [r3, #0]
    e722:	685b      	ldr	r3, [r3, #4]
    e724:	4798      	blx	r3

        // Release the buffers
        m_tb_buf_release(p_buf_utrans);
    e726:	0020      	movs	r0, r4
    e728:	f002 ffb8 	bl	1169c <m_tb_buf_release>
        m_tb_buf_release(p_buf_access);
    e72c:	0028      	movs	r0, r5
    e72e:	f002 ffb5 	bl	1169c <m_tb_buf_release>

        // Handle next buffer in the encryption queue
        m_lay_utrans_check_decrypt_queue();
    e732:	f7ff fd91 	bl	e258 <m_lay_utrans_check_decrypt_queue>
    e736:	e033      	b.n	e7a0 <m_lay_utrans_ccm_dec_finished_cb+0xf8>
{
    // Get pointer to buffer environment
    m_lay_buf_env_t *p_env_utrans = (m_lay_buf_env_t *)&p_buf_utrans->env[0];

    // If destination is a virtual address, check if decryption with another label UUID can be tried
    if (M_IS_VIRTUAL_ADDR(p_env_utrans->dst) && (p_env_utrans->va_lid != M_INVALID_LID))
    e738:	8be3      	ldrh	r3, [r4, #30]
    e73a:	0b9b      	lsrs	r3, r3, #14
    e73c:	2b02      	cmp	r3, #2
    e73e:	d109      	bne.n	e754 <m_lay_utrans_ccm_dec_finished_cb+0xac>
    e740:	1ce3      	adds	r3, r4, #3
    e742:	7fdb      	ldrb	r3, [r3, #31]
    e744:	2bff      	cmp	r3, #255	; 0xff
    e746:	d005      	beq.n	e754 <m_lay_utrans_ccm_dec_finished_cb+0xac>
    {
        // Increase decryption attempt counter for virtual address
        p_env_utrans->u16.nb_dec_attemps_va++;
    e748:	0022      	movs	r2, r4
    e74a:	322e      	adds	r2, #46	; 0x2e
    e74c:	7813      	ldrb	r3, [r2, #0]
    e74e:	3301      	adds	r3, #1
    e750:	7013      	strb	r3, [r2, #0]
    e752:	e014      	b.n	e77e <m_lay_utrans_ccm_dec_finished_cb+0xd6>
    }
    else
    {
        if (p_env_utrans->app_lid != M_TB_KEY_DEVICE_LID)
    e754:	7ca3      	ldrb	r3, [r4, #18]
    e756:	2b00      	cmp	r3, #0
    e758:	d00f      	beq.n	e77a <m_lay_utrans_ccm_dec_finished_cb+0xd2>
        {
            // Extract AID and look for application key
            uint8_t aid = GETF(p_env_utrans->u14.opcode_aid_afk, M_MSG_AID);
    e75a:	0023      	movs	r3, r4

            // Check if a new decryption attempt can be started
            p_env_utrans->app_lid
                         = m_tb_key_app_lid_from_net_aid(p_env_utrans->net_lid, aid,
    e75c:	0025      	movs	r5, r4
    else
    {
        if (p_env_utrans->app_lid != M_TB_KEY_DEVICE_LID)
        {
            // Extract AID and look for application key
            uint8_t aid = GETF(p_env_utrans->u14.opcode_aid_afk, M_MSG_AID);
    e75e:	332c      	adds	r3, #44	; 0x2c

            // Check if a new decryption attempt can be started
            p_env_utrans->app_lid
                         = m_tb_key_app_lid_from_net_aid(p_env_utrans->net_lid, aid,
    e760:	7819      	ldrb	r1, [r3, #0]
    e762:	233f      	movs	r3, #63	; 0x3f
    e764:	352d      	adds	r5, #45	; 0x2d
    e766:	4019      	ands	r1, r3
    e768:	782a      	ldrb	r2, [r5, #0]
    e76a:	7c60      	ldrb	r0, [r4, #17]
    e76c:	f004 f85e 	bl	1282c <m_tb_key_app_lid_from_net_aid>
    e770:	74a0      	strb	r0, [r4, #18]
                                                         p_env_utrans->u15.nb_dec_attempts);

            // Increase number of decryption attempts
            p_env_utrans->u15.nb_dec_attempts++;
    e772:	782b      	ldrb	r3, [r5, #0]
    e774:	3301      	adds	r3, #1
    e776:	702b      	strb	r3, [r5, #0]
    e778:	e001      	b.n	e77e <m_lay_utrans_ccm_dec_finished_cb+0xd6>
        }
        else
        {
            p_env_utrans->app_lid = M_INVALID_LID;
    e77a:	23ff      	movs	r3, #255	; 0xff
    e77c:	74a3      	strb	r3, [r4, #18]
        }
    }

    if (p_env_utrans->app_lid == M_INVALID_LID)
    e77e:	7ca3      	ldrb	r3, [r4, #18]
    e780:	2bff      	cmp	r3, #255	; 0xff
    e782:	d10b      	bne.n	e79c <m_lay_utrans_ccm_dec_finished_cb+0xf4>
    {
        // Remove the buffer from the encryption queue
        co_list_pop_front(&p_m_lay_utrans_env->decrypt_queue);
    e784:	6838      	ldr	r0, [r7, #0]
    e786:	3020      	adds	r0, #32
    e788:	f7f5 fe30 	bl	43ec <co_list_pop_front>

        if (p_env_utrans->p_buf_1)
    e78c:	6a60      	ldr	r0, [r4, #36]	; 0x24
    e78e:	2800      	cmp	r0, #0
    e790:	d001      	beq.n	e796 <m_lay_utrans_ccm_dec_finished_cb+0xee>
        {
            // Release the buffer containing the access PDU
            m_tb_buf_release(p_env_utrans->p_buf_1);
    e792:	f002 ff83 	bl	1169c <m_tb_buf_release>
        }

        // Release the buffer containing the upper transport PDU
        m_tb_buf_release(p_buf_utrans);
    e796:	0020      	movs	r0, r4
    e798:	f002 ff80 	bl	1169c <m_tb_buf_release>
    }

    // Handle next buffer in the decryption queue
    m_lay_utrans_check_decrypt_queue();
    e79c:	f7ff fd5c 	bl	e258 <m_lay_utrans_check_decrypt_queue>
    else
    {
        // Handle decryption error
        m_lay_utrans_decrypt_err(p_buf_utrans, status);
    }
}
    e7a0:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
    e7a2:	46c0      	nop			; (mov r8, r8)
    e7a4:	10010514 	.word	0x10010514
    e7a8:	00021ca8 	.word	0x00021ca8
    e7ac:	00021c28 	.word	0x00021c28
    e7b0:	100126b8 	.word	0x100126b8

0000e7b4 <m_lay_utrans_send>:
 *
 * @return M_ERR_NO_ERROR if PDU has been properly pushed.
 ****************************************************************************************
 */
__STATIC uint16_t m_lay_utrans_send(m_tb_buf_t *p_buf, uint8_t intf_type)
{
    e7b4:	b570      	push	{r4, r5, r6, lr}
    e7b6:	000d      	movs	r5, r1
    // Get pointer to buffer environment in the provided buffer
    m_lay_buf_env_t *p_env = (m_lay_buf_env_t *)&p_buf->env[0];
	m_printf_hex(L_NET, "m_lay_utrans_send", M_TB_BUF_DATA(p_buf), p_buf->data_len);
    e7b8:	0001      	movs	r1, r0
    e7ba:	8882      	ldrh	r2, [r0, #4]
    e7bc:	3130      	adds	r1, #48	; 0x30
    e7be:	188a      	adds	r2, r1, r2
    e7c0:	4912      	ldr	r1, [pc, #72]	; (e80c <m_lay_utrans_send+0x58>)
    e7c2:	8903      	ldrh	r3, [r0, #8]
 *
 * @return M_ERR_NO_ERROR if PDU has been properly pushed.
 ****************************************************************************************
 */
__STATIC uint16_t m_lay_utrans_send(m_tb_buf_t *p_buf, uint8_t intf_type)
{
    e7c4:	0004      	movs	r4, r0
    // Get pointer to buffer environment in the provided buffer
    m_lay_buf_env_t *p_env = (m_lay_buf_env_t *)&p_buf->env[0];
	m_printf_hex(L_NET, "m_lay_utrans_send", M_TB_BUF_DATA(p_buf), p_buf->data_len);
    e7c6:	315f      	adds	r1, #95	; 0x5f
    e7c8:	2010      	movs	r0, #16
    e7ca:	f7f6 f94f 	bl	4a6c <m_printf_hex>
    // Initialize pointer to buffer that will contain the encrypted messasge
    p_env->p_buf_1 = NULL;
    e7ce:	2300      	movs	r3, #0
    e7d0:	6263      	str	r3, [r4, #36]	; 0x24

    switch (intf_type)
    {
        case (M_LAY_UTRANS_INTF_TYPE_ACCESS):
        {
            intf_idx = M_LAY_UTRANS_INTF_ACCESS;
    e7d2:	1e2b      	subs	r3, r5, #0
__STATIC uint8_t m_lay_utrans_intf_type_to_idx(uint8_t intf_type)
{
    // Interface index
    uint8_t intf_idx = M_LAY_UTRANS_INTF_NB;

    switch (intf_type)
    e7d4:	d004      	beq.n	e7e0 <m_lay_utrans_send+0x2c>
 ****************************************************************************************
 */
__STATIC uint8_t m_lay_utrans_intf_type_to_idx(uint8_t intf_type)
{
    // Interface index
    uint8_t intf_idx = M_LAY_UTRANS_INTF_NB;
    e7d6:	3d01      	subs	r5, #1
    e7d8:	426b      	negs	r3, r5
    e7da:	416b      	adcs	r3, r5
    e7dc:	2502      	movs	r5, #2
    e7de:	1aeb      	subs	r3, r5, r3
    m_lay_buf_env_t *p_env = (m_lay_buf_env_t *)&p_buf->env[0];
	m_printf_hex(L_NET, "m_lay_utrans_send", M_TB_BUF_DATA(p_buf), p_buf->data_len);
    // Initialize pointer to buffer that will contain the encrypted messasge
    p_env->p_buf_1 = NULL;
    // Set interface index
    p_env->u15.intf_idx_utrans = m_lay_utrans_intf_type_to_idx(intf_type);
    e7e0:	0022      	movs	r2, r4
    e7e2:	322d      	adds	r2, #45	; 0x2d
    e7e4:	7013      	strb	r3, [r2, #0]

    // Acquire the buffer
    m_tb_buf_acquire(p_buf);
    e7e6:	0020      	movs	r0, r4
    e7e8:	f002 ff54 	bl	11694 <m_tb_buf_acquire>

    // Push the buffer in the transmission queue
    co_list_push_back(&p_m_lay_utrans_env->tx_queue, &p_buf->hdr);
    e7ec:	4d08      	ldr	r5, [pc, #32]	; (e810 <m_lay_utrans_send+0x5c>)
    e7ee:	0021      	movs	r1, r4
    e7f0:	6828      	ldr	r0, [r5, #0]
    e7f2:	3018      	adds	r0, #24
    e7f4:	f7f5 fdcf 	bl	4396 <co_list_push_back>

    // If buffer is the first element in the transmission queue, program transmission
    if ((m_tb_buf_t *)co_list_pick(&p_m_lay_utrans_env->tx_queue) == p_buf)
    e7f8:	6828      	ldr	r0, [r5, #0]
    e7fa:	6983      	ldr	r3, [r0, #24]
    e7fc:	429c      	cmp	r4, r3
    e7fe:	d102      	bne.n	e806 <m_lay_utrans_send+0x52>
    {
        // Delay message transmission
        m_al_djob_reg(&(p_m_lay_utrans_env->djob));
    e800:	300c      	adds	r0, #12
    e802:	f7f6 fa43 	bl	4c8c <m_al_djob_reg>
    }

    return (M_ERR_NO_ERROR);
}
    e806:	2000      	movs	r0, #0
    e808:	bd70      	pop	{r4, r5, r6, pc}
    e80a:	46c0      	nop			; (mov r8, r8)
    e80c:	00021ca8 	.word	0x00021ca8
    e810:	100126b8 	.word	0x100126b8

0000e814 <m_lay_utrans_sent>:
 * @param[in] p_buf_utrans      Pointer to buffer containing the upper transport PDU.
 * @param[in] status            Transmission status
 ****************************************************************************************
 */
__STATIC void m_lay_utrans_sent(m_tb_buf_t *p_buf_utrans, uint16_t status)
{
    e814:	b570      	push	{r4, r5, r6, lr}
    // Pointer to buffer environment
    m_lay_buf_env_t *p_env_utrans = (m_lay_buf_env_t *)&p_buf_utrans->env[0];

    if (!GETB(p_env_utrans->ttl_ctl, M_MSG_CTL))
    e816:	1c43      	adds	r3, r0, #1
    e818:	7fdb      	ldrb	r3, [r3, #31]
 * @param[in] p_buf_utrans      Pointer to buffer containing the upper transport PDU.
 * @param[in] status            Transmission status
 ****************************************************************************************
 */
__STATIC void m_lay_utrans_sent(m_tb_buf_t *p_buf_utrans, uint16_t status)
{
    e81a:	0004      	movs	r4, r0
    e81c:	4d18      	ldr	r5, [pc, #96]	; (e880 <m_lay_utrans_sent+0x6c>)
    // Pointer to buffer environment
    m_lay_buf_env_t *p_env_utrans = (m_lay_buf_env_t *)&p_buf_utrans->env[0];

    if (!GETB(p_env_utrans->ttl_ctl, M_MSG_CTL))
    e81e:	2b7f      	cmp	r3, #127	; 0x7f
    e820:	d80e      	bhi.n	e840 <m_lay_utrans_sent+0x2c>
    {
        // Retrieve buffer containing the Access PDU
        m_tb_buf_t *p_buf_access = p_env_utrans->p_buf_1;
    e822:	6a46      	ldr	r6, [r0, #36]	; 0x24

        // TODO [LT] - Is this check really needed if not debug
        if (p_buf_access && (p_env_utrans->model_lid != M_INVALID_LID))
    e824:	2e00      	cmp	r6, #0
    e826:	d013      	beq.n	e850 <m_lay_utrans_sent+0x3c>
    e828:	7cc3      	ldrb	r3, [r0, #19]
    e82a:	2bff      	cmp	r3, #255	; 0xff
    e82c:	d010      	beq.n	e850 <m_lay_utrans_sent+0x3c>
        {
            // Forward the transmission status
            p_m_lay_utrans_env->p_cb[M_LAY_UTRANS_INTF_ACCESS]->sent(p_buf_access, status);
    e82e:	682b      	ldr	r3, [r5, #0]
    e830:	0030      	movs	r0, r6
    e832:	681b      	ldr	r3, [r3, #0]
    e834:	681b      	ldr	r3, [r3, #0]
    e836:	4798      	blx	r3

            // Release the buffer
            m_tb_buf_release(p_buf_access);
    e838:	0030      	movs	r0, r6
    e83a:	f002 ff2f 	bl	1169c <m_tb_buf_release>
    e83e:	e007      	b.n	e850 <m_lay_utrans_sent+0x3c>
        }
    }
    else
    {
        // Forward the transmission status
        p_m_lay_utrans_env->p_cb[p_env_utrans->u15.intf_idx_utrans]->sent(p_buf_utrans, status);
    e840:	0003      	movs	r3, r0
    e842:	332d      	adds	r3, #45	; 0x2d
    e844:	781b      	ldrb	r3, [r3, #0]
    e846:	682a      	ldr	r2, [r5, #0]
    e848:	009b      	lsls	r3, r3, #2
    e84a:	589b      	ldr	r3, [r3, r2]
    e84c:	681b      	ldr	r3, [r3, #0]
    e84e:	4798      	blx	r3
    }

    // Release the buffer
    m_tb_buf_release(p_buf_utrans);
    e850:	0020      	movs	r0, r4
    e852:	f002 ff23 	bl	1169c <m_tb_buf_release>

    // Check if a buffer waiting for fragmentation can be pushed
    p_buf_utrans = (m_tb_buf_t *)co_list_pick(&p_m_lay_utrans_env->wait_queue);
    e856:	6828      	ldr	r0, [r5, #0]
    e858:	6a84      	ldr	r4, [r0, #40]	; 0x28

    if (p_buf_utrans)
    e85a:	2c00      	cmp	r4, #0
    e85c:	d00e      	beq.n	e87c <m_lay_utrans_sent+0x68>
    {
        // Remove the buffer from the TX queue
        co_list_pop_front(&p_m_lay_utrans_env->wait_queue);
    e85e:	3028      	adds	r0, #40	; 0x28
    e860:	f7f5 fdc4 	bl	43ec <co_list_pop_front>

        // Try to push the buffer for transmission
        status = p_m_lay_utrans_env->p_ltrans_api->send(p_buf_utrans);
    e864:	682b      	ldr	r3, [r5, #0]
    e866:	0020      	movs	r0, r4
    e868:	689b      	ldr	r3, [r3, #8]
    e86a:	681b      	ldr	r3, [r3, #0]
    e86c:	4798      	blx	r3

        if (status == M_ERR_NO_ERROR)
    e86e:	2800      	cmp	r0, #0
    e870:	d104      	bne.n	e87c <m_lay_utrans_sent+0x68>
        {
            // Insert the buffer in the TX queue
            co_list_push_front(&p_m_lay_utrans_env->wait_queue, &p_buf_utrans->hdr);
    e872:	6828      	ldr	r0, [r5, #0]
    e874:	0021      	movs	r1, r4
    e876:	3028      	adds	r0, #40	; 0x28
    e878:	f7f5 fdae 	bl	43d8 <co_list_push_front>
        }
    }
}
    e87c:	bd70      	pop	{r4, r5, r6, pc}
    e87e:	46c0      	nop			; (mov r8, r8)
    e880:	100126b8 	.word	0x100126b8

0000e884 <m_lay_utrans_rx>:
 *
 * @param[in] p_buf_utrans        Pointer to the buffer containing the received upper transport PDU.
 ****************************************************************************************
 */
__STATIC void m_lay_utrans_rx(m_tb_buf_t *p_buf_utrans)
{
    e884:	b570      	push	{r4, r5, r6, lr}
	m_printf_hex(L_UTARNS, "m_lay_utrans_rx", M_TB_BUF_DATA(p_buf_utrans), p_buf_utrans->data_len);
    e886:	0001      	movs	r1, r0
    e888:	8903      	ldrh	r3, [r0, #8]
    e88a:	8882      	ldrh	r2, [r0, #4]
 *
 * @param[in] p_buf_utrans        Pointer to the buffer containing the received upper transport PDU.
 ****************************************************************************************
 */
__STATIC void m_lay_utrans_rx(m_tb_buf_t *p_buf_utrans)
{
    e88c:	0004      	movs	r4, r0
	m_printf_hex(L_UTARNS, "m_lay_utrans_rx", M_TB_BUF_DATA(p_buf_utrans), p_buf_utrans->data_len);
    e88e:	2080      	movs	r0, #128	; 0x80
    e890:	3130      	adds	r1, #48	; 0x30
    e892:	188a      	adds	r2, r1, r2
    e894:	4921      	ldr	r1, [pc, #132]	; (e91c <m_lay_utrans_rx+0x98>)
    e896:	0040      	lsls	r0, r0, #1
    e898:	3171      	adds	r1, #113	; 0x71
    e89a:	f7f6 f8e7 	bl	4a6c <m_printf_hex>
    // Get pointer to buffer environment
    m_lay_buf_env_t *p_env_utrans = (m_lay_buf_env_t *)&p_buf_utrans->env[0];

    // Check if received PDU is an access or a control PDU
    if (GETB(p_env_utrans->ttl_ctl, M_MSG_CTL))
    e89e:	1c63      	adds	r3, r4, #1
    e8a0:	7fda      	ldrb	r2, [r3, #31]
    e8a2:	332b      	adds	r3, #43	; 0x2b
    e8a4:	2a7f      	cmp	r2, #127	; 0x7f
    e8a6:	d90c      	bls.n	e8c2 <m_lay_utrans_rx+0x3e>
__STATIC void m_lay_utrans_ctl_handler(m_tb_buf_t *p_buf_ltrans)
{
    // Get buffer environment
    m_lay_buf_env_t *p_env = (m_lay_buf_env_t *)&p_buf_ltrans->env[0];
    // Read opcode
    uint8_t opcode = p_env->u14.opcode_aid_afk;
    e8a8:	781b      	ldrb	r3, [r3, #0]

    // Check opcode value
    if ((opcode >= M_LAY_UTRANS_OPCODE_FRIEND_POLL) && (opcode <= M_LAY_UTRANS_OPCODE_HEARTBEAT))
    e8aa:	1e5a      	subs	r2, r3, #1
    e8ac:	2a09      	cmp	r2, #9
    e8ae:	d834      	bhi.n	e91a <m_lay_utrans_rx+0x96>
    {
        // Call the appropriate handler
        switch (opcode)
    e8b0:	2b0a      	cmp	r3, #10
    e8b2:	d132      	bne.n	e91a <m_lay_utrans_rx+0x96>
        {
            case (M_LAY_UTRANS_OPCODE_HEARTBEAT):
            {
                // Inform the Low Power Node module about reception
                p_m_lay_utrans_env->p_cb[M_LAY_UTRANS_INTF_HB]->rx(p_buf_ltrans);
    e8b4:	4b1a      	ldr	r3, [pc, #104]	; (e920 <m_lay_utrans_rx+0x9c>)
    e8b6:	0020      	movs	r0, r4
    e8b8:	681b      	ldr	r3, [r3, #0]
    e8ba:	685b      	ldr	r3, [r3, #4]
    e8bc:	685b      	ldr	r3, [r3, #4]
    e8be:	4798      	blx	r3
    e8c0:	e02b      	b.n	e91a <m_lay_utrans_rx+0x96>
        m_lay_utrans_ctl_handler(p_buf_utrans);
    }
    else
    {
        // Check if PDU has been encrypted using application or device key
        if (GETB(p_env_utrans->u14.opcode_aid_afk, M_MSG_AFK))
    e8c2:	7819      	ldrb	r1, [r3, #0]
    e8c4:	2340      	movs	r3, #64	; 0x40
    e8c6:	400b      	ands	r3, r1
    e8c8:	d007      	beq.n	e8da <m_lay_utrans_rx+0x56>
        {
            // Extract AID and look for application key
            uint8_t aid = GETF(p_env_utrans->u14.opcode_aid_afk, M_MSG_AID);

            // Look for an application with this AID and the network LID
            p_env_utrans->app_lid = m_tb_key_app_lid_from_net_aid(p_env_utrans->net_lid, aid, 0);
    e8ca:	233f      	movs	r3, #63	; 0x3f
    e8cc:	7c60      	ldrb	r0, [r4, #17]
    e8ce:	4019      	ands	r1, r3
    e8d0:	2200      	movs	r2, #0
    e8d2:	f003 ffab 	bl	1282c <m_tb_key_app_lid_from_net_aid>
    e8d6:	74a0      	strb	r0, [r4, #18]
    e8d8:	e000      	b.n	e8dc <m_lay_utrans_rx+0x58>
        }
        else
        {
            // Use device key
            p_env_utrans->app_lid = M_TB_KEY_DEVICE_LID;
    e8da:	74a3      	strb	r3, [r4, #18]
        }

        if (p_env_utrans->app_lid != M_INVALID_LID)
    e8dc:	7ca3      	ldrb	r3, [r4, #18]
    e8de:	2bff      	cmp	r3, #255	; 0xff
    e8e0:	d01b      	beq.n	e91a <m_lay_utrans_rx+0x96>
        {
            // Acquire buffer
            m_tb_buf_acquire(p_buf_utrans);
    e8e2:	0020      	movs	r0, r4
    e8e4:	f002 fed6 	bl	11694 <m_tb_buf_acquire>

            // Initialize buffer environment
            p_env_utrans->p_buf_1 = NULL;
            p_env_utrans->u15.nb_dec_attempts = 1;
    e8e8:	0022      	movs	r2, r4
        {
            // Acquire buffer
            m_tb_buf_acquire(p_buf_utrans);

            // Initialize buffer environment
            p_env_utrans->p_buf_1 = NULL;
    e8ea:	2300      	movs	r3, #0
            p_env_utrans->u15.nb_dec_attempts = 1;
    e8ec:	2101      	movs	r1, #1
    e8ee:	322d      	adds	r2, #45	; 0x2d
        {
            // Acquire buffer
            m_tb_buf_acquire(p_buf_utrans);

            // Initialize buffer environment
            p_env_utrans->p_buf_1 = NULL;
    e8f0:	6263      	str	r3, [r4, #36]	; 0x24
            p_env_utrans->u15.nb_dec_attempts = 1;
    e8f2:	7011      	strb	r1, [r2, #0]
            p_env_utrans->u16.nb_dec_attemps_va = 0;
    e8f4:	7053      	strb	r3, [r2, #1]
            p_env_utrans->va_lid = M_INVALID_LID;
    e8f6:	22ff      	movs	r2, #255	; 0xff

            // Push the buffer in the decryption queue
            co_list_push_back(&p_m_lay_utrans_env->decrypt_queue, &p_buf_utrans->hdr);
    e8f8:	4d09      	ldr	r5, [pc, #36]	; (e920 <m_lay_utrans_rx+0x9c>)

            // Initialize buffer environment
            p_env_utrans->p_buf_1 = NULL;
            p_env_utrans->u15.nb_dec_attempts = 1;
            p_env_utrans->u16.nb_dec_attemps_va = 0;
            p_env_utrans->va_lid = M_INVALID_LID;
    e8fa:	1ce3      	adds	r3, r4, #3

            // Push the buffer in the decryption queue
            co_list_push_back(&p_m_lay_utrans_env->decrypt_queue, &p_buf_utrans->hdr);
    e8fc:	6828      	ldr	r0, [r5, #0]

            // Initialize buffer environment
            p_env_utrans->p_buf_1 = NULL;
            p_env_utrans->u15.nb_dec_attempts = 1;
            p_env_utrans->u16.nb_dec_attemps_va = 0;
            p_env_utrans->va_lid = M_INVALID_LID;
    e8fe:	77da      	strb	r2, [r3, #31]

            // Push the buffer in the decryption queue
            co_list_push_back(&p_m_lay_utrans_env->decrypt_queue, &p_buf_utrans->hdr);
    e900:	3020      	adds	r0, #32
    e902:	0021      	movs	r1, r4
    e904:	f7f5 fd47 	bl	4396 <co_list_push_back>
    e908:	682b      	ldr	r3, [r5, #0]

            // If buffer is the first element in the encryption queue, request to start decryption
            if ((m_tb_buf_t *)co_list_pick(&p_m_lay_utrans_env->decrypt_queue) == p_buf_utrans)
    e90a:	6a1b      	ldr	r3, [r3, #32]
    e90c:	429c      	cmp	r4, r3
    e90e:	d104      	bne.n	e91a <m_lay_utrans_rx+0x96>
            {
                m_tb_sec_ccm_dec_start(M_TB_SEC_TOKEN_UTRANS_DEC, m_lay_utrans_ccm_dec_ready_cb,
    e910:	4a04      	ldr	r2, [pc, #16]	; (e924 <m_lay_utrans_rx+0xa0>)
    e912:	4905      	ldr	r1, [pc, #20]	; (e928 <m_lay_utrans_rx+0xa4>)
    e914:	2002      	movs	r0, #2
    e916:	f005 fb7e 	bl	14016 <m_tb_sec_ccm_dec_start>
                                                                  m_lay_utrans_ccm_dec_finished_cb);
            }
        }
        // else discard the PDU
    }
}
    e91a:	bd70      	pop	{r4, r5, r6, pc}
    e91c:	00021ca8 	.word	0x00021ca8
    e920:	100126b8 	.word	0x100126b8
    e924:	0000e6a9 	.word	0x0000e6a9
    e928:	0000e491 	.word	0x0000e491

0000e92c <m_lay_utrans_tx>:
 * @brief Delayed function for transmission of message.
 ****************************************************************************************
 */
__STATIC void m_lay_utrans_tx(void *p_env)
{
	M_PRINTF(L_UTARNS, "");
    e92c:	4b24      	ldr	r3, [pc, #144]	; (e9c0 <m_lay_utrans_tx+0x94>)
 ****************************************************************************************
 * @brief Delayed function for transmission of message.
 ****************************************************************************************
 */
__STATIC void m_lay_utrans_tx(void *p_env)
{
    e92e:	b573      	push	{r0, r1, r4, r5, r6, lr}
	M_PRINTF(L_UTARNS, "");
    e930:	681b      	ldr	r3, [r3, #0]
    e932:	05db      	lsls	r3, r3, #23
    e934:	d514      	bpl.n	e960 <m_lay_utrans_tx+0x34>
    e936:	4c23      	ldr	r4, [pc, #140]	; (e9c4 <m_lay_utrans_tx+0x98>)
    e938:	4d23      	ldr	r5, [pc, #140]	; (e9c8 <m_lay_utrans_tx+0x9c>)
    e93a:	0022      	movs	r2, r4
    e93c:	0020      	movs	r0, r4
    e93e:	1c6b      	adds	r3, r5, #1
    e940:	0021      	movs	r1, r4
    e942:	3221      	adds	r2, #33	; 0x21
    e944:	9300      	str	r3, [sp, #0]
    e946:	3030      	adds	r0, #48	; 0x30
    e948:	4b20      	ldr	r3, [pc, #128]	; (e9cc <m_lay_utrans_tx+0xa0>)
    e94a:	f7f6 f82f 	bl	49ac <m_print>
    e94e:	0028      	movs	r0, r5
    e950:	3011      	adds	r0, #17
    e952:	f7f6 f82b 	bl	49ac <m_print>
    e956:	0020      	movs	r0, r4
    e958:	1da1      	adds	r1, r4, #6
    e95a:	3069      	adds	r0, #105	; 0x69
    e95c:	f7f6 f826 	bl	49ac <m_print>
    // Get first buffer in transmission queue
    m_tb_buf_t *p_buf = (m_tb_buf_t *)co_list_pick(&p_m_lay_utrans_env->tx_queue);
    e960:	4c1b      	ldr	r4, [pc, #108]	; (e9d0 <m_lay_utrans_tx+0xa4>)
    e962:	6820      	ldr	r0, [r4, #0]
    e964:	6985      	ldr	r5, [r0, #24]

    if (p_buf)
    e966:	2d00      	cmp	r5, #0
    e968:	d028      	beq.n	e9bc <m_lay_utrans_tx+0x90>
    {
        // Get pointer to environment in the buffer
        m_lay_buf_env_t *p_env = (m_lay_buf_env_t *)&p_buf->env[0];
        // Interface index
        uint8_t intf_idx_utrans = p_env->u15.intf_idx_utrans;
    e96a:	002b      	movs	r3, r5
    e96c:	332d      	adds	r3, #45	; 0x2d
    e96e:	781e      	ldrb	r6, [r3, #0]

        if (intf_idx_utrans == M_LAY_UTRANS_INTF_ACCESS)
    e970:	2e00      	cmp	r6, #0
    e972:	d105      	bne.n	e980 <m_lay_utrans_tx+0x54>
        {
            // Push token for encryption of Access PDU
            m_tb_sec_ccm_enc_start(M_TB_SEC_TOKEN_UTRANS_ENC, m_lay_utrans_ccm_enc_ready_cb,
    e974:	4a17      	ldr	r2, [pc, #92]	; (e9d4 <m_lay_utrans_tx+0xa8>)
    e976:	4918      	ldr	r1, [pc, #96]	; (e9d8 <m_lay_utrans_tx+0xac>)
    e978:	2001      	movs	r0, #1
    e97a:	f005 fb45 	bl	14008 <m_tb_sec_ccm_enc_start>
    e97e:	e01d      	b.n	e9bc <m_lay_utrans_tx+0x90>
        {
            // Status
            uint16_t status;

            // Extract the buffer from the transmission queue
            co_list_pop_front(&p_m_lay_utrans_env->tx_queue);
    e980:	3018      	adds	r0, #24
    e982:	f7f5 fd33 	bl	43ec <co_list_pop_front>

            // Push the buffer for transmission
            status = p_m_lay_utrans_env->p_ltrans_api->send(p_buf);
    e986:	6823      	ldr	r3, [r4, #0]
    e988:	0028      	movs	r0, r5
    e98a:	689b      	ldr	r3, [r3, #8]
    e98c:	681b      	ldr	r3, [r3, #0]
    e98e:	4798      	blx	r3

            if (status == M_ERR_CANNOT_FRAGMENT)
    e990:	4b12      	ldr	r3, [pc, #72]	; (e9dc <m_lay_utrans_tx+0xb0>)

            // Extract the buffer from the transmission queue
            co_list_pop_front(&p_m_lay_utrans_env->tx_queue);

            // Push the buffer for transmission
            status = p_m_lay_utrans_env->p_ltrans_api->send(p_buf);
    e992:	0001      	movs	r1, r0

            if (status == M_ERR_CANNOT_FRAGMENT)
    e994:	4298      	cmp	r0, r3
    e996:	d105      	bne.n	e9a4 <m_lay_utrans_tx+0x78>
            {
                // Insert the buffer in the waiting queue
                co_list_push_back(&p_m_lay_utrans_env->wait_queue, &p_buf->hdr);
    e998:	6820      	ldr	r0, [r4, #0]
    e99a:	0029      	movs	r1, r5
    e99c:	3028      	adds	r0, #40	; 0x28
    e99e:	f7f5 fcfa 	bl	4396 <co_list_push_back>
    e9a2:	e007      	b.n	e9b4 <m_lay_utrans_tx+0x88>

                // Consider there is no error
                status = M_ERR_NO_ERROR;
            }

            if (status != M_ERR_NO_ERROR)
    e9a4:	2800      	cmp	r0, #0
    e9a6:	d005      	beq.n	e9b4 <m_lay_utrans_tx+0x88>
            {
                // Inform the upper layer about the error
                p_m_lay_utrans_env->p_cb[intf_idx_utrans]->sent(p_buf, status);
    e9a8:	6823      	ldr	r3, [r4, #0]
    e9aa:	00b6      	lsls	r6, r6, #2
    e9ac:	58f3      	ldr	r3, [r6, r3]
    e9ae:	0028      	movs	r0, r5
    e9b0:	681b      	ldr	r3, [r3, #0]
    e9b2:	4798      	blx	r3
            }

            // Delay transmission of next PDU
            m_al_djob_reg(&p_m_lay_utrans_env->djob);
    e9b4:	6820      	ldr	r0, [r4, #0]
    e9b6:	300c      	adds	r0, #12
    e9b8:	f7f6 f968 	bl	4c8c <m_al_djob_reg>
        }
    }
}
    e9bc:	bd73      	pop	{r0, r1, r4, r5, r6, pc}
    e9be:	46c0      	nop			; (mov r8, r8)
    e9c0:	10010514 	.word	0x10010514
    e9c4:	00021c28 	.word	0x00021c28
    e9c8:	00021d28 	.word	0x00021d28
    e9cc:	00000396 	.word	0x00000396
    e9d0:	100126b8 	.word	0x100126b8
    e9d4:	0000e425 	.word	0x0000e425
    e9d8:	0000e27d 	.word	0x0000e27d
    e9dc:	00000d82 	.word	0x00000d82

0000e9e0 <m_lay_utrans_init>:
 * GLOBAL FUNCTIONS
 ****************************************************************************************
 */

uint16_t m_lay_utrans_init(bool reset, void *p_env)
{
    e9e0:	b510      	push	{r4, lr}
    e9e2:	4b08      	ldr	r3, [pc, #32]	; (ea04 <m_lay_utrans_init+0x24>)
    e9e4:	000c      	movs	r4, r1
    if (!reset)
    e9e6:	2800      	cmp	r0, #0
    e9e8:	d108      	bne.n	e9fc <m_lay_utrans_init+0x1c>
    {
        // Get environment for Upper Transport Layer
        p_m_lay_utrans_env = (m_lay_utrans_env_t *)p_env;
    e9ea:	6019      	str	r1, [r3, #0]

        // Initialize environment
        memset(p_env, 0, sizeof(m_lay_utrans_env_t));
    e9ec:	2240      	movs	r2, #64	; 0x40
    e9ee:	0001      	movs	r1, r0
    e9f0:	0020      	movs	r0, r4
    e9f2:	f007 f82b 	bl	15a4c <memset>

        // Initialize delayed job
        p_m_lay_utrans_env->djob.cb = m_lay_utrans_tx;
    e9f6:	4b04      	ldr	r3, [pc, #16]	; (ea08 <m_lay_utrans_init+0x28>)
    e9f8:	6163      	str	r3, [r4, #20]
    e9fa:	e001      	b.n	ea00 <m_lay_utrans_init+0x20>
    }
    else
    {
        p_m_lay_utrans_env = NULL;
    e9fc:	2200      	movs	r2, #0
    e9fe:	601a      	str	r2, [r3, #0]
    }

    return (sizeof(m_lay_utrans_env_t));
}
    ea00:	2040      	movs	r0, #64	; 0x40
    ea02:	bd10      	pop	{r4, pc}
    ea04:	100126b8 	.word	0x100126b8
    ea08:	0000e92d 	.word	0x0000e92d

0000ea0c <m_lay_utrans_get_env_size>:

uint16_t m_lay_utrans_get_env_size(const m_cfg_t* p_cfg)
{
    return (sizeof(m_lay_utrans_env_t));
}
    ea0c:	2040      	movs	r0, #64	; 0x40
    ea0e:	4770      	bx	lr

0000ea10 <m_lay_utrans_connect_api_ltrans>:

void m_lay_utrans_connect_api_ltrans(const m_lay_ltrans_api_t *p_api)
{

    p_m_lay_utrans_env->p_ltrans_api = p_api;
    ea10:	4b01      	ldr	r3, [pc, #4]	; (ea18 <m_lay_utrans_connect_api_ltrans+0x8>)
    ea12:	681b      	ldr	r3, [r3, #0]
    ea14:	6098      	str	r0, [r3, #8]
}
    ea16:	4770      	bx	lr
    ea18:	100126b8 	.word	0x100126b8

0000ea1c <m_lay_utrans_connect_cb>:
__STATIC uint8_t m_lay_utrans_intf_type_to_idx(uint8_t intf_type)
{
    // Interface index
    uint8_t intf_idx = M_LAY_UTRANS_INTF_NB;

    switch (intf_type)
    ea1c:	2900      	cmp	r1, #0
    ea1e:	d001      	beq.n	ea24 <m_lay_utrans_connect_cb+0x8>
    ea20:	2901      	cmp	r1, #1
    ea22:	d103      	bne.n	ea2c <m_lay_utrans_connect_cb+0x10>
    // Get interface index
    uint8_t intf_idx = m_lay_utrans_intf_type_to_idx(intf_type);

    if (intf_idx < M_LAY_UTRANS_INTF_NB)
    {
        p_m_lay_utrans_env->p_cb[intf_idx] = p_cb;
    ea24:	4b02      	ldr	r3, [pc, #8]	; (ea30 <m_lay_utrans_connect_cb+0x14>)
    ea26:	0089      	lsls	r1, r1, #2
    ea28:	681b      	ldr	r3, [r3, #0]
    ea2a:	50c8      	str	r0, [r1, r3]
    }
}
    ea2c:	4770      	bx	lr
    ea2e:	46c0      	nop			; (mov r8, r8)
    ea30:	100126b8 	.word	0x100126b8

0000ea34 <co_bswap>:
 * @param[in] len       number of bytes to swap
 ****************************************************************************************
 */
__INLINE_S__ void co_bswap(uint8_t* p_val_out, const uint8_t* p_val_in, uint16_t len)
{
    while (len > 0)
    ea34:	2a00      	cmp	r2, #0
    ea36:	d005      	beq.n	ea44 <co_bswap+0x10>
    {
        len--;
    ea38:	3a01      	subs	r2, #1
    ea3a:	b292      	uxth	r2, r2
        *p_val_out = p_val_in[len];
    ea3c:	5c8b      	ldrb	r3, [r1, r2]
    ea3e:	7003      	strb	r3, [r0, #0]
        p_val_out++;
    ea40:	3001      	adds	r0, #1
    ea42:	e7f7      	b.n	ea34 <co_bswap>
    }
}
    ea44:	4770      	bx	lr

0000ea46 <m_prov_state_send>:
 * @param[in]  status  Status Error code
 ****************************************************************************************
 */
__STATIC void m_prov_state_send(uint8_t state, uint16_t status)
{
	M_PRINTF(L_PROV, "");
    ea46:	4b18      	ldr	r3, [pc, #96]	; (eaa8 <m_prov_state_send+0x62>)
 * @param[in]  state   Provisioning state (@see enum m_prov_state)
 * @param[in]  status  Status Error code
 ****************************************************************************************
 */
__STATIC void m_prov_state_send(uint8_t state, uint16_t status)
{
    ea48:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	M_PRINTF(L_PROV, "");
    ea4a:	681b      	ldr	r3, [r3, #0]
 * @param[in]  state   Provisioning state (@see enum m_prov_state)
 * @param[in]  status  Status Error code
 ****************************************************************************************
 */
__STATIC void m_prov_state_send(uint8_t state, uint16_t status)
{
    ea4c:	0006      	movs	r6, r0
    ea4e:	000f      	movs	r7, r1
	M_PRINTF(L_PROV, "");
    ea50:	071b      	lsls	r3, r3, #28
    ea52:	d516      	bpl.n	ea82 <m_prov_state_send+0x3c>
    ea54:	4c15      	ldr	r4, [pc, #84]	; (eaac <m_prov_state_send+0x66>)
    ea56:	4d16      	ldr	r5, [pc, #88]	; (eab0 <m_prov_state_send+0x6a>)
    ea58:	0023      	movs	r3, r4
    ea5a:	336d      	adds	r3, #109	; 0x6d
    ea5c:	9300      	str	r3, [sp, #0]
    ea5e:	0022      	movs	r2, r4
    ea60:	0020      	movs	r0, r4
    ea62:	23da      	movs	r3, #218	; 0xda
    ea64:	0029      	movs	r1, r5
    ea66:	3255      	adds	r2, #85	; 0x55
    ea68:	005b      	lsls	r3, r3, #1
    ea6a:	305e      	adds	r0, #94	; 0x5e
    ea6c:	f7f5 ff9e 	bl	49ac <m_print>
    ea70:	0028      	movs	r0, r5
    ea72:	3025      	adds	r0, #37	; 0x25
    ea74:	f7f5 ff9a 	bl	49ac <m_print>
    ea78:	0020      	movs	r0, r4
    ea7a:	490e      	ldr	r1, [pc, #56]	; (eab4 <m_prov_state_send+0x6e>)
    ea7c:	307f      	adds	r0, #127	; 0x7f
    ea7e:	f7f5 ff95 	bl	49ac <m_print>
    // Update attention timer, force it to zero
    if(m_tb_state_get_attention_state() != 0)
    ea82:	f005 fcef 	bl	14464 <m_tb_state_get_attention_state>
    ea86:	2800      	cmp	r0, #0
    ea88:	d002      	beq.n	ea90 <m_prov_state_send+0x4a>
    {
        m_tb_state_set_attention_state(0);
    ea8a:	2000      	movs	r0, #0
    ea8c:	f005 fbbc 	bl	14208 <m_tb_state_set_attention_state>
    }

    // inform application that provisioning failed or succeed
    if(p_m_api_cb && p_m_api_cb->cb_prov_state)
    ea90:	4b09      	ldr	r3, [pc, #36]	; (eab8 <m_prov_state_send+0x72>)
    ea92:	681b      	ldr	r3, [r3, #0]
    ea94:	2b00      	cmp	r3, #0
    ea96:	d005      	beq.n	eaa4 <m_prov_state_send+0x5e>
    ea98:	689b      	ldr	r3, [r3, #8]
    ea9a:	2b00      	cmp	r3, #0
    ea9c:	d002      	beq.n	eaa4 <m_prov_state_send+0x5e>
    	p_m_api_cb->cb_prov_state(state, status);
    ea9e:	0039      	movs	r1, r7
    eaa0:	0030      	movs	r0, r6
    eaa2:	4798      	blx	r3
}
    eaa4:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
    eaa6:	46c0      	nop			; (mov r8, r8)
    eaa8:	10010514 	.word	0x10010514
    eaac:	00021dc8 	.word	0x00021dc8
    eab0:	00021d48 	.word	0x00021d48
    eab4:	00021d4e 	.word	0x00021d4e
    eab8:	10012698 	.word	0x10012698

0000eabc <m_prov_pdu_send>:
 *
 * @return Execution status
 ****************************************************************************************
 */
__STATIC uint16_t m_prov_pdu_send(union m_prov_pdu *p_pdu, const uint8_t** pp_data)
{
    eabc:	b5f0      	push	{r4, r5, r6, r7, lr}
    uint16_t status = M_ERR_INVALID_PARAM;

    // check that bearer is opened
    if(p_m_prov_env->bearer_lid == M_INVALID_LID)
    eabe:	4b2a      	ldr	r3, [pc, #168]	; (eb68 <m_prov_pdu_send+0xac>)
 *
 * @return Execution status
 ****************************************************************************************
 */
__STATIC uint16_t m_prov_pdu_send(union m_prov_pdu *p_pdu, const uint8_t** pp_data)
{
    eac0:	b085      	sub	sp, #20
    uint16_t status = M_ERR_INVALID_PARAM;

    // check that bearer is opened
    if(p_m_prov_env->bearer_lid == M_INVALID_LID)
    eac2:	681b      	ldr	r3, [r3, #0]
 *
 * @return Execution status
 ****************************************************************************************
 */
__STATIC uint16_t m_prov_pdu_send(union m_prov_pdu *p_pdu, const uint8_t** pp_data)
{
    eac4:	0005      	movs	r5, r0
    uint16_t status = M_ERR_INVALID_PARAM;

    // check that bearer is opened
    if(p_m_prov_env->bearer_lid == M_INVALID_LID)
    eac6:	7c5b      	ldrb	r3, [r3, #17]
 *
 * @return Execution status
 ****************************************************************************************
 */
__STATIC uint16_t m_prov_pdu_send(union m_prov_pdu *p_pdu, const uint8_t** pp_data)
{
    eac8:	000f      	movs	r7, r1
    uint16_t status = M_ERR_INVALID_PARAM;

    // check that bearer is opened
    if(p_m_prov_env->bearer_lid == M_INVALID_LID)
    eaca:	2bff      	cmp	r3, #255	; 0xff
    eacc:	d044      	beq.n	eb58 <m_prov_pdu_send+0x9c>
    {
        status = M_ERR_COMMAND_DISALLOWED;
    }
    else if(p_pdu != NULL)
    eace:	2800      	cmp	r0, #0
    ead0:	d044      	beq.n	eb5c <m_prov_pdu_send+0xa0>
    {
        m_tb_buf_t* p_buf = NULL;
        uint8_t*    p_data;
        uint16_t    tx_len = m_prov_pdu_handlers[p_pdu->type].length;
    ead2:	210c      	movs	r1, #12
    ead4:	7802      	ldrb	r2, [r0, #0]
    {
        status = M_ERR_COMMAND_DISALLOWED;
    }
    else if(p_pdu != NULL)
    {
        m_tb_buf_t* p_buf = NULL;
    ead6:	2300      	movs	r3, #0
        uint8_t*    p_data;
        uint16_t    tx_len = m_prov_pdu_handlers[p_pdu->type].length;
    ead8:	434a      	muls	r2, r1
    eada:	4924      	ldr	r1, [pc, #144]	; (eb6c <m_prov_pdu_send+0xb0>)
        status = m_tb_buf_alloc(&p_buf, 1, tx_len, 0);
    eadc:	a803      	add	r0, sp, #12
    }
    else if(p_pdu != NULL)
    {
        m_tb_buf_t* p_buf = NULL;
        uint8_t*    p_data;
        uint16_t    tx_len = m_prov_pdu_handlers[p_pdu->type].length;
    eade:	188a      	adds	r2, r1, r2
    eae0:	4669      	mov	r1, sp
    eae2:	8f92      	ldrh	r2, [r2, #60]	; 0x3c
    {
        status = M_ERR_COMMAND_DISALLOWED;
    }
    else if(p_pdu != NULL)
    {
        m_tb_buf_t* p_buf = NULL;
    eae4:	9303      	str	r3, [sp, #12]
        uint8_t*    p_data;
        uint16_t    tx_len = m_prov_pdu_handlers[p_pdu->type].length;
    eae6:	814a      	strh	r2, [r1, #10]
        status = m_tb_buf_alloc(&p_buf, 1, tx_len, 0);
    eae8:	2101      	movs	r1, #1
    eaea:	f002 fd25 	bl	11538 <m_tb_buf_alloc>
    eaee:	1e04      	subs	r4, r0, #0

        if(status == M_ERR_NO_ERROR)
    eaf0:	d136      	bne.n	eb60 <m_prov_pdu_send+0xa4>
        {
            p_data = M_TB_BUF_DATA(p_buf);
    eaf2:	9b03      	ldr	r3, [sp, #12]
            // Perform PDU packing
            status = co_util_pack(p_data, ((uint8_t*) p_pdu)+1, &tx_len, sizeof(union m_prov_pdu),
    eaf4:	220c      	movs	r2, #12
        uint16_t    tx_len = m_prov_pdu_handlers[p_pdu->type].length;
        status = m_tb_buf_alloc(&p_buf, 1, tx_len, 0);

        if(status == M_ERR_NO_ERROR)
        {
            p_data = M_TB_BUF_DATA(p_buf);
    eaf6:	001e      	movs	r6, r3
    eaf8:	889b      	ldrh	r3, [r3, #4]
    eafa:	3630      	adds	r6, #48	; 0x30
    eafc:	18f6      	adds	r6, r6, r3
            // Perform PDU packing
            status = co_util_pack(p_data, ((uint8_t*) p_pdu)+1, &tx_len, sizeof(union m_prov_pdu),
    eafe:	782b      	ldrb	r3, [r5, #0]
    eb00:	1c69      	adds	r1, r5, #1
    eb02:	4353      	muls	r3, r2
    eb04:	4a19      	ldr	r2, [pc, #100]	; (eb6c <m_prov_pdu_send+0xb0>)
    eb06:	0030      	movs	r0, r6
    eb08:	18d3      	adds	r3, r2, r3
    eb0a:	220a      	movs	r2, #10
    eb0c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    eb0e:	446a      	add	r2, sp
    eb10:	9300      	str	r3, [sp, #0]
    eb12:	2342      	movs	r3, #66	; 0x42
    eb14:	f7f5 fd3c 	bl	4590 <co_util_pack>
                                   m_prov_pdu_handlers[p_pdu->type].p_pack_format);

            ASSERT_INFO(status == CO_UTIL_PACK_OK, status, p_pdu->type);
    eb18:	2800      	cmp	r0, #0
    eb1a:	d1fd      	bne.n	eb18 <m_prov_pdu_send+0x5c>
            if(status == CO_UTIL_PACK_OK)
            {
                m_prov_res_t* p_res = p_m_prov_env->p_res;
    eb1c:	4c12      	ldr	r4, [pc, #72]	; (eb68 <m_prov_pdu_send+0xac>)
                m_prov_buf_env_t* p_buf_env = (m_prov_buf_env_t*) p_buf->env;
                p_buf_env->pdu_type = p_pdu->type;
    eb1e:	9a03      	ldr	r2, [sp, #12]
                                   m_prov_pdu_handlers[p_pdu->type].p_pack_format);

            ASSERT_INFO(status == CO_UTIL_PACK_OK, status, p_pdu->type);
            if(status == CO_UTIL_PACK_OK)
            {
                m_prov_res_t* p_res = p_m_prov_env->p_res;
    eb20:	6823      	ldr	r3, [r4, #0]
                m_prov_buf_env_t* p_buf_env = (m_prov_buf_env_t*) p_buf->env;
                p_buf_env->pdu_type = p_pdu->type;

                // Start transaction timer
                m_tb_timer_set(&(p_res->timer_trans_timeout), M_PROV_TRANS_TIMEOUT);
    eb22:	4913      	ldr	r1, [pc, #76]	; (eb70 <m_prov_pdu_send+0xb4>)
                                   m_prov_pdu_handlers[p_pdu->type].p_pack_format);

            ASSERT_INFO(status == CO_UTIL_PACK_OK, status, p_pdu->type);
            if(status == CO_UTIL_PACK_OK)
            {
                m_prov_res_t* p_res = p_m_prov_env->p_res;
    eb24:	6858      	ldr	r0, [r3, #4]
                m_prov_buf_env_t* p_buf_env = (m_prov_buf_env_t*) p_buf->env;
                p_buf_env->pdu_type = p_pdu->type;
    eb26:	782b      	ldrb	r3, [r5, #0]

                // Start transaction timer
                m_tb_timer_set(&(p_res->timer_trans_timeout), M_PROV_TRANS_TIMEOUT);
    eb28:	300c      	adds	r0, #12
            ASSERT_INFO(status == CO_UTIL_PACK_OK, status, p_pdu->type);
            if(status == CO_UTIL_PACK_OK)
            {
                m_prov_res_t* p_res = p_m_prov_env->p_res;
                m_prov_buf_env_t* p_buf_env = (m_prov_buf_env_t*) p_buf->env;
                p_buf_env->pdu_type = p_pdu->type;
    eb2a:	7413      	strb	r3, [r2, #16]

                // Start transaction timer
                m_tb_timer_set(&(p_res->timer_trans_timeout), M_PROV_TRANS_TIMEOUT);
    eb2c:	f006 fbea 	bl	15304 <m_tb_timer_set>

                switch(p_m_prov_env->bearer_type)
    eb30:	6823      	ldr	r3, [r4, #0]
    eb32:	7c1b      	ldrb	r3, [r3, #16]
    eb34:	2b01      	cmp	r3, #1
    eb36:	d105      	bne.n	eb44 <m_prov_pdu_send+0x88>
                {
                    case M_PROV_BEARER_ADV:
                    {
                        // send packet over advertiser bearer
                        status = m_prov_adv_trans_send(p_buf);
    eb38:	9803      	ldr	r0, [sp, #12]
    eb3a:	f001 fee3 	bl	10904 <m_prov_adv_trans_send>
    eb3e:	1e04      	subs	r4, r0, #0
            {
                status = M_ERR_UNSPECIFIED_ERROR;
            }

            // release buffer if an error occurs
            if(status != M_ERR_NO_ERROR)
    eb40:	d006      	beq.n	eb50 <m_prov_pdu_send+0x94>
    eb42:	e001      	b.n	eb48 <m_prov_pdu_send+0x8c>
                    {
                        // send packet over gatt bearer
                        status = m_prov_bearer_gatt_send(p_buf);
                    } break;
                    #endif // (BLE_MESH_GATT_PROV)
                    default: { status = M_ERR_NOT_SUPPORTED; } break;
    eb44:	24a8      	movs	r4, #168	; 0xa8
    eb46:	0124      	lsls	r4, r4, #4
            }

            // release buffer if an error occurs
            if(status != M_ERR_NO_ERROR)
            {
                m_tb_buf_release(p_buf);
    eb48:	9803      	ldr	r0, [sp, #12]
    eb4a:	f002 fda7 	bl	1169c <m_tb_buf_release>
    eb4e:	e007      	b.n	eb60 <m_prov_pdu_send+0xa4>
            }
            // provide the allocated buffer
            else if(pp_data != NULL)
    eb50:	2f00      	cmp	r7, #0
    eb52:	d005      	beq.n	eb60 <m_prov_pdu_send+0xa4>
            {
                *pp_data = p_data;
    eb54:	603e      	str	r6, [r7, #0]
    eb56:	e003      	b.n	eb60 <m_prov_pdu_send+0xa4>
    uint16_t status = M_ERR_INVALID_PARAM;

    // check that bearer is opened
    if(p_m_prov_env->bearer_lid == M_INVALID_LID)
    {
        status = M_ERR_COMMAND_DISALLOWED;
    eb58:	4c06      	ldr	r4, [pc, #24]	; (eb74 <m_prov_pdu_send+0xb8>)
    eb5a:	e001      	b.n	eb60 <m_prov_pdu_send+0xa4>
 * @return Execution status
 ****************************************************************************************
 */
__STATIC uint16_t m_prov_pdu_send(union m_prov_pdu *p_pdu, const uint8_t** pp_data)
{
    uint16_t status = M_ERR_INVALID_PARAM;
    eb5c:	24c1      	movs	r4, #193	; 0xc1
    eb5e:	0064      	lsls	r4, r4, #1
            }
        }
    }

    return status;
}
    eb60:	0020      	movs	r0, r4
    eb62:	b005      	add	sp, #20
    eb64:	bdf0      	pop	{r4, r5, r6, r7, pc}
    eb66:	46c0      	nop			; (mov r8, r8)
    eb68:	100128a4 	.word	0x100128a4
    eb6c:	00021d48 	.word	0x00021d48
    eb70:	00007530 	.word	0x00007530
    eb74:	00000282 	.word	0x00000282

0000eb78 <m_prov_pdu_invite_handler>:
 ****************************************************************************************
 */
__STATIC uint16_t m_prov_pdu_invite_handler(m_prov_invite_t* p_pdu, m_tb_buf_t* p_buf)
{
    uint16_t status = M_ERR_PROV_UNEXPECTED_PDU;
    m_prov_res_t* p_res = p_m_prov_env->p_res;
    eb78:	4b41      	ldr	r3, [pc, #260]	; (ec80 <m_prov_pdu_invite_handler+0x108>)
 *
 * @return Execution status of handler execution
 ****************************************************************************************
 */
__STATIC uint16_t m_prov_pdu_invite_handler(m_prov_invite_t* p_pdu, m_tb_buf_t* p_buf)
{
    eb7a:	b5f0      	push	{r4, r5, r6, r7, lr}
    uint16_t status = M_ERR_PROV_UNEXPECTED_PDU;
    m_prov_res_t* p_res = p_m_prov_env->p_res;
    eb7c:	681b      	ldr	r3, [r3, #0]
 *
 * @return Execution status of handler execution
 ****************************************************************************************
 */
__STATIC uint16_t m_prov_pdu_invite_handler(m_prov_invite_t* p_pdu, m_tb_buf_t* p_buf)
{
    eb7e:	b08b      	sub	sp, #44	; 0x2c
    uint16_t status = M_ERR_PROV_UNEXPECTED_PDU;
    m_prov_res_t* p_res = p_m_prov_env->p_res;
    eb80:	685f      	ldr	r7, [r3, #4]
	M_PRINTF(L_PROV, "state = %d data = 0x%02x", p_res->state, *M_TB_BUF_DATA(p_buf));
    eb82:	4b40      	ldr	r3, [pc, #256]	; (ec84 <m_prov_pdu_invite_handler+0x10c>)
 *
 * @return Execution status of handler execution
 ****************************************************************************************
 */
__STATIC uint16_t m_prov_pdu_invite_handler(m_prov_invite_t* p_pdu, m_tb_buf_t* p_buf)
{
    eb84:	9003      	str	r0, [sp, #12]
    uint16_t status = M_ERR_PROV_UNEXPECTED_PDU;
    m_prov_res_t* p_res = p_m_prov_env->p_res;
	M_PRINTF(L_PROV, "state = %d data = 0x%02x", p_res->state, *M_TB_BUF_DATA(p_buf));
    eb86:	681b      	ldr	r3, [r3, #0]
 *
 * @return Execution status of handler execution
 ****************************************************************************************
 */
__STATIC uint16_t m_prov_pdu_invite_handler(m_prov_invite_t* p_pdu, m_tb_buf_t* p_buf)
{
    eb88:	000d      	movs	r5, r1
    uint16_t status = M_ERR_PROV_UNEXPECTED_PDU;
    m_prov_res_t* p_res = p_m_prov_env->p_res;
	M_PRINTF(L_PROV, "state = %d data = 0x%02x", p_res->state, *M_TB_BUF_DATA(p_buf));
    eb8a:	071b      	lsls	r3, r3, #28
    eb8c:	d51c      	bpl.n	ebc8 <m_prov_pdu_invite_handler+0x50>
    eb8e:	4c3e      	ldr	r4, [pc, #248]	; (ec88 <m_prov_pdu_invite_handler+0x110>)
    eb90:	4e3e      	ldr	r6, [pc, #248]	; (ec8c <m_prov_pdu_invite_handler+0x114>)
    eb92:	0022      	movs	r2, r4
    eb94:	0020      	movs	r0, r4
    eb96:	1cb3      	adds	r3, r6, #2
    eb98:	3255      	adds	r2, #85	; 0x55
    eb9a:	9300      	str	r3, [sp, #0]
    eb9c:	493c      	ldr	r1, [pc, #240]	; (ec90 <m_prov_pdu_invite_handler+0x118>)
    eb9e:	4b3d      	ldr	r3, [pc, #244]	; (ec94 <m_prov_pdu_invite_handler+0x11c>)
    eba0:	305e      	adds	r0, #94	; 0x5e
    eba2:	f7f5 ff03 	bl	49ac <m_print>
    eba6:	88ab      	ldrh	r3, [r5, #4]
    eba8:	0030      	movs	r0, r6
    ebaa:	18eb      	adds	r3, r5, r3
    ebac:	3330      	adds	r3, #48	; 0x30
    ebae:	781a      	ldrb	r2, [r3, #0]
    ebb0:	003b      	movs	r3, r7
    ebb2:	3358      	adds	r3, #88	; 0x58
    ebb4:	7819      	ldrb	r1, [r3, #0]
    ebb6:	301c      	adds	r0, #28
    ebb8:	f7f5 fef8 	bl	49ac <m_print>
    ebbc:	0020      	movs	r0, r4
    ebbe:	4b34      	ldr	r3, [pc, #208]	; (ec90 <m_prov_pdu_invite_handler+0x118>)
    ebc0:	307f      	adds	r0, #127	; 0x7f
    ebc2:	1d99      	adds	r1, r3, #6
    ebc4:	f7f5 fef2 	bl	49ac <m_print>
    // sanity check on the state
    if(p_res->state == M_PROV_DSTATE_WAIT_INVITE)
    ebc8:	003e      	movs	r6, r7
    ebca:	3658      	adds	r6, #88	; 0x58
    ebcc:	7833      	ldrb	r3, [r6, #0]
    ebce:	2b02      	cmp	r3, #2
    ebd0:	d152      	bne.n	ec78 <m_prov_pdu_invite_handler+0x100>
    {
        m_prov_capabilities_t pdu;
        const uint8_t* p_tx_data = NULL;
    ebd2:	2300      	movs	r3, #0
        m_prov_param_t *p_param = &p_res->prov_param;

        // copy attention timer in confirmation inputs (Reverse bytes)
        co_bswap(&(p_res->comp_data[M_PROV_CFM_INPUTS_INVITE_OFFSET]), M_TB_BUF_DATA(p_buf), M_PROV_PDU_INVITE_LEN);
    ebd4:	0029      	movs	r1, r5
    ebd6:	0038      	movs	r0, r7
	M_PRINTF(L_PROV, "state = %d data = 0x%02x", p_res->state, *M_TB_BUF_DATA(p_buf));
    // sanity check on the state
    if(p_res->state == M_PROV_DSTATE_WAIT_INVITE)
    {
        m_prov_capabilities_t pdu;
        const uint8_t* p_tx_data = NULL;
    ebd8:	9305      	str	r3, [sp, #20]
        m_prov_param_t *p_param = &p_res->prov_param;

        // copy attention timer in confirmation inputs (Reverse bytes)
        co_bswap(&(p_res->comp_data[M_PROV_CFM_INPUTS_INVITE_OFFSET]), M_TB_BUF_DATA(p_buf), M_PROV_PDU_INVITE_LEN);
    ebda:	88ab      	ldrh	r3, [r5, #4]
    ebdc:	3130      	adds	r1, #48	; 0x30
    ebde:	18c9      	adds	r1, r1, r3
    ebe0:	30ea      	adds	r0, #234	; 0xea
    ebe2:	2201      	movs	r2, #1
    ebe4:	f7ff ff26 	bl	ea34 <co_bswap>

        // Update the attention timer state if not zero
        if(p_pdu->attention_dur > 0)
    ebe8:	9b03      	ldr	r3, [sp, #12]
    ebea:	7858      	ldrb	r0, [r3, #1]
    ebec:	2800      	cmp	r0, #0
    ebee:	d001      	beq.n	ebf4 <m_prov_pdu_invite_handler+0x7c>
        {
            m_tb_state_set_attention_state(p_pdu->attention_dur);
    ebf0:	f005 fb0a 	bl	14208 <m_tb_state_set_attention_state>
        }

        // Send device capabilities
        pdu.type            = M_PROV_PDU_CAPABILITIES;
    ebf4:	2201      	movs	r2, #1
        pdu.nb_elt          = p_param->nb_elt;
    ebf6:	003b      	movs	r3, r7
        {
            m_tb_state_set_attention_state(p_pdu->attention_dur);
        }

        // Send device capabilities
        pdu.type            = M_PROV_PDU_CAPABILITIES;
    ebf8:	ac06      	add	r4, sp, #24
    ebfa:	7022      	strb	r2, [r4, #0]
        pdu.nb_elt          = p_param->nb_elt;
    ebfc:	3334      	adds	r3, #52	; 0x34
    ebfe:	7f99      	ldrb	r1, [r3, #30]
        pdu.algorithms      = M_PROV_ALGO_FIPS_P256_ELLIPTIC_CURVE;
    ec00:	8062      	strh	r2, [r4, #2]
            m_tb_state_set_attention_state(p_pdu->attention_dur);
        }

        // Send device capabilities
        pdu.type            = M_PROV_PDU_CAPABILITIES;
        pdu.nb_elt          = p_param->nb_elt;
    ec02:	7061      	strb	r1, [r4, #1]
        pdu.algorithms      = M_PROV_ALGO_FIPS_P256_ELLIPTIC_CURVE;
        pdu.pub_key_type    = p_param->pub_key_oob;
    ec04:	7d9a      	ldrb	r2, [r3, #22]
    ec06:	7122      	strb	r2, [r4, #4]
        pdu.static_oob_type = p_param->static_oob;
    ec08:	7dda      	ldrb	r2, [r3, #23]
    ec0a:	7162      	strb	r2, [r4, #5]
        pdu.out_oob_size    = p_param->out_oob_size;
    ec0c:	7e1a      	ldrb	r2, [r3, #24]
    ec0e:	71a2      	strb	r2, [r4, #6]
        pdu.out_oob_action  = p_param->out_oob_action;
    ec10:	003a      	movs	r2, r7
    ec12:	324e      	adds	r2, #78	; 0x4e
    ec14:	8812      	ldrh	r2, [r2, #0]
    ec16:	8122      	strh	r2, [r4, #8]
        pdu.in_oob_size     = p_param->in_oob_size;
    ec18:	7e5b      	ldrb	r3, [r3, #25]
    ec1a:	72a3      	strb	r3, [r4, #10]
        pdu.in_oob_action   = p_param->in_oob_action;
    ec1c:	003b      	movs	r3, r7
    ec1e:	3350      	adds	r3, #80	; 0x50
    ec20:	881b      	ldrh	r3, [r3, #0]
    ec22:	81a3      	strh	r3, [r4, #12]

        p_res->state = M_PROV_DSTATE_WAIT_START;
    ec24:	2303      	movs	r3, #3
    ec26:	7033      	strb	r3, [r6, #0]
		M_PRINTF(L_PROV, "send device capabilities");
    ec28:	4b16      	ldr	r3, [pc, #88]	; (ec84 <m_prov_pdu_invite_handler+0x10c>)
    ec2a:	681b      	ldr	r3, [r3, #0]
    ec2c:	071b      	lsls	r3, r3, #28
    ec2e:	d516      	bpl.n	ec5e <m_prov_pdu_invite_handler+0xe6>
    ec30:	4b16      	ldr	r3, [pc, #88]	; (ec8c <m_prov_pdu_invite_handler+0x114>)
    ec32:	4d15      	ldr	r5, [pc, #84]	; (ec88 <m_prov_pdu_invite_handler+0x110>)
    ec34:	3302      	adds	r3, #2
    ec36:	9300      	str	r3, [sp, #0]
    ec38:	002a      	movs	r2, r5
    ec3a:	0028      	movs	r0, r5
    ec3c:	239c      	movs	r3, #156	; 0x9c
    ec3e:	4e14      	ldr	r6, [pc, #80]	; (ec90 <m_prov_pdu_invite_handler+0x118>)
    ec40:	3255      	adds	r2, #85	; 0x55
    ec42:	0031      	movs	r1, r6
    ec44:	009b      	lsls	r3, r3, #2
    ec46:	305e      	adds	r0, #94	; 0x5e
    ec48:	f7f5 feb0 	bl	49ac <m_print>
    ec4c:	480f      	ldr	r0, [pc, #60]	; (ec8c <m_prov_pdu_invite_handler+0x114>)
    ec4e:	3035      	adds	r0, #53	; 0x35
    ec50:	f7f5 feac 	bl	49ac <m_print>
    ec54:	0028      	movs	r0, r5
    ec56:	1db1      	adds	r1, r6, #6
    ec58:	307f      	adds	r0, #127	; 0x7f
    ec5a:	f7f5 fea7 	bl	49ac <m_print>
        status = m_prov_pdu_send((union m_prov_pdu*) &pdu, &p_tx_data);
    ec5e:	0020      	movs	r0, r4
    ec60:	a905      	add	r1, sp, #20
    ec62:	f7ff ff2b 	bl	eabc <m_prov_pdu_send>
    ec66:	1e04      	subs	r4, r0, #0

        if(status == M_ERR_NO_ERROR){
    ec68:	d107      	bne.n	ec7a <m_prov_pdu_invite_handler+0x102>
            // copy capabilities PDU in confirmation inputs (Reverse bytes)
            co_bswap(&(p_res->comp_data[M_PROV_CFM_INPUTS_CAPABILITIES_OFFSET]), p_tx_data, M_PROV_PDU_CAPABILITIES_LEN);
    ec6a:	0038      	movs	r0, r7
    ec6c:	220b      	movs	r2, #11
    ec6e:	30df      	adds	r0, #223	; 0xdf
    ec70:	9905      	ldr	r1, [sp, #20]
    ec72:	f7ff fedf 	bl	ea34 <co_bswap>
    ec76:	e000      	b.n	ec7a <m_prov_pdu_invite_handler+0x102>
 * @return Execution status of handler execution
 ****************************************************************************************
 */
__STATIC uint16_t m_prov_pdu_invite_handler(m_prov_invite_t* p_pdu, m_tb_buf_t* p_buf)
{
    uint16_t status = M_ERR_PROV_UNEXPECTED_PDU;
    ec78:	4c07      	ldr	r4, [pc, #28]	; (ec98 <m_prov_pdu_invite_handler+0x120>)
            co_bswap(&(p_res->comp_data[M_PROV_CFM_INPUTS_CAPABILITIES_OFFSET]), p_tx_data, M_PROV_PDU_CAPABILITIES_LEN);
		}
    }

    return (status);
}
    ec7a:	0020      	movs	r0, r4
    ec7c:	b00b      	add	sp, #44	; 0x2c
    ec7e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    ec80:	100128a4 	.word	0x100128a4
    ec84:	10010514 	.word	0x10010514
    ec88:	00021dc8 	.word	0x00021dc8
    ec8c:	00021e48 	.word	0x00021e48
    ec90:	00021d48 	.word	0x00021d48
    ec94:	00000253 	.word	0x00000253
    ec98:	00000381 	.word	0x00000381

0000ec9c <m_prov_pdu_capabilities_handler>:
 * @return Execution status of handler execution
 ****************************************************************************************
 */
__STATIC uint16_t m_prov_pdu_capabilities_handler(m_prov_capabilities_t* p_pdu, m_tb_buf_t* p_buf)
{
	M_PRINTF(L_PROV, "");
    ec9c:	4b0f      	ldr	r3, [pc, #60]	; (ecdc <m_prov_pdu_capabilities_handler+0x40>)
 *
 * @return Execution status of handler execution
 ****************************************************************************************
 */
__STATIC uint16_t m_prov_pdu_capabilities_handler(m_prov_capabilities_t* p_pdu, m_tb_buf_t* p_buf)
{
    ec9e:	b573      	push	{r0, r1, r4, r5, r6, lr}
	M_PRINTF(L_PROV, "");
    eca0:	681b      	ldr	r3, [r3, #0]
    eca2:	071b      	lsls	r3, r3, #28
    eca4:	d517      	bpl.n	ecd6 <m_prov_pdu_capabilities_handler+0x3a>
    eca6:	4b0e      	ldr	r3, [pc, #56]	; (ece0 <m_prov_pdu_capabilities_handler+0x44>)
    eca8:	4c0e      	ldr	r4, [pc, #56]	; (ece4 <m_prov_pdu_capabilities_handler+0x48>)
    ecaa:	334e      	adds	r3, #78	; 0x4e
    ecac:	9300      	str	r3, [sp, #0]
    ecae:	0022      	movs	r2, r4
    ecb0:	0020      	movs	r0, r4
    ecb2:	23a2      	movs	r3, #162	; 0xa2
    ecb4:	4d0c      	ldr	r5, [pc, #48]	; (ece8 <m_prov_pdu_capabilities_handler+0x4c>)
    ecb6:	3255      	adds	r2, #85	; 0x55
    ecb8:	0029      	movs	r1, r5
    ecba:	009b      	lsls	r3, r3, #2
    ecbc:	305e      	adds	r0, #94	; 0x5e
    ecbe:	f7f5 fe75 	bl	49ac <m_print>
    ecc2:	0028      	movs	r0, r5
    ecc4:	3025      	adds	r0, #37	; 0x25
    ecc6:	f7f5 fe71 	bl	49ac <m_print>
    ecca:	0020      	movs	r0, r4
    eccc:	1dae      	adds	r6, r5, #6
    ecce:	307f      	adds	r0, #127	; 0x7f
    ecd0:	0031      	movs	r1, r6
    ecd2:	f7f5 fe6b 	bl	49ac <m_print>
    uint16_t status = M_ERR_PROV_UNEXPECTED_PDU;

    return (status);
}
    ecd6:	4805      	ldr	r0, [pc, #20]	; (ecec <m_prov_pdu_capabilities_handler+0x50>)
    ecd8:	bd76      	pop	{r1, r2, r4, r5, r6, pc}
    ecda:	46c0      	nop			; (mov r8, r8)
    ecdc:	10010514 	.word	0x10010514
    ece0:	00021e48 	.word	0x00021e48
    ece4:	00021dc8 	.word	0x00021dc8
    ece8:	00021d48 	.word	0x00021d48
    ecec:	00000381 	.word	0x00000381

0000ecf0 <m_prov_pdu_start_handler>:
 * @return Execution status of handler execution
 ****************************************************************************************
 */
__STATIC uint16_t m_prov_pdu_start_handler(m_prov_start_t* p_pdu, m_tb_buf_t* p_buf)
{
	M_PRINTF(L_PROV, "");
    ecf0:	4b40      	ldr	r3, [pc, #256]	; (edf4 <m_prov_pdu_start_handler+0x104>)
 *
 * @return Execution status of handler execution
 ****************************************************************************************
 */
__STATIC uint16_t m_prov_pdu_start_handler(m_prov_start_t* p_pdu, m_tb_buf_t* p_buf)
{
    ecf2:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	M_PRINTF(L_PROV, "");
    ecf4:	681b      	ldr	r3, [r3, #0]
 *
 * @return Execution status of handler execution
 ****************************************************************************************
 */
__STATIC uint16_t m_prov_pdu_start_handler(m_prov_start_t* p_pdu, m_tb_buf_t* p_buf)
{
    ecf6:	0004      	movs	r4, r0
    ecf8:	000f      	movs	r7, r1
	M_PRINTF(L_PROV, "");
    ecfa:	071b      	lsls	r3, r3, #28
    ecfc:	d515      	bpl.n	ed2a <m_prov_pdu_start_handler+0x3a>
    ecfe:	4d3e      	ldr	r5, [pc, #248]	; (edf8 <m_prov_pdu_start_handler+0x108>)
    ed00:	4b3e      	ldr	r3, [pc, #248]	; (edfc <m_prov_pdu_start_handler+0x10c>)
    ed02:	002a      	movs	r2, r5
    ed04:	0028      	movs	r0, r5
    ed06:	4e3e      	ldr	r6, [pc, #248]	; (ee00 <m_prov_pdu_start_handler+0x110>)
    ed08:	336e      	adds	r3, #110	; 0x6e
    ed0a:	0031      	movs	r1, r6
    ed0c:	3255      	adds	r2, #85	; 0x55
    ed0e:	9300      	str	r3, [sp, #0]
    ed10:	305e      	adds	r0, #94	; 0x5e
    ed12:	4b3c      	ldr	r3, [pc, #240]	; (ee04 <m_prov_pdu_start_handler+0x114>)
    ed14:	f7f5 fe4a 	bl	49ac <m_print>
    ed18:	0030      	movs	r0, r6
    ed1a:	3025      	adds	r0, #37	; 0x25
    ed1c:	f7f5 fe46 	bl	49ac <m_print>
    ed20:	0028      	movs	r0, r5
    ed22:	4939      	ldr	r1, [pc, #228]	; (ee08 <m_prov_pdu_start_handler+0x118>)
    ed24:	307f      	adds	r0, #127	; 0x7f
    ed26:	f7f5 fe41 	bl	49ac <m_print>
    uint16_t status = M_ERR_PROV_UNEXPECTED_PDU;
    m_prov_res_t* p_res = p_m_prov_env->p_res;
    ed2a:	4b38      	ldr	r3, [pc, #224]	; (ee0c <m_prov_pdu_start_handler+0x11c>)
    ed2c:	681b      	ldr	r3, [r3, #0]
    ed2e:	685d      	ldr	r5, [r3, #4]
    do
    {
        m_prov_param_t *p_param = &p_res->prov_param;

        // sanity check on the state
        if(p_res->state != M_PROV_DSTATE_WAIT_START) { break; }
    ed30:	002e      	movs	r6, r5
    ed32:	3658      	adds	r6, #88	; 0x58
    ed34:	7833      	ldrb	r3, [r6, #0]
    ed36:	2b03      	cmp	r3, #3
    ed38:	d134      	bne.n	eda4 <m_prov_pdu_start_handler+0xb4>


        status = M_ERR_PROV_INVALID_FORMAT;

        // Sanity check on Public Key Used
        if(p_pdu->pub_key >= M_PROV_PUB_KEY_OOB_MAX) { break; }
    ed3a:	78a3      	ldrb	r3, [r4, #2]
    ed3c:	2b01      	cmp	r3, #1
    ed3e:	d833      	bhi.n	eda8 <m_prov_pdu_start_handler+0xb8>

        // Sanity check on selected algorithm
        if(CO_BIT(p_pdu->algorithm) != M_PROV_ALGO_FIPS_P256_ELLIPTIC_CURVE) { break; }
    ed40:	2201      	movs	r2, #1
    ed42:	7861      	ldrb	r1, [r4, #1]
    ed44:	408a      	lsls	r2, r1
    ed46:	2a01      	cmp	r2, #1
    ed48:	d12e      	bne.n	eda8 <m_prov_pdu_start_handler+0xb8>

        // check that public key usage is supported
        if(   (p_pdu->pub_key == M_PROV_PUB_KEY_OOB_USED)
    ed4a:	2b01      	cmp	r3, #1
    ed4c:	d104      	bne.n	ed58 <m_prov_pdu_start_handler+0x68>
           && (!(p_param->pub_key_oob & M_PROV_PUB_KEY_OOB_AVAILABLE)))
    ed4e:	002a      	movs	r2, r5
    ed50:	3234      	adds	r2, #52	; 0x34
    ed52:	7d92      	ldrb	r2, [r2, #22]
    ed54:	421a      	tst	r2, r3
    ed56:	d027      	beq.n	eda8 <m_prov_pdu_start_handler+0xb8>
        {
            break;
        }

        // check authentication method
        switch(p_pdu->auth_method)
    ed58:	78e0      	ldrb	r0, [r4, #3]
    ed5a:	2803      	cmp	r0, #3
    ed5c:	d824      	bhi.n	eda8 <m_prov_pdu_start_handler+0xb8>
    ed5e:	f00e fff9 	bl	1dd54 <__gnu_thumb1_case_uqi>
    ed62:	0225      	.short	0x0225
    ed64:	1305      	.short	0x1305
                status = M_ERR_NO_ERROR;
            }break;
            case M_PROV_AUTH_STATIC_OOB:
            {
                // Force auth size to 16
                p_pdu->auth_size = M_PROV_STATIC_OOB_SIZE;
    ed66:	2310      	movs	r3, #16
    ed68:	7163      	strb	r3, [r4, #5]
                status = M_ERR_NO_ERROR;
            }break;
    ed6a:	e01f      	b.n	edac <m_prov_pdu_start_handler+0xbc>
            case M_PROV_AUTH_OUTPUT_OOB:
            {
                // verify authentication properties
                if(   ((CO_BIT(p_pdu->auth_action) & p_param->out_oob_action) != 0)
    ed6c:	002b      	movs	r3, r5
    ed6e:	334e      	adds	r3, #78	; 0x4e
    ed70:	881b      	ldrh	r3, [r3, #0]
    ed72:	7922      	ldrb	r2, [r4, #4]
    ed74:	40d3      	lsrs	r3, r2
    ed76:	07db      	lsls	r3, r3, #31
    ed78:	d516      	bpl.n	eda8 <m_prov_pdu_start_handler+0xb8>
                   && (p_pdu->auth_size <= p_param->out_oob_size))
    ed7a:	002b      	movs	r3, r5
    ed7c:	3334      	adds	r3, #52	; 0x34
    ed7e:	7962      	ldrb	r2, [r4, #5]
    ed80:	7e1b      	ldrb	r3, [r3, #24]
    ed82:	429a      	cmp	r2, r3
    ed84:	d912      	bls.n	edac <m_prov_pdu_start_handler+0xbc>
    ed86:	e00f      	b.n	eda8 <m_prov_pdu_start_handler+0xb8>
                }
            }break;
            case M_PROV_AUTH_INPUT_OOB:
            {
                // verify authentication properties
                if(   ((CO_BIT(p_pdu->auth_action) & p_param->in_oob_action) != 0)
    ed88:	002b      	movs	r3, r5
    ed8a:	3350      	adds	r3, #80	; 0x50
    ed8c:	881b      	ldrh	r3, [r3, #0]
    ed8e:	7922      	ldrb	r2, [r4, #4]
    ed90:	40d3      	lsrs	r3, r2
    ed92:	07db      	lsls	r3, r3, #31
    ed94:	d508      	bpl.n	eda8 <m_prov_pdu_start_handler+0xb8>
                   && (p_pdu->auth_size <= p_param->in_oob_size))
    ed96:	002b      	movs	r3, r5
    ed98:	3334      	adds	r3, #52	; 0x34
    ed9a:	7962      	ldrb	r2, [r4, #5]
    ed9c:	7e5b      	ldrb	r3, [r3, #25]
    ed9e:	429a      	cmp	r2, r3
    eda0:	d904      	bls.n	edac <m_prov_pdu_start_handler+0xbc>
    eda2:	e001      	b.n	eda8 <m_prov_pdu_start_handler+0xb8>
 ****************************************************************************************
 */
__STATIC uint16_t m_prov_pdu_start_handler(m_prov_start_t* p_pdu, m_tb_buf_t* p_buf)
{
	M_PRINTF(L_PROV, "");
    uint16_t status = M_ERR_PROV_UNEXPECTED_PDU;
    eda4:	481a      	ldr	r0, [pc, #104]	; (ee10 <m_prov_pdu_start_handler+0x120>)
    eda6:	e024      	b.n	edf2 <m_prov_pdu_start_handler+0x102>

        // sanity check on the state
        if(p_res->state != M_PROV_DSTATE_WAIT_START) { break; }


        status = M_ERR_PROV_INVALID_FORMAT;
    eda8:	481a      	ldr	r0, [pc, #104]	; (ee14 <m_prov_pdu_start_handler+0x124>)
            p_res->auth_size   = p_pdu->auth_size;
            p_res->state       = M_PROV_DSTATE_WAIT_PUB_KEY;
        }
    } while (0);

    return (status);
    edaa:	e022      	b.n	edf2 <m_prov_pdu_start_handler+0x102>
        }

        if(status == M_ERR_NO_ERROR)
        {
            // copy start PDU in confirmation inputs - (Reverse Bytes)
            co_bswap(&(p_res->comp_data[M_PROV_CFM_INPUTS_START_OFFSET]), M_TB_BUF_DATA(p_buf), M_PROV_PDU_START_LEN);
    edac:	0039      	movs	r1, r7
    edae:	0028      	movs	r0, r5
    edb0:	88bb      	ldrh	r3, [r7, #4]
    edb2:	3130      	adds	r1, #48	; 0x30
    edb4:	2205      	movs	r2, #5
    edb6:	18c9      	adds	r1, r1, r3
    edb8:	30da      	adds	r0, #218	; 0xda
    edba:	f7ff fe3b 	bl	ea34 <co_bswap>

            // Copy provisioning information
            p_res->oob_pub_key = (p_pdu->pub_key == M_PROV_PUB_KEY_OOB_USED);
    edbe:	78a3      	ldrb	r3, [r4, #2]
    edc0:	3b01      	subs	r3, #1
    edc2:	425a      	negs	r2, r3
    edc4:	4153      	adcs	r3, r2
    edc6:	002a      	movs	r2, r5
    edc8:	3254      	adds	r2, #84	; 0x54
    edca:	7013      	strb	r3, [r2, #0]
            p_res->auth_method = p_pdu->auth_method;
    edcc:	78e3      	ldrb	r3, [r4, #3]
    edce:	7053      	strb	r3, [r2, #1]

            if((p_res->auth_method == M_PROV_AUTH_OUTPUT_OOB) || (p_res->auth_method == M_PROV_AUTH_INPUT_OOB))
    edd0:	3b02      	subs	r3, #2
    edd2:	3202      	adds	r2, #2
    edd4:	2b01      	cmp	r3, #1
    edd6:	d804      	bhi.n	ede2 <m_prov_pdu_start_handler+0xf2>
            {
                p_res->auth_action = (1 << p_pdu->auth_action);
    edd8:	2301      	movs	r3, #1
    edda:	7921      	ldrb	r1, [r4, #4]
    eddc:	408b      	lsls	r3, r1
    edde:	7013      	strb	r3, [r2, #0]
    ede0:	e001      	b.n	ede6 <m_prov_pdu_start_handler+0xf6>
            }
            else
            {
                p_res->auth_action = 0;
    ede2:	2300      	movs	r3, #0
    ede4:	7013      	strb	r3, [r2, #0]
            }

            p_res->auth_size   = p_pdu->auth_size;
    ede6:	7963      	ldrb	r3, [r4, #5]
    ede8:	3557      	adds	r5, #87	; 0x57
    edea:	702b      	strb	r3, [r5, #0]
            p_res->state       = M_PROV_DSTATE_WAIT_PUB_KEY;
    edec:	2304      	movs	r3, #4
    edee:	2000      	movs	r0, #0
    edf0:	7033      	strb	r3, [r6, #0]
        }
    } while (0);

    return (status);
}
    edf2:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
    edf4:	10010514 	.word	0x10010514
    edf8:	00021dc8 	.word	0x00021dc8
    edfc:	00021e48 	.word	0x00021e48
    ee00:	00021d48 	.word	0x00021d48
    ee04:	0000029a 	.word	0x0000029a
    ee08:	00021d4e 	.word	0x00021d4e
    ee0c:	100128a4 	.word	0x100128a4
    ee10:	00000381 	.word	0x00000381
    ee14:	00000281 	.word	0x00000281

0000ee18 <m_prov_pdu_pub_key_handler>:
 ****************************************************************************************
 */
__STATIC uint16_t m_prov_pdu_pub_key_handler(m_prov_pub_key_t* p_pdu, m_tb_buf_t* p_buf)
{
    uint16_t status = M_ERR_PROV_UNEXPECTED_PDU;
    m_prov_res_t* p_res = p_m_prov_env->p_res;
    ee18:	4b54      	ldr	r3, [pc, #336]	; (ef6c <m_prov_pdu_pub_key_handler+0x154>)
 *
 * @return Execution status of handler execution
 ****************************************************************************************
 */
__STATIC uint16_t m_prov_pdu_pub_key_handler(m_prov_pub_key_t* p_pdu, m_tb_buf_t* p_buf)
{
    ee1a:	b5f0      	push	{r4, r5, r6, r7, lr}
    uint16_t status = M_ERR_PROV_UNEXPECTED_PDU;
    m_prov_res_t* p_res = p_m_prov_env->p_res;
    ee1c:	681b      	ldr	r3, [r3, #0]
 *
 * @return Execution status of handler execution
 ****************************************************************************************
 */
__STATIC uint16_t m_prov_pdu_pub_key_handler(m_prov_pub_key_t* p_pdu, m_tb_buf_t* p_buf)
{
    ee1e:	b097      	sub	sp, #92	; 0x5c
    uint16_t status = M_ERR_PROV_UNEXPECTED_PDU;
    m_prov_res_t* p_res = p_m_prov_env->p_res;
    ee20:	685c      	ldr	r4, [r3, #4]

	M_PRINTF(L_PROV, "state = %d", p_res->state);
    ee22:	4b53      	ldr	r3, [pc, #332]	; (ef70 <m_prov_pdu_pub_key_handler+0x158>)
 *
 * @return Execution status of handler execution
 ****************************************************************************************
 */
__STATIC uint16_t m_prov_pdu_pub_key_handler(m_prov_pub_key_t* p_pdu, m_tb_buf_t* p_buf)
{
    ee24:	0006      	movs	r6, r0
    uint16_t status = M_ERR_PROV_UNEXPECTED_PDU;
    m_prov_res_t* p_res = p_m_prov_env->p_res;

	M_PRINTF(L_PROV, "state = %d", p_res->state);
    ee26:	681b      	ldr	r3, [r3, #0]
    ee28:	071b      	lsls	r3, r3, #28
    ee2a:	d518      	bpl.n	ee5e <m_prov_pdu_pub_key_handler+0x46>
    ee2c:	4d51      	ldr	r5, [pc, #324]	; (ef74 <m_prov_pdu_pub_key_handler+0x15c>)
    ee2e:	4f52      	ldr	r7, [pc, #328]	; (ef78 <m_prov_pdu_pub_key_handler+0x160>)
    ee30:	002a      	movs	r2, r5
    ee32:	0028      	movs	r0, r5
    ee34:	1dfb      	adds	r3, r7, #7
    ee36:	3255      	adds	r2, #85	; 0x55
    ee38:	9300      	str	r3, [sp, #0]
    ee3a:	4950      	ldr	r1, [pc, #320]	; (ef7c <m_prov_pdu_pub_key_handler+0x164>)
    ee3c:	4b50      	ldr	r3, [pc, #320]	; (ef80 <m_prov_pdu_pub_key_handler+0x168>)
    ee3e:	305e      	adds	r0, #94	; 0x5e
    ee40:	f7f5 fdb4 	bl	49ac <m_print>
    ee44:	0023      	movs	r3, r4
    ee46:	0038      	movs	r0, r7
    ee48:	3358      	adds	r3, #88	; 0x58
    ee4a:	7819      	ldrb	r1, [r3, #0]
    ee4c:	3022      	adds	r0, #34	; 0x22
    ee4e:	f7f5 fdad 	bl	49ac <m_print>
    ee52:	0028      	movs	r0, r5
    ee54:	4b49      	ldr	r3, [pc, #292]	; (ef7c <m_prov_pdu_pub_key_handler+0x164>)
    ee56:	307f      	adds	r0, #127	; 0x7f
    ee58:	1d99      	adds	r1, r3, #6
    ee5a:	f7f5 fda7 	bl	49ac <m_print>
	m_printf_hex(L_PROV, "recv prov pub key x", p_pdu->pub_key_x, M_PUB_KEY_X_LEN);
    ee5e:	4d46      	ldr	r5, [pc, #280]	; (ef78 <m_prov_pdu_pub_key_handler+0x160>)
    ee60:	1c77      	adds	r7, r6, #1
    ee62:	0029      	movs	r1, r5
    ee64:	2320      	movs	r3, #32
    ee66:	312d      	adds	r1, #45	; 0x2d
    ee68:	003a      	movs	r2, r7
    ee6a:	2008      	movs	r0, #8
    ee6c:	f7f5 fdfe 	bl	4a6c <m_printf_hex>
	m_printf_hex(L_PROV, "recv prov pub key y", p_pdu->pub_key_y, M_PUB_KEY_X_LEN);
    ee70:	0029      	movs	r1, r5
    ee72:	3621      	adds	r6, #33	; 0x21
    ee74:	2320      	movs	r3, #32
    ee76:	3141      	adds	r1, #65	; 0x41
    ee78:	0032      	movs	r2, r6
    ee7a:	2008      	movs	r0, #8
    ee7c:	f7f5 fdf6 	bl	4a6c <m_printf_hex>

    if(p_res->state == M_PROV_DSTATE_WAIT_PUB_KEY)
    ee80:	0023      	movs	r3, r4
    ee82:	3358      	adds	r3, #88	; 0x58
    ee84:	9303      	str	r3, [sp, #12]
    ee86:	781b      	ldrb	r3, [r3, #0]
    ee88:	2b04      	cmp	r3, #4
    ee8a:	d16c      	bne.n	ef66 <m_prov_pdu_pub_key_handler+0x14e>
    {
        // copy provisioner public key in confirmation inputs
        memcpy(&(p_res->comp_data[M_PROV_CFM_INPUTS_PROV_PUB_KEY_X_OFFSET]), p_pdu->pub_key_x, M_PUB_KEY_X_LEN);
    ee8c:	0020      	movs	r0, r4
    ee8e:	0039      	movs	r1, r7
    ee90:	2220      	movs	r2, #32
    ee92:	30ba      	adds	r0, #186	; 0xba
    ee94:	f006 fd9c 	bl	159d0 <memcpy>
        memcpy(&(p_res->comp_data[M_PROV_CFM_INPUTS_PROV_PUB_KEY_Y_OFFSET]), p_pdu->pub_key_y, M_PUB_KEY_Y_LEN);
    ee98:	0020      	movs	r0, r4
    ee9a:	2220      	movs	r2, #32
    ee9c:	0031      	movs	r1, r6
    ee9e:	309a      	adds	r0, #154	; 0x9a
    eea0:	f006 fd96 	bl	159d0 <memcpy>

        status = M_ERR_NO_ERROR;

        // Wait for peer confirmation (exept for input where we first wait for user input)
        p_res->state = (p_res->auth_method == M_PROV_AUTH_INPUT_OOB)
    eea4:	0023      	movs	r3, r4
    eea6:	3355      	adds	r3, #85	; 0x55
    eea8:	781b      	ldrb	r3, [r3, #0]
    eeaa:	3b03      	subs	r3, #3
    eeac:	425a      	negs	r2, r3
    eeae:	4153      	adcs	r3, r2
    eeb0:	2206      	movs	r2, #6
    eeb2:	1ad3      	subs	r3, r2, r3
    eeb4:	9a03      	ldr	r2, [sp, #12]
    eeb6:	7013      	strb	r3, [r2, #0]
                     ? M_PROV_DSTATE_WAIT_AUTH_INPUT : M_PROV_DSTATE_WAIT_CFM;

        // check if public key should be sent
        if(!p_res->oob_pub_key){
    eeb8:	0023      	movs	r3, r4
    eeba:	3354      	adds	r3, #84	; 0x54
    eebc:	781f      	ldrb	r7, [r3, #0]
    eebe:	2f00      	cmp	r7, #0
    eec0:	d01a      	beq.n	eef8 <m_prov_pdu_pub_key_handler+0xe0>
			m_printf_hex(L_PROV, "send dev pub key y", pdu.pub_key_y, M_PUB_KEY_X_LEN);
            status = m_prov_pdu_send((union m_prov_pdu*) &pdu, NULL);
			
        }
        if(status == M_ERR_NO_ERROR){
        	M_PRINTF(L_PROV, "confirmation salted key ");
    eec2:	4b2b      	ldr	r3, [pc, #172]	; (ef70 <m_prov_pdu_pub_key_handler+0x158>)
    eec4:	681b      	ldr	r3, [r3, #0]
    eec6:	071b      	lsls	r3, r3, #28
    eec8:	d544      	bpl.n	ef54 <m_prov_pdu_pub_key_handler+0x13c>
    eeca:	4e2a      	ldr	r6, [pc, #168]	; (ef74 <m_prov_pdu_pub_key_handler+0x15c>)
    eecc:	1deb      	adds	r3, r5, #7
    eece:	9300      	str	r3, [sp, #0]
    eed0:	0032      	movs	r2, r6
    eed2:	0030      	movs	r0, r6
    eed4:	23c8      	movs	r3, #200	; 0xc8
    eed6:	4f29      	ldr	r7, [pc, #164]	; (ef7c <m_prov_pdu_pub_key_handler+0x164>)
    eed8:	3255      	adds	r2, #85	; 0x55
    eeda:	0039      	movs	r1, r7
    eedc:	009b      	lsls	r3, r3, #2
    eede:	305e      	adds	r0, #94	; 0x5e
    eee0:	f7f5 fd64 	bl	49ac <m_print>
    eee4:	0028      	movs	r0, r5
    eee6:	307b      	adds	r0, #123	; 0x7b
    eee8:	f7f5 fd60 	bl	49ac <m_print>
    eeec:	0030      	movs	r0, r6
    eeee:	1db9      	adds	r1, r7, #6
    eef0:	307f      	adds	r0, #127	; 0x7f
    eef2:	f7f5 fd5b 	bl	49ac <m_print>
    eef6:	e02d      	b.n	ef54 <m_prov_pdu_pub_key_handler+0x13c>
        // check if public key should be sent
        if(!p_res->oob_pub_key){
        	
            // Send local public key
            m_prov_pub_key_t pdu;
            pdu.type            = M_PROV_PDU_PUBLIC_KEY;
    eef8:	2303      	movs	r3, #3
			memcpy(pdu.pub_key_x, &(p_res->comp_data[M_PROV_CFM_INPUTS_DEV_PUB_KEY_X_OFFSET]), M_PUB_KEY_X_LEN);
    eefa:	0021      	movs	r1, r4
        // check if public key should be sent
        if(!p_res->oob_pub_key){
        	
            // Send local public key
            m_prov_pub_key_t pdu;
            pdu.type            = M_PROV_PDU_PUBLIC_KEY;
    eefc:	ae05      	add	r6, sp, #20
    eefe:	7033      	strb	r3, [r6, #0]
			memcpy(pdu.pub_key_x, &(p_res->comp_data[M_PROV_CFM_INPUTS_DEV_PUB_KEY_X_OFFSET]), M_PUB_KEY_X_LEN);
    ef00:	a802      	add	r0, sp, #8
    ef02:	330a      	adds	r3, #10
    ef04:	181b      	adds	r3, r3, r0
    ef06:	2220      	movs	r2, #32
    ef08:	317a      	adds	r1, #122	; 0x7a
    ef0a:	0018      	movs	r0, r3
    ef0c:	f006 fd60 	bl	159d0 <memcpy>
            memcpy(pdu.pub_key_y, &(p_res->comp_data[M_PROV_CFM_INPUTS_DEV_PUB_KEY_Y_OFFSET]), M_PUB_KEY_Y_LEN);
    ef10:	232d      	movs	r3, #45	; 0x2d
    ef12:	0021      	movs	r1, r4
    ef14:	a802      	add	r0, sp, #8
    ef16:	181b      	adds	r3, r3, r0
    ef18:	2220      	movs	r2, #32
    ef1a:	315a      	adds	r1, #90	; 0x5a
    ef1c:	0018      	movs	r0, r3
    ef1e:	f006 fd57 	bl	159d0 <memcpy>

			m_printf_hex(L_PROV, "send dev pub key x", pdu.pub_key_x, M_PUB_KEY_X_LEN);
    ef22:	0029      	movs	r1, r5
    ef24:	220d      	movs	r2, #13
    ef26:	a802      	add	r0, sp, #8
    ef28:	1812      	adds	r2, r2, r0
    ef2a:	3155      	adds	r1, #85	; 0x55
    ef2c:	2320      	movs	r3, #32
    ef2e:	2008      	movs	r0, #8
    ef30:	f7f5 fd9c 	bl	4a6c <m_printf_hex>
			m_printf_hex(L_PROV, "send dev pub key y", pdu.pub_key_y, M_PUB_KEY_X_LEN);
    ef34:	0029      	movs	r1, r5
    ef36:	222d      	movs	r2, #45	; 0x2d
    ef38:	a802      	add	r0, sp, #8
    ef3a:	3168      	adds	r1, #104	; 0x68
    ef3c:	1812      	adds	r2, r2, r0
    ef3e:	2320      	movs	r3, #32
    ef40:	2008      	movs	r0, #8
    ef42:	f7f5 fd93 	bl	4a6c <m_printf_hex>
            status = m_prov_pdu_send((union m_prov_pdu*) &pdu, NULL);
    ef46:	0039      	movs	r1, r7
    ef48:	0030      	movs	r0, r6
    ef4a:	f7ff fdb7 	bl	eabc <m_prov_pdu_send>
			
        }
        if(status == M_ERR_NO_ERROR){
    ef4e:	2800      	cmp	r0, #0
    ef50:	d10a      	bne.n	ef68 <m_prov_pdu_pub_key_handler+0x150>
    ef52:	e7b6      	b.n	eec2 <m_prov_pdu_pub_key_handler+0xaa>
        	M_PRINTF(L_PROV, "confirmation salted key ");
            // Immediately requests computation of confirmation salted key
            p_res->comp_inputs = 0;
    ef54:	2300      	movs	r3, #0
    ef56:	3459      	adds	r4, #89	; 0x59
    ef58:	7023      	strb	r3, [r4, #0]
            status = m_tb_sec_s1_start(M_TB_SEC_TOKEN_KEY_MANAGER, m_prov_s1_ready_cb, m_prov_cfm_salt_finished_cb);
    ef5a:	4a0a      	ldr	r2, [pc, #40]	; (ef84 <m_prov_pdu_pub_key_handler+0x16c>)
    ef5c:	490a      	ldr	r1, [pc, #40]	; (ef88 <m_prov_pdu_pub_key_handler+0x170>)
    ef5e:	2004      	movs	r0, #4
    ef60:	f005 f826 	bl	13fb0 <m_tb_sec_s1_start>
    ef64:	e000      	b.n	ef68 <m_prov_pdu_pub_key_handler+0x150>
 * @return Execution status of handler execution
 ****************************************************************************************
 */
__STATIC uint16_t m_prov_pdu_pub_key_handler(m_prov_pub_key_t* p_pdu, m_tb_buf_t* p_buf)
{
    uint16_t status = M_ERR_PROV_UNEXPECTED_PDU;
    ef66:	4809      	ldr	r0, [pc, #36]	; (ef8c <m_prov_pdu_pub_key_handler+0x174>)
            status = m_tb_sec_s1_start(M_TB_SEC_TOKEN_KEY_MANAGER, m_prov_s1_ready_cb, m_prov_cfm_salt_finished_cb);
        }
    }

    return (status);
}
    ef68:	b017      	add	sp, #92	; 0x5c
    ef6a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    ef6c:	100128a4 	.word	0x100128a4
    ef70:	10010514 	.word	0x10010514
    ef74:	00021dc8 	.word	0x00021dc8
    ef78:	00021ec8 	.word	0x00021ec8
    ef7c:	00021d48 	.word	0x00021d48
    ef80:	00000301 	.word	0x00000301
    ef84:	0000f2a5 	.word	0x0000f2a5
    ef88:	0000f265 	.word	0x0000f265
    ef8c:	00000381 	.word	0x00000381

0000ef90 <m_prov_pdu_input_cmp_handler>:
 * @return Execution status of handler execution
 ****************************************************************************************
 */
__STATIC uint16_t m_prov_pdu_input_cmp_handler(m_prov_input_cmp_t* p_pdu, m_tb_buf_t* p_buf)
{
	M_PRINTF(L_PROV, "");
    ef90:	4b0e      	ldr	r3, [pc, #56]	; (efcc <m_prov_pdu_input_cmp_handler+0x3c>)
 *
 * @return Execution status of handler execution
 ****************************************************************************************
 */
__STATIC uint16_t m_prov_pdu_input_cmp_handler(m_prov_input_cmp_t* p_pdu, m_tb_buf_t* p_buf)
{
    ef92:	b573      	push	{r0, r1, r4, r5, r6, lr}
	M_PRINTF(L_PROV, "");
    ef94:	681b      	ldr	r3, [r3, #0]
    ef96:	071b      	lsls	r3, r3, #28
    ef98:	d516      	bpl.n	efc8 <m_prov_pdu_input_cmp_handler+0x38>
    ef9a:	4c0d      	ldr	r4, [pc, #52]	; (efd0 <m_prov_pdu_input_cmp_handler+0x40>)
    ef9c:	4b0d      	ldr	r3, [pc, #52]	; (efd4 <m_prov_pdu_input_cmp_handler+0x44>)
    ef9e:	0022      	movs	r2, r4
    efa0:	0020      	movs	r0, r4
    efa2:	4d0d      	ldr	r5, [pc, #52]	; (efd8 <m_prov_pdu_input_cmp_handler+0x48>)
    efa4:	3314      	adds	r3, #20
    efa6:	0029      	movs	r1, r5
    efa8:	3255      	adds	r2, #85	; 0x55
    efaa:	9300      	str	r3, [sp, #0]
    efac:	305e      	adds	r0, #94	; 0x5e
    efae:	4b0b      	ldr	r3, [pc, #44]	; (efdc <m_prov_pdu_input_cmp_handler+0x4c>)
    efb0:	f7f5 fcfc 	bl	49ac <m_print>
    efb4:	0028      	movs	r0, r5
    efb6:	3025      	adds	r0, #37	; 0x25
    efb8:	f7f5 fcf8 	bl	49ac <m_print>
    efbc:	0020      	movs	r0, r4
    efbe:	1dae      	adds	r6, r5, #6
    efc0:	307f      	adds	r0, #127	; 0x7f
    efc2:	0031      	movs	r1, r6
    efc4:	f7f5 fcf2 	bl	49ac <m_print>
    uint16_t status = M_ERR_PROV_UNEXPECTED_PDU;
    return (status);
}
    efc8:	4805      	ldr	r0, [pc, #20]	; (efe0 <m_prov_pdu_input_cmp_handler+0x50>)
    efca:	bd76      	pop	{r1, r2, r4, r5, r6, pc}
    efcc:	10010514 	.word	0x10010514
    efd0:	00021dc8 	.word	0x00021dc8
    efd4:	00021f48 	.word	0x00021f48
    efd8:	00021d48 	.word	0x00021d48
    efdc:	00000336 	.word	0x00000336
    efe0:	00000381 	.word	0x00000381

0000efe4 <m_prov_pdu_cfm_handler>:
 ****************************************************************************************
 */
__STATIC uint16_t m_prov_pdu_cfm_handler(m_prov_cfm_t* p_pdu, m_tb_buf_t* p_buf)
{
    uint16_t status = M_ERR_PROV_UNEXPECTED_PDU;
    m_prov_res_t* p_res = p_m_prov_env->p_res;
    efe4:	4b23      	ldr	r3, [pc, #140]	; (f074 <m_prov_pdu_cfm_handler+0x90>)
 *
 * @return Execution status of handler execution
 ****************************************************************************************
 */
__STATIC uint16_t m_prov_pdu_cfm_handler(m_prov_cfm_t* p_pdu, m_tb_buf_t* p_buf)
{
    efe6:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    uint16_t status = M_ERR_PROV_UNEXPECTED_PDU;
    m_prov_res_t* p_res = p_m_prov_env->p_res;
    efe8:	681b      	ldr	r3, [r3, #0]
 *
 * @return Execution status of handler execution
 ****************************************************************************************
 */
__STATIC uint16_t m_prov_pdu_cfm_handler(m_prov_cfm_t* p_pdu, m_tb_buf_t* p_buf)
{
    efea:	0006      	movs	r6, r0
    uint16_t status = M_ERR_PROV_UNEXPECTED_PDU;
    m_prov_res_t* p_res = p_m_prov_env->p_res;
    efec:	685c      	ldr	r4, [r3, #4]
	M_PRINTF(L_PROV, "state = %d", p_res->state);
    efee:	4b22      	ldr	r3, [pc, #136]	; (f078 <m_prov_pdu_cfm_handler+0x94>)
    eff0:	681b      	ldr	r3, [r3, #0]
    eff2:	071b      	lsls	r3, r3, #28
    eff4:	d518      	bpl.n	f028 <m_prov_pdu_cfm_handler+0x44>
    eff6:	4d21      	ldr	r5, [pc, #132]	; (f07c <m_prov_pdu_cfm_handler+0x98>)
    eff8:	4b21      	ldr	r3, [pc, #132]	; (f080 <m_prov_pdu_cfm_handler+0x9c>)
    effa:	002a      	movs	r2, r5
    effc:	0028      	movs	r0, r5
    effe:	4f21      	ldr	r7, [pc, #132]	; (f084 <m_prov_pdu_cfm_handler+0xa0>)
    f000:	3331      	adds	r3, #49	; 0x31
    f002:	3255      	adds	r2, #85	; 0x55
    f004:	9300      	str	r3, [sp, #0]
    f006:	0039      	movs	r1, r7
    f008:	4b1f      	ldr	r3, [pc, #124]	; (f088 <m_prov_pdu_cfm_handler+0xa4>)
    f00a:	305e      	adds	r0, #94	; 0x5e
    f00c:	f7f5 fcce 	bl	49ac <m_print>
    f010:	0023      	movs	r3, r4
    f012:	481e      	ldr	r0, [pc, #120]	; (f08c <m_prov_pdu_cfm_handler+0xa8>)
    f014:	3358      	adds	r3, #88	; 0x58
    f016:	7819      	ldrb	r1, [r3, #0]
    f018:	3022      	adds	r0, #34	; 0x22
    f01a:	f7f5 fcc7 	bl	49ac <m_print>
    f01e:	0028      	movs	r0, r5
    f020:	1db9      	adds	r1, r7, #6
    f022:	307f      	adds	r0, #127	; 0x7f
    f024:	f7f5 fcc2 	bl	49ac <m_print>
	m_printf_hex(L_PROV, "prov pdu cfm handler", p_pdu->value, M_KEY_LEN);
    if(p_res->state == M_PROV_DSTATE_WAIT_CFM)
    f028:	0025      	movs	r5, r4
__STATIC uint16_t m_prov_pdu_cfm_handler(m_prov_cfm_t* p_pdu, m_tb_buf_t* p_buf)
{
    uint16_t status = M_ERR_PROV_UNEXPECTED_PDU;
    m_prov_res_t* p_res = p_m_prov_env->p_res;
	M_PRINTF(L_PROV, "state = %d", p_res->state);
	m_printf_hex(L_PROV, "prov pdu cfm handler", p_pdu->value, M_KEY_LEN);
    f02a:	4915      	ldr	r1, [pc, #84]	; (f080 <m_prov_pdu_cfm_handler+0x9c>)
    f02c:	3601      	adds	r6, #1
    f02e:	2310      	movs	r3, #16
    f030:	3148      	adds	r1, #72	; 0x48
    f032:	0032      	movs	r2, r6
    f034:	2008      	movs	r0, #8
    if(p_res->state == M_PROV_DSTATE_WAIT_CFM)
    f036:	3558      	adds	r5, #88	; 0x58
__STATIC uint16_t m_prov_pdu_cfm_handler(m_prov_cfm_t* p_pdu, m_tb_buf_t* p_buf)
{
    uint16_t status = M_ERR_PROV_UNEXPECTED_PDU;
    m_prov_res_t* p_res = p_m_prov_env->p_res;
	M_PRINTF(L_PROV, "state = %d", p_res->state);
	m_printf_hex(L_PROV, "prov pdu cfm handler", p_pdu->value, M_KEY_LEN);
    f038:	f7f5 fd18 	bl	4a6c <m_printf_hex>
    if(p_res->state == M_PROV_DSTATE_WAIT_CFM)
    f03c:	782b      	ldrb	r3, [r5, #0]
    f03e:	2b06      	cmp	r3, #6
    f040:	d115      	bne.n	f06e <m_prov_pdu_cfm_handler+0x8a>
    {
        // Copy received data
        memcpy(&(p_res->comp_data[M_PROV_CFM_PEER_VAL_OFFSET]), p_pdu->value, M_KEY_LEN);
    f042:	0020      	movs	r0, r4
    f044:	2210      	movs	r2, #16
    f046:	30eb      	adds	r0, #235	; 0xeb
    f048:	0031      	movs	r1, r6
    f04a:	f006 fcc1 	bl	159d0 <memcpy>
        p_res->state = M_PROV_DSTATE_WAIT_RND_COMP;
    f04e:	2307      	movs	r3, #7

        // check if all expected data for confirmation computation has been received
        if(   GETB(p_res->comp_inputs, M_PROV_COMP_AUTH_DATA)
    f050:	3459      	adds	r4, #89	; 0x59
	m_printf_hex(L_PROV, "prov pdu cfm handler", p_pdu->value, M_KEY_LEN);
    if(p_res->state == M_PROV_DSTATE_WAIT_CFM)
    {
        // Copy received data
        memcpy(&(p_res->comp_data[M_PROV_CFM_PEER_VAL_OFFSET]), p_pdu->value, M_KEY_LEN);
        p_res->state = M_PROV_DSTATE_WAIT_RND_COMP;
    f052:	702b      	strb	r3, [r5, #0]

        // check if all expected data for confirmation computation has been received
        if(   GETB(p_res->comp_inputs, M_PROV_COMP_AUTH_DATA)
    f054:	7822      	ldrb	r2, [r4, #0]
    f056:	3b02      	subs	r3, #2
    f058:	4013      	ands	r3, r2
            // compute device random data (local)
            status = m_tb_sec_rand_start(M_TB_SEC_TOKEN_PROVISIONING, m_prov_rand_finished_cb);
        }
        else
        {
            status = M_ERR_NO_ERROR;
    f05a:	2000      	movs	r0, #0
        // Copy received data
        memcpy(&(p_res->comp_data[M_PROV_CFM_PEER_VAL_OFFSET]), p_pdu->value, M_KEY_LEN);
        p_res->state = M_PROV_DSTATE_WAIT_RND_COMP;

        // check if all expected data for confirmation computation has been received
        if(   GETB(p_res->comp_inputs, M_PROV_COMP_AUTH_DATA)
    f05c:	2b05      	cmp	r3, #5
    f05e:	d107      	bne.n	f070 <m_prov_pdu_cfm_handler+0x8c>
           && GETB(p_res->comp_inputs, M_PROV_COMP_CFM_SALT)
           && GETB(p_res->comp_inputs, M_PROV_COMP_ECDH_SECRET))
    f060:	0792      	lsls	r2, r2, #30
    f062:	d505      	bpl.n	f070 <m_prov_pdu_cfm_handler+0x8c>
        {
            // compute device random data (local)
            status = m_tb_sec_rand_start(M_TB_SEC_TOKEN_PROVISIONING, m_prov_rand_finished_cb);
    f064:	490a      	ldr	r1, [pc, #40]	; (f090 <m_prov_pdu_cfm_handler+0xac>)
    f066:	0018      	movs	r0, r3
    f068:	f004 ffc5 	bl	13ff6 <m_tb_sec_rand_start>
    f06c:	e000      	b.n	f070 <m_prov_pdu_cfm_handler+0x8c>
 * @return Execution status of handler execution
 ****************************************************************************************
 */
__STATIC uint16_t m_prov_pdu_cfm_handler(m_prov_cfm_t* p_pdu, m_tb_buf_t* p_buf)
{
    uint16_t status = M_ERR_PROV_UNEXPECTED_PDU;
    f06e:	4809      	ldr	r0, [pc, #36]	; (f094 <m_prov_pdu_cfm_handler+0xb0>)
            status = M_ERR_NO_ERROR;
        }
    }

    return (status);
}
    f070:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
    f072:	46c0      	nop			; (mov r8, r8)
    f074:	100128a4 	.word	0x100128a4
    f078:	10010514 	.word	0x10010514
    f07c:	00021dc8 	.word	0x00021dc8
    f080:	00021f48 	.word	0x00021f48
    f084:	00021d48 	.word	0x00021d48
    f088:	00000349 	.word	0x00000349
    f08c:	00021ec8 	.word	0x00021ec8
    f090:	0000f689 	.word	0x0000f689
    f094:	00000381 	.word	0x00000381

0000f098 <m_prov_pdu_random_handler>:
 ****************************************************************************************
 */
__STATIC uint16_t m_prov_pdu_random_handler(m_prov_random_t* p_pdu, m_tb_buf_t* p_buf)
{
    uint16_t status = M_ERR_PROV_UNEXPECTED_PDU;
    m_prov_res_t* p_res = p_m_prov_env->p_res;
    f098:	4b14      	ldr	r3, [pc, #80]	; (f0ec <m_prov_pdu_random_handler+0x54>)
	m_printf_hex(L_PROV, "prov pdu random", p_pdu->value, M_KEY_LEN);
    f09a:	4915      	ldr	r1, [pc, #84]	; (f0f0 <m_prov_pdu_random_handler+0x58>)
 ****************************************************************************************
 */
__STATIC uint16_t m_prov_pdu_random_handler(m_prov_random_t* p_pdu, m_tb_buf_t* p_buf)
{
    uint16_t status = M_ERR_PROV_UNEXPECTED_PDU;
    m_prov_res_t* p_res = p_m_prov_env->p_res;
    f09c:	681b      	ldr	r3, [r3, #0]
 *
 * @return Execution status of handler execution
 ****************************************************************************************
 */
__STATIC uint16_t m_prov_pdu_random_handler(m_prov_random_t* p_pdu, m_tb_buf_t* p_buf)
{
    f09e:	b570      	push	{r4, r5, r6, lr}
    uint16_t status = M_ERR_PROV_UNEXPECTED_PDU;
    m_prov_res_t* p_res = p_m_prov_env->p_res;
    f0a0:	685c      	ldr	r4, [r3, #4]
	m_printf_hex(L_PROV, "prov pdu random", p_pdu->value, M_KEY_LEN);
    f0a2:	1c45      	adds	r5, r0, #1
    f0a4:	2310      	movs	r3, #16
    f0a6:	002a      	movs	r2, r5
    f0a8:	315d      	adds	r1, #93	; 0x5d
    f0aa:	2008      	movs	r0, #8
    f0ac:	f7f5 fcde 	bl	4a6c <m_printf_hex>
    if(p_res && p_res->state == M_PROV_DSTATE_WAIT_RND){
    f0b0:	2c00      	cmp	r4, #0
    f0b2:	d018      	beq.n	f0e6 <m_prov_pdu_random_handler+0x4e>
    f0b4:	0026      	movs	r6, r4
    f0b6:	3658      	adds	r6, #88	; 0x58
    f0b8:	7833      	ldrb	r3, [r6, #0]
    f0ba:	2b0a      	cmp	r3, #10
    f0bc:	d113      	bne.n	f0e6 <m_prov_pdu_random_handler+0x4e>
        // Copy received data
        memcpy(&(p_res->comp_data[M_PROV_COMP_RANDOM_OFFSET]),      p_pdu->value, M_KEY_LEN);
    f0be:	0020      	movs	r0, r4
    f0c0:	0029      	movs	r1, r5
    f0c2:	2210      	movs	r2, #16
    f0c4:	309a      	adds	r0, #154	; 0x9a
    f0c6:	f006 fc83 	bl	159d0 <memcpy>
        memcpy(&(p_res->comp_data[M_PROV_COMP_RANDOM_PROV_OFFSET]), p_pdu->value, M_KEY_LEN);
    f0ca:	0020      	movs	r0, r4
    f0cc:	0029      	movs	r1, r5
    f0ce:	2210      	movs	r2, #16
    f0d0:	306a      	adds	r0, #106	; 0x6a
    f0d2:	f006 fc7d 	bl	159d0 <memcpy>

        // Check provisioner confirmation value
        p_res->state = M_PROV_DSTATE_WAIT_PROV_CFM_COMP;
    f0d6:	230b      	movs	r3, #11
        status = m_tb_sec_cmac_start(M_TB_SEC_TOKEN_PROVISIONING, m_prov_cmac_ready_cb, m_prov_cmac_finished_cb);
    f0d8:	4a06      	ldr	r2, [pc, #24]	; (f0f4 <m_prov_pdu_random_handler+0x5c>)
        // Copy received data
        memcpy(&(p_res->comp_data[M_PROV_COMP_RANDOM_OFFSET]),      p_pdu->value, M_KEY_LEN);
        memcpy(&(p_res->comp_data[M_PROV_COMP_RANDOM_PROV_OFFSET]), p_pdu->value, M_KEY_LEN);

        // Check provisioner confirmation value
        p_res->state = M_PROV_DSTATE_WAIT_PROV_CFM_COMP;
    f0da:	7033      	strb	r3, [r6, #0]
        status = m_tb_sec_cmac_start(M_TB_SEC_TOKEN_PROVISIONING, m_prov_cmac_ready_cb, m_prov_cmac_finished_cb);
    f0dc:	4906      	ldr	r1, [pc, #24]	; (f0f8 <m_prov_pdu_random_handler+0x60>)
    f0de:	2005      	movs	r0, #5
    f0e0:	f004 ff5f 	bl	13fa2 <m_tb_sec_cmac_start>
    f0e4:	e000      	b.n	f0e8 <m_prov_pdu_random_handler+0x50>
 * @return Execution status of handler execution
 ****************************************************************************************
 */
__STATIC uint16_t m_prov_pdu_random_handler(m_prov_random_t* p_pdu, m_tb_buf_t* p_buf)
{
    uint16_t status = M_ERR_PROV_UNEXPECTED_PDU;
    f0e6:	4805      	ldr	r0, [pc, #20]	; (f0fc <m_prov_pdu_random_handler+0x64>)
        p_res->state = M_PROV_DSTATE_WAIT_PROV_CFM_COMP;
        status = m_tb_sec_cmac_start(M_TB_SEC_TOKEN_PROVISIONING, m_prov_cmac_ready_cb, m_prov_cmac_finished_cb);
    }

    return (status);
}
    f0e8:	bd70      	pop	{r4, r5, r6, pc}
    f0ea:	46c0      	nop			; (mov r8, r8)
    f0ec:	100128a4 	.word	0x100128a4
    f0f0:	00021f48 	.word	0x00021f48
    f0f4:	0000fa31 	.word	0x0000fa31
    f0f8:	0000f9f1 	.word	0x0000f9f1
    f0fc:	00000381 	.word	0x00000381

0000f100 <m_prov_pdu_data_handler>:
 ****************************************************************************************
 */
__STATIC uint16_t m_prov_pdu_data_handler(m_prov_data_t* p_pdu, m_tb_buf_t* p_buf)
{
    uint16_t status = M_ERR_PROV_UNEXPECTED_PDU;
    m_prov_res_t* p_res = p_m_prov_env->p_res;
    f100:	4b1c      	ldr	r3, [pc, #112]	; (f174 <m_prov_pdu_data_handler+0x74>)
 *
 * @return Execution status of handler execution
 ****************************************************************************************
 */
__STATIC uint16_t m_prov_pdu_data_handler(m_prov_data_t* p_pdu, m_tb_buf_t* p_buf)
{
    f102:	b5f0      	push	{r4, r5, r6, r7, lr}
    uint16_t status = M_ERR_PROV_UNEXPECTED_PDU;
    m_prov_res_t* p_res = p_m_prov_env->p_res;
    f104:	681b      	ldr	r3, [r3, #0]
 *
 * @return Execution status of handler execution
 ****************************************************************************************
 */
__STATIC uint16_t m_prov_pdu_data_handler(m_prov_data_t* p_pdu, m_tb_buf_t* p_buf)
{
    f106:	b085      	sub	sp, #20
    uint16_t status = M_ERR_PROV_UNEXPECTED_PDU;
    m_prov_res_t* p_res = p_m_prov_env->p_res;
    f108:	685d      	ldr	r5, [r3, #4]
	M_PRINTF(L_PROV, "state = %d", p_res->state);
    f10a:	4b1b      	ldr	r3, [pc, #108]	; (f178 <m_prov_pdu_data_handler+0x78>)
    f10c:	002f      	movs	r7, r5
    f10e:	681b      	ldr	r3, [r3, #0]
 *
 * @return Execution status of handler execution
 ****************************************************************************************
 */
__STATIC uint16_t m_prov_pdu_data_handler(m_prov_data_t* p_pdu, m_tb_buf_t* p_buf)
{
    f110:	9003      	str	r0, [sp, #12]
    f112:	3758      	adds	r7, #88	; 0x58
    uint16_t status = M_ERR_PROV_UNEXPECTED_PDU;
    m_prov_res_t* p_res = p_m_prov_env->p_res;
	M_PRINTF(L_PROV, "state = %d", p_res->state);
    f114:	071b      	lsls	r3, r3, #28
    f116:	d517      	bpl.n	f148 <m_prov_pdu_data_handler+0x48>
    f118:	4b18      	ldr	r3, [pc, #96]	; (f17c <m_prov_pdu_data_handler+0x7c>)
    f11a:	4c19      	ldr	r4, [pc, #100]	; (f180 <m_prov_pdu_data_handler+0x80>)
    f11c:	336d      	adds	r3, #109	; 0x6d
    f11e:	9300      	str	r3, [sp, #0]
    f120:	0022      	movs	r2, r4
    f122:	0020      	movs	r0, r4
    f124:	23e3      	movs	r3, #227	; 0xe3
    f126:	4e17      	ldr	r6, [pc, #92]	; (f184 <m_prov_pdu_data_handler+0x84>)
    f128:	3255      	adds	r2, #85	; 0x55
    f12a:	009b      	lsls	r3, r3, #2
    f12c:	0031      	movs	r1, r6
    f12e:	305e      	adds	r0, #94	; 0x5e
    f130:	f7f5 fc3c 	bl	49ac <m_print>
    f134:	4814      	ldr	r0, [pc, #80]	; (f188 <m_prov_pdu_data_handler+0x88>)
    f136:	7839      	ldrb	r1, [r7, #0]
    f138:	3022      	adds	r0, #34	; 0x22
    f13a:	f7f5 fc37 	bl	49ac <m_print>
    f13e:	0020      	movs	r0, r4
    f140:	1db1      	adds	r1, r6, #6
    f142:	307f      	adds	r0, #127	; 0x7f
    f144:	f7f5 fc32 	bl	49ac <m_print>
    // Check device is in proper state
    if(p_res->state == M_PROV_DSTATE_WAIT_DATA)
    f148:	783b      	ldrb	r3, [r7, #0]
    f14a:	2b10      	cmp	r3, #16
    f14c:	d10e      	bne.n	f16c <m_prov_pdu_data_handler+0x6c>
    {
        // copy received data
        memcpy(&(p_res->comp_data[M_PROV_COMP_DATA_ENC_OFFSET]), p_pdu->enc, M_PROV_DATA_LEN + M_PROV_MIC_LEN);
    f14e:	0028      	movs	r0, r5
    f150:	9903      	ldr	r1, [sp, #12]
    f152:	2221      	movs	r2, #33	; 0x21
    f154:	3101      	adds	r1, #1
    f156:	30aa      	adds	r0, #170	; 0xaa
    f158:	f006 fc3a 	bl	159d0 <memcpy>

        // Ready to decrypt (session info loaded), start decryption
        p_res->state = M_PROV_DSTATE_WAIT_DATA_DEC;
    f15c:	2311      	movs	r3, #17
        status = m_tb_sec_ccm_dec_start(M_TB_SEC_TOKEN_PROVISIONING, m_prov_ccm_ready_cb, m_prov_ccm_finished_cb);
    f15e:	4a0b      	ldr	r2, [pc, #44]	; (f18c <m_prov_pdu_data_handler+0x8c>)
    {
        // copy received data
        memcpy(&(p_res->comp_data[M_PROV_COMP_DATA_ENC_OFFSET]), p_pdu->enc, M_PROV_DATA_LEN + M_PROV_MIC_LEN);

        // Ready to decrypt (session info loaded), start decryption
        p_res->state = M_PROV_DSTATE_WAIT_DATA_DEC;
    f160:	703b      	strb	r3, [r7, #0]
        status = m_tb_sec_ccm_dec_start(M_TB_SEC_TOKEN_PROVISIONING, m_prov_ccm_ready_cb, m_prov_ccm_finished_cb);
    f162:	490b      	ldr	r1, [pc, #44]	; (f190 <m_prov_pdu_data_handler+0x90>)
    f164:	2005      	movs	r0, #5
    f166:	f004 ff56 	bl	14016 <m_tb_sec_ccm_dec_start>
    f16a:	e000      	b.n	f16e <m_prov_pdu_data_handler+0x6e>
 * @return Execution status of handler execution
 ****************************************************************************************
 */
__STATIC uint16_t m_prov_pdu_data_handler(m_prov_data_t* p_pdu, m_tb_buf_t* p_buf)
{
    uint16_t status = M_ERR_PROV_UNEXPECTED_PDU;
    f16c:	4809      	ldr	r0, [pc, #36]	; (f194 <m_prov_pdu_data_handler+0x94>)
        p_res->state = M_PROV_DSTATE_WAIT_DATA_DEC;
        status = m_tb_sec_ccm_dec_start(M_TB_SEC_TOKEN_PROVISIONING, m_prov_ccm_ready_cb, m_prov_ccm_finished_cb);
    }

    return (status);
}
    f16e:	b005      	add	sp, #20
    f170:	bdf0      	pop	{r4, r5, r6, r7, pc}
    f172:	46c0      	nop			; (mov r8, r8)
    f174:	100128a4 	.word	0x100128a4
    f178:	10010514 	.word	0x10010514
    f17c:	00021f48 	.word	0x00021f48
    f180:	00021dc8 	.word	0x00021dc8
    f184:	00021d48 	.word	0x00021d48
    f188:	00021ec8 	.word	0x00021ec8
    f18c:	0000fbfd 	.word	0x0000fbfd
    f190:	0000fba1 	.word	0x0000fba1
    f194:	00000381 	.word	0x00000381

0000f198 <m_prov_pdu_cmp_handler>:
 * @return Execution status of handler execution
 ****************************************************************************************
 */
__STATIC uint16_t m_prov_pdu_cmp_handler(m_prov_cmp_t* p_pdu, m_tb_buf_t* p_buf)
{
	M_PRINTF(L_PROV, "");
    f198:	4b0e      	ldr	r3, [pc, #56]	; (f1d4 <m_prov_pdu_cmp_handler+0x3c>)
 *
 * @return Execution status of handler execution
 ****************************************************************************************
 */
__STATIC uint16_t m_prov_pdu_cmp_handler(m_prov_cmp_t* p_pdu, m_tb_buf_t* p_buf)
{
    f19a:	b573      	push	{r0, r1, r4, r5, r6, lr}
	M_PRINTF(L_PROV, "");
    f19c:	681b      	ldr	r3, [r3, #0]
    f19e:	071b      	lsls	r3, r3, #28
    f1a0:	d516      	bpl.n	f1d0 <m_prov_pdu_cmp_handler+0x38>
    f1a2:	4c0d      	ldr	r4, [pc, #52]	; (f1d8 <m_prov_pdu_cmp_handler+0x40>)
    f1a4:	4b0d      	ldr	r3, [pc, #52]	; (f1dc <m_prov_pdu_cmp_handler+0x44>)
    f1a6:	0022      	movs	r2, r4
    f1a8:	0020      	movs	r0, r4
    f1aa:	4d0d      	ldr	r5, [pc, #52]	; (f1e0 <m_prov_pdu_cmp_handler+0x48>)
    f1ac:	3305      	adds	r3, #5
    f1ae:	0029      	movs	r1, r5
    f1b0:	3255      	adds	r2, #85	; 0x55
    f1b2:	9300      	str	r3, [sp, #0]
    f1b4:	305e      	adds	r0, #94	; 0x5e
    f1b6:	4b0b      	ldr	r3, [pc, #44]	; (f1e4 <m_prov_pdu_cmp_handler+0x4c>)
    f1b8:	f7f5 fbf8 	bl	49ac <m_print>
    f1bc:	0028      	movs	r0, r5
    f1be:	3025      	adds	r0, #37	; 0x25
    f1c0:	f7f5 fbf4 	bl	49ac <m_print>
    f1c4:	0020      	movs	r0, r4
    f1c6:	1dae      	adds	r6, r5, #6
    f1c8:	307f      	adds	r0, #127	; 0x7f
    f1ca:	0031      	movs	r1, r6
    f1cc:	f7f5 fbee 	bl	49ac <m_print>
    uint16_t status = M_ERR_PROV_UNEXPECTED_PDU;
    return (status);
}
    f1d0:	4805      	ldr	r0, [pc, #20]	; (f1e8 <m_prov_pdu_cmp_handler+0x50>)
    f1d2:	bd76      	pop	{r1, r2, r4, r5, r6, pc}
    f1d4:	10010514 	.word	0x10010514
    f1d8:	00021dc8 	.word	0x00021dc8
    f1dc:	00021fc8 	.word	0x00021fc8
    f1e0:	00021d48 	.word	0x00021d48
    f1e4:	000003a7 	.word	0x000003a7
    f1e8:	00000381 	.word	0x00000381

0000f1ec <m_prov_pdu_failed_handler>:
 * @return Execution status of handler execution
 ****************************************************************************************
 */
__STATIC uint16_t m_prov_pdu_failed_handler(m_prov_failed_t* p_pdu, m_tb_buf_t* p_buf)
{
	M_PRINTF(L_PROV, "");
    f1ec:	4b17      	ldr	r3, [pc, #92]	; (f24c <m_prov_pdu_failed_handler+0x60>)
 *
 * @return Execution status of handler execution
 ****************************************************************************************
 */
__STATIC uint16_t m_prov_pdu_failed_handler(m_prov_failed_t* p_pdu, m_tb_buf_t* p_buf)
{
    f1ee:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	M_PRINTF(L_PROV, "");
    f1f0:	681b      	ldr	r3, [r3, #0]
 *
 * @return Execution status of handler execution
 ****************************************************************************************
 */
__STATIC uint16_t m_prov_pdu_failed_handler(m_prov_failed_t* p_pdu, m_tb_buf_t* p_buf)
{
    f1f2:	0005      	movs	r5, r0
	M_PRINTF(L_PROV, "");
    f1f4:	071b      	lsls	r3, r3, #28
    f1f6:	d517      	bpl.n	f228 <m_prov_pdu_failed_handler+0x3c>
    f1f8:	4b15      	ldr	r3, [pc, #84]	; (f250 <m_prov_pdu_failed_handler+0x64>)
    f1fa:	4c16      	ldr	r4, [pc, #88]	; (f254 <m_prov_pdu_failed_handler+0x68>)
    f1fc:	331c      	adds	r3, #28
    f1fe:	9300      	str	r3, [sp, #0]
    f200:	0022      	movs	r2, r4
    f202:	0020      	movs	r0, r4
    f204:	23ee      	movs	r3, #238	; 0xee
    f206:	4f14      	ldr	r7, [pc, #80]	; (f258 <m_prov_pdu_failed_handler+0x6c>)
    f208:	3255      	adds	r2, #85	; 0x55
    f20a:	0039      	movs	r1, r7
    f20c:	009b      	lsls	r3, r3, #2
    f20e:	305e      	adds	r0, #94	; 0x5e
    f210:	f7f5 fbcc 	bl	49ac <m_print>
    f214:	0038      	movs	r0, r7
    f216:	3025      	adds	r0, #37	; 0x25
    f218:	f7f5 fbc8 	bl	49ac <m_print>
    f21c:	0020      	movs	r0, r4
    f21e:	1dbe      	adds	r6, r7, #6
    f220:	307f      	adds	r0, #127	; 0x7f
    f222:	0031      	movs	r1, r6
    f224:	f7f5 fbc2 	bl	49ac <m_print>
    uint16_t status = M_ERR_PROV_UNEXPECTED_PDU;
    m_prov_res_t* p_res = p_m_prov_env->p_res;
    f228:	4b0c      	ldr	r3, [pc, #48]	; (f25c <m_prov_pdu_failed_handler+0x70>)
    f22a:	681b      	ldr	r3, [r3, #0]
    f22c:	685b      	ldr	r3, [r3, #4]

    if(p_res != NULL)
    f22e:	2b00      	cmp	r3, #0
    f230:	d00a      	beq.n	f248 <m_prov_pdu_failed_handler+0x5c>
    {
        // Pairing failed, handle it.
        p_res->state = M_PROV_DSTATE_PEER_FAILED;
    f232:	2214      	movs	r2, #20
    f234:	3358      	adds	r3, #88	; 0x58
    f236:	701a      	strb	r2, [r3, #0]
        m_prov_error_handle(M_ERR(PROVISIONING, p_pdu->err_code));
    f238:	2381      	movs	r3, #129	; 0x81
    f23a:	7868      	ldrb	r0, [r5, #1]
    f23c:	0200      	lsls	r0, r0, #8
    f23e:	4318      	orrs	r0, r3
    f240:	f000 fd94 	bl	fd6c <m_prov_error_handle>
        status = M_ERR_NO_ERROR;
    f244:	2000      	movs	r0, #0
    f246:	e000      	b.n	f24a <m_prov_pdu_failed_handler+0x5e>
 ****************************************************************************************
 */
__STATIC uint16_t m_prov_pdu_failed_handler(m_prov_failed_t* p_pdu, m_tb_buf_t* p_buf)
{
	M_PRINTF(L_PROV, "");
    uint16_t status = M_ERR_PROV_UNEXPECTED_PDU;
    f248:	4805      	ldr	r0, [pc, #20]	; (f260 <m_prov_pdu_failed_handler+0x74>)
        p_res->state = M_PROV_DSTATE_PEER_FAILED;
        m_prov_error_handle(M_ERR(PROVISIONING, p_pdu->err_code));
        status = M_ERR_NO_ERROR;
    }
    return (status);
}
    f24a:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
    f24c:	10010514 	.word	0x10010514
    f250:	00021fc8 	.word	0x00021fc8
    f254:	00021dc8 	.word	0x00021dc8
    f258:	00021d48 	.word	0x00021d48
    f25c:	100128a4 	.word	0x100128a4
    f260:	00000381 	.word	0x00000381

0000f264 <m_prov_s1_ready_cb>:
 ****************************************************************************************
 */
__STATIC uint16_t m_prov_s1_ready_cb(uint8_t token_id, const uint8_t** pp_msg, uint8_t* p_msg_len)
{
    uint16_t status = M_ERR_COMMAND_DISALLOWED;
    m_prov_res_t* p_res = p_m_prov_env->p_res;
    f264:	4b0d      	ldr	r3, [pc, #52]	; (f29c <m_prov_s1_ready_cb+0x38>)
    f266:	681b      	ldr	r3, [r3, #0]
    f268:	685b      	ldr	r3, [r3, #4]

    if(p_res != NULL)
    f26a:	2b00      	cmp	r3, #0
    f26c:	d014      	beq.n	f298 <m_prov_s1_ready_cb+0x34>
    {
        // check state of
        switch(p_res->state)
    f26e:	0018      	movs	r0, r3
    f270:	3058      	adds	r0, #88	; 0x58
    f272:	7800      	ldrb	r0, [r0, #0]
    f274:	2805      	cmp	r0, #5
    f276:	d30f      	bcc.n	f298 <m_prov_s1_ready_cb+0x34>
    f278:	2807      	cmp	r0, #7
    f27a:	d907      	bls.n	f28c <m_prov_s1_ready_cb+0x28>
    f27c:	280c      	cmp	r0, #12
    f27e:	d10b      	bne.n	f298 <m_prov_s1_ready_cb+0x34>
                status = M_ERR_NO_ERROR;
            } break;
            case M_PROV_DSTATE_WAIT_PROV_SALT_COMP:
            {
                // Copy input data
                *pp_msg    = (uint8_t*) &(p_res->comp_data[M_PROV_COMP_RANDOM_DEV_OFFSET]);
    f280:	335a      	adds	r3, #90	; 0x5a
    f282:	600b      	str	r3, [r1, #0]
                *p_msg_len = (M_KEY_LEN*3);
    f284:	2330      	movs	r3, #48	; 0x30

                status = M_ERR_NO_ERROR;
    f286:	2000      	movs	r0, #0
            } break;
            case M_PROV_DSTATE_WAIT_PROV_SALT_COMP:
            {
                // Copy input data
                *pp_msg    = (uint8_t*) &(p_res->comp_data[M_PROV_COMP_RANDOM_DEV_OFFSET]);
                *p_msg_len = (M_KEY_LEN*3);
    f288:	7013      	strb	r3, [r2, #0]

                status = M_ERR_NO_ERROR;
            } break;
    f28a:	e006      	b.n	f29a <m_prov_s1_ready_cb+0x36>
            case M_PROV_DSTATE_WAIT_AUTH_INPUT:
            case M_PROV_DSTATE_WAIT_CFM:
            case M_PROV_DSTATE_WAIT_RND_COMP:
            {
                // Copy input data
                *pp_msg    = (uint8_t*) p_res->comp_data;
    f28c:	335a      	adds	r3, #90	; 0x5a
    f28e:	600b      	str	r3, [r1, #0]
                *p_msg_len = M_PROV_CFM_INPUTS_LEN;
    f290:	2391      	movs	r3, #145	; 0x91

                status = M_ERR_NO_ERROR;
    f292:	2000      	movs	r0, #0
            case M_PROV_DSTATE_WAIT_CFM:
            case M_PROV_DSTATE_WAIT_RND_COMP:
            {
                // Copy input data
                *pp_msg    = (uint8_t*) p_res->comp_data;
                *p_msg_len = M_PROV_CFM_INPUTS_LEN;
    f294:	7013      	strb	r3, [r2, #0]

                status = M_ERR_NO_ERROR;
            } break;
    f296:	e000      	b.n	f29a <m_prov_s1_ready_cb+0x36>
 * @return Status error code (@see enum m_error)
 ****************************************************************************************
 */
__STATIC uint16_t m_prov_s1_ready_cb(uint8_t token_id, const uint8_t** pp_msg, uint8_t* p_msg_len)
{
    uint16_t status = M_ERR_COMMAND_DISALLOWED;
    f298:	4801      	ldr	r0, [pc, #4]	; (f2a0 <m_prov_s1_ready_cb+0x3c>)
            default: { /* Nothing to do */} break;
        }
    }

    return (status);
}
    f29a:	4770      	bx	lr
    f29c:	100128a4 	.word	0x100128a4
    f2a0:	00000282 	.word	0x00000282

0000f2a4 <m_prov_cfm_salt_finished_cb>:
 *                      (@note equals NULL for AES-CCM encrypt and decrypt functions)
 ****************************************************************************************
 */
__STATIC void m_prov_cfm_salt_finished_cb(uint8_t token_id, uint16_t status, const uint8_t* p_key)
{
    m_prov_res_t* p_res = p_m_prov_env->p_res;
    f2a4:	4b52      	ldr	r3, [pc, #328]	; (f3f0 <m_prov_cfm_salt_finished_cb+0x14c>)
 *                      (@note length is variable and depends on security function used)
 *                      (@note equals NULL for AES-CCM encrypt and decrypt functions)
 ****************************************************************************************
 */
__STATIC void m_prov_cfm_salt_finished_cb(uint8_t token_id, uint16_t status, const uint8_t* p_key)
{
    f2a6:	b5f0      	push	{r4, r5, r6, r7, lr}
    m_prov_res_t* p_res = p_m_prov_env->p_res;
    f2a8:	681b      	ldr	r3, [r3, #0]
 *                      (@note length is variable and depends on security function used)
 *                      (@note equals NULL for AES-CCM encrypt and decrypt functions)
 ****************************************************************************************
 */
__STATIC void m_prov_cfm_salt_finished_cb(uint8_t token_id, uint16_t status, const uint8_t* p_key)
{
    f2aa:	b085      	sub	sp, #20
    m_prov_res_t* p_res = p_m_prov_env->p_res;
    f2ac:	685c      	ldr	r4, [r3, #4]
	M_PRINTF(L_PROV, "status = %d", status);
    f2ae:	4b51      	ldr	r3, [pc, #324]	; (f3f4 <m_prov_cfm_salt_finished_cb+0x150>)
 *                      (@note length is variable and depends on security function used)
 *                      (@note equals NULL for AES-CCM encrypt and decrypt functions)
 ****************************************************************************************
 */
__STATIC void m_prov_cfm_salt_finished_cb(uint8_t token_id, uint16_t status, const uint8_t* p_key)
{
    f2b0:	9102      	str	r1, [sp, #8]
    m_prov_res_t* p_res = p_m_prov_env->p_res;
	M_PRINTF(L_PROV, "status = %d", status);
    f2b2:	681b      	ldr	r3, [r3, #0]
 *                      (@note length is variable and depends on security function used)
 *                      (@note equals NULL for AES-CCM encrypt and decrypt functions)
 ****************************************************************************************
 */
__STATIC void m_prov_cfm_salt_finished_cb(uint8_t token_id, uint16_t status, const uint8_t* p_key)
{
    f2b4:	9203      	str	r2, [sp, #12]
    m_prov_res_t* p_res = p_m_prov_env->p_res;
	M_PRINTF(L_PROV, "status = %d", status);
    f2b6:	071b      	lsls	r3, r3, #28
    f2b8:	d517      	bpl.n	f2ea <m_prov_cfm_salt_finished_cb+0x46>
    f2ba:	4e4f      	ldr	r6, [pc, #316]	; (f3f8 <m_prov_cfm_salt_finished_cb+0x154>)
    f2bc:	4d4f      	ldr	r5, [pc, #316]	; (f3fc <m_prov_cfm_salt_finished_cb+0x158>)
    f2be:	0033      	movs	r3, r6
    f2c0:	002a      	movs	r2, r5
    f2c2:	0028      	movs	r0, r5
    f2c4:	4f4e      	ldr	r7, [pc, #312]	; (f400 <m_prov_cfm_salt_finished_cb+0x15c>)
    f2c6:	3336      	adds	r3, #54	; 0x36
    f2c8:	3255      	adds	r2, #85	; 0x55
    f2ca:	9300      	str	r3, [sp, #0]
    f2cc:	0039      	movs	r1, r7
    f2ce:	4b4d      	ldr	r3, [pc, #308]	; (f404 <m_prov_cfm_salt_finished_cb+0x160>)
    f2d0:	305e      	adds	r0, #94	; 0x5e
    f2d2:	f7f5 fb6b 	bl	49ac <m_print>
    f2d6:	0030      	movs	r0, r6
    f2d8:	9902      	ldr	r1, [sp, #8]
    f2da:	3052      	adds	r0, #82	; 0x52
    f2dc:	f7f5 fb66 	bl	49ac <m_print>
    f2e0:	0028      	movs	r0, r5
    f2e2:	1db9      	adds	r1, r7, #6
    f2e4:	307f      	adds	r0, #127	; 0x7f
    f2e6:	f7f5 fb61 	bl	49ac <m_print>
	m_printf_hex(L_PROV, "prov cfm salt finished", p_key, 16);
    f2ea:	4f43      	ldr	r7, [pc, #268]	; (f3f8 <m_prov_cfm_salt_finished_cb+0x154>)
    f2ec:	2310      	movs	r3, #16
    f2ee:	0039      	movs	r1, r7
    f2f0:	9a03      	ldr	r2, [sp, #12]
    f2f2:	315e      	adds	r1, #94	; 0x5e
    f2f4:	2008      	movs	r0, #8
    f2f6:	f7f5 fbb9 	bl	4a6c <m_printf_hex>
	M_PRINTF(L_PROV, "state = %d", p_res->state);
    f2fa:	4b3e      	ldr	r3, [pc, #248]	; (f3f4 <m_prov_cfm_salt_finished_cb+0x150>)
    f2fc:	681b      	ldr	r3, [r3, #0]
    f2fe:	071b      	lsls	r3, r3, #28
    f300:	d518      	bpl.n	f334 <m_prov_cfm_salt_finished_cb+0x90>
    f302:	4d3e      	ldr	r5, [pc, #248]	; (f3fc <m_prov_cfm_salt_finished_cb+0x158>)
    f304:	4e3e      	ldr	r6, [pc, #248]	; (f400 <m_prov_cfm_salt_finished_cb+0x15c>)
    f306:	002a      	movs	r2, r5
    f308:	0028      	movs	r0, r5
    f30a:	3736      	adds	r7, #54	; 0x36
    f30c:	3255      	adds	r2, #85	; 0x55
    f30e:	0031      	movs	r1, r6
    f310:	9700      	str	r7, [sp, #0]
    f312:	4b3d      	ldr	r3, [pc, #244]	; (f408 <m_prov_cfm_salt_finished_cb+0x164>)
    f314:	305e      	adds	r0, #94	; 0x5e
    f316:	f7f5 fb49 	bl	49ac <m_print>
    f31a:	0023      	movs	r3, r4
    f31c:	483b      	ldr	r0, [pc, #236]	; (f40c <m_prov_cfm_salt_finished_cb+0x168>)
    f31e:	3358      	adds	r3, #88	; 0x58
    f320:	7819      	ldrb	r1, [r3, #0]
    f322:	3022      	adds	r0, #34	; 0x22
    f324:	f7f5 fb42 	bl	49ac <m_print>
    f328:	0028      	movs	r0, r5
    f32a:	1db1      	adds	r1, r6, #6
    f32c:	307f      	adds	r0, #127	; 0x7f
    f32e:	f7f5 fb3d 	bl	49ac <m_print>
    f332:	e001      	b.n	f338 <m_prov_cfm_salt_finished_cb+0x94>
    if(p_res != NULL)
    f334:	2c00      	cmp	r4, #0
    f336:	d059      	beq.n	f3ec <m_prov_cfm_salt_finished_cb+0x148>
    {
        uint16_t pub_key_x_offset = 0;
        uint16_t pub_key_y_offset = 0;

        if(status == M_ERR_NO_ERROR)
    f338:	9b02      	ldr	r3, [sp, #8]
    f33a:	2b00      	cmp	r3, #0
    f33c:	d107      	bne.n	f34e <m_prov_cfm_salt_finished_cb+0xaa>
        {
            switch(p_res->state)
    f33e:	0023      	movs	r3, r4
    f340:	3358      	adds	r3, #88	; 0x58
    f342:	781b      	ldrb	r3, [r3, #0]
    f344:	3b05      	subs	r3, #5
    f346:	2b02      	cmp	r3, #2
    f348:	d905      	bls.n	f356 <m_prov_cfm_salt_finished_cb+0xb2>
                    pub_key_x_offset = M_PROV_CFM_INPUTS_PROV_PUB_KEY_X_OFFSET;
                    pub_key_y_offset = M_PROV_CFM_INPUTS_PROV_PUB_KEY_Y_OFFSET;
                } break;

                // unexpected state of the  provisioning algorithm
                default: { status = M_ERR_PROV_UNEXPECTED; } break;
    f34a:	4b31      	ldr	r3, [pc, #196]	; (f410 <m_prov_cfm_salt_finished_cb+0x16c>)
    f34c:	9302      	str	r3, [sp, #8]
            }
        }
        else
        {
            // Handle error
            m_prov_error_handle(status);
    f34e:	9802      	ldr	r0, [sp, #8]
    f350:	f000 fd0c 	bl	fd6c <m_prov_error_handle>
    f354:	e04a      	b.n	f3ec <m_prov_cfm_salt_finished_cb+0x148>
            }
        }

        if(status == M_ERR_NO_ERROR)
        {	
			M_PRINTF(L_PROV, "");
    f356:	4b27      	ldr	r3, [pc, #156]	; (f3f4 <m_prov_cfm_salt_finished_cb+0x150>)
    f358:	681b      	ldr	r3, [r3, #0]
    f35a:	071b      	lsls	r3, r3, #28
    f35c:	d516      	bpl.n	f38c <m_prov_cfm_salt_finished_cb+0xe8>
    f35e:	4d27      	ldr	r5, [pc, #156]	; (f3fc <m_prov_cfm_salt_finished_cb+0x158>)
    f360:	4b25      	ldr	r3, [pc, #148]	; (f3f8 <m_prov_cfm_salt_finished_cb+0x154>)
    f362:	002a      	movs	r2, r5
    f364:	0028      	movs	r0, r5
    f366:	4e26      	ldr	r6, [pc, #152]	; (f400 <m_prov_cfm_salt_finished_cb+0x15c>)
    f368:	3336      	adds	r3, #54	; 0x36
    f36a:	0031      	movs	r1, r6
    f36c:	3255      	adds	r2, #85	; 0x55
    f36e:	9300      	str	r3, [sp, #0]
    f370:	305e      	adds	r0, #94	; 0x5e
    f372:	4b28      	ldr	r3, [pc, #160]	; (f414 <m_prov_cfm_salt_finished_cb+0x170>)
    f374:	f7f5 fb1a 	bl	49ac <m_print>
    f378:	0030      	movs	r0, r6
    f37a:	3025      	adds	r0, #37	; 0x25
    f37c:	f7f5 fb16 	bl	49ac <m_print>
    f380:	0028      	movs	r0, r5
    f382:	1db7      	adds	r7, r6, #6
    f384:	307f      	adds	r0, #127	; 0x7f
    f386:	0039      	movs	r1, r7
    f388:	f7f5 fb10 	bl	49ac <m_print>
            // Request computation of ECDHSecret
            m_al_sec_ecdh_secret(&(p_res->comp_data[pub_key_x_offset]),
    f38c:	0021      	movs	r1, r4
    f38e:	0020      	movs	r0, r4
                                 &(p_res->comp_data[pub_key_y_offset]),
                                 m_prov_ecdh_secret_res_cb);

            // Mark that Confirm Salt has been computed - copy it
            SETB(p_res->comp_inputs, M_PROV_COMP_CFM_SALT, true);
    f390:	0026      	movs	r6, r4

        if(status == M_ERR_NO_ERROR)
        {	
			M_PRINTF(L_PROV, "");
            // Request computation of ECDHSecret
            m_al_sec_ecdh_secret(&(p_res->comp_data[pub_key_x_offset]),
    f392:	4a21      	ldr	r2, [pc, #132]	; (f418 <m_prov_cfm_salt_finished_cb+0x174>)
    f394:	319a      	adds	r1, #154	; 0x9a
    f396:	30ba      	adds	r0, #186	; 0xba
    f398:	f7f6 f832 	bl	5400 <m_al_sec_ecdh_secret>
                                 &(p_res->comp_data[pub_key_y_offset]),
                                 m_prov_ecdh_secret_res_cb);

            // Mark that Confirm Salt has been computed - copy it
            SETB(p_res->comp_inputs, M_PROV_COMP_CFM_SALT, true);
    f39c:	2304      	movs	r3, #4
            memcpy(&(p_res->comp_data[M_PROV_COMP_SALT_OFFSET]), p_key, M_KEY_LEN);
    f39e:	0020      	movs	r0, r4
            m_al_sec_ecdh_secret(&(p_res->comp_data[pub_key_x_offset]),
                                 &(p_res->comp_data[pub_key_y_offset]),
                                 m_prov_ecdh_secret_res_cb);

            // Mark that Confirm Salt has been computed - copy it
            SETB(p_res->comp_inputs, M_PROV_COMP_CFM_SALT, true);
    f3a0:	3659      	adds	r6, #89	; 0x59
    f3a2:	7835      	ldrb	r5, [r6, #0]
            memcpy(&(p_res->comp_data[M_PROV_COMP_SALT_OFFSET]), p_key, M_KEY_LEN);
    f3a4:	2210      	movs	r2, #16
            m_al_sec_ecdh_secret(&(p_res->comp_data[pub_key_x_offset]),
                                 &(p_res->comp_data[pub_key_y_offset]),
                                 m_prov_ecdh_secret_res_cb);

            // Mark that Confirm Salt has been computed - copy it
            SETB(p_res->comp_inputs, M_PROV_COMP_CFM_SALT, true);
    f3a6:	432b      	orrs	r3, r5
    f3a8:	7033      	strb	r3, [r6, #0]
            memcpy(&(p_res->comp_data[M_PROV_COMP_SALT_OFFSET]), p_key, M_KEY_LEN);
    f3aa:	9903      	ldr	r1, [sp, #12]
    f3ac:	307a      	adds	r0, #122	; 0x7a
    f3ae:	f006 fb0f 	bl	159d0 <memcpy>

            // No OOB data expected
            if(p_res->auth_method == M_PROV_AUTH_NO_OOB)
    f3b2:	0023      	movs	r3, r4
    f3b4:	3355      	adds	r3, #85	; 0x55
    f3b6:	781b      	ldrb	r3, [r3, #0]
    f3b8:	2b00      	cmp	r3, #0
    f3ba:	d109      	bne.n	f3d0 <m_prov_cfm_salt_finished_cb+0x12c>
            {
                // mark that authentication data has been received
                SETB(p_res->comp_inputs, M_PROV_COMP_AUTH_DATA, true);
    f3bc:	2205      	movs	r2, #5

                // Force AUTH data to zero
                memset(&(p_res->comp_data[M_PROV_COMP_AUTH_VALUE_OFFSET]), 0, M_OOB_AUTH_DATA_LEN);
    f3be:	0020      	movs	r0, r4

            // No OOB data expected
            if(p_res->auth_method == M_PROV_AUTH_NO_OOB)
            {
                // mark that authentication data has been received
                SETB(p_res->comp_inputs, M_PROV_COMP_AUTH_DATA, true);
    f3c0:	4315      	orrs	r5, r2
    f3c2:	7035      	strb	r5, [r6, #0]

                // Force AUTH data to zero
                memset(&(p_res->comp_data[M_PROV_COMP_AUTH_VALUE_OFFSET]), 0, M_OOB_AUTH_DATA_LEN);
    f3c4:	320b      	adds	r2, #11
    f3c6:	0019      	movs	r1, r3
    f3c8:	308a      	adds	r0, #138	; 0x8a
    f3ca:	f006 fb3f 	bl	15a4c <memset>
    f3ce:	e00d      	b.n	f3ec <m_prov_cfm_salt_finished_cb+0x148>
            }
            else
            {
                // Request Application to provide AUTH Data
                if(p_m_api_cb && p_m_api_cb->cb_prov_auth_req)
    f3d0:	4a12      	ldr	r2, [pc, #72]	; (f41c <m_prov_cfm_salt_finished_cb+0x178>)
    f3d2:	6812      	ldr	r2, [r2, #0]
    f3d4:	2a00      	cmp	r2, #0
    f3d6:	d009      	beq.n	f3ec <m_prov_cfm_salt_finished_cb+0x148>
    f3d8:	6915      	ldr	r5, [r2, #16]
    f3da:	2d00      	cmp	r5, #0
    f3dc:	d006      	beq.n	f3ec <m_prov_cfm_salt_finished_cb+0x148>
                	p_m_api_cb->cb_prov_auth_req(p_res->auth_method, p_res->auth_action, p_res->auth_size);
    f3de:	0022      	movs	r2, r4
    f3e0:	3456      	adds	r4, #86	; 0x56
    f3e2:	3257      	adds	r2, #87	; 0x57
    f3e4:	7812      	ldrb	r2, [r2, #0]
    f3e6:	7821      	ldrb	r1, [r4, #0]
    f3e8:	0018      	movs	r0, r3
    f3ea:	47a8      	blx	r5
        {
            // Handle error
            m_prov_error_handle(status);
        }
    }
}
    f3ec:	b005      	add	sp, #20
    f3ee:	bdf0      	pop	{r4, r5, r6, r7, pc}
    f3f0:	100128a4 	.word	0x100128a4
    f3f4:	10010514 	.word	0x10010514
    f3f8:	00021fc8 	.word	0x00021fc8
    f3fc:	00021dc8 	.word	0x00021dc8
    f400:	00021d48 	.word	0x00021d48
    f404:	00000409 	.word	0x00000409
    f408:	0000040b 	.word	0x0000040b
    f40c:	00021ec8 	.word	0x00021ec8
    f410:	00000781 	.word	0x00000781
    f414:	00000427 	.word	0x00000427
    f418:	0000f5c1 	.word	0x0000f5c1
    f41c:	10012698 	.word	0x10012698

0000f420 <m_prov_psalt_finished_cb>:
 *                      (@note equals NULL for AES-CCM encrypt and decrypt functions)
 ****************************************************************************************
 */
__STATIC void m_prov_psalt_finished_cb(uint8_t token_id, uint16_t status, const uint8_t* p_key)
{
    m_prov_res_t* p_res = p_m_prov_env->p_res;
    f420:	4b24      	ldr	r3, [pc, #144]	; (f4b4 <m_prov_psalt_finished_cb+0x94>)
 *                      (@note length is variable and depends on security function used)
 *                      (@note equals NULL for AES-CCM encrypt and decrypt functions)
 ****************************************************************************************
 */
__STATIC void m_prov_psalt_finished_cb(uint8_t token_id, uint16_t status, const uint8_t* p_key)
{
    f422:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    m_prov_res_t* p_res = p_m_prov_env->p_res;
    f424:	681b      	ldr	r3, [r3, #0]
 *                      (@note length is variable and depends on security function used)
 *                      (@note equals NULL for AES-CCM encrypt and decrypt functions)
 ****************************************************************************************
 */
__STATIC void m_prov_psalt_finished_cb(uint8_t token_id, uint16_t status, const uint8_t* p_key)
{
    f426:	000c      	movs	r4, r1
    m_prov_res_t* p_res = p_m_prov_env->p_res;
    f428:	685d      	ldr	r5, [r3, #4]
	M_PRINTF(L_PROV, "status = %d state = %d", status, p_res->state);
    f42a:	4b23      	ldr	r3, [pc, #140]	; (f4b8 <m_prov_psalt_finished_cb+0x98>)
 *                      (@note length is variable and depends on security function used)
 *                      (@note equals NULL for AES-CCM encrypt and decrypt functions)
 ****************************************************************************************
 */
__STATIC void m_prov_psalt_finished_cb(uint8_t token_id, uint16_t status, const uint8_t* p_key)
{
    f42c:	0017      	movs	r7, r2
    m_prov_res_t* p_res = p_m_prov_env->p_res;
	M_PRINTF(L_PROV, "status = %d state = %d", status, p_res->state);
    f42e:	681b      	ldr	r3, [r3, #0]
    f430:	071b      	lsls	r3, r3, #28
    f432:	d519      	bpl.n	f468 <m_prov_psalt_finished_cb+0x48>
    f434:	4e21      	ldr	r6, [pc, #132]	; (f4bc <m_prov_psalt_finished_cb+0x9c>)
    f436:	4b22      	ldr	r3, [pc, #136]	; (f4c0 <m_prov_psalt_finished_cb+0xa0>)
    f438:	0032      	movs	r2, r6
    f43a:	0030      	movs	r0, r6
    f43c:	3375      	adds	r3, #117	; 0x75
    f43e:	3255      	adds	r2, #85	; 0x55
    f440:	9300      	str	r3, [sp, #0]
    f442:	4920      	ldr	r1, [pc, #128]	; (f4c4 <m_prov_psalt_finished_cb+0xa4>)
    f444:	4b20      	ldr	r3, [pc, #128]	; (f4c8 <m_prov_psalt_finished_cb+0xa8>)
    f446:	305e      	adds	r0, #94	; 0x5e
    f448:	f7f5 fab0 	bl	49ac <m_print>
    f44c:	002b      	movs	r3, r5
    f44e:	481f      	ldr	r0, [pc, #124]	; (f4cc <m_prov_psalt_finished_cb+0xac>)
    f450:	3358      	adds	r3, #88	; 0x58
    f452:	781a      	ldrb	r2, [r3, #0]
    f454:	0021      	movs	r1, r4
    f456:	300e      	adds	r0, #14
    f458:	f7f5 faa8 	bl	49ac <m_print>
    f45c:	0030      	movs	r0, r6
    f45e:	4b19      	ldr	r3, [pc, #100]	; (f4c4 <m_prov_psalt_finished_cb+0xa4>)
    f460:	307f      	adds	r0, #127	; 0x7f
    f462:	1d99      	adds	r1, r3, #6
    f464:	f7f5 faa2 	bl	49ac <m_print>
	m_printf_hex(L_PROV, "prov psalt finished", p_key, M_KEY_LEN);
    f468:	4918      	ldr	r1, [pc, #96]	; (f4cc <m_prov_psalt_finished_cb+0xac>)
    f46a:	2310      	movs	r3, #16
    f46c:	003a      	movs	r2, r7
    f46e:	3125      	adds	r1, #37	; 0x25
    f470:	2008      	movs	r0, #8
    f472:	f7f5 fafb 	bl	4a6c <m_printf_hex>
    if(p_res != NULL)
    f476:	2d00      	cmp	r5, #0
    f478:	d01b      	beq.n	f4b2 <m_prov_psalt_finished_cb+0x92>
    {
        if(status == M_ERR_NO_ERROR)
    f47a:	2c00      	cmp	r4, #0
    f47c:	d113      	bne.n	f4a6 <m_prov_psalt_finished_cb+0x86>
        {
            switch(p_res->state)
    f47e:	002c      	movs	r4, r5
    f480:	3458      	adds	r4, #88	; 0x58
    f482:	7823      	ldrb	r3, [r4, #0]
    f484:	2b0c      	cmp	r3, #12
    f486:	d112      	bne.n	f4ae <m_prov_psalt_finished_cb+0x8e>
            {
                case M_PROV_DSTATE_WAIT_PROV_SALT_COMP:
                {
                    memcpy(&(p_res->comp_data[M_PROV_COMP_PROV_SALT_OFFSET]), p_key, M_KEY_LEN);
    f488:	0028      	movs	r0, r5
    f48a:	2210      	movs	r2, #16
    f48c:	0039      	movs	r1, r7
    f48e:	309a      	adds	r0, #154	; 0x9a
    f490:	f006 fa9e 	bl	159d0 <memcpy>
                    p_res->state = M_PROV_DSTATE_WAIT_DEVICE_KEY_COMP;
    f494:	230d      	movs	r3, #13

					status = m_tb_sec_k1_start(M_TB_SEC_TOKEN_PROVISIONING, m_prov_k1_ready_cb, m_prov_k1_finished_cb);
    f496:	4a0e      	ldr	r2, [pc, #56]	; (f4d0 <m_prov_psalt_finished_cb+0xb0>)
            switch(p_res->state)
            {
                case M_PROV_DSTATE_WAIT_PROV_SALT_COMP:
                {
                    memcpy(&(p_res->comp_data[M_PROV_COMP_PROV_SALT_OFFSET]), p_key, M_KEY_LEN);
                    p_res->state = M_PROV_DSTATE_WAIT_DEVICE_KEY_COMP;
    f498:	7023      	strb	r3, [r4, #0]

					status = m_tb_sec_k1_start(M_TB_SEC_TOKEN_PROVISIONING, m_prov_k1_ready_cb, m_prov_k1_finished_cb);
    f49a:	490e      	ldr	r1, [pc, #56]	; (f4d4 <m_prov_psalt_finished_cb+0xb4>)
    f49c:	2005      	movs	r0, #5
    f49e:	f004 fd8e 	bl	13fbe <m_tb_sec_k1_start>
    f4a2:	1e04      	subs	r4, r0, #0
                // unexpected state of the  provisioning algorithm
                default: { status = M_ERR_PROV_UNEXPECTED; } break;
            }
        }

        if(status != M_ERR_NO_ERROR)
    f4a4:	d005      	beq.n	f4b2 <m_prov_psalt_finished_cb+0x92>
        {
            // Handle error
            m_prov_error_handle(status);
    f4a6:	0020      	movs	r0, r4
    f4a8:	f000 fc60 	bl	fd6c <m_prov_error_handle>
        }
    }
}
    f4ac:	e001      	b.n	f4b2 <m_prov_psalt_finished_cb+0x92>

					status = m_tb_sec_k1_start(M_TB_SEC_TOKEN_PROVISIONING, m_prov_k1_ready_cb, m_prov_k1_finished_cb);
                } break;

                // unexpected state of the  provisioning algorithm
                default: { status = M_ERR_PROV_UNEXPECTED; } break;
    f4ae:	4c0a      	ldr	r4, [pc, #40]	; (f4d8 <m_prov_psalt_finished_cb+0xb8>)
    f4b0:	e7f9      	b.n	f4a6 <m_prov_psalt_finished_cb+0x86>
        {
            // Handle error
            m_prov_error_handle(status);
        }
    }
}
    f4b2:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
    f4b4:	100128a4 	.word	0x100128a4
    f4b8:	10010514 	.word	0x10010514
    f4bc:	00021dc8 	.word	0x00021dc8
    f4c0:	00021fc8 	.word	0x00021fc8
    f4c4:	00021d48 	.word	0x00021d48
    f4c8:	00000457 	.word	0x00000457
    f4cc:	00022048 	.word	0x00022048
    f4d0:	0000f841 	.word	0x0000f841
    f4d4:	0000f751 	.word	0x0000f751
    f4d8:	00000781 	.word	0x00000781

0000f4dc <m_prov_pub_key_res_cb>:
 ****************************************************************************************
 */
__STATIC void m_prov_pub_key_res_cb(uint16_t status, const uint8_t* p_pub_key_x, const uint8_t* p_pub_key_y)
{
	
    m_prov_res_t* p_res = p_m_prov_env->p_res;
    f4dc:	4b31      	ldr	r3, [pc, #196]	; (f5a4 <m_prov_pub_key_res_cb+0xc8>)
 * @param[in] p_pub_key_x    32 bytes (LSB) X coordinate of public key
 * @param[in] p_pub_key_y    32 bytes (LSB) Y coordinate of public key
 ****************************************************************************************
 */
__STATIC void m_prov_pub_key_res_cb(uint16_t status, const uint8_t* p_pub_key_x, const uint8_t* p_pub_key_y)
{
    f4de:	b5f0      	push	{r4, r5, r6, r7, lr}
	
    m_prov_res_t* p_res = p_m_prov_env->p_res;
    f4e0:	681b      	ldr	r3, [r3, #0]
 * @param[in] p_pub_key_x    32 bytes (LSB) X coordinate of public key
 * @param[in] p_pub_key_y    32 bytes (LSB) Y coordinate of public key
 ****************************************************************************************
 */
__STATIC void m_prov_pub_key_res_cb(uint16_t status, const uint8_t* p_pub_key_x, const uint8_t* p_pub_key_y)
{
    f4e2:	b085      	sub	sp, #20
	
    m_prov_res_t* p_res = p_m_prov_env->p_res;
    f4e4:	685c      	ldr	r4, [r3, #4]
	M_PRINTF(L_PROV, "status = %d, state = %d", status, p_res->state);
    f4e6:	4b30      	ldr	r3, [pc, #192]	; (f5a8 <m_prov_pub_key_res_cb+0xcc>)
 * @param[in] p_pub_key_x    32 bytes (LSB) X coordinate of public key
 * @param[in] p_pub_key_y    32 bytes (LSB) Y coordinate of public key
 ****************************************************************************************
 */
__STATIC void m_prov_pub_key_res_cb(uint16_t status, const uint8_t* p_pub_key_x, const uint8_t* p_pub_key_y)
{
    f4e8:	9003      	str	r0, [sp, #12]
	
    m_prov_res_t* p_res = p_m_prov_env->p_res;
	M_PRINTF(L_PROV, "status = %d, state = %d", status, p_res->state);
    f4ea:	681b      	ldr	r3, [r3, #0]
 * @param[in] p_pub_key_x    32 bytes (LSB) X coordinate of public key
 * @param[in] p_pub_key_y    32 bytes (LSB) Y coordinate of public key
 ****************************************************************************************
 */
__STATIC void m_prov_pub_key_res_cb(uint16_t status, const uint8_t* p_pub_key_x, const uint8_t* p_pub_key_y)
{
    f4ec:	000f      	movs	r7, r1
    f4ee:	0016      	movs	r6, r2
	
    m_prov_res_t* p_res = p_m_prov_env->p_res;
	M_PRINTF(L_PROV, "status = %d, state = %d", status, p_res->state);
    f4f0:	071b      	lsls	r3, r3, #28
    f4f2:	d519      	bpl.n	f528 <m_prov_pub_key_res_cb+0x4c>
    f4f4:	4d2d      	ldr	r5, [pc, #180]	; (f5ac <m_prov_pub_key_res_cb+0xd0>)
    f4f6:	4b2e      	ldr	r3, [pc, #184]	; (f5b0 <m_prov_pub_key_res_cb+0xd4>)
    f4f8:	002a      	movs	r2, r5
    f4fa:	0028      	movs	r0, r5
    f4fc:	3339      	adds	r3, #57	; 0x39
    f4fe:	3255      	adds	r2, #85	; 0x55
    f500:	9300      	str	r3, [sp, #0]
    f502:	492c      	ldr	r1, [pc, #176]	; (f5b4 <m_prov_pub_key_res_cb+0xd8>)
    f504:	4b2c      	ldr	r3, [pc, #176]	; (f5b8 <m_prov_pub_key_res_cb+0xdc>)
    f506:	305e      	adds	r0, #94	; 0x5e
    f508:	f7f5 fa50 	bl	49ac <m_print>
    f50c:	0023      	movs	r3, r4
    f50e:	4828      	ldr	r0, [pc, #160]	; (f5b0 <m_prov_pub_key_res_cb+0xd4>)
    f510:	3358      	adds	r3, #88	; 0x58
    f512:	781a      	ldrb	r2, [r3, #0]
    f514:	9903      	ldr	r1, [sp, #12]
    f516:	304f      	adds	r0, #79	; 0x4f
    f518:	f7f5 fa48 	bl	49ac <m_print>
    f51c:	0028      	movs	r0, r5
    f51e:	4b25      	ldr	r3, [pc, #148]	; (f5b4 <m_prov_pub_key_res_cb+0xd8>)
    f520:	307f      	adds	r0, #127	; 0x7f
    f522:	1d99      	adds	r1, r3, #6
    f524:	f7f5 fa42 	bl	49ac <m_print>
	m_printf_hex(L_PROV, "prov pub ley res x", p_pub_key_x, M_PUB_KEY_X_LEN);
    f528:	4d21      	ldr	r5, [pc, #132]	; (f5b0 <m_prov_pub_key_res_cb+0xd4>)
    f52a:	2320      	movs	r3, #32
    f52c:	0029      	movs	r1, r5
    f52e:	003a      	movs	r2, r7
    f530:	3167      	adds	r1, #103	; 0x67
    f532:	2008      	movs	r0, #8
    f534:	f7f5 fa9a 	bl	4a6c <m_printf_hex>
	m_printf_hex(L_PROV, "prov pub ley res y", p_pub_key_y, M_PUB_KEY_X_LEN);
    f538:	0029      	movs	r1, r5
    f53a:	2320      	movs	r3, #32
    f53c:	317a      	adds	r1, #122	; 0x7a
    f53e:	0032      	movs	r2, r6
    f540:	2008      	movs	r0, #8
    f542:	f7f5 fa93 	bl	4a6c <m_printf_hex>

    if(p_res != NULL)
    f546:	2c00      	cmp	r4, #0
    f548:	d02a      	beq.n	f5a0 <m_prov_pub_key_res_cb+0xc4>
    {
        if(status != M_ERR_NO_ERROR)
    f54a:	9b03      	ldr	r3, [sp, #12]
    f54c:	2b00      	cmp	r3, #0
    f54e:	d00a      	beq.n	f566 <m_prov_pub_key_res_cb+0x8a>
        {
            // handle error, stop provisioning
            m_prov_error_handle(M_ERR_ECDH_FAILED);
    f550:	481a      	ldr	r0, [pc, #104]	; (f5bc <m_prov_pub_key_res_cb+0xe0>)
    f552:	f000 fc0b 	bl	fd6c <m_prov_error_handle>
            m_al_free(p_res);
    f556:	0020      	movs	r0, r4
    f558:	f7f6 f840 	bl	55dc <m_al_free>
            p_m_prov_env->p_res = NULL;
    f55c:	2200      	movs	r2, #0
    f55e:	4b11      	ldr	r3, [pc, #68]	; (f5a4 <m_prov_pub_key_res_cb+0xc8>)
    f560:	681b      	ldr	r3, [r3, #0]
    f562:	605a      	str	r2, [r3, #4]
    f564:	e7fe      	b.n	f564 <m_prov_pub_key_res_cb+0x88>

            // Shall be considered as a critical error
            ASSERT_ERR(0);
        }
        // Device
        else if(p_res->state == M_PROV_DSTATE_IDLE)
    f566:	0023      	movs	r3, r4
    f568:	3358      	adds	r3, #88	; 0x58
    f56a:	781d      	ldrb	r5, [r3, #0]
    f56c:	2d01      	cmp	r5, #1
    f56e:	d117      	bne.n	f5a0 <m_prov_pub_key_res_cb+0xc4>
        {
            // Copy local public key
            memcpy(&(p_res->comp_data[M_PROV_CFM_INPUTS_DEV_PUB_KEY_X_OFFSET]), p_pub_key_x, M_PUB_KEY_X_LEN);
    f570:	0020      	movs	r0, r4
    f572:	2220      	movs	r2, #32
    f574:	0039      	movs	r1, r7
    f576:	307a      	adds	r0, #122	; 0x7a
    f578:	f006 fa2a 	bl	159d0 <memcpy>
            memcpy(&(p_res->comp_data[M_PROV_CFM_INPUTS_DEV_PUB_KEY_Y_OFFSET]), p_pub_key_y, M_PUB_KEY_Y_LEN);
    f57c:	0020      	movs	r0, r4
    f57e:	2220      	movs	r2, #32
    f580:	0031      	movs	r1, r6
    f582:	305a      	adds	r0, #90	; 0x5a
    f584:	f006 fa24 	bl	159d0 <memcpy>

            // Start transmission of unprovisioned device beacons
            m_bcn_start_tx_unprov_bcn(&p_res->prov_param.dev_uuid[0], p_res->prov_param.oob_info,
                                      p_res->prov_param.uri_hash,
                                      (p_res->prov_param.info & M_PROV_INFO_URI_HASH_PRESENT) != 0);
    f588:	0023      	movs	r3, r4
            // Copy local public key
            memcpy(&(p_res->comp_data[M_PROV_CFM_INPUTS_DEV_PUB_KEY_X_OFFSET]), p_pub_key_x, M_PUB_KEY_X_LEN);
            memcpy(&(p_res->comp_data[M_PROV_CFM_INPUTS_DEV_PUB_KEY_Y_OFFSET]), p_pub_key_y, M_PUB_KEY_Y_LEN);

            // Start transmission of unprovisioned device beacons
            m_bcn_start_tx_unprov_bcn(&p_res->prov_param.dev_uuid[0], p_res->prov_param.oob_info,
    f58a:	0022      	movs	r2, r4
    f58c:	0020      	movs	r0, r4
                                      p_res->prov_param.uri_hash,
                                      (p_res->prov_param.info & M_PROV_INFO_URI_HASH_PRESENT) != 0);
    f58e:	3353      	adds	r3, #83	; 0x53
            // Copy local public key
            memcpy(&(p_res->comp_data[M_PROV_CFM_INPUTS_DEV_PUB_KEY_X_OFFSET]), p_pub_key_x, M_PUB_KEY_X_LEN);
            memcpy(&(p_res->comp_data[M_PROV_CFM_INPUTS_DEV_PUB_KEY_Y_OFFSET]), p_pub_key_y, M_PUB_KEY_Y_LEN);

            // Start transmission of unprovisioned device beacons
            m_bcn_start_tx_unprov_bcn(&p_res->prov_param.dev_uuid[0], p_res->prov_param.oob_info,
    f590:	781b      	ldrb	r3, [r3, #0]
    f592:	3248      	adds	r2, #72	; 0x48
    f594:	8811      	ldrh	r1, [r2, #0]
    f596:	402b      	ands	r3, r5
    f598:	3034      	adds	r0, #52	; 0x34
    f59a:	6c62      	ldr	r2, [r4, #68]	; 0x44
    f59c:	f7fa fa16 	bl	99cc <m_bcn_start_tx_unprov_bcn>
                m_prov_bearer_scan_start();
            }
            #endif // (BLE_MESH_GATT_PROV)
        }
    }
}
    f5a0:	b005      	add	sp, #20
    f5a2:	bdf0      	pop	{r4, r5, r6, r7, pc}
    f5a4:	100128a4 	.word	0x100128a4
    f5a8:	10010514 	.word	0x10010514
    f5ac:	00021dc8 	.word	0x00021dc8
    f5b0:	00022048 	.word	0x00022048
    f5b4:	00021d48 	.word	0x00021d48
    f5b8:	00000482 	.word	0x00000482
    f5bc:	00000b82 	.word	0x00000b82

0000f5c0 <m_prov_ecdh_secret_res_cb>:
 * @param[in] p_ecdh_secret  32 bytes (LSB) ECDH Secret value
 ****************************************************************************************
 */
__STATIC void m_prov_ecdh_secret_res_cb(uint16_t status, const uint8_t* p_ecdh_secret)
{
    m_prov_res_t* p_res = p_m_prov_env->p_res;
    f5c0:	4b28      	ldr	r3, [pc, #160]	; (f664 <m_prov_ecdh_secret_res_cb+0xa4>)
 * @param[in] status         Status of the ECDH Secret computation
 * @param[in] p_ecdh_secret  32 bytes (LSB) ECDH Secret value
 ****************************************************************************************
 */
__STATIC void m_prov_ecdh_secret_res_cb(uint16_t status, const uint8_t* p_ecdh_secret)
{
    f5c2:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    m_prov_res_t* p_res = p_m_prov_env->p_res;
    f5c4:	681b      	ldr	r3, [r3, #0]
 * @param[in] status         Status of the ECDH Secret computation
 * @param[in] p_ecdh_secret  32 bytes (LSB) ECDH Secret value
 ****************************************************************************************
 */
__STATIC void m_prov_ecdh_secret_res_cb(uint16_t status, const uint8_t* p_ecdh_secret)
{
    f5c6:	0005      	movs	r5, r0
    m_prov_res_t* p_res = p_m_prov_env->p_res;
    f5c8:	685c      	ldr	r4, [r3, #4]
	M_PRINTF(L_PROV, "status = %d state = %d", status, p_res->state);
    f5ca:	4b27      	ldr	r3, [pc, #156]	; (f668 <m_prov_ecdh_secret_res_cb+0xa8>)
 * @param[in] status         Status of the ECDH Secret computation
 * @param[in] p_ecdh_secret  32 bytes (LSB) ECDH Secret value
 ****************************************************************************************
 */
__STATIC void m_prov_ecdh_secret_res_cb(uint16_t status, const uint8_t* p_ecdh_secret)
{
    f5cc:	000f      	movs	r7, r1
    m_prov_res_t* p_res = p_m_prov_env->p_res;
	M_PRINTF(L_PROV, "status = %d state = %d", status, p_res->state);
    f5ce:	681b      	ldr	r3, [r3, #0]
    f5d0:	071b      	lsls	r3, r3, #28
    f5d2:	d519      	bpl.n	f608 <m_prov_ecdh_secret_res_cb+0x48>
    f5d4:	4e25      	ldr	r6, [pc, #148]	; (f66c <m_prov_ecdh_secret_res_cb+0xac>)
    f5d6:	4b26      	ldr	r3, [pc, #152]	; (f670 <m_prov_ecdh_secret_res_cb+0xb0>)
    f5d8:	0032      	movs	r2, r6
    f5da:	0030      	movs	r0, r6
    f5dc:	330d      	adds	r3, #13
    f5de:	3255      	adds	r2, #85	; 0x55
    f5e0:	9300      	str	r3, [sp, #0]
    f5e2:	4924      	ldr	r1, [pc, #144]	; (f674 <m_prov_ecdh_secret_res_cb+0xb4>)
    f5e4:	4b24      	ldr	r3, [pc, #144]	; (f678 <m_prov_ecdh_secret_res_cb+0xb8>)
    f5e6:	305e      	adds	r0, #94	; 0x5e
    f5e8:	f7f5 f9e0 	bl	49ac <m_print>
    f5ec:	0023      	movs	r3, r4
    f5ee:	4823      	ldr	r0, [pc, #140]	; (f67c <m_prov_ecdh_secret_res_cb+0xbc>)
    f5f0:	3358      	adds	r3, #88	; 0x58
    f5f2:	781a      	ldrb	r2, [r3, #0]
    f5f4:	0029      	movs	r1, r5
    f5f6:	300e      	adds	r0, #14
    f5f8:	f7f5 f9d8 	bl	49ac <m_print>
    f5fc:	0030      	movs	r0, r6
    f5fe:	4b1d      	ldr	r3, [pc, #116]	; (f674 <m_prov_ecdh_secret_res_cb+0xb4>)
    f600:	307f      	adds	r0, #127	; 0x7f
    f602:	1d99      	adds	r1, r3, #6
    f604:	f7f5 f9d2 	bl	49ac <m_print>
	m_printf_hex(L_PROV, "prov ecdh secret res x", p_ecdh_secret, 32);
    f608:	4919      	ldr	r1, [pc, #100]	; (f670 <m_prov_ecdh_secret_res_cb+0xb0>)
    f60a:	2320      	movs	r3, #32
    f60c:	003a      	movs	r2, r7
    f60e:	3127      	adds	r1, #39	; 0x27
    f610:	2008      	movs	r0, #8
    f612:	f7f5 fa2b 	bl	4a6c <m_printf_hex>
    if(p_res != NULL)
    f616:	2c00      	cmp	r4, #0
    f618:	d023      	beq.n	f662 <m_prov_ecdh_secret_res_cb+0xa2>
    {
        // State sanity check
        switch(p_res->state)
    f61a:	0023      	movs	r3, r4
    f61c:	3358      	adds	r3, #88	; 0x58
    f61e:	781e      	ldrb	r6, [r3, #0]
    f620:	1f73      	subs	r3, r6, #5
    f622:	2b02      	cmp	r3, #2
    f624:	d81b      	bhi.n	f65e <m_prov_ecdh_secret_res_cb+0x9e>
        {
            case M_PROV_DSTATE_WAIT_AUTH_INPUT:
            case M_PROV_DSTATE_WAIT_CFM:
            case M_PROV_DSTATE_WAIT_RND_COMP:
            {
                if(status == M_ERR_NO_ERROR)
    f626:	2d00      	cmp	r5, #0
    f628:	d115      	bne.n	f656 <m_prov_ecdh_secret_res_cb+0x96>
                {
                    // Mark that ECDH Secret has been computed - copy it
                    SETB(p_res->comp_inputs, M_PROV_COMP_ECDH_SECRET, true);
    f62a:	0022      	movs	r2, r4
    f62c:	2302      	movs	r3, #2
                    memcpy(&(p_res->comp_data[M_PROV_COMP_ECDH_SECRET_OFFSET]), p_ecdh_secret, M_ECDH_SECRET_LEN);
    f62e:	0020      	movs	r0, r4
            case M_PROV_DSTATE_WAIT_RND_COMP:
            {
                if(status == M_ERR_NO_ERROR)
                {
                    // Mark that ECDH Secret has been computed - copy it
                    SETB(p_res->comp_inputs, M_PROV_COMP_ECDH_SECRET, true);
    f630:	3259      	adds	r2, #89	; 0x59
    f632:	7815      	ldrb	r5, [r2, #0]
                    memcpy(&(p_res->comp_data[M_PROV_COMP_ECDH_SECRET_OFFSET]), p_ecdh_secret, M_ECDH_SECRET_LEN);
    f634:	30aa      	adds	r0, #170	; 0xaa
            case M_PROV_DSTATE_WAIT_RND_COMP:
            {
                if(status == M_ERR_NO_ERROR)
                {
                    // Mark that ECDH Secret has been computed - copy it
                    SETB(p_res->comp_inputs, M_PROV_COMP_ECDH_SECRET, true);
    f636:	432b      	orrs	r3, r5
    f638:	7013      	strb	r3, [r2, #0]
                    memcpy(&(p_res->comp_data[M_PROV_COMP_ECDH_SECRET_OFFSET]), p_ecdh_secret, M_ECDH_SECRET_LEN);
    f63a:	0039      	movs	r1, r7
    f63c:	2220      	movs	r2, #32
    f63e:	f006 f9c7 	bl	159d0 <memcpy>

                    // check if authentication data has been received
                    if(GETB(p_res->comp_inputs, M_PROV_COMP_AUTH_DATA))
    f642:	07eb      	lsls	r3, r5, #31
    f644:	d50d      	bpl.n	f662 <m_prov_ecdh_secret_res_cb+0xa2>
                    {
                        // Check current state - does provisioner should compute random number
                        if (p_res->state == M_PROV_DSTATE_WAIT_RND_COMP)
    f646:	2e07      	cmp	r6, #7
    f648:	d10b      	bne.n	f662 <m_prov_ecdh_secret_res_cb+0xa2>
                        {
                            status = m_tb_sec_rand_start(M_TB_SEC_TOKEN_PROVISIONING, m_prov_rand_finished_cb);
    f64a:	490d      	ldr	r1, [pc, #52]	; (f680 <m_prov_ecdh_secret_res_cb+0xc0>)
    f64c:	2005      	movs	r0, #5
    f64e:	f004 fcd2 	bl	13ff6 <m_tb_sec_rand_start>
    f652:	1e05      	subs	r5, r0, #0

            // unexpected state of the  provisioning algorithm
            default: { status = M_ERR_PROV_UNEXPECTED; } break;
        }

        if(status != M_ERR_NO_ERROR)
    f654:	d005      	beq.n	f662 <m_prov_ecdh_secret_res_cb+0xa2>
        {
            // Handle error
            m_prov_error_handle(status);
    f656:	0028      	movs	r0, r5
    f658:	f000 fb88 	bl	fd6c <m_prov_error_handle>
        }
    }
}
    f65c:	e001      	b.n	f662 <m_prov_ecdh_secret_res_cb+0xa2>
                    }
                }
            } break;

            // unexpected state of the  provisioning algorithm
            default: { status = M_ERR_PROV_UNEXPECTED; } break;
    f65e:	4d09      	ldr	r5, [pc, #36]	; (f684 <m_prov_ecdh_secret_res_cb+0xc4>)
    f660:	e7f9      	b.n	f656 <m_prov_ecdh_secret_res_cb+0x96>
        {
            // Handle error
            m_prov_error_handle(status);
        }
    }
}
    f662:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
    f664:	100128a4 	.word	0x100128a4
    f668:	10010514 	.word	0x10010514
    f66c:	00021dc8 	.word	0x00021dc8
    f670:	000220c8 	.word	0x000220c8
    f674:	00021d48 	.word	0x00021d48
    f678:	000004b7 	.word	0x000004b7
    f67c:	00022048 	.word	0x00022048
    f680:	0000f689 	.word	0x0000f689
    f684:	00000781 	.word	0x00000781

0000f688 <m_prov_rand_finished_cb>:
 *                      (@note equals NULL for AES-CCM encrypt and decrypt functions)
 ****************************************************************************************
 */
__STATIC void m_prov_rand_finished_cb(uint8_t token_id, uint16_t status, const uint8_t* p_rand)
{
    m_prov_res_t* p_res = p_m_prov_env->p_res;
    f688:	4b27      	ldr	r3, [pc, #156]	; (f728 <m_prov_rand_finished_cb+0xa0>)
 *                      (@note length is variable and depends on security function used)
 *                      (@note equals NULL for AES-CCM encrypt and decrypt functions)
 ****************************************************************************************
 */
__STATIC void m_prov_rand_finished_cb(uint8_t token_id, uint16_t status, const uint8_t* p_rand)
{
    f68a:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    m_prov_res_t* p_res = p_m_prov_env->p_res;
    f68c:	681b      	ldr	r3, [r3, #0]
 *                      (@note length is variable and depends on security function used)
 *                      (@note equals NULL for AES-CCM encrypt and decrypt functions)
 ****************************************************************************************
 */
__STATIC void m_prov_rand_finished_cb(uint8_t token_id, uint16_t status, const uint8_t* p_rand)
{
    f68e:	000d      	movs	r5, r1
    m_prov_res_t* p_res = p_m_prov_env->p_res;
    f690:	685c      	ldr	r4, [r3, #4]
	M_PRINTF(L_PROV, "status = %d state = %d", status, p_res->state);
    f692:	4b26      	ldr	r3, [pc, #152]	; (f72c <m_prov_rand_finished_cb+0xa4>)
 *                      (@note length is variable and depends on security function used)
 *                      (@note equals NULL for AES-CCM encrypt and decrypt functions)
 ****************************************************************************************
 */
__STATIC void m_prov_rand_finished_cb(uint8_t token_id, uint16_t status, const uint8_t* p_rand)
{
    f694:	0017      	movs	r7, r2
    m_prov_res_t* p_res = p_m_prov_env->p_res;
	M_PRINTF(L_PROV, "status = %d state = %d", status, p_res->state);
    f696:	681b      	ldr	r3, [r3, #0]
    f698:	071b      	lsls	r3, r3, #28
    f69a:	d519      	bpl.n	f6d0 <m_prov_rand_finished_cb+0x48>
    f69c:	4e24      	ldr	r6, [pc, #144]	; (f730 <m_prov_rand_finished_cb+0xa8>)
    f69e:	4b25      	ldr	r3, [pc, #148]	; (f734 <m_prov_rand_finished_cb+0xac>)
    f6a0:	0032      	movs	r2, r6
    f6a2:	0030      	movs	r0, r6
    f6a4:	333e      	adds	r3, #62	; 0x3e
    f6a6:	3255      	adds	r2, #85	; 0x55
    f6a8:	9300      	str	r3, [sp, #0]
    f6aa:	4923      	ldr	r1, [pc, #140]	; (f738 <m_prov_rand_finished_cb+0xb0>)
    f6ac:	4b23      	ldr	r3, [pc, #140]	; (f73c <m_prov_rand_finished_cb+0xb4>)
    f6ae:	305e      	adds	r0, #94	; 0x5e
    f6b0:	f7f5 f97c 	bl	49ac <m_print>
    f6b4:	0023      	movs	r3, r4
    f6b6:	4822      	ldr	r0, [pc, #136]	; (f740 <m_prov_rand_finished_cb+0xb8>)
    f6b8:	3358      	adds	r3, #88	; 0x58
    f6ba:	781a      	ldrb	r2, [r3, #0]
    f6bc:	0029      	movs	r1, r5
    f6be:	300e      	adds	r0, #14
    f6c0:	f7f5 f974 	bl	49ac <m_print>
    f6c4:	0030      	movs	r0, r6
    f6c6:	4b1c      	ldr	r3, [pc, #112]	; (f738 <m_prov_rand_finished_cb+0xb0>)
    f6c8:	307f      	adds	r0, #127	; 0x7f
    f6ca:	1d99      	adds	r1, r3, #6
    f6cc:	f7f5 f96e 	bl	49ac <m_print>
	m_printf_hex(L_PROV, "prov rand finished", p_rand, M_KEY_LEN);
    f6d0:	4918      	ldr	r1, [pc, #96]	; (f734 <m_prov_rand_finished_cb+0xac>)
    f6d2:	2310      	movs	r3, #16
    f6d4:	003a      	movs	r2, r7
    f6d6:	3156      	adds	r1, #86	; 0x56
    f6d8:	2008      	movs	r0, #8
    f6da:	f7f5 f9c7 	bl	4a6c <m_printf_hex>
    if(p_res != NULL)
    f6de:	2c00      	cmp	r4, #0
    f6e0:	d021      	beq.n	f726 <m_prov_rand_finished_cb+0x9e>
    {
        if(status == M_ERR_NO_ERROR)
    f6e2:	2d00      	cmp	r5, #0
    f6e4:	d119      	bne.n	f71a <m_prov_rand_finished_cb+0x92>
        {
            // Copy local random value
            if(p_res->state == M_PROV_DSTATE_WAIT_RND_COMP)
    f6e6:	0025      	movs	r5, r4
    f6e8:	3558      	adds	r5, #88	; 0x58
    f6ea:	782b      	ldrb	r3, [r5, #0]
    f6ec:	2b07      	cmp	r3, #7
    f6ee:	d118      	bne.n	f722 <m_prov_rand_finished_cb+0x9a>
            {
                memcpy(&(p_res->comp_data[M_PROV_COMP_RANDOM_DEV_OFFSET]), p_rand, M_KEY_LEN);
    f6f0:	0020      	movs	r0, r4
    f6f2:	2210      	movs	r2, #16
    f6f4:	0039      	movs	r1, r7
    f6f6:	305a      	adds	r0, #90	; 0x5a
    f6f8:	f006 f96a 	bl	159d0 <memcpy>
                memcpy(&(p_res->comp_data[M_PROV_COMP_RANDOM_OFFSET]),     p_rand, M_KEY_LEN);
    f6fc:	0020      	movs	r0, r4
    f6fe:	2210      	movs	r2, #16
    f700:	0039      	movs	r1, r7
    f702:	309a      	adds	r0, #154	; 0x9a
    f704:	f006 f964 	bl	159d0 <memcpy>

                // Compute confirmation key
                p_res->state = M_PROV_DSTATE_WAIT_CFM_KEY_COMP;
    f708:	2308      	movs	r3, #8
                status = m_tb_sec_k1_start(M_TB_SEC_TOKEN_PROVISIONING, m_prov_k1_ready_cb, m_prov_k1_finished_cb);
    f70a:	4a0e      	ldr	r2, [pc, #56]	; (f744 <m_prov_rand_finished_cb+0xbc>)
            {
                memcpy(&(p_res->comp_data[M_PROV_COMP_RANDOM_DEV_OFFSET]), p_rand, M_KEY_LEN);
                memcpy(&(p_res->comp_data[M_PROV_COMP_RANDOM_OFFSET]),     p_rand, M_KEY_LEN);

                // Compute confirmation key
                p_res->state = M_PROV_DSTATE_WAIT_CFM_KEY_COMP;
    f70c:	702b      	strb	r3, [r5, #0]
                status = m_tb_sec_k1_start(M_TB_SEC_TOKEN_PROVISIONING, m_prov_k1_ready_cb, m_prov_k1_finished_cb);
    f70e:	490e      	ldr	r1, [pc, #56]	; (f748 <m_prov_rand_finished_cb+0xc0>)
    f710:	2005      	movs	r0, #5
    f712:	f004 fc54 	bl	13fbe <m_tb_sec_k1_start>
    f716:	1e05      	subs	r5, r0, #0
            {
                status = M_ERR_PROV_UNEXPECTED;
            }
        }

        if(status != M_ERR_NO_ERROR)
    f718:	d005      	beq.n	f726 <m_prov_rand_finished_cb+0x9e>
        {
            // Handle error
            m_prov_error_handle(status);
    f71a:	0028      	movs	r0, r5
    f71c:	f000 fb26 	bl	fd6c <m_prov_error_handle>
        }
    }
}
    f720:	e001      	b.n	f726 <m_prov_rand_finished_cb+0x9e>
                p_res->state = M_PROV_DSTATE_WAIT_CFM_KEY_COMP;
                status = m_tb_sec_k1_start(M_TB_SEC_TOKEN_PROVISIONING, m_prov_k1_ready_cb, m_prov_k1_finished_cb);
            }
            else
            {
                status = M_ERR_PROV_UNEXPECTED;
    f722:	4d0a      	ldr	r5, [pc, #40]	; (f74c <m_prov_rand_finished_cb+0xc4>)
    f724:	e7f9      	b.n	f71a <m_prov_rand_finished_cb+0x92>
        {
            // Handle error
            m_prov_error_handle(status);
        }
    }
}
    f726:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
    f728:	100128a4 	.word	0x100128a4
    f72c:	10010514 	.word	0x10010514
    f730:	00021dc8 	.word	0x00021dc8
    f734:	000220c8 	.word	0x000220c8
    f738:	00021d48 	.word	0x00021d48
    f73c:	000004ee 	.word	0x000004ee
    f740:	00022048 	.word	0x00022048
    f744:	0000f841 	.word	0x0000f841
    f748:	0000f751 	.word	0x0000f751
    f74c:	00000781 	.word	0x00000781

0000f750 <m_prov_k1_ready_cb>:
 * @return Status error code (@see enum m_error)
 ****************************************************************************************
 */
__STATIC uint16_t m_prov_k1_ready_cb(uint8_t token_id, const uint8_t** pp_salt, const uint8_t** pp_n, uint8_t* p_n_len,
                                     const uint8_t** pp_p, uint8_t* p_p_len)
{
    f750:	b5f0      	push	{r4, r5, r6, r7, lr}
    uint16_t status = M_ERR_COMMAND_DISALLOWED;
    m_prov_res_t* p_res = p_m_prov_env->p_res;
    f752:	4d33      	ldr	r5, [pc, #204]	; (f820 <m_prov_k1_ready_cb+0xd0>)
 * @return Status error code (@see enum m_error)
 ****************************************************************************************
 */
__STATIC uint16_t m_prov_k1_ready_cb(uint8_t token_id, const uint8_t** pp_salt, const uint8_t** pp_n, uint8_t* p_n_len,
                                     const uint8_t** pp_p, uint8_t* p_p_len)
{
    f754:	b085      	sub	sp, #20
    f756:	9303      	str	r3, [sp, #12]
    uint16_t status = M_ERR_COMMAND_DISALLOWED;
    m_prov_res_t* p_res = p_m_prov_env->p_res;
    f758:	682b      	ldr	r3, [r5, #0]
 * @return Status error code (@see enum m_error)
 ****************************************************************************************
 */
__STATIC uint16_t m_prov_k1_ready_cb(uint8_t token_id, const uint8_t** pp_salt, const uint8_t** pp_n, uint8_t* p_n_len,
                                     const uint8_t** pp_p, uint8_t* p_p_len)
{
    f75a:	000e      	movs	r6, r1
    uint16_t status = M_ERR_COMMAND_DISALLOWED;
    m_prov_res_t* p_res = p_m_prov_env->p_res;
    f75c:	685c      	ldr	r4, [r3, #4]
	M_PRINTF(L_PROV, "p_m_prov_env = %p", p_m_prov_env);
    f75e:	4b31      	ldr	r3, [pc, #196]	; (f824 <m_prov_k1_ready_cb+0xd4>)
 * @return Status error code (@see enum m_error)
 ****************************************************************************************
 */
__STATIC uint16_t m_prov_k1_ready_cb(uint8_t token_id, const uint8_t** pp_salt, const uint8_t** pp_n, uint8_t* p_n_len,
                                     const uint8_t** pp_p, uint8_t* p_p_len)
{
    f760:	0017      	movs	r7, r2
    uint16_t status = M_ERR_COMMAND_DISALLOWED;
    m_prov_res_t* p_res = p_m_prov_env->p_res;
	M_PRINTF(L_PROV, "p_m_prov_env = %p", p_m_prov_env);
    f762:	681b      	ldr	r3, [r3, #0]
    f764:	071b      	lsls	r3, r3, #28
    f766:	d515      	bpl.n	f794 <m_prov_k1_ready_cb+0x44>
    f768:	4b2f      	ldr	r3, [pc, #188]	; (f828 <m_prov_k1_ready_cb+0xd8>)
    f76a:	4a30      	ldr	r2, [pc, #192]	; (f82c <m_prov_k1_ready_cb+0xdc>)
    f76c:	482f      	ldr	r0, [pc, #188]	; (f82c <m_prov_k1_ready_cb+0xdc>)
    f76e:	3369      	adds	r3, #105	; 0x69
    f770:	3255      	adds	r2, #85	; 0x55
    f772:	9300      	str	r3, [sp, #0]
    f774:	492e      	ldr	r1, [pc, #184]	; (f830 <m_prov_k1_ready_cb+0xe0>)
    f776:	4b2f      	ldr	r3, [pc, #188]	; (f834 <m_prov_k1_ready_cb+0xe4>)
    f778:	305e      	adds	r0, #94	; 0x5e
    f77a:	f7f5 f917 	bl	49ac <m_print>
    f77e:	482a      	ldr	r0, [pc, #168]	; (f828 <m_prov_k1_ready_cb+0xd8>)
    f780:	6829      	ldr	r1, [r5, #0]
    f782:	307c      	adds	r0, #124	; 0x7c
    f784:	f7f5 f912 	bl	49ac <m_print>
    f788:	4b29      	ldr	r3, [pc, #164]	; (f830 <m_prov_k1_ready_cb+0xe0>)
    f78a:	4828      	ldr	r0, [pc, #160]	; (f82c <m_prov_k1_ready_cb+0xdc>)
    f78c:	1d99      	adds	r1, r3, #6
    f78e:	307f      	adds	r0, #127	; 0x7f
    f790:	f7f5 f90c 	bl	49ac <m_print>
    if(p_res != NULL)
    f794:	2c00      	cmp	r4, #0
    f796:	d03d      	beq.n	f814 <m_prov_k1_ready_cb+0xc4>
    {
        // check state of provisioning
        switch(p_res->state)
    f798:	0023      	movs	r3, r4
    f79a:	3358      	adds	r3, #88	; 0x58
    f79c:	7818      	ldrb	r0, [r3, #0]
    f79e:	3808      	subs	r0, #8
    f7a0:	2807      	cmp	r0, #7
    f7a2:	d839      	bhi.n	f818 <m_prov_k1_ready_cb+0xc8>
    f7a4:	f00e fad6 	bl	1dd54 <__gnu_thumb1_case_uqi>
    f7a8:	38383804 	.word	0x38383804
    f7ac:	251a0f38 	.word	0x251a0f38
        {
            case M_PROV_DSTATE_WAIT_CFM_KEY_COMP:
            {
                *pp_salt = &(p_res->comp_data[M_PROV_COMP_SALT_OFFSET]);
    f7b0:	0023      	movs	r3, r4
    f7b2:	337a      	adds	r3, #122	; 0x7a
    f7b4:	6033      	str	r3, [r6, #0]
                *pp_n    = &(p_res->comp_data[M_PROV_COMP_ECDH_SECRET_OFFSET]);
                *p_n_len = M_ECDH_SECRET_LEN;
    f7b6:	2320      	movs	r3, #32
    f7b8:	9a03      	ldr	r2, [sp, #12]
        switch(p_res->state)
        {
            case M_PROV_DSTATE_WAIT_CFM_KEY_COMP:
            {
                *pp_salt = &(p_res->comp_data[M_PROV_COMP_SALT_OFFSET]);
                *pp_n    = &(p_res->comp_data[M_PROV_COMP_ECDH_SECRET_OFFSET]);
    f7ba:	34aa      	adds	r4, #170	; 0xaa
    f7bc:	603c      	str	r4, [r7, #0]
                *p_n_len = M_ECDH_SECRET_LEN;
    f7be:	7013      	strb	r3, [r2, #0]
                *pp_p    = m_prov_cfm_key_p_val;
    f7c0:	4b1a      	ldr	r3, [pc, #104]	; (f82c <m_prov_k1_ready_cb+0xdc>)
    f7c2:	332c      	adds	r3, #44	; 0x2c
    f7c4:	e01f      	b.n	f806 <m_prov_k1_ready_cb+0xb6>
                status = M_ERR_NO_ERROR;
            } break;

            case M_PROV_DSTATE_WAIT_DEVICE_KEY_COMP:
            {
                *pp_salt = &(p_res->comp_data[M_PROV_COMP_PROV_SALT_OFFSET]);
    f7c6:	0023      	movs	r3, r4
    f7c8:	339a      	adds	r3, #154	; 0x9a
    f7ca:	6033      	str	r3, [r6, #0]
                *pp_n    = &(p_res->comp_data[M_PROV_COMP_ECDH_SECRET_OFFSET]);
                *p_n_len = M_ECDH_SECRET_LEN;
    f7cc:	2320      	movs	r3, #32
    f7ce:	9a03      	ldr	r2, [sp, #12]
            } break;

            case M_PROV_DSTATE_WAIT_DEVICE_KEY_COMP:
            {
                *pp_salt = &(p_res->comp_data[M_PROV_COMP_PROV_SALT_OFFSET]);
                *pp_n    = &(p_res->comp_data[M_PROV_COMP_ECDH_SECRET_OFFSET]);
    f7d0:	34aa      	adds	r4, #170	; 0xaa
    f7d2:	603c      	str	r4, [r7, #0]
                *p_n_len = M_ECDH_SECRET_LEN;
    f7d4:	7013      	strb	r3, [r2, #0]
                *pp_p    = m_prov_device_key_p_val;
    f7d6:	4b15      	ldr	r3, [pc, #84]	; (f82c <m_prov_k1_ready_cb+0xdc>)
    f7d8:	3338      	adds	r3, #56	; 0x38
    f7da:	e014      	b.n	f806 <m_prov_k1_ready_cb+0xb6>
                status = M_ERR_NO_ERROR;
            } break;

            case M_PROV_DSTATE_WAIT_SESSION_KEY_COMP:
            {
                *pp_salt = &(p_res->comp_data[M_PROV_COMP_PROV_SALT_OFFSET]);
    f7dc:	0023      	movs	r3, r4
    f7de:	339a      	adds	r3, #154	; 0x9a
    f7e0:	6033      	str	r3, [r6, #0]
                *pp_n    = &(p_res->comp_data[M_PROV_COMP_ECDH_SECRET_OFFSET]);
                *p_n_len = M_ECDH_SECRET_LEN;
    f7e2:	2320      	movs	r3, #32
    f7e4:	9a03      	ldr	r2, [sp, #12]
            } break;

            case M_PROV_DSTATE_WAIT_SESSION_KEY_COMP:
            {
                *pp_salt = &(p_res->comp_data[M_PROV_COMP_PROV_SALT_OFFSET]);
                *pp_n    = &(p_res->comp_data[M_PROV_COMP_ECDH_SECRET_OFFSET]);
    f7e6:	34aa      	adds	r4, #170	; 0xaa
    f7e8:	603c      	str	r4, [r7, #0]
                *p_n_len = M_ECDH_SECRET_LEN;
    f7ea:	7013      	strb	r3, [r2, #0]
                *pp_p    = m_prov_session_key_p_val;
    f7ec:	4b0f      	ldr	r3, [pc, #60]	; (f82c <m_prov_k1_ready_cb+0xdc>)
    f7ee:	3330      	adds	r3, #48	; 0x30
    f7f0:	e009      	b.n	f806 <m_prov_k1_ready_cb+0xb6>
                status = M_ERR_NO_ERROR;
            } break;

            case M_PROV_DSTATE_WAIT_SESSION_NONCE_COMP:
            {
                *pp_salt = &(p_res->comp_data[M_PROV_COMP_PROV_SALT_OFFSET]);
    f7f2:	0023      	movs	r3, r4
    f7f4:	339a      	adds	r3, #154	; 0x9a
    f7f6:	6033      	str	r3, [r6, #0]
                *pp_n    = &(p_res->comp_data[M_PROV_COMP_ECDH_SECRET_OFFSET]);
                *p_n_len = M_ECDH_SECRET_LEN;
    f7f8:	2320      	movs	r3, #32
    f7fa:	9a03      	ldr	r2, [sp, #12]
            } break;

            case M_PROV_DSTATE_WAIT_SESSION_NONCE_COMP:
            {
                *pp_salt = &(p_res->comp_data[M_PROV_COMP_PROV_SALT_OFFSET]);
                *pp_n    = &(p_res->comp_data[M_PROV_COMP_ECDH_SECRET_OFFSET]);
    f7fc:	34aa      	adds	r4, #170	; 0xaa
    f7fe:	603c      	str	r4, [r7, #0]
                *p_n_len = M_ECDH_SECRET_LEN;
    f800:	7013      	strb	r3, [r2, #0]
                *pp_p    = m_prov_session_nonce_p_val;
    f802:	4b0a      	ldr	r3, [pc, #40]	; (f82c <m_prov_k1_ready_cb+0xdc>)
    f804:	3334      	adds	r3, #52	; 0x34
    f806:	9a0a      	ldr	r2, [sp, #40]	; 0x28
                *p_p_len = sizeof(m_prov_session_nonce_p_val);

                status = M_ERR_NO_ERROR;
    f808:	2000      	movs	r0, #0
            case M_PROV_DSTATE_WAIT_SESSION_NONCE_COMP:
            {
                *pp_salt = &(p_res->comp_data[M_PROV_COMP_PROV_SALT_OFFSET]);
                *pp_n    = &(p_res->comp_data[M_PROV_COMP_ECDH_SECRET_OFFSET]);
                *p_n_len = M_ECDH_SECRET_LEN;
                *pp_p    = m_prov_session_nonce_p_val;
    f80a:	6013      	str	r3, [r2, #0]
                *p_p_len = sizeof(m_prov_session_nonce_p_val);
    f80c:	2304      	movs	r3, #4
    f80e:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    f810:	7013      	strb	r3, [r2, #0]

                status = M_ERR_NO_ERROR;
            } break;
    f812:	e002      	b.n	f81a <m_prov_k1_ready_cb+0xca>
 ****************************************************************************************
 */
__STATIC uint16_t m_prov_k1_ready_cb(uint8_t token_id, const uint8_t** pp_salt, const uint8_t** pp_n, uint8_t* p_n_len,
                                     const uint8_t** pp_p, uint8_t* p_p_len)
{
    uint16_t status = M_ERR_COMMAND_DISALLOWED;
    f814:	4808      	ldr	r0, [pc, #32]	; (f838 <m_prov_k1_ready_cb+0xe8>)
    f816:	e000      	b.n	f81a <m_prov_k1_ready_cb+0xca>
                *p_p_len = sizeof(m_prov_session_nonce_p_val);

                status = M_ERR_NO_ERROR;
            } break;

            default: {  status = M_ERR_PROV_UNEXPECTED; } break;
    f818:	4808      	ldr	r0, [pc, #32]	; (f83c <m_prov_k1_ready_cb+0xec>)
        }
    }

    return (status);
}
    f81a:	b005      	add	sp, #20
    f81c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    f81e:	46c0      	nop			; (mov r8, r8)
    f820:	100128a4 	.word	0x100128a4
    f824:	10010514 	.word	0x10010514
    f828:	000220c8 	.word	0x000220c8
    f82c:	00021dc8 	.word	0x00021dc8
    f830:	00021d48 	.word	0x00021d48
    f834:	0000051f 	.word	0x0000051f
    f838:	00000282 	.word	0x00000282
    f83c:	00000781 	.word	0x00000781

0000f840 <m_prov_k1_finished_cb>:
 *                      (@note length is variable and depends on security function used)
 *                      (@note equals NULL for AES-CCM encrypt and decrypt functions)
 ****************************************************************************************
 */
__STATIC void m_prov_k1_finished_cb(uint8_t token_id, uint16_t status, const uint8_t* p_aes)
{
    f840:	b5f0      	push	{r4, r5, r6, r7, lr}
	M_PRINTF(L_PROV, "status = %d p_m_prov_env = %p", status, p_m_prov_env);
    f842:	4b5d      	ldr	r3, [pc, #372]	; (f9b8 <m_prov_k1_finished_cb+0x178>)
 *                      (@note length is variable and depends on security function used)
 *                      (@note equals NULL for AES-CCM encrypt and decrypt functions)
 ****************************************************************************************
 */
__STATIC void m_prov_k1_finished_cb(uint8_t token_id, uint16_t status, const uint8_t* p_aes)
{
    f844:	b089      	sub	sp, #36	; 0x24
	M_PRINTF(L_PROV, "status = %d p_m_prov_env = %p", status, p_m_prov_env);
    f846:	681b      	ldr	r3, [r3, #0]
 *                      (@note length is variable and depends on security function used)
 *                      (@note equals NULL for AES-CCM encrypt and decrypt functions)
 ****************************************************************************************
 */
__STATIC void m_prov_k1_finished_cb(uint8_t token_id, uint16_t status, const uint8_t* p_aes)
{
    f848:	000c      	movs	r4, r1
    f84a:	0015      	movs	r5, r2
	M_PRINTF(L_PROV, "status = %d p_m_prov_env = %p", status, p_m_prov_env);
    f84c:	071b      	lsls	r3, r3, #28
    f84e:	d519      	bpl.n	f884 <m_prov_k1_finished_cb+0x44>
    f850:	4f5a      	ldr	r7, [pc, #360]	; (f9bc <m_prov_k1_finished_cb+0x17c>)
    f852:	4e5b      	ldr	r6, [pc, #364]	; (f9c0 <m_prov_k1_finished_cb+0x180>)
    f854:	003b      	movs	r3, r7
    f856:	0032      	movs	r2, r6
    f858:	0030      	movs	r0, r6
    f85a:	330e      	adds	r3, #14
    f85c:	3255      	adds	r2, #85	; 0x55
    f85e:	9300      	str	r3, [sp, #0]
    f860:	4958      	ldr	r1, [pc, #352]	; (f9c4 <m_prov_k1_finished_cb+0x184>)
    f862:	4b59      	ldr	r3, [pc, #356]	; (f9c8 <m_prov_k1_finished_cb+0x188>)
    f864:	305e      	adds	r0, #94	; 0x5e
    f866:	f7f5 f8a1 	bl	49ac <m_print>
    f86a:	0038      	movs	r0, r7
    f86c:	4b57      	ldr	r3, [pc, #348]	; (f9cc <m_prov_k1_finished_cb+0x18c>)
    f86e:	0021      	movs	r1, r4
    f870:	681a      	ldr	r2, [r3, #0]
    f872:	3024      	adds	r0, #36	; 0x24
    f874:	f7f5 f89a 	bl	49ac <m_print>
    f878:	0030      	movs	r0, r6
    f87a:	4b52      	ldr	r3, [pc, #328]	; (f9c4 <m_prov_k1_finished_cb+0x184>)
    f87c:	307f      	adds	r0, #127	; 0x7f
    f87e:	1d99      	adds	r1, r3, #6
    f880:	f7f5 f894 	bl	49ac <m_print>
    m_prov_res_t* p_res = p_m_prov_env->p_res;
    f884:	4b51      	ldr	r3, [pc, #324]	; (f9cc <m_prov_k1_finished_cb+0x18c>)
    f886:	681b      	ldr	r3, [r3, #0]
    f888:	685e      	ldr	r6, [r3, #4]
	
    if(p_res != NULL){
    f88a:	2e00      	cmp	r6, #0
    f88c:	d100      	bne.n	f890 <m_prov_k1_finished_cb+0x50>
    f88e:	e090      	b.n	f9b2 <m_prov_k1_finished_cb+0x172>
    	M_PRINTF(L_PROV, "state = %d", p_res->state);
    f890:	4b49      	ldr	r3, [pc, #292]	; (f9b8 <m_prov_k1_finished_cb+0x178>)
    f892:	681b      	ldr	r3, [r3, #0]
    f894:	071b      	lsls	r3, r3, #28
    f896:	d518      	bpl.n	f8ca <m_prov_k1_finished_cb+0x8a>
    f898:	4f49      	ldr	r7, [pc, #292]	; (f9c0 <m_prov_k1_finished_cb+0x180>)
    f89a:	4b48      	ldr	r3, [pc, #288]	; (f9bc <m_prov_k1_finished_cb+0x17c>)
    f89c:	003a      	movs	r2, r7
    f89e:	0038      	movs	r0, r7
    f8a0:	330e      	adds	r3, #14
    f8a2:	3255      	adds	r2, #85	; 0x55
    f8a4:	9300      	str	r3, [sp, #0]
    f8a6:	4947      	ldr	r1, [pc, #284]	; (f9c4 <m_prov_k1_finished_cb+0x184>)
    f8a8:	4b49      	ldr	r3, [pc, #292]	; (f9d0 <m_prov_k1_finished_cb+0x190>)
    f8aa:	305e      	adds	r0, #94	; 0x5e
    f8ac:	f7f5 f87e 	bl	49ac <m_print>
    f8b0:	0033      	movs	r3, r6
    f8b2:	4848      	ldr	r0, [pc, #288]	; (f9d4 <m_prov_k1_finished_cb+0x194>)
    f8b4:	3358      	adds	r3, #88	; 0x58
    f8b6:	7819      	ldrb	r1, [r3, #0]
    f8b8:	3022      	adds	r0, #34	; 0x22
    f8ba:	f7f5 f877 	bl	49ac <m_print>
    f8be:	0038      	movs	r0, r7
    f8c0:	4b40      	ldr	r3, [pc, #256]	; (f9c4 <m_prov_k1_finished_cb+0x184>)
    f8c2:	307f      	adds	r0, #127	; 0x7f
    f8c4:	1d99      	adds	r1, r3, #6
    f8c6:	f7f5 f871 	bl	49ac <m_print>
		m_printf_hex(L_PROV, "prov k1 finished", p_aes, M_KEY_LEN);
    f8ca:	4f3c      	ldr	r7, [pc, #240]	; (f9bc <m_prov_k1_finished_cb+0x17c>)
    f8cc:	2310      	movs	r3, #16
    f8ce:	0039      	movs	r1, r7
    f8d0:	002a      	movs	r2, r5
    f8d2:	3142      	adds	r1, #66	; 0x42
    f8d4:	2008      	movs	r0, #8
    f8d6:	f7f5 f8c9 	bl	4a6c <m_printf_hex>
        if(status == M_ERR_NO_ERROR){
    f8da:	2c00      	cmp	r4, #0
    f8dc:	d163      	bne.n	f9a6 <m_prov_k1_finished_cb+0x166>
            // check state of provisioning
            switch(p_res->state){
    f8de:	0034      	movs	r4, r6
    f8e0:	3458      	adds	r4, #88	; 0x58
    f8e2:	7820      	ldrb	r0, [r4, #0]
    f8e4:	3808      	subs	r0, #8
    f8e6:	2807      	cmp	r0, #7
    f8e8:	d861      	bhi.n	f9ae <m_prov_k1_finished_cb+0x16e>
    f8ea:	f00e fa33 	bl	1dd54 <__gnu_thumb1_case_uqi>
    f8ee:	6004      	.short	0x6004
    f8f0:	13606060 	.word	0x13606060
    f8f4:	2a1b      	.short	0x2a1b
                case M_PROV_DSTATE_WAIT_CFM_KEY_COMP:{
                    memcpy(&(p_res->comp_data[M_PROV_COMP_CFM_KEY_OFFSET]), p_aes, M_KEY_LEN);
    f8f6:	0030      	movs	r0, r6
    f8f8:	2210      	movs	r2, #16
    f8fa:	0029      	movs	r1, r5
    f8fc:	30ca      	adds	r0, #202	; 0xca
    f8fe:	f006 f867 	bl	159d0 <memcpy>

                    // Compute confirmation value
                    p_res->state = M_PROV_DSTATE_WAIT_CFM_COMP;
    f902:	2309      	movs	r3, #9
                    status = m_tb_sec_cmac_start(M_TB_SEC_TOKEN_PROVISIONING, m_prov_cmac_ready_cb, m_prov_cmac_finished_cb);
    f904:	4a34      	ldr	r2, [pc, #208]	; (f9d8 <m_prov_k1_finished_cb+0x198>)
            switch(p_res->state){
                case M_PROV_DSTATE_WAIT_CFM_KEY_COMP:{
                    memcpy(&(p_res->comp_data[M_PROV_COMP_CFM_KEY_OFFSET]), p_aes, M_KEY_LEN);

                    // Compute confirmation value
                    p_res->state = M_PROV_DSTATE_WAIT_CFM_COMP;
    f906:	7023      	strb	r3, [r4, #0]
                    status = m_tb_sec_cmac_start(M_TB_SEC_TOKEN_PROVISIONING, m_prov_cmac_ready_cb, m_prov_cmac_finished_cb);
    f908:	4934      	ldr	r1, [pc, #208]	; (f9dc <m_prov_k1_finished_cb+0x19c>)
    f90a:	2005      	movs	r0, #5
    f90c:	f004 fb49 	bl	13fa2 <m_tb_sec_cmac_start>
    f910:	0004      	movs	r4, r0
                } break;
    f912:	e046      	b.n	f9a2 <m_prov_k1_finished_cb+0x162>

                case M_PROV_DSTATE_WAIT_DEVICE_KEY_COMP:{
                    memcpy(&(p_res->comp_data[M_PROV_COMP_DEVICE_KEY_OFFSET]), p_aes, M_KEY_LEN);
    f914:	0030      	movs	r0, r6
    f916:	2210      	movs	r2, #16
    f918:	308a      	adds	r0, #138	; 0x8a
    f91a:	0029      	movs	r1, r5
    f91c:	f006 f858 	bl	159d0 <memcpy>
                    p_res->state = M_PROV_DSTATE_WAIT_SESSION_KEY_COMP;
    f920:	230e      	movs	r3, #14
    f922:	e006      	b.n	f932 <m_prov_k1_finished_cb+0xf2>
                    status = m_tb_sec_k1_start(M_TB_SEC_TOKEN_PROVISIONING, m_prov_k1_ready_cb, m_prov_k1_finished_cb);
				} break;

                case M_PROV_DSTATE_WAIT_SESSION_KEY_COMP:{
                    memcpy(&(p_res->comp_data[M_PROV_COMP_SESSION_KEY_OFFSET]), p_aes, M_KEY_LEN);
    f924:	0030      	movs	r0, r6
    f926:	2210      	movs	r2, #16
    f928:	307a      	adds	r0, #122	; 0x7a
    f92a:	0029      	movs	r1, r5
    f92c:	f006 f850 	bl	159d0 <memcpy>
                    // Compute confirmation value
                    p_res->state = M_PROV_DSTATE_WAIT_SESSION_NONCE_COMP;
    f930:	230f      	movs	r3, #15
    f932:	7023      	strb	r3, [r4, #0]
					
                    status = m_tb_sec_k1_start(M_TB_SEC_TOKEN_PROVISIONING, m_prov_k1_ready_cb, m_prov_k1_finished_cb);
    f934:	4a2a      	ldr	r2, [pc, #168]	; (f9e0 <m_prov_k1_finished_cb+0x1a0>)
    f936:	492b      	ldr	r1, [pc, #172]	; (f9e4 <m_prov_k1_finished_cb+0x1a4>)
    f938:	2005      	movs	r0, #5
    f93a:	f004 fb40 	bl	13fbe <m_tb_sec_k1_start>
    f93e:	0004      	movs	r4, r0
				} break;
    f940:	e02f      	b.n	f9a2 <m_prov_k1_finished_cb+0x162>

                case M_PROV_DSTATE_WAIT_SESSION_NONCE_COMP:{
                    m_prov_random_t pdu;
					
                    co_bswap(&(p_res->comp_data[M_PROV_COMP_SESSION_NONCE_OFFSET]), p_aes, M_NONCE_LEN);
    f942:	0030      	movs	r0, r6
    f944:	220d      	movs	r2, #13
    f946:	306a      	adds	r0, #106	; 0x6a
    f948:	0029      	movs	r1, r5
    f94a:	f7ff f873 	bl	ea34 <co_bswap>

                    // Send local random value - and wait for provisioning data
                    p_res->state = M_PROV_DSTATE_WAIT_DATA;
    f94e:	2210      	movs	r2, #16
                    pdu.type = M_PROV_PDU_RANDOM;
                    memcpy(pdu.value, &(p_res->comp_data[M_PROV_COMP_RANDOM_DEV_OFFSET]), M_KEY_LEN);
    f950:	0031      	movs	r1, r6
    f952:	200d      	movs	r0, #13
					
                    co_bswap(&(p_res->comp_data[M_PROV_COMP_SESSION_NONCE_OFFSET]), p_aes, M_NONCE_LEN);

                    // Send local random value - and wait for provisioning data
                    p_res->state = M_PROV_DSTATE_WAIT_DATA;
                    pdu.type = M_PROV_PDU_RANDOM;
    f954:	2306      	movs	r3, #6
                    m_prov_random_t pdu;
					
                    co_bswap(&(p_res->comp_data[M_PROV_COMP_SESSION_NONCE_OFFSET]), p_aes, M_NONCE_LEN);

                    // Send local random value - and wait for provisioning data
                    p_res->state = M_PROV_DSTATE_WAIT_DATA;
    f956:	7022      	strb	r2, [r4, #0]
                    pdu.type = M_PROV_PDU_RANDOM;
                    memcpy(pdu.value, &(p_res->comp_data[M_PROV_COMP_RANDOM_DEV_OFFSET]), M_KEY_LEN);
    f958:	315a      	adds	r1, #90	; 0x5a
					
                    co_bswap(&(p_res->comp_data[M_PROV_COMP_SESSION_NONCE_OFFSET]), p_aes, M_NONCE_LEN);

                    // Send local random value - and wait for provisioning data
                    p_res->state = M_PROV_DSTATE_WAIT_DATA;
                    pdu.type = M_PROV_PDU_RANDOM;
    f95a:	ac03      	add	r4, sp, #12
                    memcpy(pdu.value, &(p_res->comp_data[M_PROV_COMP_RANDOM_DEV_OFFSET]), M_KEY_LEN);
    f95c:	4468      	add	r0, sp
					
                    co_bswap(&(p_res->comp_data[M_PROV_COMP_SESSION_NONCE_OFFSET]), p_aes, M_NONCE_LEN);

                    // Send local random value - and wait for provisioning data
                    p_res->state = M_PROV_DSTATE_WAIT_DATA;
                    pdu.type = M_PROV_PDU_RANDOM;
    f95e:	7023      	strb	r3, [r4, #0]
                    memcpy(pdu.value, &(p_res->comp_data[M_PROV_COMP_RANDOM_DEV_OFFSET]), M_KEY_LEN);
    f960:	f006 f836 	bl	159d0 <memcpy>
                    status = m_prov_pdu_send((union m_prov_pdu*) &pdu, NULL);
    f964:	0020      	movs	r0, r4
    f966:	2100      	movs	r1, #0
    f968:	f7ff f8a8 	bl	eabc <m_prov_pdu_send>
					M_PRINTF(L_PROV, "send device random number");
    f96c:	4b12      	ldr	r3, [pc, #72]	; (f9b8 <m_prov_k1_finished_cb+0x178>)

                    // Send local random value - and wait for provisioning data
                    p_res->state = M_PROV_DSTATE_WAIT_DATA;
                    pdu.type = M_PROV_PDU_RANDOM;
                    memcpy(pdu.value, &(p_res->comp_data[M_PROV_COMP_RANDOM_DEV_OFFSET]), M_KEY_LEN);
                    status = m_prov_pdu_send((union m_prov_pdu*) &pdu, NULL);
    f96e:	0004      	movs	r4, r0
					M_PRINTF(L_PROV, "send device random number");
    f970:	681b      	ldr	r3, [r3, #0]
    f972:	071b      	lsls	r3, r3, #28
    f974:	d515      	bpl.n	f9a2 <m_prov_k1_finished_cb+0x162>
    f976:	4d12      	ldr	r5, [pc, #72]	; (f9c0 <m_prov_k1_finished_cb+0x180>)
    f978:	003b      	movs	r3, r7
    f97a:	002a      	movs	r2, r5
    f97c:	0028      	movs	r0, r5
    f97e:	4e11      	ldr	r6, [pc, #68]	; (f9c4 <m_prov_k1_finished_cb+0x184>)
    f980:	330e      	adds	r3, #14
    f982:	0031      	movs	r1, r6
    f984:	3255      	adds	r2, #85	; 0x55
    f986:	9300      	str	r3, [sp, #0]
    f988:	305e      	adds	r0, #94	; 0x5e
    f98a:	4b17      	ldr	r3, [pc, #92]	; (f9e8 <m_prov_k1_finished_cb+0x1a8>)
    f98c:	f7f5 f80e 	bl	49ac <m_print>
    f990:	0038      	movs	r0, r7
    f992:	3053      	adds	r0, #83	; 0x53
    f994:	f7f5 f80a 	bl	49ac <m_print>
    f998:	0028      	movs	r0, r5
    f99a:	1db1      	adds	r1, r6, #6
    f99c:	307f      	adds	r0, #127	; 0x7f
    f99e:	f7f5 f805 	bl	49ac <m_print>

                default: {  status = M_ERR_PROV_UNEXPECTED; } break;
            }
        }

        if(status != M_ERR_NO_ERROR){
    f9a2:	2c00      	cmp	r4, #0
    f9a4:	d005      	beq.n	f9b2 <m_prov_k1_finished_cb+0x172>
            // Handle error
            m_prov_error_handle(status);
    f9a6:	0020      	movs	r0, r4
    f9a8:	f000 f9e0 	bl	fd6c <m_prov_error_handle>
        }
    }
}
    f9ac:	e001      	b.n	f9b2 <m_prov_k1_finished_cb+0x172>
                    memcpy(pdu.value, &(p_res->comp_data[M_PROV_COMP_RANDOM_DEV_OFFSET]), M_KEY_LEN);
                    status = m_prov_pdu_send((union m_prov_pdu*) &pdu, NULL);
					M_PRINTF(L_PROV, "send device random number");
				} break;

                default: {  status = M_ERR_PROV_UNEXPECTED; } break;
    f9ae:	4c0f      	ldr	r4, [pc, #60]	; (f9ec <m_prov_k1_finished_cb+0x1ac>)
    f9b0:	e7f9      	b.n	f9a6 <m_prov_k1_finished_cb+0x166>
        if(status != M_ERR_NO_ERROR){
            // Handle error
            m_prov_error_handle(status);
        }
    }
}
    f9b2:	b009      	add	sp, #36	; 0x24
    f9b4:	bdf0      	pop	{r4, r5, r6, r7, pc}
    f9b6:	46c0      	nop			; (mov r8, r8)
    f9b8:	10010514 	.word	0x10010514
    f9bc:	00022148 	.word	0x00022148
    f9c0:	00021dc8 	.word	0x00021dc8
    f9c4:	00021d48 	.word	0x00021d48
    f9c8:	00000565 	.word	0x00000565
    f9cc:	100128a4 	.word	0x100128a4
    f9d0:	00000569 	.word	0x00000569
    f9d4:	00021ec8 	.word	0x00021ec8
    f9d8:	0000fa31 	.word	0x0000fa31
    f9dc:	0000f9f1 	.word	0x0000f9f1
    f9e0:	0000f841 	.word	0x0000f841
    f9e4:	0000f751 	.word	0x0000f751
    f9e8:	0000058e 	.word	0x0000058e
    f9ec:	00000781 	.word	0x00000781

0000f9f0 <m_prov_cmac_ready_cb>:
 */
__STATIC uint16_t m_prov_cmac_ready_cb(uint8_t token_id, const uint8_t** pp_key, const uint8_t** pp_msg,
                                       uint16_t* p_msg_len)
{
    uint16_t status = M_ERR_COMMAND_DISALLOWED;
    m_prov_res_t* p_res = p_m_prov_env->p_res;
    f9f0:	480c      	ldr	r0, [pc, #48]	; (fa24 <m_prov_cmac_ready_cb+0x34>)
 * @return Status error code (@see enum m_error)
 ****************************************************************************************
 */
__STATIC uint16_t m_prov_cmac_ready_cb(uint8_t token_id, const uint8_t** pp_key, const uint8_t** pp_msg,
                                       uint16_t* p_msg_len)
{
    f9f2:	b510      	push	{r4, lr}
    uint16_t status = M_ERR_COMMAND_DISALLOWED;
    m_prov_res_t* p_res = p_m_prov_env->p_res;
    f9f4:	6800      	ldr	r0, [r0, #0]
    f9f6:	6840      	ldr	r0, [r0, #4]

    if(p_res != NULL)
    f9f8:	2800      	cmp	r0, #0
    f9fa:	d00f      	beq.n	fa1c <m_prov_cmac_ready_cb+0x2c>
    {
        // check state of provisioning
        switch(p_res->state)
    f9fc:	0004      	movs	r4, r0
    f9fe:	3458      	adds	r4, #88	; 0x58
    fa00:	7824      	ldrb	r4, [r4, #0]
    fa02:	2c09      	cmp	r4, #9
    fa04:	d001      	beq.n	fa0a <m_prov_cmac_ready_cb+0x1a>
    fa06:	2c0b      	cmp	r4, #11
    fa08:	d10a      	bne.n	fa20 <m_prov_cmac_ready_cb+0x30>
        {
            case M_PROV_DSTATE_WAIT_CFM_COMP:
            case M_PROV_DSTATE_WAIT_PROV_CFM_COMP:
            {
                *pp_key    = &(p_res->comp_data[M_PROV_COMP_CFM_KEY_OFFSET]);
    fa0a:	0004      	movs	r4, r0
                *pp_msg    = &(p_res->comp_data[M_PROV_COMP_AUTH_VALUE_OFFSET]);
    fa0c:	308a      	adds	r0, #138	; 0x8a
        switch(p_res->state)
        {
            case M_PROV_DSTATE_WAIT_CFM_COMP:
            case M_PROV_DSTATE_WAIT_PROV_CFM_COMP:
            {
                *pp_key    = &(p_res->comp_data[M_PROV_COMP_CFM_KEY_OFFSET]);
    fa0e:	34ca      	adds	r4, #202	; 0xca
    fa10:	600c      	str	r4, [r1, #0]
                *pp_msg    = &(p_res->comp_data[M_PROV_COMP_AUTH_VALUE_OFFSET]);
    fa12:	6010      	str	r0, [r2, #0]
                *p_msg_len = M_KEY_LEN + M_OOB_AUTH_DATA_LEN;
    fa14:	2220      	movs	r2, #32

                status = M_ERR_NO_ERROR;
    fa16:	2000      	movs	r0, #0
            case M_PROV_DSTATE_WAIT_CFM_COMP:
            case M_PROV_DSTATE_WAIT_PROV_CFM_COMP:
            {
                *pp_key    = &(p_res->comp_data[M_PROV_COMP_CFM_KEY_OFFSET]);
                *pp_msg    = &(p_res->comp_data[M_PROV_COMP_AUTH_VALUE_OFFSET]);
                *p_msg_len = M_KEY_LEN + M_OOB_AUTH_DATA_LEN;
    fa18:	801a      	strh	r2, [r3, #0]

                status = M_ERR_NO_ERROR;
            } break;
    fa1a:	e002      	b.n	fa22 <m_prov_cmac_ready_cb+0x32>
 ****************************************************************************************
 */
__STATIC uint16_t m_prov_cmac_ready_cb(uint8_t token_id, const uint8_t** pp_key, const uint8_t** pp_msg,
                                       uint16_t* p_msg_len)
{
    uint16_t status = M_ERR_COMMAND_DISALLOWED;
    fa1c:	4802      	ldr	r0, [pc, #8]	; (fa28 <m_prov_cmac_ready_cb+0x38>)
    fa1e:	e000      	b.n	fa22 <m_prov_cmac_ready_cb+0x32>
                *p_msg_len = M_KEY_LEN + M_OOB_AUTH_DATA_LEN;

                status = M_ERR_NO_ERROR;
            } break;

            default: {  status = M_ERR_PROV_UNEXPECTED; } break;
    fa20:	4802      	ldr	r0, [pc, #8]	; (fa2c <m_prov_cmac_ready_cb+0x3c>)
        }
    }

    return (status);
}
    fa22:	bd10      	pop	{r4, pc}
    fa24:	100128a4 	.word	0x100128a4
    fa28:	00000282 	.word	0x00000282
    fa2c:	00000781 	.word	0x00000781

0000fa30 <m_prov_cmac_finished_cb>:
 *                      (@note equals NULL for AES-CCM encrypt and decrypt functions)
 ****************************************************************************************
 */
__STATIC void m_prov_cmac_finished_cb(uint8_t token_id, uint16_t status, const uint8_t* p_cmac)
{
    m_prov_res_t* p_res = p_m_prov_env->p_res;
    fa30:	4b4d      	ldr	r3, [pc, #308]	; (fb68 <m_prov_cmac_finished_cb+0x138>)
 *                      (@note length is variable and depends on security function used)
 *                      (@note equals NULL for AES-CCM encrypt and decrypt functions)
 ****************************************************************************************
 */
__STATIC void m_prov_cmac_finished_cb(uint8_t token_id, uint16_t status, const uint8_t* p_cmac)
{
    fa32:	b5f0      	push	{r4, r5, r6, r7, lr}
    m_prov_res_t* p_res = p_m_prov_env->p_res;
    fa34:	681b      	ldr	r3, [r3, #0]
 *                      (@note length is variable and depends on security function used)
 *                      (@note equals NULL for AES-CCM encrypt and decrypt functions)
 ****************************************************************************************
 */
__STATIC void m_prov_cmac_finished_cb(uint8_t token_id, uint16_t status, const uint8_t* p_cmac)
{
    fa36:	b08b      	sub	sp, #44	; 0x2c
    m_prov_res_t* p_res = p_m_prov_env->p_res;
    fa38:	685f      	ldr	r7, [r3, #4]
	M_PRINTF(L_PROV, "status = %d state = %d", status, p_res->state);
    fa3a:	4b4c      	ldr	r3, [pc, #304]	; (fb6c <m_prov_cmac_finished_cb+0x13c>)
 *                      (@note length is variable and depends on security function used)
 *                      (@note equals NULL for AES-CCM encrypt and decrypt functions)
 ****************************************************************************************
 */
__STATIC void m_prov_cmac_finished_cb(uint8_t token_id, uint16_t status, const uint8_t* p_cmac)
{
    fa3c:	000c      	movs	r4, r1
    m_prov_res_t* p_res = p_m_prov_env->p_res;
	M_PRINTF(L_PROV, "status = %d state = %d", status, p_res->state);
    fa3e:	681b      	ldr	r3, [r3, #0]
 *                      (@note length is variable and depends on security function used)
 *                      (@note equals NULL for AES-CCM encrypt and decrypt functions)
 ****************************************************************************************
 */
__STATIC void m_prov_cmac_finished_cb(uint8_t token_id, uint16_t status, const uint8_t* p_cmac)
{
    fa40:	9203      	str	r2, [sp, #12]
    m_prov_res_t* p_res = p_m_prov_env->p_res;
	M_PRINTF(L_PROV, "status = %d state = %d", status, p_res->state);
    fa42:	071b      	lsls	r3, r3, #28
    fa44:	d519      	bpl.n	fa7a <m_prov_cmac_finished_cb+0x4a>
    fa46:	4d4a      	ldr	r5, [pc, #296]	; (fb70 <m_prov_cmac_finished_cb+0x140>)
    fa48:	4b4a      	ldr	r3, [pc, #296]	; (fb74 <m_prov_cmac_finished_cb+0x144>)
    fa4a:	002a      	movs	r2, r5
    fa4c:	0028      	movs	r0, r5
    fa4e:	4e4a      	ldr	r6, [pc, #296]	; (fb78 <m_prov_cmac_finished_cb+0x148>)
    fa50:	336d      	adds	r3, #109	; 0x6d
    fa52:	3255      	adds	r2, #85	; 0x55
    fa54:	9300      	str	r3, [sp, #0]
    fa56:	0031      	movs	r1, r6
    fa58:	4b48      	ldr	r3, [pc, #288]	; (fb7c <m_prov_cmac_finished_cb+0x14c>)
    fa5a:	305e      	adds	r0, #94	; 0x5e
    fa5c:	f7f4 ffa6 	bl	49ac <m_print>
    fa60:	003b      	movs	r3, r7
    fa62:	4847      	ldr	r0, [pc, #284]	; (fb80 <m_prov_cmac_finished_cb+0x150>)
    fa64:	3358      	adds	r3, #88	; 0x58
    fa66:	0021      	movs	r1, r4
    fa68:	781a      	ldrb	r2, [r3, #0]
    fa6a:	300e      	adds	r0, #14
    fa6c:	f7f4 ff9e 	bl	49ac <m_print>
    fa70:	0028      	movs	r0, r5
    fa72:	1db1      	adds	r1, r6, #6
    fa74:	307f      	adds	r0, #127	; 0x7f
    fa76:	f7f4 ff99 	bl	49ac <m_print>
	m_printf_hex(L_PROV, "prov cmac finished", p_cmac, M_KEY_LEN);
    fa7a:	4d42      	ldr	r5, [pc, #264]	; (fb84 <m_prov_cmac_finished_cb+0x154>)
    fa7c:	2310      	movs	r3, #16
    fa7e:	1d69      	adds	r1, r5, #5
    fa80:	9a03      	ldr	r2, [sp, #12]
    fa82:	2008      	movs	r0, #8
    fa84:	f7f4 fff2 	bl	4a6c <m_printf_hex>

    if(p_res != NULL)
    fa88:	2f00      	cmp	r7, #0
    fa8a:	d06a      	beq.n	fb62 <m_prov_cmac_finished_cb+0x132>
    {
        if(status == M_ERR_NO_ERROR)
    fa8c:	2c00      	cmp	r4, #0
    fa8e:	d165      	bne.n	fb5c <m_prov_cmac_finished_cb+0x12c>
        {
            m_prov_cfm_t pdu;

            // check state of provisioning
            switch(p_res->state)
    fa90:	003e      	movs	r6, r7
    fa92:	3658      	adds	r6, #88	; 0x58
    fa94:	7833      	ldrb	r3, [r6, #0]
    fa96:	2b09      	cmp	r3, #9
    fa98:	d002      	beq.n	faa0 <m_prov_cmac_finished_cb+0x70>
    fa9a:	2b0b      	cmp	r3, #11
    fa9c:	d012      	beq.n	fac4 <m_prov_cmac_finished_cb+0x94>
    fa9e:	e057      	b.n	fb50 <m_prov_cmac_finished_cb+0x120>
            {
                case M_PROV_DSTATE_WAIT_CFM_COMP:
                {
                    p_res->state = M_PROV_DSTATE_WAIT_RND;
    faa0:	230a      	movs	r3, #10

                    // Send Confirmation value
                    pdu.type            = M_PROV_PDU_CONFIRMATION;
                    memcpy(pdu.value, p_cmac, M_KEY_LEN);
    faa2:	200d      	movs	r0, #13
            // check state of provisioning
            switch(p_res->state)
            {
                case M_PROV_DSTATE_WAIT_CFM_COMP:
                {
                    p_res->state = M_PROV_DSTATE_WAIT_RND;
    faa4:	7033      	strb	r3, [r6, #0]

                    // Send Confirmation value
                    pdu.type            = M_PROV_PDU_CONFIRMATION;
    faa6:	ad05      	add	r5, sp, #20
    faa8:	3b05      	subs	r3, #5
    faaa:	702b      	strb	r3, [r5, #0]
                    memcpy(pdu.value, p_cmac, M_KEY_LEN);
    faac:	ab02      	add	r3, sp, #8
    faae:	2210      	movs	r2, #16
    fab0:	9903      	ldr	r1, [sp, #12]
    fab2:	18c0      	adds	r0, r0, r3
    fab4:	f005 ff8c 	bl	159d0 <memcpy>
                    status = m_prov_pdu_send((union m_prov_pdu*) &pdu, NULL);
    fab8:	0021      	movs	r1, r4
    faba:	0028      	movs	r0, r5
    fabc:	f7fe fffe 	bl	eabc <m_prov_pdu_send>
    fac0:	0004      	movs	r4, r0
                } break;
    fac2:	e049      	b.n	fb58 <m_prov_cmac_finished_cb+0x128>
                case M_PROV_DSTATE_WAIT_PROV_CFM_COMP:
                {
                    // check if peer confirmation value is valid
                    if(memcmp(&(p_res->comp_data[M_PROV_CFM_PEER_VAL_OFFSET]), p_cmac, M_KEY_LEN) == 0)
    fac4:	0038      	movs	r0, r7
    fac6:	2210      	movs	r2, #16
    fac8:	30eb      	adds	r0, #235	; 0xeb
    faca:	9903      	ldr	r1, [sp, #12]
    facc:	f005 ff58 	bl	15980 <memcmp>
    fad0:	4a26      	ldr	r2, [pc, #152]	; (fb6c <m_prov_cmac_finished_cb+0x13c>)
    fad2:	2308      	movs	r3, #8
                    {
                    	M_PRINTF(L_PROV, "valid");
    fad4:	6812      	ldr	r2, [r2, #0]
                    status = m_prov_pdu_send((union m_prov_pdu*) &pdu, NULL);
                } break;
                case M_PROV_DSTATE_WAIT_PROV_CFM_COMP:
                {
                    // check if peer confirmation value is valid
                    if(memcmp(&(p_res->comp_data[M_PROV_CFM_PEER_VAL_OFFSET]), p_cmac, M_KEY_LEN) == 0)
    fad6:	2800      	cmp	r0, #0
    fad8:	d120      	bne.n	fb1c <m_prov_cmac_finished_cb+0xec>
                    {
                    	M_PRINTF(L_PROV, "valid");
    fada:	421a      	tst	r2, r3
    fadc:	d015      	beq.n	fb0a <m_prov_cmac_finished_cb+0xda>
    fade:	4c24      	ldr	r4, [pc, #144]	; (fb70 <m_prov_cmac_finished_cb+0x140>)
    fae0:	4b24      	ldr	r3, [pc, #144]	; (fb74 <m_prov_cmac_finished_cb+0x144>)
    fae2:	0022      	movs	r2, r4
    fae4:	0020      	movs	r0, r4
    fae6:	4f24      	ldr	r7, [pc, #144]	; (fb78 <m_prov_cmac_finished_cb+0x148>)
    fae8:	336d      	adds	r3, #109	; 0x6d
    faea:	0039      	movs	r1, r7
    faec:	3255      	adds	r2, #85	; 0x55
    faee:	9300      	str	r3, [sp, #0]
    faf0:	305e      	adds	r0, #94	; 0x5e
    faf2:	4b25      	ldr	r3, [pc, #148]	; (fb88 <m_prov_cmac_finished_cb+0x158>)
    faf4:	f7f4 ff5a 	bl	49ac <m_print>
    faf8:	0028      	movs	r0, r5
    fafa:	3018      	adds	r0, #24
    fafc:	f7f4 ff56 	bl	49ac <m_print>
    fb00:	0020      	movs	r0, r4
    fb02:	1db9      	adds	r1, r7, #6
    fb04:	307f      	adds	r0, #127	; 0x7f
    fb06:	f7f4 ff51 	bl	49ac <m_print>
                        // Immediately requests computation of Provisioning salted key
                        p_res->state = M_PROV_DSTATE_WAIT_PROV_SALT_COMP;
    fb0a:	230c      	movs	r3, #12
                        status = m_tb_sec_s1_start(M_TB_SEC_TOKEN_KEY_MANAGER, m_prov_s1_ready_cb, m_prov_psalt_finished_cb);
    fb0c:	4a1f      	ldr	r2, [pc, #124]	; (fb8c <m_prov_cmac_finished_cb+0x15c>)
                    // check if peer confirmation value is valid
                    if(memcmp(&(p_res->comp_data[M_PROV_CFM_PEER_VAL_OFFSET]), p_cmac, M_KEY_LEN) == 0)
                    {
                    	M_PRINTF(L_PROV, "valid");
                        // Immediately requests computation of Provisioning salted key
                        p_res->state = M_PROV_DSTATE_WAIT_PROV_SALT_COMP;
    fb0e:	7033      	strb	r3, [r6, #0]
                        status = m_tb_sec_s1_start(M_TB_SEC_TOKEN_KEY_MANAGER, m_prov_s1_ready_cb, m_prov_psalt_finished_cb);
    fb10:	491f      	ldr	r1, [pc, #124]	; (fb90 <m_prov_cmac_finished_cb+0x160>)
    fb12:	2004      	movs	r0, #4
    fb14:	f004 fa4c 	bl	13fb0 <m_tb_sec_s1_start>
    fb18:	0004      	movs	r4, r0
    fb1a:	e01d      	b.n	fb58 <m_prov_cmac_finished_cb+0x128>
                    }
                    else
                    {
                    	M_PRINTF(L_PROV, "invalid");
    fb1c:	421a      	tst	r2, r3
    fb1e:	d019      	beq.n	fb54 <m_prov_cmac_finished_cb+0x124>
    fb20:	4c13      	ldr	r4, [pc, #76]	; (fb70 <m_prov_cmac_finished_cb+0x140>)
    fb22:	4b14      	ldr	r3, [pc, #80]	; (fb74 <m_prov_cmac_finished_cb+0x144>)
    fb24:	0022      	movs	r2, r4
    fb26:	0020      	movs	r0, r4
    fb28:	4e13      	ldr	r6, [pc, #76]	; (fb78 <m_prov_cmac_finished_cb+0x148>)
    fb2a:	336d      	adds	r3, #109	; 0x6d
    fb2c:	3255      	adds	r2, #85	; 0x55
    fb2e:	0031      	movs	r1, r6
    fb30:	9300      	str	r3, [sp, #0]
    fb32:	305e      	adds	r0, #94	; 0x5e
    fb34:	4b17      	ldr	r3, [pc, #92]	; (fb94 <m_prov_cmac_finished_cb+0x164>)
    fb36:	f7f4 ff39 	bl	49ac <m_print>
    fb3a:	0028      	movs	r0, r5
    fb3c:	301e      	adds	r0, #30
    fb3e:	f7f4 ff35 	bl	49ac <m_print>
    fb42:	0020      	movs	r0, r4
    fb44:	1db1      	adds	r1, r6, #6
    fb46:	307f      	adds	r0, #127	; 0x7f
    fb48:	f7f4 ff30 	bl	49ac <m_print>
                        status = M_ERR_PROV_CONFIRMATION_FAILED;
    fb4c:	4c12      	ldr	r4, [pc, #72]	; (fb98 <m_prov_cmac_finished_cb+0x168>)
    fb4e:	e005      	b.n	fb5c <m_prov_cmac_finished_cb+0x12c>
                    }
                } break;
                default: { status = M_ERR_PROV_UNEXPECTED; } break;
    fb50:	4c12      	ldr	r4, [pc, #72]	; (fb9c <m_prov_cmac_finished_cb+0x16c>)
    fb52:	e003      	b.n	fb5c <m_prov_cmac_finished_cb+0x12c>
                        status = m_tb_sec_s1_start(M_TB_SEC_TOKEN_KEY_MANAGER, m_prov_s1_ready_cb, m_prov_psalt_finished_cb);
                    }
                    else
                    {
                    	M_PRINTF(L_PROV, "invalid");
                        status = M_ERR_PROV_CONFIRMATION_FAILED;
    fb54:	4c10      	ldr	r4, [pc, #64]	; (fb98 <m_prov_cmac_finished_cb+0x168>)
    fb56:	e001      	b.n	fb5c <m_prov_cmac_finished_cb+0x12c>
                } break;
                default: { status = M_ERR_PROV_UNEXPECTED; } break;
            }
        }

        if(status != M_ERR_NO_ERROR)
    fb58:	2c00      	cmp	r4, #0
    fb5a:	d002      	beq.n	fb62 <m_prov_cmac_finished_cb+0x132>
        {
            // Handle error
            m_prov_error_handle(status);
    fb5c:	0020      	movs	r0, r4
    fb5e:	f000 f905 	bl	fd6c <m_prov_error_handle>
        }
    }
}
    fb62:	b00b      	add	sp, #44	; 0x2c
    fb64:	bdf0      	pop	{r4, r5, r6, r7, pc}
    fb66:	46c0      	nop			; (mov r8, r8)
    fb68:	100128a4 	.word	0x100128a4
    fb6c:	10010514 	.word	0x10010514
    fb70:	00021dc8 	.word	0x00021dc8
    fb74:	00022148 	.word	0x00022148
    fb78:	00021d48 	.word	0x00021d48
    fb7c:	000005d3 	.word	0x000005d3
    fb80:	00022048 	.word	0x00022048
    fb84:	000221c8 	.word	0x000221c8
    fb88:	000005ed 	.word	0x000005ed
    fb8c:	0000f421 	.word	0x0000f421
    fb90:	0000f265 	.word	0x0000f265
    fb94:	000005f4 	.word	0x000005f4
    fb98:	00000481 	.word	0x00000481
    fb9c:	00000781 	.word	0x00000781

0000fba0 <m_prov_ccm_ready_cb>:
__STATIC uint16_t m_prov_ccm_ready_cb(uint8_t token_id, const uint8_t** pp_key, const uint8_t** pp_nonce,
                                      const uint8_t** pp_in,  uint8_t** pp_out, uint16_t* p_msg_len,
                                      uint8_t* p_mic_len,  const uint8_t** pp_auth_data, uint8_t * p_auth_data_len)
{
    uint16_t status = M_ERR_COMMAND_DISALLOWED;
    m_prov_res_t* p_res = p_m_prov_env->p_res;
    fba0:	4813      	ldr	r0, [pc, #76]	; (fbf0 <m_prov_ccm_ready_cb+0x50>)
 ****************************************************************************************
 */
__STATIC uint16_t m_prov_ccm_ready_cb(uint8_t token_id, const uint8_t** pp_key, const uint8_t** pp_nonce,
                                      const uint8_t** pp_in,  uint8_t** pp_out, uint16_t* p_msg_len,
                                      uint8_t* p_mic_len,  const uint8_t** pp_auth_data, uint8_t * p_auth_data_len)
{
    fba2:	b510      	push	{r4, lr}
    uint16_t status = M_ERR_COMMAND_DISALLOWED;
    m_prov_res_t* p_res = p_m_prov_env->p_res;
    fba4:	6800      	ldr	r0, [r0, #0]
    fba6:	6844      	ldr	r4, [r0, #4]

    if(p_res != NULL)
    fba8:	2c00      	cmp	r4, #0
    fbaa:	d01c      	beq.n	fbe6 <m_prov_ccm_ready_cb+0x46>
    {
        // check state of provisioning
        switch(p_res->state)
    fbac:	0020      	movs	r0, r4
    fbae:	3058      	adds	r0, #88	; 0x58
    fbb0:	7800      	ldrb	r0, [r0, #0]
    fbb2:	2811      	cmp	r0, #17
    fbb4:	d119      	bne.n	fbea <m_prov_ccm_ready_cb+0x4a>
        {
            case M_PROV_DSTATE_WAIT_DATA_DEC:
            {
                *pp_key          = &(p_res->comp_data[M_PROV_COMP_SESSION_KEY_OFFSET]);
    fbb6:	0020      	movs	r0, r4
    fbb8:	307a      	adds	r0, #122	; 0x7a
    fbba:	6008      	str	r0, [r1, #0]
                *pp_nonce        = &(p_res->comp_data[M_PROV_COMP_SESSION_NONCE_OFFSET]);
    fbbc:	0021      	movs	r1, r4
                *pp_auth_data    = NULL;
    fbbe:	2000      	movs	r0, #0
        switch(p_res->state)
        {
            case M_PROV_DSTATE_WAIT_DATA_DEC:
            {
                *pp_key          = &(p_res->comp_data[M_PROV_COMP_SESSION_KEY_OFFSET]);
                *pp_nonce        = &(p_res->comp_data[M_PROV_COMP_SESSION_NONCE_OFFSET]);
    fbc0:	316a      	adds	r1, #106	; 0x6a
    fbc2:	6011      	str	r1, [r2, #0]
                *pp_auth_data    = NULL;
    fbc4:	9a05      	ldr	r2, [sp, #20]
    fbc6:	6010      	str	r0, [r2, #0]
                *p_auth_data_len = 0;
    fbc8:	9a06      	ldr	r2, [sp, #24]
    fbca:	7010      	strb	r0, [r2, #0]
                *pp_in           = &(p_res->comp_data[M_PROV_COMP_DATA_ENC_OFFSET]);
    fbcc:	0022      	movs	r2, r4
    fbce:	32aa      	adds	r2, #170	; 0xaa
    fbd0:	601a      	str	r2, [r3, #0]
                *pp_out          = &(p_res->comp_data[M_PROV_COMP_DATA_DEC_OFFSET]);
    fbd2:	9b02      	ldr	r3, [sp, #8]
    fbd4:	34d2      	adds	r4, #210	; 0xd2
    fbd6:	601c      	str	r4, [r3, #0]
                *p_msg_len       = M_PROV_DATA_LEN;
    fbd8:	2319      	movs	r3, #25
    fbda:	9a03      	ldr	r2, [sp, #12]
    fbdc:	8013      	strh	r3, [r2, #0]
                *p_mic_len       = M_PROV_MIC_LEN;
    fbde:	9a04      	ldr	r2, [sp, #16]
    fbe0:	3b11      	subs	r3, #17
    fbe2:	7013      	strb	r3, [r2, #0]

                status = M_ERR_NO_ERROR;
            } break;
    fbe4:	e002      	b.n	fbec <m_prov_ccm_ready_cb+0x4c>
 */
__STATIC uint16_t m_prov_ccm_ready_cb(uint8_t token_id, const uint8_t** pp_key, const uint8_t** pp_nonce,
                                      const uint8_t** pp_in,  uint8_t** pp_out, uint16_t* p_msg_len,
                                      uint8_t* p_mic_len,  const uint8_t** pp_auth_data, uint8_t * p_auth_data_len)
{
    uint16_t status = M_ERR_COMMAND_DISALLOWED;
    fbe6:	4803      	ldr	r0, [pc, #12]	; (fbf4 <m_prov_ccm_ready_cb+0x54>)
    fbe8:	e000      	b.n	fbec <m_prov_ccm_ready_cb+0x4c>
                *p_mic_len       = M_PROV_MIC_LEN;

                status = M_ERR_NO_ERROR;
            } break;

            default: { status = M_ERR_PROV_UNEXPECTED; } break;
    fbea:	4803      	ldr	r0, [pc, #12]	; (fbf8 <m_prov_ccm_ready_cb+0x58>)
        }
    }

    return (status);
}
    fbec:	bd10      	pop	{r4, pc}
    fbee:	46c0      	nop			; (mov r8, r8)
    fbf0:	100128a4 	.word	0x100128a4
    fbf4:	00000282 	.word	0x00000282
    fbf8:	00000781 	.word	0x00000781

0000fbfc <m_prov_ccm_finished_cb>:
 *
 * @return Execution status (@see enum m_error)
 ****************************************************************************************
 */
__STATIC void m_prov_ccm_finished_cb(uint8_t token_id, uint16_t status, const uint8_t* p_none)
{
    fbfc:	b570      	push	{r4, r5, r6, lr}
	M_PRINTF(L_PROV, "status = %d", status);
    fbfe:	4b2d      	ldr	r3, [pc, #180]	; (fcb4 <m_prov_ccm_finished_cb+0xb8>)
 *
 * @return Execution status (@see enum m_error)
 ****************************************************************************************
 */
__STATIC void m_prov_ccm_finished_cb(uint8_t token_id, uint16_t status, const uint8_t* p_none)
{
    fc00:	b08a      	sub	sp, #40	; 0x28
	M_PRINTF(L_PROV, "status = %d", status);
    fc02:	681b      	ldr	r3, [r3, #0]
 *
 * @return Execution status (@see enum m_error)
 ****************************************************************************************
 */
__STATIC void m_prov_ccm_finished_cb(uint8_t token_id, uint16_t status, const uint8_t* p_none)
{
    fc04:	000e      	movs	r6, r1
	M_PRINTF(L_PROV, "status = %d", status);
    fc06:	071b      	lsls	r3, r3, #28
    fc08:	d516      	bpl.n	fc38 <m_prov_ccm_finished_cb+0x3c>
    fc0a:	4c2b      	ldr	r4, [pc, #172]	; (fcb8 <m_prov_ccm_finished_cb+0xbc>)
    fc0c:	4b2b      	ldr	r3, [pc, #172]	; (fcbc <m_prov_ccm_finished_cb+0xc0>)
    fc0e:	0022      	movs	r2, r4
    fc10:	0020      	movs	r0, r4
    fc12:	4d2b      	ldr	r5, [pc, #172]	; (fcc0 <m_prov_ccm_finished_cb+0xc4>)
    fc14:	3326      	adds	r3, #38	; 0x26
    fc16:	3255      	adds	r2, #85	; 0x55
    fc18:	9300      	str	r3, [sp, #0]
    fc1a:	0029      	movs	r1, r5
    fc1c:	4b29      	ldr	r3, [pc, #164]	; (fcc4 <m_prov_ccm_finished_cb+0xc8>)
    fc1e:	305e      	adds	r0, #94	; 0x5e
    fc20:	f7f4 fec4 	bl	49ac <m_print>
    fc24:	4828      	ldr	r0, [pc, #160]	; (fcc8 <m_prov_ccm_finished_cb+0xcc>)
    fc26:	0031      	movs	r1, r6
    fc28:	3052      	adds	r0, #82	; 0x52
    fc2a:	f7f4 febf 	bl	49ac <m_print>
    fc2e:	0020      	movs	r0, r4
    fc30:	1da9      	adds	r1, r5, #6
    fc32:	307f      	adds	r0, #127	; 0x7f
    fc34:	f7f4 feba 	bl	49ac <m_print>
    m_prov_res_t* p_res = p_m_prov_env->p_res;
    fc38:	4b24      	ldr	r3, [pc, #144]	; (fccc <m_prov_ccm_finished_cb+0xd0>)
    fc3a:	681b      	ldr	r3, [r3, #0]
    fc3c:	685d      	ldr	r5, [r3, #4]

    if(p_res != NULL)
    fc3e:	2d00      	cmp	r5, #0
    fc40:	d035      	beq.n	fcae <m_prov_ccm_finished_cb+0xb2>
    {
        // check state of provisioning
        switch(p_res->state)
    fc42:	002b      	movs	r3, r5
    fc44:	3358      	adds	r3, #88	; 0x58
    fc46:	781b      	ldrb	r3, [r3, #0]
    fc48:	2b11      	cmp	r3, #17
    fc4a:	d12d      	bne.n	fca8 <m_prov_ccm_finished_cb+0xac>
        {
            case M_PROV_DSTATE_WAIT_DATA_DEC:
            {
                do {
                    uint16_t prov_data_len = sizeof(m_prov_data_dec_t);
    fc4c:	220a      	movs	r2, #10
    fc4e:	330b      	adds	r3, #11
    fc50:	446a      	add	r2, sp
    fc52:	8013      	strh	r3, [r2, #0]
                    m_prov_data_dec_t prov_data;

                    // Check if decryption is ok
                    if(status != M_ERR_NO_ERROR) { status = M_ERR_PROV_DECRYPTION_FAILED; break; }
    fc54:	2e00      	cmp	r6, #0
    fc56:	d125      	bne.n	fca4 <m_prov_ccm_finished_cb+0xa8>

                    // Extract provisioining data
                    status = co_util_unpack((uint8_t*) &prov_data, &(p_res->comp_data[M_PROV_COMP_DATA_DEC_OFFSET]),
    fc58:	0029      	movs	r1, r5
    fc5a:	4b18      	ldr	r3, [pc, #96]	; (fcbc <m_prov_ccm_finished_cb+0xc0>)
    fc5c:	ac03      	add	r4, sp, #12
    fc5e:	333d      	adds	r3, #61	; 0x3d
    fc60:	9300      	str	r3, [sp, #0]
    fc62:	31d2      	adds	r1, #210	; 0xd2
    fc64:	2319      	movs	r3, #25
    fc66:	0020      	movs	r0, r4
    fc68:	f7f4 fd84 	bl	4774 <co_util_unpack>
                                            &prov_data_len, M_PROV_DATA_LEN, ">16GHBLH");
                    if(status != CO_UTIL_PACK_OK) { status = M_ERR_PROV_UNEXPECTED; break; };
    fc6c:	2800      	cmp	r0, #0
    fc6e:	d11b      	bne.n	fca8 <m_prov_ccm_finished_cb+0xac>

                    // Set device key
                    status = m_tb_key_dev_add(&(p_res->comp_data[M_PROV_COMP_DEVICE_KEY_OFFSET]));
    fc70:	0028      	movs	r0, r5
    fc72:	308a      	adds	r0, #138	; 0x8a
    fc74:	f002 f8aa 	bl	11dcc <m_tb_key_dev_add>
                    if(status != M_ERR_NO_ERROR) { status = M_ERR_PROV_UNEXPECTED; break; }
    fc78:	2800      	cmp	r0, #0
    fc7a:	d115      	bne.n	fca8 <m_prov_ccm_finished_cb+0xac>

                    // Fill device primary address
                    m_tb_mio_set_prim_addr(prov_data.unicast_addr);
    fc7c:	8b20      	ldrh	r0, [r4, #24]
    fc7e:	f003 fea9 	bl	139d4 <m_tb_mio_set_prim_addr>

                    // TODO [LT] - Do this elsewhere
                    m_tb_key_model_bind(M_TB_KEY_DEVICE_LID, 0);
    fc82:	0031      	movs	r1, r6
    fc84:	0030      	movs	r0, r6
    fc86:	f002 fe85 	bl	12994 <m_tb_key_model_bind>

                    // Set network key
                    status = m_tb_key_net_add(prov_data.net_key_id, prov_data.net_key,
    fc8a:	7ca2      	ldrb	r2, [r4, #18]
    fc8c:	8a20      	ldrh	r0, [r4, #16]
    fc8e:	4b10      	ldr	r3, [pc, #64]	; (fcd0 <m_prov_ccm_finished_cb+0xd4>)
    fc90:	0021      	movs	r1, r4
    fc92:	f002 f8eb 	bl	11e6c <m_tb_key_net_add>
                                              prov_data.flags, m_prov_net_key_added_cb);

                    if (status != M_ERR_NO_ERROR)
    fc96:	2800      	cmp	r0, #0
    fc98:	d106      	bne.n	fca8 <m_prov_ccm_finished_cb+0xac>
                        status = M_ERR_PROV_UNEXPECTED;
                        break;
                    }

                    // Set IV
                    m_tb_key_set_iv_seq(prov_data.iv, 0);
    fc9a:	0031      	movs	r1, r6
    fc9c:	6960      	ldr	r0, [r4, #20]
    fc9e:	f002 ffc5 	bl	12c2c <m_tb_key_set_iv_seq>
    fca2:	e004      	b.n	fcae <m_prov_ccm_finished_cb+0xb2>
                do {
                    uint16_t prov_data_len = sizeof(m_prov_data_dec_t);
                    m_prov_data_dec_t prov_data;

                    // Check if decryption is ok
                    if(status != M_ERR_NO_ERROR) { status = M_ERR_PROV_DECRYPTION_FAILED; break; }
    fca4:	480b      	ldr	r0, [pc, #44]	; (fcd4 <m_prov_ccm_finished_cb+0xd8>)
    fca6:	e000      	b.n	fcaa <m_prov_ccm_finished_cb+0xae>

                    // Set IV
                    m_tb_key_set_iv_seq(prov_data.iv, 0);
                } while (0);
            } break;
            default: { status = M_ERR_PROV_UNEXPECTED; } break;
    fca8:	480b      	ldr	r0, [pc, #44]	; (fcd8 <m_prov_ccm_finished_cb+0xdc>)
        }

        if(status != M_ERR_NO_ERROR)
        {
            // Handle error
            m_prov_error_handle(status);
    fcaa:	f000 f85f 	bl	fd6c <m_prov_error_handle>
        }
    }
}
    fcae:	b00a      	add	sp, #40	; 0x28
    fcb0:	bd70      	pop	{r4, r5, r6, pc}
    fcb2:	46c0      	nop			; (mov r8, r8)
    fcb4:	10010514 	.word	0x10010514
    fcb8:	00021dc8 	.word	0x00021dc8
    fcbc:	000221c8 	.word	0x000221c8
    fcc0:	00021d48 	.word	0x00021d48
    fcc4:	00000642 	.word	0x00000642
    fcc8:	00021fc8 	.word	0x00021fc8
    fccc:	100128a4 	.word	0x100128a4
    fcd0:	0000fcdd 	.word	0x0000fcdd
    fcd4:	00000681 	.word	0x00000681
    fcd8:	00000781 	.word	0x00000781

0000fcdc <m_prov_net_key_added_cb>:
 *
 * @return Execution status (@see enum m_error)
 ****************************************************************************************
 */
__STATIC void m_prov_net_key_added_cb(uint16_t status, m_lid_t key_lid)
{
    fcdc:	b5f0      	push	{r4, r5, r6, r7, lr}
	M_PRINTF(L_PROV, "status = %d key_lid = 0x%02x", status, key_lid);
    fcde:	4b1d      	ldr	r3, [pc, #116]	; (fd54 <m_prov_net_key_added_cb+0x78>)
 *
 * @return Execution status (@see enum m_error)
 ****************************************************************************************
 */
__STATIC void m_prov_net_key_added_cb(uint16_t status, m_lid_t key_lid)
{
    fce0:	b087      	sub	sp, #28
	M_PRINTF(L_PROV, "status = %d key_lid = 0x%02x", status, key_lid);
    fce2:	681b      	ldr	r3, [r3, #0]
 *
 * @return Execution status (@see enum m_error)
 ****************************************************************************************
 */
__STATIC void m_prov_net_key_added_cb(uint16_t status, m_lid_t key_lid)
{
    fce4:	0004      	movs	r4, r0
    fce6:	9103      	str	r1, [sp, #12]
	M_PRINTF(L_PROV, "status = %d key_lid = 0x%02x", status, key_lid);
    fce8:	071b      	lsls	r3, r3, #28
    fcea:	d518      	bpl.n	fd1e <m_prov_net_key_added_cb+0x42>
    fcec:	4e1a      	ldr	r6, [pc, #104]	; (fd58 <m_prov_net_key_added_cb+0x7c>)
    fcee:	4d1b      	ldr	r5, [pc, #108]	; (fd5c <m_prov_net_key_added_cb+0x80>)
    fcf0:	0033      	movs	r3, r6
    fcf2:	002a      	movs	r2, r5
    fcf4:	0028      	movs	r0, r5
    fcf6:	4f1a      	ldr	r7, [pc, #104]	; (fd60 <m_prov_net_key_added_cb+0x84>)
    fcf8:	3346      	adds	r3, #70	; 0x46
    fcfa:	3255      	adds	r2, #85	; 0x55
    fcfc:	9300      	str	r3, [sp, #0]
    fcfe:	0039      	movs	r1, r7
    fd00:	4b18      	ldr	r3, [pc, #96]	; (fd64 <m_prov_net_key_added_cb+0x88>)
    fd02:	305e      	adds	r0, #94	; 0x5e
    fd04:	f7f4 fe52 	bl	49ac <m_print>
    fd08:	0030      	movs	r0, r6
    fd0a:	0021      	movs	r1, r4
    fd0c:	305e      	adds	r0, #94	; 0x5e
    fd0e:	9a03      	ldr	r2, [sp, #12]
    fd10:	f7f4 fe4c 	bl	49ac <m_print>
    fd14:	0028      	movs	r0, r5
    fd16:	1db9      	adds	r1, r7, #6
    fd18:	307f      	adds	r0, #127	; 0x7f
    fd1a:	f7f4 fe47 	bl	49ac <m_print>
    m_prov_res_t* p_res = p_m_prov_env->p_res;
    fd1e:	4b12      	ldr	r3, [pc, #72]	; (fd68 <m_prov_net_key_added_cb+0x8c>)
    fd20:	681b      	ldr	r3, [r3, #0]
    fd22:	685b      	ldr	r3, [r3, #4]

    if(p_res->state == M_PROV_DSTATE_WAIT_DATA_DEC)
    fd24:	001a      	movs	r2, r3
    fd26:	3258      	adds	r2, #88	; 0x58
    fd28:	7811      	ldrb	r1, [r2, #0]
    fd2a:	2911      	cmp	r1, #17
    fd2c:	d110      	bne.n	fd50 <m_prov_net_key_added_cb+0x74>
    {
        if(status == M_ERR_NO_ERROR)
    fd2e:	2c00      	cmp	r4, #0
    fd30:	d10b      	bne.n	fd4a <m_prov_net_key_added_cb+0x6e>
        {
            m_prov_cmp_t pdu;
            p_res->state  = M_PROV_DSTATE_WAIT_CMP_ACK;
    fd32:	3101      	adds	r1, #1
            p_res->reason = M_PROV_SUCCESS;
    fd34:	33fb      	adds	r3, #251	; 0xfb
    if(p_res->state == M_PROV_DSTATE_WAIT_DATA_DEC)
    {
        if(status == M_ERR_NO_ERROR)
        {
            m_prov_cmp_t pdu;
            p_res->state  = M_PROV_DSTATE_WAIT_CMP_ACK;
    fd36:	7011      	strb	r1, [r2, #0]
            p_res->reason = M_PROV_SUCCESS;
    fd38:	701c      	strb	r4, [r3, #0]

            // Send complete PDU
            pdu.type = M_PROV_PDU_COMPLETE;
    fd3a:	2308      	movs	r3, #8
    fd3c:	a805      	add	r0, sp, #20
            status   = m_prov_pdu_send((union m_prov_pdu*) &pdu, NULL);
    fd3e:	0021      	movs	r1, r4
            m_prov_cmp_t pdu;
            p_res->state  = M_PROV_DSTATE_WAIT_CMP_ACK;
            p_res->reason = M_PROV_SUCCESS;

            // Send complete PDU
            pdu.type = M_PROV_PDU_COMPLETE;
    fd40:	7003      	strb	r3, [r0, #0]
            status   = m_prov_pdu_send((union m_prov_pdu*) &pdu, NULL);
    fd42:	f7fe febb 	bl	eabc <m_prov_pdu_send>
    fd46:	1e04      	subs	r4, r0, #0
        }

        if(status != M_ERR_NO_ERROR)
    fd48:	d002      	beq.n	fd50 <m_prov_net_key_added_cb+0x74>
        {
            // handle error
            m_prov_error_handle(status);
    fd4a:	0020      	movs	r0, r4
    fd4c:	f000 f80e 	bl	fd6c <m_prov_error_handle>
        }
    }
}
    fd50:	b007      	add	sp, #28
    fd52:	bdf0      	pop	{r4, r5, r6, r7, pc}
    fd54:	10010514 	.word	0x10010514
    fd58:	000221c8 	.word	0x000221c8
    fd5c:	00021dc8 	.word	0x00021dc8
    fd60:	00021d48 	.word	0x00021d48
    fd64:	00000687 	.word	0x00000687
    fd68:	100128a4 	.word	0x100128a4

0000fd6c <m_prov_error_handle>:
 * @param[in] status Error status code
 ****************************************************************************************
 */
__STATIC void m_prov_error_handle(uint16_t status)
{
    m_prov_res_t* p_res = p_m_prov_env->p_res;
    fd6c:	4b1f      	ldr	r3, [pc, #124]	; (fdec <m_prov_error_handle+0x80>)
 *
 * @param[in] status Error status code
 ****************************************************************************************
 */
__STATIC void m_prov_error_handle(uint16_t status)
{
    fd6e:	b573      	push	{r0, r1, r4, r5, r6, lr}
    m_prov_res_t* p_res = p_m_prov_env->p_res;
    fd70:	681b      	ldr	r3, [r3, #0]
 *
 * @param[in] status Error status code
 ****************************************************************************************
 */
__STATIC void m_prov_error_handle(uint16_t status)
{
    fd72:	0004      	movs	r4, r0
    m_prov_res_t* p_res = p_m_prov_env->p_res;
    fd74:	685d      	ldr	r5, [r3, #4]

    if(p_res != NULL)
    fd76:	2d00      	cmp	r5, #0
    fd78:	d036      	beq.n	fde8 <m_prov_error_handle+0x7c>
    fd7a:	002e      	movs	r6, r5
    {
        // If not idle inform application
        if(   (status == M_ERR_BEARER_CLOSED)
    fd7c:	4b1c      	ldr	r3, [pc, #112]	; (fdf0 <m_prov_error_handle+0x84>)
    fd7e:	3658      	adds	r6, #88	; 0x58
    fd80:	4298      	cmp	r0, r3
    fd82:	d005      	beq.n	fd90 <m_prov_error_handle+0x24>
           || (status == M_ERR_ECDH_FAILED)
    fd84:	4b1b      	ldr	r3, [pc, #108]	; (fdf4 <m_prov_error_handle+0x88>)
    fd86:	4298      	cmp	r0, r3
    fd88:	d002      	beq.n	fd90 <m_prov_error_handle+0x24>
           || (p_res->state != M_PROV_DSTATE_IDLE))
    fd8a:	7833      	ldrb	r3, [r6, #0]
    fd8c:	2b01      	cmp	r3, #1
    fd8e:	d009      	beq.n	fda4 <m_prov_error_handle+0x38>
        {
            // Reset provisioning state
            m_tb_state_set_prov_state(M_TB_STATE_PROV_STATE_UNPROV);
    fd90:	2000      	movs	r0, #0
    fd92:	f004 f9b1 	bl	140f8 <m_tb_state_set_prov_state>
            p_res->reason = M_PROV_FAIL;
    fd96:	002b      	movs	r3, r5
    fd98:	2002      	movs	r0, #2
    fd9a:	33fb      	adds	r3, #251	; 0xfb
    fd9c:	7018      	strb	r0, [r3, #0]
            // inform application that provisioning failed
            m_prov_state_send(M_PROV_FAILED, status);
    fd9e:	0021      	movs	r1, r4
    fda0:	f7fe fe51 	bl	ea46 <m_prov_state_send>
        }

        // peer send the pairing failed, wait for peer to close link
        if(p_res->state == M_PROV_DSTATE_PEER_FAILED)
    fda4:	7833      	ldrb	r3, [r6, #0]
    fda6:	2b14      	cmp	r3, #20
    fda8:	d108      	bne.n	fdbc <m_prov_error_handle+0x50>
        {
            p_res->state = M_PROV_DSTATE_WAIT_LINK_CLOSE;
            m_tb_timer_set(&(p_res->timer_link_timeout), M_PROV_LINK_FAILED_TIMEOUT);
    fdaa:	0028      	movs	r0, r5
    fdac:	21fa      	movs	r1, #250	; 0xfa
        }

        // peer send the pairing failed, wait for peer to close link
        if(p_res->state == M_PROV_DSTATE_PEER_FAILED)
        {
            p_res->state = M_PROV_DSTATE_WAIT_LINK_CLOSE;
    fdae:	3301      	adds	r3, #1
    fdb0:	7033      	strb	r3, [r6, #0]
            m_tb_timer_set(&(p_res->timer_link_timeout), M_PROV_LINK_FAILED_TIMEOUT);
    fdb2:	3020      	adds	r0, #32
    fdb4:	0089      	lsls	r1, r1, #2
    fdb6:	f005 faa5 	bl	15304 <m_tb_timer_set>
    fdba:	e015      	b.n	fde8 <m_prov_error_handle+0x7c>
        }
        // Check if pairing failed PDU should be sent
        else if((p_res->state != M_PROV_DSTATE_IDLE) && (p_res->state != M_PROV_DSTATE_LINK_CLOSE))
    fdbc:	2b01      	cmp	r3, #1
    fdbe:	d013      	beq.n	fde8 <m_prov_error_handle+0x7c>
    fdc0:	2b16      	cmp	r3, #22
    fdc2:	d011      	beq.n	fde8 <m_prov_error_handle+0x7c>
        {
            m_prov_failed_t pdu;

            // assign error to another code
            if(M_ERR_GRP(status) != M_ERR_PROVISIONING_CODE)
    fdc4:	b2e3      	uxtb	r3, r4
    fdc6:	2b81      	cmp	r3, #129	; 0x81
    fdc8:	d000      	beq.n	fdcc <m_prov_error_handle+0x60>
            {
                status = M_ERR_PROV_UNEXPECTED;
    fdca:	4c0b      	ldr	r4, [pc, #44]	; (fdf8 <m_prov_error_handle+0x8c>)
            }

            // Send Error PDU
            pdu.type     = M_PROV_PDU_FAILED;
    fdcc:	2309      	movs	r3, #9
    fdce:	a801      	add	r0, sp, #4
    fdd0:	7003      	strb	r3, [r0, #0]
            pdu.err_code = M_SUBERR(status);
            p_res->state = M_PROV_DSTATE_WAIT_FAILED_ACK;
    fdd2:	330a      	adds	r3, #10
                status = M_ERR_PROV_UNEXPECTED;
            }

            // Send Error PDU
            pdu.type     = M_PROV_PDU_FAILED;
            pdu.err_code = M_SUBERR(status);
    fdd4:	0a24      	lsrs	r4, r4, #8
            p_res->state = M_PROV_DSTATE_WAIT_FAILED_ACK;
    fdd6:	7033      	strb	r3, [r6, #0]
            status = m_prov_pdu_send((union m_prov_pdu*) &pdu, NULL);
    fdd8:	2100      	movs	r1, #0
                status = M_ERR_PROV_UNEXPECTED;
            }

            // Send Error PDU
            pdu.type     = M_PROV_PDU_FAILED;
            pdu.err_code = M_SUBERR(status);
    fdda:	7044      	strb	r4, [r0, #1]
            p_res->state = M_PROV_DSTATE_WAIT_FAILED_ACK;
            status = m_prov_pdu_send((union m_prov_pdu*) &pdu, NULL);
    fddc:	f7fe fe6e 	bl	eabc <m_prov_pdu_send>

            // if an unexpected error occurs
            if(status != M_ERR_NO_ERROR)
    fde0:	2800      	cmp	r0, #0
    fde2:	d001      	beq.n	fde8 <m_prov_error_handle+0x7c>
            {
                // Go back to idle state
                p_res->state = M_PROV_DSTATE_IDLE;
    fde4:	2301      	movs	r3, #1
    fde6:	7033      	strb	r3, [r6, #0]
            }
        }
    }
}
    fde8:	bd73      	pop	{r0, r1, r4, r5, r6, pc}
    fdea:	46c0      	nop			; (mov r8, r8)
    fdec:	100128a4 	.word	0x100128a4
    fdf0:	00000882 	.word	0x00000882
    fdf4:	00000b82 	.word	0x00000b82
    fdf8:	00000781 	.word	0x00000781

0000fdfc <m_prov_link_timeout_cb>:
 * @param[in] p_dummy not used
 ****************************************************************************************
 */
__STATIC void m_prov_link_timeout_cb(void * p_dummy)
{
    m_prov_res_t* p_res = p_m_prov_env->p_res;
    fdfc:	4b1e      	ldr	r3, [pc, #120]	; (fe78 <m_prov_link_timeout_cb+0x7c>)
 *
 * @param[in] p_dummy not used
 ****************************************************************************************
 */
__STATIC void m_prov_link_timeout_cb(void * p_dummy)
{
    fdfe:	b573      	push	{r0, r1, r4, r5, r6, lr}
    m_prov_res_t* p_res = p_m_prov_env->p_res;
    fe00:	681b      	ldr	r3, [r3, #0]
    fe02:	6858      	ldr	r0, [r3, #4]

    if(p_res != NULL)
    fe04:	2800      	cmp	r0, #0
    fe06:	d036      	beq.n	fe76 <m_prov_link_timeout_cb+0x7a>
    {
        switch(p_res->state)
    fe08:	0002      	movs	r2, r0
    fe0a:	0005      	movs	r5, r0
    fe0c:	3258      	adds	r2, #88	; 0x58
    fe0e:	7811      	ldrb	r1, [r2, #0]
    fe10:	35fb      	adds	r5, #251	; 0xfb
    fe12:	2916      	cmp	r1, #22
    fe14:	d11d      	bne.n	fe52 <m_prov_link_timeout_cb+0x56>
            // if sending close PDU
            // mark the link closed and clean-up PB-ADV
            case M_PROV_DSTATE_LINK_CLOSE:
            {
                // Close the link
                M_PRINTF(L_PROV, "prov_link timeout");
    fe16:	4b19      	ldr	r3, [pc, #100]	; (fe7c <m_prov_link_timeout_cb+0x80>)
    fe18:	681b      	ldr	r3, [r3, #0]
    fe1a:	071b      	lsls	r3, r3, #28
    fe1c:	d515      	bpl.n	fe4a <m_prov_link_timeout_cb+0x4e>
    fe1e:	4c18      	ldr	r4, [pc, #96]	; (fe80 <m_prov_link_timeout_cb+0x84>)
    fe20:	4b18      	ldr	r3, [pc, #96]	; (fe84 <m_prov_link_timeout_cb+0x88>)
    fe22:	0022      	movs	r2, r4
    fe24:	0020      	movs	r0, r4
    fe26:	4e18      	ldr	r6, [pc, #96]	; (fe88 <m_prov_link_timeout_cb+0x8c>)
    fe28:	337b      	adds	r3, #123	; 0x7b
    fe2a:	0031      	movs	r1, r6
    fe2c:	3255      	adds	r2, #85	; 0x55
    fe2e:	9300      	str	r3, [sp, #0]
    fe30:	305e      	adds	r0, #94	; 0x5e
    fe32:	4b16      	ldr	r3, [pc, #88]	; (fe8c <m_prov_link_timeout_cb+0x90>)
    fe34:	f7f4 fdba 	bl	49ac <m_print>
    fe38:	4815      	ldr	r0, [pc, #84]	; (fe90 <m_prov_link_timeout_cb+0x94>)
    fe3a:	3012      	adds	r0, #18
    fe3c:	f7f4 fdb6 	bl	49ac <m_print>
    fe40:	0020      	movs	r0, r4
    fe42:	1db1      	adds	r1, r6, #6
    fe44:	307f      	adds	r0, #127	; 0x7f
    fe46:	f7f4 fdb1 	bl	49ac <m_print>
                m_prov_link_closed(p_res->reason);
    fe4a:	7828      	ldrb	r0, [r5, #0]
    fe4c:	f000 f9be 	bl	101cc <m_prov_link_closed>
            } break;
    fe50:	e011      	b.n	fe76 <m_prov_link_timeout_cb+0x7a>
            case M_PROV_DSTATE_WAIT_LINK_CLOSE:
            // During provisioning
            // Send a link close (with timeout reason)
            default:
            {
                p_res->state = M_PROV_DSTATE_LINK_CLOSE;
    fe52:	2116      	movs	r1, #22
    fe54:	7011      	strb	r1, [r2, #0]

                if (p_m_prov_env->bearer_type == M_PROV_BEARER_ADV)
    fe56:	7c1b      	ldrb	r3, [r3, #16]
    fe58:	2b01      	cmp	r3, #1
    fe5a:	d104      	bne.n	fe66 <m_prov_link_timeout_cb+0x6a>
                {
                    // Link Close message must be sent at least 3 times, start the timer for that purpose
                    m_tb_timer_set(&(p_res->timer_link_timeout), M_PROV_LINK_CLOSE_TIMEOUT);
    fe5c:	31df      	adds	r1, #223	; 0xdf
    fe5e:	3020      	adds	r0, #32
    fe60:	31ff      	adds	r1, #255	; 0xff
    fe62:	f005 fa4f 	bl	15304 <m_tb_timer_set>
                }

                // If reason already set, do not change the reason
                if (p_res->reason == M_PROV_NO_REASON)
    fe66:	782b      	ldrb	r3, [r5, #0]
    fe68:	2bff      	cmp	r3, #255	; 0xff
    fe6a:	d101      	bne.n	fe70 <m_prov_link_timeout_cb+0x74>
                {
                    p_res->reason = M_PROV_TIMEOUT;
    fe6c:	3bfe      	subs	r3, #254	; 0xfe
    fe6e:	702b      	strb	r3, [r5, #0]
                }

                // Send the message
                m_prov_bearer_close(p_res->reason);
    fe70:	7828      	ldrb	r0, [r5, #0]
    fe72:	f001 f9db 	bl	1122c <m_prov_bearer_close>
            } break;
        }
    }
}
    fe76:	bd73      	pop	{r0, r1, r4, r5, r6, pc}
    fe78:	100128a4 	.word	0x100128a4
    fe7c:	10010514 	.word	0x10010514
    fe80:	00021dc8 	.word	0x00021dc8
    fe84:	000221c8 	.word	0x000221c8
    fe88:	00021d48 	.word	0x00021d48
    fe8c:	000006ef 	.word	0x000006ef
    fe90:	00022248 	.word	0x00022248

0000fe94 <m_prov_trans_timeout_cb>:
 * @param[in] p_dummy not used
 ****************************************************************************************
 */
__STATIC void m_prov_trans_timeout_cb(void* p_dummy)
{
    m_prov_res_t* p_res = p_m_prov_env->p_res;
    fe94:	4b0e      	ldr	r3, [pc, #56]	; (fed0 <m_prov_trans_timeout_cb+0x3c>)
 *
 * @param[in] p_dummy not used
 ****************************************************************************************
 */
__STATIC void m_prov_trans_timeout_cb(void* p_dummy)
{
    fe96:	b510      	push	{r4, lr}
    m_prov_res_t* p_res = p_m_prov_env->p_res;
    fe98:	681b      	ldr	r3, [r3, #0]
    fe9a:	685c      	ldr	r4, [r3, #4]

    // Send a link close (with timeout reason)
    if((p_res != NULL) && (p_res->state != M_PROV_DSTATE_IDLE))
    fe9c:	2c00      	cmp	r4, #0
    fe9e:	d015      	beq.n	fecc <m_prov_trans_timeout_cb+0x38>
    fea0:	0023      	movs	r3, r4
    fea2:	3358      	adds	r3, #88	; 0x58
    fea4:	781a      	ldrb	r2, [r3, #0]
    fea6:	2a01      	cmp	r2, #1
    fea8:	d010      	beq.n	fecc <m_prov_trans_timeout_cb+0x38>
    {
        p_res->state = M_PROV_DSTATE_LINK_CLOSE;
    feaa:	2216      	movs	r2, #22

        // send link close message
        m_tb_timer_set(&(p_res->timer_link_timeout), M_PROV_LINK_CLOSE_TIMEOUT);
    feac:	0020      	movs	r0, r4
    feae:	21fa      	movs	r1, #250	; 0xfa
    m_prov_res_t* p_res = p_m_prov_env->p_res;

    // Send a link close (with timeout reason)
    if((p_res != NULL) && (p_res->state != M_PROV_DSTATE_IDLE))
    {
        p_res->state = M_PROV_DSTATE_LINK_CLOSE;
    feb0:	701a      	strb	r2, [r3, #0]

        // send link close message
        m_tb_timer_set(&(p_res->timer_link_timeout), M_PROV_LINK_CLOSE_TIMEOUT);
    feb2:	3020      	adds	r0, #32
    feb4:	0049      	lsls	r1, r1, #1

        // If reason already set, do not change the reason
        if(p_res->reason == M_PROV_NO_REASON)
    feb6:	34fb      	adds	r4, #251	; 0xfb
    if((p_res != NULL) && (p_res->state != M_PROV_DSTATE_IDLE))
    {
        p_res->state = M_PROV_DSTATE_LINK_CLOSE;

        // send link close message
        m_tb_timer_set(&(p_res->timer_link_timeout), M_PROV_LINK_CLOSE_TIMEOUT);
    feb8:	f005 fa24 	bl	15304 <m_tb_timer_set>

        // If reason already set, do not change the reason
        if(p_res->reason == M_PROV_NO_REASON)
    febc:	7823      	ldrb	r3, [r4, #0]
    febe:	2bff      	cmp	r3, #255	; 0xff
    fec0:	d101      	bne.n	fec6 <m_prov_trans_timeout_cb+0x32>
        {
            p_res->reason = M_PROV_TIMEOUT;
    fec2:	3bfe      	subs	r3, #254	; 0xfe
    fec4:	7023      	strb	r3, [r4, #0]
        }

        m_prov_bearer_close(M_PROV_TIMEOUT);
    fec6:	2001      	movs	r0, #1
    fec8:	f001 f9b0 	bl	1122c <m_prov_bearer_close>
    }
}
    fecc:	bd10      	pop	{r4, pc}
    fece:	46c0      	nop			; (mov r8, r8)
    fed0:	100128a4 	.word	0x100128a4

0000fed4 <m_prov_param_req>:
 ****************************************************************************************
 */
__STATIC void m_prov_param_req(void* p_dummy)
{
    // Request application to provide provisioning parameters
    if(p_m_api_cb && p_m_api_cb->cb_prov_param_req)
    fed4:	4b04      	ldr	r3, [pc, #16]	; (fee8 <m_prov_param_req+0x14>)
 *
 * @param[in] p_dummy not used
 ****************************************************************************************
 */
__STATIC void m_prov_param_req(void* p_dummy)
{
    fed6:	b510      	push	{r4, lr}
    // Request application to provide provisioning parameters
    if(p_m_api_cb && p_m_api_cb->cb_prov_param_req)
    fed8:	681b      	ldr	r3, [r3, #0]
    feda:	2b00      	cmp	r3, #0
    fedc:	d003      	beq.n	fee6 <m_prov_param_req+0x12>
    fede:	68db      	ldr	r3, [r3, #12]
    fee0:	2b00      	cmp	r3, #0
    fee2:	d000      	beq.n	fee6 <m_prov_param_req+0x12>
    	p_m_api_cb->cb_prov_param_req();
    fee4:	4798      	blx	r3
}
    fee6:	bd10      	pop	{r4, pc}
    fee8:	10012698 	.word	0x10012698

0000feec <m_prov_init>:
 * FUNCTIONS
 ****************************************************************************************
 */

uint16_t m_prov_init(bool reset, void *p_env, const m_cfg_t* p_cfg)
{
    feec:	b510      	push	{r4, lr}
    feee:	4c12      	ldr	r4, [pc, #72]	; (ff38 <m_prov_init+0x4c>)
    if (!reset)
    fef0:	2800      	cmp	r0, #0
    fef2:	d10a      	bne.n	ff0a <m_prov_init+0x1e>
        // Clean-up link information
        p_m_prov_env->bearer_type     = M_PROV_BEARER_NONE;
        p_m_prov_env->p_res           = NULL;
        p_m_prov_env->p_adv_res       = NULL;
        p_m_prov_env->p_gatt_res      = NULL;
        p_m_prov_env->adv_bearer_lid  = M_INVALID_LID;
    fef4:	23ff      	movs	r3, #255	; 0xff
        // Get environment for provisioning device
        p_m_prov_env  = (m_prov_env_t*) p_env_cursor;
        p_env_cursor += CO_ALIGN4_HI(sizeof(p_m_prov_env));

        // Clean-up link information
        p_m_prov_env->bearer_type     = M_PROV_BEARER_NONE;
    fef6:	7408      	strb	r0, [r1, #16]
        p_m_prov_env->p_res           = NULL;
    fef8:	6048      	str	r0, [r1, #4]
        p_m_prov_env->p_adv_res       = NULL;
    fefa:	6088      	str	r0, [r1, #8]
        p_m_prov_env->p_gatt_res      = NULL;
    fefc:	60c8      	str	r0, [r1, #12]
        p_m_prov_env->adv_bearer_lid  = M_INVALID_LID;
    fefe:	748b      	strb	r3, [r1, #18]
        p_m_prov_env->bearer_lid      = M_INVALID_LID;
    ff00:	744b      	strb	r3, [r1, #17]
    if (!reset)
    {
        uint8_t* p_env_cursor = (uint8_t*) p_env;

        // Get environment for provisioning device
        p_m_prov_env  = (m_prov_env_t*) p_env_cursor;
    ff02:	6021      	str	r1, [r4, #0]
        p_m_prov_env->p_gatt_res      = NULL;
        p_m_prov_env->adv_bearer_lid  = M_INVALID_LID;
        p_m_prov_env->bearer_lid      = M_INVALID_LID;

        // Initialize interface with bearer
        m_prov_bearer_init();
    ff04:	f001 f968 	bl	111d8 <m_prov_bearer_init>
    ff08:	e013      	b.n	ff32 <m_prov_init+0x46>
    }
    else
    {
        // close ADV resources
        if(p_m_prov_env->p_adv_res != NULL)
    ff0a:	6823      	ldr	r3, [r4, #0]
    ff0c:	6898      	ldr	r0, [r3, #8]
    ff0e:	2800      	cmp	r0, #0
    ff10:	d001      	beq.n	ff16 <m_prov_init+0x2a>
        {
            m_al_free(p_m_prov_env->p_adv_res);
    ff12:	f7f5 fb63 	bl	55dc <m_al_free>
        }
        // close GATT resources
        if(p_m_prov_env->p_gatt_res != NULL)
    ff16:	6823      	ldr	r3, [r4, #0]
    ff18:	68d8      	ldr	r0, [r3, #12]
    ff1a:	2800      	cmp	r0, #0
    ff1c:	d001      	beq.n	ff22 <m_prov_init+0x36>
        {
            m_al_free(p_m_prov_env->p_gatt_res);
    ff1e:	f7f5 fb5d 	bl	55dc <m_al_free>
        }

        // Clean-up provisioning resources
        if(p_m_prov_env->p_res != NULL)
    ff22:	6823      	ldr	r3, [r4, #0]
    ff24:	6858      	ldr	r0, [r3, #4]
    ff26:	2800      	cmp	r0, #0
    ff28:	d001      	beq.n	ff2e <m_prov_init+0x42>
        {
            m_al_free(p_m_prov_env->p_res);
    ff2a:	f7f5 fb57 	bl	55dc <m_al_free>
        }

        p_m_prov_env = NULL;
    ff2e:	2300      	movs	r3, #0
    ff30:	6023      	str	r3, [r4, #0]
    }

    return (sizeof(m_prov_env_t));
}
    ff32:	2014      	movs	r0, #20
    ff34:	bd10      	pop	{r4, pc}
    ff36:	46c0      	nop			; (mov r8, r8)
    ff38:	100128a4 	.word	0x100128a4

0000ff3c <m_prov_get_env_size>:

uint16_t m_prov_get_env_size(const m_cfg_t* p_cfg)
{
    return (sizeof(m_prov_env_t));
}
    ff3c:	2014      	movs	r0, #20
    ff3e:	4770      	bx	lr

0000ff40 <m_prov_start>:
 *
 * @return Execution status code
 ****************************************************************************************
 */
uint16_t m_prov_start(void)
{
    ff40:	b570      	push	{r4, r5, r6, lr}
    uint16_t status = M_ERR_COMMAND_DISALLOWED;
    m_prov_res_t* p_res = p_m_prov_env->p_res;
    ff42:	4e12      	ldr	r6, [pc, #72]	; (ff8c <m_prov_start+0x4c>)
    ff44:	6833      	ldr	r3, [r6, #0]

    if(p_res == NULL)
    ff46:	685c      	ldr	r4, [r3, #4]
    ff48:	2c00      	cmp	r4, #0
    ff4a:	d11d      	bne.n	ff88 <m_prov_start+0x48>
    {
        // Create a dedicated environment for provisioning
        p_res = (m_prov_res_t*) m_al_malloc(sizeof(m_prov_res_t));
    ff4c:	20fc      	movs	r0, #252	; 0xfc
    ff4e:	f7f5 fb40 	bl	55d2 <m_al_malloc>

        p_res->state = M_PROV_DSTATE_IDLE;
    ff52:	0003      	movs	r3, r0
    m_prov_res_t* p_res = p_m_prov_env->p_res;

    if(p_res == NULL)
    {
        // Create a dedicated environment for provisioning
        p_res = (m_prov_res_t*) m_al_malloc(sizeof(m_prov_res_t));
    ff54:	0005      	movs	r5, r0

        p_res->state = M_PROV_DSTATE_IDLE;
    ff56:	2001      	movs	r0, #1
    ff58:	3358      	adds	r3, #88	; 0x58
    ff5a:	7018      	strb	r0, [r3, #0]
        p_m_prov_env->p_res = p_res;
    ff5c:	6833      	ldr	r3, [r6, #0]
    ff5e:	605d      	str	r5, [r3, #4]

        // Initialize timer
        p_res->timer_link_timeout.p_env   = NULL;
        p_res->timer_link_timeout.cb      = m_prov_link_timeout_cb;
    ff60:	4b0b      	ldr	r3, [pc, #44]	; (ff90 <m_prov_start+0x50>)

        p_res->state = M_PROV_DSTATE_IDLE;
        p_m_prov_env->p_res = p_res;

        // Initialize timer
        p_res->timer_link_timeout.p_env   = NULL;
    ff62:	62ac      	str	r4, [r5, #40]	; 0x28
        p_res->timer_link_timeout.cb      = m_prov_link_timeout_cb;
    ff64:	626b      	str	r3, [r5, #36]	; 0x24
        p_res->timer_trans_timeout.p_env  = NULL;
        p_res->timer_trans_timeout.cb     = m_prov_trans_timeout_cb;
    ff66:	4b0b      	ldr	r3, [pc, #44]	; (ff94 <m_prov_start+0x54>)
        p_m_prov_env->p_res = p_res;

        // Initialize timer
        p_res->timer_link_timeout.p_env   = NULL;
        p_res->timer_link_timeout.cb      = m_prov_link_timeout_cb;
        p_res->timer_trans_timeout.p_env  = NULL;
    ff68:	616c      	str	r4, [r5, #20]
        p_res->timer_trans_timeout.cb     = m_prov_trans_timeout_cb;
    ff6a:	612b      	str	r3, [r5, #16]

        // Keep in mind that provisioning has been started
        m_tb_state_set_prov_state(M_TB_STATE_PROV_STATE_BEING_PROV);
    ff6c:	f004 f8c4 	bl	140f8 <m_tb_state_set_prov_state>

        p_res->job.cb    = m_prov_param_req;
    ff70:	4b09      	ldr	r3, [pc, #36]	; (ff98 <m_prov_start+0x58>)
        p_res->job.p_env = NULL;
        m_al_djob_reg(&(p_res->job));
    ff72:	0028      	movs	r0, r5
        p_res->timer_trans_timeout.cb     = m_prov_trans_timeout_cb;

        // Keep in mind that provisioning has been started
        m_tb_state_set_prov_state(M_TB_STATE_PROV_STATE_BEING_PROV);

        p_res->job.cb    = m_prov_param_req;
    ff74:	60ab      	str	r3, [r5, #8]
        p_res->job.p_env = NULL;
    ff76:	606c      	str	r4, [r5, #4]
        m_al_djob_reg(&(p_res->job));
    ff78:	f7f4 fe88 	bl	4c8c <m_al_djob_reg>

        status = M_ERR_NO_ERROR;
		m_prov_state_send(M_PROV_STARTED, status);
    ff7c:	0020      	movs	r0, r4
    ff7e:	0021      	movs	r1, r4
    ff80:	f7fe fd61 	bl	ea46 <m_prov_state_send>

        p_res->job.cb    = m_prov_param_req;
        p_res->job.p_env = NULL;
        m_al_djob_reg(&(p_res->job));

        status = M_ERR_NO_ERROR;
    ff84:	0020      	movs	r0, r4
    ff86:	e000      	b.n	ff8a <m_prov_start+0x4a>
 * @return Execution status code
 ****************************************************************************************
 */
uint16_t m_prov_start(void)
{
    uint16_t status = M_ERR_COMMAND_DISALLOWED;
    ff88:	4804      	ldr	r0, [pc, #16]	; (ff9c <m_prov_start+0x5c>)
        status = M_ERR_NO_ERROR;
		m_prov_state_send(M_PROV_STARTED, status);
    }

    return (status);
}
    ff8a:	bd70      	pop	{r4, r5, r6, pc}
    ff8c:	100128a4 	.word	0x100128a4
    ff90:	0000fdfd 	.word	0x0000fdfd
    ff94:	0000fe95 	.word	0x0000fe95
    ff98:	0000fed5 	.word	0x0000fed5
    ff9c:	00000282 	.word	0x00000282

0000ffa0 <m_prov_oob_auth_rsp>:

void m_prov_oob_auth_rsp(bool accept, uint8_t auth_size, const uint8_t* p_auth_data)
{
    m_prov_res_t* p_res = p_m_prov_env->p_res;
    ffa0:	4b2f      	ldr	r3, [pc, #188]	; (10060 <m_prov_oob_auth_rsp+0xc0>)

    return (status);
}

void m_prov_oob_auth_rsp(bool accept, uint8_t auth_size, const uint8_t* p_auth_data)
{
    ffa2:	b5f0      	push	{r4, r5, r6, r7, lr}
    m_prov_res_t* p_res = p_m_prov_env->p_res;
    ffa4:	681b      	ldr	r3, [r3, #0]

    return (status);
}

void m_prov_oob_auth_rsp(bool accept, uint8_t auth_size, const uint8_t* p_auth_data)
{
    ffa6:	b085      	sub	sp, #20
    m_prov_res_t* p_res = p_m_prov_env->p_res;
    ffa8:	685c      	ldr	r4, [r3, #4]

    return (status);
}

void m_prov_oob_auth_rsp(bool accept, uint8_t auth_size, const uint8_t* p_auth_data)
{
    ffaa:	000d      	movs	r5, r1
    ffac:	0017      	movs	r7, r2
    do
    {
        uint16_t status = M_ERR_NO_ERROR;

        // ensure that provisioning operation exist
        if(p_res == NULL) { break; }
    ffae:	2c00      	cmp	r4, #0
    ffb0:	d053      	beq.n	1005a <m_prov_oob_auth_rsp+0xba>

        if(   (p_res->state != M_PROV_DSTATE_WAIT_AUTH_INPUT)
    ffb2:	0026      	movs	r6, r4
    ffb4:	3658      	adds	r6, #88	; 0x58
    ffb6:	7833      	ldrb	r3, [r6, #0]
    ffb8:	3b05      	subs	r3, #5
    ffba:	2b02      	cmp	r3, #2
    ffbc:	d84d      	bhi.n	1005a <m_prov_oob_auth_rsp+0xba>
           && (p_res->state != M_PROV_DSTATE_WAIT_RND_COMP))
        {
            break; // Ignore Message
        }

        if(   (!accept) || (auth_size > p_res->auth_size)
    ffbe:	2800      	cmp	r0, #0
    ffc0:	d00b      	beq.n	ffda <m_prov_oob_auth_rsp+0x3a>
    ffc2:	0023      	movs	r3, r4
    ffc4:	3357      	adds	r3, #87	; 0x57
    ffc6:	781b      	ldrb	r3, [r3, #0]
    ffc8:	428b      	cmp	r3, r1
    ffca:	d306      	bcc.n	ffda <m_prov_oob_auth_rsp+0x3a>
           || ((p_res->auth_method == M_PROV_AUTH_STATIC_OOB) && auth_size != M_OOB_AUTH_DATA_LEN))
    ffcc:	0023      	movs	r3, r4
    ffce:	3355      	adds	r3, #85	; 0x55
    ffd0:	781b      	ldrb	r3, [r3, #0]
    ffd2:	2b01      	cmp	r3, #1
    ffd4:	d105      	bne.n	ffe2 <m_prov_oob_auth_rsp+0x42>
    ffd6:	2910      	cmp	r1, #16
    ffd8:	d003      	beq.n	ffe2 <m_prov_oob_auth_rsp+0x42>
        {
            // Consider pairing failed
            m_prov_error_handle(M_ERR_PROV_UNEXPECTED);
    ffda:	4822      	ldr	r0, [pc, #136]	; (10064 <m_prov_oob_auth_rsp+0xc4>)
    ffdc:	f7ff fec6 	bl	fd6c <m_prov_error_handle>
            break;
    ffe0:	e03b      	b.n	1005a <m_prov_oob_auth_rsp+0xba>
        }

        // Initialize authentication value with zeros
        memset(&(p_res->comp_data[M_PROV_COMP_AUTH_VALUE_OFFSET]), 0, M_OOB_AUTH_DATA_LEN);
    ffe2:	0023      	movs	r3, r4
    ffe4:	338a      	adds	r3, #138	; 0x8a
    ffe6:	2210      	movs	r2, #16
    ffe8:	0018      	movs	r0, r3
    ffea:	2100      	movs	r1, #0
    ffec:	9301      	str	r3, [sp, #4]
    ffee:	f005 fd2d 	bl	15a4c <memset>

        // Alphanumeric value
        if(   ((p_res->auth_method == M_PROV_AUTH_OUTPUT_OOB) && (p_res->auth_action == M_PROV_OUT_OOB_ALPHANUMERIC))
    fff2:	6d62      	ldr	r2, [r4, #84]	; 0x54
    fff4:	4b1c      	ldr	r3, [pc, #112]	; (10068 <m_prov_oob_auth_rsp+0xc8>)
    fff6:	4013      	ands	r3, r2
    fff8:	4a1c      	ldr	r2, [pc, #112]	; (1006c <m_prov_oob_auth_rsp+0xcc>)
    fffa:	4293      	cmp	r3, r2
    fffc:	d002      	beq.n	10004 <m_prov_oob_auth_rsp+0x64>
           || ((p_res->auth_method == M_PROV_AUTH_INPUT_OOB)  && (p_res->auth_action == M_PROV_IN_OOB_ALPHANUMERIC)))
    fffe:	4a1c      	ldr	r2, [pc, #112]	; (10070 <m_prov_oob_auth_rsp+0xd0>)
   10000:	4293      	cmp	r3, r2
   10002:	d106      	bne.n	10012 <m_prov_oob_auth_rsp+0x72>
        {
            // Swipe byte to have a value MSB
            co_bswap(&(p_res->comp_data[M_PROV_COMP_AUTH_VALUE_OFFSET + M_OOB_AUTH_DATA_LEN - auth_size]),
   10004:	1b60      	subs	r0, r4, r5
   10006:	b2aa      	uxth	r2, r5
   10008:	309a      	adds	r0, #154	; 0x9a
   1000a:	0039      	movs	r1, r7
   1000c:	f7fe fd12 	bl	ea34 <co_bswap>
   10010:	e004      	b.n	1001c <m_prov_oob_auth_rsp+0x7c>
                     p_auth_data, auth_size);
        }
        // numeric value LSB
        else
        {
            memcpy(&(p_res->comp_data[M_PROV_COMP_AUTH_VALUE_OFFSET]), p_auth_data, auth_size);
   10012:	002a      	movs	r2, r5
   10014:	0039      	movs	r1, r7
   10016:	9801      	ldr	r0, [sp, #4]
   10018:	f005 fcda 	bl	159d0 <memcpy>
        }

        // mark that authentication data received properly
        SETB(p_res->comp_inputs, M_PROV_COMP_AUTH_DATA, true);
   1001c:	2201      	movs	r2, #1
   1001e:	3459      	adds	r4, #89	; 0x59
   10020:	7821      	ldrb	r1, [r4, #0]
   10022:	430a      	orrs	r2, r1
   10024:	7022      	strb	r2, [r4, #0]

        // Input data received
        if(p_res->state == M_PROV_DSTATE_WAIT_AUTH_INPUT)
   10026:	7833      	ldrb	r3, [r6, #0]
   10028:	2b05      	cmp	r3, #5
   1002a:	d108      	bne.n	1003e <m_prov_oob_auth_rsp+0x9e>
        {
            // Send that user has entered input data
            m_prov_input_cmp_t pdu;
            pdu.type = M_PROV_PDU_INPUT_COMPLETE;
   1002c:	a803      	add	r0, sp, #12
   1002e:	3b01      	subs	r3, #1
   10030:	7003      	strb	r3, [r0, #0]
            p_res->state = M_PROV_DSTATE_WAIT_CFM;
   10032:	3302      	adds	r3, #2
   10034:	7033      	strb	r3, [r6, #0]
            status = m_prov_pdu_send((union m_prov_pdu*) &pdu, NULL);
   10036:	2100      	movs	r1, #0
   10038:	f7fe fd40 	bl	eabc <m_prov_pdu_send>
   1003c:	e009      	b.n	10052 <m_prov_oob_auth_rsp+0xb2>
        }
        else if(p_res->state == M_PROV_DSTATE_WAIT_RND_COMP)
   1003e:	2b07      	cmp	r3, #7
   10040:	d10b      	bne.n	1005a <m_prov_oob_auth_rsp+0xba>
        {
            // check if all expected data for confirmation computation has been received
            if(   GETB(p_res->comp_inputs, M_PROV_COMP_CFM_SALT)
   10042:	3b01      	subs	r3, #1
   10044:	400b      	ands	r3, r1
   10046:	2b06      	cmp	r3, #6
   10048:	d107      	bne.n	1005a <m_prov_oob_auth_rsp+0xba>
               && GETB(p_res->comp_inputs, M_PROV_COMP_ECDH_SECRET))
            {
                // compute device random data (local)
                status = m_tb_sec_rand_start(M_TB_SEC_TOKEN_PROVISIONING, m_prov_rand_finished_cb);
   1004a:	490a      	ldr	r1, [pc, #40]	; (10074 <m_prov_oob_auth_rsp+0xd4>)
   1004c:	2005      	movs	r0, #5
   1004e:	f003 ffd2 	bl	13ff6 <m_tb_sec_rand_start>
            }
        }

        if(status != M_ERR_NO_ERROR)
   10052:	2800      	cmp	r0, #0
   10054:	d001      	beq.n	1005a <m_prov_oob_auth_rsp+0xba>
        {
            // handle pairing failed
            m_prov_error_handle(status);
   10056:	f7ff fe89 	bl	fd6c <m_prov_error_handle>
        }

    } while(0);
}
   1005a:	b005      	add	sp, #20
   1005c:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1005e:	46c0      	nop			; (mov r8, r8)
   10060:	100128a4 	.word	0x100128a4
   10064:	00000781 	.word	0x00000781
   10068:	00ffff00 	.word	0x00ffff00
   1006c:	00100200 	.word	0x00100200
   10070:	00080300 	.word	0x00080300
   10074:	0000f689 	.word	0x0000f689

00010078 <m_prov_param_rsp>:

void m_prov_param_rsp(void *p_param)
{
	M_PRINTF(L_PROV, "");
   10078:	4b18      	ldr	r3, [pc, #96]	; (100dc <m_prov_param_rsp+0x64>)

    } while(0);
}

void m_prov_param_rsp(void *p_param)
{
   1007a:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	M_PRINTF(L_PROV, "");
   1007c:	681b      	ldr	r3, [r3, #0]

    } while(0);
}

void m_prov_param_rsp(void *p_param)
{
   1007e:	0005      	movs	r5, r0
	M_PRINTF(L_PROV, "");
   10080:	071b      	lsls	r3, r3, #28
   10082:	d517      	bpl.n	100b4 <m_prov_param_rsp+0x3c>
   10084:	4b16      	ldr	r3, [pc, #88]	; (100e0 <m_prov_param_rsp+0x68>)
   10086:	4c17      	ldr	r4, [pc, #92]	; (100e4 <m_prov_param_rsp+0x6c>)
   10088:	3324      	adds	r3, #36	; 0x24
   1008a:	9300      	str	r3, [sp, #0]
   1008c:	0022      	movs	r2, r4
   1008e:	0020      	movs	r0, r4
   10090:	23fd      	movs	r3, #253	; 0xfd
   10092:	4f15      	ldr	r7, [pc, #84]	; (100e8 <m_prov_param_rsp+0x70>)
   10094:	3255      	adds	r2, #85	; 0x55
   10096:	0039      	movs	r1, r7
   10098:	00db      	lsls	r3, r3, #3
   1009a:	305e      	adds	r0, #94	; 0x5e
   1009c:	f7f4 fc86 	bl	49ac <m_print>
   100a0:	0038      	movs	r0, r7
   100a2:	3025      	adds	r0, #37	; 0x25
   100a4:	f7f4 fc82 	bl	49ac <m_print>
   100a8:	0020      	movs	r0, r4
   100aa:	1dbe      	adds	r6, r7, #6
   100ac:	307f      	adds	r0, #127	; 0x7f
   100ae:	0031      	movs	r1, r6
   100b0:	f7f4 fc7c 	bl	49ac <m_print>
    m_prov_res_t *p_res = p_m_prov_env->p_res;
   100b4:	4b0d      	ldr	r3, [pc, #52]	; (100ec <m_prov_param_rsp+0x74>)
   100b6:	681b      	ldr	r3, [r3, #0]
   100b8:	6858      	ldr	r0, [r3, #4]

    // Check that provisioning is well started
    if (p_res)
   100ba:	2800      	cmp	r0, #0
   100bc:	d00d      	beq.n	100da <m_prov_param_rsp+0x62>
    {
        // Check current state
        if (p_res->state == M_PROV_DSTATE_IDLE)
   100be:	0003      	movs	r3, r0
   100c0:	3358      	adds	r3, #88	; 0x58
   100c2:	781b      	ldrb	r3, [r3, #0]
   100c4:	2b01      	cmp	r3, #1
   100c6:	d108      	bne.n	100da <m_prov_param_rsp+0x62>
        {
            // Keep provided parameters
            memcpy(&p_res->prov_param, p_param, sizeof(m_prov_param_t));
   100c8:	0029      	movs	r1, r5
   100ca:	3034      	adds	r0, #52	; 0x34
   100cc:	2220      	movs	r2, #32
   100ce:	f005 fc7f 	bl	159d0 <memcpy>

            // Read local public key
            m_al_sec_pub_key_read(false, m_prov_pub_key_res_cb);
   100d2:	4907      	ldr	r1, [pc, #28]	; (100f0 <m_prov_param_rsp+0x78>)
   100d4:	2000      	movs	r0, #0
   100d6:	f7f5 f941 	bl	535c <m_al_sec_pub_key_read>
        }
    }
}
   100da:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
   100dc:	10010514 	.word	0x10010514
   100e0:	00022248 	.word	0x00022248
   100e4:	00021dc8 	.word	0x00021dc8
   100e8:	00021d48 	.word	0x00021d48
   100ec:	100128a4 	.word	0x100128a4
   100f0:	0000f4dd 	.word	0x0000f4dd

000100f4 <m_prov_pub_key_get>:

uint16_t m_prov_pub_key_get(uint8_t* p_pub_key_x, uint8_t* p_pub_key_y)
{
    uint16_t status = M_ERR_COMMAND_DISALLOWED;
    m_prov_res_t* p_res = p_m_prov_env->p_res;
   100f4:	4b0a      	ldr	r3, [pc, #40]	; (10120 <m_prov_pub_key_get+0x2c>)
        }
    }
}

uint16_t m_prov_pub_key_get(uint8_t* p_pub_key_x, uint8_t* p_pub_key_y)
{
   100f6:	b570      	push	{r4, r5, r6, lr}
    uint16_t status = M_ERR_COMMAND_DISALLOWED;
    m_prov_res_t* p_res = p_m_prov_env->p_res;
   100f8:	681b      	ldr	r3, [r3, #0]
        }
    }
}

uint16_t m_prov_pub_key_get(uint8_t* p_pub_key_x, uint8_t* p_pub_key_y)
{
   100fa:	000d      	movs	r5, r1
    uint16_t status = M_ERR_COMMAND_DISALLOWED;
    m_prov_res_t* p_res = p_m_prov_env->p_res;
   100fc:	685c      	ldr	r4, [r3, #4]

    if(p_res != NULL)
   100fe:	2c00      	cmp	r4, #0
   10100:	d00c      	beq.n	1011c <m_prov_pub_key_get+0x28>
    {
        memcpy(p_pub_key_x, &(p_res->comp_data[M_PROV_CFM_INPUTS_DEV_PUB_KEY_X_OFFSET]), M_PUB_KEY_X_LEN);
   10102:	0021      	movs	r1, r4
   10104:	2220      	movs	r2, #32
   10106:	317a      	adds	r1, #122	; 0x7a
   10108:	f005 fc62 	bl	159d0 <memcpy>
        memcpy(p_pub_key_y, &(p_res->comp_data[M_PROV_CFM_INPUTS_DEV_PUB_KEY_Y_OFFSET]), M_PUB_KEY_Y_LEN);
   1010c:	0021      	movs	r1, r4
   1010e:	2220      	movs	r2, #32
   10110:	315a      	adds	r1, #90	; 0x5a
   10112:	0028      	movs	r0, r5
   10114:	f005 fc5c 	bl	159d0 <memcpy>
        status = M_ERR_NO_ERROR;
   10118:	2000      	movs	r0, #0
   1011a:	e000      	b.n	1011e <m_prov_pub_key_get+0x2a>
    }
}

uint16_t m_prov_pub_key_get(uint8_t* p_pub_key_x, uint8_t* p_pub_key_y)
{
    uint16_t status = M_ERR_COMMAND_DISALLOWED;
   1011c:	4801      	ldr	r0, [pc, #4]	; (10124 <m_prov_pub_key_get+0x30>)
        memcpy(p_pub_key_y, &(p_res->comp_data[M_PROV_CFM_INPUTS_DEV_PUB_KEY_Y_OFFSET]), M_PUB_KEY_Y_LEN);
        status = M_ERR_NO_ERROR;
    }

    return (status);
}
   1011e:	bd70      	pop	{r4, r5, r6, pc}
   10120:	100128a4 	.word	0x100128a4
   10124:	00000282 	.word	0x00000282

00010128 <m_prov_link_open>:

uint16_t m_prov_link_open(uint8_t bearer_type, m_lid_t bearer_lid)
{
   10128:	b5f0      	push	{r4, r5, r6, r7, lr}
    uint16_t status = M_ERR_COMMAND_DISALLOWED;
    m_prov_res_t* p_res = p_m_prov_env->p_res;
   1012a:	4b20      	ldr	r3, [pc, #128]	; (101ac <m_prov_link_open+0x84>)

    return (status);
}

uint16_t m_prov_link_open(uint8_t bearer_type, m_lid_t bearer_lid)
{
   1012c:	b085      	sub	sp, #20
    uint16_t status = M_ERR_COMMAND_DISALLOWED;
    m_prov_res_t* p_res = p_m_prov_env->p_res;
   1012e:	681b      	ldr	r3, [r3, #0]

    return (status);
}

uint16_t m_prov_link_open(uint8_t bearer_type, m_lid_t bearer_lid)
{
   10130:	9002      	str	r0, [sp, #8]
   10132:	9103      	str	r1, [sp, #12]
    uint16_t status = M_ERR_COMMAND_DISALLOWED;
    m_prov_res_t* p_res = p_m_prov_env->p_res;

    // check that provisioning is not already communicating with another bearer
    if((p_m_prov_env->bearer_type == M_PROV_BEARER_NONE) && (p_res != NULL))
   10134:	7c1a      	ldrb	r2, [r3, #16]
   10136:	2a00      	cmp	r2, #0
   10138:	d135      	bne.n	101a6 <m_prov_link_open+0x7e>
}

uint16_t m_prov_link_open(uint8_t bearer_type, m_lid_t bearer_lid)
{
    uint16_t status = M_ERR_COMMAND_DISALLOWED;
    m_prov_res_t* p_res = p_m_prov_env->p_res;
   1013a:	685c      	ldr	r4, [r3, #4]

    // check that provisioning is not already communicating with another bearer
    if((p_m_prov_env->bearer_type == M_PROV_BEARER_NONE) && (p_res != NULL))
   1013c:	2c00      	cmp	r4, #0
   1013e:	d032      	beq.n	101a6 <m_prov_link_open+0x7e>
    {
    	M_PRINTF(L_PROV, "");
   10140:	4b1b      	ldr	r3, [pc, #108]	; (101b0 <m_prov_link_open+0x88>)
   10142:	681b      	ldr	r3, [r3, #0]
   10144:	071b      	lsls	r3, r3, #28
   10146:	d516      	bpl.n	10176 <m_prov_link_open+0x4e>
   10148:	4d1a      	ldr	r5, [pc, #104]	; (101b4 <m_prov_link_open+0x8c>)
   1014a:	4b1b      	ldr	r3, [pc, #108]	; (101b8 <m_prov_link_open+0x90>)
   1014c:	002a      	movs	r2, r5
   1014e:	0028      	movs	r0, r5
   10150:	4e1a      	ldr	r6, [pc, #104]	; (101bc <m_prov_link_open+0x94>)
   10152:	3335      	adds	r3, #53	; 0x35
   10154:	0031      	movs	r1, r6
   10156:	3255      	adds	r2, #85	; 0x55
   10158:	9300      	str	r3, [sp, #0]
   1015a:	305e      	adds	r0, #94	; 0x5e
   1015c:	4b18      	ldr	r3, [pc, #96]	; (101c0 <m_prov_link_open+0x98>)
   1015e:	f7f4 fc25 	bl	49ac <m_print>
   10162:	0030      	movs	r0, r6
   10164:	3025      	adds	r0, #37	; 0x25
   10166:	f7f4 fc21 	bl	49ac <m_print>
   1016a:	0028      	movs	r0, r5
   1016c:	1db7      	adds	r7, r6, #6
   1016e:	307f      	adds	r0, #127	; 0x7f
   10170:	0039      	movs	r1, r7
   10172:	f7f4 fc1b 	bl	49ac <m_print>
        // assign opened bearer
        p_m_prov_env->bearer_type = bearer_type;
   10176:	466a      	mov	r2, sp
   10178:	4b0c      	ldr	r3, [pc, #48]	; (101ac <m_prov_link_open+0x84>)
   1017a:	7a12      	ldrb	r2, [r2, #8]
   1017c:	681b      	ldr	r3, [r3, #0]
        p_m_prov_env->bearer_lid  = bearer_lid;
        p_res->state       = M_PROV_DSTATE_WAIT_INVITE;
        p_res->reason      = M_PROV_NO_REASON;

        // Start link timeout timer
        m_tb_timer_set(&(p_res->timer_link_timeout), M_PROV_LINK_TIMEOUT);
   1017e:	0020      	movs	r0, r4
    // check that provisioning is not already communicating with another bearer
    if((p_m_prov_env->bearer_type == M_PROV_BEARER_NONE) && (p_res != NULL))
    {
    	M_PRINTF(L_PROV, "");
        // assign opened bearer
        p_m_prov_env->bearer_type = bearer_type;
   10180:	741a      	strb	r2, [r3, #16]
        p_m_prov_env->bearer_lid  = bearer_lid;
   10182:	466a      	mov	r2, sp
   10184:	7b12      	ldrb	r2, [r2, #12]
        p_res->state       = M_PROV_DSTATE_WAIT_INVITE;
        p_res->reason      = M_PROV_NO_REASON;

        // Start link timeout timer
        m_tb_timer_set(&(p_res->timer_link_timeout), M_PROV_LINK_TIMEOUT);
   10186:	3020      	adds	r0, #32
    if((p_m_prov_env->bearer_type == M_PROV_BEARER_NONE) && (p_res != NULL))
    {
    	M_PRINTF(L_PROV, "");
        // assign opened bearer
        p_m_prov_env->bearer_type = bearer_type;
        p_m_prov_env->bearer_lid  = bearer_lid;
   10188:	745a      	strb	r2, [r3, #17]
        p_res->state       = M_PROV_DSTATE_WAIT_INVITE;
   1018a:	0023      	movs	r3, r4
   1018c:	2202      	movs	r2, #2
   1018e:	3358      	adds	r3, #88	; 0x58
   10190:	701a      	strb	r2, [r3, #0]
        p_res->reason      = M_PROV_NO_REASON;
   10192:	33a3      	adds	r3, #163	; 0xa3
   10194:	32fd      	adds	r2, #253	; 0xfd
   10196:	701a      	strb	r2, [r3, #0]

        // Start link timeout timer
        m_tb_timer_set(&(p_res->timer_link_timeout), M_PROV_LINK_TIMEOUT);
   10198:	490a      	ldr	r1, [pc, #40]	; (101c4 <m_prov_link_open+0x9c>)
   1019a:	f005 f8b3 	bl	15304 <m_tb_timer_set>

        // Stop transmission of unprovisioned beacons
        m_bcn_stop_tx_unprov_bcn();
   1019e:	f7f9 fc83 	bl	9aa8 <m_bcn_stop_tx_unprov_bcn>
        {
            m_prov_bearer_gatt_stop();
        }
        #endif // (BLE_MESH_GATT_PROV)

        status = M_ERR_NO_ERROR;
   101a2:	2000      	movs	r0, #0
   101a4:	e000      	b.n	101a8 <m_prov_link_open+0x80>
    return (status);
}

uint16_t m_prov_link_open(uint8_t bearer_type, m_lid_t bearer_lid)
{
    uint16_t status = M_ERR_COMMAND_DISALLOWED;
   101a6:	4808      	ldr	r0, [pc, #32]	; (101c8 <m_prov_link_open+0xa0>)

        status = M_ERR_NO_ERROR;
    }

    return (status);
}
   101a8:	b005      	add	sp, #20
   101aa:	bdf0      	pop	{r4, r5, r6, r7, pc}
   101ac:	100128a4 	.word	0x100128a4
   101b0:	10010514 	.word	0x10010514
   101b4:	00021dc8 	.word	0x00021dc8
   101b8:	00022248 	.word	0x00022248
   101bc:	00021d48 	.word	0x00021d48
   101c0:	00000811 	.word	0x00000811
   101c4:	0000ea60 	.word	0x0000ea60
   101c8:	00000282 	.word	0x00000282

000101cc <m_prov_link_closed>:

void m_prov_link_closed(uint8_t reason)
{
   101cc:	b5f0      	push	{r4, r5, r6, r7, lr}
	M_PRINTF(L_PROV, "reason = %d", reason);
   101ce:	4b47      	ldr	r3, [pc, #284]	; (102ec <m_prov_link_closed+0x120>)

    return (status);
}

void m_prov_link_closed(uint8_t reason)
{
   101d0:	b085      	sub	sp, #20
	M_PRINTF(L_PROV, "reason = %d", reason);
   101d2:	681a      	ldr	r2, [r3, #0]

    return (status);
}

void m_prov_link_closed(uint8_t reason)
{
   101d4:	0007      	movs	r7, r0
   101d6:	9303      	str	r3, [sp, #12]
	M_PRINTF(L_PROV, "reason = %d", reason);
   101d8:	0713      	lsls	r3, r2, #28
   101da:	d517      	bpl.n	1020c <m_prov_link_closed+0x40>
   101dc:	4e44      	ldr	r6, [pc, #272]	; (102f0 <m_prov_link_closed+0x124>)
   101de:	4c45      	ldr	r4, [pc, #276]	; (102f4 <m_prov_link_closed+0x128>)
   101e0:	0033      	movs	r3, r6
   101e2:	0022      	movs	r2, r4
   101e4:	0020      	movs	r0, r4
   101e6:	4d44      	ldr	r5, [pc, #272]	; (102f8 <m_prov_link_closed+0x12c>)
   101e8:	3346      	adds	r3, #70	; 0x46
   101ea:	3255      	adds	r2, #85	; 0x55
   101ec:	9300      	str	r3, [sp, #0]
   101ee:	0029      	movs	r1, r5
   101f0:	4b42      	ldr	r3, [pc, #264]	; (102fc <m_prov_link_closed+0x130>)
   101f2:	305e      	adds	r0, #94	; 0x5e
   101f4:	f7f4 fbda 	bl	49ac <m_print>
   101f8:	0030      	movs	r0, r6
   101fa:	0039      	movs	r1, r7
   101fc:	3059      	adds	r0, #89	; 0x59
   101fe:	f7f4 fbd5 	bl	49ac <m_print>
   10202:	0020      	movs	r0, r4
   10204:	1da9      	adds	r1, r5, #6
   10206:	307f      	adds	r0, #127	; 0x7f
   10208:	f7f4 fbd0 	bl	49ac <m_print>
    m_prov_res_t* p_res = p_m_prov_env->p_res;
   1020c:	4e3c      	ldr	r6, [pc, #240]	; (10300 <m_prov_link_closed+0x134>)
   1020e:	6833      	ldr	r3, [r6, #0]
   10210:	685d      	ldr	r5, [r3, #4]

    if(p_res != NULL)
   10212:	2d00      	cmp	r5, #0
   10214:	d04f      	beq.n	102b6 <m_prov_link_closed+0xea>
    {
        // Stop link timeout timer
        m_tb_timer_clear(&(p_res->timer_link_timeout));
   10216:	0028      	movs	r0, r5
   10218:	3020      	adds	r0, #32
   1021a:	f005 f8bd 	bl	15398 <m_tb_timer_clear>

        // Stop transaction timeout timer
        m_tb_timer_clear(&(p_res->timer_trans_timeout));
   1021e:	0028      	movs	r0, r5
   10220:	300c      	adds	r0, #12
   10222:	f005 f8b9 	bl	15398 <m_tb_timer_clear>

        // Clean-up the bearer
        if(p_m_prov_env->bearer_type == M_PROV_BEARER_ADV)
   10226:	6833      	ldr	r3, [r6, #0]
   10228:	7c1b      	ldrb	r3, [r3, #16]
   1022a:	2b01      	cmp	r3, #1
   1022c:	d101      	bne.n	10232 <m_prov_link_closed+0x66>
        {
            // Clean-up advertising transport
            m_prov_adv_trans_clean_up();
   1022e:	f000 fb3b 	bl	108a8 <m_prov_adv_trans_clean_up>
        }

        if(p_res->state != M_PROV_DSTATE_IDLE)
   10232:	002b      	movs	r3, r5
   10234:	3358      	adds	r3, #88	; 0x58
   10236:	781a      	ldrb	r2, [r3, #0]
   10238:	2a01      	cmp	r2, #1
   1023a:	d03c      	beq.n	102b6 <m_prov_link_closed+0xea>
        {
            uint16_t status;
            p_res->state = M_PROV_DSTATE_IDLE;
   1023c:	2201      	movs	r2, #1
   1023e:	701a      	strb	r2, [r3, #0]

            // check if provisioning reason already set
            if(p_res->reason != M_PROV_NO_REASON)
   10240:	33a3      	adds	r3, #163	; 0xa3
   10242:	9302      	str	r3, [sp, #8]
   10244:	781c      	ldrb	r4, [r3, #0]
   10246:	2cff      	cmp	r4, #255	; 0xff
   10248:	d102      	bne.n	10250 <m_prov_link_closed+0x84>
            {
                reason = p_res->reason;
            }
            else if(reason == M_PROV_SUCCESS)
   1024a:	2f00      	cmp	r7, #0
   1024c:	d04a      	beq.n	102e4 <m_prov_link_closed+0x118>
   1024e:	003c      	movs	r4, r7
            {
                reason = M_PROV_NO_REASON;
            }

            // change reason to a mesh error code
            switch(reason)
   10250:	2c01      	cmp	r4, #1
   10252:	d005      	beq.n	10260 <m_prov_link_closed+0x94>
   10254:	2c00      	cmp	r4, #0
   10256:	d036      	beq.n	102c6 <m_prov_link_closed+0xfa>
   10258:	2cfe      	cmp	r4, #254	; 0xfe
   1025a:	d143      	bne.n	102e4 <m_prov_link_closed+0x118>
                {
                    status = M_ERR_PROVISIONING_TIMEOUT;
                } break;
                case M_PROV_BEARER_CLOSED:
                {
                    status = M_ERR_BEARER_CLOSED;
   1025c:	4d29      	ldr	r5, [pc, #164]	; (10304 <m_prov_link_closed+0x138>)
   1025e:	e000      	b.n	10262 <m_prov_link_closed+0x96>
            // change reason to a mesh error code
            switch(reason)
            {
                case M_PROV_TIMEOUT:
                {
                    status = M_ERR_PROVISIONING_TIMEOUT;
   10260:	4d29      	ldr	r5, [pc, #164]	; (10308 <m_prov_link_closed+0x13c>)
            }
            // provisioning failed
            else
            {
                // Reset provisioning state
                m_tb_state_set_prov_state(M_TB_STATE_PROV_STATE_UNPROV);
   10262:	2000      	movs	r0, #0
   10264:	f003 ff48 	bl	140f8 <m_tb_state_set_prov_state>

                // Read local public key
                M_PRINTF(L_PROV, "m_al_sec_pub_key_read");
   10268:	9b03      	ldr	r3, [sp, #12]
   1026a:	681b      	ldr	r3, [r3, #0]
   1026c:	071b      	lsls	r3, r3, #28
   1026e:	d516      	bpl.n	1029e <m_prov_link_closed+0xd2>
   10270:	4f1f      	ldr	r7, [pc, #124]	; (102f0 <m_prov_link_closed+0x124>)
   10272:	4c20      	ldr	r4, [pc, #128]	; (102f4 <m_prov_link_closed+0x128>)
   10274:	003b      	movs	r3, r7
   10276:	0022      	movs	r2, r4
   10278:	0020      	movs	r0, r4
   1027a:	4e1f      	ldr	r6, [pc, #124]	; (102f8 <m_prov_link_closed+0x12c>)
   1027c:	3346      	adds	r3, #70	; 0x46
   1027e:	0031      	movs	r1, r6
   10280:	3255      	adds	r2, #85	; 0x55
   10282:	9300      	str	r3, [sp, #0]
   10284:	305e      	adds	r0, #94	; 0x5e
   10286:	4b21      	ldr	r3, [pc, #132]	; (1030c <m_prov_link_closed+0x140>)
   10288:	f7f4 fb90 	bl	49ac <m_print>
   1028c:	0038      	movs	r0, r7
   1028e:	3065      	adds	r0, #101	; 0x65
   10290:	f7f4 fb8c 	bl	49ac <m_print>
   10294:	0020      	movs	r0, r4
   10296:	1db1      	adds	r1, r6, #6
   10298:	307f      	adds	r0, #127	; 0x7f
   1029a:	f7f4 fb87 	bl	49ac <m_print>
                m_al_sec_pub_key_read(false, m_prov_pub_key_res_cb);
   1029e:	491c      	ldr	r1, [pc, #112]	; (10310 <m_prov_link_closed+0x144>)
   102a0:	2000      	movs	r0, #0
   102a2:	f7f5 f85b 	bl	535c <m_al_sec_pub_key_read>

                // if pairing failed, application is already aware
                if(p_res->reason != M_PROV_FAIL)
   102a6:	9b02      	ldr	r3, [sp, #8]
   102a8:	781b      	ldrb	r3, [r3, #0]
   102aa:	2b02      	cmp	r3, #2
   102ac:	d003      	beq.n	102b6 <m_prov_link_closed+0xea>
                {
                    // inform application that provisioning failed
                    m_prov_state_send(M_PROV_FAILED, status);
   102ae:	0029      	movs	r1, r5
   102b0:	2002      	movs	r0, #2
   102b2:	f7fe fbc8 	bl	ea46 <m_prov_state_send>
            }
        }
    }

    // release opened bearer
    p_m_prov_env->bearer_type = M_PROV_BEARER_NONE;
   102b6:	2200      	movs	r2, #0
   102b8:	4b11      	ldr	r3, [pc, #68]	; (10300 <m_prov_link_closed+0x134>)
   102ba:	681b      	ldr	r3, [r3, #0]
   102bc:	741a      	strb	r2, [r3, #16]
    p_m_prov_env->bearer_lid  = M_INVALID_LID;
   102be:	32ff      	adds	r2, #255	; 0xff
   102c0:	745a      	strb	r2, [r3, #17]
}
   102c2:	b005      	add	sp, #20
   102c4:	bdf0      	pop	{r4, r5, r6, r7, pc}

            // provisioning succeed
            if(status == M_ERR_NO_ERROR)
            {
                // Keep in mind that device is now provisioned
                m_tb_state_set_prov_state(M_TB_STATE_PROV_STATE_PROV);
   102c6:	2002      	movs	r0, #2
   102c8:	f003 ff16 	bl	140f8 <m_tb_state_set_prov_state>

                // inform that provisioning succeed
                m_prov_state_send(M_PROV_SUCCEED, M_ERR_NO_ERROR);
   102cc:	0021      	movs	r1, r4
   102ce:	2001      	movs	r0, #1
   102d0:	f7fe fbb9 	bl	ea46 <m_prov_state_send>

                // Inform beaconing layer that device is now provisioned
                m_bcn_state_update();
   102d4:	f7f9 fc3a 	bl	9b4c <m_bcn_state_update>
                    #endif // (BLE_MESH_GATT_PROXY)
                }
                #endif // (BLE_MESH_GATT_PROV)

                // Clean-up pairing environment
                m_al_free(p_res);
   102d8:	0028      	movs	r0, r5
   102da:	f7f5 f97f 	bl	55dc <m_al_free>
                p_m_prov_env->p_res = NULL;
   102de:	6833      	ldr	r3, [r6, #0]
   102e0:	605c      	str	r4, [r3, #4]
   102e2:	e7e8      	b.n	102b6 <m_prov_link_closed+0xea>
                } break;
                case M_PROV_FAIL:
                case M_PROV_NO_REASON:
                default:
                {
                    status = M_ERR_UNSPECIFIED_ERROR;
   102e4:	2584      	movs	r5, #132	; 0x84
   102e6:	016d      	lsls	r5, r5, #5
   102e8:	e7bb      	b.n	10262 <m_prov_link_closed+0x96>
   102ea:	46c0      	nop			; (mov r8, r8)
   102ec:	10010514 	.word	0x10010514
   102f0:	00022248 	.word	0x00022248
   102f4:	00021dc8 	.word	0x00021dc8
   102f8:	00021d48 	.word	0x00021d48
   102fc:	00000833 	.word	0x00000833
   10300:	100128a4 	.word	0x100128a4
   10304:	00000882 	.word	0x00000882
   10308:	00000a82 	.word	0x00000a82
   1030c:	0000089b 	.word	0x0000089b
   10310:	0000f4dd 	.word	0x0000f4dd

00010314 <m_prov_pdu_rx>:
}

void m_prov_pdu_rx(m_tb_buf_t *p_buf)
{
    uint16_t status;
    m_prov_res_t* p_res = p_m_prov_env->p_res;
   10314:	4b1d      	ldr	r3, [pc, #116]	; (1038c <m_prov_pdu_rx+0x78>)
    p_m_prov_env->bearer_type = M_PROV_BEARER_NONE;
    p_m_prov_env->bearer_lid  = M_INVALID_LID;
}

void m_prov_pdu_rx(m_tb_buf_t *p_buf)
{
   10316:	b5f0      	push	{r4, r5, r6, r7, lr}
    uint16_t status;
    m_prov_res_t* p_res = p_m_prov_env->p_res;
   10318:	681b      	ldr	r3, [r3, #0]
    p_m_prov_env->bearer_type = M_PROV_BEARER_NONE;
    p_m_prov_env->bearer_lid  = M_INVALID_LID;
}

void m_prov_pdu_rx(m_tb_buf_t *p_buf)
{
   1031a:	0005      	movs	r5, r0
    uint16_t status;
    m_prov_res_t* p_res = p_m_prov_env->p_res;
   1031c:	6858      	ldr	r0, [r3, #4]
    p_m_prov_env->bearer_type = M_PROV_BEARER_NONE;
    p_m_prov_env->bearer_lid  = M_INVALID_LID;
}

void m_prov_pdu_rx(m_tb_buf_t *p_buf)
{
   1031e:	b095      	sub	sp, #84	; 0x54
    uint16_t status;
    m_prov_res_t* p_res = p_m_prov_env->p_res;

    if(p_res != NULL)
   10320:	2800      	cmp	r0, #0
   10322:	d031      	beq.n	10388 <m_prov_pdu_rx+0x74>
    {
         // Restart link timeout timer
        m_tb_timer_set(&(p_res->timer_link_timeout), M_PROV_LINK_TIMEOUT);
   10324:	3020      	adds	r0, #32
   10326:	491a      	ldr	r1, [pc, #104]	; (10390 <m_prov_pdu_rx+0x7c>)
   10328:	f004 ffec 	bl	15304 <m_tb_timer_set>
{
    union m_prov_pdu pdu;
    uint16_t status = M_ERR_INVALID_PARAM;
    m_prov_buf_env_t* p_buf_env = (m_prov_buf_env_t*) p_buf->env;

    pdu.type = p_buf_env->pdu_type;
   1032c:	7c2b      	ldrb	r3, [r5, #16]
   1032e:	ae03      	add	r6, sp, #12
   10330:	7033      	strb	r3, [r6, #0]

    // Check PDU type
    if (pdu.type >= M_PROV_PDU_MAX)
   10332:	2b09      	cmp	r3, #9
   10334:	d822      	bhi.n	1037c <m_prov_pdu_rx+0x68>
    {
        status = M_ERR_PROV_INVALID_PDU;
    }
    else if (p_buf->data_len != m_prov_pdu_handlers[pdu.type].length)
   10336:	240c      	movs	r4, #12
   10338:	4363      	muls	r3, r4
   1033a:	4f16      	ldr	r7, [pc, #88]	; (10394 <m_prov_pdu_rx+0x80>)
   1033c:	892a      	ldrh	r2, [r5, #8]
   1033e:	18f8      	adds	r0, r7, r3
   10340:	8f83      	ldrh	r3, [r0, #60]	; 0x3c
   10342:	4293      	cmp	r3, r2
   10344:	d11d      	bne.n	10382 <m_prov_pdu_rx+0x6e>
    {
        status = M_ERR_PROV_INVALID_FORMAT; // incorrect length
    }
    else
    {
        uint16_t pdu_len = sizeof(union m_prov_pdu);
   10346:	220a      	movs	r2, #10
   10348:	2142      	movs	r1, #66	; 0x42
   1034a:	446a      	add	r2, sp
   1034c:	8011      	strh	r1, [r2, #0]

        // Perform PDU unpacking
        status = co_util_unpack(((uint8_t*) &pdu)+1, M_TB_BUF_DATA(p_buf), &pdu_len, p_buf->data_len,
   1034e:	88a9      	ldrh	r1, [r5, #4]
   10350:	6b80      	ldr	r0, [r0, #56]	; 0x38
   10352:	468c      	mov	ip, r1
   10354:	0029      	movs	r1, r5
   10356:	9000      	str	r0, [sp, #0]
   10358:	200d      	movs	r0, #13
   1035a:	3130      	adds	r1, #48	; 0x30
   1035c:	4461      	add	r1, ip
   1035e:	4468      	add	r0, sp
   10360:	f7f4 fa08 	bl	4774 <co_util_unpack>
                                m_prov_pdu_handlers[pdu.type].p_pack_format);

        // check if unpack succeed or not
        if(status == M_ERR_NO_ERROR)
   10364:	2800      	cmp	r0, #0
   10366:	d10c      	bne.n	10382 <m_prov_pdu_rx+0x6e>
        {
            status = CO_ERROR_NO_ERROR;

            // execute message handler
            status = m_prov_pdu_handlers[pdu.type].handler(&pdu, p_buf);
   10368:	7833      	ldrb	r3, [r6, #0]
   1036a:	0029      	movs	r1, r5
   1036c:	435c      	muls	r4, r3
   1036e:	193c      	adds	r4, r7, r4
   10370:	6b63      	ldr	r3, [r4, #52]	; 0x34
   10372:	0030      	movs	r0, r6
   10374:	4798      	blx	r3
        m_tb_timer_set(&(p_res->timer_link_timeout), M_PROV_LINK_TIMEOUT);

        // Extract and handle received PDU
        status = m_prov_pdu_handle(p_buf);

        if(status != M_ERR_NO_ERROR)
   10376:	2800      	cmp	r0, #0
   10378:	d006      	beq.n	10388 <m_prov_pdu_rx+0x74>
   1037a:	e003      	b.n	10384 <m_prov_pdu_rx+0x70>
    pdu.type = p_buf_env->pdu_type;

    // Check PDU type
    if (pdu.type >= M_PROV_PDU_MAX)
    {
        status = M_ERR_PROV_INVALID_PDU;
   1037c:	2082      	movs	r0, #130	; 0x82
   1037e:	30ff      	adds	r0, #255	; 0xff
   10380:	e000      	b.n	10384 <m_prov_pdu_rx+0x70>
    }
    else if (p_buf->data_len != m_prov_pdu_handlers[pdu.type].length)
    {
        status = M_ERR_PROV_INVALID_FORMAT; // incorrect length
   10382:	4805      	ldr	r0, [pc, #20]	; (10398 <m_prov_pdu_rx+0x84>)
        status = m_prov_pdu_handle(p_buf);

        if(status != M_ERR_NO_ERROR)
        {
            // Handle error
            m_prov_error_handle(status);
   10384:	f7ff fcf2 	bl	fd6c <m_prov_error_handle>
        }
    }
}
   10388:	b015      	add	sp, #84	; 0x54
   1038a:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1038c:	100128a4 	.word	0x100128a4
   10390:	0000ea60 	.word	0x0000ea60
   10394:	00021d48 	.word	0x00021d48
   10398:	00000281 	.word	0x00000281

0001039c <m_prov_pdu_sent>:

void m_prov_pdu_sent(m_tb_buf_t *p_buf, uint16_t status)
{
    m_prov_res_t* p_res = p_m_prov_env->p_res;
   1039c:	4b0e      	ldr	r3, [pc, #56]	; (103d8 <m_prov_pdu_sent+0x3c>)
        }
    }
}

void m_prov_pdu_sent(m_tb_buf_t *p_buf, uint16_t status)
{
   1039e:	b570      	push	{r4, r5, r6, lr}
    m_prov_res_t* p_res = p_m_prov_env->p_res;
   103a0:	681b      	ldr	r3, [r3, #0]
        }
    }
}

void m_prov_pdu_sent(m_tb_buf_t *p_buf, uint16_t status)
{
   103a2:	000d      	movs	r5, r1
    m_prov_res_t* p_res = p_m_prov_env->p_res;
   103a4:	685c      	ldr	r4, [r3, #4]

    if(p_res != NULL)
   103a6:	2c00      	cmp	r4, #0
   103a8:	d015      	beq.n	103d6 <m_prov_pdu_sent+0x3a>
    {
        // release buffer
        bc_m_buf_release(p_buf);
   103aa:	f7f8 fd04 	bl	8db6 <bc_m_buf_release>

        // Clear transaction timer
        m_tb_timer_clear(&(p_res->timer_trans_timeout));
   103ae:	0020      	movs	r0, r4
   103b0:	300c      	adds	r0, #12
   103b2:	f004 fff1 	bl	15398 <m_tb_timer_clear>

        // check state machine to know what to do next
        if(status == M_ERR_NO_ERROR)
   103b6:	2d00      	cmp	r5, #0
   103b8:	d10d      	bne.n	103d6 <m_prov_pdu_sent+0x3a>
        {
            if((p_res->state == M_PROV_DSTATE_WAIT_CMP_ACK) || (p_res->state == M_PROV_DSTATE_WAIT_FAILED_ACK))
   103ba:	0022      	movs	r2, r4
   103bc:	3258      	adds	r2, #88	; 0x58
   103be:	7813      	ldrb	r3, [r2, #0]
   103c0:	3b12      	subs	r3, #18
   103c2:	2b01      	cmp	r3, #1
   103c4:	d807      	bhi.n	103d6 <m_prov_pdu_sent+0x3a>
            {
                p_res->state = M_PROV_DSTATE_WAIT_LINK_CLOSE;
   103c6:	2315      	movs	r3, #21
                m_tb_timer_set(&(p_res->timer_link_timeout), M_PROV_LINK_FAILED_TIMEOUT);
   103c8:	0020      	movs	r0, r4
   103ca:	21fa      	movs	r1, #250	; 0xfa
        // check state machine to know what to do next
        if(status == M_ERR_NO_ERROR)
        {
            if((p_res->state == M_PROV_DSTATE_WAIT_CMP_ACK) || (p_res->state == M_PROV_DSTATE_WAIT_FAILED_ACK))
            {
                p_res->state = M_PROV_DSTATE_WAIT_LINK_CLOSE;
   103cc:	7013      	strb	r3, [r2, #0]
                m_tb_timer_set(&(p_res->timer_link_timeout), M_PROV_LINK_FAILED_TIMEOUT);
   103ce:	3020      	adds	r0, #32
   103d0:	0089      	lsls	r1, r1, #2
   103d2:	f004 ff97 	bl	15304 <m_tb_timer_set>
            }
        }
        // else ignore, the provisioning link is considered as closed
    }
}
   103d6:	bd70      	pop	{r4, r5, r6, pc}
   103d8:	100128a4 	.word	0x100128a4

000103dc <co_bswap32>:
 * @param[in] val32 The 32 bits value to swap.
 * @return The 32 bit swapped value.
 ****************************************************************************************
 */
__INLINE_S__ uint32_t co_bswap32(uint32_t val32)
{
   103dc:	ba00      	rev	r0, r0
    return (val32<<24) | ((val32<<8)&0xFF0000) | ((val32>>8)&0xFF00) | ((val32>>24)&0xFF);
}
   103de:	4770      	bx	lr

000103e0 <m_prov_adv_trans_tx_set>:
 ****************************************************************************************
 * @brief Mark that there is a packet to transmit
 ****************************************************************************************
 */
__STATIC void m_prov_adv_trans_tx_set(void)
{
   103e0:	b573      	push	{r0, r1, r4, r5, r6, lr}
	M_PRINTF(L_PROV, "");
   103e2:	4e22      	ldr	r6, [pc, #136]	; (1046c <m_prov_adv_trans_tx_set+0x8c>)
   103e4:	6833      	ldr	r3, [r6, #0]
   103e6:	071b      	lsls	r3, r3, #28
   103e8:	d515      	bpl.n	10416 <m_prov_adv_trans_tx_set+0x36>
   103ea:	4c21      	ldr	r4, [pc, #132]	; (10470 <m_prov_adv_trans_tx_set+0x90>)
   103ec:	4d21      	ldr	r5, [pc, #132]	; (10474 <m_prov_adv_trans_tx_set+0x94>)
   103ee:	0023      	movs	r3, r4
   103f0:	0022      	movs	r2, r4
   103f2:	0020      	movs	r0, r4
   103f4:	3344      	adds	r3, #68	; 0x44
   103f6:	0029      	movs	r1, r5
   103f8:	3222      	adds	r2, #34	; 0x22
   103fa:	9300      	str	r3, [sp, #0]
   103fc:	3035      	adds	r0, #53	; 0x35
   103fe:	2377      	movs	r3, #119	; 0x77
   10400:	f7f4 fad4 	bl	49ac <m_print>
   10404:	0020      	movs	r0, r4
   10406:	305c      	adds	r0, #92	; 0x5c
   10408:	f7f4 fad0 	bl	49ac <m_print>
   1040c:	0020      	movs	r0, r4
   1040e:	1da9      	adds	r1, r5, #6
   10410:	305d      	adds	r0, #93	; 0x5d
   10412:	f7f4 facb 	bl	49ac <m_print>
    m_prov_adv_res_t* p_adv_res = p_m_prov_env->p_adv_res;
   10416:	4b18      	ldr	r3, [pc, #96]	; (10478 <m_prov_adv_trans_tx_set+0x98>)
   10418:	681b      	ldr	r3, [r3, #0]
   1041a:	689d      	ldr	r5, [r3, #8]

    // check if a transmission can be performed
    if(   (p_adv_res != NULL)
   1041c:	2d00      	cmp	r5, #0
   1041e:	d024      	beq.n	1046a <m_prov_adv_trans_tx_set+0x8a>
       && (!GETB(p_adv_res->link_info, M_PROV_IN_TX))
       && (!GETB(p_adv_res->link_info, M_PROV_TX_REQ)))
   10420:	2206      	movs	r2, #6
	M_PRINTF(L_PROV, "");
    m_prov_adv_res_t* p_adv_res = p_m_prov_env->p_adv_res;

    // check if a transmission can be performed
    if(   (p_adv_res != NULL)
       && (!GETB(p_adv_res->link_info, M_PROV_IN_TX))
   10422:	8d2b      	ldrh	r3, [r5, #40]	; 0x28
       && (!GETB(p_adv_res->link_info, M_PROV_TX_REQ)))
   10424:	4213      	tst	r3, r2
   10426:	d120      	bne.n	1046a <m_prov_adv_trans_tx_set+0x8a>
    {
        uint8_t delay;

        // Mark that transmission starts
        SETB(p_adv_res->link_info, M_PROV_TX_REQ, true);
   10428:	3a02      	subs	r2, #2
   1042a:	4313      	orrs	r3, r2
   1042c:	852b      	strh	r3, [r5, #40]	; 0x28

        // delay must be a random value between 20 and 50 ms
        
        //delay = (co_rand_byte() % 30) + 20;
        delay = 20;
		M_PRINTF(L_PROV, "delay = %d",delay);
   1042e:	6833      	ldr	r3, [r6, #0]
   10430:	071b      	lsls	r3, r3, #28
   10432:	d516      	bpl.n	10462 <m_prov_adv_trans_tx_set+0x82>
   10434:	4c0e      	ldr	r4, [pc, #56]	; (10470 <m_prov_adv_trans_tx_set+0x90>)
   10436:	4e0f      	ldr	r6, [pc, #60]	; (10474 <m_prov_adv_trans_tx_set+0x94>)
   10438:	0023      	movs	r3, r4
   1043a:	0022      	movs	r2, r4
   1043c:	0020      	movs	r0, r4
   1043e:	3344      	adds	r3, #68	; 0x44
   10440:	3222      	adds	r2, #34	; 0x22
   10442:	9300      	str	r3, [sp, #0]
   10444:	0031      	movs	r1, r6
   10446:	2388      	movs	r3, #136	; 0x88
   10448:	3035      	adds	r0, #53	; 0x35
   1044a:	f7f4 faaf 	bl	49ac <m_print>
   1044e:	0020      	movs	r0, r4
   10450:	2114      	movs	r1, #20
   10452:	3060      	adds	r0, #96	; 0x60
   10454:	f7f4 faaa 	bl	49ac <m_print>
   10458:	0020      	movs	r0, r4
   1045a:	1db1      	adds	r1, r6, #6
   1045c:	305d      	adds	r0, #93	; 0x5d
   1045e:	f7f4 faa5 	bl	49ac <m_print>
        // start transmission timer
        m_tb_timer_set(&(p_adv_res->timer_tx), delay);
   10462:	2114      	movs	r1, #20
   10464:	0028      	movs	r0, r5
   10466:	f004 ff4d 	bl	15304 <m_tb_timer_set>
    }
}
   1046a:	bd73      	pop	{r0, r1, r4, r5, r6, pc}
   1046c:	10010514 	.word	0x10010514
   10470:	000223c3 	.word	0x000223c3
   10474:	000222c3 	.word	0x000222c3
   10478:	100128a4 	.word	0x100128a4

0001047c <m_prov_adv_trans_tx_cb>:
 */
__STATIC void m_prov_adv_trans_tx_cb(void* p_dummy)
{
    do
    {
        m_prov_adv_res_t* p_adv_res = p_m_prov_env->p_adv_res;
   1047c:	4bb8      	ldr	r3, [pc, #736]	; (10760 <m_prov_adv_trans_tx_cb+0x2e4>)
 ****************************************************************************************
 * @brief Transmission callback (triggered by transmission timer)
 ****************************************************************************************
 */
__STATIC void m_prov_adv_trans_tx_cb(void* p_dummy)
{
   1047e:	b5f0      	push	{r4, r5, r6, r7, lr}
    do
    {
        m_prov_adv_res_t* p_adv_res = p_m_prov_env->p_adv_res;
   10480:	681b      	ldr	r3, [r3, #0]
 ****************************************************************************************
 * @brief Transmission callback (triggered by transmission timer)
 ****************************************************************************************
 */
__STATIC void m_prov_adv_trans_tx_cb(void* p_dummy)
{
   10482:	b085      	sub	sp, #20
    do
    {
        m_prov_adv_res_t* p_adv_res = p_m_prov_env->p_adv_res;
   10484:	689c      	ldr	r4, [r3, #8]
   10486:	4eb7      	ldr	r6, [pc, #732]	; (10764 <m_prov_adv_trans_tx_cb+0x2e8>)
        uint8_t* p_data;

        // check that provisioner enabled
        if(p_adv_res == NULL) { M_PRINTF(L_PROV, "p_adv_res == NULL");break; }
   10488:	2c00      	cmp	r4, #0
   1048a:	d113      	bne.n	104b4 <m_prov_adv_trans_tx_cb+0x38>
   1048c:	6833      	ldr	r3, [r6, #0]
   1048e:	071b      	lsls	r3, r3, #28
   10490:	d400      	bmi.n	10494 <m_prov_adv_trans_tx_cb+0x18>
   10492:	e1fe      	b.n	10892 <m_prov_adv_trans_tx_cb+0x416>
   10494:	4cb4      	ldr	r4, [pc, #720]	; (10768 <m_prov_adv_trans_tx_cb+0x2ec>)
   10496:	4db5      	ldr	r5, [pc, #724]	; (1076c <m_prov_adv_trans_tx_cb+0x2f0>)
   10498:	0023      	movs	r3, r4
   1049a:	0022      	movs	r2, r4
   1049c:	0020      	movs	r0, r4
   1049e:	336b      	adds	r3, #107	; 0x6b
   104a0:	9300      	str	r3, [sp, #0]
   104a2:	3222      	adds	r2, #34	; 0x22
   104a4:	3035      	adds	r0, #53	; 0x35
   104a6:	239b      	movs	r3, #155	; 0x9b
   104a8:	0029      	movs	r1, r5
   104aa:	f7f4 fa7f 	bl	49ac <m_print>
   104ae:	48b0      	ldr	r0, [pc, #704]	; (10770 <m_prov_adv_trans_tx_cb+0x2f4>)
   104b0:	3002      	adds	r0, #2
   104b2:	e016      	b.n	104e2 <m_prov_adv_trans_tx_cb+0x66>

        // check that transmission requested
        if(!GETB(p_adv_res->link_info, M_PROV_TX_REQ)) { 
   104b4:	2204      	movs	r2, #4
   104b6:	8d23      	ldrh	r3, [r4, #40]	; 0x28
   104b8:	4213      	tst	r3, r2
   104ba:	d11a      	bne.n	104f2 <m_prov_adv_trans_tx_cb+0x76>
			M_PRINTF(L_PROV, "info error");
   104bc:	6833      	ldr	r3, [r6, #0]
   104be:	071b      	lsls	r3, r3, #28
   104c0:	d400      	bmi.n	104c4 <m_prov_adv_trans_tx_cb+0x48>
   104c2:	e1e6      	b.n	10892 <m_prov_adv_trans_tx_cb+0x416>
   104c4:	4ca8      	ldr	r4, [pc, #672]	; (10768 <m_prov_adv_trans_tx_cb+0x2ec>)
   104c6:	4da9      	ldr	r5, [pc, #676]	; (1076c <m_prov_adv_trans_tx_cb+0x2f0>)
   104c8:	0023      	movs	r3, r4
   104ca:	0022      	movs	r2, r4
   104cc:	0020      	movs	r0, r4
   104ce:	336b      	adds	r3, #107	; 0x6b
   104d0:	9300      	str	r3, [sp, #0]
   104d2:	3222      	adds	r2, #34	; 0x22
   104d4:	3035      	adds	r0, #53	; 0x35
   104d6:	239f      	movs	r3, #159	; 0x9f
   104d8:	0029      	movs	r1, r5
   104da:	f7f4 fa67 	bl	49ac <m_print>
   104de:	48a4      	ldr	r0, [pc, #656]	; (10770 <m_prov_adv_trans_tx_cb+0x2f4>)
   104e0:	3014      	adds	r0, #20
   104e2:	f7f4 fa63 	bl	49ac <m_print>
   104e6:	0020      	movs	r0, r4
   104e8:	1da9      	adds	r1, r5, #6
   104ea:	305d      	adds	r0, #93	; 0x5d
   104ec:	f7f4 fa5e 	bl	49ac <m_print>
   104f0:	e1cf      	b.n	10892 <m_prov_adv_trans_tx_cb+0x416>
			break; 
		}

        // Mark that request handled
        SETB(p_adv_res->link_info, M_PROV_TX_REQ, false);
        SETB(p_adv_res->link_info, M_PROV_IN_TX, true);
   104f2:	0019      	movs	r1, r3
   104f4:	4391      	bics	r1, r2
   104f6:	000a      	movs	r2, r1
   104f8:	2102      	movs	r1, #2
   104fa:	430a      	orrs	r2, r1
   104fc:	8522      	strh	r2, [r4, #40]	; 0x28

        // check if acknowledgment must be transmitted
        if(GETB(p_adv_res->link_info, M_PROV_SEND_ACK))
   104fe:	06da      	lsls	r2, r3, #27
   10500:	d56b      	bpl.n	105da <m_prov_adv_trans_tx_cb+0x15e>
        {
        	M_PRINTF(L_PROV, "acknowledgment");
   10502:	6833      	ldr	r3, [r6, #0]
   10504:	071b      	lsls	r3, r3, #28
   10506:	d515      	bpl.n	10534 <m_prov_adv_trans_tx_cb+0xb8>
   10508:	4d97      	ldr	r5, [pc, #604]	; (10768 <m_prov_adv_trans_tx_cb+0x2ec>)
   1050a:	4f98      	ldr	r7, [pc, #608]	; (1076c <m_prov_adv_trans_tx_cb+0x2f0>)
   1050c:	002b      	movs	r3, r5
   1050e:	002a      	movs	r2, r5
   10510:	0028      	movs	r0, r5
   10512:	336b      	adds	r3, #107	; 0x6b
   10514:	0039      	movs	r1, r7
   10516:	3222      	adds	r2, #34	; 0x22
   10518:	9300      	str	r3, [sp, #0]
   1051a:	3035      	adds	r0, #53	; 0x35
   1051c:	23aa      	movs	r3, #170	; 0xaa
   1051e:	f7f4 fa45 	bl	49ac <m_print>
   10522:	4893      	ldr	r0, [pc, #588]	; (10770 <m_prov_adv_trans_tx_cb+0x2f4>)
   10524:	301f      	adds	r0, #31
   10526:	f7f4 fa41 	bl	49ac <m_print>
   1052a:	0028      	movs	r0, r5
   1052c:	1db9      	adds	r1, r7, #6
   1052e:	305d      	adds	r0, #93	; 0x5d
   10530:	f7f4 fa3c 	bl	49ac <m_print>
            m_tb_buf_t* p_ack_buf = p_adv_res->p_tx_adv_buf;
   10534:	69e7      	ldr	r7, [r4, #28]

            m_tb_buf_acquire(p_ack_buf);

            m_tb_buf_reuse(p_ack_buf, M_BEARER_ADV_HEAD_LEN, M_PROV_PB_ADV_PKT_MIN_LEN, 0);
            p_data = M_TB_BUF_DATA(p_ack_buf);
   10536:	003d      	movs	r5, r7
        if(GETB(p_adv_res->link_info, M_PROV_SEND_ACK))
        {
        	M_PRINTF(L_PROV, "acknowledgment");
            m_tb_buf_t* p_ack_buf = p_adv_res->p_tx_adv_buf;

            m_tb_buf_acquire(p_ack_buf);
   10538:	0038      	movs	r0, r7
   1053a:	f001 f8ab 	bl	11694 <m_tb_buf_acquire>

            m_tb_buf_reuse(p_ack_buf, M_BEARER_ADV_HEAD_LEN, M_PROV_PB_ADV_PKT_MIN_LEN, 0);
   1053e:	2206      	movs	r2, #6
   10540:	2300      	movs	r3, #0
   10542:	2102      	movs	r1, #2
   10544:	0038      	movs	r0, r7
   10546:	f001 f925 	bl	11794 <m_tb_buf_reuse>
            p_data = M_TB_BUF_DATA(p_ack_buf);
   1054a:	88bb      	ldrh	r3, [r7, #4]
__INLINE_S__ uint32_t co_htonl(uint32_t hostlong)
{
    #if (!CPU_LE)
        return hostlong;
    #else
        return co_bswap32(hostlong);
   1054c:	6a20      	ldr	r0, [r4, #32]
   1054e:	3530      	adds	r5, #48	; 0x30
   10550:	18ed      	adds	r5, r5, r3
   10552:	f7ff ff43 	bl	103dc <co_bswap32>
__INLINE_S__ void co_write32p(void const *ptr32, uint32_t value)
{
    uint8_t *ptr=(uint8_t*)ptr32;

    *ptr++ = (uint8_t)(value&0xff);
    *ptr++ = (uint8_t)((value&0xff00)>>8);
   10556:	0a03      	lsrs	r3, r0, #8
   10558:	706b      	strb	r3, [r5, #1]
    *ptr++ = (uint8_t)((value&0xff0000)>>16);
   1055a:	0c03      	lsrs	r3, r0, #16
   1055c:	70ab      	strb	r3, [r5, #2]
            // Fill link identifier
            co_write32p(p_data, co_htonl(p_adv_res->link_id));
            p_data += 4;

            // Check if Link ACK packet must be sent
            if(!GETB(p_adv_res->link_info, M_PROV_RX_OK))
   1055e:	2308      	movs	r3, #8
 */
__INLINE_S__ void co_write32p(void const *ptr32, uint32_t value)
{
    uint8_t *ptr=(uint8_t*)ptr32;

    *ptr++ = (uint8_t)(value&0xff);
   10560:	7028      	strb	r0, [r5, #0]
    *ptr++ = (uint8_t)((value&0xff00)>>8);
    *ptr++ = (uint8_t)((value&0xff0000)>>16);
    *ptr = (uint8_t)((value&0xff000000)>>24);
   10562:	0e00      	lsrs	r0, r0, #24
   10564:	70e8      	strb	r0, [r5, #3]
   10566:	8d22      	ldrh	r2, [r4, #40]	; 0x28
   10568:	4013      	ands	r3, r2
   1056a:	d103      	bne.n	10574 <m_prov_adv_trans_tx_cb+0xf8>
            {
                // Fill transaction number (0 for a control packet)
                *p_data = 0;
   1056c:	712b      	strb	r3, [r5, #4]
                p_data += 1;

                // Fill PDU Type
                SETF(*p_data, M_PROV_GPCF,   M_PROV_GPCF_BEARER_CTL);
                SETF(*p_data, M_PROV_OPCODE, M_PROV_LINK_ACK);
   1056e:	3307      	adds	r3, #7
   10570:	716b      	strb	r3, [r5, #5]
   10572:	e006      	b.n	10582 <m_prov_adv_trans_tx_cb+0x106>
            }
            // Or transaction ACK Open packet must be sent
            else
            {
                // Fill transaction number - receive transaction number
                *p_data = (p_adv_res->rx_trans_cursor - 1);
   10574:	0023      	movs	r3, r4
   10576:	332b      	adds	r3, #43	; 0x2b
   10578:	781b      	ldrb	r3, [r3, #0]
   1057a:	3b01      	subs	r3, #1
   1057c:	712b      	strb	r3, [r5, #4]
                p_data += 1;

                // Fill PDU Type
                SETF(*p_data, M_PROV_GPCF,   M_PROV_GPCF_TRANS_ACK);
                SETF(*p_data, M_PROV_OPCODE, 0);
   1057e:	2301      	movs	r3, #1
   10580:	716b      	strb	r3, [r5, #5]
            }

            // mark that packet acknowledgment performed
            SETB(p_adv_res->link_info, M_PROV_SEND_ACK, false);
   10582:	2210      	movs	r2, #16
   10584:	8d23      	ldrh	r3, [r4, #40]	; 0x28

            if(m_prov_bearer_send(p_ack_buf) != M_ERR_NO_ERROR)
   10586:	0038      	movs	r0, r7
                SETF(*p_data, M_PROV_GPCF,   M_PROV_GPCF_TRANS_ACK);
                SETF(*p_data, M_PROV_OPCODE, 0);
            }

            // mark that packet acknowledgment performed
            SETB(p_adv_res->link_info, M_PROV_SEND_ACK, false);
   10588:	4393      	bics	r3, r2
   1058a:	8523      	strh	r3, [r4, #40]	; 0x28

            if(m_prov_bearer_send(p_ack_buf) != M_ERR_NO_ERROR)
   1058c:	f000 fe36 	bl	111fc <m_prov_bearer_send>
   10590:	2800      	cmp	r0, #0
   10592:	d100      	bne.n	10596 <m_prov_adv_trans_tx_cb+0x11a>
   10594:	e17d      	b.n	10892 <m_prov_adv_trans_tx_cb+0x416>
            {
                SETB(p_adv_res->link_info, M_PROV_IN_TX, false);
   10596:	2202      	movs	r2, #2
   10598:	8d23      	ldrh	r3, [r4, #40]	; 0x28

                m_tb_buf_release(p_ack_buf);
   1059a:	0038      	movs	r0, r7
            // mark that packet acknowledgment performed
            SETB(p_adv_res->link_info, M_PROV_SEND_ACK, false);

            if(m_prov_bearer_send(p_ack_buf) != M_ERR_NO_ERROR)
            {
                SETB(p_adv_res->link_info, M_PROV_IN_TX, false);
   1059c:	4393      	bics	r3, r2
   1059e:	8523      	strh	r3, [r4, #40]	; 0x28

                m_tb_buf_release(p_ack_buf);
   105a0:	f001 f87c 	bl	1169c <m_tb_buf_release>

                // Consider Bearer as closed
                M_PRINTF(L_PROV, "adv send error");
   105a4:	6833      	ldr	r3, [r6, #0]
   105a6:	071b      	lsls	r3, r3, #28
   105a8:	d400      	bmi.n	105ac <m_prov_adv_trans_tx_cb+0x130>
   105aa:	e150      	b.n	1084e <m_prov_adv_trans_tx_cb+0x3d2>
   105ac:	4c6e      	ldr	r4, [pc, #440]	; (10768 <m_prov_adv_trans_tx_cb+0x2ec>)
   105ae:	4d6f      	ldr	r5, [pc, #444]	; (1076c <m_prov_adv_trans_tx_cb+0x2f0>)
   105b0:	0023      	movs	r3, r4
   105b2:	0022      	movs	r2, r4
   105b4:	0020      	movs	r0, r4
   105b6:	336b      	adds	r3, #107	; 0x6b
   105b8:	9300      	str	r3, [sp, #0]
   105ba:	3222      	adds	r2, #34	; 0x22
   105bc:	3035      	adds	r0, #53	; 0x35
   105be:	23d7      	movs	r3, #215	; 0xd7
   105c0:	0029      	movs	r1, r5
   105c2:	f7f4 f9f3 	bl	49ac <m_print>
   105c6:	486a      	ldr	r0, [pc, #424]	; (10770 <m_prov_adv_trans_tx_cb+0x2f4>)
   105c8:	302e      	adds	r0, #46	; 0x2e
   105ca:	f7f4 f9ef 	bl	49ac <m_print>
   105ce:	0020      	movs	r0, r4
   105d0:	1da9      	adds	r1, r5, #6
   105d2:	305d      	adds	r0, #93	; 0x5d
   105d4:	f7f4 f9ea 	bl	49ac <m_print>
   105d8:	e139      	b.n	1084e <m_prov_adv_trans_tx_cb+0x3d2>
                m_prov_link_closed(M_PROV_BEARER_CLOSED);
            }
        }
        // Check if Link Close packet must be sent
        else if(GETB(p_adv_res->link_info, M_PROV_SEND_LINK_CLOSE))
   105da:	069b      	lsls	r3, r3, #26
   105dc:	d559      	bpl.n	10692 <m_prov_adv_trans_tx_cb+0x216>
        {
        	M_PRINTF(L_PROV, "link close packet");
   105de:	6833      	ldr	r3, [r6, #0]
   105e0:	071b      	lsls	r3, r3, #28
   105e2:	d515      	bpl.n	10610 <m_prov_adv_trans_tx_cb+0x194>
   105e4:	4d60      	ldr	r5, [pc, #384]	; (10768 <m_prov_adv_trans_tx_cb+0x2ec>)
   105e6:	4f61      	ldr	r7, [pc, #388]	; (1076c <m_prov_adv_trans_tx_cb+0x2f0>)
   105e8:	002b      	movs	r3, r5
   105ea:	002a      	movs	r2, r5
   105ec:	0028      	movs	r0, r5
   105ee:	336b      	adds	r3, #107	; 0x6b
   105f0:	0039      	movs	r1, r7
   105f2:	3222      	adds	r2, #34	; 0x22
   105f4:	9300      	str	r3, [sp, #0]
   105f6:	3035      	adds	r0, #53	; 0x35
   105f8:	23de      	movs	r3, #222	; 0xde
   105fa:	f7f4 f9d7 	bl	49ac <m_print>
   105fe:	485c      	ldr	r0, [pc, #368]	; (10770 <m_prov_adv_trans_tx_cb+0x2f4>)
   10600:	303d      	adds	r0, #61	; 0x3d
   10602:	f7f4 f9d3 	bl	49ac <m_print>
   10606:	0028      	movs	r0, r5
   10608:	1db9      	adds	r1, r7, #6
   1060a:	305d      	adds	r0, #93	; 0x5d
   1060c:	f7f4 f9ce 	bl	49ac <m_print>
            m_tb_buf_t* p_close_buf = p_adv_res->p_tx_adv_buf;
   10610:	69e7      	ldr	r7, [r4, #28]
            m_tb_buf_acquire(p_close_buf);

            m_tb_buf_reuse(p_close_buf, M_BEARER_ADV_HEAD_LEN, M_PROV_PB_ADV_PKT_MIN_LEN + M_PROV_REASON_LEN, 0);
            p_data = M_TB_BUF_DATA(p_close_buf);
   10612:	003d      	movs	r5, r7
        // Check if Link Close packet must be sent
        else if(GETB(p_adv_res->link_info, M_PROV_SEND_LINK_CLOSE))
        {
        	M_PRINTF(L_PROV, "link close packet");
            m_tb_buf_t* p_close_buf = p_adv_res->p_tx_adv_buf;
            m_tb_buf_acquire(p_close_buf);
   10614:	0038      	movs	r0, r7
   10616:	f001 f83d 	bl	11694 <m_tb_buf_acquire>

            m_tb_buf_reuse(p_close_buf, M_BEARER_ADV_HEAD_LEN, M_PROV_PB_ADV_PKT_MIN_LEN + M_PROV_REASON_LEN, 0);
   1061a:	2300      	movs	r3, #0
   1061c:	2207      	movs	r2, #7
   1061e:	2102      	movs	r1, #2
   10620:	0038      	movs	r0, r7
   10622:	f001 f8b7 	bl	11794 <m_tb_buf_reuse>
            p_data = M_TB_BUF_DATA(p_close_buf);
   10626:	88bb      	ldrh	r3, [r7, #4]
   10628:	6a20      	ldr	r0, [r4, #32]
   1062a:	3530      	adds	r5, #48	; 0x30
   1062c:	18ed      	adds	r5, r5, r3
   1062e:	f7ff fed5 	bl	103dc <co_bswap32>
__INLINE_S__ void co_write32p(void const *ptr32, uint32_t value)
{
    uint8_t *ptr=(uint8_t*)ptr32;

    *ptr++ = (uint8_t)(value&0xff);
    *ptr++ = (uint8_t)((value&0xff00)>>8);
   10632:	0a03      	lsrs	r3, r0, #8
   10634:	706b      	strb	r3, [r5, #1]
    *ptr++ = (uint8_t)((value&0xff0000)>>16);
   10636:	0c03      	lsrs	r3, r0, #16
   10638:	70ab      	strb	r3, [r5, #2]
            // Fill link identifier
            co_write32p(p_data, co_htonl(p_adv_res->link_id));
            p_data += 4;

            // Fill transaction number (0 for a control packet)
            *p_data = 0;
   1063a:	2300      	movs	r3, #0
   1063c:	712b      	strb	r3, [r5, #4]
            p_data += 1;

            // Fill PDU Type
            SETF(*p_data, M_PROV_GPCF,   M_PROV_GPCF_BEARER_CTL);
            SETF(*p_data, M_PROV_OPCODE, M_PROV_LINK_CLOSE);
   1063e:	330b      	adds	r3, #11
   10640:	716b      	strb	r3, [r5, #5]
            p_data += 1;

            // Fill Reason
            *p_data = p_adv_res->close_reason;
   10642:	0023      	movs	r3, r4
 */
__INLINE_S__ void co_write32p(void const *ptr32, uint32_t value)
{
    uint8_t *ptr=(uint8_t*)ptr32;

    *ptr++ = (uint8_t)(value&0xff);
   10644:	7028      	strb	r0, [r5, #0]
    *ptr++ = (uint8_t)((value&0xff00)>>8);
    *ptr++ = (uint8_t)((value&0xff0000)>>16);
    *ptr = (uint8_t)((value&0xff000000)>>24);
   10646:	0e00      	lsrs	r0, r0, #24
   10648:	70e8      	strb	r0, [r5, #3]
   1064a:	332c      	adds	r3, #44	; 0x2c
   1064c:	781b      	ldrb	r3, [r3, #0]

            if(m_prov_bearer_send(p_close_buf) != M_ERR_NO_ERROR){
   1064e:	0038      	movs	r0, r7
            SETF(*p_data, M_PROV_GPCF,   M_PROV_GPCF_BEARER_CTL);
            SETF(*p_data, M_PROV_OPCODE, M_PROV_LINK_CLOSE);
            p_data += 1;

            // Fill Reason
            *p_data = p_adv_res->close_reason;
   10650:	71ab      	strb	r3, [r5, #6]

            if(m_prov_bearer_send(p_close_buf) != M_ERR_NO_ERROR){
   10652:	f000 fdd3 	bl	111fc <m_prov_bearer_send>
   10656:	2800      	cmp	r0, #0
   10658:	d100      	bne.n	1065c <m_prov_adv_trans_tx_cb+0x1e0>
   1065a:	e11a      	b.n	10892 <m_prov_adv_trans_tx_cb+0x416>
                SETB(p_adv_res->link_info, M_PROV_IN_TX, false);
   1065c:	2202      	movs	r2, #2
   1065e:	8d23      	ldrh	r3, [r4, #40]	; 0x28

                m_tb_buf_release(p_close_buf);
   10660:	0038      	movs	r0, r7

            // Fill Reason
            *p_data = p_adv_res->close_reason;

            if(m_prov_bearer_send(p_close_buf) != M_ERR_NO_ERROR){
                SETB(p_adv_res->link_info, M_PROV_IN_TX, false);
   10662:	4393      	bics	r3, r2
   10664:	8523      	strh	r3, [r4, #40]	; 0x28

                m_tb_buf_release(p_close_buf);
   10666:	f001 f819 	bl	1169c <m_tb_buf_release>
                // Consider Bearer as closed
                M_PRINTF(L_PROV, "link close");
   1066a:	6833      	ldr	r3, [r6, #0]
   1066c:	071b      	lsls	r3, r3, #28
   1066e:	d400      	bmi.n	10672 <m_prov_adv_trans_tx_cb+0x1f6>
   10670:	e0ed      	b.n	1084e <m_prov_adv_trans_tx_cb+0x3d2>
   10672:	4c3d      	ldr	r4, [pc, #244]	; (10768 <m_prov_adv_trans_tx_cb+0x2ec>)
   10674:	4d3d      	ldr	r5, [pc, #244]	; (1076c <m_prov_adv_trans_tx_cb+0x2f0>)
   10676:	0023      	movs	r3, r4
   10678:	0022      	movs	r2, r4
   1067a:	0020      	movs	r0, r4
   1067c:	336b      	adds	r3, #107	; 0x6b
   1067e:	9300      	str	r3, [sp, #0]
   10680:	3222      	adds	r2, #34	; 0x22
   10682:	3035      	adds	r0, #53	; 0x35
   10684:	23fa      	movs	r3, #250	; 0xfa
   10686:	0029      	movs	r1, r5
   10688:	f7f4 f990 	bl	49ac <m_print>
   1068c:	4838      	ldr	r0, [pc, #224]	; (10770 <m_prov_adv_trans_tx_cb+0x2f4>)
   1068e:	304f      	adds	r0, #79	; 0x4f
   10690:	e79b      	b.n	105ca <m_prov_adv_trans_tx_cb+0x14e>
                m_prov_link_closed(M_PROV_BEARER_CLOSED);
            }
        }
        // Check if packet must be transmitted
        else if(!co_list_is_empty(&(p_adv_res->tx_queue))){
   10692:	6962      	ldr	r2, [r4, #20]
   10694:	2308      	movs	r3, #8
   10696:	2a00      	cmp	r2, #0
   10698:	d100      	bne.n	1069c <m_prov_adv_trans_tx_cb+0x220>
   1069a:	e0dc      	b.n	10856 <m_prov_adv_trans_tx_cb+0x3da>
        	M_PRINTF(L_PROV, "tx_queue is not empty");
   1069c:	6832      	ldr	r2, [r6, #0]
   1069e:	421a      	tst	r2, r3
   106a0:	d016      	beq.n	106d0 <m_prov_adv_trans_tx_cb+0x254>
   106a2:	4d31      	ldr	r5, [pc, #196]	; (10768 <m_prov_adv_trans_tx_cb+0x2ec>)
   106a4:	4f31      	ldr	r7, [pc, #196]	; (1076c <m_prov_adv_trans_tx_cb+0x2f0>)
   106a6:	002b      	movs	r3, r5
   106a8:	336b      	adds	r3, #107	; 0x6b
   106aa:	9300      	str	r3, [sp, #0]
   106ac:	002a      	movs	r2, r5
   106ae:	0028      	movs	r0, r5
   106b0:	2380      	movs	r3, #128	; 0x80
   106b2:	0039      	movs	r1, r7
   106b4:	3222      	adds	r2, #34	; 0x22
   106b6:	005b      	lsls	r3, r3, #1
   106b8:	3035      	adds	r0, #53	; 0x35
   106ba:	f7f4 f977 	bl	49ac <m_print>
   106be:	482c      	ldr	r0, [pc, #176]	; (10770 <m_prov_adv_trans_tx_cb+0x2f4>)
   106c0:	305a      	adds	r0, #90	; 0x5a
   106c2:	f7f4 f973 	bl	49ac <m_print>
   106c6:	0028      	movs	r0, r5
   106c8:	1db9      	adds	r1, r7, #6
   106ca:	305d      	adds	r0, #93	; 0x5d
   106cc:	f7f4 f96e 	bl	49ac <m_print>
            m_tb_buf_t*       p_seg_buf    = NULL;
            m_tb_buf_t*       p_tx_buf     = (m_tb_buf_t*) co_list_pick(&(p_adv_res->tx_queue));
            m_prov_buf_env_t* p_tx_buf_env = (m_prov_buf_env_t*) p_tx_buf->env;

            p_seg_buf = p_adv_res->p_tx_adv_buf;
   106d0:	69e3      	ldr	r3, [r4, #28]
   106d2:	6965      	ldr	r5, [r4, #20]

            m_tb_buf_acquire(p_seg_buf);
   106d4:	0018      	movs	r0, r3
        	M_PRINTF(L_PROV, "tx_queue is not empty");
            m_tb_buf_t*       p_seg_buf    = NULL;
            m_tb_buf_t*       p_tx_buf     = (m_tb_buf_t*) co_list_pick(&(p_adv_res->tx_queue));
            m_prov_buf_env_t* p_tx_buf_env = (m_prov_buf_env_t*) p_tx_buf->env;

            p_seg_buf = p_adv_res->p_tx_adv_buf;
   106d6:	9302      	str	r3, [sp, #8]

            m_tb_buf_acquire(p_seg_buf);
   106d8:	f000 ffdc 	bl	11694 <m_tb_buf_acquire>
            // Segment start
            if(p_tx_buf_env->seg_cursor == 0){
   106dc:	7d2b      	ldrb	r3, [r5, #20]
   106de:	2b00      	cmp	r3, #0
   106e0:	d148      	bne.n	10774 <m_prov_adv_trans_tx_cb+0x2f8>
                uint16_t data_len = M_PROV_TRANS_START_PLD_MAX_LEN;
                if(p_tx_buf->data_len < data_len){
   106e2:	892f      	ldrh	r7, [r5, #8]
   106e4:	2f12      	cmp	r7, #18
   106e6:	d900      	bls.n	106ea <m_prov_adv_trans_tx_cb+0x26e>
            p_seg_buf = p_adv_res->p_tx_adv_buf;

            m_tb_buf_acquire(p_seg_buf);
            // Segment start
            if(p_tx_buf_env->seg_cursor == 0){
                uint16_t data_len = M_PROV_TRANS_START_PLD_MAX_LEN;
   106e8:	2713      	movs	r7, #19
                if(p_tx_buf->data_len < data_len){
                    data_len = p_tx_buf->data_len;
                }

                // Update buffer length
                m_tb_buf_reuse(p_seg_buf, M_BEARER_ADV_HEAD_LEN,
   106ea:	003a      	movs	r2, r7
   106ec:	320a      	adds	r2, #10
   106ee:	b292      	uxth	r2, r2
   106f0:	2102      	movs	r1, #2
   106f2:	2300      	movs	r3, #0
   106f4:	9802      	ldr	r0, [sp, #8]
   106f6:	f001 f84d 	bl	11794 <m_tb_buf_reuse>
                               M_PROV_PB_ADV_PKT_MIN_LEN + M_PROV_TRANS_START_PDU_MIN_LEN + data_len, 0);

                p_data = M_TB_BUF_DATA(p_seg_buf);
   106fa:	9b02      	ldr	r3, [sp, #8]
   106fc:	6a20      	ldr	r0, [r4, #32]
   106fe:	889e      	ldrh	r6, [r3, #4]
   10700:	3330      	adds	r3, #48	; 0x30
   10702:	199e      	adds	r6, r3, r6
   10704:	f7ff fe6a 	bl	103dc <co_bswap32>
                // Fill transaction number
                *p_data = p_tx_buf_env->trans_nb;
                p_data += 1;

                // Fill PDU Type
                SETF(*p_data, M_PROV_GPCF,   M_PROV_GPCF_TRANS_START);
   10708:	2203      	movs	r2, #3
__INLINE_S__ void co_write32p(void const *ptr32, uint32_t value)
{
    uint8_t *ptr=(uint8_t*)ptr32;

    *ptr++ = (uint8_t)(value&0xff);
    *ptr++ = (uint8_t)((value&0xff00)>>8);
   1070a:	0a03      	lsrs	r3, r0, #8
 */
__INLINE_S__ void co_write32p(void const *ptr32, uint32_t value)
{
    uint8_t *ptr=(uint8_t*)ptr32;

    *ptr++ = (uint8_t)(value&0xff);
   1070c:	7030      	strb	r0, [r6, #0]
    *ptr++ = (uint8_t)((value&0xff00)>>8);
   1070e:	7073      	strb	r3, [r6, #1]
    *ptr++ = (uint8_t)((value&0xff0000)>>16);
   10710:	0c03      	lsrs	r3, r0, #16
    *ptr = (uint8_t)((value&0xff000000)>>24);
   10712:	0e00      	lsrs	r0, r0, #24
{
    uint8_t *ptr=(uint8_t*)ptr32;

    *ptr++ = (uint8_t)(value&0xff);
    *ptr++ = (uint8_t)((value&0xff00)>>8);
    *ptr++ = (uint8_t)((value&0xff0000)>>16);
   10714:	70b3      	strb	r3, [r6, #2]
    *ptr = (uint8_t)((value&0xff000000)>>24);
   10716:	70f0      	strb	r0, [r6, #3]
                // Fill link identifier
                co_write32p(p_data, co_htonl(p_adv_res->link_id));
                p_data += 4;

                // Fill transaction number
                *p_data = p_tx_buf_env->trans_nb;
   10718:	7d6b      	ldrb	r3, [r5, #21]
   1071a:	7133      	strb	r3, [r6, #4]
                p_data += 1;

                // Fill PDU Type
                SETF(*p_data, M_PROV_GPCF,   M_PROV_GPCF_TRANS_START);
   1071c:	7973      	ldrb	r3, [r6, #5]
   1071e:	4393      	bics	r3, r2
   10720:	7173      	strb	r3, [r6, #5]
                SETF(*p_data, M_PROV_SEG_N,  p_tx_buf_env->seg_nb - 1);
   10722:	7ceb      	ldrb	r3, [r5, #19]
   10724:	32f9      	adds	r2, #249	; 0xf9
   10726:	3b01      	subs	r3, #1
   10728:	009b      	lsls	r3, r3, #2
   1072a:	0019      	movs	r1, r3
   1072c:	4391      	bics	r1, r2
   1072e:	000a      	movs	r2, r1
   10730:	2a00      	cmp	r2, #0
   10732:	d1fd      	bne.n	10730 <m_prov_adv_trans_tx_cb+0x2b4>
                // Fill PDU Type
                *p_data = p_tx_buf_env->pdu_type;
                p_data += 1;

                // Fill Data
                memcpy(p_data, M_TB_BUF_DATA(p_tx_buf), data_len);
   10734:	0029      	movs	r1, r5
   10736:	0030      	movs	r0, r6
                *p_data = p_tx_buf_env->trans_nb;
                p_data += 1;

                // Fill PDU Type
                SETF(*p_data, M_PROV_GPCF,   M_PROV_GPCF_TRANS_START);
                SETF(*p_data, M_PROV_SEG_N,  p_tx_buf_env->seg_nb - 1);
   10738:	7173      	strb	r3, [r6, #5]
   1073a:	892b      	ldrh	r3, [r5, #8]
                // Fill PDU Type
                *p_data = p_tx_buf_env->pdu_type;
                p_data += 1;

                // Fill Data
                memcpy(p_data, M_TB_BUF_DATA(p_tx_buf), data_len);
   1073c:	3130      	adds	r1, #48	; 0x30
   1073e:	3301      	adds	r3, #1
   10740:	ba5b      	rev16	r3, r3
   10742:	b29b      	uxth	r3, r3
 */
__INLINE_S__ void co_write16p(void const *ptr16, uint16_t value)
{
    uint8_t *ptr=(uint8_t*)ptr16;

    *ptr++ = value&0xff;
   10744:	71b3      	strb	r3, [r6, #6]
    *ptr = (value&0xff00)>>8;
   10746:	0a1b      	lsrs	r3, r3, #8
   10748:	71f3      	strb	r3, [r6, #7]
                // Fill Total Packet length
                co_write16p(p_data, co_htons(p_tx_buf->data_len + 1));
                p_data += 2;

                // Fill FCS
                *p_data = p_tx_buf_env->fcs;
   1074a:	7c6b      	ldrb	r3, [r5, #17]
                // Fill PDU Type
                *p_data = p_tx_buf_env->pdu_type;
                p_data += 1;

                // Fill Data
                memcpy(p_data, M_TB_BUF_DATA(p_tx_buf), data_len);
   1074c:	003a      	movs	r2, r7
                // Fill Total Packet length
                co_write16p(p_data, co_htons(p_tx_buf->data_len + 1));
                p_data += 2;

                // Fill FCS
                *p_data = p_tx_buf_env->fcs;
   1074e:	7233      	strb	r3, [r6, #8]
                p_data += 1;

                // Fill PDU Type
                *p_data = p_tx_buf_env->pdu_type;
   10750:	7c2b      	ldrb	r3, [r5, #16]
                p_data += 1;

                // Fill Data
                memcpy(p_data, M_TB_BUF_DATA(p_tx_buf), data_len);
   10752:	300a      	adds	r0, #10
                // Fill FCS
                *p_data = p_tx_buf_env->fcs;
                p_data += 1;

                // Fill PDU Type
                *p_data = p_tx_buf_env->pdu_type;
   10754:	7273      	strb	r3, [r6, #9]
                p_data += 1;

                // Fill Data
                memcpy(p_data, M_TB_BUF_DATA(p_tx_buf), data_len);
   10756:	88ab      	ldrh	r3, [r5, #4]
   10758:	18c9      	adds	r1, r1, r3
   1075a:	f005 f939 	bl	159d0 <memcpy>
   1075e:	e061      	b.n	10824 <m_prov_adv_trans_tx_cb+0x3a8>
   10760:	100128a4 	.word	0x100128a4
   10764:	10010514 	.word	0x10010514
   10768:	000223c3 	.word	0x000223c3
   1076c:	000222c3 	.word	0x000222c3
   10770:	00022443 	.word	0x00022443
            }
            else{
				M_PRINTF(L_PROV, "tx_queue is empty");
   10774:	6833      	ldr	r3, [r6, #0]
   10776:	071b      	lsls	r3, r3, #28
   10778:	d516      	bpl.n	107a8 <m_prov_adv_trans_tx_cb+0x32c>
   1077a:	4e47      	ldr	r6, [pc, #284]	; (10898 <m_prov_adv_trans_tx_cb+0x41c>)
   1077c:	4f47      	ldr	r7, [pc, #284]	; (1089c <m_prov_adv_trans_tx_cb+0x420>)
   1077e:	0033      	movs	r3, r6
   10780:	336b      	adds	r3, #107	; 0x6b
   10782:	9300      	str	r3, [sp, #0]
   10784:	0032      	movs	r2, r6
   10786:	0030      	movs	r0, r6
   10788:	2399      	movs	r3, #153	; 0x99
   1078a:	0039      	movs	r1, r7
   1078c:	3222      	adds	r2, #34	; 0x22
   1078e:	005b      	lsls	r3, r3, #1
   10790:	3035      	adds	r0, #53	; 0x35
   10792:	f7f4 f90b 	bl	49ac <m_print>
   10796:	4842      	ldr	r0, [pc, #264]	; (108a0 <m_prov_adv_trans_tx_cb+0x424>)
   10798:	3070      	adds	r0, #112	; 0x70
   1079a:	f7f4 f907 	bl	49ac <m_print>
   1079e:	0030      	movs	r0, r6
   107a0:	1db9      	adds	r1, r7, #6
   107a2:	305d      	adds	r0, #93	; 0x5d
   107a4:	f7f4 f902 	bl	49ac <m_print>
                uint16_t offset   = M_PROV_TRANS_START_PLD_MAX_LEN
   107a8:	2717      	movs	r7, #23
   107aa:	7d29      	ldrb	r1, [r5, #20]
   107ac:	3901      	subs	r1, #1
   107ae:	4379      	muls	r1, r7
   107b0:	3113      	adds	r1, #19
   107b2:	b28b      	uxth	r3, r1
   107b4:	9303      	str	r3, [sp, #12]
                                  + (M_PROV_TRANS_CONT_PLD_MAX_LEN * (p_tx_buf_env->seg_cursor - 1));
                uint16_t data_len = M_PROV_TRANS_CONT_PLD_MAX_LEN;
                if((p_tx_buf->data_len - offset) < data_len){
   107b6:	892b      	ldrh	r3, [r5, #8]
   107b8:	9a03      	ldr	r2, [sp, #12]
   107ba:	1a9b      	subs	r3, r3, r2
   107bc:	2b16      	cmp	r3, #22
   107be:	dc00      	bgt.n	107c2 <m_prov_adv_trans_tx_cb+0x346>
                    data_len = p_tx_buf->data_len - offset;
   107c0:	b29f      	uxth	r7, r3
                }

                // Update buffer length
                m_tb_buf_reuse(p_seg_buf, M_BEARER_ADV_HEAD_LEN, M_PROV_PB_ADV_PKT_MIN_LEN + data_len, 0);
   107c2:	1dba      	adds	r2, r7, #6
   107c4:	b292      	uxth	r2, r2
   107c6:	2102      	movs	r1, #2
   107c8:	2300      	movs	r3, #0
   107ca:	9802      	ldr	r0, [sp, #8]
   107cc:	f000 ffe2 	bl	11794 <m_tb_buf_reuse>

                p_data = M_TB_BUF_DATA(p_seg_buf);
   107d0:	9b02      	ldr	r3, [sp, #8]
   107d2:	6a20      	ldr	r0, [r4, #32]
   107d4:	889e      	ldrh	r6, [r3, #4]
   107d6:	3330      	adds	r3, #48	; 0x30
   107d8:	199e      	adds	r6, r3, r6
   107da:	f7ff fdff 	bl	103dc <co_bswap32>
__INLINE_S__ void co_write32p(void const *ptr32, uint32_t value)
{
    uint8_t *ptr=(uint8_t*)ptr32;

    *ptr++ = (uint8_t)(value&0xff);
    *ptr++ = (uint8_t)((value&0xff00)>>8);
   107de:	0a03      	lsrs	r3, r0, #8
 */
__INLINE_S__ void co_write32p(void const *ptr32, uint32_t value)
{
    uint8_t *ptr=(uint8_t*)ptr32;

    *ptr++ = (uint8_t)(value&0xff);
   107e0:	7030      	strb	r0, [r6, #0]
    *ptr++ = (uint8_t)((value&0xff00)>>8);
   107e2:	7073      	strb	r3, [r6, #1]
    *ptr++ = (uint8_t)((value&0xff0000)>>16);
   107e4:	0c03      	lsrs	r3, r0, #16
    *ptr = (uint8_t)((value&0xff000000)>>24);
   107e6:	0e00      	lsrs	r0, r0, #24
   107e8:	70f0      	strb	r0, [r6, #3]
{
    uint8_t *ptr=(uint8_t*)ptr32;

    *ptr++ = (uint8_t)(value&0xff);
    *ptr++ = (uint8_t)((value&0xff00)>>8);
    *ptr++ = (uint8_t)((value&0xff0000)>>16);
   107ea:	70b3      	strb	r3, [r6, #2]
                // Fill link identifier
                co_write32p(p_data, co_htonl(p_adv_res->link_id));
                p_data += 4;

                // Fill transaction number
                *p_data = p_tx_buf_env->trans_nb;
   107ec:	7d6b      	ldrb	r3, [r5, #21]
                p_data += 1;

                // Fill PDU Type
                SETF(*p_data, M_PROV_GPCF,   M_PROV_GPCF_TRANS_CONT);
   107ee:	2102      	movs	r1, #2
                // Fill link identifier
                co_write32p(p_data, co_htonl(p_adv_res->link_id));
                p_data += 4;

                // Fill transaction number
                *p_data = p_tx_buf_env->trans_nb;
   107f0:	7133      	strb	r3, [r6, #4]
                p_data += 1;

                // Fill PDU Type
                SETF(*p_data, M_PROV_GPCF,   M_PROV_GPCF_TRANS_CONT);
   107f2:	2303      	movs	r3, #3
   107f4:	7972      	ldrb	r2, [r6, #5]
   107f6:	439a      	bics	r2, r3
   107f8:	430a      	orrs	r2, r1
   107fa:	7172      	strb	r2, [r6, #5]
                SETF(*p_data, M_PROV_SEG_N,  p_tx_buf_env->seg_cursor);
   107fc:	7d2b      	ldrb	r3, [r5, #20]
   107fe:	22fc      	movs	r2, #252	; 0xfc
   10800:	408b      	lsls	r3, r1
   10802:	0018      	movs	r0, r3
   10804:	4390      	bics	r0, r2
   10806:	0002      	movs	r2, r0
   10808:	2a00      	cmp	r2, #0
   1080a:	d1fd      	bne.n	10808 <m_prov_adv_trans_tx_cb+0x38c>
   1080c:	430b      	orrs	r3, r1
   1080e:	7173      	strb	r3, [r6, #5]
                p_data += 1;

                // Fill Data
                memcpy(p_data, M_TB_BUF_DATA(p_tx_buf) + offset, data_len);
   10810:	88a9      	ldrh	r1, [r5, #4]
   10812:	9b03      	ldr	r3, [sp, #12]
   10814:	1db0      	adds	r0, r6, #6
   10816:	18c9      	adds	r1, r1, r3
   10818:	002b      	movs	r3, r5
   1081a:	3330      	adds	r3, #48	; 0x30
   1081c:	1859      	adds	r1, r3, r1
   1081e:	003a      	movs	r2, r7
   10820:	f005 f8d6 	bl	159d0 <memcpy>
            }

            // Change segment cursor position
            p_tx_buf_env->seg_cursor += 1;
   10824:	7d2b      	ldrb	r3, [r5, #20]
            if(p_tx_buf_env->seg_cursor >= p_tx_buf_env->seg_nb){
   10826:	7cea      	ldrb	r2, [r5, #19]
                // Fill Data
                memcpy(p_data, M_TB_BUF_DATA(p_tx_buf) + offset, data_len);
            }

            // Change segment cursor position
            p_tx_buf_env->seg_cursor += 1;
   10828:	3301      	adds	r3, #1
   1082a:	b2db      	uxtb	r3, r3
   1082c:	752b      	strb	r3, [r5, #20]
            if(p_tx_buf_env->seg_cursor >= p_tx_buf_env->seg_nb){
   1082e:	429a      	cmp	r2, r3
   10830:	d801      	bhi.n	10836 <m_prov_adv_trans_tx_cb+0x3ba>
                p_tx_buf_env->seg_cursor = 0;
   10832:	2300      	movs	r3, #0
   10834:	752b      	strb	r3, [r5, #20]
            }
            if(m_prov_bearer_send(p_seg_buf) != M_ERR_NO_ERROR){
   10836:	9802      	ldr	r0, [sp, #8]
   10838:	f000 fce0 	bl	111fc <m_prov_bearer_send>
   1083c:	2800      	cmp	r0, #0
   1083e:	d028      	beq.n	10892 <m_prov_adv_trans_tx_cb+0x416>
                SETB(p_adv_res->link_info, M_PROV_IN_TX, false);
   10840:	2202      	movs	r2, #2
   10842:	8d23      	ldrh	r3, [r4, #40]	; 0x28

                m_tb_buf_release(p_seg_buf);
   10844:	9802      	ldr	r0, [sp, #8]
            p_tx_buf_env->seg_cursor += 1;
            if(p_tx_buf_env->seg_cursor >= p_tx_buf_env->seg_nb){
                p_tx_buf_env->seg_cursor = 0;
            }
            if(m_prov_bearer_send(p_seg_buf) != M_ERR_NO_ERROR){
                SETB(p_adv_res->link_info, M_PROV_IN_TX, false);
   10846:	4393      	bics	r3, r2
   10848:	8523      	strh	r3, [r4, #40]	; 0x28

                m_tb_buf_release(p_seg_buf);
   1084a:	f000 ff27 	bl	1169c <m_tb_buf_release>

                // Mark Link Closed
                m_prov_link_closed(M_PROV_BEARER_CLOSED);
   1084e:	20fe      	movs	r0, #254	; 0xfe
   10850:	f7ff fcbc 	bl	101cc <m_prov_link_closed>
   10854:	e01d      	b.n	10892 <m_prov_adv_trans_tx_cb+0x416>
            }
        }
        else
        {
        	M_PRINTF(L_PROV, "NOTHING TO BE SENT");
   10856:	6832      	ldr	r2, [r6, #0]
   10858:	421a      	tst	r2, r3
   1085a:	d016      	beq.n	1088a <m_prov_adv_trans_tx_cb+0x40e>
   1085c:	4d0e      	ldr	r5, [pc, #56]	; (10898 <m_prov_adv_trans_tx_cb+0x41c>)
   1085e:	4e0f      	ldr	r6, [pc, #60]	; (1089c <m_prov_adv_trans_tx_cb+0x420>)
   10860:	002b      	movs	r3, r5
   10862:	336b      	adds	r3, #107	; 0x6b
   10864:	9300      	str	r3, [sp, #0]
   10866:	002a      	movs	r2, r5
   10868:	0028      	movs	r0, r5
   1086a:	23b0      	movs	r3, #176	; 0xb0
   1086c:	0031      	movs	r1, r6
   1086e:	3222      	adds	r2, #34	; 0x22
   10870:	005b      	lsls	r3, r3, #1
   10872:	3035      	adds	r0, #53	; 0x35
   10874:	f7f4 f89a 	bl	49ac <m_print>
   10878:	480a      	ldr	r0, [pc, #40]	; (108a4 <m_prov_adv_trans_tx_cb+0x428>)
   1087a:	3002      	adds	r0, #2
   1087c:	f7f4 f896 	bl	49ac <m_print>
   10880:	0028      	movs	r0, r5
   10882:	1db1      	adds	r1, r6, #6
   10884:	305d      	adds	r0, #93	; 0x5d
   10886:	f7f4 f891 	bl	49ac <m_print>
            // NOTHING TO BE SENT - abort
            SETB(p_adv_res->link_info, M_PROV_IN_TX, false);
   1088a:	2202      	movs	r2, #2
   1088c:	8d23      	ldrh	r3, [r4, #40]	; 0x28
   1088e:	4393      	bics	r3, r2
   10890:	8523      	strh	r3, [r4, #40]	; 0x28
        }

    } while(0);
}
   10892:	b005      	add	sp, #20
   10894:	bdf0      	pop	{r4, r5, r6, r7, pc}
   10896:	46c0      	nop			; (mov r8, r8)
   10898:	000223c3 	.word	0x000223c3
   1089c:	000222c3 	.word	0x000222c3
   108a0:	00022443 	.word	0x00022443
   108a4:	000224c3 	.word	0x000224c3

000108a8 <m_prov_adv_trans_clean_up>:
/*
 * FUNCTIONS
 ****************************************************************************************
 */
void m_prov_adv_trans_clean_up(void)
{
   108a8:	b570      	push	{r4, r5, r6, lr}
    m_prov_adv_res_t* p_adv_res = p_m_prov_env->p_adv_res;
   108aa:	4d14      	ldr	r5, [pc, #80]	; (108fc <m_prov_adv_trans_clean_up+0x54>)
   108ac:	682b      	ldr	r3, [r5, #0]
   108ae:	689c      	ldr	r4, [r3, #8]

    if(p_adv_res != NULL)
   108b0:	2c00      	cmp	r4, #0
   108b2:	d022      	beq.n	108fa <m_prov_adv_trans_clean_up+0x52>
    {
        SETB(p_adv_res->link_info, M_PROV_ADV_CLOSED, true);
   108b4:	2301      	movs	r3, #1
   108b6:	8d26      	ldrh	r6, [r4, #40]	; 0x28
   108b8:	4333      	orrs	r3, r6
   108ba:	8523      	strh	r3, [r4, #40]	; 0x28

        // postpone the clean-up
        if(!GETB(p_adv_res->link_info, M_PROV_IN_TX))
   108bc:	2302      	movs	r3, #2
   108be:	401e      	ands	r6, r3
   108c0:	d11b      	bne.n	108fa <m_prov_adv_trans_clean_up+0x52>
        {
            // release reception buffer
            if(p_adv_res->p_rx_buf != NULL)
   108c2:	6a60      	ldr	r0, [r4, #36]	; 0x24
   108c4:	2800      	cmp	r0, #0
   108c6:	d002      	beq.n	108ce <m_prov_adv_trans_clean_up+0x26>
            {
                m_tb_buf_release(p_adv_res->p_rx_buf);
   108c8:	f000 fee8 	bl	1169c <m_tb_buf_release>
                p_adv_res->p_rx_buf        = NULL;
   108cc:	6266      	str	r6, [r4, #36]	; 0x24
            }

            // release transmit buffer
            while(!co_list_is_empty(&(p_adv_res->tx_queue)))
   108ce:	6966      	ldr	r6, [r4, #20]
            {
                m_tb_buf_t *p_tx_buf = (m_tb_buf_t *) co_list_pop_front(&(p_adv_res->tx_queue));
   108d0:	0020      	movs	r0, r4
                m_tb_buf_release(p_adv_res->p_rx_buf);
                p_adv_res->p_rx_buf        = NULL;
            }

            // release transmit buffer
            while(!co_list_is_empty(&(p_adv_res->tx_queue)))
   108d2:	2e00      	cmp	r6, #0
   108d4:	d00a      	beq.n	108ec <m_prov_adv_trans_clean_up+0x44>
            {
                m_tb_buf_t *p_tx_buf = (m_tb_buf_t *) co_list_pop_front(&(p_adv_res->tx_queue));
   108d6:	3014      	adds	r0, #20
   108d8:	f7f3 fd88 	bl	43ec <co_list_pop_front>
   108dc:	0006      	movs	r6, r0
                m_prov_pdu_sent(p_tx_buf, M_ERR_BEARER_CLOSED);
   108de:	4908      	ldr	r1, [pc, #32]	; (10900 <m_prov_adv_trans_clean_up+0x58>)
   108e0:	f7ff fd5c 	bl	1039c <m_prov_pdu_sent>
                m_tb_buf_release(p_tx_buf);
   108e4:	0030      	movs	r0, r6
   108e6:	f000 fed9 	bl	1169c <m_tb_buf_release>
   108ea:	e7f0      	b.n	108ce <m_prov_adv_trans_clean_up+0x26>
            }

            // Clear transmission timer
            m_tb_timer_clear(&(p_adv_res->timer_tx));
   108ec:	f004 fd54 	bl	15398 <m_tb_timer_clear>

            // Clean-up environment
            m_al_free(p_adv_res);
   108f0:	0020      	movs	r0, r4
   108f2:	f7f4 fe73 	bl	55dc <m_al_free>
            p_m_prov_env->p_adv_res = NULL;
   108f6:	682b      	ldr	r3, [r5, #0]
   108f8:	609e      	str	r6, [r3, #8]
        }
    }
}
   108fa:	bd70      	pop	{r4, r5, r6, pc}
   108fc:	100128a4 	.word	0x100128a4
   10900:	00000882 	.word	0x00000882

00010904 <m_prov_adv_trans_send>:

uint16_t m_prov_adv_trans_send(m_tb_buf_t *p_buf)
{
   10904:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    do
    {
        m_prov_buf_env_t* p_buf_env = (m_prov_buf_env_t*) p_buf->env;

        // Check Packet length
        if(p_buf->data_len > M_PROV_GEN_PLD_MAX_SIZE) break;
   10906:	8903      	ldrh	r3, [r0, #8]
        }
    }
}

uint16_t m_prov_adv_trans_send(m_tb_buf_t *p_buf)
{
   10908:	0004      	movs	r4, r0
    do
    {
        m_prov_buf_env_t* p_buf_env = (m_prov_buf_env_t*) p_buf->env;

        // Check Packet length
        if(p_buf->data_len > M_PROV_GEN_PLD_MAX_SIZE) break;
   1090a:	2b40      	cmp	r3, #64	; 0x40
   1090c:	d83f      	bhi.n	1098e <m_prov_adv_trans_send+0x8a>
    }
}

uint16_t m_prov_adv_trans_send(m_tb_buf_t *p_buf)
{
    m_prov_adv_res_t* p_adv_res = p_m_prov_env->p_adv_res;
   1090e:	4b22      	ldr	r3, [pc, #136]	; (10998 <m_prov_adv_trans_send+0x94>)
   10910:	681b      	ldr	r3, [r3, #0]
   10912:	689d      	ldr	r5, [r3, #8]

        // Check Packet length
        if(p_buf->data_len > M_PROV_GEN_PLD_MAX_SIZE) break;

        // check environment
        if((p_adv_res == NULL) || GETB(p_adv_res->link_info, M_PROV_ADV_CLOSED))
   10914:	2d00      	cmp	r5, #0
   10916:	d03d      	beq.n	10994 <m_prov_adv_trans_send+0x90>
   10918:	8d2b      	ldrh	r3, [r5, #40]	; 0x28
   1091a:	07db      	lsls	r3, r3, #31
   1091c:	d43a      	bmi.n	10994 <m_prov_adv_trans_send+0x90>
            status = M_ERR_COMMAND_DISALLOWED;
            break;
        }

        // Acquire buffer to transmit
        m_tb_buf_acquire(p_buf);
   1091e:	f000 feb9 	bl	11694 <m_tb_buf_acquire>

        // Initialize buffer environment
        p_buf_env->fcs        = m_prov_adv_trans_fcs_compute(p_buf_env->pdu_type, p_buf->data_len, M_TB_BUF_DATA(p_buf));
   10922:	0023      	movs	r3, r4
 * @return Computed Frame Check Sequence value
 ****************************************************************************************
 */
__STATIC uint8_t m_prov_adv_trans_fcs_compute(uint8_t opcode, uint16_t data_len, uint8_t* data)
{
    uint8_t fcs = m_prov_adv_crctable[0xFF ^ opcode];
   10924:	7c22      	ldrb	r2, [r4, #16]

        // Acquire buffer to transmit
        m_tb_buf_acquire(p_buf);

        // Initialize buffer environment
        p_buf_env->fcs        = m_prov_adv_trans_fcs_compute(p_buf_env->pdu_type, p_buf->data_len, M_TB_BUF_DATA(p_buf));
   10926:	8920      	ldrh	r0, [r4, #8]
 * @return Computed Frame Check Sequence value
 ****************************************************************************************
 */
__STATIC uint8_t m_prov_adv_trans_fcs_compute(uint8_t opcode, uint16_t data_len, uint8_t* data)
{
    uint8_t fcs = m_prov_adv_crctable[0xFF ^ opcode];
   10928:	43d2      	mvns	r2, r2

        // Acquire buffer to transmit
        m_tb_buf_acquire(p_buf);

        // Initialize buffer environment
        p_buf_env->fcs        = m_prov_adv_trans_fcs_compute(p_buf_env->pdu_type, p_buf->data_len, M_TB_BUF_DATA(p_buf));
   1092a:	0001      	movs	r1, r0
   1092c:	88a6      	ldrh	r6, [r4, #4]
   1092e:	3330      	adds	r3, #48	; 0x30
   10930:	199e      	adds	r6, r3, r6
 * @return Computed Frame Check Sequence value
 ****************************************************************************************
 */
__STATIC uint8_t m_prov_adv_trans_fcs_compute(uint8_t opcode, uint16_t data_len, uint8_t* data)
{
    uint8_t fcs = m_prov_adv_crctable[0xFF ^ opcode];
   10932:	4b1a      	ldr	r3, [pc, #104]	; (1099c <m_prov_adv_trans_send+0x98>)
   10934:	b2d2      	uxtb	r2, r2
   10936:	3309      	adds	r3, #9
   10938:	5c9a      	ldrb	r2, [r3, r2]

    // use CRC table to perform (X^8 + X^2 + X^1 + 1)
    while(data_len--)
   1093a:	4f19      	ldr	r7, [pc, #100]	; (109a0 <m_prov_adv_trans_send+0x9c>)
    {
        fcs = m_prov_adv_crctable[fcs ^ *data];
   1093c:	9301      	str	r3, [sp, #4]
__STATIC uint8_t m_prov_adv_trans_fcs_compute(uint8_t opcode, uint16_t data_len, uint8_t* data)
{
    uint8_t fcs = m_prov_adv_crctable[0xFF ^ opcode];

    // use CRC table to perform (X^8 + X^2 + X^1 + 1)
    while(data_len--)
   1093e:	3901      	subs	r1, #1
   10940:	b289      	uxth	r1, r1
   10942:	42b9      	cmp	r1, r7
   10944:	d005      	beq.n	10952 <m_prov_adv_trans_send+0x4e>
    {
        fcs = m_prov_adv_crctable[fcs ^ *data];
   10946:	7833      	ldrb	r3, [r6, #0]
        data++;
   10948:	3601      	adds	r6, #1
    uint8_t fcs = m_prov_adv_crctable[0xFF ^ opcode];

    // use CRC table to perform (X^8 + X^2 + X^1 + 1)
    while(data_len--)
    {
        fcs = m_prov_adv_crctable[fcs ^ *data];
   1094a:	405a      	eors	r2, r3
   1094c:	9b01      	ldr	r3, [sp, #4]
   1094e:	5c9a      	ldrb	r2, [r3, r2]
   10950:	e7f5      	b.n	1093e <m_prov_adv_trans_send+0x3a>

        // Acquire buffer to transmit
        m_tb_buf_acquire(p_buf);

        // Initialize buffer environment
        p_buf_env->fcs        = m_prov_adv_trans_fcs_compute(p_buf_env->pdu_type, p_buf->data_len, M_TB_BUF_DATA(p_buf));
   10952:	43d2      	mvns	r2, r2
        p_buf_env->seg_cursor = 0;
   10954:	2300      	movs	r3, #0

        // Acquire buffer to transmit
        m_tb_buf_acquire(p_buf);

        // Initialize buffer environment
        p_buf_env->fcs        = m_prov_adv_trans_fcs_compute(p_buf_env->pdu_type, p_buf->data_len, M_TB_BUF_DATA(p_buf));
   10956:	7462      	strb	r2, [r4, #17]
        p_buf_env->seg_cursor = 0;
   10958:	7523      	strb	r3, [r4, #20]

        // Compute number of segment to transmit
        p_buf_env->seg_nb         = 1;
        if(p_buf->data_len > M_PROV_TRANS_START_PLD_MAX_LEN)
   1095a:	2813      	cmp	r0, #19
   1095c:	d802      	bhi.n	10964 <m_prov_adv_trans_send+0x60>
        // Initialize buffer environment
        p_buf_env->fcs        = m_prov_adv_trans_fcs_compute(p_buf_env->pdu_type, p_buf->data_len, M_TB_BUF_DATA(p_buf));
        p_buf_env->seg_cursor = 0;

        // Compute number of segment to transmit
        p_buf_env->seg_nb         = 1;
   1095e:	3301      	adds	r3, #1
   10960:	74e3      	strb	r3, [r4, #19]
   10962:	e005      	b.n	10970 <m_prov_adv_trans_send+0x6c>
        if(p_buf->data_len > M_PROV_TRANS_START_PLD_MAX_LEN)
        {
            p_buf_env->seg_nb += (  (  (p_buf->data_len - M_PROV_TRANS_START_PLD_MAX_LEN)
   10964:	3003      	adds	r0, #3
   10966:	2117      	movs	r1, #23
   10968:	f7f3 fc99 	bl	429e <__aeabi_idiv>
   1096c:	3001      	adds	r0, #1
   1096e:	74e0      	strb	r0, [r4, #19]
                                     + (M_PROV_TRANS_CONT_PLD_MAX_LEN - 1))
                                  / M_PROV_TRANS_CONT_PLD_MAX_LEN);
        }

        // Update transmission information
        co_list_push_back(&(p_adv_res->tx_queue), &(p_buf->hdr));
   10970:	0028      	movs	r0, r5
   10972:	0021      	movs	r1, r4
   10974:	3014      	adds	r0, #20

        // Set the transmission cursor value
        p_buf_env->trans_nb         = p_adv_res->tx_trans_cursor;
   10976:	352a      	adds	r5, #42	; 0x2a
                                     + (M_PROV_TRANS_CONT_PLD_MAX_LEN - 1))
                                  / M_PROV_TRANS_CONT_PLD_MAX_LEN);
        }

        // Update transmission information
        co_list_push_back(&(p_adv_res->tx_queue), &(p_buf->hdr));
   10978:	f7f3 fd0d 	bl	4396 <co_list_push_back>

        // Set the transmission cursor value
        p_buf_env->trans_nb         = p_adv_res->tx_trans_cursor;
   1097c:	782b      	ldrb	r3, [r5, #0]
   1097e:	7563      	strb	r3, [r4, #21]
        p_adv_res->tx_trans_cursor += 1;
   10980:	782b      	ldrb	r3, [r5, #0]
   10982:	3301      	adds	r3, #1
   10984:	702b      	strb	r3, [r5, #0]

        status = M_ERR_NO_ERROR;

        // Request transmission to be performed
        m_prov_adv_trans_tx_set();
   10986:	f7ff fd2b 	bl	103e0 <m_prov_adv_trans_tx_set>

        // Set the transmission cursor value
        p_buf_env->trans_nb         = p_adv_res->tx_trans_cursor;
        p_adv_res->tx_trans_cursor += 1;

        status = M_ERR_NO_ERROR;
   1098a:	2000      	movs	r0, #0
   1098c:	e003      	b.n	10996 <m_prov_adv_trans_send+0x92>
}

uint16_t m_prov_adv_trans_send(m_tb_buf_t *p_buf)
{
    m_prov_adv_res_t* p_adv_res = p_m_prov_env->p_adv_res;
    uint16_t status = M_ERR_INVALID_PARAM;
   1098e:	20c1      	movs	r0, #193	; 0xc1
   10990:	0040      	lsls	r0, r0, #1
   10992:	e000      	b.n	10996 <m_prov_adv_trans_send+0x92>
        if(p_buf->data_len > M_PROV_GEN_PLD_MAX_SIZE) break;

        // check environment
        if((p_adv_res == NULL) || GETB(p_adv_res->link_info, M_PROV_ADV_CLOSED))
        {
            status = M_ERR_COMMAND_DISALLOWED;
   10994:	4803      	ldr	r0, [pc, #12]	; (109a4 <m_prov_adv_trans_send+0xa0>)
        // Request transmission to be performed
        m_prov_adv_trans_tx_set();
    }while(0);

    return (status);
}
   10996:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
   10998:	100128a4 	.word	0x100128a4
   1099c:	000222c3 	.word	0x000222c3
   109a0:	0000ffff 	.word	0x0000ffff
   109a4:	00000282 	.word	0x00000282

000109a8 <m_prov_adv_trans_link_close_send>:

uint16_t m_prov_adv_trans_link_close_send(uint8_t reason)
{
    uint16_t status = M_ERR_COMMAND_DISALLOWED;
    m_prov_adv_res_t* p_adv_res = p_m_prov_env->p_adv_res;
   109a8:	4b0a      	ldr	r3, [pc, #40]	; (109d4 <m_prov_adv_trans_link_close_send+0x2c>)

    return (status);
}

uint16_t m_prov_adv_trans_link_close_send(uint8_t reason)
{
   109aa:	b510      	push	{r4, lr}
    uint16_t status = M_ERR_COMMAND_DISALLOWED;
    m_prov_adv_res_t* p_adv_res = p_m_prov_env->p_adv_res;
   109ac:	681b      	ldr	r3, [r3, #0]
   109ae:	689b      	ldr	r3, [r3, #8]

    // ensure that link is established
    if((p_adv_res != NULL) && !GETB(p_adv_res->link_info, M_PROV_ADV_CLOSED))
   109b0:	2b00      	cmp	r3, #0
   109b2:	d00c      	beq.n	109ce <m_prov_adv_trans_link_close_send+0x26>
   109b4:	2401      	movs	r4, #1
   109b6:	8d1a      	ldrh	r2, [r3, #40]	; 0x28
   109b8:	4014      	ands	r4, r2
   109ba:	d108      	bne.n	109ce <m_prov_adv_trans_link_close_send+0x26>
    {
        // Mark that close packet must be tranmitted
        SETB(p_adv_res->link_info, M_PROV_SEND_LINK_CLOSE, true);
   109bc:	2120      	movs	r1, #32
   109be:	430a      	orrs	r2, r1
   109c0:	851a      	strh	r2, [r3, #40]	; 0x28
        p_adv_res->close_reason = reason;
   109c2:	332c      	adds	r3, #44	; 0x2c
   109c4:	7018      	strb	r0, [r3, #0]

        // Mark that something must be sent
        m_prov_adv_trans_tx_set();
   109c6:	f7ff fd0b 	bl	103e0 <m_prov_adv_trans_tx_set>

        status = M_ERR_NO_ERROR;
   109ca:	0020      	movs	r0, r4
   109cc:	e000      	b.n	109d0 <m_prov_adv_trans_link_close_send+0x28>
    return (status);
}

uint16_t m_prov_adv_trans_link_close_send(uint8_t reason)
{
    uint16_t status = M_ERR_COMMAND_DISALLOWED;
   109ce:	4802      	ldr	r0, [pc, #8]	; (109d8 <m_prov_adv_trans_link_close_send+0x30>)

        status = M_ERR_NO_ERROR;
    }

    return (status);
}
   109d0:	bd10      	pop	{r4, pc}
   109d2:	46c0      	nop			; (mov r8, r8)
   109d4:	100128a4 	.word	0x100128a4
   109d8:	00000282 	.word	0x00000282

000109dc <m_prov_adv_trans_rx>:

void m_prov_adv_trans_rx(m_tb_buf_t *p_buf)
{
   109dc:	b5f0      	push	{r4, r5, r6, r7, lr}
	M_PRINTF(L_PROV, "");
   109de:	4bd4      	ldr	r3, [pc, #848]	; (10d30 <m_prov_adv_trans_rx+0x354>)

    return (status);
}

void m_prov_adv_trans_rx(m_tb_buf_t *p_buf)
{
   109e0:	b08d      	sub	sp, #52	; 0x34
	M_PRINTF(L_PROV, "");
   109e2:	681b      	ldr	r3, [r3, #0]

    return (status);
}

void m_prov_adv_trans_rx(m_tb_buf_t *p_buf)
{
   109e4:	9002      	str	r0, [sp, #8]
	M_PRINTF(L_PROV, "");
   109e6:	071b      	lsls	r3, r3, #28
   109e8:	d516      	bpl.n	10a18 <m_prov_adv_trans_rx+0x3c>
   109ea:	4bd2      	ldr	r3, [pc, #840]	; (10d34 <m_prov_adv_trans_rx+0x358>)
   109ec:	4cd2      	ldr	r4, [pc, #840]	; (10d38 <m_prov_adv_trans_rx+0x35c>)
   109ee:	3315      	adds	r3, #21
   109f0:	9300      	str	r3, [sp, #0]
   109f2:	0022      	movs	r2, r4
   109f4:	0020      	movs	r0, r4
   109f6:	2396      	movs	r3, #150	; 0x96
   109f8:	4dd0      	ldr	r5, [pc, #832]	; (10d3c <m_prov_adv_trans_rx+0x360>)
   109fa:	3222      	adds	r2, #34	; 0x22
   109fc:	0029      	movs	r1, r5
   109fe:	009b      	lsls	r3, r3, #2
   10a00:	3035      	adds	r0, #53	; 0x35
   10a02:	f7f3 ffd3 	bl	49ac <m_print>
   10a06:	0020      	movs	r0, r4
   10a08:	305c      	adds	r0, #92	; 0x5c
   10a0a:	f7f3 ffcf 	bl	49ac <m_print>
   10a0e:	0020      	movs	r0, r4
   10a10:	1da9      	adds	r1, r5, #6
   10a12:	305d      	adds	r0, #93	; 0x5d
   10a14:	f7f3 ffca 	bl	49ac <m_print>
        uint8_t        trans_nb;
        uint8_t        gpc_head;
        uint8_t*       p_data   = M_TB_BUF_DATA(p_buf);

        // Ignore packet too small
        if(p_buf->data_len < M_PROV_PB_ADV_PKT_MIN_LEN) { break; }
   10a18:	9b02      	ldr	r3, [sp, #8]
   10a1a:	891b      	ldrh	r3, [r3, #8]
   10a1c:	2b05      	cmp	r3, #5
   10a1e:	d800      	bhi.n	10a22 <m_prov_adv_trans_rx+0x46>
   10a20:	e2b4      	b.n	10f8c <m_prov_adv_trans_rx+0x5b0>
}

void m_prov_adv_trans_rx(m_tb_buf_t *p_buf)
{
	M_PRINTF(L_PROV, "");
    m_prov_adv_res_t* p_adv_res = p_m_prov_env->p_adv_res;
   10a22:	4cc7      	ldr	r4, [pc, #796]	; (10d40 <m_prov_adv_trans_rx+0x364>)
   10a24:	6823      	ldr	r3, [r4, #0]
   10a26:	0026      	movs	r6, r4
   10a28:	689f      	ldr	r7, [r3, #8]
    m_prov_res_t* p_res = p_m_prov_env->p_res;
   10a2a:	685b      	ldr	r3, [r3, #4]
   10a2c:	9307      	str	r3, [sp, #28]
    do
    {
        uint32_t       link_id;
        uint8_t        trans_nb;
        uint8_t        gpc_head;
        uint8_t*       p_data   = M_TB_BUF_DATA(p_buf);
   10a2e:	9b02      	ldr	r3, [sp, #8]
   10a30:	3330      	adds	r3, #48	; 0x30
   10a32:	9306      	str	r3, [sp, #24]
   10a34:	9b02      	ldr	r3, [sp, #8]
   10a36:	9a06      	ldr	r2, [sp, #24]
   10a38:	889b      	ldrh	r3, [r3, #4]
   10a3a:	18d3      	adds	r3, r2, r3
   10a3c:	78d8      	ldrb	r0, [r3, #3]
   10a3e:	789a      	ldrb	r2, [r3, #2]
   10a40:	9303      	str	r3, [sp, #12]
   10a42:	9903      	ldr	r1, [sp, #12]
   10a44:	0200      	lsls	r0, r0, #8
   10a46:	4310      	orrs	r0, r2
   10a48:	785b      	ldrb	r3, [r3, #1]
   10a4a:	0402      	lsls	r2, r0, #16
   10a4c:	7808      	ldrb	r0, [r1, #0]
   10a4e:	021b      	lsls	r3, r3, #8
   10a50:	4318      	orrs	r0, r3
   10a52:	4310      	orrs	r0, r2
   10a54:	f7ff fcc2 	bl	103dc <co_bswap32>
        if(p_buf->data_len < M_PROV_PB_ADV_PKT_MIN_LEN) { break; }

        // Read Link identifier (MSB in packet)
        link_id = co_ntohl(co_read32p(p_data));
        p_data += 4;
        trans_nb = *p_data;
   10a58:	9b03      	ldr	r3, [sp, #12]
   10a5a:	9009      	str	r0, [sp, #36]	; 0x24
   10a5c:	791b      	ldrb	r3, [r3, #4]
        p_data += 1;
        gpc_head = *p_data;
        p_data += 1;

        // update data in buffer.
        m_tb_buf_head_release(p_buf, M_PROV_PB_ADV_PKT_MIN_LEN);
   10a5e:	2106      	movs	r1, #6
        if(p_buf->data_len < M_PROV_PB_ADV_PKT_MIN_LEN) { break; }

        // Read Link identifier (MSB in packet)
        link_id = co_ntohl(co_read32p(p_data));
        p_data += 4;
        trans_nb = *p_data;
   10a60:	9305      	str	r3, [sp, #20]
        p_data += 1;
        gpc_head = *p_data;
   10a62:	9b03      	ldr	r3, [sp, #12]
        p_data += 1;

        // update data in buffer.
        m_tb_buf_head_release(p_buf, M_PROV_PB_ADV_PKT_MIN_LEN);
   10a64:	9802      	ldr	r0, [sp, #8]
        // Read Link identifier (MSB in packet)
        link_id = co_ntohl(co_read32p(p_data));
        p_data += 4;
        trans_nb = *p_data;
        p_data += 1;
        gpc_head = *p_data;
   10a66:	795b      	ldrb	r3, [r3, #5]
   10a68:	9304      	str	r3, [sp, #16]
        p_data += 1;
   10a6a:	9b03      	ldr	r3, [sp, #12]
   10a6c:	3306      	adds	r3, #6
   10a6e:	9308      	str	r3, [sp, #32]

        // update data in buffer.
        m_tb_buf_head_release(p_buf, M_PROV_PB_ADV_PKT_MIN_LEN);
   10a70:	f000 fde6 	bl	11640 <m_tb_buf_head_release>

        if(p_adv_res == NULL)
   10a74:	2f00      	cmp	r7, #0
   10a76:	d15f      	bne.n	10b38 <m_prov_adv_trans_rx+0x15c>
        {
            // If no link environment found, accept packet only for a Link Open control packet
            if(   (GETF(gpc_head, M_PROV_GPCF)   == M_PROV_GPCF_BEARER_CTL)
   10a78:	9b04      	ldr	r3, [sp, #16]
   10a7a:	43db      	mvns	r3, r3
   10a7c:	079b      	lsls	r3, r3, #30
   10a7e:	d000      	beq.n	10a82 <m_prov_adv_trans_rx+0xa6>
   10a80:	e284      	b.n	10f8c <m_prov_adv_trans_rx+0x5b0>
               && (GETF(gpc_head, M_PROV_OPCODE) == M_PROV_LINK_OPEN)
   10a82:	9b04      	ldr	r3, [sp, #16]
   10a84:	089d      	lsrs	r5, r3, #2
   10a86:	d000      	beq.n	10a8a <m_prov_adv_trans_rx+0xae>
   10a88:	e280      	b.n	10f8c <m_prov_adv_trans_rx+0x5b0>
               && (p_buf->data_len == M_DEV_UUID_LEN)
   10a8a:	9b02      	ldr	r3, [sp, #8]
   10a8c:	891a      	ldrh	r2, [r3, #8]
   10a8e:	2a10      	cmp	r2, #16
   10a90:	d000      	beq.n	10a94 <m_prov_adv_trans_rx+0xb8>
   10a92:	e27b      	b.n	10f8c <m_prov_adv_trans_rx+0x5b0>
               && (memcmp(p_data, p_res->prov_param.dev_uuid, M_DEV_UUID_LEN) == 0))
   10a94:	9907      	ldr	r1, [sp, #28]
   10a96:	9808      	ldr	r0, [sp, #32]
   10a98:	3134      	adds	r1, #52	; 0x34
   10a9a:	f004 ff71 	bl	15980 <memcmp>
   10a9e:	2800      	cmp	r0, #0
   10aa0:	d000      	beq.n	10aa4 <m_prov_adv_trans_rx+0xc8>
   10aa2:	e273      	b.n	10f8c <m_prov_adv_trans_rx+0x5b0>
            {
            	M_PRINTF(L_PROV, "m_prov_link_open");
   10aa4:	4ba2      	ldr	r3, [pc, #648]	; (10d30 <m_prov_adv_trans_rx+0x354>)
   10aa6:	681b      	ldr	r3, [r3, #0]
   10aa8:	071b      	lsls	r3, r3, #28
   10aaa:	d516      	bpl.n	10ada <m_prov_adv_trans_rx+0xfe>
   10aac:	4fa1      	ldr	r7, [pc, #644]	; (10d34 <m_prov_adv_trans_rx+0x358>)
   10aae:	4ca2      	ldr	r4, [pc, #648]	; (10d38 <m_prov_adv_trans_rx+0x35c>)
   10ab0:	003b      	movs	r3, r7
   10ab2:	0022      	movs	r2, r4
   10ab4:	0020      	movs	r0, r4
   10ab6:	4da1      	ldr	r5, [pc, #644]	; (10d3c <m_prov_adv_trans_rx+0x360>)
   10ab8:	3315      	adds	r3, #21
   10aba:	0029      	movs	r1, r5
   10abc:	3222      	adds	r2, #34	; 0x22
   10abe:	9300      	str	r3, [sp, #0]
   10ac0:	3035      	adds	r0, #53	; 0x35
   10ac2:	4ba0      	ldr	r3, [pc, #640]	; (10d44 <m_prov_adv_trans_rx+0x368>)
   10ac4:	f7f3 ff72 	bl	49ac <m_print>
   10ac8:	0038      	movs	r0, r7
   10aca:	3029      	adds	r0, #41	; 0x29
   10acc:	f7f3 ff6e 	bl	49ac <m_print>
   10ad0:	0020      	movs	r0, r4
   10ad2:	1da9      	adds	r1, r5, #6
   10ad4:	305d      	adds	r0, #93	; 0x5d
   10ad6:	f7f3 ff69 	bl	49ac <m_print>
                // Try to open provisioning link
                if(m_prov_link_open(M_PROV_BEARER_ADV, p_m_prov_env->adv_bearer_lid) == M_ERR_NO_ERROR)
   10ada:	6833      	ldr	r3, [r6, #0]
   10adc:	2001      	movs	r0, #1
   10ade:	7c99      	ldrb	r1, [r3, #18]
   10ae0:	f7ff fb22 	bl	10128 <m_prov_link_open>
   10ae4:	1e05      	subs	r5, r0, #0
   10ae6:	d000      	beq.n	10aea <m_prov_adv_trans_rx+0x10e>
   10ae8:	e250      	b.n	10f8c <m_prov_adv_trans_rx+0x5b0>
{
    uint8_t *p_mem;
    m_tb_buf_t *p_adv_tx_buf = NULL;
    m_prov_adv_res_t *p_adv_res = NULL;

    p_mem = (uint8_t *)m_al_malloc(sizeof(m_prov_adv_res_t) + sizeof(m_tb_buf_t) + M_TB_BUF_SMALL_SIZE);
   10aea:	2080      	movs	r0, #128	; 0x80
   10aec:	f7f4 fd71 	bl	55d2 <m_al_malloc>
   10af0:	1e04      	subs	r4, r0, #0

    ASSERT_ERR(p_mem != NULL);
   10af2:	d100      	bne.n	10af6 <m_prov_adv_trans_rx+0x11a>
   10af4:	e7fe      	b.n	10af4 <m_prov_adv_trans_rx+0x118>
    p_adv_res = (m_prov_adv_res_t *)p_mem;
    p_mem += sizeof(m_prov_adv_res_t);
    p_adv_tx_buf = (m_tb_buf_t *)p_mem;

    // Initialize buffers
    p_adv_tx_buf->block_id = M_PROV_TX_BUF_BLOCK_ID;
   10af6:	0003      	movs	r3, r0
   10af8:	22fe      	movs	r2, #254	; 0xfe
   10afa:	3330      	adds	r3, #48	; 0x30
   10afc:	731a      	strb	r2, [r3, #12]
    p_adv_tx_buf->pattern = M_TB_BUF_DBG_PATTERN;
    #endif //(BLE_MESH_DBG)
    p_adv_tx_buf->acq_cnt = 1;

    // Initialize link parameters
    p_m_prov_env->bearer_type = M_PROV_BEARER_ADV;
   10afe:	6831      	ldr	r1, [r6, #0]
    p_adv_tx_buf = (m_tb_buf_t *)p_mem;

    // Initialize buffers
    p_adv_tx_buf->block_id = M_PROV_TX_BUF_BLOCK_ID;
    p_adv_tx_buf->buf_id = 0;
    p_adv_tx_buf->buf_len = M_TB_BUF_SMALL_SIZE;
   10b00:	3ade      	subs	r2, #222	; 0xde
    p_mem += sizeof(m_prov_adv_res_t);
    p_adv_tx_buf = (m_tb_buf_t *)p_mem;

    // Initialize buffers
    p_adv_tx_buf->block_id = M_PROV_TX_BUF_BLOCK_ID;
    p_adv_tx_buf->buf_id = 0;
   10b02:	735d      	strb	r5, [r3, #13]
    p_adv_tx_buf->buf_len = M_TB_BUF_SMALL_SIZE;
   10b04:	8742      	strh	r2, [r0, #58]	; 0x3a
    #if (BLE_MESH_DBG)
    p_adv_tx_buf->pattern = M_TB_BUF_DBG_PATTERN;
    #endif //(BLE_MESH_DBG)
    p_adv_tx_buf->acq_cnt = 1;
   10b06:	3a1f      	subs	r2, #31
   10b08:	739a      	strb	r2, [r3, #14]

    // Initialize link parameters
    p_m_prov_env->bearer_type = M_PROV_BEARER_ADV;
   10b0a:	740a      	strb	r2, [r1, #16]

    p_adv_res->link_id        = link_id;
   10b0c:	9a09      	ldr	r2, [sp, #36]	; 0x24
    p_adv_res->link_info = M_PROV_SEND_ACK_BIT;
    p_adv_res->tx_trans_cursor = 0x80;
   10b0e:	2180      	movs	r1, #128	; 0x80
    p_adv_tx_buf->acq_cnt = 1;

    // Initialize link parameters
    p_m_prov_env->bearer_type = M_PROV_BEARER_ADV;

    p_adv_res->link_id        = link_id;
   10b10:	6202      	str	r2, [r0, #32]
    p_adv_res->link_info = M_PROV_SEND_ACK_BIT;
   10b12:	2210      	movs	r2, #16
   10b14:	8502      	strh	r2, [r0, #40]	; 0x28
    p_adv_res->tx_trans_cursor = 0x80;
   10b16:	0002      	movs	r2, r0
   10b18:	322a      	adds	r2, #42	; 0x2a
   10b1a:	7011      	strb	r1, [r2, #0]
    p_adv_res->rx_trans_cursor = 0x00;
   10b1c:	7055      	strb	r5, [r2, #1]
    p_adv_res->p_rx_buf        = NULL;
    p_adv_res->p_tx_adv_buf    = p_adv_tx_buf;
    co_list_init(&(p_adv_res->tx_queue));
   10b1e:	3014      	adds	r0, #20
    p_adv_res->link_id        = link_id;
    p_adv_res->link_info = M_PROV_SEND_ACK_BIT;
    p_adv_res->tx_trans_cursor = 0x80;
    p_adv_res->rx_trans_cursor = 0x00;
    p_adv_res->p_rx_buf        = NULL;
    p_adv_res->p_tx_adv_buf    = p_adv_tx_buf;
   10b20:	6083      	str	r3, [r0, #8]

    p_adv_res->link_id        = link_id;
    p_adv_res->link_info = M_PROV_SEND_ACK_BIT;
    p_adv_res->tx_trans_cursor = 0x80;
    p_adv_res->rx_trans_cursor = 0x00;
    p_adv_res->p_rx_buf        = NULL;
   10b22:	6105      	str	r5, [r0, #16]
    p_adv_res->p_tx_adv_buf    = p_adv_tx_buf;
    co_list_init(&(p_adv_res->tx_queue));
   10b24:	f7f3 fbfc 	bl	4320 <co_list_init>

    // Configure TX timer
    p_adv_res->timer_tx.cb     = m_prov_adv_trans_tx_cb;
   10b28:	4b87      	ldr	r3, [pc, #540]	; (10d48 <m_prov_adv_trans_rx+0x36c>)
    p_adv_res->timer_tx.p_env  = NULL;
   10b2a:	60a5      	str	r5, [r4, #8]
    p_adv_res->p_rx_buf        = NULL;
    p_adv_res->p_tx_adv_buf    = p_adv_tx_buf;
    co_list_init(&(p_adv_res->tx_queue));

    // Configure TX timer
    p_adv_res->timer_tx.cb     = m_prov_adv_trans_tx_cb;
   10b2c:	6063      	str	r3, [r4, #4]
    p_adv_res->timer_tx.p_env  = NULL;

    p_m_prov_env->p_adv_res    = p_adv_res;
   10b2e:	6833      	ldr	r3, [r6, #0]
   10b30:	609c      	str	r4, [r3, #8]

    // Mark that something must be sent
    m_prov_adv_trans_tx_set();
   10b32:	f7ff fc55 	bl	103e0 <m_prov_adv_trans_tx_set>
   10b36:	e229      	b.n	10f8c <m_prov_adv_trans_rx+0x5b0>
            }
            // else ignore packet
            else { break; }
        }
        // sanity check to verify if local device is targeted
        else if(   (p_m_prov_env->bearer_type != M_PROV_BEARER_ADV) || (p_adv_res->link_id != link_id)
   10b38:	6823      	ldr	r3, [r4, #0]
   10b3a:	7c1b      	ldrb	r3, [r3, #16]
   10b3c:	2b01      	cmp	r3, #1
   10b3e:	d000      	beq.n	10b42 <m_prov_adv_trans_rx+0x166>
   10b40:	e224      	b.n	10f8c <m_prov_adv_trans_rx+0x5b0>
   10b42:	6a3a      	ldr	r2, [r7, #32]
   10b44:	9909      	ldr	r1, [sp, #36]	; 0x24
   10b46:	428a      	cmp	r2, r1
   10b48:	d000      	beq.n	10b4c <m_prov_adv_trans_rx+0x170>
   10b4a:	e21f      	b.n	10f8c <m_prov_adv_trans_rx+0x5b0>
                || GETB(p_adv_res->link_info, M_PROV_ADV_CLOSED))
   10b4c:	8d3a      	ldrh	r2, [r7, #40]	; 0x28
   10b4e:	421a      	tst	r2, r3
   10b50:	d000      	beq.n	10b54 <m_prov_adv_trans_rx+0x178>
   10b52:	e21b      	b.n	10f8c <m_prov_adv_trans_rx+0x5b0>
        {
            break;
        }

        // Check the Generic Provisioning Control Format
        switch(GETF(gpc_head, M_PROV_GPCF))
   10b54:	9a04      	ldr	r2, [sp, #16]
   10b56:	3302      	adds	r3, #2
   10b58:	4013      	ands	r3, r2
   10b5a:	4975      	ldr	r1, [pc, #468]	; (10d30 <m_prov_adv_trans_rx+0x354>)
   10b5c:	2208      	movs	r2, #8
   10b5e:	2b02      	cmp	r3, #2
   10b60:	d100      	bne.n	10b64 <m_prov_adv_trans_rx+0x188>
   10b62:	e186      	b.n	10e72 <m_prov_adv_trans_rx+0x496>
   10b64:	2b03      	cmp	r3, #3
   10b66:	d003      	beq.n	10b70 <m_prov_adv_trans_rx+0x194>
   10b68:	2b01      	cmp	r3, #1
   10b6a:	d000      	beq.n	10b6e <m_prov_adv_trans_rx+0x192>
   10b6c:	e094      	b.n	10c98 <m_prov_adv_trans_rx+0x2bc>
   10b6e:	e1de      	b.n	10f2e <m_prov_adv_trans_rx+0x552>
        {
            case M_PROV_GPCF_BEARER_CTL:
            {
            	M_PRINTF(L_PROV, "M_PROV_GPCF_BEARER_CTL");
   10b70:	680b      	ldr	r3, [r1, #0]
   10b72:	4213      	tst	r3, r2
   10b74:	d017      	beq.n	10ba6 <m_prov_adv_trans_rx+0x1ca>
   10b76:	4d6f      	ldr	r5, [pc, #444]	; (10d34 <m_prov_adv_trans_rx+0x358>)
   10b78:	4c6f      	ldr	r4, [pc, #444]	; (10d38 <m_prov_adv_trans_rx+0x35c>)
   10b7a:	002b      	movs	r3, r5
   10b7c:	3315      	adds	r3, #21
   10b7e:	9300      	str	r3, [sp, #0]
   10b80:	0022      	movs	r2, r4
   10b82:	0020      	movs	r0, r4
   10b84:	23a5      	movs	r3, #165	; 0xa5
   10b86:	4e6d      	ldr	r6, [pc, #436]	; (10d3c <m_prov_adv_trans_rx+0x360>)
   10b88:	3222      	adds	r2, #34	; 0x22
   10b8a:	0031      	movs	r1, r6
   10b8c:	009b      	lsls	r3, r3, #2
   10b8e:	3035      	adds	r0, #53	; 0x35
   10b90:	f7f3 ff0c 	bl	49ac <m_print>
   10b94:	0028      	movs	r0, r5
   10b96:	303a      	adds	r0, #58	; 0x3a
   10b98:	f7f3 ff08 	bl	49ac <m_print>
   10b9c:	0020      	movs	r0, r4
   10b9e:	1db1      	adds	r1, r6, #6
   10ba0:	305d      	adds	r0, #93	; 0x5d
   10ba2:	f7f3 ff03 	bl	49ac <m_print>
                //  Provisioning Bearer operation code
                switch(GETF(gpc_head, M_PROV_OPCODE))
   10ba6:	9b04      	ldr	r3, [sp, #16]
   10ba8:	089d      	lsrs	r5, r3, #2
   10baa:	d002      	beq.n	10bb2 <m_prov_adv_trans_rx+0x1d6>
   10bac:	2d02      	cmp	r5, #2
   10bae:	d04e      	beq.n	10c4e <m_prov_adv_trans_rx+0x272>
   10bb0:	e1ec      	b.n	10f8c <m_prov_adv_trans_rx+0x5b0>
                {
                    case M_PROV_LINK_OPEN:
                    {
                    	M_PRINTF(L_PROV, "M_PROV_LINK_OPEN");
   10bb2:	4b5f      	ldr	r3, [pc, #380]	; (10d30 <m_prov_adv_trans_rx+0x354>)
   10bb4:	681b      	ldr	r3, [r3, #0]
   10bb6:	071b      	lsls	r3, r3, #28
   10bb8:	d516      	bpl.n	10be8 <m_prov_adv_trans_rx+0x20c>
   10bba:	4e5e      	ldr	r6, [pc, #376]	; (10d34 <m_prov_adv_trans_rx+0x358>)
   10bbc:	4c5e      	ldr	r4, [pc, #376]	; (10d38 <m_prov_adv_trans_rx+0x35c>)
   10bbe:	0033      	movs	r3, r6
   10bc0:	0022      	movs	r2, r4
   10bc2:	0020      	movs	r0, r4
   10bc4:	4d5d      	ldr	r5, [pc, #372]	; (10d3c <m_prov_adv_trans_rx+0x360>)
   10bc6:	3315      	adds	r3, #21
   10bc8:	0029      	movs	r1, r5
   10bca:	3222      	adds	r2, #34	; 0x22
   10bcc:	9300      	str	r3, [sp, #0]
   10bce:	3035      	adds	r0, #53	; 0x35
   10bd0:	4b5e      	ldr	r3, [pc, #376]	; (10d4c <m_prov_adv_trans_rx+0x370>)
   10bd2:	f7f3 feeb 	bl	49ac <m_print>
   10bd6:	0030      	movs	r0, r6
   10bd8:	3051      	adds	r0, #81	; 0x51
   10bda:	f7f3 fee7 	bl	49ac <m_print>
   10bde:	0020      	movs	r0, r4
   10be0:	1da9      	adds	r1, r5, #6
   10be2:	305d      	adds	r0, #93	; 0x5d
   10be4:	f7f3 fee2 	bl	49ac <m_print>
                        if(   (p_buf->data_len == M_DEV_UUID_LEN)
   10be8:	9b02      	ldr	r3, [sp, #8]
   10bea:	891c      	ldrh	r4, [r3, #8]
   10bec:	2c10      	cmp	r4, #16
   10bee:	d000      	beq.n	10bf2 <m_prov_adv_trans_rx+0x216>
   10bf0:	e1cc      	b.n	10f8c <m_prov_adv_trans_rx+0x5b0>
                           // local device targeted
                           && (memcmp(p_data, p_res->prov_param.dev_uuid, M_DEV_UUID_LEN) == 0)
   10bf2:	9907      	ldr	r1, [sp, #28]
   10bf4:	0022      	movs	r2, r4
   10bf6:	3134      	adds	r1, #52	; 0x34
   10bf8:	9808      	ldr	r0, [sp, #32]
   10bfa:	f004 fec1 	bl	15980 <memcmp>
   10bfe:	2800      	cmp	r0, #0
   10c00:	d000      	beq.n	10c04 <m_prov_adv_trans_rx+0x228>
   10c02:	e1c3      	b.n	10f8c <m_prov_adv_trans_rx+0x5b0>
                           // No transaction received
                           && (!GETB(p_adv_res->link_info, M_PROV_RX_OK))
                           // No TX ACK waiting to be transmitted
                           && (!GETB(p_adv_res->link_info, M_PROV_SEND_ACK)))
   10c04:	2218      	movs	r2, #24
                    	M_PRINTF(L_PROV, "M_PROV_LINK_OPEN");
                        if(   (p_buf->data_len == M_DEV_UUID_LEN)
                           // local device targeted
                           && (memcmp(p_data, p_res->prov_param.dev_uuid, M_DEV_UUID_LEN) == 0)
                           // No transaction received
                           && (!GETB(p_adv_res->link_info, M_PROV_RX_OK))
   10c06:	8d3b      	ldrh	r3, [r7, #40]	; 0x28
                           // No TX ACK waiting to be transmitted
                           && (!GETB(p_adv_res->link_info, M_PROV_SEND_ACK)))
   10c08:	4213      	tst	r3, r2
   10c0a:	d000      	beq.n	10c0e <m_prov_adv_trans_rx+0x232>
   10c0c:	e1be      	b.n	10f8c <m_prov_adv_trans_rx+0x5b0>
                        {
                            // Mark that Link ACK message must be sent
                            SETB(p_adv_res->link_info, M_PROV_SEND_ACK, true);
   10c0e:	431c      	orrs	r4, r3
							M_PRINTF(L_PROV, "link_info = %d", p_adv_res->link_info);
   10c10:	4b47      	ldr	r3, [pc, #284]	; (10d30 <m_prov_adv_trans_rx+0x354>)
                           && (!GETB(p_adv_res->link_info, M_PROV_RX_OK))
                           // No TX ACK waiting to be transmitted
                           && (!GETB(p_adv_res->link_info, M_PROV_SEND_ACK)))
                        {
                            // Mark that Link ACK message must be sent
                            SETB(p_adv_res->link_info, M_PROV_SEND_ACK, true);
   10c12:	853c      	strh	r4, [r7, #40]	; 0x28
							M_PRINTF(L_PROV, "link_info = %d", p_adv_res->link_info);
   10c14:	681b      	ldr	r3, [r3, #0]
   10c16:	071b      	lsls	r3, r3, #28
   10c18:	d400      	bmi.n	10c1c <m_prov_adv_trans_rx+0x240>
   10c1a:	e085      	b.n	10d28 <m_prov_adv_trans_rx+0x34c>
   10c1c:	4e45      	ldr	r6, [pc, #276]	; (10d34 <m_prov_adv_trans_rx+0x358>)
   10c1e:	4c46      	ldr	r4, [pc, #280]	; (10d38 <m_prov_adv_trans_rx+0x35c>)
   10c20:	0033      	movs	r3, r6
   10c22:	0022      	movs	r2, r4
   10c24:	0020      	movs	r0, r4
   10c26:	4d45      	ldr	r5, [pc, #276]	; (10d3c <m_prov_adv_trans_rx+0x360>)
   10c28:	3315      	adds	r3, #21
   10c2a:	3222      	adds	r2, #34	; 0x22
   10c2c:	9300      	str	r3, [sp, #0]
   10c2e:	0029      	movs	r1, r5
   10c30:	4b47      	ldr	r3, [pc, #284]	; (10d50 <m_prov_adv_trans_rx+0x374>)
   10c32:	3035      	adds	r0, #53	; 0x35
   10c34:	f7f3 feba 	bl	49ac <m_print>
   10c38:	0030      	movs	r0, r6
   10c3a:	8d39      	ldrh	r1, [r7, #40]	; 0x28
   10c3c:	3062      	adds	r0, #98	; 0x62
   10c3e:	f7f3 feb5 	bl	49ac <m_print>
   10c42:	0020      	movs	r0, r4
   10c44:	1da9      	adds	r1, r5, #6
   10c46:	305d      	adds	r0, #93	; 0x5d
   10c48:	f7f3 feb0 	bl	49ac <m_print>
   10c4c:	e06c      	b.n	10d28 <m_prov_adv_trans_rx+0x34c>
                        }
                        // else ignore message
                    } break;
                    case M_PROV_LINK_CLOSE:
                    {
                    	M_PRINTF(L_PROV, "M_PROV_LINK_CLOSE");
   10c4e:	4b38      	ldr	r3, [pc, #224]	; (10d30 <m_prov_adv_trans_rx+0x354>)
   10c50:	681b      	ldr	r3, [r3, #0]
   10c52:	071b      	lsls	r3, r3, #28
   10c54:	d516      	bpl.n	10c84 <m_prov_adv_trans_rx+0x2a8>
   10c56:	4e37      	ldr	r6, [pc, #220]	; (10d34 <m_prov_adv_trans_rx+0x358>)
   10c58:	4c37      	ldr	r4, [pc, #220]	; (10d38 <m_prov_adv_trans_rx+0x35c>)
   10c5a:	0033      	movs	r3, r6
   10c5c:	0022      	movs	r2, r4
   10c5e:	0020      	movs	r0, r4
   10c60:	4d36      	ldr	r5, [pc, #216]	; (10d3c <m_prov_adv_trans_rx+0x360>)
   10c62:	3315      	adds	r3, #21
   10c64:	0029      	movs	r1, r5
   10c66:	3222      	adds	r2, #34	; 0x22
   10c68:	9300      	str	r3, [sp, #0]
   10c6a:	3035      	adds	r0, #53	; 0x35
   10c6c:	4b39      	ldr	r3, [pc, #228]	; (10d54 <m_prov_adv_trans_rx+0x378>)
   10c6e:	f7f3 fe9d 	bl	49ac <m_print>
   10c72:	0030      	movs	r0, r6
   10c74:	3071      	adds	r0, #113	; 0x71
   10c76:	f7f3 fe99 	bl	49ac <m_print>
   10c7a:	0020      	movs	r0, r4
   10c7c:	1da9      	adds	r1, r5, #6
   10c7e:	305d      	adds	r0, #93	; 0x5d
   10c80:	f7f3 fe94 	bl	49ac <m_print>
                        // Close reason present in the PDU
                        if(p_buf->data_len == M_PROV_REASON_LEN)
   10c84:	9b02      	ldr	r3, [sp, #8]
   10c86:	891b      	ldrh	r3, [r3, #8]
   10c88:	2b01      	cmp	r3, #1
   10c8a:	d000      	beq.n	10c8e <m_prov_adv_trans_rx+0x2b2>
   10c8c:	e17e      	b.n	10f8c <m_prov_adv_trans_rx+0x5b0>
                        {
                            // Inform that provisioning link is closed
                            m_prov_link_closed(*p_data);
   10c8e:	9b03      	ldr	r3, [sp, #12]
   10c90:	7998      	ldrb	r0, [r3, #6]
   10c92:	f7ff fa9b 	bl	101cc <m_prov_link_closed>
   10c96:	e179      	b.n	10f8c <m_prov_adv_trans_rx+0x5b0>
                    default: { /* Ignore packet */ } break;
                }
            } break;
            case M_PROV_GPCF_TRANS_START:
            {
            	M_PRINTF(L_PROV, "M_PROV_GPCF_TRANS_START");
   10c98:	680b      	ldr	r3, [r1, #0]
   10c9a:	4213      	tst	r3, r2
   10c9c:	d015      	beq.n	10cca <m_prov_adv_trans_rx+0x2ee>
   10c9e:	4c26      	ldr	r4, [pc, #152]	; (10d38 <m_prov_adv_trans_rx+0x35c>)
   10ca0:	4b24      	ldr	r3, [pc, #144]	; (10d34 <m_prov_adv_trans_rx+0x358>)
   10ca2:	0022      	movs	r2, r4
   10ca4:	0020      	movs	r0, r4
   10ca6:	4d25      	ldr	r5, [pc, #148]	; (10d3c <m_prov_adv_trans_rx+0x360>)
   10ca8:	3315      	adds	r3, #21
   10caa:	0029      	movs	r1, r5
   10cac:	3222      	adds	r2, #34	; 0x22
   10cae:	9300      	str	r3, [sp, #0]
   10cb0:	3035      	adds	r0, #53	; 0x35
   10cb2:	4b29      	ldr	r3, [pc, #164]	; (10d58 <m_prov_adv_trans_rx+0x37c>)
   10cb4:	f7f3 fe7a 	bl	49ac <m_print>
   10cb8:	4828      	ldr	r0, [pc, #160]	; (10d5c <m_prov_adv_trans_rx+0x380>)
   10cba:	3003      	adds	r0, #3
   10cbc:	f7f3 fe76 	bl	49ac <m_print>
   10cc0:	0020      	movs	r0, r4
   10cc2:	1da9      	adds	r1, r5, #6
   10cc4:	305d      	adds	r0, #93	; 0x5d
   10cc6:	f7f3 fe71 	bl	49ac <m_print>
                // sanity check on minimum packet length
                if((p_buf->data_len < M_PROV_TRANS_START_PDU_MIN_LEN)) { break; }
   10cca:	9b02      	ldr	r3, [sp, #8]
   10ccc:	891b      	ldrh	r3, [r3, #8]
   10cce:	2b03      	cmp	r3, #3
   10cd0:	d800      	bhi.n	10cd4 <m_prov_adv_trans_rx+0x2f8>
   10cd2:	e15b      	b.n	10f8c <m_prov_adv_trans_rx+0x5b0>

                // Check if packet already received
                if(trans_nb == (p_adv_res->rx_trans_cursor - 1))
   10cd4:	003b      	movs	r3, r7
   10cd6:	332b      	adds	r3, #43	; 0x2b
   10cd8:	781b      	ldrb	r3, [r3, #0]
   10cda:	9905      	ldr	r1, [sp, #20]
   10cdc:	1e5a      	subs	r2, r3, #1
   10cde:	4291      	cmp	r1, r2
   10ce0:	d140      	bne.n	10d64 <m_prov_adv_trans_rx+0x388>
                {
                	M_PRINTF(L_PROV, "already received");
   10ce2:	4b13      	ldr	r3, [pc, #76]	; (10d30 <m_prov_adv_trans_rx+0x354>)
   10ce4:	681b      	ldr	r3, [r3, #0]
   10ce6:	071b      	lsls	r3, r3, #28
   10ce8:	d515      	bpl.n	10d16 <m_prov_adv_trans_rx+0x33a>
   10cea:	4c13      	ldr	r4, [pc, #76]	; (10d38 <m_prov_adv_trans_rx+0x35c>)
   10cec:	4b11      	ldr	r3, [pc, #68]	; (10d34 <m_prov_adv_trans_rx+0x358>)
   10cee:	0022      	movs	r2, r4
   10cf0:	0020      	movs	r0, r4
   10cf2:	4d12      	ldr	r5, [pc, #72]	; (10d3c <m_prov_adv_trans_rx+0x360>)
   10cf4:	3315      	adds	r3, #21
   10cf6:	0029      	movs	r1, r5
   10cf8:	3222      	adds	r2, #34	; 0x22
   10cfa:	9300      	str	r3, [sp, #0]
   10cfc:	3035      	adds	r0, #53	; 0x35
   10cfe:	4b18      	ldr	r3, [pc, #96]	; (10d60 <m_prov_adv_trans_rx+0x384>)
   10d00:	f7f3 fe54 	bl	49ac <m_print>
   10d04:	4815      	ldr	r0, [pc, #84]	; (10d5c <m_prov_adv_trans_rx+0x380>)
   10d06:	301b      	adds	r0, #27
   10d08:	f7f3 fe50 	bl	49ac <m_print>
   10d0c:	0020      	movs	r0, r4
   10d0e:	1da9      	adds	r1, r5, #6
   10d10:	305d      	adds	r0, #93	; 0x5d
   10d12:	f7f3 fe4b 	bl	49ac <m_print>
                    // seems that packet acknowledgment not received
                    if(GETB(p_adv_res->link_info, M_PROV_RX_OK) && !GETB(p_adv_res->link_info, M_PROV_SEND_ACK))
   10d16:	2218      	movs	r2, #24
   10d18:	8d3b      	ldrh	r3, [r7, #40]	; 0x28
   10d1a:	401a      	ands	r2, r3
   10d1c:	2a08      	cmp	r2, #8
   10d1e:	d000      	beq.n	10d22 <m_prov_adv_trans_rx+0x346>
   10d20:	e134      	b.n	10f8c <m_prov_adv_trans_rx+0x5b0>
                    {
                        // Mark that Link ACK message must be sent
                        SETB(p_adv_res->link_info, M_PROV_SEND_ACK, true);
   10d22:	3208      	adds	r2, #8
   10d24:	4313      	orrs	r3, r2
   10d26:	853b      	strh	r3, [r7, #40]	; 0x28
                        // Mark that something must be sent
                        m_prov_adv_trans_tx_set();
   10d28:	f7ff fb5a 	bl	103e0 <m_prov_adv_trans_tx_set>
   10d2c:	e12e      	b.n	10f8c <m_prov_adv_trans_rx+0x5b0>
   10d2e:	46c0      	nop			; (mov r8, r8)
   10d30:	10010514 	.word	0x10010514
   10d34:	000224c3 	.word	0x000224c3
   10d38:	000223c3 	.word	0x000223c3
   10d3c:	000222c3 	.word	0x000222c3
   10d40:	100128a4 	.word	0x100128a4
   10d44:	00000279 	.word	0x00000279
   10d48:	0001047d 	.word	0x0001047d
   10d4c:	0000029a 	.word	0x0000029a
   10d50:	000002a5 	.word	0x000002a5
   10d54:	000002ad 	.word	0x000002ad
   10d58:	000002ba 	.word	0x000002ba
   10d5c:	00022543 	.word	0x00022543
   10d60:	000002c1 	.word	0x000002c1
                    }
                }
                // New packet received
                else if((trans_nb == p_adv_res->rx_trans_cursor) && (p_adv_res->p_rx_buf == NULL))
   10d64:	9a05      	ldr	r2, [sp, #20]
   10d66:	429a      	cmp	r2, r3
   10d68:	d000      	beq.n	10d6c <m_prov_adv_trans_rx+0x390>
   10d6a:	e10f      	b.n	10f8c <m_prov_adv_trans_rx+0x5b0>
   10d6c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   10d6e:	2b00      	cmp	r3, #0
   10d70:	d000      	beq.n	10d74 <m_prov_adv_trans_rx+0x398>
   10d72:	e10b      	b.n	10f8c <m_prov_adv_trans_rx+0x5b0>
                {
                	M_PRINTF(L_PROV, "New packet received");
   10d74:	4b86      	ldr	r3, [pc, #536]	; (10f90 <m_prov_adv_trans_rx+0x5b4>)
   10d76:	681b      	ldr	r3, [r3, #0]
   10d78:	071b      	lsls	r3, r3, #28
   10d7a:	d515      	bpl.n	10da8 <m_prov_adv_trans_rx+0x3cc>
   10d7c:	4c85      	ldr	r4, [pc, #532]	; (10f94 <m_prov_adv_trans_rx+0x5b8>)
   10d7e:	4b86      	ldr	r3, [pc, #536]	; (10f98 <m_prov_adv_trans_rx+0x5bc>)
   10d80:	0022      	movs	r2, r4
   10d82:	0020      	movs	r0, r4
   10d84:	4d85      	ldr	r5, [pc, #532]	; (10f9c <m_prov_adv_trans_rx+0x5c0>)
   10d86:	3315      	adds	r3, #21
   10d88:	0029      	movs	r1, r5
   10d8a:	3222      	adds	r2, #34	; 0x22
   10d8c:	9300      	str	r3, [sp, #0]
   10d8e:	3035      	adds	r0, #53	; 0x35
   10d90:	4b83      	ldr	r3, [pc, #524]	; (10fa0 <m_prov_adv_trans_rx+0x5c4>)
   10d92:	f7f3 fe0b 	bl	49ac <m_print>
   10d96:	4883      	ldr	r0, [pc, #524]	; (10fa4 <m_prov_adv_trans_rx+0x5c8>)
   10d98:	302c      	adds	r0, #44	; 0x2c
   10d9a:	f7f3 fe07 	bl	49ac <m_print>
   10d9e:	0020      	movs	r0, r4
   10da0:	1da9      	adds	r1, r5, #6
   10da2:	305d      	adds	r0, #93	; 0x5d
   10da4:	f7f3 fe02 	bl	49ac <m_print>
                    uint8_t  fcs;
                    uint8_t  pdu_type;
                    uint16_t total_len;
                    uint16_t min_exp_len = 0;
                    uint16_t max_exp_len = M_PROV_TRANS_START_PLD_MAX_LEN
                                         + (GETF(gpc_head, M_PROV_SEG_N) * M_PROV_TRANS_CONT_PLD_MAX_LEN);
   10da8:	9b04      	ldr	r3, [sp, #16]

                    m_tb_buf_t *p_rx_buf = NULL;
   10daa:	2200      	movs	r2, #0
                    uint8_t  fcs;
                    uint8_t  pdu_type;
                    uint16_t total_len;
                    uint16_t min_exp_len = 0;
                    uint16_t max_exp_len = M_PROV_TRANS_START_PLD_MAX_LEN
                                         + (GETF(gpc_head, M_PROV_SEG_N) * M_PROV_TRANS_CONT_PLD_MAX_LEN);
   10dac:	089d      	lsrs	r5, r3, #2
                	M_PRINTF(L_PROV, "New packet received");
                    uint8_t  fcs;
                    uint8_t  pdu_type;
                    uint16_t total_len;
                    uint16_t min_exp_len = 0;
                    uint16_t max_exp_len = M_PROV_TRANS_START_PLD_MAX_LEN
   10dae:	2317      	movs	r3, #23
   10db0:	001e      	movs	r6, r3
   10db2:	436e      	muls	r6, r5
   10db4:	3613      	adds	r6, #19
   10db6:	9604      	str	r6, [sp, #16]
                                         + (GETF(gpc_head, M_PROV_SEG_N) * M_PROV_TRANS_CONT_PLD_MAX_LEN);

                    m_tb_buf_t *p_rx_buf = NULL;
   10db8:	920b      	str	r2, [sp, #44]	; 0x2c
                {
                	M_PRINTF(L_PROV, "New packet received");
                    uint8_t  fcs;
                    uint8_t  pdu_type;
                    uint16_t total_len;
                    uint16_t min_exp_len = 0;
   10dba:	002e      	movs	r6, r5

                    m_tb_buf_t *p_rx_buf = NULL;
                    m_prov_buf_env_t* p_rx_buf_env;

                    // Compute minimum length if there is more that one segment
                    if(GETF(gpc_head, M_PROV_SEG_N) > 0)
   10dbc:	4295      	cmp	r5, r2
   10dbe:	d003      	beq.n	10dc8 <m_prov_adv_trans_rx+0x3ec>
                    {
                        min_exp_len = M_PROV_TRANS_START_PLD_MAX_LEN
   10dc0:	1e6a      	subs	r2, r5, #1
   10dc2:	4353      	muls	r3, r2
   10dc4:	3313      	adds	r3, #19
   10dc6:	b29e      	uxth	r6, r3
 * @return The 16 bits value.
 ****************************************************************************************
 */
__INLINE_S__ uint16_t co_read16p(void const *ptr16)
{
    uint16_t value = ((uint8_t *)ptr16)[0] | ((uint8_t *)ptr16)[1] << 8;
   10dc8:	9b03      	ldr	r3, [sp, #12]
   10dca:	9a03      	ldr	r2, [sp, #12]
   10dcc:	79db      	ldrb	r3, [r3, #7]
   10dce:	7994      	ldrb	r4, [r2, #6]
   10dd0:	021b      	lsls	r3, r3, #8
   10dd2:	4323      	orrs	r3, r4
                                    + ((GETF(gpc_head, M_PROV_SEG_N) - 1) * M_PROV_TRANS_CONT_PLD_MAX_LEN);
                    }

                    // Load Length, FCS and PDU type
                    total_len = (co_ntohs(co_read16p(p_data)) - 1);
   10dd4:	021c      	lsls	r4, r3, #8
   10dd6:	0a1b      	lsrs	r3, r3, #8
   10dd8:	431c      	orrs	r4, r3
                    p_data   += 2;
                    fcs       = *p_data;
   10dda:	7a13      	ldrb	r3, [r2, #8]
                        min_exp_len = M_PROV_TRANS_START_PLD_MAX_LEN
                                    + ((GETF(gpc_head, M_PROV_SEG_N) - 1) * M_PROV_TRANS_CONT_PLD_MAX_LEN);
                    }

                    // Load Length, FCS and PDU type
                    total_len = (co_ntohs(co_read16p(p_data)) - 1);
   10ddc:	3c01      	subs	r4, #1
                    p_data   += 2;
                    fcs       = *p_data;
   10dde:	9305      	str	r3, [sp, #20]
                    p_data   += 1;
                    pdu_type  = *p_data;
   10de0:	7a53      	ldrb	r3, [r2, #9]
                        min_exp_len = M_PROV_TRANS_START_PLD_MAX_LEN
                                    + ((GETF(gpc_head, M_PROV_SEG_N) - 1) * M_PROV_TRANS_CONT_PLD_MAX_LEN);
                    }

                    // Load Length, FCS and PDU type
                    total_len = (co_ntohs(co_read16p(p_data)) - 1);
   10de2:	b2a4      	uxth	r4, r4
                    p_data   += 1;
                    pdu_type  = *p_data;
                    p_data   += 1;

                    // Update buffer to point on PDU Data
                    m_tb_buf_head_release(p_buf, M_PROV_TRANS_START_PDU_MIN_LEN);
   10de4:	2104      	movs	r1, #4
   10de6:	9802      	ldr	r0, [sp, #8]
                    // Load Length, FCS and PDU type
                    total_len = (co_ntohs(co_read16p(p_data)) - 1);
                    p_data   += 2;
                    fcs       = *p_data;
                    p_data   += 1;
                    pdu_type  = *p_data;
   10de8:	9303      	str	r3, [sp, #12]
                    p_data   += 1;

                    // Update buffer to point on PDU Data
                    m_tb_buf_head_release(p_buf, M_PROV_TRANS_START_PDU_MIN_LEN);
   10dea:	f000 fc29 	bl	11640 <m_tb_buf_head_release>

                    // sanity check on payload length
                    if(   (total_len > M_PROV_GEN_PLD_MAX_SIZE)
   10dee:	2c40      	cmp	r4, #64	; 0x40
   10df0:	d900      	bls.n	10df4 <m_prov_adv_trans_rx+0x418>
   10df2:	e0cb      	b.n	10f8c <m_prov_adv_trans_rx+0x5b0>
                       // ensure that number of segment allows to contains payload length
                       || (total_len < min_exp_len) || (total_len > max_exp_len))
   10df4:	42a6      	cmp	r6, r4
   10df6:	d900      	bls.n	10dfa <m_prov_adv_trans_rx+0x41e>
   10df8:	e0c8      	b.n	10f8c <m_prov_adv_trans_rx+0x5b0>
   10dfa:	9b04      	ldr	r3, [sp, #16]
   10dfc:	42a3      	cmp	r3, r4
   10dfe:	d200      	bcs.n	10e02 <m_prov_adv_trans_rx+0x426>
   10e00:	e0c4      	b.n	10f8c <m_prov_adv_trans_rx+0x5b0>
   10e02:	9b02      	ldr	r3, [sp, #8]
   10e04:	891b      	ldrh	r3, [r3, #8]
                    {
                        break;
                    }

                    // sanity check on buffer length
                    if(   ((GETF(gpc_head, M_PROV_SEG_N) == 0) && (p_buf->data_len != total_len))
   10e06:	2d00      	cmp	r5, #0
   10e08:	d103      	bne.n	10e12 <m_prov_adv_trans_rx+0x436>
   10e0a:	42a3      	cmp	r3, r4
   10e0c:	d000      	beq.n	10e10 <m_prov_adv_trans_rx+0x434>
   10e0e:	e0bd      	b.n	10f8c <m_prov_adv_trans_rx+0x5b0>
   10e10:	e002      	b.n	10e18 <m_prov_adv_trans_rx+0x43c>
                       || ((GETF(gpc_head, M_PROV_SEG_N) > 0)  && (p_buf->data_len != M_PROV_TRANS_START_PLD_MAX_LEN)))
   10e12:	2b13      	cmp	r3, #19
   10e14:	d000      	beq.n	10e18 <m_prov_adv_trans_rx+0x43c>
   10e16:	e0b9      	b.n	10f8c <m_prov_adv_trans_rx+0x5b0>
                    {
                        break;
                    }

                    // Allocate reception buffer
                    if(m_tb_buf_alloc(&p_rx_buf, 0, total_len, 0) != M_ERR_NO_ERROR)
   10e18:	2300      	movs	r3, #0
   10e1a:	0022      	movs	r2, r4
   10e1c:	0019      	movs	r1, r3
   10e1e:	a80b      	add	r0, sp, #44	; 0x2c
   10e20:	f000 fb8a 	bl	11538 <m_tb_buf_alloc>
   10e24:	2800      	cmp	r0, #0
   10e26:	d000      	beq.n	10e2a <m_prov_adv_trans_rx+0x44e>
   10e28:	e0b0      	b.n	10f8c <m_prov_adv_trans_rx+0x5b0>
                    }

                    p_rx_buf_env = (m_prov_buf_env_t*) p_rx_buf->env;

                    // Load FCS and Pdu type
                    p_rx_buf_env->fcs       = fcs;
   10e2a:	466a      	mov	r2, sp
                    if(m_tb_buf_alloc(&p_rx_buf, 0, total_len, 0) != M_ERR_NO_ERROR)
                    {
                        break;
                    }

                    p_rx_buf_env = (m_prov_buf_env_t*) p_rx_buf->env;
   10e2c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c

                    // Load FCS and Pdu type
                    p_rx_buf_env->fcs       = fcs;
   10e2e:	7d12      	ldrb	r2, [r2, #20]
                    // Fill buffer information
                    p_rx_buf_env->seg_nb    = GETF(gpc_head, M_PROV_SEG_N) + 1;
                    p_rx_buf_env->seg_mask  = CO_BIT(p_rx_buf_env->seg_nb) - 1;

                    // Consider that first segment is received
                    p_rx_buf_env->seg_mask &= ~CO_BIT(0);
   10e30:	2101      	movs	r1, #1
                    }

                    p_rx_buf_env = (m_prov_buf_env_t*) p_rx_buf->env;

                    // Load FCS and Pdu type
                    p_rx_buf_env->fcs       = fcs;
   10e32:	745a      	strb	r2, [r3, #17]
                    p_rx_buf_env->pdu_type  = pdu_type;
   10e34:	466a      	mov	r2, sp
   10e36:	7b12      	ldrb	r2, [r2, #12]

                    // Fill buffer information
                    p_rx_buf_env->seg_nb    = GETF(gpc_head, M_PROV_SEG_N) + 1;
   10e38:	3501      	adds	r5, #1

                    p_rx_buf_env = (m_prov_buf_env_t*) p_rx_buf->env;

                    // Load FCS and Pdu type
                    p_rx_buf_env->fcs       = fcs;
                    p_rx_buf_env->pdu_type  = pdu_type;
   10e3a:	741a      	strb	r2, [r3, #16]
                    // Fill buffer information
                    p_rx_buf_env->seg_nb    = GETF(gpc_head, M_PROV_SEG_N) + 1;
                    p_rx_buf_env->seg_mask  = CO_BIT(p_rx_buf_env->seg_nb) - 1;

                    // Consider that first segment is received
                    p_rx_buf_env->seg_mask &= ~CO_BIT(0);
   10e3c:	000a      	movs	r2, r1
   10e3e:	40aa      	lsls	r2, r5

                    // Copy buffer data
                    memcpy(M_TB_BUF_DATA(p_rx_buf), M_TB_BUF_DATA(p_buf), p_buf->data_len);
   10e40:	0018      	movs	r0, r3
                    // Fill buffer information
                    p_rx_buf_env->seg_nb    = GETF(gpc_head, M_PROV_SEG_N) + 1;
                    p_rx_buf_env->seg_mask  = CO_BIT(p_rx_buf_env->seg_nb) - 1;

                    // Consider that first segment is received
                    p_rx_buf_env->seg_mask &= ~CO_BIT(0);
   10e42:	3a01      	subs	r2, #1
   10e44:	438a      	bics	r2, r1
                    // Load FCS and Pdu type
                    p_rx_buf_env->fcs       = fcs;
                    p_rx_buf_env->pdu_type  = pdu_type;

                    // Fill buffer information
                    p_rx_buf_env->seg_nb    = GETF(gpc_head, M_PROV_SEG_N) + 1;
   10e46:	74dd      	strb	r5, [r3, #19]
                    p_rx_buf_env->seg_mask  = CO_BIT(p_rx_buf_env->seg_nb) - 1;

                    // Consider that first segment is received
                    p_rx_buf_env->seg_mask &= ~CO_BIT(0);
   10e48:	749a      	strb	r2, [r3, #18]

                    // Copy buffer data
                    memcpy(M_TB_BUF_DATA(p_rx_buf), M_TB_BUF_DATA(p_buf), p_buf->data_len);
   10e4a:	889b      	ldrh	r3, [r3, #4]
   10e4c:	3030      	adds	r0, #48	; 0x30
   10e4e:	18c0      	adds	r0, r0, r3
   10e50:	9b02      	ldr	r3, [sp, #8]
   10e52:	891a      	ldrh	r2, [r3, #8]
   10e54:	8899      	ldrh	r1, [r3, #4]
   10e56:	9b06      	ldr	r3, [sp, #24]
   10e58:	1859      	adds	r1, r3, r1
   10e5a:	f004 fdb9 	bl	159d0 <memcpy>

                    // update buffer expectation
                    SETB(p_adv_res->link_info, M_PROV_RX_OK, false);
                    // ensure that no TX Ack will  be sent
                    SETB(p_adv_res->link_info, M_PROV_SEND_ACK, false);
   10e5e:	2218      	movs	r2, #24
   10e60:	8d3b      	ldrh	r3, [r7, #40]	; 0x28

                    // Check if complete PDU received
                    p_adv_res->p_rx_buf = p_rx_buf;
                    m_prov_adv_trans_rx_check(p_adv_res);
   10e62:	0038      	movs	r0, r7
                    memcpy(M_TB_BUF_DATA(p_rx_buf), M_TB_BUF_DATA(p_buf), p_buf->data_len);

                    // update buffer expectation
                    SETB(p_adv_res->link_info, M_PROV_RX_OK, false);
                    // ensure that no TX Ack will  be sent
                    SETB(p_adv_res->link_info, M_PROV_SEND_ACK, false);
   10e64:	4393      	bics	r3, r2
   10e66:	853b      	strh	r3, [r7, #40]	; 0x28

                    // Check if complete PDU received
                    p_adv_res->p_rx_buf = p_rx_buf;
   10e68:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   10e6a:	627b      	str	r3, [r7, #36]	; 0x24
                    m_prov_adv_trans_rx_check(p_adv_res);
   10e6c:	f000 f90a 	bl	11084 <m_prov_adv_trans_rx_check>
   10e70:	e08c      	b.n	10f8c <m_prov_adv_trans_rx+0x5b0>
                }
            } break;
            case M_PROV_GPCF_TRANS_CONT:
            {
            	M_PRINTF(L_PROV, "M_PROV_GPCF_TRANS_CONT");
   10e72:	680b      	ldr	r3, [r1, #0]
   10e74:	4213      	tst	r3, r2
   10e76:	d016      	beq.n	10ea6 <m_prov_adv_trans_rx+0x4ca>
   10e78:	4b47      	ldr	r3, [pc, #284]	; (10f98 <m_prov_adv_trans_rx+0x5bc>)
   10e7a:	4c46      	ldr	r4, [pc, #280]	; (10f94 <m_prov_adv_trans_rx+0x5b8>)
   10e7c:	3315      	adds	r3, #21
   10e7e:	9300      	str	r3, [sp, #0]
   10e80:	0022      	movs	r2, r4
   10e82:	0020      	movs	r0, r4
   10e84:	23c7      	movs	r3, #199	; 0xc7
   10e86:	4d45      	ldr	r5, [pc, #276]	; (10f9c <m_prov_adv_trans_rx+0x5c0>)
   10e88:	3222      	adds	r2, #34	; 0x22
   10e8a:	0029      	movs	r1, r5
   10e8c:	009b      	lsls	r3, r3, #2
   10e8e:	3035      	adds	r0, #53	; 0x35
   10e90:	f7f3 fd8c 	bl	49ac <m_print>
   10e94:	4843      	ldr	r0, [pc, #268]	; (10fa4 <m_prov_adv_trans_rx+0x5c8>)
   10e96:	3040      	adds	r0, #64	; 0x40
   10e98:	f7f3 fd88 	bl	49ac <m_print>
   10e9c:	0020      	movs	r0, r4
   10e9e:	1da9      	adds	r1, r5, #6
   10ea0:	305d      	adds	r0, #93	; 0x5d
   10ea2:	f7f3 fd83 	bl	49ac <m_print>
                // Check if packet already received
                if(GETB(p_adv_res->link_info, M_PROV_RX_OK))
   10ea6:	8d3b      	ldrh	r3, [r7, #40]	; 0x28
   10ea8:	071a      	lsls	r2, r3, #28
   10eaa:	d50a      	bpl.n	10ec2 <m_prov_adv_trans_rx+0x4e6>
                {
                    // check transport number and if acknowledgment must be sent
                    if(   (trans_nb == (p_adv_res->rx_trans_cursor - 1))
   10eac:	003a      	movs	r2, r7
   10eae:	322b      	adds	r2, #43	; 0x2b
   10eb0:	7812      	ldrb	r2, [r2, #0]
   10eb2:	9905      	ldr	r1, [sp, #20]
   10eb4:	3a01      	subs	r2, #1
   10eb6:	4291      	cmp	r1, r2
   10eb8:	d168      	bne.n	10f8c <m_prov_adv_trans_rx+0x5b0>
                       && (!GETB(p_adv_res->link_info, M_PROV_SEND_ACK)))
   10eba:	2210      	movs	r2, #16
   10ebc:	4213      	tst	r3, r2
   10ebe:	d165      	bne.n	10f8c <m_prov_adv_trans_rx+0x5b0>
   10ec0:	e730      	b.n	10d24 <m_prov_adv_trans_rx+0x348>
                    }

                    break;
                }
                // check if a packet is under reception
                else if((p_adv_res->p_rx_buf != NULL) && (trans_nb == p_adv_res->rx_trans_cursor))
   10ec2:	6a7a      	ldr	r2, [r7, #36]	; 0x24
   10ec4:	2a00      	cmp	r2, #0
   10ec6:	d061      	beq.n	10f8c <m_prov_adv_trans_rx+0x5b0>
   10ec8:	003b      	movs	r3, r7
   10eca:	332b      	adds	r3, #43	; 0x2b
   10ecc:	781b      	ldrb	r3, [r3, #0]
   10ece:	9905      	ldr	r1, [sp, #20]
   10ed0:	428b      	cmp	r3, r1
   10ed2:	d15b      	bne.n	10f8c <m_prov_adv_trans_rx+0x5b0>
                    uint16_t          data_offset;
                    // Retrieve buffer info
                    m_tb_buf_t*       p_rx_buf     = p_adv_res->p_rx_buf;
                    m_prov_buf_env_t* p_rx_buf_env = (m_prov_buf_env_t*) p_rx_buf->env;
                    // Check if segment not already received
                    if((p_rx_buf_env->seg_mask & CO_BIT(GETF(gpc_head, M_PROV_SEG_N))) == 0)
   10ed4:	9b04      	ldr	r3, [sp, #16]
   10ed6:	7c91      	ldrb	r1, [r2, #18]
   10ed8:	089d      	lsrs	r5, r3, #2
   10eda:	000b      	movs	r3, r1
   10edc:	40eb      	lsrs	r3, r5
   10ede:	07db      	lsls	r3, r3, #31
   10ee0:	d554      	bpl.n	10f8c <m_prov_adv_trans_rx+0x5b0>
                    {
                        break;
                    }

                    // Compute data offset
                    data_offset = M_PROV_TRANS_START_PLD_MAX_LEN
   10ee2:	2317      	movs	r3, #23
   10ee4:	1e68      	subs	r0, r5, #1
   10ee6:	4343      	muls	r3, r0
                                + ((GETF(gpc_head, M_PROV_SEG_N) - 1) * M_PROV_TRANS_CONT_PLD_MAX_LEN);

                    // sanity check on buffer length
                    if(GETF(gpc_head, M_PROV_SEG_N) == (p_rx_buf_env->seg_nb - 1))
   10ee8:	7cd0      	ldrb	r0, [r2, #19]
   10eea:	9c02      	ldr	r4, [sp, #8]
                    {
                        break;
                    }

                    // Compute data offset
                    data_offset = M_PROV_TRANS_START_PLD_MAX_LEN
   10eec:	3313      	adds	r3, #19
                                + ((GETF(gpc_head, M_PROV_SEG_N) - 1) * M_PROV_TRANS_CONT_PLD_MAX_LEN);

                    // sanity check on buffer length
                    if(GETF(gpc_head, M_PROV_SEG_N) == (p_rx_buf_env->seg_nb - 1))
   10eee:	3801      	subs	r0, #1
                    {
                        break;
                    }

                    // Compute data offset
                    data_offset = M_PROV_TRANS_START_PLD_MAX_LEN
   10ef0:	b29b      	uxth	r3, r3
   10ef2:	8924      	ldrh	r4, [r4, #8]
                                + ((GETF(gpc_head, M_PROV_SEG_N) - 1) * M_PROV_TRANS_CONT_PLD_MAX_LEN);

                    // sanity check on buffer length
                    if(GETF(gpc_head, M_PROV_SEG_N) == (p_rx_buf_env->seg_nb - 1))
   10ef4:	4285      	cmp	r5, r0
   10ef6:	d104      	bne.n	10f02 <m_prov_adv_trans_rx+0x526>
                    {
                        if(p_buf->data_len != p_rx_buf->data_len - data_offset) break;
   10ef8:	8910      	ldrh	r0, [r2, #8]
   10efa:	1ac0      	subs	r0, r0, r3
   10efc:	4284      	cmp	r4, r0
   10efe:	d145      	bne.n	10f8c <m_prov_adv_trans_rx+0x5b0>
   10f00:	e001      	b.n	10f06 <m_prov_adv_trans_rx+0x52a>
                    }
                    else
                    {
                        if(p_buf->data_len != M_PROV_TRANS_CONT_PLD_MAX_LEN) break;
   10f02:	2c17      	cmp	r4, #23
   10f04:	d142      	bne.n	10f8c <m_prov_adv_trans_rx+0x5b0>
                    }

                    // Consider segment is received
                    p_rx_buf_env->seg_mask &= ~CO_BIT(GETF(gpc_head, M_PROV_SEG_N));
   10f06:	2001      	movs	r0, #1
   10f08:	40a8      	lsls	r0, r5
   10f0a:	4381      	bics	r1, r0
   10f0c:	7491      	strb	r1, [r2, #18]

                    // Copy buffer data
                    memcpy(M_TB_BUF_DATA(p_rx_buf) + data_offset, M_TB_BUF_DATA(p_buf), p_buf->data_len);
   10f0e:	0011      	movs	r1, r2
   10f10:	8890      	ldrh	r0, [r2, #4]
   10f12:	3130      	adds	r1, #48	; 0x30
   10f14:	18c3      	adds	r3, r0, r3
   10f16:	18c8      	adds	r0, r1, r3
   10f18:	9b02      	ldr	r3, [sp, #8]
   10f1a:	891a      	ldrh	r2, [r3, #8]
   10f1c:	8899      	ldrh	r1, [r3, #4]
   10f1e:	9b06      	ldr	r3, [sp, #24]
   10f20:	1859      	adds	r1, r3, r1
   10f22:	f004 fd55 	bl	159d0 <memcpy>

                    // Check if complete PDU received
                    m_prov_adv_trans_rx_check(p_adv_res);
   10f26:	0038      	movs	r0, r7
   10f28:	f000 f8ac 	bl	11084 <m_prov_adv_trans_rx_check>
   10f2c:	e02e      	b.n	10f8c <m_prov_adv_trans_rx+0x5b0>
                }
            } break;
            case M_PROV_GPCF_TRANS_ACK:
            {
            	M_PRINTF(L_PROV, "M_PROV_GPCF_TRANS_ACK");
   10f2e:	680b      	ldr	r3, [r1, #0]
   10f30:	4213      	tst	r3, r2
   10f32:	d015      	beq.n	10f60 <m_prov_adv_trans_rx+0x584>
   10f34:	4c17      	ldr	r4, [pc, #92]	; (10f94 <m_prov_adv_trans_rx+0x5b8>)
   10f36:	4b18      	ldr	r3, [pc, #96]	; (10f98 <m_prov_adv_trans_rx+0x5bc>)
   10f38:	0022      	movs	r2, r4
   10f3a:	0020      	movs	r0, r4
   10f3c:	4d17      	ldr	r5, [pc, #92]	; (10f9c <m_prov_adv_trans_rx+0x5c0>)
   10f3e:	3315      	adds	r3, #21
   10f40:	0029      	movs	r1, r5
   10f42:	3222      	adds	r2, #34	; 0x22
   10f44:	9300      	str	r3, [sp, #0]
   10f46:	3035      	adds	r0, #53	; 0x35
   10f48:	4b17      	ldr	r3, [pc, #92]	; (10fa8 <m_prov_adv_trans_rx+0x5cc>)
   10f4a:	f7f3 fd2f 	bl	49ac <m_print>
   10f4e:	4815      	ldr	r0, [pc, #84]	; (10fa4 <m_prov_adv_trans_rx+0x5c8>)
   10f50:	3057      	adds	r0, #87	; 0x57
   10f52:	f7f3 fd2b 	bl	49ac <m_print>
   10f56:	0020      	movs	r0, r4
   10f58:	1da9      	adds	r1, r5, #6
   10f5a:	305d      	adds	r0, #93	; 0x5d
   10f5c:	f7f3 fd26 	bl	49ac <m_print>
   10f60:	697c      	ldr	r4, [r7, #20]
                m_tb_buf_t* p_tx_buf = (m_tb_buf_t*) co_list_pick(&(p_adv_res->tx_queue));
                m_prov_buf_env_t* p_tx_buf_env;
                // check that buffer is present
                if(p_tx_buf == NULL) break;
   10f62:	2c00      	cmp	r4, #0
   10f64:	d012      	beq.n	10f8c <m_prov_adv_trans_rx+0x5b0>

                // no payload data expected
                if(p_buf->data_len != 0) break;
   10f66:	9b02      	ldr	r3, [sp, #8]
   10f68:	891d      	ldrh	r5, [r3, #8]
   10f6a:	2d00      	cmp	r5, #0
   10f6c:	d10e      	bne.n	10f8c <m_prov_adv_trans_rx+0x5b0>

                p_tx_buf_env = (m_prov_buf_env_t*) p_tx_buf->env;

                // check transmission number
                if(trans_nb != p_tx_buf_env->trans_nb) { break; }
   10f6e:	7d63      	ldrb	r3, [r4, #21]
   10f70:	9a05      	ldr	r2, [sp, #20]
   10f72:	4293      	cmp	r3, r2
   10f74:	d10a      	bne.n	10f8c <m_prov_adv_trans_rx+0x5b0>

                // Mark packet acknowledged
                co_list_pop_front(&(p_adv_res->tx_queue));
   10f76:	0038      	movs	r0, r7
   10f78:	3014      	adds	r0, #20
   10f7a:	f7f3 fa37 	bl	43ec <co_list_pop_front>

                // Inform provisioning module of correct transmission of the PDU
                m_prov_pdu_sent(p_tx_buf, M_ERR_NO_ERROR);
   10f7e:	0020      	movs	r0, r4
   10f80:	0029      	movs	r1, r5
   10f82:	f7ff fa0b 	bl	1039c <m_prov_pdu_sent>
                m_tb_buf_release(p_tx_buf);
   10f86:	0020      	movs	r0, r4
   10f88:	f000 fb88 	bl	1169c <m_tb_buf_release>
            } break;
            // should not be possible
            default: { ASSERT_INFO(0, gpc_head, link_id & 0xFFFF); } break;
        }
    } while(0);
}
   10f8c:	b00d      	add	sp, #52	; 0x34
   10f8e:	bdf0      	pop	{r4, r5, r6, r7, pc}
   10f90:	10010514 	.word	0x10010514
   10f94:	000223c3 	.word	0x000223c3
   10f98:	000224c3 	.word	0x000224c3
   10f9c:	000222c3 	.word	0x000222c3
   10fa0:	000002ce 	.word	0x000002ce
   10fa4:	00022543 	.word	0x00022543
   10fa8:	00000353 	.word	0x00000353

00010fac <m_prov_adv_trans_sent>:

void m_prov_adv_trans_sent(m_tb_buf_t *p_buf, uint16_t status)
{
   10fac:	b5f0      	push	{r4, r5, r6, r7, lr}
	M_PRINTF(L_PROV, "");
   10fae:	4b2f      	ldr	r3, [pc, #188]	; (1106c <m_prov_adv_trans_sent+0xc0>)
        }
    } while(0);
}

void m_prov_adv_trans_sent(m_tb_buf_t *p_buf, uint16_t status)
{
   10fb0:	b085      	sub	sp, #20
	M_PRINTF(L_PROV, "");
   10fb2:	681a      	ldr	r2, [r3, #0]
        }
    } while(0);
}

void m_prov_adv_trans_sent(m_tb_buf_t *p_buf, uint16_t status)
{
   10fb4:	0007      	movs	r7, r0
   10fb6:	9103      	str	r1, [sp, #12]
   10fb8:	001e      	movs	r6, r3
	M_PRINTF(L_PROV, "");
   10fba:	0713      	lsls	r3, r2, #28
   10fbc:	d516      	bpl.n	10fec <m_prov_adv_trans_sent+0x40>
   10fbe:	4b2c      	ldr	r3, [pc, #176]	; (11070 <m_prov_adv_trans_sent+0xc4>)
   10fc0:	4c2c      	ldr	r4, [pc, #176]	; (11074 <m_prov_adv_trans_sent+0xc8>)
   10fc2:	336d      	adds	r3, #109	; 0x6d
   10fc4:	9300      	str	r3, [sp, #0]
   10fc6:	0022      	movs	r2, r4
   10fc8:	0020      	movs	r0, r4
   10fca:	23dc      	movs	r3, #220	; 0xdc
   10fcc:	4d2a      	ldr	r5, [pc, #168]	; (11078 <m_prov_adv_trans_sent+0xcc>)
   10fce:	3222      	adds	r2, #34	; 0x22
   10fd0:	0029      	movs	r1, r5
   10fd2:	009b      	lsls	r3, r3, #2
   10fd4:	3035      	adds	r0, #53	; 0x35
   10fd6:	f7f3 fce9 	bl	49ac <m_print>
   10fda:	0020      	movs	r0, r4
   10fdc:	305c      	adds	r0, #92	; 0x5c
   10fde:	f7f3 fce5 	bl	49ac <m_print>
   10fe2:	0020      	movs	r0, r4
   10fe4:	1da9      	adds	r1, r5, #6
   10fe6:	305d      	adds	r0, #93	; 0x5d
   10fe8:	f7f3 fce0 	bl	49ac <m_print>
    m_prov_adv_res_t* p_adv_res = p_m_prov_env->p_adv_res;
   10fec:	4b23      	ldr	r3, [pc, #140]	; (1107c <m_prov_adv_trans_sent+0xd0>)
   10fee:	681b      	ldr	r3, [r3, #0]
   10ff0:	689c      	ldr	r4, [r3, #8]

    // check that provisioner enabled
    if((p_adv_res != NULL) && (p_m_prov_env->p_res != NULL))
   10ff2:	2c00      	cmp	r4, #0
   10ff4:	d037      	beq.n	11066 <m_prov_adv_trans_sent+0xba>
   10ff6:	685b      	ldr	r3, [r3, #4]
   10ff8:	2b00      	cmp	r3, #0
   10ffa:	d034      	beq.n	11066 <m_prov_adv_trans_sent+0xba>
    {
        m_tb_buf_release(p_buf);
   10ffc:	0038      	movs	r0, r7
   10ffe:	f000 fb4d 	bl	1169c <m_tb_buf_release>

        SETB(p_adv_res->link_info, M_PROV_IN_TX, false);
   11002:	8d23      	ldrh	r3, [r4, #40]	; 0x28
   11004:	2202      	movs	r2, #2
   11006:	0019      	movs	r1, r3
   11008:	4391      	bics	r1, r2
   1100a:	8521      	strh	r1, [r4, #40]	; 0x28

        // Ready to clean-up transport
        if(GETB(p_adv_res->link_info, M_PROV_ADV_CLOSED))
   1100c:	07db      	lsls	r3, r3, #31
   1100e:	d501      	bpl.n	11014 <m_prov_adv_trans_sent+0x68>
        {
            m_prov_adv_trans_clean_up();
   11010:	f7ff fc4a 	bl	108a8 <m_prov_adv_trans_clean_up>
        }

        // an error occurs during transmission
        if(status != M_ERR_NO_ERROR)
   11014:	9b03      	ldr	r3, [sp, #12]
   11016:	2b00      	cmp	r3, #0
   11018:	d01c      	beq.n	11054 <m_prov_adv_trans_sent+0xa8>
        {
            // Critical issue here PB-ADV not available - trigger an error
            // Consider Bearer as closed
            M_PRINTF(L_PROV, "");
   1101a:	6833      	ldr	r3, [r6, #0]
   1101c:	071b      	lsls	r3, r3, #28
   1101e:	d515      	bpl.n	1104c <m_prov_adv_trans_sent+0xa0>
   11020:	4c14      	ldr	r4, [pc, #80]	; (11074 <m_prov_adv_trans_sent+0xc8>)
   11022:	4b13      	ldr	r3, [pc, #76]	; (11070 <m_prov_adv_trans_sent+0xc4>)
   11024:	0022      	movs	r2, r4
   11026:	0020      	movs	r0, r4
   11028:	4d13      	ldr	r5, [pc, #76]	; (11078 <m_prov_adv_trans_sent+0xcc>)
   1102a:	336d      	adds	r3, #109	; 0x6d
   1102c:	0029      	movs	r1, r5
   1102e:	3222      	adds	r2, #34	; 0x22
   11030:	9300      	str	r3, [sp, #0]
   11032:	3035      	adds	r0, #53	; 0x35
   11034:	4b12      	ldr	r3, [pc, #72]	; (11080 <m_prov_adv_trans_sent+0xd4>)
   11036:	f7f3 fcb9 	bl	49ac <m_print>
   1103a:	0020      	movs	r0, r4
   1103c:	305c      	adds	r0, #92	; 0x5c
   1103e:	f7f3 fcb5 	bl	49ac <m_print>
   11042:	0020      	movs	r0, r4
   11044:	1da9      	adds	r1, r5, #6
   11046:	305d      	adds	r0, #93	; 0x5d
   11048:	f7f3 fcb0 	bl	49ac <m_print>
            m_prov_link_closed(M_PROV_BEARER_CLOSED);
   1104c:	20fe      	movs	r0, #254	; 0xfe
   1104e:	f7ff f8bd 	bl	101cc <m_prov_link_closed>
   11052:	e008      	b.n	11066 <m_prov_adv_trans_sent+0xba>
        }

        // check if something need to be transmitted
        else if(   GETB(p_adv_res->link_info, M_PROV_SEND_ACK)
   11054:	2330      	movs	r3, #48	; 0x30
   11056:	8d22      	ldrh	r2, [r4, #40]	; 0x28
   11058:	421a      	tst	r2, r3
   1105a:	d102      	bne.n	11062 <m_prov_adv_trans_sent+0xb6>
                || GETB(p_adv_res->link_info, M_PROV_SEND_LINK_CLOSE)
                || !co_list_is_empty(&(p_adv_res->tx_queue)))
   1105c:	6963      	ldr	r3, [r4, #20]
   1105e:	2b00      	cmp	r3, #0
   11060:	d001      	beq.n	11066 <m_prov_adv_trans_sent+0xba>
        {
            // if yes force next transmission
            m_prov_adv_trans_tx_set();
   11062:	f7ff f9bd 	bl	103e0 <m_prov_adv_trans_tx_set>
        }
    }
}
   11066:	b005      	add	sp, #20
   11068:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1106a:	46c0      	nop			; (mov r8, r8)
   1106c:	10010514 	.word	0x10010514
   11070:	00022543 	.word	0x00022543
   11074:	000223c3 	.word	0x000223c3
   11078:	000222c3 	.word	0x000222c3
   1107c:	100128a4 	.word	0x100128a4
   11080:	00000385 	.word	0x00000385

00011084 <m_prov_adv_trans_rx_check>:
 *
 * @param[in] p_adv_res Advertising Link resources
 ****************************************************************************************
 */
__STATIC void m_prov_adv_trans_rx_check(m_prov_adv_res_t* p_adv_res)
{
   11084:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    m_tb_buf_t*       p_buf     = p_adv_res->p_rx_buf;
   11086:	6a44      	ldr	r4, [r0, #36]	; 0x24
 *
 * @param[in] p_adv_res Advertising Link resources
 ****************************************************************************************
 */
__STATIC void m_prov_adv_trans_rx_check(m_prov_adv_res_t* p_adv_res)
{
   11088:	0005      	movs	r5, r0
    m_tb_buf_t*       p_buf     = p_adv_res->p_rx_buf;
    m_prov_buf_env_t* p_buf_env = (m_prov_buf_env_t*) p_buf->env;

    // check that all segment has been received
    if(p_buf_env->seg_mask == 0)
   1108a:	7ca3      	ldrb	r3, [r4, #18]
   1108c:	2b00      	cmp	r3, #0
   1108e:	d130      	bne.n	110f2 <m_prov_adv_trans_rx_check+0x6e>
    {
        // Check that FCS is ok
        uint8_t comp_fcs = m_prov_adv_trans_fcs_compute(p_buf_env->pdu_type, p_buf->data_len, M_TB_BUF_DATA(p_buf));
   11090:	0023      	movs	r3, r4
   11092:	88a0      	ldrh	r0, [r4, #4]
   11094:	3330      	adds	r3, #48	; 0x30
   11096:	1818      	adds	r0, r3, r0
 * @return Computed Frame Check Sequence value
 ****************************************************************************************
 */
__STATIC uint8_t m_prov_adv_trans_fcs_compute(uint8_t opcode, uint16_t data_len, uint8_t* data)
{
    uint8_t fcs = m_prov_adv_crctable[0xFF ^ opcode];
   11098:	7c23      	ldrb	r3, [r4, #16]
   1109a:	4a16      	ldr	r2, [pc, #88]	; (110f4 <m_prov_adv_trans_rx_check+0x70>)
   1109c:	43db      	mvns	r3, r3
   1109e:	3209      	adds	r2, #9
   110a0:	b2db      	uxtb	r3, r3

    // check that all segment has been received
    if(p_buf_env->seg_mask == 0)
    {
        // Check that FCS is ok
        uint8_t comp_fcs = m_prov_adv_trans_fcs_compute(p_buf_env->pdu_type, p_buf->data_len, M_TB_BUF_DATA(p_buf));
   110a2:	8921      	ldrh	r1, [r4, #8]
 * @return Computed Frame Check Sequence value
 ****************************************************************************************
 */
__STATIC uint8_t m_prov_adv_trans_fcs_compute(uint8_t opcode, uint16_t data_len, uint8_t* data)
{
    uint8_t fcs = m_prov_adv_crctable[0xFF ^ opcode];
   110a4:	5cd3      	ldrb	r3, [r2, r3]

    // use CRC table to perform (X^8 + X^2 + X^1 + 1)
    while(data_len--)
   110a6:	4f14      	ldr	r7, [pc, #80]	; (110f8 <m_prov_adv_trans_rx_check+0x74>)
   110a8:	3901      	subs	r1, #1
   110aa:	b289      	uxth	r1, r1
   110ac:	42b9      	cmp	r1, r7
   110ae:	d004      	beq.n	110ba <m_prov_adv_trans_rx_check+0x36>
    {
        fcs = m_prov_adv_crctable[fcs ^ *data];
   110b0:	7806      	ldrb	r6, [r0, #0]
        data++;
   110b2:	3001      	adds	r0, #1
    uint8_t fcs = m_prov_adv_crctable[0xFF ^ opcode];

    // use CRC table to perform (X^8 + X^2 + X^1 + 1)
    while(data_len--)
    {
        fcs = m_prov_adv_crctable[fcs ^ *data];
   110b4:	4073      	eors	r3, r6
   110b6:	5cd3      	ldrb	r3, [r2, r3]
   110b8:	e7f6      	b.n	110a8 <m_prov_adv_trans_rx_check+0x24>
    if(p_buf_env->seg_mask == 0)
    {
        // Check that FCS is ok
        uint8_t comp_fcs = m_prov_adv_trans_fcs_compute(p_buf_env->pdu_type, p_buf->data_len, M_TB_BUF_DATA(p_buf));

        if(comp_fcs == p_buf_env->fcs)
   110ba:	43db      	mvns	r3, r3
   110bc:	7c61      	ldrb	r1, [r4, #17]
   110be:	b2db      	uxtb	r3, r3
   110c0:	8d2a      	ldrh	r2, [r5, #40]	; 0x28
   110c2:	4299      	cmp	r1, r3
   110c4:	d10d      	bne.n	110e2 <m_prov_adv_trans_rx_check+0x5e>
        {
            // Reception is ok
            SETB(p_adv_res->link_info, M_PROV_RX_OK,  true);
            // Mark that Link ACK message must be sent
            SETB(p_adv_res->link_info, M_PROV_SEND_ACK, true);
   110c6:	2318      	movs	r3, #24
   110c8:	431a      	orrs	r2, r3
   110ca:	852a      	strh	r2, [r5, #40]	; 0x28
            // update next expected packet
            p_adv_res->rx_trans_cursor += 1;
   110cc:	002a      	movs	r2, r5
   110ce:	322b      	adds	r2, #43	; 0x2b
   110d0:	7813      	ldrb	r3, [r2, #0]
   110d2:	3301      	adds	r3, #1
   110d4:	7013      	strb	r3, [r2, #0]

            // Mark that something must be sent
            m_prov_adv_trans_tx_set();
   110d6:	f7ff f983 	bl	103e0 <m_prov_adv_trans_tx_set>

            // inform provisioning that payload has been received
            m_prov_pdu_rx(p_buf);
   110da:	0020      	movs	r0, r4
   110dc:	f7ff f91a 	bl	10314 <m_prov_pdu_rx>
   110e0:	e002      	b.n	110e8 <m_prov_adv_trans_rx_check+0x64>
        }
        else
        {
            SETB(p_adv_res->link_info, M_PROV_RX_OK,  false);
   110e2:	2308      	movs	r3, #8
   110e4:	439a      	bics	r2, r3
   110e6:	852a      	strh	r2, [r5, #40]	; 0x28
        }

        m_tb_buf_release(p_buf);
   110e8:	0020      	movs	r0, r4
   110ea:	f000 fad7 	bl	1169c <m_tb_buf_release>
        p_adv_res->p_rx_buf = NULL;
   110ee:	2300      	movs	r3, #0
   110f0:	626b      	str	r3, [r5, #36]	; 0x24
    }
}
   110f2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   110f4:	000222c3 	.word	0x000222c3
   110f8:	0000ffff 	.word	0x0000ffff

000110fc <m_prov_bearer_rx_cb>:
 * @param[in] p_buf             Pointer to the buffer containing the received PDU.
 ****************************************************************************************
 */
__STATIC void m_prov_bearer_rx_cb(m_tb_buf_t *p_buf)
{
	m_printf_hex(L_PROV, "recv prov data", M_TB_BUF_DATA(p_buf), p_buf->data_len);
   110fc:	0001      	movs	r1, r0
 *
 * @param[in] p_buf             Pointer to the buffer containing the received PDU.
 ****************************************************************************************
 */
__STATIC void m_prov_bearer_rx_cb(m_tb_buf_t *p_buf)
{
   110fe:	b510      	push	{r4, lr}
	m_printf_hex(L_PROV, "recv prov data", M_TB_BUF_DATA(p_buf), p_buf->data_len);
   11100:	8882      	ldrh	r2, [r0, #4]
   11102:	3130      	adds	r1, #48	; 0x30
   11104:	188a      	adds	r2, r1, r2
   11106:	490a      	ldr	r1, [pc, #40]	; (11130 <m_prov_bearer_rx_cb+0x34>)
   11108:	8903      	ldrh	r3, [r0, #8]
 *
 * @param[in] p_buf             Pointer to the buffer containing the received PDU.
 ****************************************************************************************
 */
__STATIC void m_prov_bearer_rx_cb(m_tb_buf_t *p_buf)
{
   1110a:	0004      	movs	r4, r0
	m_printf_hex(L_PROV, "recv prov data", M_TB_BUF_DATA(p_buf), p_buf->data_len);
   1110c:	3109      	adds	r1, #9
   1110e:	2008      	movs	r0, #8
   11110:	f7f3 fcac 	bl	4a6c <m_printf_hex>
    // Check that provisioning is stated
    if(p_m_prov_env->p_res != NULL)
   11114:	4b07      	ldr	r3, [pc, #28]	; (11134 <m_prov_bearer_rx_cb+0x38>)
   11116:	681b      	ldr	r3, [r3, #0]
   11118:	685a      	ldr	r2, [r3, #4]
   1111a:	2a00      	cmp	r2, #0
   1111c:	d006      	beq.n	1112c <m_prov_bearer_rx_cb+0x30>
    {
        m_lay_bearer_buf_env_t* p_buf_env = (m_lay_bearer_buf_env_t *) p_buf->env;

        // let the advertising transport to handle the message
        if (p_buf_env->bearer_lid == p_m_prov_env->adv_bearer_lid)
   1111e:	7c62      	ldrb	r2, [r4, #17]
   11120:	7c9b      	ldrb	r3, [r3, #18]
   11122:	429a      	cmp	r2, r3
   11124:	d102      	bne.n	1112c <m_prov_bearer_rx_cb+0x30>
        {
            m_prov_adv_trans_rx(p_buf);
   11126:	0020      	movs	r0, r4
   11128:	f7ff fc58 	bl	109dc <m_prov_adv_trans_rx>
        else
        {
            /* Nothing to do - Ignore it*/
        }
    }
}
   1112c:	bd10      	pop	{r4, pc}
   1112e:	46c0      	nop			; (mov r8, r8)
   11130:	000225c8 	.word	0x000225c8
   11134:	100128a4 	.word	0x100128a4

00011138 <m_prov_bearer_sent_cb>:
 * @param[in] p_buf             Pointer to the buffer containing the sent PDU.
 * @param[in] status            Transmission status.
 ****************************************************************************************
 */
__STATIC void m_prov_bearer_sent_cb(m_tb_buf_t *p_buf, uint16_t status)
{
   11138:	b510      	push	{r4, lr}
    m_lay_bearer_buf_env_t *p_buf_env = (m_lay_bearer_buf_env_t *)p_buf->env;

    // let the advertising transport to handle the message
    if (p_buf_env->bearer_lid == p_m_prov_env->adv_bearer_lid)
   1113a:	4b04      	ldr	r3, [pc, #16]	; (1114c <m_prov_bearer_sent_cb+0x14>)
   1113c:	7c42      	ldrb	r2, [r0, #17]
   1113e:	681b      	ldr	r3, [r3, #0]
   11140:	7c9b      	ldrb	r3, [r3, #18]
   11142:	429a      	cmp	r2, r3
   11144:	d101      	bne.n	1114a <m_prov_bearer_sent_cb+0x12>
    {
        m_prov_adv_trans_sent(p_buf, status);
   11146:	f7ff ff31 	bl	10fac <m_prov_adv_trans_sent>
    else
    {
        m_prov_pdu_sent(p_buf, status);
    }
    #endif // (BLE_MESH_GATT_PROV)
}
   1114a:	bd10      	pop	{r4, pc}
   1114c:	100128a4 	.word	0x100128a4

00011150 <m_prov_bearer_opened_cb>:
 ****************************************************************************************
 */
__STATIC void m_prov_bearer_opened_cb(uint8_t bearer_lid, uint8_t type)
{
    // Register advertising bearer
    switch(type)
   11150:	2900      	cmp	r1, #0
   11152:	d105      	bne.n	11160 <m_prov_bearer_opened_cb+0x10>
    {
        case M_BEARER_TYPE_ADV:
        {
            ASSERT_INFO((p_m_prov_env->adv_bearer_lid == M_INVALID_LID), bearer_lid, p_m_prov_env->adv_bearer_lid);
   11154:	4b03      	ldr	r3, [pc, #12]	; (11164 <m_prov_bearer_opened_cb+0x14>)
   11156:	681b      	ldr	r3, [r3, #0]
   11158:	7c9a      	ldrb	r2, [r3, #18]
   1115a:	2aff      	cmp	r2, #255	; 0xff
   1115c:	d1fd      	bne.n	1115a <m_prov_bearer_opened_cb+0xa>

            if(p_m_prov_env->adv_bearer_lid == M_INVALID_LID)
            {
                p_m_prov_env->adv_bearer_lid = bearer_lid;
   1115e:	7498      	strb	r0, [r3, #18]
        } break;
        #endif // (BLE_MESH_GATT_PROV)

        default: { /* Nothing to do */ } break;
    }
}
   11160:	4770      	bx	lr
   11162:	46c0      	nop			; (mov r8, r8)
   11164:	100128a4 	.word	0x100128a4

00011168 <m_prov_bearer_closed_cb>:
 * @param[in] bearer_lid        Bearer LID.
 ****************************************************************************************
 */
__STATIC void m_prov_bearer_closed_cb(uint8_t bearer_lid)
{
	M_PRINTF(L_PROV, "");
   11168:	4b15      	ldr	r3, [pc, #84]	; (111c0 <m_prov_bearer_closed_cb+0x58>)
 *
 * @param[in] bearer_lid        Bearer LID.
 ****************************************************************************************
 */
__STATIC void m_prov_bearer_closed_cb(uint8_t bearer_lid)
{
   1116a:	b537      	push	{r0, r1, r2, r4, r5, lr}
	M_PRINTF(L_PROV, "");
   1116c:	681b      	ldr	r3, [r3, #0]
 *
 * @param[in] bearer_lid        Bearer LID.
 ****************************************************************************************
 */
__STATIC void m_prov_bearer_closed_cb(uint8_t bearer_lid)
{
   1116e:	0005      	movs	r5, r0
	M_PRINTF(L_PROV, "");
   11170:	071b      	lsls	r3, r3, #28
   11172:	d514      	bpl.n	1119e <m_prov_bearer_closed_cb+0x36>
   11174:	4c13      	ldr	r4, [pc, #76]	; (111c4 <m_prov_bearer_closed_cb+0x5c>)
   11176:	0023      	movs	r3, r4
   11178:	0022      	movs	r2, r4
   1117a:	0020      	movs	r0, r4
   1117c:	3350      	adds	r3, #80	; 0x50
   1117e:	0021      	movs	r1, r4
   11180:	3231      	adds	r2, #49	; 0x31
   11182:	9300      	str	r3, [sp, #0]
   11184:	3041      	adds	r0, #65	; 0x41
   11186:	23a0      	movs	r3, #160	; 0xa0
   11188:	f7f3 fc10 	bl	49ac <m_print>
   1118c:	0020      	movs	r0, r4
   1118e:	3068      	adds	r0, #104	; 0x68
   11190:	f7f3 fc0c 	bl	49ac <m_print>
   11194:	0020      	movs	r0, r4
   11196:	1da1      	adds	r1, r4, #6
   11198:	3069      	adds	r0, #105	; 0x69
   1119a:	f7f3 fc07 	bl	49ac <m_print>
    if(p_m_prov_env->bearer_lid == bearer_lid)
   1119e:	4b0a      	ldr	r3, [pc, #40]	; (111c8 <m_prov_bearer_closed_cb+0x60>)
   111a0:	681a      	ldr	r2, [r3, #0]
   111a2:	001c      	movs	r4, r3
   111a4:	7c52      	ldrb	r2, [r2, #17]
   111a6:	42aa      	cmp	r2, r5
   111a8:	d102      	bne.n	111b0 <m_prov_bearer_closed_cb+0x48>
    {
        // Inform that used bearer is closed
        m_prov_link_closed(M_PROV_BEARER_CLOSED);
   111aa:	20fe      	movs	r0, #254	; 0xfe
   111ac:	f7ff f80e 	bl	101cc <m_prov_link_closed>
    }

    // Unregister advertising bearer
    if(p_m_prov_env->adv_bearer_lid == bearer_lid)
   111b0:	6823      	ldr	r3, [r4, #0]
   111b2:	7c9a      	ldrb	r2, [r3, #18]
   111b4:	42aa      	cmp	r2, r5
   111b6:	d101      	bne.n	111bc <m_prov_bearer_closed_cb+0x54>
    {
        p_m_prov_env->adv_bearer_lid = M_INVALID_LID;
   111b8:	22ff      	movs	r2, #255	; 0xff
   111ba:	749a      	strb	r2, [r3, #18]
    }
}
   111bc:	bd37      	pop	{r0, r1, r2, r4, r5, pc}
   111be:	46c0      	nop			; (mov r8, r8)
   111c0:	10010514 	.word	0x10010514
   111c4:	000225c8 	.word	0x000225c8
   111c8:	100128a4 	.word	0x100128a4

000111cc <m_prov_bearer_connect_api>:
 ****************************************************************************************
 */

void m_prov_bearer_connect_api(const m_bearer_api_t *p_api)
{
    p_m_prov_env->p_bearer_api = p_api;
   111cc:	4b01      	ldr	r3, [pc, #4]	; (111d4 <m_prov_bearer_connect_api+0x8>)
   111ce:	681b      	ldr	r3, [r3, #0]
   111d0:	6018      	str	r0, [r3, #0]
}
   111d2:	4770      	bx	lr
   111d4:	100128a4 	.word	0x100128a4

000111d8 <m_prov_bearer_init>:

void m_prov_bearer_init(void)
{
   111d8:	b510      	push	{r4, lr}
 ****************************************************************************************
 */

void m_prov_bearer_connect_api(const m_bearer_api_t *p_api)
{
    p_m_prov_env->p_bearer_api = p_api;
   111da:	4b05      	ldr	r3, [pc, #20]	; (111f0 <m_prov_bearer_init+0x18>)
   111dc:	4a05      	ldr	r2, [pc, #20]	; (111f4 <m_prov_bearer_init+0x1c>)
   111de:	681b      	ldr	r3, [r3, #0]
void m_prov_bearer_init(void)
{
    // Connect provisioning layer to bearer layer API functions
    m_prov_bearer_connect_api(&m_bearer_api);
    // Connect bearer layer to Provisioning layer CB functions
    m_bearer_connect_client_cb(M_BEARER_CLI_PROV, &m_prov_bearer_cb);
   111e0:	4905      	ldr	r1, [pc, #20]	; (111f8 <m_prov_bearer_init+0x20>)
 ****************************************************************************************
 */

void m_prov_bearer_connect_api(const m_bearer_api_t *p_api)
{
    p_m_prov_env->p_bearer_api = p_api;
   111e2:	601a      	str	r2, [r3, #0]
void m_prov_bearer_init(void)
{
    // Connect provisioning layer to bearer layer API functions
    m_prov_bearer_connect_api(&m_bearer_api);
    // Connect bearer layer to Provisioning layer CB functions
    m_bearer_connect_client_cb(M_BEARER_CLI_PROV, &m_prov_bearer_cb);
   111e4:	316c      	adds	r1, #108	; 0x6c
   111e6:	2001      	movs	r0, #1
   111e8:	f7f8 fe16 	bl	9e18 <m_bearer_connect_client_cb>
}
   111ec:	bd10      	pop	{r4, pc}
   111ee:	46c0      	nop			; (mov r8, r8)
   111f0:	100128a4 	.word	0x100128a4
   111f4:	000214e8 	.word	0x000214e8
   111f8:	000225c8 	.word	0x000225c8

000111fc <m_prov_bearer_send>:

uint16_t m_prov_bearer_send(m_tb_buf_t *p_buf)
{
   111fc:	b510      	push	{r4, lr}
    uint16_t status = M_ERR_COMMAND_DISALLOWED;

    if(p_m_prov_env->bearer_lid != M_INVALID_LID)
   111fe:	4b09      	ldr	r3, [pc, #36]	; (11224 <m_prov_bearer_send+0x28>)
    // Connect bearer layer to Provisioning layer CB functions
    m_bearer_connect_client_cb(M_BEARER_CLI_PROV, &m_prov_bearer_cb);
}

uint16_t m_prov_bearer_send(m_tb_buf_t *p_buf)
{
   11200:	0001      	movs	r1, r0
    uint16_t status = M_ERR_COMMAND_DISALLOWED;

    if(p_m_prov_env->bearer_lid != M_INVALID_LID)
   11202:	681b      	ldr	r3, [r3, #0]
   11204:	7c5a      	ldrb	r2, [r3, #17]
   11206:	2aff      	cmp	r2, #255	; 0xff
   11208:	d009      	beq.n	1121e <m_prov_bearer_send+0x22>
    {
        m_lay_bearer_buf_env_t *p_buf_env = (m_lay_bearer_buf_env_t *)p_buf->env;

        p_buf_env->flags = 0;
   1120a:	2200      	movs	r2, #0
   1120c:	7402      	strb	r2, [r0, #16]
        p_buf_env->msg_type   = M_BEARER_MSG_PROV;
   1120e:	2001      	movs	r0, #1
   11210:	7488      	strb	r0, [r1, #18]
        p_buf_env->bearer_lid = p_m_prov_env->bearer_lid;
   11212:	7c5a      	ldrb	r2, [r3, #17]
   11214:	744a      	strb	r2, [r1, #17]

        status = p_m_prov_env->p_bearer_api->send(M_BEARER_CLI_PROV, p_buf);
   11216:	681b      	ldr	r3, [r3, #0]
   11218:	681b      	ldr	r3, [r3, #0]
   1121a:	4798      	blx	r3
   1121c:	e000      	b.n	11220 <m_prov_bearer_send+0x24>
    m_bearer_connect_client_cb(M_BEARER_CLI_PROV, &m_prov_bearer_cb);
}

uint16_t m_prov_bearer_send(m_tb_buf_t *p_buf)
{
    uint16_t status = M_ERR_COMMAND_DISALLOWED;
   1121e:	4802      	ldr	r0, [pc, #8]	; (11228 <m_prov_bearer_send+0x2c>)

        status = p_m_prov_env->p_bearer_api->send(M_BEARER_CLI_PROV, p_buf);
    }

    return  (status);
}
   11220:	bd10      	pop	{r4, pc}
   11222:	46c0      	nop			; (mov r8, r8)
   11224:	100128a4 	.word	0x100128a4
   11228:	00000282 	.word	0x00000282

0001122c <m_prov_bearer_close>:

void m_prov_bearer_close(uint8_t reason)
{
   1122c:	b510      	push	{r4, lr}
    switch (p_m_prov_env->bearer_type)
   1122e:	4b04      	ldr	r3, [pc, #16]	; (11240 <m_prov_bearer_close+0x14>)
   11230:	681b      	ldr	r3, [r3, #0]
   11232:	7c1b      	ldrb	r3, [r3, #16]
   11234:	2b01      	cmp	r3, #1
   11236:	d102      	bne.n	1123e <m_prov_bearer_close+0x12>
    {
        case M_PROV_BEARER_ADV:
        {
            m_prov_adv_trans_link_close_send(reason);
   11238:	f7ff fbb6 	bl	109a8 <m_prov_adv_trans_link_close_send>
        default:
        {
            ASSERT_INFO(0, p_m_prov_env->bearer_type, reason);
        } break;
    }
}
   1123c:	bd10      	pop	{r4, pc}
   1123e:	e7fe      	b.n	1123e <m_prov_bearer_close+0x12>
   11240:	100128a4 	.word	0x100128a4

00011244 <m_tb_get_env_size>:
 ****************************************************************************************
 */


uint16_t m_tb_get_env_size(const m_cfg_t* p_cfg)
{
   11244:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   11246:	0007      	movs	r7, r0
    uint16_t    total_env_size = 0;

    // Retrieve size of environment variable required for following mesh toolbox modules
    total_env_size += CO_ALIGN4_HI(m_tb_sec_get_env_size(p_cfg));
   11248:	f002 fe78 	bl	13f3c <m_tb_sec_get_env_size>
   1124c:	0004      	movs	r4, r0
    total_env_size += CO_ALIGN4_HI(m_tb_key_get_env_size(p_cfg));
   1124e:	0038      	movs	r0, r7
   11250:	2503      	movs	r5, #3
   11252:	f000 fdb9 	bl	11dc8 <m_tb_key_get_env_size>
   11256:	3403      	adds	r4, #3
   11258:	1940      	adds	r0, r0, r5
   1125a:	43a8      	bics	r0, r5
   1125c:	43ac      	bics	r4, r5
   1125e:	1824      	adds	r4, r4, r0
    total_env_size += CO_ALIGN4_HI(m_tb_buf_get_env_size(p_cfg));
   11260:	0038      	movs	r0, r7
   11262:	f000 f8db 	bl	1141c <m_tb_buf_get_env_size>
   11266:	1946      	adds	r6, r0, r5
    total_env_size += CO_ALIGN4_HI(m_tb_timer_get_env_size(p_cfg));
   11268:	0038      	movs	r0, r7
   1126a:	f004 f849 	bl	15300 <m_tb_timer_get_env_size>
    uint16_t    total_env_size = 0;

    // Retrieve size of environment variable required for following mesh toolbox modules
    total_env_size += CO_ALIGN4_HI(m_tb_sec_get_env_size(p_cfg));
    total_env_size += CO_ALIGN4_HI(m_tb_key_get_env_size(p_cfg));
    total_env_size += CO_ALIGN4_HI(m_tb_buf_get_env_size(p_cfg));
   1126e:	43ae      	bics	r6, r5
{
    uint16_t    total_env_size = 0;

    // Retrieve size of environment variable required for following mesh toolbox modules
    total_env_size += CO_ALIGN4_HI(m_tb_sec_get_env_size(p_cfg));
    total_env_size += CO_ALIGN4_HI(m_tb_key_get_env_size(p_cfg));
   11270:	b2a4      	uxth	r4, r4
    total_env_size += CO_ALIGN4_HI(m_tb_buf_get_env_size(p_cfg));
   11272:	19a4      	adds	r4, r4, r6
   11274:	b2a6      	uxth	r6, r4
    total_env_size += CO_ALIGN4_HI(m_tb_timer_get_env_size(p_cfg));
   11276:	1944      	adds	r4, r0, r5
    total_env_size += CO_ALIGN4_HI(m_tb_mio_get_env_size(p_cfg));
   11278:	0038      	movs	r0, r7
   1127a:	f001 ff71 	bl	13160 <m_tb_mio_get_env_size>

    // Retrieve size of environment variable required for following mesh toolbox modules
    total_env_size += CO_ALIGN4_HI(m_tb_sec_get_env_size(p_cfg));
    total_env_size += CO_ALIGN4_HI(m_tb_key_get_env_size(p_cfg));
    total_env_size += CO_ALIGN4_HI(m_tb_buf_get_env_size(p_cfg));
    total_env_size += CO_ALIGN4_HI(m_tb_timer_get_env_size(p_cfg));
   1127e:	43ac      	bics	r4, r5
   11280:	1936      	adds	r6, r6, r4
   11282:	b2b4      	uxth	r4, r6
    total_env_size += CO_ALIGN4_HI(m_tb_mio_get_env_size(p_cfg));
   11284:	1946      	adds	r6, r0, r5
    total_env_size += CO_ALIGN4_HI(m_tb_state_get_env_size(p_cfg));
   11286:	0038      	movs	r0, r7
   11288:	f002 ff22 	bl	140d0 <m_tb_state_get_env_size>
    // Retrieve size of environment variable required for following mesh toolbox modules
    total_env_size += CO_ALIGN4_HI(m_tb_sec_get_env_size(p_cfg));
    total_env_size += CO_ALIGN4_HI(m_tb_key_get_env_size(p_cfg));
    total_env_size += CO_ALIGN4_HI(m_tb_buf_get_env_size(p_cfg));
    total_env_size += CO_ALIGN4_HI(m_tb_timer_get_env_size(p_cfg));
    total_env_size += CO_ALIGN4_HI(m_tb_mio_get_env_size(p_cfg));
   1128c:	43ae      	bics	r6, r5
   1128e:	19a4      	adds	r4, r4, r6
   11290:	b2a6      	uxth	r6, r4
    total_env_size += CO_ALIGN4_HI(m_tb_state_get_env_size(p_cfg));
   11292:	1944      	adds	r4, r0, r5
    total_env_size += CO_ALIGN4_HI(m_tb_store_get_env_size(p_cfg));
   11294:	0038      	movs	r0, r7
   11296:	f003 fbe5 	bl	14a64 <m_tb_store_get_env_size>
    total_env_size += CO_ALIGN4_HI(m_tb_sec_get_env_size(p_cfg));
    total_env_size += CO_ALIGN4_HI(m_tb_key_get_env_size(p_cfg));
    total_env_size += CO_ALIGN4_HI(m_tb_buf_get_env_size(p_cfg));
    total_env_size += CO_ALIGN4_HI(m_tb_timer_get_env_size(p_cfg));
    total_env_size += CO_ALIGN4_HI(m_tb_mio_get_env_size(p_cfg));
    total_env_size += CO_ALIGN4_HI(m_tb_state_get_env_size(p_cfg));
   1129a:	43ac      	bics	r4, r5
   1129c:	1936      	adds	r6, r6, r4
    total_env_size += CO_ALIGN4_HI(m_tb_store_get_env_size(p_cfg));
    #if (BLE_MESH_FRIEND)
    total_env_size += CO_ALIGN4_HI(m_tb_friend_get_env_size(p_cfg));
    #endif //(BLE_MESH_FRIEND)

    return total_env_size;
   1129e:	1940      	adds	r0, r0, r5
    total_env_size += CO_ALIGN4_HI(m_tb_sec_get_env_size(p_cfg));
    total_env_size += CO_ALIGN4_HI(m_tb_key_get_env_size(p_cfg));
    total_env_size += CO_ALIGN4_HI(m_tb_buf_get_env_size(p_cfg));
    total_env_size += CO_ALIGN4_HI(m_tb_timer_get_env_size(p_cfg));
    total_env_size += CO_ALIGN4_HI(m_tb_mio_get_env_size(p_cfg));
    total_env_size += CO_ALIGN4_HI(m_tb_state_get_env_size(p_cfg));
   112a0:	b2b4      	uxth	r4, r6
    total_env_size += CO_ALIGN4_HI(m_tb_store_get_env_size(p_cfg));
    #if (BLE_MESH_FRIEND)
    total_env_size += CO_ALIGN4_HI(m_tb_friend_get_env_size(p_cfg));
    #endif //(BLE_MESH_FRIEND)

    return total_env_size;
   112a2:	43a8      	bics	r0, r5
   112a4:	1820      	adds	r0, r4, r0
   112a6:	b280      	uxth	r0, r0
}
   112a8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

000112aa <m_tb_init>:

uint16_t m_tb_init(bool reset, void* p_env, const m_cfg_t* p_cfg)
{
   112aa:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   112ac:	0005      	movs	r5, r0
   112ae:	0016      	movs	r6, r2
   112b0:	000f      	movs	r7, r1
    // Stack initialization
    uint8_t* p_env_cursor = (uint8_t*) p_env;

    p_env_cursor += CO_ALIGN4_HI(m_tb_sec_init(reset, (void*) p_env_cursor, p_cfg));
   112b2:	f002 fe45 	bl	13f40 <m_tb_sec_init>
   112b6:	2403      	movs	r4, #3
   112b8:	3003      	adds	r0, #3
   112ba:	43a0      	bics	r0, r4
   112bc:	183b      	adds	r3, r7, r0
    p_env_cursor += CO_ALIGN4_HI(m_tb_key_init(reset, (void*) p_env_cursor, p_cfg));
   112be:	0032      	movs	r2, r6
   112c0:	0019      	movs	r1, r3
   112c2:	0028      	movs	r0, r5
uint16_t m_tb_init(bool reset, void* p_env, const m_cfg_t* p_cfg)
{
    // Stack initialization
    uint8_t* p_env_cursor = (uint8_t*) p_env;

    p_env_cursor += CO_ALIGN4_HI(m_tb_sec_init(reset, (void*) p_env_cursor, p_cfg));
   112c4:	9301      	str	r3, [sp, #4]
    p_env_cursor += CO_ALIGN4_HI(m_tb_key_init(reset, (void*) p_env_cursor, p_cfg));
   112c6:	f000 fd47 	bl	11d58 <m_tb_key_init>
   112ca:	9b01      	ldr	r3, [sp, #4]
   112cc:	1900      	adds	r0, r0, r4
   112ce:	43a0      	bics	r0, r4
   112d0:	181b      	adds	r3, r3, r0
    p_env_cursor += CO_ALIGN4_HI(m_tb_buf_init(reset, (void*) p_env_cursor, p_cfg));
   112d2:	0032      	movs	r2, r6
   112d4:	0019      	movs	r1, r3
   112d6:	0028      	movs	r0, r5
{
    // Stack initialization
    uint8_t* p_env_cursor = (uint8_t*) p_env;

    p_env_cursor += CO_ALIGN4_HI(m_tb_sec_init(reset, (void*) p_env_cursor, p_cfg));
    p_env_cursor += CO_ALIGN4_HI(m_tb_key_init(reset, (void*) p_env_cursor, p_cfg));
   112d8:	9301      	str	r3, [sp, #4]
    p_env_cursor += CO_ALIGN4_HI(m_tb_buf_init(reset, (void*) p_env_cursor, p_cfg));
   112da:	f000 f867 	bl	113ac <m_tb_buf_init>
   112de:	9b01      	ldr	r3, [sp, #4]
   112e0:	1900      	adds	r0, r0, r4
   112e2:	43a0      	bics	r0, r4
   112e4:	181b      	adds	r3, r3, r0
    p_env_cursor += CO_ALIGN4_HI(m_tb_timer_init(reset, (void*) p_env_cursor, p_cfg));
   112e6:	0032      	movs	r2, r6
   112e8:	0019      	movs	r1, r3
   112ea:	0028      	movs	r0, r5
    // Stack initialization
    uint8_t* p_env_cursor = (uint8_t*) p_env;

    p_env_cursor += CO_ALIGN4_HI(m_tb_sec_init(reset, (void*) p_env_cursor, p_cfg));
    p_env_cursor += CO_ALIGN4_HI(m_tb_key_init(reset, (void*) p_env_cursor, p_cfg));
    p_env_cursor += CO_ALIGN4_HI(m_tb_buf_init(reset, (void*) p_env_cursor, p_cfg));
   112ec:	9301      	str	r3, [sp, #4]
    p_env_cursor += CO_ALIGN4_HI(m_tb_timer_init(reset, (void*) p_env_cursor, p_cfg));
   112ee:	f003 fff7 	bl	152e0 <m_tb_timer_init>
   112f2:	9b01      	ldr	r3, [sp, #4]
   112f4:	1900      	adds	r0, r0, r4
   112f6:	43a0      	bics	r0, r4
   112f8:	181b      	adds	r3, r3, r0
    p_env_cursor += CO_ALIGN4_HI(m_tb_mio_init(reset, (void*) p_env_cursor, p_cfg));
   112fa:	0032      	movs	r2, r6
   112fc:	0019      	movs	r1, r3
   112fe:	0028      	movs	r0, r5
    uint8_t* p_env_cursor = (uint8_t*) p_env;

    p_env_cursor += CO_ALIGN4_HI(m_tb_sec_init(reset, (void*) p_env_cursor, p_cfg));
    p_env_cursor += CO_ALIGN4_HI(m_tb_key_init(reset, (void*) p_env_cursor, p_cfg));
    p_env_cursor += CO_ALIGN4_HI(m_tb_buf_init(reset, (void*) p_env_cursor, p_cfg));
    p_env_cursor += CO_ALIGN4_HI(m_tb_timer_init(reset, (void*) p_env_cursor, p_cfg));
   11300:	9301      	str	r3, [sp, #4]
    p_env_cursor += CO_ALIGN4_HI(m_tb_mio_init(reset, (void*) p_env_cursor, p_cfg));
   11302:	f001 ff13 	bl	1312c <m_tb_mio_init>
   11306:	9b01      	ldr	r3, [sp, #4]
   11308:	1900      	adds	r0, r0, r4
   1130a:	43a0      	bics	r0, r4
   1130c:	181b      	adds	r3, r3, r0
    p_env_cursor += CO_ALIGN4_HI(m_tb_state_init(reset, (void*) p_env_cursor, p_cfg));
   1130e:	0032      	movs	r2, r6
   11310:	0019      	movs	r1, r3
   11312:	0028      	movs	r0, r5

    p_env_cursor += CO_ALIGN4_HI(m_tb_sec_init(reset, (void*) p_env_cursor, p_cfg));
    p_env_cursor += CO_ALIGN4_HI(m_tb_key_init(reset, (void*) p_env_cursor, p_cfg));
    p_env_cursor += CO_ALIGN4_HI(m_tb_buf_init(reset, (void*) p_env_cursor, p_cfg));
    p_env_cursor += CO_ALIGN4_HI(m_tb_timer_init(reset, (void*) p_env_cursor, p_cfg));
    p_env_cursor += CO_ALIGN4_HI(m_tb_mio_init(reset, (void*) p_env_cursor, p_cfg));
   11314:	9301      	str	r3, [sp, #4]
    p_env_cursor += CO_ALIGN4_HI(m_tb_state_init(reset, (void*) p_env_cursor, p_cfg));
   11316:	f002 fe9b 	bl	14050 <m_tb_state_init>
   1131a:	9b01      	ldr	r3, [sp, #4]
   1131c:	1900      	adds	r0, r0, r4
   1131e:	43a0      	bics	r0, r4
   11320:	181b      	adds	r3, r3, r0
    p_env_cursor += CO_ALIGN4_HI(m_tb_store_init(reset, (void*) p_env_cursor, p_cfg));
   11322:	0032      	movs	r2, r6
   11324:	0019      	movs	r1, r3
   11326:	0028      	movs	r0, r5
    p_env_cursor += CO_ALIGN4_HI(m_tb_sec_init(reset, (void*) p_env_cursor, p_cfg));
    p_env_cursor += CO_ALIGN4_HI(m_tb_key_init(reset, (void*) p_env_cursor, p_cfg));
    p_env_cursor += CO_ALIGN4_HI(m_tb_buf_init(reset, (void*) p_env_cursor, p_cfg));
    p_env_cursor += CO_ALIGN4_HI(m_tb_timer_init(reset, (void*) p_env_cursor, p_cfg));
    p_env_cursor += CO_ALIGN4_HI(m_tb_mio_init(reset, (void*) p_env_cursor, p_cfg));
    p_env_cursor += CO_ALIGN4_HI(m_tb_state_init(reset, (void*) p_env_cursor, p_cfg));
   11328:	9301      	str	r3, [sp, #4]
    p_env_cursor += CO_ALIGN4_HI(m_tb_store_init(reset, (void*) p_env_cursor, p_cfg));
   1132a:	f003 fb8f 	bl	14a4c <m_tb_store_init>
    #if (BLE_MESH_FRIEND)
    p_env_cursor += CO_ALIGN4_HI(m_tb_friend_init(reset, (void*) p_env_cursor, p_cfg));
    #endif //(BLE_MESH_FRIEND)

    // Return size of te environment used
    return (((uint32_t) p_env_cursor) - ((uint32_t) p_env));
   1132e:	9b01      	ldr	r3, [sp, #4]
   11330:	1900      	adds	r0, r0, r4
   11332:	43a0      	bics	r0, r4
   11334:	1818      	adds	r0, r3, r0
   11336:	1bc0      	subs	r0, r0, r7
   11338:	b280      	uxth	r0, r0
}
   1133a:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}

0001133c <m_tb_buf_copy_data>:
 * @param[in] p_rd      Pointer to the data buffer from which data must be read
 * @param[in] len       Length of data to be copied
 ****************************************************************************************
 */
__STATIC void m_tb_buf_copy_data(uint32_t *p_wr, uint32_t *p_rd, uint32_t len)
{
   1133c:	b5f0      	push	{r4, r5, r6, r7, lr}
    uint32_t rem_len = len;
    // Counter
    uint8_t cnt;

    // Check if provided pointers are word aligned
    if ((((uint32_t)p_wr % 4) == 0) && (((uint32_t)p_rd % 4) == 0))
   1133e:	0004      	movs	r4, r0
   11340:	2303      	movs	r3, #3
   11342:	430c      	orrs	r4, r1
   11344:	4023      	ands	r3, r4
   11346:	d002      	beq.n	1134e <m_tb_buf_copy_data+0x12>
   11348:	000d      	movs	r5, r1
   1134a:	0006      	movs	r6, r0
   1134c:	e006      	b.n	1135c <m_tb_buf_copy_data+0x20>
    {
        while (rem_len >= 4)
   1134e:	1ad4      	subs	r4, r2, r3
   11350:	2c03      	cmp	r4, #3
   11352:	d91b      	bls.n	1138c <m_tb_buf_copy_data+0x50>
        {
            // Copy 4 bytes
            *p_wr = *p_rd;
   11354:	58cc      	ldr	r4, [r1, r3]
   11356:	50c4      	str	r4, [r0, r3]
   11358:	3304      	adds	r3, #4
   1135a:	e7f8      	b.n	1134e <m_tb_buf_copy_data+0x12>
   1135c:	1b53      	subs	r3, r2, r5
   1135e:	18cb      	adds	r3, r1, r3
            rem_len -= 4;
        }
    }
    else
    {
        while (rem_len >= 4)
   11360:	2b03      	cmp	r3, #3
   11362:	d913      	bls.n	1138c <m_tb_buf_copy_data+0x50>
__INLINE_S__ uint32_t co_read32p(void const *ptr32)
{
    uint16_t addr_l, addr_h;
    addr_l = co_read16p(ptr32);
    addr_h = co_read16p((uint8_t *)ptr32 + 2);
    return ((uint32_t)addr_l | (uint32_t)addr_h << 16);
   11364:	78eb      	ldrb	r3, [r5, #3]
   11366:	78af      	ldrb	r7, [r5, #2]
   11368:	021b      	lsls	r3, r3, #8
   1136a:	786c      	ldrb	r4, [r5, #1]
   1136c:	433b      	orrs	r3, r7
   1136e:	041f      	lsls	r7, r3, #16
   11370:	782b      	ldrb	r3, [r5, #0]
   11372:	0224      	lsls	r4, r4, #8
   11374:	4323      	orrs	r3, r4
   11376:	433b      	orrs	r3, r7
__INLINE_S__ void co_write32p(void const *ptr32, uint32_t value)
{
    uint8_t *ptr=(uint8_t*)ptr32;

    *ptr++ = (uint8_t)(value&0xff);
    *ptr++ = (uint8_t)((value&0xff00)>>8);
   11378:	0a1c      	lsrs	r4, r3, #8
 */
__INLINE_S__ void co_write32p(void const *ptr32, uint32_t value)
{
    uint8_t *ptr=(uint8_t*)ptr32;

    *ptr++ = (uint8_t)(value&0xff);
   1137a:	7033      	strb	r3, [r6, #0]
    *ptr++ = (uint8_t)((value&0xff00)>>8);
   1137c:	7074      	strb	r4, [r6, #1]
    *ptr++ = (uint8_t)((value&0xff0000)>>16);
   1137e:	0c1c      	lsrs	r4, r3, #16
    *ptr = (uint8_t)((value&0xff000000)>>24);
   11380:	0e1b      	lsrs	r3, r3, #24
{
    uint8_t *ptr=(uint8_t*)ptr32;

    *ptr++ = (uint8_t)(value&0xff);
    *ptr++ = (uint8_t)((value&0xff00)>>8);
    *ptr++ = (uint8_t)((value&0xff0000)>>16);
   11382:	70b4      	strb	r4, [r6, #2]
    *ptr = (uint8_t)((value&0xff000000)>>24);
   11384:	70f3      	strb	r3, [r6, #3]
            // Copy 4 bytes
            co_write32p(p_wr, co_read32p(p_rd));

            // Move pointers
            p_wr++;
            p_rd++;
   11386:	3504      	adds	r5, #4
        {
            // Copy 4 bytes
            co_write32p(p_wr, co_read32p(p_rd));

            // Move pointers
            p_wr++;
   11388:	3604      	adds	r6, #4
   1138a:	e7e7      	b.n	1135c <m_tb_buf_copy_data+0x20>
   1138c:	0893      	lsrs	r3, r2, #2
   1138e:	009b      	lsls	r3, r3, #2
   11390:	18c0      	adds	r0, r0, r3
   11392:	18c9      	adds	r1, r1, r3
   11394:	1ad2      	subs	r2, r2, r3
            rem_len -= 4;
        }
    }

    // Copy remaining bytes
    for (cnt = 0; cnt < rem_len; cnt++)
   11396:	25ff      	movs	r5, #255	; 0xff
   11398:	2300      	movs	r3, #0
   1139a:	001c      	movs	r4, r3
   1139c:	402c      	ands	r4, r5
   1139e:	42a2      	cmp	r2, r4
   113a0:	d903      	bls.n	113aa <m_tb_buf_copy_data+0x6e>
    {
        // Copy 1 byte
        *((uint8_t *)p_wr) = *((uint8_t *)p_rd);
   113a2:	5ccc      	ldrb	r4, [r1, r3]
   113a4:	54c4      	strb	r4, [r0, r3]
   113a6:	3301      	adds	r3, #1
   113a8:	e7f7      	b.n	1139a <m_tb_buf_copy_data+0x5e>

        // Move pointer
        p_wr = (uint32_t *)(((uint8_t *)p_wr) + 1);
        p_rd = (uint32_t *)(((uint8_t *)p_rd) + 1);
    }
}
   113aa:	bdf0      	pop	{r4, r5, r6, r7, pc}

000113ac <m_tb_buf_init>:
 * GLOBAL FUNCTIONS
 ****************************************************************************************
 */

uint16_t m_tb_buf_init(bool reset, void* p_env, const m_cfg_t* p_cfg)
{
   113ac:	b573      	push	{r0, r1, r4, r5, r6, lr}
   113ae:	2500      	movs	r5, #0
   113b0:	0006      	movs	r6, r0
   113b2:	4c19      	ldr	r4, [pc, #100]	; (11418 <m_tb_buf_init+0x6c>)
   113b4:	0008      	movs	r0, r1
    if (!reset)
   113b6:	42ae      	cmp	r6, r5
   113b8:	d114      	bne.n	113e4 <m_tb_buf_init+0x38>
    {
        // Block ID
        uint8_t block_id;

        // Get environment for Buffer Manager Toolbox
        p_m_tb_buf_env = (m_tb_buf_env_t *) p_env;
   113ba:	6021      	str	r1, [r4, #0]

        // Clear environment
        memset(p_m_tb_buf_env, 0, sizeof(m_tb_buf_env_t));
   113bc:	222c      	movs	r2, #44	; 0x2c
   113be:	0031      	movs	r1, r6
   113c0:	f004 fb44 	bl	15a4c <memset>

        // Allocate "small" buffers
        m_tb_buf_block_alloc(&block_id, M_TB_BUF_INIT_SMALL_NB, true);
   113c4:	466b      	mov	r3, sp
   113c6:	2201      	movs	r2, #1
   113c8:	210a      	movs	r1, #10
   113ca:	1dd8      	adds	r0, r3, #7
   113cc:	f000 f828 	bl	11420 <m_tb_buf_block_alloc>
        // Allocate "long" buffers
        m_tb_buf_block_alloc(&block_id, M_TB_BUF_INIT_LONG_NB, false);
   113d0:	466b      	mov	r3, sp
   113d2:	0032      	movs	r2, r6
   113d4:	2102      	movs	r1, #2
   113d6:	1dd8      	adds	r0, r3, #7
   113d8:	f000 f822 	bl	11420 <m_tb_buf_block_alloc>
   113dc:	e019      	b.n	11412 <m_tb_buf_init+0x66>
   113de:	3501      	adds	r5, #1
    {
        // Counter
        uint8_t cnt;

        // Free all allocated buffer blocks
        for (cnt = 0; cnt < M_TB_BUF_BLOCK_MAX; cnt++)
   113e0:	2d05      	cmp	r5, #5
   113e2:	d008      	beq.n	113f6 <m_tb_buf_init+0x4a>
        {
            // Get block
            m_tb_buf_block_t *p_block = p_m_tb_buf_env->p_buf_blocks[cnt];
   113e4:	1d2b      	adds	r3, r5, #4
   113e6:	6822      	ldr	r2, [r4, #0]
   113e8:	009b      	lsls	r3, r3, #2
   113ea:	5898      	ldr	r0, [r3, r2]

            if (p_block != NULL)
   113ec:	2800      	cmp	r0, #0
   113ee:	d0f6      	beq.n	113de <m_tb_buf_init+0x32>
            {
                m_al_free(p_block);
   113f0:	f7f4 f8f4 	bl	55dc <m_al_free>
   113f4:	e7f3      	b.n	113de <m_tb_buf_init+0x32>

        // Free dynamically allocated buffers
        for (cnt = 0; cnt < M_TB_BUF_DYN_MAX; cnt++)
        {
            // Get buffer
            m_tb_buf_t *p_buf = p_m_tb_buf_env->p_dyn_bufs[cnt];
   113f6:	6823      	ldr	r3, [r4, #0]
   113f8:	6a58      	ldr	r0, [r3, #36]	; 0x24

            if (p_buf != NULL)
   113fa:	2800      	cmp	r0, #0
   113fc:	d001      	beq.n	11402 <m_tb_buf_init+0x56>
            {
                m_al_free(p_buf);
   113fe:	f7f4 f8ed 	bl	55dc <m_al_free>

        // Free dynamically allocated buffers
        for (cnt = 0; cnt < M_TB_BUF_DYN_MAX; cnt++)
        {
            // Get buffer
            m_tb_buf_t *p_buf = p_m_tb_buf_env->p_dyn_bufs[cnt];
   11402:	6823      	ldr	r3, [r4, #0]
   11404:	6a98      	ldr	r0, [r3, #40]	; 0x28

            if (p_buf != NULL)
   11406:	2800      	cmp	r0, #0
   11408:	d001      	beq.n	1140e <m_tb_buf_init+0x62>
            {
                m_al_free(p_buf);
   1140a:	f7f4 f8e7 	bl	55dc <m_al_free>
            }
        }

        p_m_tb_buf_env = NULL;
   1140e:	2300      	movs	r3, #0
   11410:	6023      	str	r3, [r4, #0]
    }

    return (sizeof(m_tb_buf_env_t));
}
   11412:	202c      	movs	r0, #44	; 0x2c
   11414:	bd76      	pop	{r1, r2, r4, r5, r6, pc}
   11416:	46c0      	nop			; (mov r8, r8)
   11418:	100126bc 	.word	0x100126bc

0001141c <m_tb_buf_get_env_size>:

uint16_t m_tb_buf_get_env_size(const m_cfg_t* p_cfg)
{
    return (sizeof(m_tb_buf_env_t));
}
   1141c:	202c      	movs	r0, #44	; 0x2c
   1141e:	4770      	bx	lr

00011420 <m_tb_buf_block_alloc>:

uint16_t m_tb_buf_block_alloc(uint8_t *p_block_id, uint8_t nb_bufs, bool small)
{
   11420:	b5f0      	push	{r4, r5, r6, r7, lr}
   11422:	b085      	sub	sp, #20
   11424:	9002      	str	r0, [sp, #8]
   11426:	000d      	movs	r5, r1
   11428:	9201      	str	r2, [sp, #4]
    // Returned status
    uint16_t status = M_ERR_INSUFFICIENT_RESOURCES;
    // Counter
    uint8_t cnt;

    if (nb_bufs >= M_TB_BUF_BLOCK_BUF_MAX)
   1142a:	291f      	cmp	r1, #31
   1142c:	d845      	bhi.n	114ba <m_tb_buf_block_alloc+0x9a>
    {
        // Look for an available block ID
        for (cnt = 0; cnt < M_TB_BUF_BLOCK_MAX; cnt++)
        {
            // Get block
            m_tb_buf_block_t *p_block = p_m_tb_buf_env->p_buf_blocks[cnt];
   1142e:	2400      	movs	r4, #0
   11430:	4b24      	ldr	r3, [pc, #144]	; (114c4 <m_tb_buf_block_alloc+0xa4>)
   11432:	681a      	ldr	r2, [r3, #0]
   11434:	9303      	str	r3, [sp, #12]
   11436:	00a3      	lsls	r3, r4, #2
   11438:	18d3      	adds	r3, r2, r3

            if (p_block == NULL)
   1143a:	691b      	ldr	r3, [r3, #16]
   1143c:	b2e7      	uxtb	r7, r4
   1143e:	2b00      	cmp	r3, #0
   11440:	d137      	bne.n	114b2 <m_tb_buf_block_alloc+0x92>
            {
                // Compute size of a buffer
                uint32_t buf_size = sizeof(m_tb_buf_t) + ((small) ? M_TB_BUF_SMALL_SIZE : M_TB_BUF_LONG_SIZE);
   11442:	9b01      	ldr	r3, [sp, #4]
   11444:	2650      	movs	r6, #80	; 0x50
   11446:	2b00      	cmp	r3, #0
   11448:	d100      	bne.n	1144c <m_tb_buf_block_alloc+0x2c>
   1144a:	3678      	adds	r6, #120	; 0x78
                // Allocate a new block
                p_block = m_al_malloc(sizeof(m_tb_buf_block_t) + (nb_bufs * buf_size));
   1144c:	0028      	movs	r0, r5
   1144e:	4370      	muls	r0, r6
   11450:	3010      	adds	r0, #16
   11452:	b280      	uxth	r0, r0
   11454:	f7f4 f8bd 	bl	55d2 <m_al_malloc>
   11458:	1e01      	subs	r1, r0, #0

                if (p_block)
   1145a:	d102      	bne.n	11462 <m_tb_buf_block_alloc+0x42>
}

uint16_t m_tb_buf_block_alloc(uint8_t *p_block_id, uint8_t nb_bufs, bool small)
{
    // Returned status
    uint16_t status = M_ERR_INSUFFICIENT_RESOURCES;
   1145c:	20b0      	movs	r0, #176	; 0xb0
   1145e:	00c0      	lsls	r0, r0, #3
   11460:	e02d      	b.n	114be <m_tb_buf_block_alloc+0x9e>
                {
                    // Buffer counter
                    uint8_t buf_cnt;

                    // Keep block address
                    p_m_tb_buf_env->p_buf_blocks[cnt] = p_block;
   11462:	9b03      	ldr	r3, [sp, #12]
   11464:	3404      	adds	r4, #4
   11466:	6818      	ldr	r0, [r3, #0]

                    // Set block information
                    p_block->nb_bufs      = nb_bufs;
                    p_block->nb_bufs_free = nb_bufs;
                    p_block->ava_buf      = (uint32_t)(-1);
   11468:	2301      	movs	r3, #1
                {
                    // Buffer counter
                    uint8_t buf_cnt;

                    // Keep block address
                    p_m_tb_buf_env->p_buf_blocks[cnt] = p_block;
   1146a:	00a4      	lsls	r4, r4, #2

                    // Set block information
                    p_block->nb_bufs      = nb_bufs;
                    p_block->nb_bufs_free = nb_bufs;
                    p_block->ava_buf      = (uint32_t)(-1);
   1146c:	425b      	negs	r3, r3
                {
                    // Buffer counter
                    uint8_t buf_cnt;

                    // Keep block address
                    p_m_tb_buf_env->p_buf_blocks[cnt] = p_block;
   1146e:	5021      	str	r1, [r4, r0]
   11470:	000a      	movs	r2, r1

                    // Set block information
                    p_block->nb_bufs      = nb_bufs;
                    p_block->nb_bufs_free = nb_bufs;
                    p_block->ava_buf      = (uint32_t)(-1);
   11472:	604b      	str	r3, [r1, #4]
                    p_block->cb_released  = NULL;
   11474:	2300      	movs	r3, #0

                    // Keep block address
                    p_m_tb_buf_env->p_buf_blocks[cnt] = p_block;

                    // Set block information
                    p_block->nb_bufs      = nb_bufs;
   11476:	730d      	strb	r5, [r1, #12]
                    p_block->nb_bufs_free = nb_bufs;
   11478:	734d      	strb	r5, [r1, #13]
                    p_block->ava_buf      = (uint32_t)(-1);
                    p_block->cb_released  = NULL;
   1147a:	608b      	str	r3, [r1, #8]
                    p_block->status       = 0;
   1147c:	738b      	strb	r3, [r1, #14]
   1147e:	321c      	adds	r2, #28

                    // Set block ID and buffer ID in all buffers
                    for (buf_cnt = 0; buf_cnt < nb_bufs; buf_cnt++)
   11480:	429d      	cmp	r5, r3
   11482:	d005      	beq.n	11490 <m_tb_buf_block_alloc+0x70>
                    {
                        m_tb_buf_t *p_buf = (m_tb_buf_t *)((uint32_t)&p_block->bufs[0] + (buf_cnt * buf_size));

                        p_buf->block_id = cnt;
                        p_buf->buf_id = buf_cnt;
   11484:	7053      	strb	r3, [r2, #1]
                    p_block->ava_buf      = (uint32_t)(-1);
                    p_block->cb_released  = NULL;
                    p_block->status       = 0;

                    // Set block ID and buffer ID in all buffers
                    for (buf_cnt = 0; buf_cnt < nb_bufs; buf_cnt++)
   11486:	3301      	adds	r3, #1
                    {
                        m_tb_buf_t *p_buf = (m_tb_buf_t *)((uint32_t)&p_block->bufs[0] + (buf_cnt * buf_size));

                        p_buf->block_id = cnt;
   11488:	7017      	strb	r7, [r2, #0]
                    p_block->ava_buf      = (uint32_t)(-1);
                    p_block->cb_released  = NULL;
                    p_block->status       = 0;

                    // Set block ID and buffer ID in all buffers
                    for (buf_cnt = 0; buf_cnt < nb_bufs; buf_cnt++)
   1148a:	b2db      	uxtb	r3, r3
   1148c:	1992      	adds	r2, r2, r6
   1148e:	e7f7      	b.n	11480 <m_tb_buf_block_alloc+0x60>
                        #if (BLE_MESH_DBG)
                        p_buf->pattern = M_TB_BUF_DBG_PATTERN;
                        #endif //(BLE_MESH_DBG)
                    }

                    if (!small)
   11490:	9b01      	ldr	r3, [sp, #4]
   11492:	2b00      	cmp	r3, #0
   11494:	d107      	bne.n	114a6 <m_tb_buf_block_alloc+0x86>
                    {
                        SETB(p_block->status, M_TB_BUF_BLOCK_STATUS_LONG, 1);
   11496:	2202      	movs	r2, #2
   11498:	7b8b      	ldrb	r3, [r1, #14]

                        // Insert the block in the list of blocks
                        co_list_push_back(&p_m_tb_buf_env->list_free_long, &p_block->hdr);
   1149a:	3008      	adds	r0, #8
                        #endif //(BLE_MESH_DBG)
                    }

                    if (!small)
                    {
                        SETB(p_block->status, M_TB_BUF_BLOCK_STATUS_LONG, 1);
   1149c:	4313      	orrs	r3, r2
   1149e:	738b      	strb	r3, [r1, #14]

                        // Insert the block in the list of blocks
                        co_list_push_back(&p_m_tb_buf_env->list_free_long, &p_block->hdr);
   114a0:	f7f2 ff79 	bl	4396 <co_list_push_back>
   114a4:	e001      	b.n	114aa <m_tb_buf_block_alloc+0x8a>
                    }
                    else
                    {
                        // Insert the block in the list of blocks
                        co_list_push_back(&p_m_tb_buf_env->list_free_small, &p_block->hdr);
   114a6:	f7f2 ff76 	bl	4396 <co_list_push_back>
                    }

                    // Return the allocated block id
                    *p_block_id = cnt;
   114aa:	9b02      	ldr	r3, [sp, #8]
                    status = M_ERR_NO_ERROR;
   114ac:	2000      	movs	r0, #0
                        // Insert the block in the list of blocks
                        co_list_push_back(&p_m_tb_buf_env->list_free_small, &p_block->hdr);
                    }

                    // Return the allocated block id
                    *p_block_id = cnt;
   114ae:	701f      	strb	r7, [r3, #0]
   114b0:	e005      	b.n	114be <m_tb_buf_block_alloc+0x9e>
   114b2:	3401      	adds	r4, #1
        status = M_ERR_INVALID_PARAM;
    }
    else
    {
        // Look for an available block ID
        for (cnt = 0; cnt < M_TB_BUF_BLOCK_MAX; cnt++)
   114b4:	2c05      	cmp	r4, #5
   114b6:	d1be      	bne.n	11436 <m_tb_buf_block_alloc+0x16>
   114b8:	e7d0      	b.n	1145c <m_tb_buf_block_alloc+0x3c>
    // Counter
    uint8_t cnt;

    if (nb_bufs >= M_TB_BUF_BLOCK_BUF_MAX)
    {
        status = M_ERR_INVALID_PARAM;
   114ba:	20c1      	movs	r0, #193	; 0xc1
   114bc:	0040      	lsls	r0, r0, #1
            }
        }
    }

    return (status);
}
   114be:	b005      	add	sp, #20
   114c0:	bdf0      	pop	{r4, r5, r6, r7, pc}
   114c2:	46c0      	nop			; (mov r8, r8)
   114c4:	100126bc 	.word	0x100126bc

000114c8 <m_tb_buf_block_free>:

uint16_t m_tb_buf_block_free(uint8_t block_id, m_tb_buf_block_released_cb cb_released)
{
   114c8:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   114ca:	0006      	movs	r6, r0
   114cc:	000d      	movs	r5, r1
    // Returned status
    uint16_t status = M_ERR_INVALID_PARAM;

    // Check provided index
    if (block_id < M_TB_BUF_BLOCK_MAX)
   114ce:	2804      	cmp	r0, #4
   114d0:	d82d      	bhi.n	1152e <m_tb_buf_block_free+0x66>
    {
        // Get indicated block
        m_tb_buf_block_t *p_block = p_m_tb_buf_env->p_buf_blocks[block_id];
   114d2:	4f18      	ldr	r7, [pc, #96]	; (11534 <m_tb_buf_block_free+0x6c>)
   114d4:	1d33      	adds	r3, r6, #4
   114d6:	6838      	ldr	r0, [r7, #0]
   114d8:	009b      	lsls	r3, r3, #2
   114da:	581c      	ldr	r4, [r3, r0]
   114dc:	9301      	str	r3, [sp, #4]

        if (p_block)
   114de:	2c00      	cmp	r4, #0
   114e0:	d025      	beq.n	1152e <m_tb_buf_block_free+0x66>
        {
            status = M_ERR_NO_ERROR;

            // If all buffer are free, block can be free now
            if (p_block->nb_bufs == p_block->nb_bufs_free)
   114e2:	7b63      	ldrb	r3, [r4, #13]
   114e4:	7b22      	ldrb	r2, [r4, #12]
   114e6:	429a      	cmp	r2, r3
   114e8:	d10d      	bne.n	11506 <m_tb_buf_block_free+0x3e>
            {
                // Free the block
                m_al_free(p_block);
   114ea:	0020      	movs	r0, r4

                // Clear block pointer
                p_m_tb_buf_env->p_buf_blocks[block_id] = 0;
   114ec:	2400      	movs	r4, #0

            // If all buffer are free, block can be free now
            if (p_block->nb_bufs == p_block->nb_bufs_free)
            {
                // Free the block
                m_al_free(p_block);
   114ee:	f7f4 f875 	bl	55dc <m_al_free>

                // Clear block pointer
                p_m_tb_buf_env->p_buf_blocks[block_id] = 0;
   114f2:	683b      	ldr	r3, [r7, #0]
   114f4:	9a01      	ldr	r2, [sp, #4]
        // Get indicated block
        m_tb_buf_block_t *p_block = p_m_tb_buf_env->p_buf_blocks[block_id];

        if (p_block)
        {
            status = M_ERR_NO_ERROR;
   114f6:	0028      	movs	r0, r5
            {
                // Free the block
                m_al_free(p_block);

                // Clear block pointer
                p_m_tb_buf_env->p_buf_blocks[block_id] = 0;
   114f8:	50d4      	str	r4, [r2, r3]

                // Call the callback indicating that a block has been freed
                if(cb_released != NULL)
   114fa:	42a5      	cmp	r5, r4
   114fc:	d019      	beq.n	11532 <m_tb_buf_block_free+0x6a>
                {
                    cb_released(block_id);
   114fe:	0030      	movs	r0, r6
   11500:	47a8      	blx	r5
        // Get indicated block
        m_tb_buf_block_t *p_block = p_m_tb_buf_env->p_buf_blocks[block_id];

        if (p_block)
        {
            status = M_ERR_NO_ERROR;
   11502:	0020      	movs	r0, r4
   11504:	e015      	b.n	11532 <m_tb_buf_block_free+0x6a>
            }
            else
            {
                // If not all buffers are currently used, remove the block from the list
                // of blocks
                if (p_block->nb_bufs_free)
   11506:	2b00      	cmp	r3, #0
   11508:	d00a      	beq.n	11520 <m_tb_buf_block_free+0x58>
                {
                    if (GETB(p_block->status, M_TB_BUF_BLOCK_STATUS_LONG))
   1150a:	7ba3      	ldrb	r3, [r4, #14]
   1150c:	079b      	lsls	r3, r3, #30
   1150e:	d504      	bpl.n	1151a <m_tb_buf_block_free+0x52>
                    {
                        CO_LIST_POP_ELT(p_m_tb_buf_env->list_free_long, p_block);
   11510:	0021      	movs	r1, r4
   11512:	3008      	adds	r0, #8
   11514:	f7f2 ff74 	bl	4400 <co_list_extract>
   11518:	e002      	b.n	11520 <m_tb_buf_block_free+0x58>
                    }
                    else
                    {
                        CO_LIST_POP_ELT(p_m_tb_buf_env->list_free_small, p_block);
   1151a:	0021      	movs	r1, r4
   1151c:	f7f2 ff70 	bl	4400 <co_list_extract>

                // Register callback
                p_block->cb_released = cb_released;

                // Keep in mind that block must be freed
                SETB(p_block->status, M_TB_BUF_BLOCK_STATUS_FREE, 1);
   11520:	2201      	movs	r2, #1
   11522:	7ba3      	ldrb	r3, [r4, #14]
                        CO_LIST_POP_ELT(p_m_tb_buf_env->list_free_small, p_block);
                    }
                }

                // Register callback
                p_block->cb_released = cb_released;
   11524:	60a5      	str	r5, [r4, #8]

                // Keep in mind that block must be freed
                SETB(p_block->status, M_TB_BUF_BLOCK_STATUS_FREE, 1);
   11526:	4313      	orrs	r3, r2
   11528:	73a3      	strb	r3, [r4, #14]
        // Get indicated block
        m_tb_buf_block_t *p_block = p_m_tb_buf_env->p_buf_blocks[block_id];

        if (p_block)
        {
            status = M_ERR_NO_ERROR;
   1152a:	2000      	movs	r0, #0
   1152c:	e001      	b.n	11532 <m_tb_buf_block_free+0x6a>
}

uint16_t m_tb_buf_block_free(uint8_t block_id, m_tb_buf_block_released_cb cb_released)
{
    // Returned status
    uint16_t status = M_ERR_INVALID_PARAM;
   1152e:	20c1      	movs	r0, #193	; 0xc1
   11530:	0040      	lsls	r0, r0, #1
            }
        }
    }

    return (status);
}
   11532:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
   11534:	100126bc 	.word	0x100126bc

00011538 <m_tb_buf_alloc>:

uint16_t m_tb_buf_alloc(m_tb_buf_t **pp_buf, uint16_t head_len, uint16_t data_len, uint16_t tail_len)
{
   11538:	b5f0      	push	{r4, r5, r6, r7, lr}
   1153a:	b087      	sub	sp, #28
   1153c:	9304      	str	r3, [sp, #16]
    // Pointer to the block in which buffer can be taken
    m_tb_buf_block_t *p_block;
    // Pointer to the allocated buffer
    m_tb_buf_t *p_abuf = NULL;
    // Required buffer length
    uint16_t len = head_len + data_len + tail_len;
   1153e:	0013      	movs	r3, r2

    return (status);
}

uint16_t m_tb_buf_alloc(m_tb_buf_t **pp_buf, uint16_t head_len, uint16_t data_len, uint16_t tail_len)
{
   11540:	9203      	str	r2, [sp, #12]
    // Pointer to the block in which buffer can be taken
    m_tb_buf_block_t *p_block;
    // Pointer to the allocated buffer
    m_tb_buf_t *p_abuf = NULL;
    // Required buffer length
    uint16_t len = head_len + data_len + tail_len;
   11542:	9a04      	ldr	r2, [sp, #16]

    return (status);
}

uint16_t m_tb_buf_alloc(m_tb_buf_t **pp_buf, uint16_t head_len, uint16_t data_len, uint16_t tail_len)
{
   11544:	9005      	str	r0, [sp, #20]
    // Pointer to the block in which buffer can be taken
    m_tb_buf_block_t *p_block;
    // Pointer to the allocated buffer
    m_tb_buf_t *p_abuf = NULL;
    // Required buffer length
    uint16_t len = head_len + data_len + tail_len;
   11546:	189d      	adds	r5, r3, r2
   11548:	194d      	adds	r5, r1, r5
   1154a:	b2ad      	uxth	r5, r5

    return (status);
}

uint16_t m_tb_buf_alloc(m_tb_buf_t **pp_buf, uint16_t head_len, uint16_t data_len, uint16_t tail_len)
{
   1154c:	9102      	str	r1, [sp, #8]
   1154e:	4f34      	ldr	r7, [pc, #208]	; (11620 <m_tb_buf_alloc+0xe8>)
    uint16_t len = head_len + data_len + tail_len;
    // Buffer size
    uint32_t buf_size = 0;

    // Check if a small or a long buffer is needed or if buffer must be dynamically allocated
    if (len > M_TB_BUF_LONG_SIZE)
   11550:	2d98      	cmp	r5, #152	; 0x98
   11552:	d80c      	bhi.n	1156e <m_tb_buf_alloc+0x36>
        p_list = NULL;
    }
    else if (len <= M_TB_BUF_SMALL_SIZE)
    {
        // Can use a small buffer
        p_list = &p_m_tb_buf_env->list_free_small;
   11554:	683e      	ldr	r6, [r7, #0]
    if (len > M_TB_BUF_LONG_SIZE)
    {
        // Buffer will be dynamically allocated
        p_list = NULL;
    }
    else if (len <= M_TB_BUF_SMALL_SIZE)
   11556:	2d20      	cmp	r5, #32
   11558:	d803      	bhi.n	11562 <m_tb_buf_alloc+0x2a>
    {
        // Can use a small buffer
        p_list = &p_m_tb_buf_env->list_free_small;
        len    = M_TB_BUF_SMALL_SIZE;
        buf_size = sizeof(m_tb_buf_t) + M_TB_BUF_SMALL_SIZE;
   1155a:	2350      	movs	r3, #80	; 0x50
    }
    else if (len <= M_TB_BUF_SMALL_SIZE)
    {
        // Can use a small buffer
        p_list = &p_m_tb_buf_env->list_free_small;
        len    = M_TB_BUF_SMALL_SIZE;
   1155c:	2520      	movs	r5, #32
        buf_size = sizeof(m_tb_buf_t) + M_TB_BUF_SMALL_SIZE;
   1155e:	9300      	str	r3, [sp, #0]
   11560:	e003      	b.n	1156a <m_tb_buf_alloc+0x32>
    else
    {
        // Can use a long buffer
        p_list = &p_m_tb_buf_env->list_free_long;
        len    = M_TB_BUF_LONG_SIZE;
        buf_size = sizeof(m_tb_buf_t) + M_TB_BUF_LONG_SIZE;
   11562:	23c8      	movs	r3, #200	; 0xc8
    }
    else
    {
        // Can use a long buffer
        p_list = &p_m_tb_buf_env->list_free_long;
        len    = M_TB_BUF_LONG_SIZE;
   11564:	2598      	movs	r5, #152	; 0x98
        buf_size = sizeof(m_tb_buf_t) + M_TB_BUF_SMALL_SIZE;
    }
    else
    {
        // Can use a long buffer
        p_list = &p_m_tb_buf_env->list_free_long;
   11566:	3608      	adds	r6, #8
        len    = M_TB_BUF_LONG_SIZE;
        buf_size = sizeof(m_tb_buf_t) + M_TB_BUF_LONG_SIZE;
   11568:	9300      	str	r3, [sp, #0]
    }

    if (p_list)
   1156a:	2e00      	cmp	r6, #0
   1156c:	d108      	bne.n	11580 <m_tb_buf_alloc+0x48>
        uint8_t cnt;

        // Check if buffer can be allocated
        for (cnt = 0; cnt < M_TB_BUF_DYN_MAX; cnt++)
        {
            if (!p_m_tb_buf_env->p_dyn_bufs[cnt])
   1156e:	683b      	ldr	r3, [r7, #0]
   11570:	6a5e      	ldr	r6, [r3, #36]	; 0x24
   11572:	2e00      	cmp	r6, #0
   11574:	d028      	beq.n	115c8 <m_tb_buf_alloc+0x90>
   11576:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   11578:	2b00      	cmp	r3, #0
   1157a:	d14c      	bne.n	11616 <m_tb_buf_alloc+0xde>
    {
        // Counter
        uint8_t cnt;

        // Check if buffer can be allocated
        for (cnt = 0; cnt < M_TB_BUF_DYN_MAX; cnt++)
   1157c:	2601      	movs	r6, #1
   1157e:	e023      	b.n	115c8 <m_tb_buf_alloc+0x90>
   11580:	6834      	ldr	r4, [r6, #0]
    {
        // Get block in the chosen list
        p_block = (m_tb_buf_block_t *)co_list_pick(p_list);

        // Check if a block with an available buffer has been found
        if (p_block)
   11582:	2c00      	cmp	r4, #0
   11584:	d047      	beq.n	11616 <m_tb_buf_alloc+0xde>
        {
            // Get index of first available buffer
            uint8_t free_id = co_clz(p_block->ava_buf);
   11586:	6867      	ldr	r7, [r4, #4]
 ****************************************************************************************
 */
__INLINE_S__ uint32_t co_clz(uint32_t val)
{
    #if defined(__arm__)
    return __builtin_clz(val);
   11588:	0038      	movs	r0, r7
   1158a:	f00c fc41 	bl	1de10 <__clzsi2>
   1158e:	9001      	str	r0, [sp, #4]

            // Sanity check
            ASSERT_INFO(p_block->nb_bufs_free, 0, 0);
   11590:	7b63      	ldrb	r3, [r4, #13]
   11592:	2b00      	cmp	r3, #0
   11594:	d100      	bne.n	11598 <m_tb_buf_alloc+0x60>
   11596:	e7fe      	b.n	11596 <m_tb_buf_alloc+0x5e>

            // Mark the buffer as used
            p_block->ava_buf &= ~CO_BIT(31 - free_id);
   11598:	211f      	movs	r1, #31
   1159a:	9a01      	ldr	r2, [sp, #4]
            // Decrement number of free buffer in the block
            p_block->nb_bufs_free--;
   1159c:	3b01      	subs	r3, #1

            // Sanity check
            ASSERT_INFO(p_block->nb_bufs_free, 0, 0);

            // Mark the buffer as used
            p_block->ava_buf &= ~CO_BIT(31 - free_id);
   1159e:	1a89      	subs	r1, r1, r2
   115a0:	2201      	movs	r2, #1
   115a2:	408a      	lsls	r2, r1
            // Decrement number of free buffer in the block
            p_block->nb_bufs_free--;
   115a4:	b2db      	uxtb	r3, r3

            // Sanity check
            ASSERT_INFO(p_block->nb_bufs_free, 0, 0);

            // Mark the buffer as used
            p_block->ava_buf &= ~CO_BIT(31 - free_id);
   115a6:	4397      	bics	r7, r2
   115a8:	6067      	str	r7, [r4, #4]
            // Decrement number of free buffer in the block
            p_block->nb_bufs_free--;
   115aa:	7363      	strb	r3, [r4, #13]

            // If no more buffers are free in the block, remove it from its list
            if (!p_block->nb_bufs_free)
   115ac:	2b00      	cmp	r3, #0
   115ae:	d103      	bne.n	115b8 <m_tb_buf_alloc+0x80>
            {
                CO_LIST_POP_ELT(*p_list, p_block);
   115b0:	0021      	movs	r1, r4
   115b2:	0030      	movs	r0, r6
   115b4:	f7f2 ff24 	bl	4400 <co_list_extract>
            }

            // Get pointer to the available buffer
            p_abuf = (m_tb_buf_t *)((uint32_t)&p_block->bufs[0] + (free_id * buf_size));
   115b8:	9800      	ldr	r0, [sp, #0]
   115ba:	9b01      	ldr	r3, [sp, #4]
   115bc:	3410      	adds	r4, #16
   115be:	4358      	muls	r0, r3
   115c0:	1900      	adds	r0, r0, r4
                p_m_tb_buf_env->p_dyn_bufs[cnt] = p_abuf;
            }
        }
    }

    if (p_abuf)
   115c2:	2800      	cmp	r0, #0
   115c4:	d10f      	bne.n	115e6 <m_tb_buf_alloc+0xae>
   115c6:	e026      	b.n	11616 <m_tb_buf_alloc+0xde>
        }

        if (cnt < M_TB_BUF_DYN_MAX)
        {
            // Allocate buffer
            p_abuf = m_al_malloc(sizeof(m_tb_buf_t) + len);
   115c8:	0028      	movs	r0, r5
   115ca:	3030      	adds	r0, #48	; 0x30
   115cc:	b280      	uxth	r0, r0
   115ce:	f7f4 f800 	bl	55d2 <m_al_malloc>

            if (p_abuf)
   115d2:	2800      	cmp	r0, #0
   115d4:	d01f      	beq.n	11616 <m_tb_buf_alloc+0xde>
            {
                // Set block id and buffer id
                p_abuf->block_id = M_TB_BUF_DYN_ALLOC;
   115d6:	23ff      	movs	r3, #255	; 0xff
                p_abuf->buf_id = cnt;
   115d8:	7346      	strb	r6, [r0, #13]
            p_abuf = m_al_malloc(sizeof(m_tb_buf_t) + len);

            if (p_abuf)
            {
                // Set block id and buffer id
                p_abuf->block_id = M_TB_BUF_DYN_ALLOC;
   115da:	7303      	strb	r3, [r0, #12]
                #if (BLE_MESH_DBG)
                p_abuf->pattern = M_TB_BUF_DBG_PATTERN;
                #endif //(BLE_MESH_DBG)

                // Keep buffer pointer
                p_m_tb_buf_env->p_dyn_bufs[cnt] = p_abuf;
   115dc:	3608      	adds	r6, #8
   115de:	683b      	ldr	r3, [r7, #0]
   115e0:	00b6      	lsls	r6, r6, #2
   115e2:	199e      	adds	r6, r3, r6
   115e4:	6070      	str	r0, [r6, #4]
    {
        // Counter
        uint8_t cnt;

        // Set provided length
        p_abuf->head_len = head_len;
   115e6:	466b      	mov	r3, sp
   115e8:	891b      	ldrh	r3, [r3, #8]
   115ea:	0002      	movs	r2, r0
   115ec:	8083      	strh	r3, [r0, #4]
        p_abuf->tail_len = tail_len;
   115ee:	466b      	mov	r3, sp
   115f0:	8a1b      	ldrh	r3, [r3, #16]
        p_abuf->acq_cnt = 1;

        // Initialize environment content
        for (cnt = 0; cnt < M_TB_BUF_ENV_SIZE / sizeof(uint32_t); cnt++)
        {
            *(((uint32_t *)&p_abuf->env) + cnt) = 0;
   115f2:	2100      	movs	r1, #0
        // Counter
        uint8_t cnt;

        // Set provided length
        p_abuf->head_len = head_len;
        p_abuf->tail_len = tail_len;
   115f4:	80c3      	strh	r3, [r0, #6]
        p_abuf->data_len = data_len;
   115f6:	466b      	mov	r3, sp
   115f8:	899b      	ldrh	r3, [r3, #12]
        p_abuf->buf_len  = len;
   115fa:	8145      	strh	r5, [r0, #10]
        uint8_t cnt;

        // Set provided length
        p_abuf->head_len = head_len;
        p_abuf->tail_len = tail_len;
        p_abuf->data_len = data_len;
   115fc:	8103      	strh	r3, [r0, #8]
        p_abuf->buf_len  = len;
        // Initialize acquire counter
        p_abuf->acq_cnt = 1;
   115fe:	2301      	movs	r3, #1
   11600:	7383      	strb	r3, [r0, #14]
   11602:	0003      	movs	r3, r0
   11604:	3230      	adds	r2, #48	; 0x30
   11606:	3310      	adds	r3, #16

        // Initialize environment content
        for (cnt = 0; cnt < M_TB_BUF_ENV_SIZE / sizeof(uint32_t); cnt++)
        {
            *(((uint32_t *)&p_abuf->env) + cnt) = 0;
   11608:	c302      	stmia	r3!, {r1}
        p_abuf->buf_len  = len;
        // Initialize acquire counter
        p_abuf->acq_cnt = 1;

        // Initialize environment content
        for (cnt = 0; cnt < M_TB_BUF_ENV_SIZE / sizeof(uint32_t); cnt++)
   1160a:	4293      	cmp	r3, r2
   1160c:	d1fc      	bne.n	11608 <m_tb_buf_alloc+0xd0>
        {
            *(((uint32_t *)&p_abuf->env) + cnt) = 0;
        }

        // Return the allocated buffer
        *pp_buf = p_abuf;
   1160e:	9b05      	ldr	r3, [sp, #20]
   11610:	6018      	str	r0, [r3, #0]

        // And a no error status
        status = M_ERR_NO_ERROR;
   11612:	2000      	movs	r0, #0
   11614:	e001      	b.n	1161a <m_tb_buf_alloc+0xe2>
}

uint16_t m_tb_buf_alloc(m_tb_buf_t **pp_buf, uint16_t head_len, uint16_t data_len, uint16_t tail_len)
{
    // Returned status
    uint16_t status = M_ERR_INSUFFICIENT_RESOURCES;
   11616:	20b0      	movs	r0, #176	; 0xb0
   11618:	00c0      	lsls	r0, r0, #3
        // And a no error status
        status = M_ERR_NO_ERROR;
    }

    return (status);
}
   1161a:	b007      	add	sp, #28
   1161c:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1161e:	46c0      	nop			; (mov r8, r8)
   11620:	100126bc 	.word	0x100126bc

00011624 <m_tb_buf_head_reserve>:
{
    // Returned status
    uint16_t status = M_ERR_NO_ERROR;

    // Check if provided length is available in the head part
    if (len <= p_buf->head_len)
   11624:	8883      	ldrh	r3, [r0, #4]
   11626:	428b      	cmp	r3, r1
   11628:	d306      	bcc.n	11638 <m_tb_buf_head_reserve+0x14>
    {
        // Decrease head part length
        p_buf->head_len -= len;
   1162a:	1a5b      	subs	r3, r3, r1
   1162c:	8083      	strh	r3, [r0, #4]
        // And increase data part length
        p_buf->data_len += len;
   1162e:	8903      	ldrh	r3, [r0, #8]
   11630:	18c9      	adds	r1, r1, r3
   11632:	8101      	strh	r1, [r0, #8]
}

uint16_t m_tb_buf_head_reserve(m_tb_buf_t *p_buf, uint16_t len)
{
    // Returned status
    uint16_t status = M_ERR_NO_ERROR;
   11634:	2000      	movs	r0, #0
   11636:	e000      	b.n	1163a <m_tb_buf_head_reserve+0x16>
        // And increase data part length
        p_buf->data_len += len;
    }
    else
    {
        status = M_ERR_COMMAND_DISALLOWED;
   11638:	4800      	ldr	r0, [pc, #0]	; (1163c <m_tb_buf_head_reserve+0x18>)
    }

    return (status);
}
   1163a:	4770      	bx	lr
   1163c:	00000282 	.word	0x00000282

00011640 <m_tb_buf_head_release>:
{
    // Returned status
    uint16_t status = M_ERR_NO_ERROR;

    // Check if provided length is available in the data part
    if (len <= p_buf->data_len)
   11640:	8903      	ldrh	r3, [r0, #8]
   11642:	428b      	cmp	r3, r1
   11644:	d306      	bcc.n	11654 <m_tb_buf_head_release+0x14>
    {
        // Increase head part length
        p_buf->head_len += len;
   11646:	8882      	ldrh	r2, [r0, #4]
        // And decrease data part length
        p_buf->data_len -= len;
   11648:	1a5b      	subs	r3, r3, r1

    // Check if provided length is available in the data part
    if (len <= p_buf->data_len)
    {
        // Increase head part length
        p_buf->head_len += len;
   1164a:	188a      	adds	r2, r1, r2
   1164c:	8082      	strh	r2, [r0, #4]
        // And decrease data part length
        p_buf->data_len -= len;
   1164e:	8103      	strh	r3, [r0, #8]
}

uint16_t m_tb_buf_head_release(m_tb_buf_t *p_buf, uint16_t len)
{
    // Returned status
    uint16_t status = M_ERR_NO_ERROR;
   11650:	2000      	movs	r0, #0
   11652:	e000      	b.n	11656 <m_tb_buf_head_release+0x16>
        // And decrease data part length
        p_buf->data_len -= len;
    }
    else
    {
        status = M_ERR_COMMAND_DISALLOWED;
   11654:	4800      	ldr	r0, [pc, #0]	; (11658 <m_tb_buf_head_release+0x18>)
    }

    return (status);
}
   11656:	4770      	bx	lr
   11658:	00000282 	.word	0x00000282

0001165c <m_tb_buf_tail_reserve>:
{
    // Returned status
    uint16_t status = M_ERR_NO_ERROR;

    // Check if provided length is available in the tail part
    if (len <= p_buf->tail_len)
   1165c:	88c3      	ldrh	r3, [r0, #6]
   1165e:	428b      	cmp	r3, r1
   11660:	d306      	bcc.n	11670 <m_tb_buf_tail_reserve+0x14>
    {
        // Decrease tail part length
        p_buf->tail_len -= len;
   11662:	1a5b      	subs	r3, r3, r1
   11664:	80c3      	strh	r3, [r0, #6]
        // And increase data part length
        p_buf->data_len += len;
   11666:	8903      	ldrh	r3, [r0, #8]
   11668:	18c9      	adds	r1, r1, r3
   1166a:	8101      	strh	r1, [r0, #8]
}

uint16_t m_tb_buf_tail_reserve(m_tb_buf_t *p_buf, uint16_t len)
{
    // Returned status
    uint16_t status = M_ERR_NO_ERROR;
   1166c:	2000      	movs	r0, #0
   1166e:	e000      	b.n	11672 <m_tb_buf_tail_reserve+0x16>
        // And increase data part length
        p_buf->data_len += len;
    }
    else
    {
        status = M_ERR_COMMAND_DISALLOWED;
   11670:	4800      	ldr	r0, [pc, #0]	; (11674 <m_tb_buf_tail_reserve+0x18>)
    }

    return (status);
}
   11672:	4770      	bx	lr
   11674:	00000282 	.word	0x00000282

00011678 <m_tb_buf_tail_release>:
{
    // Returned status
    uint16_t status = M_ERR_NO_ERROR;

    // Check if provided length is available in the data part
    if (len <= p_buf->data_len)
   11678:	8903      	ldrh	r3, [r0, #8]
   1167a:	428b      	cmp	r3, r1
   1167c:	d306      	bcc.n	1168c <m_tb_buf_tail_release+0x14>
    {
        // Increase tail part length
        p_buf->tail_len += len;
   1167e:	88c2      	ldrh	r2, [r0, #6]
        // And decrease data part length
        p_buf->data_len -= len;
   11680:	1a5b      	subs	r3, r3, r1

    // Check if provided length is available in the data part
    if (len <= p_buf->data_len)
    {
        // Increase tail part length
        p_buf->tail_len += len;
   11682:	188a      	adds	r2, r1, r2
   11684:	80c2      	strh	r2, [r0, #6]
        // And decrease data part length
        p_buf->data_len -= len;
   11686:	8103      	strh	r3, [r0, #8]
}

uint16_t m_tb_buf_tail_release(m_tb_buf_t *p_buf, uint16_t len)
{
    // Returned status
    uint16_t status = M_ERR_NO_ERROR;
   11688:	2000      	movs	r0, #0
   1168a:	e000      	b.n	1168e <m_tb_buf_tail_release+0x16>
        // And decrease data part length
        p_buf->data_len -= len;
    }
    else
    {
        status = M_ERR_COMMAND_DISALLOWED;
   1168c:	4800      	ldr	r0, [pc, #0]	; (11690 <m_tb_buf_tail_release+0x18>)
    }

    return (status);
}
   1168e:	4770      	bx	lr
   11690:	00000282 	.word	0x00000282

00011694 <m_tb_buf_acquire>:
    // Sanity check
    ASSERT_ERR(p_buf->pattern == M_TB_BUF_DBG_PATTERN);
    #endif //(BLE_MESH_DBG)

    // Increase acquire counter for the buffer
    p_buf->acq_cnt++;
   11694:	7b83      	ldrb	r3, [r0, #14]
   11696:	3301      	adds	r3, #1
   11698:	7383      	strb	r3, [r0, #14]
}
   1169a:	4770      	bx	lr

0001169c <m_tb_buf_release>:

uint16_t m_tb_buf_release(m_tb_buf_t *p_buf)
{
   1169c:	b570      	push	{r4, r5, r6, lr}
    {
        // Sanity check
        #if (BLE_MESH_DBG)
        ASSERT_ERR(p_buf->pattern == M_TB_BUF_DBG_PATTERN);
        #endif //(BLE_MESH_DBG)
        ASSERT_INFO(p_buf->acq_cnt, 0, 0);
   1169e:	7b83      	ldrb	r3, [r0, #14]
   116a0:	2b00      	cmp	r3, #0
   116a2:	d100      	bne.n	116a6 <m_tb_buf_release+0xa>
   116a4:	e7fe      	b.n	116a4 <m_tb_buf_release+0x8>
            status = M_ERR_COMMAND_DISALLOWED;
            break;
        }

        // Decrease acquire counter
        p_buf->acq_cnt--;
   116a6:	3b01      	subs	r3, #1
   116a8:	b2db      	uxtb	r3, r3
   116aa:	7383      	strb	r3, [r0, #14]

        // If acquire counter becomes 0, free the buffer
        if (p_buf->acq_cnt)
   116ac:	2b00      	cmp	r3, #0
   116ae:	d132      	bne.n	11716 <m_tb_buf_release+0x7a>
        {
            break;
        }

        // Check if block was dynamically allocated
        if (p_buf->block_id == M_TB_BUF_DYN_ALLOC)
   116b0:	7b02      	ldrb	r2, [r0, #12]
   116b2:	491a      	ldr	r1, [pc, #104]	; (1171c <m_tb_buf_release+0x80>)
   116b4:	2aff      	cmp	r2, #255	; 0xff
   116b6:	d109      	bne.n	116cc <m_tb_buf_release+0x30>
        {
            // Clear pointer to buffer
            p_m_tb_buf_env->p_dyn_bufs[p_buf->buf_id] = NULL;
   116b8:	680c      	ldr	r4, [r1, #0]
   116ba:	7b41      	ldrb	r1, [r0, #13]
   116bc:	000a      	movs	r2, r1
   116be:	3208      	adds	r2, #8
   116c0:	0092      	lsls	r2, r2, #2
   116c2:	18a2      	adds	r2, r4, r2
   116c4:	6053      	str	r3, [r2, #4]

            // Free the buffer
            m_al_free(p_buf);
   116c6:	f7f3 ff89 	bl	55dc <m_al_free>
   116ca:	e024      	b.n	11716 <m_tb_buf_release+0x7a>
        }
        else
        {
            // Get information about block the buffer belongs to
            m_tb_buf_block_t *p_block = p_m_tb_buf_env->p_buf_blocks[p_buf->block_id];
   116cc:	680b      	ldr	r3, [r1, #0]
   116ce:	3204      	adds	r2, #4
   116d0:	0092      	lsls	r2, r2, #2
   116d2:	58d1      	ldr	r1, [r2, r3]
            // Current number of free buffers in the block
            uint8_t init_nb_bufs_free = p_block->nb_bufs_free;
   116d4:	7b4c      	ldrb	r4, [r1, #13]

            // Increase number of free buffers in the block
            p_block->nb_bufs_free++;
   116d6:	1c62      	adds	r2, r4, #1
   116d8:	734a      	strb	r2, [r1, #13]
            // Mark the buffer as free
            p_block->ava_buf |= CO_BIT(31 - p_buf->buf_id);
   116da:	221f      	movs	r2, #31
   116dc:	7b45      	ldrb	r5, [r0, #13]
   116de:	1b52      	subs	r2, r2, r5
   116e0:	2501      	movs	r5, #1
   116e2:	002e      	movs	r6, r5
   116e4:	4096      	lsls	r6, r2
   116e6:	0032      	movs	r2, r6
   116e8:	684e      	ldr	r6, [r1, #4]
   116ea:	4332      	orrs	r2, r6
   116ec:	604a      	str	r2, [r1, #4]

            // Check if block is being freed
            if (GETB(p_block->status, M_TB_BUF_BLOCK_STATUS_FREE))
   116ee:	7b8a      	ldrb	r2, [r1, #14]
   116f0:	422a      	tst	r2, r5
   116f2:	d004      	beq.n	116fe <m_tb_buf_release+0x62>
            {
                // Try to free the block
                m_tb_buf_block_free(p_buf->block_id, p_block->cb_released);
   116f4:	6889      	ldr	r1, [r1, #8]
   116f6:	7b00      	ldrb	r0, [r0, #12]
   116f8:	f7ff fee6 	bl	114c8 <m_tb_buf_block_free>
                break;
   116fc:	e00b      	b.n	11716 <m_tb_buf_release+0x7a>
            }

            // If all buffers where used, insert the block in the list of blocks with available buffers
            if (init_nb_bufs_free)
   116fe:	2c00      	cmp	r4, #0
   11700:	d109      	bne.n	11716 <m_tb_buf_release+0x7a>
            {
                break;
            }

            // Is it a block of "small" or "long" buffers ?
            if (GETB(p_block->status, M_TB_BUF_BLOCK_STATUS_LONG))
   11702:	0792      	lsls	r2, r2, #30
   11704:	d504      	bpl.n	11710 <m_tb_buf_release+0x74>
            {
                co_list_push_back(&p_m_tb_buf_env->list_free_long, &p_block->hdr);
   11706:	3308      	adds	r3, #8
   11708:	0018      	movs	r0, r3
   1170a:	f7f2 fe44 	bl	4396 <co_list_push_back>
   1170e:	e002      	b.n	11716 <m_tb_buf_release+0x7a>
            }
            else
            {
                co_list_push_back(&p_m_tb_buf_env->list_free_small, &p_block->hdr);
   11710:	0018      	movs	r0, r3
   11712:	f7f2 fe40 	bl	4396 <co_list_push_back>
            }
        }
    } while (0);

    return (status);
}
   11716:	2000      	movs	r0, #0
   11718:	bd70      	pop	{r4, r5, r6, pc}
   1171a:	46c0      	nop			; (mov r8, r8)
   1171c:	100126bc 	.word	0x100126bc

00011720 <m_tb_buf_copy>:

uint16_t m_tb_buf_copy(m_tb_buf_t *p_buf_in, m_tb_buf_t *p_buf_out, uint16_t length, bool copy_env)
{
   11720:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   11722:	001f      	movs	r7, r3
    // Returned status
    uint16_t status = M_ERR_NO_ERROR;

    // Check if output buffer can receive the data to copy
    if (length <= p_buf_out->data_len)
   11724:	890b      	ldrh	r3, [r1, #8]

    return (status);
}

uint16_t m_tb_buf_copy(m_tb_buf_t *p_buf_in, m_tb_buf_t *p_buf_out, uint16_t length, bool copy_env)
{
   11726:	0005      	movs	r5, r0
   11728:	000c      	movs	r4, r1
    // Returned status
    uint16_t status = M_ERR_NO_ERROR;

    // Check if output buffer can receive the data to copy
    if (length <= p_buf_out->data_len)
   1172a:	4293      	cmp	r3, r2
   1172c:	d312      	bcc.n	11754 <m_tb_buf_copy+0x34>
}

uint16_t m_tb_buf_copy(m_tb_buf_t *p_buf_in, m_tb_buf_t *p_buf_out, uint16_t length, bool copy_env)
{
    // Returned status
    uint16_t status = M_ERR_NO_ERROR;
   1172e:	2600      	movs	r6, #0
    // Check if output buffer can receive the data to copy
    if (length <= p_buf_out->data_len)
    {
        // Copy buffer data
        m_tb_buf_copy_data((uint32_t *)&p_buf_out->buf[p_buf_out->head_len],
                           (uint32_t *)&p_buf_in->buf[p_buf_in->head_len], length);
   11730:	8881      	ldrh	r1, [r0, #4]
   11732:	3130      	adds	r1, #48	; 0x30
   11734:	1841      	adds	r1, r0, r1

    // Check if output buffer can receive the data to copy
    if (length <= p_buf_out->data_len)
    {
        // Copy buffer data
        m_tb_buf_copy_data((uint32_t *)&p_buf_out->buf[p_buf_out->head_len],
   11736:	88a0      	ldrh	r0, [r4, #4]
   11738:	3030      	adds	r0, #48	; 0x30
   1173a:	1820      	adds	r0, r4, r0
   1173c:	f7ff fdfe 	bl	1133c <m_tb_buf_copy_data>
                           (uint32_t *)&p_buf_in->buf[p_buf_in->head_len], length);

        // Copy environment if required
        if (copy_env)
   11740:	42b7      	cmp	r7, r6
   11742:	d008      	beq.n	11756 <m_tb_buf_copy+0x36>
        {
            m_tb_buf_copy_data((uint32_t *)&p_buf_out->env[0], (uint32_t *)&p_buf_in->env[0], M_TB_BUF_ENV_SIZE);
   11744:	0029      	movs	r1, r5
   11746:	0020      	movs	r0, r4
   11748:	3110      	adds	r1, #16
   1174a:	3010      	adds	r0, #16
   1174c:	2220      	movs	r2, #32
   1174e:	f7ff fdf5 	bl	1133c <m_tb_buf_copy_data>
   11752:	e000      	b.n	11756 <m_tb_buf_copy+0x36>
        }
    }
    else
    {
        status = M_ERR_COMMAND_DISALLOWED;
   11754:	4e01      	ldr	r6, [pc, #4]	; (1175c <m_tb_buf_copy+0x3c>)
    }

    return (status);
}
   11756:	0030      	movs	r0, r6
   11758:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1175a:	46c0      	nop			; (mov r8, r8)
   1175c:	00000282 	.word	0x00000282

00011760 <m_tb_buf_copy_data_from_mem>:

uint16_t m_tb_buf_copy_data_from_mem(m_tb_buf_t *p_buf, const uint8_t *p_mem, uint16_t len)
{
   11760:	b510      	push	{r4, lr}
   11762:	0013      	movs	r3, r2
    // Returned status
    uint16_t status = M_ERR_NO_ERROR;

    // Check that provided buffer can contain the provided length
    if (p_buf->data_len == len)
   11764:	8902      	ldrh	r2, [r0, #8]
   11766:	429a      	cmp	r2, r3
   11768:	d106      	bne.n	11778 <m_tb_buf_copy_data_from_mem+0x18>
    {
        // Copy provided data
        m_tb_buf_copy_data((uint32_t *)&p_buf->buf[p_buf->head_len], (uint32_t *)p_mem, len);
   1176a:	8883      	ldrh	r3, [r0, #4]
   1176c:	3330      	adds	r3, #48	; 0x30
   1176e:	18c0      	adds	r0, r0, r3
   11770:	f7ff fde4 	bl	1133c <m_tb_buf_copy_data>
}

uint16_t m_tb_buf_copy_data_from_mem(m_tb_buf_t *p_buf, const uint8_t *p_mem, uint16_t len)
{
    // Returned status
    uint16_t status = M_ERR_NO_ERROR;
   11774:	2000      	movs	r0, #0
   11776:	e000      	b.n	1177a <m_tb_buf_copy_data_from_mem+0x1a>
        // Copy provided data
        m_tb_buf_copy_data((uint32_t *)&p_buf->buf[p_buf->head_len], (uint32_t *)p_mem, len);
    }
    else
    {
        status = M_ERR_COMMAND_DISALLOWED;
   11778:	4800      	ldr	r0, [pc, #0]	; (1177c <m_tb_buf_copy_data_from_mem+0x1c>)
    }

    return (status);
}
   1177a:	bd10      	pop	{r4, pc}
   1177c:	00000282 	.word	0x00000282

00011780 <m_tb_buf_copy_data_to_mem>:

void m_tb_buf_copy_data_to_mem(m_tb_buf_t *p_buf, uint8_t *p_mem)
{
   11780:	000b      	movs	r3, r1
   11782:	b510      	push	{r4, lr}
    // Copy provided data
    m_tb_buf_copy_data((uint32_t *)p_mem, (uint32_t *)&p_buf->buf[p_buf->head_len], p_buf->data_len);
   11784:	8881      	ldrh	r1, [r0, #4]
   11786:	8902      	ldrh	r2, [r0, #8]
   11788:	3130      	adds	r1, #48	; 0x30
   1178a:	1841      	adds	r1, r0, r1
   1178c:	0018      	movs	r0, r3
   1178e:	f7ff fdd5 	bl	1133c <m_tb_buf_copy_data>
}
   11792:	bd10      	pop	{r4, pc}

00011794 <m_tb_buf_reuse>:

uint16_t m_tb_buf_reuse(m_tb_buf_t *p_buf, uint16_t head_len, uint16_t data_len, uint16_t tail_len)
{
   11794:	b530      	push	{r4, r5, lr}
    uint16_t status = M_ERR_INVALID_PARAM;

    // Initialize buffer lengths
    if((p_buf) &&  (p_buf->buf_len >= (head_len + data_len + tail_len)))
   11796:	2800      	cmp	r0, #0
   11798:	d009      	beq.n	117ae <m_tb_buf_reuse+0x1a>
   1179a:	188c      	adds	r4, r1, r2
   1179c:	8945      	ldrh	r5, [r0, #10]
   1179e:	18e4      	adds	r4, r4, r3
   117a0:	42a5      	cmp	r5, r4
   117a2:	db04      	blt.n	117ae <m_tb_buf_reuse+0x1a>
    {
        p_buf->head_len = head_len;
   117a4:	8081      	strh	r1, [r0, #4]
        p_buf->data_len = data_len;
   117a6:	8102      	strh	r2, [r0, #8]
        p_buf->tail_len = tail_len;
   117a8:	80c3      	strh	r3, [r0, #6]
        status = M_ERR_NO_ERROR;
   117aa:	2000      	movs	r0, #0
   117ac:	e001      	b.n	117b2 <m_tb_buf_reuse+0x1e>
    m_tb_buf_copy_data((uint32_t *)p_mem, (uint32_t *)&p_buf->buf[p_buf->head_len], p_buf->data_len);
}

uint16_t m_tb_buf_reuse(m_tb_buf_t *p_buf, uint16_t head_len, uint16_t data_len, uint16_t tail_len)
{
    uint16_t status = M_ERR_INVALID_PARAM;
   117ae:	20c1      	movs	r0, #193	; 0xc1
   117b0:	0040      	lsls	r0, r0, #1
        p_buf->tail_len = tail_len;
        status = M_ERR_NO_ERROR;
    }

    return (status);
}
   117b2:	bd30      	pop	{r4, r5, pc}

000117b4 <m_tb_key_create_start>:
 * @param[in] res_cb   Function called when all sub-keys has been generated
 ****************************************************************************************
 */
__STATIC void m_tb_key_create_start(m_lid_t key_lid, m_tb_key_t *p_key, m_tb_key_added_cb res_cb)
{
    p_m_tb_key_env->key_create_lid = key_lid;
   117b4:	4b06      	ldr	r3, [pc, #24]	; (117d0 <m_tb_key_create_start+0x1c>)
 * @param[in] p_key    Pointer of the key structure
 * @param[in] res_cb   Function called when all sub-keys has been generated
 ****************************************************************************************
 */
__STATIC void m_tb_key_create_start(m_lid_t key_lid, m_tb_key_t *p_key, m_tb_key_added_cb res_cb)
{
   117b6:	b510      	push	{r4, lr}
    p_m_tb_key_env->key_create_lid = key_lid;
   117b8:	681b      	ldr	r3, [r3, #0]
   117ba:	001c      	movs	r4, r3
   117bc:	34b4      	adds	r4, #180	; 0xb4
   117be:	7020      	strb	r0, [r4, #0]
    p_m_tb_key_env->p_key_create = p_key;
   117c0:	6399      	str	r1, [r3, #56]	; 0x38
    p_m_tb_key_env->cb_create = res_cb;

    SETB(p_m_tb_key_env->status, M_TB_KEY_STATE_KEY_GEN, 1);
   117c2:	2108      	movs	r1, #8
 */
__STATIC void m_tb_key_create_start(m_lid_t key_lid, m_tb_key_t *p_key, m_tb_key_added_cb res_cb)
{
    p_m_tb_key_env->key_create_lid = key_lid;
    p_m_tb_key_env->p_key_create = p_key;
    p_m_tb_key_env->cb_create = res_cb;
   117c4:	63da      	str	r2, [r3, #60]	; 0x3c

    SETB(p_m_tb_key_env->status, M_TB_KEY_STATE_KEY_GEN, 1);
   117c6:	33b9      	adds	r3, #185	; 0xb9
   117c8:	781a      	ldrb	r2, [r3, #0]
   117ca:	430a      	orrs	r2, r1
   117cc:	701a      	strb	r2, [r3, #0]
}
   117ce:	bd10      	pop	{r4, pc}
   117d0:	100126c0 	.word	0x100126c0

000117d4 <m_tb_key_nid_tbl_add>:
{
    // Counter
    m_lid_t i;

    // Browse table in reverse order
    for (i = p_m_tb_key_env->nb_nids; i > 0; i--)
   117d4:	4b13      	ldr	r3, [pc, #76]	; (11824 <m_tb_key_nid_tbl_add+0x50>)
 * @param[in] net_key_lid   Network Key Local Index
 * @param[in] nid           Network Key NID
 ****************************************************************************************
 */
__STATIC void m_tb_key_nid_tbl_add(m_lid_t net_key_lid, uint8_t nid)
{
   117d6:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    // Counter
    m_lid_t i;

    // Browse table in reverse order
    for (i = p_m_tb_key_env->nb_nids; i > 0; i--)
   117d8:	681f      	ldr	r7, [r3, #0]
 * @param[in] net_key_lid   Network Key Local Index
 * @param[in] nid           Network Key NID
 ****************************************************************************************
 */
__STATIC void m_tb_key_nid_tbl_add(m_lid_t net_key_lid, uint8_t nid)
{
   117da:	9001      	str	r0, [sp, #4]
    // Counter
    m_lid_t i;

    // Browse table in reverse order
    for (i = p_m_tb_key_env->nb_nids; i > 0; i--)
   117dc:	003e      	movs	r6, r7
   117de:	36b5      	adds	r6, #181	; 0xb5
   117e0:	7835      	ldrb	r5, [r6, #0]
   117e2:	002a      	movs	r2, r5
   117e4:	0053      	lsls	r3, r2, #1
   117e6:	2a00      	cmp	r2, #0
   117e8:	d010      	beq.n	1180c <m_tb_key_nid_tbl_add+0x38>
    {
        // Check if previous element has a greater NID than one to insert
        if (p_m_tb_key_env->map_nid_nk[i - 1].nid > nid)
   117ea:	203e      	movs	r0, #62	; 0x3e
   117ec:	4684      	mov	ip, r0
   117ee:	18fc      	adds	r4, r7, r3
   117f0:	44a4      	add	ip, r4
   117f2:	4660      	mov	r0, ip
   117f4:	7800      	ldrb	r0, [r0, #0]
   117f6:	4288      	cmp	r0, r1
   117f8:	d908      	bls.n	1180c <m_tb_key_nid_tbl_add+0x38>
        {
            p_m_tb_key_env->map_nid_nk[i].nid = p_m_tb_key_env->map_nid_nk[i - 1].nid ;
   117fa:	0023      	movs	r3, r4
   117fc:	3340      	adds	r3, #64	; 0x40
   117fe:	7018      	strb	r0, [r3, #0]
            p_m_tb_key_env->map_nid_nk[i].net_key_lid = p_m_tb_key_env->map_nid_nk[i - 1].net_key_lid;
   11800:	343f      	adds	r4, #63	; 0x3f
   11802:	7824      	ldrb	r4, [r4, #0]
{
    // Counter
    m_lid_t i;

    // Browse table in reverse order
    for (i = p_m_tb_key_env->nb_nids; i > 0; i--)
   11804:	3a01      	subs	r2, #1
    {
        // Check if previous element has a greater NID than one to insert
        if (p_m_tb_key_env->map_nid_nk[i - 1].nid > nid)
        {
            p_m_tb_key_env->map_nid_nk[i].nid = p_m_tb_key_env->map_nid_nk[i - 1].nid ;
            p_m_tb_key_env->map_nid_nk[i].net_key_lid = p_m_tb_key_env->map_nid_nk[i - 1].net_key_lid;
   11806:	705c      	strb	r4, [r3, #1]
{
    // Counter
    m_lid_t i;

    // Browse table in reverse order
    for (i = p_m_tb_key_env->nb_nids; i > 0; i--)
   11808:	b2d2      	uxtb	r2, r2
   1180a:	e7eb      	b.n	117e4 <m_tb_key_nid_tbl_add+0x10>
   1180c:	18fb      	adds	r3, r7, r3
            break;
        }
    }

    // Insert latest element
    p_m_tb_key_env->map_nid_nk[i].nid = nid;
   1180e:	001a      	movs	r2, r3
   11810:	3240      	adds	r2, #64	; 0x40
   11812:	7011      	strb	r1, [r2, #0]
    p_m_tb_key_env->map_nid_nk[i].net_key_lid = net_key_lid;
   11814:	466a      	mov	r2, sp
   11816:	7912      	ldrb	r2, [r2, #4]
    p_m_tb_key_env->nb_nids++;
   11818:	3501      	adds	r5, #1
        }
    }

    // Insert latest element
    p_m_tb_key_env->map_nid_nk[i].nid = nid;
    p_m_tb_key_env->map_nid_nk[i].net_key_lid = net_key_lid;
   1181a:	3341      	adds	r3, #65	; 0x41
   1181c:	701a      	strb	r2, [r3, #0]
    p_m_tb_key_env->nb_nids++;
   1181e:	7035      	strb	r5, [r6, #0]
}
   11820:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
   11822:	46c0      	nop			; (mov r8, r8)
   11824:	100126c0 	.word	0x100126c0

00011828 <m_tb_key_nid_tbl_del>:
{
    // Counter
    m_lid_t i;

    // Browse list in order to find position of the network key index
    for (i = 0; i < p_m_tb_key_env->nb_nids; i++)
   11828:	4b18      	ldr	r3, [pc, #96]	; (1188c <m_tb_key_nid_tbl_del+0x64>)
 * @param[in] net_key_lid   Network Key Local Index
 * @param[in] nid           Network Key NID
 ****************************************************************************************
 */
__STATIC void m_tb_key_nid_tbl_del(m_lid_t net_key_lid)
{
   1182a:	b5f0      	push	{r4, r5, r6, r7, lr}
    // Counter
    m_lid_t i;

    // Browse list in order to find position of the network key index
    for (i = 0; i < p_m_tb_key_env->nb_nids; i++)
   1182c:	681c      	ldr	r4, [r3, #0]
   1182e:	2300      	movs	r3, #0
   11830:	0021      	movs	r1, r4
   11832:	0022      	movs	r2, r4
   11834:	31b5      	adds	r1, #181	; 0xb5
   11836:	780d      	ldrb	r5, [r1, #0]
   11838:	3241      	adds	r2, #65	; 0x41
   1183a:	42ab      	cmp	r3, r5
   1183c:	d004      	beq.n	11848 <m_tb_key_nid_tbl_del+0x20>
   1183e:	3202      	adds	r2, #2
    {
        if (p_m_tb_key_env->map_nid_nk[i].net_key_lid == net_key_lid)
   11840:	1e96      	subs	r6, r2, #2
   11842:	7836      	ldrb	r6, [r6, #0]
   11844:	4286      	cmp	r6, r0
   11846:	d101      	bne.n	1184c <m_tb_key_nid_tbl_del+0x24>
            break;
        }
    }

    // Remove element by moving following elements one row back
    for (; i < (p_m_tb_key_env->nb_nids - 1); i++)
   11848:	1e68      	subs	r0, r5, #1
   1184a:	e002      	b.n	11852 <m_tb_key_nid_tbl_del+0x2a>
{
    // Counter
    m_lid_t i;

    // Browse list in order to find position of the network key index
    for (i = 0; i < p_m_tb_key_env->nb_nids; i++)
   1184c:	3301      	adds	r3, #1
   1184e:	b2db      	uxtb	r3, r3
   11850:	e7f3      	b.n	1183a <m_tb_key_nid_tbl_del+0x12>
            break;
        }
    }

    // Remove element by moving following elements one row back
    for (; i < (p_m_tb_key_env->nb_nids - 1); i++)
   11852:	4283      	cmp	r3, r0
   11854:	da0d      	bge.n	11872 <m_tb_key_nid_tbl_del+0x4a>
   11856:	005a      	lsls	r2, r3, #1
   11858:	18a2      	adds	r2, r4, r2
    {
        p_m_tb_key_env->map_nid_nk[i].nid = p_m_tb_key_env->map_nid_nk[i + 1].nid;
   1185a:	0017      	movs	r7, r2
   1185c:	0016      	movs	r6, r2
   1185e:	3742      	adds	r7, #66	; 0x42
   11860:	783f      	ldrb	r7, [r7, #0]
   11862:	3640      	adds	r6, #64	; 0x40
   11864:	7037      	strb	r7, [r6, #0]
        p_m_tb_key_env->map_nid_nk[i].net_key_lid = p_m_tb_key_env->map_nid_nk[i + 1].net_key_lid;
   11866:	3243      	adds	r2, #67	; 0x43
   11868:	7812      	ldrb	r2, [r2, #0]
   1186a:	7072      	strb	r2, [r6, #1]
            break;
        }
    }

    // Remove element by moving following elements one row back
    for (; i < (p_m_tb_key_env->nb_nids - 1); i++)
   1186c:	1c5a      	adds	r2, r3, #1
   1186e:	b2d3      	uxtb	r3, r2
   11870:	e7ef      	b.n	11852 <m_tb_key_nid_tbl_del+0x2a>
        p_m_tb_key_env->map_nid_nk[i].nid = p_m_tb_key_env->map_nid_nk[i + 1].nid;
        p_m_tb_key_env->map_nid_nk[i].net_key_lid = p_m_tb_key_env->map_nid_nk[i + 1].net_key_lid;
    }

    // Sanity check
    ASSERT_INFO(p_m_tb_key_env->nb_nids, net_key_lid, 0);
   11872:	2d00      	cmp	r5, #0
   11874:	d100      	bne.n	11878 <m_tb_key_nid_tbl_del+0x50>
   11876:	e7fe      	b.n	11876 <m_tb_key_nid_tbl_del+0x4e>
   11878:	005b      	lsls	r3, r3, #1
   1187a:	18e3      	adds	r3, r4, r3

    // Clean last row
    p_m_tb_key_env->map_nid_nk[i].nid = 0;
   1187c:	001c      	movs	r4, r3
   1187e:	2200      	movs	r2, #0
   11880:	3440      	adds	r4, #64	; 0x40
    p_m_tb_key_env->map_nid_nk[i].net_key_lid = 0;
   11882:	3341      	adds	r3, #65	; 0x41

    // Sanity check
    ASSERT_INFO(p_m_tb_key_env->nb_nids, net_key_lid, 0);

    // Clean last row
    p_m_tb_key_env->map_nid_nk[i].nid = 0;
   11884:	7022      	strb	r2, [r4, #0]
    p_m_tb_key_env->map_nid_nk[i].net_key_lid = 0;
   11886:	701a      	strb	r2, [r3, #0]
    p_m_tb_key_env->nb_nids--;
   11888:	7008      	strb	r0, [r1, #0]
}
   1188a:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1188c:	100126c0 	.word	0x100126c0

00011890 <m_tb_key_aid_tbl_add>:
 ****************************************************************************************
 */
__STATIC void m_tb_key_aid_tbl_add(m_lid_t net_key_lid, m_lid_t app_key_lid, uint8_t aid)
{
    int8_t i;
    m_tb_key_env_t* p_env = p_m_tb_key_env;
   11890:	4b26      	ldr	r3, [pc, #152]	; (1192c <m_tb_key_aid_tbl_add+0x9c>)
 * @param[in] app_key_lid   Application Key Local identifier
 * @param[in] nid           Application Key AID
 ****************************************************************************************
 */
__STATIC void m_tb_key_aid_tbl_add(m_lid_t net_key_lid, m_lid_t app_key_lid, uint8_t aid)
{
   11892:	b5f0      	push	{r4, r5, r6, r7, lr}
    int8_t i;
    m_tb_key_env_t* p_env = p_m_tb_key_env;
   11894:	681c      	ldr	r4, [r3, #0]
 * @param[in] app_key_lid   Application Key Local identifier
 * @param[in] nid           Application Key AID
 ****************************************************************************************
 */
__STATIC void m_tb_key_aid_tbl_add(m_lid_t net_key_lid, m_lid_t app_key_lid, uint8_t aid)
{
   11896:	b085      	sub	sp, #20
    int8_t i;
    m_tb_key_env_t* p_env = p_m_tb_key_env;

    // browse list in reverse order
    for(i = p_env->nb_aids ; i > 0 ; i--)
   11898:	0023      	movs	r3, r4
 * @param[in] app_key_lid   Application Key Local identifier
 * @param[in] nid           Application Key AID
 ****************************************************************************************
 */
__STATIC void m_tb_key_aid_tbl_add(m_lid_t net_key_lid, m_lid_t app_key_lid, uint8_t aid)
{
   1189a:	9103      	str	r1, [sp, #12]
   1189c:	9202      	str	r2, [sp, #8]
    int8_t i;
    m_tb_key_env_t* p_env = p_m_tb_key_env;

    // browse list in reverse order
    for(i = p_env->nb_aids ; i > 0 ; i--)
   1189e:	33b6      	adds	r3, #182	; 0xb6
   118a0:	781b      	ldrb	r3, [r3, #0]
   118a2:	2104      	movs	r1, #4
   118a4:	9301      	str	r3, [sp, #4]
   118a6:	466b      	mov	r3, sp
    {
        // check if previous element has a greater network key local identifier than one to insert
        if (   (p_env->map_nk_ak[i-1].net_key_lid > net_key_lid)
   118a8:	2603      	movs	r6, #3
{
    int8_t i;
    m_tb_key_env_t* p_env = p_m_tb_key_env;

    // browse list in reverse order
    for(i = p_env->nb_aids ; i > 0 ; i--)
   118aa:	5659      	ldrsb	r1, [r3, r1]
   118ac:	2900      	cmp	r1, #0
   118ae:	dd09      	ble.n	118c4 <m_tb_key_aid_tbl_add+0x34>
    {
        // check if previous element has a greater network key local identifier than one to insert
        if (   (p_env->map_nk_ak[i-1].net_key_lid > net_key_lid)
   118b0:	0035      	movs	r5, r6
   118b2:	1e4b      	subs	r3, r1, #1
   118b4:	435d      	muls	r5, r3
   118b6:	1965      	adds	r5, r4, r5
   118b8:	002f      	movs	r7, r5
   118ba:	3748      	adds	r7, #72	; 0x48
   118bc:	783f      	ldrb	r7, [r7, #0]
   118be:	4287      	cmp	r7, r0
   118c0:	d819      	bhi.n	118f6 <m_tb_key_aid_tbl_add+0x66>
            || ((p_env->map_nk_ak[i-1].net_key_lid == net_key_lid) && (p_env->map_nk_ak[i-1].aid > aid)))
   118c2:	d013      	beq.n	118ec <m_tb_key_aid_tbl_add+0x5c>
            break;
        }
    }

    // Insert latest element
    p_env->map_nk_ak[i].aid         = aid;
   118c4:	2303      	movs	r3, #3
   118c6:	4359      	muls	r1, r3
   118c8:	466a      	mov	r2, sp
   118ca:	1861      	adds	r1, r4, r1
   118cc:	000b      	movs	r3, r1
   118ce:	7a12      	ldrb	r2, [r2, #8]
   118d0:	3349      	adds	r3, #73	; 0x49
   118d2:	701a      	strb	r2, [r3, #0]
    p_env->map_nk_ak[i].net_key_lid = net_key_lid;
   118d4:	3b01      	subs	r3, #1
   118d6:	7018      	strb	r0, [r3, #0]
    p_env->map_nk_ak[i].app_key_lid = app_key_lid;
   118d8:	466b      	mov	r3, sp
   118da:	7b1b      	ldrb	r3, [r3, #12]
   118dc:	314a      	adds	r1, #74	; 0x4a
   118de:	700b      	strb	r3, [r1, #0]
    p_env->nb_aids++;
   118e0:	9b01      	ldr	r3, [sp, #4]
   118e2:	34b6      	adds	r4, #182	; 0xb6
   118e4:	3301      	adds	r3, #1
   118e6:	7023      	strb	r3, [r4, #0]
}
   118e8:	b005      	add	sp, #20
   118ea:	bdf0      	pop	{r4, r5, r6, r7, pc}
    // browse list in reverse order
    for(i = p_env->nb_aids ; i > 0 ; i--)
    {
        // check if previous element has a greater network key local identifier than one to insert
        if (   (p_env->map_nk_ak[i-1].net_key_lid > net_key_lid)
            || ((p_env->map_nk_ak[i-1].net_key_lid == net_key_lid) && (p_env->map_nk_ak[i-1].aid > aid)))
   118ec:	3549      	adds	r5, #73	; 0x49
   118ee:	782d      	ldrb	r5, [r5, #0]
   118f0:	9a02      	ldr	r2, [sp, #8]
   118f2:	4295      	cmp	r5, r2
   118f4:	d9e6      	bls.n	118c4 <m_tb_key_aid_tbl_add+0x34>
        {
            // push element in next
            p_env->map_nk_ak[i].aid         = p_env->map_nk_ak[i-1].aid ;
   118f6:	4373      	muls	r3, r6
   118f8:	18e3      	adds	r3, r4, r3
   118fa:	001d      	movs	r5, r3
   118fc:	3549      	adds	r5, #73	; 0x49
   118fe:	782d      	ldrb	r5, [r5, #0]
   11900:	46ac      	mov	ip, r5
   11902:	0035      	movs	r5, r6
   11904:	434d      	muls	r5, r1
   11906:	1965      	adds	r5, r4, r5
   11908:	002f      	movs	r7, r5
   1190a:	4662      	mov	r2, ip
   1190c:	3749      	adds	r7, #73	; 0x49
   1190e:	703a      	strb	r2, [r7, #0]
            p_env->map_nk_ak[i].net_key_lid = p_env->map_nk_ak[i-1].net_key_lid;
   11910:	001f      	movs	r7, r3
   11912:	3748      	adds	r7, #72	; 0x48
   11914:	783a      	ldrb	r2, [r7, #0]
   11916:	002f      	movs	r7, r5
   11918:	3748      	adds	r7, #72	; 0x48
   1191a:	703a      	strb	r2, [r7, #0]
            p_env->map_nk_ak[i].app_key_lid = p_env->map_nk_ak[i-1].app_key_lid;
   1191c:	334a      	adds	r3, #74	; 0x4a
   1191e:	781b      	ldrb	r3, [r3, #0]
   11920:	354a      	adds	r5, #74	; 0x4a
   11922:	3901      	subs	r1, #1
   11924:	702b      	strb	r3, [r5, #0]
   11926:	b249      	sxtb	r1, r1
   11928:	e7c0      	b.n	118ac <m_tb_key_aid_tbl_add+0x1c>
   1192a:	46c0      	nop			; (mov r8, r8)
   1192c:	100126c0 	.word	0x100126c0

00011930 <m_tb_key_aid_tbl_del>:
 ****************************************************************************************
 */
__STATIC void m_tb_key_aid_tbl_del(m_lid_t net_key_lid, m_lid_t app_key_lid)
{
    int8_t i;
    m_tb_key_env_t* p_env = p_m_tb_key_env;
   11930:	4b24      	ldr	r3, [pc, #144]	; (119c4 <m_tb_key_aid_tbl_del+0x94>)
 * @param[in] app_key_lid   Application Key Local identifier
 * @param[in] nid           Application Key AID
 ****************************************************************************************
 */
__STATIC void m_tb_key_aid_tbl_del(m_lid_t net_key_lid, m_lid_t app_key_lid)
{
   11932:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    int8_t i;
    m_tb_key_env_t* p_env = p_m_tb_key_env;
   11934:	681c      	ldr	r4, [r3, #0]

    // browse list  to find position of the network key index
    for(i = 0 ; i < p_env->nb_aids ; i++)
    {
        if(   (p_env->map_nk_ak[i].net_key_lid == net_key_lid)
   11936:	2603      	movs	r6, #3
{
    int8_t i;
    m_tb_key_env_t* p_env = p_m_tb_key_env;

    // browse list  to find position of the network key index
    for(i = 0 ; i < p_env->nb_aids ; i++)
   11938:	0023      	movs	r3, r4
   1193a:	33b6      	adds	r3, #182	; 0xb6
   1193c:	9301      	str	r3, [sp, #4]
   1193e:	781d      	ldrb	r5, [r3, #0]
   11940:	2300      	movs	r3, #0
   11942:	42ab      	cmp	r3, r5
   11944:	da0b      	bge.n	1195e <m_tb_key_aid_tbl_del+0x2e>
    {
        if(   (p_env->map_nk_ak[i].net_key_lid == net_key_lid)
   11946:	0032      	movs	r2, r6
   11948:	435a      	muls	r2, r3
   1194a:	18a2      	adds	r2, r4, r2
   1194c:	0017      	movs	r7, r2
   1194e:	3748      	adds	r7, #72	; 0x48
   11950:	783f      	ldrb	r7, [r7, #0]
   11952:	4287      	cmp	r7, r0
   11954:	d105      	bne.n	11962 <m_tb_key_aid_tbl_del+0x32>
           && (p_env->map_nk_ak[i].app_key_lid == app_key_lid))
   11956:	324a      	adds	r2, #74	; 0x4a
   11958:	7812      	ldrb	r2, [r2, #0]
   1195a:	428a      	cmp	r2, r1
   1195c:	d101      	bne.n	11962 <m_tb_key_aid_tbl_del+0x32>
            break;
        }
    }

    // move following element in previous table row
    for( ; i < (p_env->nb_aids-1) ; i++)
   1195e:	1e69      	subs	r1, r5, #1
   11960:	e002      	b.n	11968 <m_tb_key_aid_tbl_del+0x38>
   11962:	3301      	adds	r3, #1
   11964:	b25b      	sxtb	r3, r3
   11966:	e7ec      	b.n	11942 <m_tb_key_aid_tbl_del+0x12>
   11968:	428b      	cmp	r3, r1
   1196a:	da1a      	bge.n	119a2 <m_tb_key_aid_tbl_del+0x72>
    {
        // update next element with temporary values
        p_env->map_nk_ak[i].aid         = p_env->map_nk_ak[i+1].aid;
   1196c:	2203      	movs	r2, #3
   1196e:	1c5e      	adds	r6, r3, #1
   11970:	4372      	muls	r2, r6
   11972:	18a2      	adds	r2, r4, r2
   11974:	0017      	movs	r7, r2
   11976:	2003      	movs	r0, #3
   11978:	3749      	adds	r7, #73	; 0x49
   1197a:	783f      	ldrb	r7, [r7, #0]
   1197c:	4343      	muls	r3, r0
   1197e:	46bc      	mov	ip, r7
   11980:	18e3      	adds	r3, r4, r3
   11982:	001f      	movs	r7, r3
   11984:	4660      	mov	r0, ip
   11986:	3749      	adds	r7, #73	; 0x49
   11988:	7038      	strb	r0, [r7, #0]
        p_env->map_nk_ak[i].net_key_lid = p_env->map_nk_ak[i+1].net_key_lid;
   1198a:	0017      	movs	r7, r2
   1198c:	3748      	adds	r7, #72	; 0x48
   1198e:	7838      	ldrb	r0, [r7, #0]
   11990:	001f      	movs	r7, r3
   11992:	3748      	adds	r7, #72	; 0x48
   11994:	7038      	strb	r0, [r7, #0]
        p_env->map_nk_ak[i].app_key_lid = p_env->map_nk_ak[i+1].app_key_lid;
   11996:	324a      	adds	r2, #74	; 0x4a
   11998:	7812      	ldrb	r2, [r2, #0]
   1199a:	334a      	adds	r3, #74	; 0x4a
   1199c:	701a      	strb	r2, [r3, #0]
   1199e:	b273      	sxtb	r3, r6
   119a0:	e7e2      	b.n	11968 <m_tb_key_aid_tbl_del+0x38>
    }

    // Sanity check
    ASSERT_INFO(p_env->nb_aids, net_key_lid, 0);
   119a2:	2d00      	cmp	r5, #0
   119a4:	d100      	bne.n	119a8 <m_tb_key_aid_tbl_del+0x78>
   119a6:	e7fe      	b.n	119a6 <m_tb_key_aid_tbl_del+0x76>

    // cleanup
    p_env->map_nk_ak[i].aid         = 0;
   119a8:	2203      	movs	r2, #3
   119aa:	4353      	muls	r3, r2
   119ac:	18e4      	adds	r4, r4, r3
   119ae:	0022      	movs	r2, r4
   119b0:	2300      	movs	r3, #0
   119b2:	3249      	adds	r2, #73	; 0x49
   119b4:	7013      	strb	r3, [r2, #0]
    p_env->map_nk_ak[i].net_key_lid = 0;
    p_env->map_nk_ak[i].app_key_lid = 0;
   119b6:	344a      	adds	r4, #74	; 0x4a
    // Sanity check
    ASSERT_INFO(p_env->nb_aids, net_key_lid, 0);

    // cleanup
    p_env->map_nk_ak[i].aid         = 0;
    p_env->map_nk_ak[i].net_key_lid = 0;
   119b8:	3a01      	subs	r2, #1
   119ba:	7013      	strb	r3, [r2, #0]
    p_env->map_nk_ak[i].app_key_lid = 0;
   119bc:	7023      	strb	r3, [r4, #0]
    p_env->nb_aids--;
   119be:	9b01      	ldr	r3, [sp, #4]
   119c0:	7019      	strb	r1, [r3, #0]
}
   119c2:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
   119c4:	100126c0 	.word	0x100126c0

000119c8 <m_tb_key_k1_ready_cb>:
__STATIC uint16_t m_tb_key_k1_ready_cb(uint8_t token_id, const uint8_t** pp_salt, const uint8_t** pp_n,
                                       uint8_t* p_n_len, const uint8_t** pp_p, uint8_t* p_p_len)
{
    // Returned status
    uint16_t status = M_ERR_COMMAND_DISALLOWED;
    m_tb_key_env_t *p_env = p_m_tb_key_env;
   119c8:	480d      	ldr	r0, [pc, #52]	; (11a00 <m_tb_key_k1_ready_cb+0x38>)
 * @return Status error code (@see enum m_error)
 ****************************************************************************************
 */
__STATIC uint16_t m_tb_key_k1_ready_cb(uint8_t token_id, const uint8_t** pp_salt, const uint8_t** pp_n,
                                       uint8_t* p_n_len, const uint8_t** pp_p, uint8_t* p_p_len)
{
   119ca:	b510      	push	{r4, lr}
    // Returned status
    uint16_t status = M_ERR_COMMAND_DISALLOWED;
    m_tb_key_env_t *p_env = p_m_tb_key_env;

    if (p_env->p_key_create != NULL)
   119cc:	6800      	ldr	r0, [r0, #0]
   119ce:	6b80      	ldr	r0, [r0, #56]	; 0x38
   119d0:	2800      	cmp	r0, #0
   119d2:	d013      	beq.n	119fc <m_tb_key_k1_ready_cb+0x34>
    {
        // Get key for which encryption is required
        m_tb_key_t *p_key = p_env->p_key_create;

        // Fill parameters for encryption function execution
        *pp_n = p_key->key;
   119d4:	1c84      	adds	r4, r0, #2
   119d6:	6014      	str	r4, [r2, #0]
        *p_n_len = M_KEY_LEN;
   119d8:	2210      	movs	r2, #16
   119da:	701a      	strb	r2, [r3, #0]
        *pp_p = m_tb_key_k1_p;
   119dc:	4b09      	ldr	r3, [pc, #36]	; (11a04 <m_tb_key_k1_ready_cb+0x3c>)
   119de:	9a02      	ldr	r2, [sp, #8]
   119e0:	001c      	movs	r4, r3
   119e2:	341a      	adds	r4, #26
   119e4:	6014      	str	r4, [r2, #0]
        *p_p_len = sizeof(m_tb_key_k1_p);
   119e6:	2206      	movs	r2, #6
   119e8:	9c03      	ldr	r4, [sp, #12]
   119ea:	7022      	strb	r2, [r4, #0]

        switch (p_key->state)
   119ec:	7842      	ldrb	r2, [r0, #1]
   119ee:	2a04      	cmp	r2, #4
   119f0:	d103      	bne.n	119fa <m_tb_key_k1_ready_cb+0x32>
            } break;
            #endif //(BLE_MESH_GATT_PROXY)

            case (M_TB_KEY_STATE_NET_GEN_BEACON):
            {
                *pp_salt = m_tb_key_k1_beacon_salt;
   119f2:	330a      	adds	r3, #10
   119f4:	600b      	str	r3, [r1, #0]
                // Not expected
                ASSERT_INFO(0, 0, 0);
            } break;
        }

        status = M_ERR_NO_ERROR;
   119f6:	2000      	movs	r0, #0
   119f8:	e001      	b.n	119fe <m_tb_key_k1_ready_cb+0x36>
   119fa:	e7fe      	b.n	119fa <m_tb_key_k1_ready_cb+0x32>
 */
__STATIC uint16_t m_tb_key_k1_ready_cb(uint8_t token_id, const uint8_t** pp_salt, const uint8_t** pp_n,
                                       uint8_t* p_n_len, const uint8_t** pp_p, uint8_t* p_p_len)
{
    // Returned status
    uint16_t status = M_ERR_COMMAND_DISALLOWED;
   119fc:	4802      	ldr	r0, [pc, #8]	; (11a08 <m_tb_key_k1_ready_cb+0x40>)

        status = M_ERR_NO_ERROR;
    }

    return (status);
}
   119fe:	bd10      	pop	{r4, pc}
   11a00:	100126c0 	.word	0x100126c0
   11a04:	00022644 	.word	0x00022644
   11a08:	00000282 	.word	0x00000282

00011a0c <m_tb_key_k2_ready_cb>:
 * @return Status error code (@see enum m_error)
 ****************************************************************************************
 */
__STATIC uint16_t m_tb_key_k2_ready_cb(uint8_t token_id, const uint8_t** pp_n, const uint8_t** pp_p,
                                       uint8_t* p_p_len)
{
   11a0c:	b5f0      	push	{r4, r5, r6, r7, lr}
   11a0e:	b085      	sub	sp, #20
   11a10:	9303      	str	r3, [sp, #12]
    // Returned status
    uint16_t status = M_ERR_COMMAND_DISALLOWED;
    m_tb_key_env_t *p_env = p_m_tb_key_env;
   11a12:	4b17      	ldr	r3, [pc, #92]	; (11a70 <m_tb_key_k2_ready_cb+0x64>)
 * @return Status error code (@see enum m_error)
 ****************************************************************************************
 */
__STATIC uint16_t m_tb_key_k2_ready_cb(uint8_t token_id, const uint8_t** pp_n, const uint8_t** pp_p,
                                       uint8_t* p_p_len)
{
   11a14:	000f      	movs	r7, r1
    // Returned status
    uint16_t status = M_ERR_COMMAND_DISALLOWED;
    m_tb_key_env_t *p_env = p_m_tb_key_env;

    if (p_env->p_key_create != NULL)
   11a16:	681b      	ldr	r3, [r3, #0]
 * @return Status error code (@see enum m_error)
 ****************************************************************************************
 */
__STATIC uint16_t m_tb_key_k2_ready_cb(uint8_t token_id, const uint8_t** pp_n, const uint8_t** pp_p,
                                       uint8_t* p_p_len)
{
   11a18:	0016      	movs	r6, r2
    // Returned status
    uint16_t status = M_ERR_COMMAND_DISALLOWED;
    m_tb_key_env_t *p_env = p_m_tb_key_env;

    if (p_env->p_key_create != NULL)
   11a1a:	6b9d      	ldr	r5, [r3, #56]	; 0x38
   11a1c:	2d00      	cmp	r5, #0
   11a1e:	d024      	beq.n	11a6a <m_tb_key_k2_ready_cb+0x5e>
    {
        // Get key for which encryption is required
        m_tb_key_t *p_key = p_env->p_key_create;
		M_PRINTF(L_AL, "p_key = %p key_type = 0x%02x", p_key, p_key->key_type);
   11a20:	4b14      	ldr	r3, [pc, #80]	; (11a74 <m_tb_key_k2_ready_cb+0x68>)
   11a22:	681b      	ldr	r3, [r3, #0]
   11a24:	07db      	lsls	r3, r3, #31
   11a26:	d516      	bpl.n	11a56 <m_tb_key_k2_ready_cb+0x4a>
   11a28:	4c13      	ldr	r4, [pc, #76]	; (11a78 <m_tb_key_k2_ready_cb+0x6c>)
   11a2a:	0023      	movs	r3, r4
   11a2c:	0022      	movs	r2, r4
   11a2e:	0020      	movs	r0, r4
   11a30:	3351      	adds	r3, #81	; 0x51
   11a32:	3237      	adds	r2, #55	; 0x37
   11a34:	9300      	str	r3, [sp, #0]
   11a36:	0021      	movs	r1, r4
   11a38:	4b10      	ldr	r3, [pc, #64]	; (11a7c <m_tb_key_k2_ready_cb+0x70>)
   11a3a:	3042      	adds	r0, #66	; 0x42
   11a3c:	f7f2 ffb6 	bl	49ac <m_print>
   11a40:	0020      	movs	r0, r4
   11a42:	0029      	movs	r1, r5
   11a44:	782a      	ldrb	r2, [r5, #0]
   11a46:	3066      	adds	r0, #102	; 0x66
   11a48:	f7f2 ffb0 	bl	49ac <m_print>
   11a4c:	480c      	ldr	r0, [pc, #48]	; (11a80 <m_tb_key_k2_ready_cb+0x74>)
   11a4e:	1da1      	adds	r1, r4, #6
   11a50:	3003      	adds	r0, #3
   11a52:	f7f2 ffab 	bl	49ac <m_print>
        // Fill parameters for encryption function execution
        *pp_n = p_key->key;
        *pp_p = m_tb_key_k2_p;
   11a56:	4b08      	ldr	r3, [pc, #32]	; (11a78 <m_tb_key_k2_ready_cb+0x6c>)
    {
        // Get key for which encryption is required
        m_tb_key_t *p_key = p_env->p_key_create;
		M_PRINTF(L_AL, "p_key = %p key_type = 0x%02x", p_key, p_key->key_type);
        // Fill parameters for encryption function execution
        *pp_n = p_key->key;
   11a58:	3502      	adds	r5, #2
        *pp_p = m_tb_key_k2_p;
   11a5a:	3309      	adds	r3, #9
    {
        // Get key for which encryption is required
        m_tb_key_t *p_key = p_env->p_key_create;
		M_PRINTF(L_AL, "p_key = %p key_type = 0x%02x", p_key, p_key->key_type);
        // Fill parameters for encryption function execution
        *pp_n = p_key->key;
   11a5c:	603d      	str	r5, [r7, #0]
        *pp_p = m_tb_key_k2_p;
   11a5e:	6033      	str	r3, [r6, #0]
        *p_p_len = sizeof(m_tb_key_k2_p);
   11a60:	2301      	movs	r3, #1
   11a62:	9a03      	ldr	r2, [sp, #12]

        status = M_ERR_NO_ERROR;
   11a64:	2000      	movs	r0, #0
        m_tb_key_t *p_key = p_env->p_key_create;
		M_PRINTF(L_AL, "p_key = %p key_type = 0x%02x", p_key, p_key->key_type);
        // Fill parameters for encryption function execution
        *pp_n = p_key->key;
        *pp_p = m_tb_key_k2_p;
        *p_p_len = sizeof(m_tb_key_k2_p);
   11a66:	7013      	strb	r3, [r2, #0]
   11a68:	e000      	b.n	11a6c <m_tb_key_k2_ready_cb+0x60>
 */
__STATIC uint16_t m_tb_key_k2_ready_cb(uint8_t token_id, const uint8_t** pp_n, const uint8_t** pp_p,
                                       uint8_t* p_p_len)
{
    // Returned status
    uint16_t status = M_ERR_COMMAND_DISALLOWED;
   11a6a:	4806      	ldr	r0, [pc, #24]	; (11a84 <m_tb_key_k2_ready_cb+0x78>)

        status = M_ERR_NO_ERROR;
    }

    return (status);
}
   11a6c:	b005      	add	sp, #20
   11a6e:	bdf0      	pop	{r4, r5, r6, r7, pc}
   11a70:	100126c0 	.word	0x100126c0
   11a74:	10010514 	.word	0x10010514
   11a78:	00022644 	.word	0x00022644
   11a7c:	00000405 	.word	0x00000405
   11a80:	000226c4 	.word	0x000226c4
   11a84:	00000282 	.word	0x00000282

00011a88 <m_tb_key_k3_ready_cb>:
   11a88:	b510      	push	{r4, lr}
   11a8a:	f000 f801 	bl	11a90 <m_tb_key_k4_ready_cb>
   11a8e:	bd10      	pop	{r4, pc}

00011a90 <m_tb_key_k4_ready_cb>:
 */
__STATIC uint16_t m_tb_key_k4_ready_cb(uint8_t token_id, const uint8_t** pp_n)
{
    // Returned status
    uint16_t status = M_ERR_COMMAND_DISALLOWED;
    m_tb_key_env_t *p_env = p_m_tb_key_env;
   11a90:	4b05      	ldr	r3, [pc, #20]	; (11aa8 <m_tb_key_k4_ready_cb+0x18>)

    if (p_env->p_key_create != NULL)
   11a92:	681b      	ldr	r3, [r3, #0]
   11a94:	6b9b      	ldr	r3, [r3, #56]	; 0x38
   11a96:	2b00      	cmp	r3, #0
   11a98:	d003      	beq.n	11aa2 <m_tb_key_k4_ready_cb+0x12>
    {
        // Get key for which encryption is required
        m_tb_key_t *p_key = p_env->p_key_create;

        // Fill parameters for encryption function execution
        *pp_n = p_key->key;
   11a9a:	3302      	adds	r3, #2
   11a9c:	600b      	str	r3, [r1, #0]

        status = M_ERR_NO_ERROR;
   11a9e:	2000      	movs	r0, #0
   11aa0:	e000      	b.n	11aa4 <m_tb_key_k4_ready_cb+0x14>
 ****************************************************************************************
 */
__STATIC uint16_t m_tb_key_k4_ready_cb(uint8_t token_id, const uint8_t** pp_n)
{
    // Returned status
    uint16_t status = M_ERR_COMMAND_DISALLOWED;
   11aa2:	4802      	ldr	r0, [pc, #8]	; (11aac <m_tb_key_k4_ready_cb+0x1c>)

        status = M_ERR_NO_ERROR;
    }

    return (status);
}
   11aa4:	4770      	bx	lr
   11aa6:	46c0      	nop			; (mov r8, r8)
   11aa8:	100126c0 	.word	0x100126c0
   11aac:	00000282 	.word	0x00000282

00011ab0 <m_tb_key_finished_cb>:
 *                      (@note length is variable and depends on security function used)
 *                      (@note equals NULL for AES-CCM encrypt and decrypt functions)
 ****************************************************************************************
 */
__STATIC void m_tb_key_finished_cb(uint8_t token_id, uint16_t status, const uint8_t* p_auth_val)
{
   11ab0:	b5f0      	push	{r4, r5, r6, r7, lr}
	
    m_tb_key_env_t *p_env = p_m_tb_key_env;
   11ab2:	4ba1      	ldr	r3, [pc, #644]	; (11d38 <m_tb_key_finished_cb+0x288>)
 *                      (@note length is variable and depends on security function used)
 *                      (@note equals NULL for AES-CCM encrypt and decrypt functions)
 ****************************************************************************************
 */
__STATIC void m_tb_key_finished_cb(uint8_t token_id, uint16_t status, const uint8_t* p_auth_val)
{
   11ab4:	b085      	sub	sp, #20
	
    m_tb_key_env_t *p_env = p_m_tb_key_env;
   11ab6:	681e      	ldr	r6, [r3, #0]
 *                      (@note length is variable and depends on security function used)
 *                      (@note equals NULL for AES-CCM encrypt and decrypt functions)
 ****************************************************************************************
 */
__STATIC void m_tb_key_finished_cb(uint8_t token_id, uint16_t status, const uint8_t* p_auth_val)
{
   11ab8:	9103      	str	r1, [sp, #12]
	
    m_tb_key_env_t *p_env = p_m_tb_key_env;
    bool finished = true;

    if (p_env->p_key_create != NULL)
   11aba:	6bb7      	ldr	r7, [r6, #56]	; 0x38
 *                      (@note length is variable and depends on security function used)
 *                      (@note equals NULL for AES-CCM encrypt and decrypt functions)
 ****************************************************************************************
 */
__STATIC void m_tb_key_finished_cb(uint8_t token_id, uint16_t status, const uint8_t* p_auth_val)
{
   11abc:	0015      	movs	r5, r2
	
    m_tb_key_env_t *p_env = p_m_tb_key_env;
    bool finished = true;

    if (p_env->p_key_create != NULL)
   11abe:	2f00      	cmp	r7, #0
   11ac0:	d100      	bne.n	11ac4 <m_tb_key_finished_cb+0x14>
   11ac2:	e137      	b.n	11d34 <m_tb_key_finished_cb+0x284>
    {
        // Get key for which encryption is required
        m_tb_key_t *p_key = p_env->p_key_create;
        m_lid_t key_lid = p_env->key_create_lid;
   11ac4:	0033      	movs	r3, r6
   11ac6:	33b4      	adds	r3, #180	; 0xb4
   11ac8:	781b      	ldrb	r3, [r3, #0]
   11aca:	9302      	str	r3, [sp, #8]
        m_tb_key_net_t *p_net_key = NULL;
		M_PRINTF(L_TB, "p_key = %p state = 0x%02x key_type = 0x%02x",p_key, p_key->state, p_key->key_type);
   11acc:	4b9b      	ldr	r3, [pc, #620]	; (11d3c <m_tb_key_finished_cb+0x28c>)
   11ace:	681b      	ldr	r3, [r3, #0]
   11ad0:	079b      	lsls	r3, r3, #30
   11ad2:	d517      	bpl.n	11b04 <m_tb_key_finished_cb+0x54>
   11ad4:	4c9a      	ldr	r4, [pc, #616]	; (11d40 <m_tb_key_finished_cb+0x290>)
   11ad6:	4b9b      	ldr	r3, [pc, #620]	; (11d44 <m_tb_key_finished_cb+0x294>)
   11ad8:	0022      	movs	r2, r4
   11ada:	0020      	movs	r0, r4
   11adc:	3306      	adds	r3, #6
   11ade:	3237      	adds	r2, #55	; 0x37
   11ae0:	9300      	str	r3, [sp, #0]
   11ae2:	0021      	movs	r1, r4
   11ae4:	4b98      	ldr	r3, [pc, #608]	; (11d48 <m_tb_key_finished_cb+0x298>)
   11ae6:	3042      	adds	r0, #66	; 0x42
   11ae8:	f7f2 ff60 	bl	49ac <m_print>
   11aec:	4895      	ldr	r0, [pc, #596]	; (11d44 <m_tb_key_finished_cb+0x294>)
   11aee:	783b      	ldrb	r3, [r7, #0]
   11af0:	0039      	movs	r1, r7
   11af2:	787a      	ldrb	r2, [r7, #1]
   11af4:	301b      	adds	r0, #27
   11af6:	f7f2 ff59 	bl	49ac <m_print>
   11afa:	4b92      	ldr	r3, [pc, #584]	; (11d44 <m_tb_key_finished_cb+0x294>)
   11afc:	1da1      	adds	r1, r4, #6
   11afe:	1cd8      	adds	r0, r3, #3
   11b00:	f7f2 ff54 	bl	49ac <m_print>
        switch (p_key->key_type)
   11b04:	783c      	ldrb	r4, [r7, #0]
   11b06:	2c01      	cmp	r4, #1
   11b08:	d003      	beq.n	11b12 <m_tb_key_finished_cb+0x62>
   11b0a:	2c02      	cmp	r4, #2
   11b0c:	d100      	bne.n	11b10 <m_tb_key_finished_cb+0x60>
   11b0e:	e0b8      	b.n	11c82 <m_tb_key_finished_cb+0x1d2>
   11b10:	e0fc      	b.n	11d0c <m_tb_key_finished_cb+0x25c>
        {
            case (M_TB_KEY_NETWORK):
            {
                p_net_key = (m_tb_key_net_t *)p_key;

                switch (p_key->state)
   11b12:	787c      	ldrb	r4, [r7, #1]
   11b14:	2c04      	cmp	r4, #4
   11b16:	d01d      	beq.n	11b54 <m_tb_key_finished_cb+0xa4>
   11b18:	2c05      	cmp	r4, #5
   11b1a:	d029      	beq.n	11b70 <m_tb_key_finished_cb+0xc0>
   11b1c:	2c03      	cmp	r4, #3
   11b1e:	d000      	beq.n	11b22 <m_tb_key_finished_cb+0x72>
   11b20:	e0f4      	b.n	11d0c <m_tb_key_finished_cb+0x25c>
                {
                    case (M_TB_KEY_STATE_NET_GEN_ENC):
                    {
                        // Copy generated privacy, encryption and NID
                        memcpy(p_net_key->priv_key, &p_auth_val[0], M_KEY_LEN);
   11b22:	0038      	movs	r0, r7
   11b24:	0029      	movs	r1, r5
   11b26:	2210      	movs	r2, #16
   11b28:	3022      	adds	r0, #34	; 0x22
   11b2a:	f003 ff51 	bl	159d0 <memcpy>
                        memcpy(p_net_key->enc_key, &p_auth_val[M_KEY_LEN], M_KEY_LEN);
   11b2e:	0038      	movs	r0, r7
   11b30:	0029      	movs	r1, r5
   11b32:	2210      	movs	r2, #16
   11b34:	3110      	adds	r1, #16
   11b36:	3012      	adds	r0, #18
   11b38:	f003 ff4a 	bl	159d0 <memcpy>
                        memcpy(&p_net_key->nid, &p_auth_val[2 * M_KEY_LEN], 1);
   11b3c:	003b      	movs	r3, r7
                    {
                        // Copy generated identity key
                        memcpy(p_net_key->identity, p_auth_val, M_KEY_LEN);
                    #endif //(BLE_MESH_GATT_PROXY)

                        p_key->state = M_TB_KEY_STATE_NET_GEN_BEACON;
   11b3e:	2004      	movs	r0, #4
                    case (M_TB_KEY_STATE_NET_GEN_ENC):
                    {
                        // Copy generated privacy, encryption and NID
                        memcpy(p_net_key->priv_key, &p_auth_val[0], M_KEY_LEN);
                        memcpy(p_net_key->enc_key, &p_auth_val[M_KEY_LEN], M_KEY_LEN);
                        memcpy(&p_net_key->nid, &p_auth_val[2 * M_KEY_LEN], 1);
   11b40:	3501      	adds	r5, #1
   11b42:	7fea      	ldrb	r2, [r5, #31]
   11b44:	3342      	adds	r3, #66	; 0x42
   11b46:	701a      	strb	r2, [r3, #0]

                        p_key->state = M_TB_KEY_STATE_NET_GEN_BEACON;
                        finished     = false;

                        // Execute K1 function
                        m_tb_sec_k1_start(M_TB_SEC_TOKEN_KEY_MANAGER, m_tb_key_k1_ready_cb, m_tb_key_finished_cb);
   11b48:	4980      	ldr	r1, [pc, #512]	; (11d4c <m_tb_key_finished_cb+0x29c>)
                    {
                        // Copy generated identity key
                        memcpy(p_net_key->identity, p_auth_val, M_KEY_LEN);
                    #endif //(BLE_MESH_GATT_PROXY)

                        p_key->state = M_TB_KEY_STATE_NET_GEN_BEACON;
   11b4a:	7078      	strb	r0, [r7, #1]
                        finished     = false;

                        // Execute K1 function
                        m_tb_sec_k1_start(M_TB_SEC_TOKEN_KEY_MANAGER, m_tb_key_k1_ready_cb, m_tb_key_finished_cb);
   11b4c:	4a80      	ldr	r2, [pc, #512]	; (11d50 <m_tb_key_finished_cb+0x2a0>)
   11b4e:	f002 fa36 	bl	13fbe <m_tb_sec_k1_start>
                    } break;
   11b52:	e0ef      	b.n	11d34 <m_tb_key_finished_cb+0x284>

                    case (M_TB_KEY_STATE_NET_GEN_BEACON):
                    {
                        // Copy generated beacon key
                        memcpy(p_net_key->beacon_key, p_auth_val, M_KEY_LEN);
   11b54:	0038      	movs	r0, r7
   11b56:	0029      	movs	r1, r5
   11b58:	2210      	movs	r2, #16
   11b5a:	3032      	adds	r0, #50	; 0x32
   11b5c:	f003 ff38 	bl	159d0 <memcpy>

                        p_key->state = M_TB_KEY_STATE_NET_GEN_N_ID;
   11b60:	2305      	movs	r3, #5
                        finished     = false;

                        // Execute K3 function
                        m_tb_sec_k3_start(M_TB_SEC_TOKEN_KEY_MANAGER, m_tb_key_k3_ready_cb, m_tb_key_finished_cb);
   11b62:	4a7b      	ldr	r2, [pc, #492]	; (11d50 <m_tb_key_finished_cb+0x2a0>)
                    case (M_TB_KEY_STATE_NET_GEN_BEACON):
                    {
                        // Copy generated beacon key
                        memcpy(p_net_key->beacon_key, p_auth_val, M_KEY_LEN);

                        p_key->state = M_TB_KEY_STATE_NET_GEN_N_ID;
   11b64:	707b      	strb	r3, [r7, #1]
                        finished     = false;

                        // Execute K3 function
                        m_tb_sec_k3_start(M_TB_SEC_TOKEN_KEY_MANAGER, m_tb_key_k3_ready_cb, m_tb_key_finished_cb);
   11b66:	497b      	ldr	r1, [pc, #492]	; (11d54 <m_tb_key_finished_cb+0x2a4>)
   11b68:	0020      	movs	r0, r4
   11b6a:	f002 fa36 	bl	13fda <m_tb_sec_k3_start>
                    } break;
   11b6e:	e0e1      	b.n	11d34 <m_tb_key_finished_cb+0x284>

                    case (M_TB_KEY_STATE_NET_GEN_N_ID):
                    {	
                        // Copy Network ID (LSB)
                        memcpy(&(p_net_key->net_id[0]), p_auth_val, M_NET_ID_LEN);
   11b70:	0038      	movs	r0, r7
   11b72:	2208      	movs	r2, #8
   11b74:	0029      	movs	r1, r5
   11b76:	3046      	adds	r0, #70	; 0x46
   11b78:	f003 ff2a 	bl	159d0 <memcpy>

                        // Put key info into the NID/NetKeyLID table
                        m_tb_key_nid_tbl_add(key_lid, p_net_key->nid);
   11b7c:	003b      	movs	r3, r7
   11b7e:	3342      	adds	r3, #66	; 0x42
   11b80:	7819      	ldrb	r1, [r3, #0]
   11b82:	9802      	ldr	r0, [sp, #8]
   11b84:	f7ff fe26 	bl	117d4 <m_tb_key_nid_tbl_add>

                        // Generation of a new network key
                        if (!GETB(key_lid, M_TB_KEY_NEW))
   11b88:	466b      	mov	r3, sp
   11b8a:	7a1b      	ldrb	r3, [r3, #8]
   11b8c:	496b      	ldr	r1, [pc, #428]	; (11d3c <m_tb_key_finished_cb+0x28c>)
   11b8e:	b25b      	sxtb	r3, r3
   11b90:	2202      	movs	r2, #2
   11b92:	2b00      	cmp	r3, #0
   11b94:	db32      	blt.n	11bfc <m_tb_key_finished_cb+0x14c>
                        {
                        	M_PRINTF(L_TB, "net Key is ready to be used");
   11b96:	680b      	ldr	r3, [r1, #0]
   11b98:	4213      	tst	r3, r2
   11b9a:	d014      	beq.n	11bc6 <m_tb_key_finished_cb+0x116>
   11b9c:	4d69      	ldr	r5, [pc, #420]	; (11d44 <m_tb_key_finished_cb+0x294>)
   11b9e:	4c68      	ldr	r4, [pc, #416]	; (11d40 <m_tb_key_finished_cb+0x290>)
   11ba0:	1dab      	adds	r3, r5, #6
   11ba2:	9300      	str	r3, [sp, #0]
   11ba4:	0022      	movs	r2, r4
   11ba6:	0020      	movs	r0, r4
   11ba8:	2394      	movs	r3, #148	; 0x94
   11baa:	0021      	movs	r1, r4
   11bac:	3237      	adds	r2, #55	; 0x37
   11bae:	00db      	lsls	r3, r3, #3
   11bb0:	3042      	adds	r0, #66	; 0x42
   11bb2:	f7f2 fefb 	bl	49ac <m_print>
   11bb6:	0028      	movs	r0, r5
   11bb8:	3047      	adds	r0, #71	; 0x47
   11bba:	f7f2 fef7 	bl	49ac <m_print>
   11bbe:	1da1      	adds	r1, r4, #6
   11bc0:	1ce8      	adds	r0, r5, #3
   11bc2:	f7f2 fef3 	bl	49ac <m_print>
                            // Key is ready to be used
                            p_key->state = M_TB_KEY_STATE_NORMAL;
   11bc6:	2300      	movs	r3, #0

                            // Store created key into database
                            p_env->p_keys[key_lid] = (m_tb_key_t *)p_key;
                            // Increment number of network keys
                            p_env->nb_net_keys++;
   11bc8:	0032      	movs	r2, r6
                        // Generation of a new network key
                        if (!GETB(key_lid, M_TB_KEY_NEW))
                        {
                        	M_PRINTF(L_TB, "net Key is ready to be used");
                            // Key is ready to be used
                            p_key->state = M_TB_KEY_STATE_NORMAL;
   11bca:	707b      	strb	r3, [r7, #1]

                            // Store created key into database
                            p_env->p_keys[key_lid] = (m_tb_key_t *)p_key;
   11bcc:	9b02      	ldr	r3, [sp, #8]
                            // Increment number of network keys
                            p_env->nb_net_keys++;
   11bce:	32b8      	adds	r2, #184	; 0xb8
                        	M_PRINTF(L_TB, "net Key is ready to be used");
                            // Key is ready to be used
                            p_key->state = M_TB_KEY_STATE_NORMAL;

                            // Store created key into database
                            p_env->p_keys[key_lid] = (m_tb_key_t *)p_key;
   11bd0:	009b      	lsls	r3, r3, #2
   11bd2:	519f      	str	r7, [r3, r6]
                            // Increment number of network keys
                            p_env->nb_net_keys++;
   11bd4:	7813      	ldrb	r3, [r2, #0]
   11bd6:	3301      	adds	r3, #1
   11bd8:	7013      	strb	r3, [r2, #0]

                            // Check if network key is a primary network key
                            if (p_net_key->net_key_id == M_TB_KEY_PRIM_NETKEY_ID)
   11bda:	1dbb      	adds	r3, r7, #6
   11bdc:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
   11bde:	2b00      	cmp	r3, #0
   11be0:	d103      	bne.n	11bea <m_tb_key_finished_cb+0x13a>
                            {
                                SETB(p_env->status, M_TB_KEY_STATUS_PRIM, 1);
   11be2:	2102      	movs	r1, #2
   11be4:	7853      	ldrb	r3, [r2, #1]
   11be6:	430b      	orrs	r3, r1
   11be8:	7053      	strb	r3, [r2, #1]
                            }

                            // Inform beaconing layer that a subnet has been added
                            m_bcn_subnet_update_ind(key_lid, true);
   11bea:	9802      	ldr	r0, [sp, #8]
   11bec:	2101      	movs	r1, #1
   11bee:	f7f7 fec7 	bl	9980 <m_bcn_subnet_update_ind>

                            // Inform the storage manager about the update
                            m_tb_store_update_ind(M_TB_STORE_UPD_TYPE_NET_KEY_UPDATED, key_lid);
   11bf2:	9902      	ldr	r1, [sp, #8]
   11bf4:	2000      	movs	r0, #0
   11bf6:	f003 f80f 	bl	14c18 <m_tb_store_update_ind>
   11bfa:	e08a      	b.n	11d12 <m_tb_key_finished_cb+0x262>
                        }
                        // Update of an existing network key
                        else
                        {
                        	M_PRINTF(L_TB, "new net Key ");
   11bfc:	680b      	ldr	r3, [r1, #0]
   11bfe:	4213      	tst	r3, r2
   11c00:	d014      	beq.n	11c2c <m_tb_key_finished_cb+0x17c>
   11c02:	4d50      	ldr	r5, [pc, #320]	; (11d44 <m_tb_key_finished_cb+0x294>)
   11c04:	4c4e      	ldr	r4, [pc, #312]	; (11d40 <m_tb_key_finished_cb+0x290>)
   11c06:	1dab      	adds	r3, r5, #6
   11c08:	9300      	str	r3, [sp, #0]
   11c0a:	0022      	movs	r2, r4
   11c0c:	0020      	movs	r0, r4
   11c0e:	2397      	movs	r3, #151	; 0x97
   11c10:	0021      	movs	r1, r4
   11c12:	3237      	adds	r2, #55	; 0x37
   11c14:	00db      	lsls	r3, r3, #3
   11c16:	3042      	adds	r0, #66	; 0x42
   11c18:	f7f2 fec8 	bl	49ac <m_print>
   11c1c:	0028      	movs	r0, r5
   11c1e:	3063      	adds	r0, #99	; 0x63
   11c20:	f7f2 fec4 	bl	49ac <m_print>
   11c24:	1da1      	adds	r1, r4, #6
   11c26:	1ce8      	adds	r0, r5, #3
   11c28:	f7f2 fec0 	bl	49ac <m_print>
                            m_lid_t base_lid = GETF(key_lid, M_TB_KEY_LID);
   11c2c:	247f      	movs	r4, #127	; 0x7f
   11c2e:	9b02      	ldr	r3, [sp, #8]
   11c30:	4023      	ands	r3, r4
   11c32:	001c      	movs	r4, r3
                            m_tb_key_net_t *p_old_net_key = (m_tb_key_net_t *)p_env->p_keys[base_lid];
   11c34:	009b      	lsls	r3, r3, #2
   11c36:	599d      	ldr	r5, [r3, r6]

                            if (p_env->p_up == NULL)
   11c38:	6b73      	ldr	r3, [r6, #52]	; 0x34
   11c3a:	9302      	str	r3, [sp, #8]
   11c3c:	2b00      	cmp	r3, #0
   11c3e:	d107      	bne.n	11c50 <m_tb_key_finished_cb+0x1a0>
                            {
                                // Allocate update structure
                                p_env->p_up = (m_tb_key_up_t *)m_al_malloc(sizeof(m_tb_key_up_t));
   11c40:	2038      	movs	r0, #56	; 0x38
   11c42:	f7f3 fcc6 	bl	55d2 <m_al_malloc>
                                memset(p_env->p_up, 0, sizeof(m_tb_key_up_t));
   11c46:	2238      	movs	r2, #56	; 0x38
                            m_tb_key_net_t *p_old_net_key = (m_tb_key_net_t *)p_env->p_keys[base_lid];

                            if (p_env->p_up == NULL)
                            {
                                // Allocate update structure
                                p_env->p_up = (m_tb_key_up_t *)m_al_malloc(sizeof(m_tb_key_up_t));
   11c48:	6370      	str	r0, [r6, #52]	; 0x34
                                memset(p_env->p_up, 0, sizeof(m_tb_key_up_t));
   11c4a:	9902      	ldr	r1, [sp, #8]
   11c4c:	f003 fefe 	bl	15a4c <memset>
                            }

                            p_net_key->net_key_id = p_old_net_key->net_key_id;
   11c50:	1dab      	adds	r3, r5, #6
   11c52:	8fda      	ldrh	r2, [r3, #62]	; 0x3e
   11c54:	1dbb      	adds	r3, r7, #6
   11c56:	87da      	strh	r2, [r3, #62]	; 0x3e
                            p_net_key->nb_app_keys = p_old_net_key->nb_app_keys;
   11c58:	002b      	movs	r3, r5
   11c5a:	334e      	adds	r3, #78	; 0x4e
   11c5c:	781a      	ldrb	r2, [r3, #0]
   11c5e:	003b      	movs	r3, r7
   11c60:	334e      	adds	r3, #78	; 0x4e
   11c62:	701a      	strb	r2, [r3, #0]
                            p_net_key->state = M_TB_KEY_STATE_NORMAL;
   11c64:	2000      	movs	r0, #0
                            p_old_net_key->state = M_TB_KEY_STATE_P1;
   11c66:	2301      	movs	r3, #1
                                memset(p_env->p_up, 0, sizeof(m_tb_key_up_t));
                            }

                            p_net_key->net_key_id = p_old_net_key->net_key_id;
                            p_net_key->nb_app_keys = p_old_net_key->nb_app_keys;
                            p_net_key->state = M_TB_KEY_STATE_NORMAL;
   11c68:	7078      	strb	r0, [r7, #1]
                            p_old_net_key->state = M_TB_KEY_STATE_P1;
   11c6a:	706b      	strb	r3, [r5, #1]

                            // store key and current key under creation
                            p_env->p_up->p_keys[base_lid] = (m_tb_key_t *)p_net_key;
   11c6c:	6b73      	ldr	r3, [r6, #52]	; 0x34
   11c6e:	00a2      	lsls	r2, r4, #2
   11c70:	509f      	str	r7, [r3, r2]
                            p_env->p_up->nb_key++;
   11c72:	3334      	adds	r3, #52	; 0x34
   11c74:	781a      	ldrb	r2, [r3, #0]

                            // Inform the storage manager about the update
                            m_tb_store_update_ind(M_TB_STORE_UPD_TYPE_NET_KEY_UPDATED, base_lid);
   11c76:	0021      	movs	r1, r4
                            p_net_key->state = M_TB_KEY_STATE_NORMAL;
                            p_old_net_key->state = M_TB_KEY_STATE_P1;

                            // store key and current key under creation
                            p_env->p_up->p_keys[base_lid] = (m_tb_key_t *)p_net_key;
                            p_env->p_up->nb_key++;
   11c78:	3201      	adds	r2, #1
   11c7a:	701a      	strb	r2, [r3, #0]

                            // Inform the storage manager about the update
                            m_tb_store_update_ind(M_TB_STORE_UPD_TYPE_NET_KEY_UPDATED, base_lid);
   11c7c:	f002 ffcc 	bl	14c18 <m_tb_store_update_ind>
   11c80:	e047      	b.n	11d12 <m_tb_key_finished_cb+0x262>
                }
            } break;

            case (M_TB_KEY_APPLICATION):
            {
            	m_printf_hex(L_TB, "application key finished", p_auth_val, 1);
   11c82:	4930      	ldr	r1, [pc, #192]	; (11d44 <m_tb_key_finished_cb+0x294>)
   11c84:	2301      	movs	r3, #1
   11c86:	002a      	movs	r2, r5
   11c88:	3170      	adds	r1, #112	; 0x70
   11c8a:	0020      	movs	r0, r4
   11c8c:	f7f2 feee 	bl	4a6c <m_printf_hex>
                if (p_key->state == M_TB_KEY_STATE_APP_GEN_AID)
   11c90:	787b      	ldrb	r3, [r7, #1]
   11c92:	2b06      	cmp	r3, #6
   11c94:	d13a      	bne.n	11d0c <m_tb_key_finished_cb+0x25c>
                {
                    // Map key to an application key
                    m_tb_key_app_t *p_app_key = (m_tb_key_app_t *)p_key;

                    // Copy generation AID
                    memcpy(&p_app_key->aid, p_auth_val, 1);
   11c96:	782b      	ldrb	r3, [r5, #0]
   11c98:	74fb      	strb	r3, [r7, #19]

                    // Key is ready to be used
                    p_key->state = M_TB_KEY_STATE_NORMAL;
   11c9a:	2300      	movs	r3, #0
   11c9c:	707b      	strb	r3, [r7, #1]

                    // Check if AID has been generated for current key or updated key
                    if (!GETB(key_lid, M_TB_KEY_NEW))
   11c9e:	466b      	mov	r3, sp
   11ca0:	7a1b      	ldrb	r3, [r3, #8]
   11ca2:	b25b      	sxtb	r3, r3
   11ca4:	2b00      	cmp	r3, #0
   11ca6:	db13      	blt.n	11cd0 <m_tb_key_finished_cb+0x220>
                    {
                        // Store created key
                        p_env->p_keys[key_lid] = (m_tb_key_t *)p_key;
   11ca8:	9b02      	ldr	r3, [sp, #8]
                        // Get network key information and increase number of application keys bound with the key
                        p_net_key = (m_tb_key_net_t *)p_env->p_keys[p_app_key->net_key_lid];
                        p_net_key->nb_app_keys++;

                        // Put key info into the NetKeyLID/AID/AppKeyLID table
                        m_tb_key_aid_tbl_add(p_app_key->net_key_lid, key_lid, p_app_key->aid);
   11caa:	9902      	ldr	r1, [sp, #8]

                    // Check if AID has been generated for current key or updated key
                    if (!GETB(key_lid, M_TB_KEY_NEW))
                    {
                        // Store created key
                        p_env->p_keys[key_lid] = (m_tb_key_t *)p_key;
   11cac:	009b      	lsls	r3, r3, #2
   11cae:	519f      	str	r7, [r3, r6]

                        // Get network key information and increase number of application keys bound with the key
                        p_net_key = (m_tb_key_net_t *)p_env->p_keys[p_app_key->net_key_lid];
   11cb0:	7dbb      	ldrb	r3, [r7, #22]
   11cb2:	009b      	lsls	r3, r3, #2
   11cb4:	599b      	ldr	r3, [r3, r6]
                        p_net_key->nb_app_keys++;
   11cb6:	334e      	adds	r3, #78	; 0x4e
   11cb8:	781a      	ldrb	r2, [r3, #0]
   11cba:	3201      	adds	r2, #1
   11cbc:	701a      	strb	r2, [r3, #0]

                        // Put key info into the NetKeyLID/AID/AppKeyLID table
                        m_tb_key_aid_tbl_add(p_app_key->net_key_lid, key_lid, p_app_key->aid);
   11cbe:	7db8      	ldrb	r0, [r7, #22]
   11cc0:	7cfa      	ldrb	r2, [r7, #19]
   11cc2:	f7ff fde5 	bl	11890 <m_tb_key_aid_tbl_add>

                        // Inform the storage manager about the update
                        m_tb_store_update_ind(M_TB_STORE_UPD_TYPE_APP_KEY_UPDATED, key_lid);
   11cc6:	9902      	ldr	r1, [sp, #8]
   11cc8:	0020      	movs	r0, r4
   11cca:	f002 ffa5 	bl	14c18 <m_tb_store_update_ind>
   11cce:	e020      	b.n	11d12 <m_tb_key_finished_cb+0x262>
                    }
                    else
                    {
                        // Get current application key
                        m_lid_t base_lid = GETF(key_lid, M_TB_KEY_LID);
   11cd0:	257f      	movs	r5, #127	; 0x7f
   11cd2:	9b02      	ldr	r3, [sp, #8]
   11cd4:	401d      	ands	r5, r3
                        m_tb_key_app_t *p_old_app_key = (m_tb_key_app_t *)p_env->p_keys[base_lid];
   11cd6:	00aa      	lsls	r2, r5, #2
   11cd8:	5993      	ldr	r3, [r2, r6]

                        // Set key information
                        p_app_key->app_key_id  = p_old_app_key->app_key_id;
   11cda:	8a99      	ldrh	r1, [r3, #20]
   11cdc:	82b9      	strh	r1, [r7, #20]
                        p_app_key->net_key_lid = p_old_app_key->net_key_lid;
   11cde:	7d99      	ldrb	r1, [r3, #22]
   11ce0:	75b9      	strb	r1, [r7, #22]
                        p_app_key->nb_models   = p_old_app_key->nb_models;
   11ce2:	7c9b      	ldrb	r3, [r3, #18]
   11ce4:	74bb      	strb	r3, [r7, #18]

                        // Store the generated key
                        ASSERT_ERR(p_env->p_up != NULL);
   11ce6:	6b73      	ldr	r3, [r6, #52]	; 0x34
   11ce8:	2b00      	cmp	r3, #0
   11cea:	d100      	bne.n	11cee <m_tb_key_finished_cb+0x23e>
   11cec:	e7fe      	b.n	11cec <m_tb_key_finished_cb+0x23c>
                        p_env->p_up->p_keys[base_lid] = (m_tb_key_t *)p_app_key;
   11cee:	509f      	str	r7, [r3, r2]
                        p_env->p_up->nb_key++;
   11cf0:	3334      	adds	r3, #52	; 0x34
   11cf2:	781a      	ldrb	r2, [r3, #0]

                        // Put key info into the NetKeyLID/AID/AppKeyLID table
                        m_tb_key_aid_tbl_add(p_app_key->net_key_lid, key_lid, p_app_key->aid);
   11cf4:	9902      	ldr	r1, [sp, #8]
                        p_app_key->nb_models   = p_old_app_key->nb_models;

                        // Store the generated key
                        ASSERT_ERR(p_env->p_up != NULL);
                        p_env->p_up->p_keys[base_lid] = (m_tb_key_t *)p_app_key;
                        p_env->p_up->nb_key++;
   11cf6:	3201      	adds	r2, #1
   11cf8:	701a      	strb	r2, [r3, #0]

                        // Put key info into the NetKeyLID/AID/AppKeyLID table
                        m_tb_key_aid_tbl_add(p_app_key->net_key_lid, key_lid, p_app_key->aid);
   11cfa:	7db8      	ldrb	r0, [r7, #22]
   11cfc:	7cfa      	ldrb	r2, [r7, #19]
   11cfe:	f7ff fdc7 	bl	11890 <m_tb_key_aid_tbl_add>

                        // Inform the storage manager about the update
                        m_tb_store_update_ind(M_TB_STORE_UPD_TYPE_APP_KEY_UPDATED, base_lid);
   11d02:	0029      	movs	r1, r5
   11d04:	0020      	movs	r0, r4
   11d06:	f002 ff87 	bl	14c18 <m_tb_store_update_ind>
   11d0a:	e002      	b.n	11d12 <m_tb_key_finished_cb+0x262>
                    }
                }
                else
                {
                    status = M_ERR_INVALID_PARAM;
   11d0c:	23c1      	movs	r3, #193	; 0xc1
   11d0e:	005b      	lsls	r3, r3, #1
   11d10:	9303      	str	r3, [sp, #12]
 ****************************************************************************************
 */
__STATIC void m_tb_key_create_end(uint16_t status)
{
    // Allow creation of another key
    SETB(p_m_tb_key_env->status, M_TB_KEY_STATE_KEY_GEN, 0);
   11d12:	4b09      	ldr	r3, [pc, #36]	; (11d38 <m_tb_key_finished_cb+0x288>)
   11d14:	2008      	movs	r0, #8
   11d16:	681b      	ldr	r3, [r3, #0]
   11d18:	0019      	movs	r1, r3
   11d1a:	31b9      	adds	r1, #185	; 0xb9
   11d1c:	780a      	ldrb	r2, [r1, #0]
   11d1e:	4382      	bics	r2, r0
   11d20:	700a      	strb	r2, [r1, #0]

    p_m_tb_key_env->p_key_create = NULL;
   11d22:	2200      	movs	r2, #0
   11d24:	639a      	str	r2, [r3, #56]	; 0x38

    // Call generation callback
    if (p_m_tb_key_env->cb_create != NULL)
   11d26:	6bda      	ldr	r2, [r3, #60]	; 0x3c
   11d28:	2a00      	cmp	r2, #0
   11d2a:	d003      	beq.n	11d34 <m_tb_key_finished_cb+0x284>
    {
        p_m_tb_key_env->cb_create(status, p_m_tb_key_env->key_create_lid);
   11d2c:	33b4      	adds	r3, #180	; 0xb4
   11d2e:	7819      	ldrb	r1, [r3, #0]
   11d30:	9803      	ldr	r0, [sp, #12]
   11d32:	4790      	blx	r2
        if (finished)
        {
            m_tb_key_create_end(status);
        }
    }
}
   11d34:	b005      	add	sp, #20
   11d36:	bdf0      	pop	{r4, r5, r6, r7, pc}
   11d38:	100126c0 	.word	0x100126c0
   11d3c:	10010514 	.word	0x10010514
   11d40:	00022644 	.word	0x00022644
   11d44:	000226c4 	.word	0x000226c4
   11d48:	00000464 	.word	0x00000464
   11d4c:	000119c9 	.word	0x000119c9
   11d50:	00011ab1 	.word	0x00011ab1
   11d54:	00011a89 	.word	0x00011a89

00011d58 <m_tb_key_init>:
 * EXPORTED FUNCTIONS DEFINITIONS
 ****************************************************************************************
 */

uint16_t m_tb_key_init(bool reset, void *p_env, const m_cfg_t *p_cfg)
{
   11d58:	b570      	push	{r4, r5, r6, lr}
   11d5a:	000b      	movs	r3, r1
   11d5c:	4c19      	ldr	r4, [pc, #100]	; (11dc4 <m_tb_key_init+0x6c>)
    if (!reset)
   11d5e:	2800      	cmp	r0, #0
   11d60:	d106      	bne.n	11d70 <m_tb_key_init+0x18>
    {
        // Keep address of allocated environment
        p_m_tb_key_env = p_env;
   11d62:	6021      	str	r1, [r4, #0]

        // Initialize environment content
        memset(p_m_tb_key_env, 0, sizeof(m_tb_key_env_t));
   11d64:	22bc      	movs	r2, #188	; 0xbc
   11d66:	0001      	movs	r1, r0
   11d68:	0018      	movs	r0, r3
   11d6a:	f003 fe6f 	bl	15a4c <memset>
   11d6e:	e026      	b.n	11dbe <m_tb_key_init+0x66>
    {
        // Counter
        m_lid_t i;

        // Free structure used during creation of a key
        if (p_m_tb_key_env->p_key_create != NULL)
   11d70:	6823      	ldr	r3, [r4, #0]
   11d72:	6b98      	ldr	r0, [r3, #56]	; 0x38
   11d74:	2800      	cmp	r0, #0
   11d76:	d001      	beq.n	11d7c <m_tb_key_init+0x24>
        {
            m_al_free(p_m_tb_key_env->p_key_create);
   11d78:	f7f3 fc30 	bl	55dc <m_al_free>
        }

        // Clean-up structure used during a key update procedure
        if (p_m_tb_key_env->p_up != NULL)
   11d7c:	6823      	ldr	r3, [r4, #0]
   11d7e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
   11d80:	2b00      	cmp	r3, #0
   11d82:	d00f      	beq.n	11da4 <m_tb_key_init+0x4c>
   11d84:	2500      	movs	r5, #0
        {
            for (i = 0 ; i < (M_TB_KEY_MAX_NB_DEV + M_TB_KEY_MAX_NB_NET + M_TB_KEY_MAX_NB_APP) ; i++)
            {
                if (p_m_tb_key_env->p_up->p_keys[i] != NULL)
   11d86:	6823      	ldr	r3, [r4, #0]
   11d88:	00aa      	lsls	r2, r5, #2
   11d8a:	6b5b      	ldr	r3, [r3, #52]	; 0x34
   11d8c:	58d0      	ldr	r0, [r2, r3]
   11d8e:	2800      	cmp	r0, #0
   11d90:	d001      	beq.n	11d96 <m_tb_key_init+0x3e>
                {
                    m_al_free(p_m_tb_key_env->p_up->p_keys[i]);
   11d92:	f7f3 fc23 	bl	55dc <m_al_free>
   11d96:	3501      	adds	r5, #1
        }

        // Clean-up structure used during a key update procedure
        if (p_m_tb_key_env->p_up != NULL)
        {
            for (i = 0 ; i < (M_TB_KEY_MAX_NB_DEV + M_TB_KEY_MAX_NB_NET + M_TB_KEY_MAX_NB_APP) ; i++)
   11d98:	2d0d      	cmp	r5, #13
   11d9a:	d1f4      	bne.n	11d86 <m_tb_key_init+0x2e>
                {
                    m_al_free(p_m_tb_key_env->p_up->p_keys[i]);
                }
            }

            m_al_free(p_m_tb_key_env->p_up);
   11d9c:	6823      	ldr	r3, [r4, #0]
   11d9e:	6b58      	ldr	r0, [r3, #52]	; 0x34
   11da0:	f7f3 fc1c 	bl	55dc <m_al_free>
   11da4:	2500      	movs	r5, #0
        }

        // Clean-up all keys
        for (i = 0 ; i < (M_TB_KEY_MAX_NB_DEV + M_TB_KEY_MAX_NB_NET + M_TB_KEY_MAX_NB_APP) ; i++)
        {
            if (p_m_tb_key_env->p_keys[i] != NULL)
   11da6:	6822      	ldr	r2, [r4, #0]
   11da8:	00ab      	lsls	r3, r5, #2
   11daa:	5898      	ldr	r0, [r3, r2]
   11dac:	2800      	cmp	r0, #0
   11dae:	d001      	beq.n	11db4 <m_tb_key_init+0x5c>
            {
                m_al_free(p_m_tb_key_env->p_keys[i]);
   11db0:	f7f3 fc14 	bl	55dc <m_al_free>
   11db4:	3501      	adds	r5, #1

            m_al_free(p_m_tb_key_env->p_up);
        }

        // Clean-up all keys
        for (i = 0 ; i < (M_TB_KEY_MAX_NB_DEV + M_TB_KEY_MAX_NB_NET + M_TB_KEY_MAX_NB_APP) ; i++)
   11db6:	2d0d      	cmp	r5, #13
   11db8:	d1f5      	bne.n	11da6 <m_tb_key_init+0x4e>
        {
            m_tb_key_friend_end_ind(i);
        }
        #endif //(BLE_MESH_FRIEND || BLE_MESH_LPN)

        p_m_tb_key_env = NULL;
   11dba:	2300      	movs	r3, #0
   11dbc:	6023      	str	r3, [r4, #0]
    }

    return (sizeof(m_tb_key_env_t));
}
   11dbe:	20bc      	movs	r0, #188	; 0xbc
   11dc0:	bd70      	pop	{r4, r5, r6, pc}
   11dc2:	46c0      	nop			; (mov r8, r8)
   11dc4:	100126c0 	.word	0x100126c0

00011dc8 <m_tb_key_get_env_size>:

uint16_t m_tb_key_get_env_size(const m_cfg_t* p_cfg)
{
    return (sizeof(m_tb_key_env_t));
}
   11dc8:	20bc      	movs	r0, #188	; 0xbc
   11dca:	4770      	bx	lr

00011dcc <m_tb_key_dev_add>:

uint16_t m_tb_key_dev_add(const uint8_t *p_dev_key)
{
	M_PRINTF(L_TB, "");
   11dcc:	4b1a      	ldr	r3, [pc, #104]	; (11e38 <m_tb_key_dev_add+0x6c>)
{
    return (sizeof(m_tb_key_env_t));
}

uint16_t m_tb_key_dev_add(const uint8_t *p_dev_key)
{
   11dce:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	M_PRINTF(L_TB, "");
   11dd0:	681b      	ldr	r3, [r3, #0]
{
    return (sizeof(m_tb_key_env_t));
}

uint16_t m_tb_key_dev_add(const uint8_t *p_dev_key)
{
   11dd2:	0005      	movs	r5, r0
	M_PRINTF(L_TB, "");
   11dd4:	079b      	lsls	r3, r3, #30
   11dd6:	d515      	bpl.n	11e04 <m_tb_key_dev_add+0x38>
   11dd8:	4e18      	ldr	r6, [pc, #96]	; (11e3c <m_tb_key_dev_add+0x70>)
   11dda:	4c19      	ldr	r4, [pc, #100]	; (11e40 <m_tb_key_dev_add+0x74>)
   11ddc:	0033      	movs	r3, r6
   11dde:	0022      	movs	r2, r4
   11de0:	0020      	movs	r0, r4
   11de2:	3309      	adds	r3, #9
   11de4:	0021      	movs	r1, r4
   11de6:	3237      	adds	r2, #55	; 0x37
   11de8:	9300      	str	r3, [sp, #0]
   11dea:	3042      	adds	r0, #66	; 0x42
   11dec:	4b15      	ldr	r3, [pc, #84]	; (11e44 <m_tb_key_dev_add+0x78>)
   11dee:	f7f2 fddd 	bl	49ac <m_print>
   11df2:	0030      	movs	r0, r6
   11df4:	301a      	adds	r0, #26
   11df6:	f7f2 fdd9 	bl	49ac <m_print>
   11dfa:	4813      	ldr	r0, [pc, #76]	; (11e48 <m_tb_key_dev_add+0x7c>)
   11dfc:	1da1      	adds	r1, r4, #6
   11dfe:	3003      	adds	r0, #3
   11e00:	f7f2 fdd4 	bl	49ac <m_print>
    uint16_t status = M_ERR_CANNOT_SET;
   11e04:	20f8      	movs	r0, #248	; 0xf8
    m_tb_key_env_t *p_env = p_m_tb_key_env;
   11e06:	4b11      	ldr	r3, [pc, #68]	; (11e4c <m_tb_key_dev_add+0x80>)
}

uint16_t m_tb_key_dev_add(const uint8_t *p_dev_key)
{
	M_PRINTF(L_TB, "");
    uint16_t status = M_ERR_CANNOT_SET;
   11e08:	0100      	lsls	r0, r0, #4
    m_tb_key_env_t *p_env = p_m_tb_key_env;
   11e0a:	681f      	ldr	r7, [r3, #0]

    if (p_env->p_keys[M_TB_KEY_DEVICE_LID] == NULL)
   11e0c:	683c      	ldr	r4, [r7, #0]
   11e0e:	2c00      	cmp	r4, #0
   11e10:	d110      	bne.n	11e34 <m_tb_key_dev_add+0x68>
    {
        m_tb_key_dev_t *p_key = (m_tb_key_dev_t*)m_al_malloc(sizeof(m_tb_key_dev_t));
   11e12:	2013      	movs	r0, #19
   11e14:	f7f3 fbdd 	bl	55d2 <m_al_malloc>

        memcpy(p_key->key, p_dev_key, M_KEY_LEN);
   11e18:	2210      	movs	r2, #16
    uint16_t status = M_ERR_CANNOT_SET;
    m_tb_key_env_t *p_env = p_m_tb_key_env;

    if (p_env->p_keys[M_TB_KEY_DEVICE_LID] == NULL)
    {
        m_tb_key_dev_t *p_key = (m_tb_key_dev_t*)m_al_malloc(sizeof(m_tb_key_dev_t));
   11e1a:	0006      	movs	r6, r0

        memcpy(p_key->key, p_dev_key, M_KEY_LEN);
   11e1c:	0029      	movs	r1, r5
   11e1e:	3002      	adds	r0, #2
   11e20:	f003 fdd6 	bl	159d0 <memcpy>

        p_env->p_keys[M_TB_KEY_DEVICE_LID] = (m_tb_key_t*)p_key;
        status = M_ERR_NO_ERROR;

        // Inform the storage manager about the update
        m_tb_store_update_ind(M_TB_STORE_UPD_TYPE_STATE, M_TB_STORE_TYPE_DEV_KEY);
   11e24:	2107      	movs	r1, #7
    if (p_env->p_keys[M_TB_KEY_DEVICE_LID] == NULL)
    {
        m_tb_key_dev_t *p_key = (m_tb_key_dev_t*)m_al_malloc(sizeof(m_tb_key_dev_t));

        memcpy(p_key->key, p_dev_key, M_KEY_LEN);
        p_key->key_type = M_TB_KEY_DEVICE;
   11e26:	7034      	strb	r4, [r6, #0]
        p_key->state = M_TB_KEY_STATE_NORMAL;
   11e28:	7074      	strb	r4, [r6, #1]

        p_env->p_keys[M_TB_KEY_DEVICE_LID] = (m_tb_key_t*)p_key;
        status = M_ERR_NO_ERROR;

        // Inform the storage manager about the update
        m_tb_store_update_ind(M_TB_STORE_UPD_TYPE_STATE, M_TB_STORE_TYPE_DEV_KEY);
   11e2a:	0008      	movs	r0, r1

        memcpy(p_key->key, p_dev_key, M_KEY_LEN);
        p_key->key_type = M_TB_KEY_DEVICE;
        p_key->state = M_TB_KEY_STATE_NORMAL;

        p_env->p_keys[M_TB_KEY_DEVICE_LID] = (m_tb_key_t*)p_key;
   11e2c:	603e      	str	r6, [r7, #0]
        status = M_ERR_NO_ERROR;

        // Inform the storage manager about the update
        m_tb_store_update_ind(M_TB_STORE_UPD_TYPE_STATE, M_TB_STORE_TYPE_DEV_KEY);
   11e2e:	f002 fef3 	bl	14c18 <m_tb_store_update_ind>
        memcpy(p_key->key, p_dev_key, M_KEY_LEN);
        p_key->key_type = M_TB_KEY_DEVICE;
        p_key->state = M_TB_KEY_STATE_NORMAL;

        p_env->p_keys[M_TB_KEY_DEVICE_LID] = (m_tb_key_t*)p_key;
        status = M_ERR_NO_ERROR;
   11e32:	0020      	movs	r0, r4
        // Inform the storage manager about the update
        m_tb_store_update_ind(M_TB_STORE_UPD_TYPE_STATE, M_TB_STORE_TYPE_DEV_KEY);
    }

    return (status);
}
   11e34:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
   11e36:	46c0      	nop			; (mov r8, r8)
   11e38:	10010514 	.word	0x10010514
   11e3c:	00022744 	.word	0x00022744
   11e40:	00022644 	.word	0x00022644
   11e44:	0000060e 	.word	0x0000060e
   11e48:	000226c4 	.word	0x000226c4
   11e4c:	100126c0 	.word	0x100126c0

00011e50 <m_tb_key_dev_get>:
#endif //(BLE_MESH_DBG)

uint16_t m_tb_key_dev_get(const m_tb_key_dev_t** pp_dev_key)
{
    uint16_t status = M_ERR_NOT_FOUND;
    m_tb_key_env_t* p_env = p_m_tb_key_env;
   11e50:	4b04      	ldr	r3, [pc, #16]	; (11e64 <m_tb_key_dev_get+0x14>)

    if(p_env->p_keys[M_TB_KEY_DEVICE_LID] != NULL)
   11e52:	681b      	ldr	r3, [r3, #0]
   11e54:	681b      	ldr	r3, [r3, #0]
   11e56:	2b00      	cmp	r3, #0
   11e58:	d002      	beq.n	11e60 <m_tb_key_dev_get+0x10>
    {
        *pp_dev_key = (m_tb_key_dev_t*)p_env->p_keys[M_TB_KEY_DEVICE_LID];
   11e5a:	6003      	str	r3, [r0, #0]
        status = M_ERR_NO_ERROR;
   11e5c:	2000      	movs	r0, #0
   11e5e:	e000      	b.n	11e62 <m_tb_key_dev_get+0x12>
}
#endif //(BLE_MESH_DBG)

uint16_t m_tb_key_dev_get(const m_tb_key_dev_t** pp_dev_key)
{
    uint16_t status = M_ERR_NOT_FOUND;
   11e60:	4801      	ldr	r0, [pc, #4]	; (11e68 <m_tb_key_dev_get+0x18>)
        *pp_dev_key = (m_tb_key_dev_t*)p_env->p_keys[M_TB_KEY_DEVICE_LID];
        status = M_ERR_NO_ERROR;
    }

    return (status);
}
   11e62:	4770      	bx	lr
   11e64:	100126c0 	.word	0x100126c0
   11e68:	00000682 	.word	0x00000682

00011e6c <m_tb_key_net_add>:

uint16_t m_tb_key_net_add(uint16_t net_key_id, const uint8_t *p_net_key, uint8_t flags, m_tb_key_added_cb res_cb)
{
   11e6c:	b5f0      	push	{r4, r5, r6, r7, lr}
   11e6e:	b085      	sub	sp, #20
   11e70:	9303      	str	r3, [sp, #12]
	M_PRINTF(L_TB, "");
   11e72:	4b3d      	ldr	r3, [pc, #244]	; (11f68 <m_tb_key_net_add+0xfc>)

    return (status);
}

uint16_t m_tb_key_net_add(uint16_t net_key_id, const uint8_t *p_net_key, uint8_t flags, m_tb_key_added_cb res_cb)
{
   11e74:	0006      	movs	r6, r0
	M_PRINTF(L_TB, "");
   11e76:	681b      	ldr	r3, [r3, #0]

    return (status);
}

uint16_t m_tb_key_net_add(uint16_t net_key_id, const uint8_t *p_net_key, uint8_t flags, m_tb_key_added_cb res_cb)
{
   11e78:	000f      	movs	r7, r1
   11e7a:	9202      	str	r2, [sp, #8]
	M_PRINTF(L_TB, "");
   11e7c:	079b      	lsls	r3, r3, #30
   11e7e:	d515      	bpl.n	11eac <m_tb_key_net_add+0x40>
   11e80:	4d3a      	ldr	r5, [pc, #232]	; (11f6c <m_tb_key_net_add+0x100>)
   11e82:	4c3b      	ldr	r4, [pc, #236]	; (11f70 <m_tb_key_net_add+0x104>)
   11e84:	002b      	movs	r3, r5
   11e86:	0022      	movs	r2, r4
   11e88:	0020      	movs	r0, r4
   11e8a:	331b      	adds	r3, #27
   11e8c:	0021      	movs	r1, r4
   11e8e:	3237      	adds	r2, #55	; 0x37
   11e90:	9300      	str	r3, [sp, #0]
   11e92:	3042      	adds	r0, #66	; 0x42
   11e94:	4b37      	ldr	r3, [pc, #220]	; (11f74 <m_tb_key_net_add+0x108>)
   11e96:	f7f2 fd89 	bl	49ac <m_print>
   11e9a:	0028      	movs	r0, r5
   11e9c:	301a      	adds	r0, #26
   11e9e:	f7f2 fd85 	bl	49ac <m_print>
   11ea2:	4835      	ldr	r0, [pc, #212]	; (11f78 <m_tb_key_net_add+0x10c>)
   11ea4:	1da1      	adds	r1, r4, #6
   11ea6:	3003      	adds	r0, #3
   11ea8:	f7f2 fd80 	bl	49ac <m_print>
    uint16_t status = M_ERR_NO_ERROR;
    m_tb_key_env_t *p_env = p_m_tb_key_env;
   11eac:	4b33      	ldr	r3, [pc, #204]	; (11f7c <m_tb_key_net_add+0x110>)
   11eae:	681b      	ldr	r3, [r3, #0]
    m_lid_t ava_lid = M_TB_KEY_INVALID_LID;
    m_tb_key_net_t *p_key = NULL;

    // Ensure that no other key are under creation
    if (!GETB(p_env->status, M_TB_KEY_STATE_KEY_GEN))
   11eb0:	001a      	movs	r2, r3
   11eb2:	32b9      	adds	r2, #185	; 0xb9
   11eb4:	7812      	ldrb	r2, [r2, #0]
   11eb6:	0712      	lsls	r2, r2, #28
   11eb8:	d44f      	bmi.n	11f5a <m_tb_key_net_add+0xee>
        m_lid_t i;

        // Seek for a key that have same net key index
        for (i = M_TB_KEY_NET_START_LID; i <= M_TB_KEY_NET_END_LID; i++)
        {
            p_key = (m_tb_key_net_t*) p_env->p_keys[i];
   11eba:	6858      	ldr	r0, [r3, #4]

            if(p_key != NULL)
   11ebc:	2800      	cmp	r0, #0
   11ebe:	d005      	beq.n	11ecc <m_tb_key_net_add+0x60>
            {
                // Network index already exist, reject request
                if (p_key->net_key_id == net_key_id)
   11ec0:	1d82      	adds	r2, r0, #6
   11ec2:	8fd2      	ldrh	r2, [r2, #62]	; 0x3e
   11ec4:	25ff      	movs	r5, #255	; 0xff
   11ec6:	42b2      	cmp	r2, r6
   11ec8:	d101      	bne.n	11ece <m_tb_key_net_add+0x62>
   11eca:	e007      	b.n	11edc <m_tb_key_net_add+0x70>
        // Seek for a key that have same net key index
        for (i = M_TB_KEY_NET_START_LID; i <= M_TB_KEY_NET_END_LID; i++)
        {
            p_key = (m_tb_key_net_t*) p_env->p_keys[i];

            if(p_key != NULL)
   11ecc:	2501      	movs	r5, #1
        m_lid_t i;

        // Seek for a key that have same net key index
        for (i = M_TB_KEY_NET_START_LID; i <= M_TB_KEY_NET_END_LID; i++)
        {
            p_key = (m_tb_key_net_t*) p_env->p_keys[i];
   11ece:	6898      	ldr	r0, [r3, #8]

            if(p_key != NULL)
   11ed0:	2800      	cmp	r0, #0
   11ed2:	d00d      	beq.n	11ef0 <m_tb_key_net_add+0x84>
            {
                // Network index already exist, reject request
                if (p_key->net_key_id == net_key_id)
   11ed4:	1d83      	adds	r3, r0, #6
   11ed6:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
   11ed8:	42b3      	cmp	r3, r6
   11eda:	d10d      	bne.n	11ef8 <m_tb_key_net_add+0x8c>
                {
                    // Check if key is the same
                    if (!memcmp(&p_key->key[0], p_net_key, M_KEY_LEN))
   11edc:	3002      	adds	r0, #2
   11ede:	2210      	movs	r2, #16
   11ee0:	0039      	movs	r1, r7
   11ee2:	f003 fd4d 	bl	15980 <memcmp>
   11ee6:	2800      	cmp	r0, #0
   11ee8:	d03a      	beq.n	11f60 <m_tb_key_net_add+0xf4>
                        status = M_ERR_NO_EFFECT;
                    }
                    else
                    {
                        // NetKey ID already used
                        status = M_ERR_KEY_ID_ALREADY_STORED;
   11eea:	20d0      	movs	r0, #208	; 0xd0
   11eec:	00c0      	lsls	r0, r0, #3
   11eee:	e038      	b.n	11f62 <m_tb_key_net_add+0xf6>
                    }
                    break;
                }
            }
            else if(ava_lid == M_TB_KEY_INVALID_LID)
   11ef0:	2dff      	cmp	r5, #255	; 0xff
   11ef2:	d103      	bne.n	11efc <m_tb_key_net_add+0x90>
    {
        // Counter
        m_lid_t i;

        // Seek for a key that have same net key index
        for (i = M_TB_KEY_NET_START_LID; i <= M_TB_KEY_NET_END_LID; i++)
   11ef4:	3dfd      	subs	r5, #253	; 0xfd
   11ef6:	e001      	b.n	11efc <m_tb_key_net_add+0x90>
            ava_lid = M_TB_KEY_INVALID_LID;
        }
        #endif //(BLE_MESH_DBG)

        // Check that a key identifier has been found
        if(ava_lid == M_TB_KEY_INVALID_LID)
   11ef8:	2dff      	cmp	r5, #255	; 0xff
   11efa:	d02b      	beq.n	11f54 <m_tb_key_net_add+0xe8>
            status = M_ERR_INSUFFICIENT_RESOURCES;
        }
        else
        {
            // Allocate new key
            p_key = (m_tb_key_net_t*) m_al_malloc(sizeof(m_tb_key_net_t));
   11efc:	2050      	movs	r0, #80	; 0x50
   11efe:	f7f3 fb68 	bl	55d2 <m_al_malloc>

            // Fill key information
            p_key->key_type = M_TB_KEY_NETWORK;
   11f02:	2301      	movs	r3, #1
            status = M_ERR_INSUFFICIENT_RESOURCES;
        }
        else
        {
            // Allocate new key
            p_key = (m_tb_key_net_t*) m_al_malloc(sizeof(m_tb_key_net_t));
   11f04:	0004      	movs	r4, r0

            // Fill key information
            p_key->key_type = M_TB_KEY_NETWORK;
   11f06:	7003      	strb	r3, [r0, #0]
            memcpy(p_key->key, p_net_key, M_KEY_LEN);
   11f08:	2210      	movs	r2, #16
   11f0a:	3002      	adds	r0, #2
   11f0c:	0039      	movs	r1, r7
   11f0e:	f003 fd5f 	bl	159d0 <memcpy>
            p_key->net_key_id  = net_key_id;
            p_key->nb_app_keys = 0;
   11f12:	2200      	movs	r2, #0
            p_key = (m_tb_key_net_t*) m_al_malloc(sizeof(m_tb_key_net_t));

            // Fill key information
            p_key->key_type = M_TB_KEY_NETWORK;
            memcpy(p_key->key, p_net_key, M_KEY_LEN);
            p_key->net_key_id  = net_key_id;
   11f14:	1da3      	adds	r3, r4, #6
   11f16:	87de      	strh	r6, [r3, #62]	; 0x3e
            p_key->nb_app_keys = 0;
   11f18:	3348      	adds	r3, #72	; 0x48
   11f1a:	701a      	strb	r2, [r3, #0]
            p_key->flags = flags;
   11f1c:	466a      	mov	r2, sp
   11f1e:	7a12      	ldrb	r2, [r2, #8]
   11f20:	3b0b      	subs	r3, #11
   11f22:	701a      	strb	r2, [r3, #0]

            if (GETB(flags, M_MSG_FLAGS_IV_UPDATE))
   11f24:	9b02      	ldr	r3, [sp, #8]
   11f26:	079b      	lsls	r3, r3, #30
   11f28:	d506      	bpl.n	11f38 <m_tb_key_net_add+0xcc>
            {
                SETB(p_m_tb_key_env->status, M_TB_KEY_STATUS_IV_UPDATE, 1);
   11f2a:	2601      	movs	r6, #1
   11f2c:	4b13      	ldr	r3, [pc, #76]	; (11f7c <m_tb_key_net_add+0x110>)
   11f2e:	681b      	ldr	r3, [r3, #0]
   11f30:	33b9      	adds	r3, #185	; 0xb9
   11f32:	781a      	ldrb	r2, [r3, #0]
   11f34:	4316      	orrs	r6, r2
   11f36:	701e      	strb	r6, [r3, #0]
            }

            // start generation of the encryption key
            p_key->state = M_TB_KEY_STATE_NET_GEN_ENC;
   11f38:	2303      	movs	r3, #3

            m_tb_key_create_start(ava_lid, (m_tb_key_t*) p_key, res_cb);
   11f3a:	9a03      	ldr	r2, [sp, #12]
            {
                SETB(p_m_tb_key_env->status, M_TB_KEY_STATUS_IV_UPDATE, 1);
            }

            // start generation of the encryption key
            p_key->state = M_TB_KEY_STATE_NET_GEN_ENC;
   11f3c:	7063      	strb	r3, [r4, #1]

            m_tb_key_create_start(ava_lid, (m_tb_key_t*) p_key, res_cb);
   11f3e:	0021      	movs	r1, r4
   11f40:	0028      	movs	r0, r5
   11f42:	f7ff fc37 	bl	117b4 <m_tb_key_create_start>

            // Use k2 algorithm to generate encryption key
            m_tb_sec_k2_start(M_TB_SEC_TOKEN_KEY_MANAGER, m_tb_key_k2_ready_cb, m_tb_key_finished_cb);
   11f46:	4a0e      	ldr	r2, [pc, #56]	; (11f80 <m_tb_key_net_add+0x114>)
   11f48:	490e      	ldr	r1, [pc, #56]	; (11f84 <m_tb_key_net_add+0x118>)
   11f4a:	2004      	movs	r0, #4
   11f4c:	f002 f83e 	bl	13fcc <m_tb_sec_k2_start>
   11f50:	2000      	movs	r0, #0
   11f52:	e006      	b.n	11f62 <m_tb_key_net_add+0xf6>
        #endif //(BLE_MESH_DBG)

        // Check that a key identifier has been found
        if(ava_lid == M_TB_KEY_INVALID_LID)
        {
            status = M_ERR_INSUFFICIENT_RESOURCES;
   11f54:	20b0      	movs	r0, #176	; 0xb0
   11f56:	00c0      	lsls	r0, r0, #3
   11f58:	e003      	b.n	11f62 <m_tb_key_net_add+0xf6>
            }
        }
    }
    else
    {
        status = M_ERR_UNSPECIFIED_ERROR;
   11f5a:	2084      	movs	r0, #132	; 0x84
   11f5c:	0140      	lsls	r0, r0, #5
   11f5e:	e000      	b.n	11f62 <m_tb_key_net_add+0xf6>
                {
                    // Check if key is the same
                    if (!memcmp(&p_key->key[0], p_net_key, M_KEY_LEN))
                    {
                        // No need to add the key as it already exists
                        status = M_ERR_NO_EFFECT;
   11f60:	4809      	ldr	r0, [pc, #36]	; (11f88 <m_tb_key_net_add+0x11c>)
            m_tb_sec_k2_start(M_TB_SEC_TOKEN_KEY_MANAGER, m_tb_key_k2_ready_cb, m_tb_key_finished_cb);
        }
    }

    return (status);
}
   11f62:	b005      	add	sp, #20
   11f64:	bdf0      	pop	{r4, r5, r6, r7, pc}
   11f66:	46c0      	nop			; (mov r8, r8)
   11f68:	10010514 	.word	0x10010514
   11f6c:	00022744 	.word	0x00022744
   11f70:	00022644 	.word	0x00022644
   11f74:	00000641 	.word	0x00000641
   11f78:	000226c4 	.word	0x000226c4
   11f7c:	100126c0 	.word	0x100126c0
   11f80:	00011ab1 	.word	0x00011ab1
   11f84:	00011a0d 	.word	0x00011a0d
   11f88:	00000c82 	.word	0x00000c82

00011f8c <m_tb_key_net_delete>:

uint16_t m_tb_key_net_delete(m_lid_t net_key_lid, bool force)
{
    uint16_t        status;
    m_tb_key_net_t* p_key = NULL;
    m_tb_key_env_t* p_env = p_m_tb_key_env;
   11f8c:	4b34      	ldr	r3, [pc, #208]	; (12060 <m_tb_key_net_delete+0xd4>)

    return (status);
}

uint16_t m_tb_key_net_delete(m_lid_t net_key_lid, bool force)
{
   11f8e:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    uint16_t        status;
    m_tb_key_net_t* p_key = NULL;
    m_tb_key_env_t* p_env = p_m_tb_key_env;
   11f90:	681c      	ldr	r4, [r3, #0]
    net_key_lid = GETF(net_key_lid, M_TB_KEY_LID);

    do
    {
        // Ensure that no key creation are on-going
        if (GETB(p_env->status, M_TB_KEY_STATE_KEY_GEN))
   11f92:	0023      	movs	r3, r4
   11f94:	33b9      	adds	r3, #185	; 0xb9
   11f96:	9300      	str	r3, [sp, #0]
   11f98:	781b      	ldrb	r3, [r3, #0]
   11f9a:	071b      	lsls	r3, r3, #28
   11f9c:	d458      	bmi.n	12050 <m_tb_key_net_delete+0xc4>
    uint16_t        status;
    m_tb_key_net_t* p_key = NULL;
    m_tb_key_env_t* p_env = p_m_tb_key_env;

    // Get the network key identifier
    net_key_lid = GETF(net_key_lid, M_TB_KEY_LID);
   11f9e:	237f      	movs	r3, #127	; 0x7f
   11fa0:	4018      	ands	r0, r3
   11fa2:	0083      	lsls	r3, r0, #2
   11fa4:	18e7      	adds	r7, r4, r3
            status = M_ERR_COMMAND_DISALLOWED;
            break;
        }

        // Retrieve key
        p_key = (m_tb_key_net_t*) p_env->p_keys[net_key_lid];
   11fa6:	683e      	ldr	r6, [r7, #0]
    uint16_t        status;
    m_tb_key_net_t* p_key = NULL;
    m_tb_key_env_t* p_env = p_m_tb_key_env;

    // Get the network key identifier
    net_key_lid = GETF(net_key_lid, M_TB_KEY_LID);
   11fa8:	0005      	movs	r5, r0
   11faa:	9301      	str	r3, [sp, #4]
        }

        // Retrieve key
        p_key = (m_tb_key_net_t*) p_env->p_keys[net_key_lid];

        if((p_key == NULL) || (p_key->key_type != M_TB_KEY_NETWORK))
   11fac:	2e00      	cmp	r6, #0
   11fae:	d051      	beq.n	12054 <m_tb_key_net_delete+0xc8>
   11fb0:	7833      	ldrb	r3, [r6, #0]
   11fb2:	2b01      	cmp	r3, #1
   11fb4:	d14e      	bne.n	12054 <m_tb_key_net_delete+0xc8>
            status = M_ERR_INVALID_NETKEY_ID;
            break;
        }

        // Check that indicated key is not the last remaining one
        if (((p_env->nb_net_keys == 1) && !force) || (p_key->nb_app_keys != 0))
   11fb6:	0023      	movs	r3, r4
   11fb8:	33b8      	adds	r3, #184	; 0xb8
   11fba:	781b      	ldrb	r3, [r3, #0]
   11fbc:	2b01      	cmp	r3, #1
   11fbe:	d101      	bne.n	11fc4 <m_tb_key_net_delete+0x38>
   11fc0:	2900      	cmp	r1, #0
   11fc2:	d04a      	beq.n	1205a <m_tb_key_net_delete+0xce>
   11fc4:	0033      	movs	r3, r6
   11fc6:	334e      	adds	r3, #78	; 0x4e
   11fc8:	781b      	ldrb	r3, [r3, #0]
   11fca:	9301      	str	r3, [sp, #4]
   11fcc:	2b00      	cmp	r3, #0
   11fce:	d144      	bne.n	1205a <m_tb_key_net_delete+0xce>
            status = M_ERR_CANNOT_REMOVE;
            break;
        }

        // Delete NID from table
        m_tb_key_nid_tbl_del(net_key_lid);
   11fd0:	0028      	movs	r0, r5
   11fd2:	f7ff fc29 	bl	11828 <m_tb_key_nid_tbl_del>

        // Inform the storage manager about the update
        m_tb_store_update_ind(M_TB_STORE_UPD_TYPE_NET_KEY_DELETED, net_key_lid);
   11fd6:	0029      	movs	r1, r5
   11fd8:	2001      	movs	r0, #1
   11fda:	f002 fe1d 	bl	14c18 <m_tb_store_update_ind>

        // Free the key
        m_al_free(p_key);
   11fde:	0030      	movs	r0, r6
   11fe0:	f7f3 fafc 	bl	55dc <m_al_free>
        p_env->p_keys[net_key_lid] = NULL;
        p_env->nb_net_keys--;
   11fe4:	0022      	movs	r2, r4
        // Inform the storage manager about the update
        m_tb_store_update_ind(M_TB_STORE_UPD_TYPE_NET_KEY_DELETED, net_key_lid);

        // Free the key
        m_al_free(p_key);
        p_env->p_keys[net_key_lid] = NULL;
   11fe6:	9b01      	ldr	r3, [sp, #4]
        p_env->nb_net_keys--;
   11fe8:	32b8      	adds	r2, #184	; 0xb8
        // Inform the storage manager about the update
        m_tb_store_update_ind(M_TB_STORE_UPD_TYPE_NET_KEY_DELETED, net_key_lid);

        // Free the key
        m_al_free(p_key);
        p_env->p_keys[net_key_lid] = NULL;
   11fea:	603b      	str	r3, [r7, #0]
        p_env->nb_net_keys--;
   11fec:	7813      	ldrb	r3, [r2, #0]

        if (p_key->net_key_id == M_TB_KEY_PRIM_NETKEY_ID)
   11fee:	3606      	adds	r6, #6
        m_tb_store_update_ind(M_TB_STORE_UPD_TYPE_NET_KEY_DELETED, net_key_lid);

        // Free the key
        m_al_free(p_key);
        p_env->p_keys[net_key_lid] = NULL;
        p_env->nb_net_keys--;
   11ff0:	3b01      	subs	r3, #1
   11ff2:	7013      	strb	r3, [r2, #0]

        if (p_key->net_key_id == M_TB_KEY_PRIM_NETKEY_ID)
   11ff4:	8ff3      	ldrh	r3, [r6, #62]	; 0x3e
   11ff6:	2b00      	cmp	r3, #0
   11ff8:	d105      	bne.n	12006 <m_tb_key_net_delete+0x7a>
        {
            SETB(p_env->status, M_TB_KEY_STATUS_PRIM, 0);
   11ffa:	2202      	movs	r2, #2
   11ffc:	9b00      	ldr	r3, [sp, #0]
   11ffe:	781b      	ldrb	r3, [r3, #0]
   12000:	4393      	bics	r3, r2
   12002:	9a00      	ldr	r2, [sp, #0]
   12004:	7013      	strb	r3, [r2, #0]
        }

       // check if key is under update
        if(p_env->p_up != NULL)
   12006:	6b63      	ldr	r3, [r4, #52]	; 0x34
   12008:	2b00      	cmp	r3, #0
   1200a:	d01b      	beq.n	12044 <m_tb_key_net_delete+0xb8>
        {
            // retrieve key
            p_key = (m_tb_key_net_t*) p_env->p_up->p_keys[net_key_lid];
   1200c:	00aa      	lsls	r2, r5, #2
   1200e:	589e      	ldr	r6, [r3, r2]

            // if a key update is on-going, remove also the key under update
            if(p_key != NULL)
   12010:	2e00      	cmp	r6, #0
   12012:	d017      	beq.n	12044 <m_tb_key_net_delete+0xb8>
            {
                // Delete NID from table
                m_tb_key_nid_tbl_del(net_key_lid | M_TB_KEY_NEW_BIT);
   12014:	2080      	movs	r0, #128	; 0x80
   12016:	4328      	orrs	r0, r5
   12018:	f7ff fc06 	bl	11828 <m_tb_key_nid_tbl_del>

                m_al_free(p_key);
   1201c:	0030      	movs	r0, r6
   1201e:	f7f3 fadd 	bl	55dc <m_al_free>
                p_env->p_up->p_keys[net_key_lid] = NULL;
   12022:	2200      	movs	r2, #0
   12024:	6b63      	ldr	r3, [r4, #52]	; 0x34
   12026:	00a9      	lsls	r1, r5, #2
   12028:	505a      	str	r2, [r3, r1]
                p_env->p_up->nb_key--;
   1202a:	3334      	adds	r3, #52	; 0x34
   1202c:	781a      	ldrb	r2, [r3, #0]
   1202e:	3a01      	subs	r2, #1
   12030:	701a      	strb	r2, [r3, #0]

                // no more key under update
                if(p_env->p_up->nb_key == 0)
   12032:	6b60      	ldr	r0, [r4, #52]	; 0x34
   12034:	0003      	movs	r3, r0
   12036:	3334      	adds	r3, #52	; 0x34
   12038:	781e      	ldrb	r6, [r3, #0]
   1203a:	2e00      	cmp	r6, #0
   1203c:	d102      	bne.n	12044 <m_tb_key_net_delete+0xb8>
                {
                    // free update key structure
                    m_al_free(p_env->p_up);
   1203e:	f7f3 facd 	bl	55dc <m_al_free>
                    p_env->p_up = NULL;
   12042:	6366      	str	r6, [r4, #52]	; 0x34
                }
            }
        }

        // Inform beaconing layer that a subnet has been deleted
        m_bcn_subnet_update_ind(net_key_lid, false);
   12044:	0028      	movs	r0, r5
   12046:	2100      	movs	r1, #0
   12048:	f7f7 fc9a 	bl	9980 <m_bcn_subnet_update_ind>

        status = M_ERR_NO_ERROR;
   1204c:	2000      	movs	r0, #0
   1204e:	e006      	b.n	1205e <m_tb_key_net_delete+0xd2>
    do
    {
        // Ensure that no key creation are on-going
        if (GETB(p_env->status, M_TB_KEY_STATE_KEY_GEN))
        {
            status = M_ERR_COMMAND_DISALLOWED;
   12050:	4804      	ldr	r0, [pc, #16]	; (12064 <m_tb_key_net_delete+0xd8>)
   12052:	e004      	b.n	1205e <m_tb_key_net_delete+0xd2>
        // Retrieve key
        p_key = (m_tb_key_net_t*) p_env->p_keys[net_key_lid];

        if((p_key == NULL) || (p_key->key_type != M_TB_KEY_NETWORK))
        {
            status = M_ERR_INVALID_NETKEY_ID;
   12054:	2090      	movs	r0, #144	; 0x90
   12056:	00c0      	lsls	r0, r0, #3
   12058:	e001      	b.n	1205e <m_tb_key_net_delete+0xd2>
        }

        // Check that indicated key is not the last remaining one
        if (((p_env->nb_net_keys == 1) && !force) || (p_key->nb_app_keys != 0))
        {
            status = M_ERR_CANNOT_REMOVE;
   1205a:	20c8      	movs	r0, #200	; 0xc8
   1205c:	0100      	lsls	r0, r0, #4

        status = M_ERR_NO_ERROR;
    } while(0);

    return (status);
}
   1205e:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
   12060:	100126c0 	.word	0x100126c0
   12064:	00000282 	.word	0x00000282

00012068 <m_tb_key_net_update>:
        m_tb_key_env_t *p_env = p_m_tb_key_env;
        m_tb_key_net_t *p_old_key = NULL;
        m_tb_key_net_t *p_up_key = NULL;

        // Force having only the local index
        net_key_lid = GETF(net_key_lid, M_TB_KEY_LID);
   12068:	237f      	movs	r3, #127	; 0x7f

    return (status);
}

uint16_t m_tb_key_net_update(m_lid_t net_key_lid, const uint8_t *p_net_key, m_tb_key_added_cb res_cb)
{
   1206a:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
        m_tb_key_env_t *p_env = p_m_tb_key_env;
        m_tb_key_net_t *p_old_key = NULL;
        m_tb_key_net_t *p_up_key = NULL;

        // Force having only the local index
        net_key_lid = GETF(net_key_lid, M_TB_KEY_LID);
   1206c:	4018      	ands	r0, r3

        if ((net_key_lid < M_TB_KEY_NET_START_LID) || (net_key_lid > M_TB_KEY_NET_END_LID))
   1206e:	1e43      	subs	r3, r0, #1

    return (status);
}

uint16_t m_tb_key_net_update(m_lid_t net_key_lid, const uint8_t *p_net_key, m_tb_key_added_cb res_cb)
{
   12070:	000e      	movs	r6, r1
   12072:	9201      	str	r2, [sp, #4]
        m_tb_key_env_t *p_env = p_m_tb_key_env;
        m_tb_key_net_t *p_old_key = NULL;
        m_tb_key_net_t *p_up_key = NULL;

        // Force having only the local index
        net_key_lid = GETF(net_key_lid, M_TB_KEY_LID);
   12074:	0004      	movs	r4, r0

        if ((net_key_lid < M_TB_KEY_NET_START_LID) || (net_key_lid > M_TB_KEY_NET_END_LID))
   12076:	2b01      	cmp	r3, #1
   12078:	d834      	bhi.n	120e4 <m_tb_key_net_update+0x7c>
{
    uint16_t status = M_ERR_NO_ERROR;

    do
    {
        m_tb_key_env_t *p_env = p_m_tb_key_env;
   1207a:	4b1e      	ldr	r3, [pc, #120]	; (120f4 <m_tb_key_net_update+0x8c>)
   1207c:	681b      	ldr	r3, [r3, #0]
            status  = M_ERR_INVALID_NETKEY_ID;
            break;
        }

        // Ensure that no key creation is on-going
        if (GETB(p_env->status, M_TB_KEY_STATE_KEY_GEN))
   1207e:	001a      	movs	r2, r3
   12080:	32b9      	adds	r2, #185	; 0xb9
   12082:	7812      	ldrb	r2, [r2, #0]
   12084:	0712      	lsls	r2, r2, #28
   12086:	d42b      	bmi.n	120e0 <m_tb_key_net_update+0x78>
            status = M_ERR_COMMAND_DISALLOWED;
            break;
        }

        // Retrieve key
        p_old_key = (m_tb_key_net_t *)p_env->p_keys[net_key_lid];
   12088:	0082      	lsls	r2, r0, #2
   1208a:	58d0      	ldr	r0, [r2, r3]

        if ((p_old_key == NULL) || (p_old_key->key_type != M_TB_KEY_NETWORK))
   1208c:	2800      	cmp	r0, #0
   1208e:	d029      	beq.n	120e4 <m_tb_key_net_update+0x7c>
   12090:	7803      	ldrb	r3, [r0, #0]
   12092:	9300      	str	r3, [sp, #0]
   12094:	2b01      	cmp	r3, #1
   12096:	d125      	bne.n	120e4 <m_tb_key_net_update+0x7c>
            status = M_ERR_INVALID_NETKEY_ID;
            break;
        }

        // Check that key is not already being updated
        if (p_old_key->state != M_TB_KEY_STATE_NORMAL)
   12098:	7847      	ldrb	r7, [r0, #1]
   1209a:	2f00      	cmp	r7, #0
   1209c:	d125      	bne.n	120ea <m_tb_key_net_update+0x82>
            status = M_ERR_CANNOT_UPDATE;
            break;
        }

        // Check that new key is different than current one
        if (!memcmp(&p_old_key->key[0], p_net_key, M_KEY_LEN))
   1209e:	3002      	adds	r0, #2
   120a0:	2210      	movs	r2, #16
   120a2:	f003 fc6d 	bl	15980 <memcmp>
   120a6:	2800      	cmp	r0, #0
   120a8:	d022      	beq.n	120f0 <m_tb_key_net_update+0x88>
            status = M_ERR_NO_EFFECT;
            break;
        }

        // Allocate new key
        p_up_key = (m_tb_key_net_t *)m_al_malloc(sizeof(m_tb_key_net_t));
   120aa:	2050      	movs	r0, #80	; 0x50
   120ac:	f7f3 fa91 	bl	55d2 <m_al_malloc>

        // Fill key information
        p_up_key->key_type = M_TB_KEY_NETWORK;
   120b0:	466b      	mov	r3, sp
   120b2:	781b      	ldrb	r3, [r3, #0]
            status = M_ERR_NO_EFFECT;
            break;
        }

        // Allocate new key
        p_up_key = (m_tb_key_net_t *)m_al_malloc(sizeof(m_tb_key_net_t));
   120b4:	0005      	movs	r5, r0

        // Fill key information
        p_up_key->key_type = M_TB_KEY_NETWORK;
   120b6:	7003      	strb	r3, [r0, #0]
        memcpy(p_up_key->key, p_net_key, M_KEY_LEN);
   120b8:	2210      	movs	r2, #16
   120ba:	0031      	movs	r1, r6
   120bc:	3002      	adds	r0, #2
   120be:	f003 fc87 	bl	159d0 <memcpy>

        // Start generation of the encryption key
        p_up_key->state = M_TB_KEY_STATE_NET_GEN_ENC;
   120c2:	2303      	movs	r3, #3

        // Create the key
        m_tb_key_create_start(net_key_lid | M_TB_KEY_NEW_BIT, (m_tb_key_t *)p_up_key, res_cb);
   120c4:	2080      	movs	r0, #128	; 0x80
        // Fill key information
        p_up_key->key_type = M_TB_KEY_NETWORK;
        memcpy(p_up_key->key, p_net_key, M_KEY_LEN);

        // Start generation of the encryption key
        p_up_key->state = M_TB_KEY_STATE_NET_GEN_ENC;
   120c6:	706b      	strb	r3, [r5, #1]

        // Create the key
        m_tb_key_create_start(net_key_lid | M_TB_KEY_NEW_BIT, (m_tb_key_t *)p_up_key, res_cb);
   120c8:	4320      	orrs	r0, r4
   120ca:	9a01      	ldr	r2, [sp, #4]
   120cc:	0029      	movs	r1, r5
   120ce:	f7ff fb71 	bl	117b4 <m_tb_key_create_start>

        // Use k2 algorithm for generation of encryption key
        m_tb_sec_k2_start(M_TB_SEC_TOKEN_KEY_MANAGER, m_tb_key_k2_ready_cb, m_tb_key_finished_cb);
   120d2:	4a09      	ldr	r2, [pc, #36]	; (120f8 <m_tb_key_net_update+0x90>)
   120d4:	4909      	ldr	r1, [pc, #36]	; (120fc <m_tb_key_net_update+0x94>)
   120d6:	2004      	movs	r0, #4
   120d8:	f001 ff78 	bl	13fcc <m_tb_sec_k2_start>

        status = M_ERR_NO_ERROR;
   120dc:	0038      	movs	r0, r7
   120de:	e008      	b.n	120f2 <m_tb_key_net_update+0x8a>
        }

        // Ensure that no key creation is on-going
        if (GETB(p_env->status, M_TB_KEY_STATE_KEY_GEN))
        {
            status = M_ERR_COMMAND_DISALLOWED;
   120e0:	4807      	ldr	r0, [pc, #28]	; (12100 <m_tb_key_net_update+0x98>)
   120e2:	e006      	b.n	120f2 <m_tb_key_net_update+0x8a>
        // Force having only the local index
        net_key_lid = GETF(net_key_lid, M_TB_KEY_LID);

        if ((net_key_lid < M_TB_KEY_NET_START_LID) || (net_key_lid > M_TB_KEY_NET_END_LID))
        {
            status  = M_ERR_INVALID_NETKEY_ID;
   120e4:	2090      	movs	r0, #144	; 0x90
   120e6:	00c0      	lsls	r0, r0, #3
   120e8:	e003      	b.n	120f2 <m_tb_key_net_update+0x8a>
        }

        // Check that key is not already being updated
        if (p_old_key->state != M_TB_KEY_STATE_NORMAL)
        {
            status = M_ERR_CANNOT_UPDATE;
   120ea:	20b8      	movs	r0, #184	; 0xb8
   120ec:	0100      	lsls	r0, r0, #4
   120ee:	e000      	b.n	120f2 <m_tb_key_net_update+0x8a>
        }

        // Check that new key is different than current one
        if (!memcmp(&p_old_key->key[0], p_net_key, M_KEY_LEN))
        {
            status = M_ERR_NO_EFFECT;
   120f0:	4804      	ldr	r0, [pc, #16]	; (12104 <m_tb_key_net_update+0x9c>)

        status = M_ERR_NO_ERROR;
    } while(0);

    return (status);
}
   120f2:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
   120f4:	100126c0 	.word	0x100126c0
   120f8:	00011ab1 	.word	0x00011ab1
   120fc:	00011a0d 	.word	0x00011a0d
   12100:	00000282 	.word	0x00000282
   12104:	00000c82 	.word	0x00000c82

00012108 <m_tb_key_net_use_new>:
    {
        m_tb_key_env_t *p_env = p_m_tb_key_env;
        m_tb_key_net_t *p_key = NULL;

        // Force having only the local index
        net_key_lid = GETF(net_key_lid, M_TB_KEY_LID);
   12108:	237f      	movs	r3, #127	; 0x7f
   1210a:	0001      	movs	r1, r0
   1210c:	4019      	ands	r1, r3

        if((net_key_lid < M_TB_KEY_NET_START_LID) || (net_key_lid > M_TB_KEY_NET_END_LID))
   1210e:	1e4b      	subs	r3, r1, #1

    return (status);
}

uint16_t m_tb_key_net_use_new(m_lid_t net_key_lid)
{
   12110:	b510      	push	{r4, lr}
        m_tb_key_net_t *p_key = NULL;

        // Force having only the local index
        net_key_lid = GETF(net_key_lid, M_TB_KEY_LID);

        if((net_key_lid < M_TB_KEY_NET_START_LID) || (net_key_lid > M_TB_KEY_NET_END_LID))
   12112:	2b01      	cmp	r3, #1
   12114:	d815      	bhi.n	12142 <m_tb_key_net_use_new+0x3a>
    // Returned status
    uint16_t status = M_ERR_NO_ERROR;

    do
    {
        m_tb_key_env_t *p_env = p_m_tb_key_env;
   12116:	4b0d      	ldr	r3, [pc, #52]	; (1214c <m_tb_key_net_use_new+0x44>)
   12118:	681b      	ldr	r3, [r3, #0]
            status  = M_ERR_INVALID_NETKEY_ID;
            break;
        }

        // Ensure that no key creation are on-going
        if (GETB(p_env->status, M_TB_KEY_STATE_KEY_GEN))
   1211a:	001a      	movs	r2, r3
   1211c:	32b9      	adds	r2, #185	; 0xb9
   1211e:	7814      	ldrb	r4, [r2, #0]
   12120:	2208      	movs	r2, #8
   12122:	4014      	ands	r4, r2
   12124:	d110      	bne.n	12148 <m_tb_key_net_use_new+0x40>
        p_key = (m_tb_key_net_t *)p_env->p_keys[net_key_lid];

        // Check that key is in an expected state
        if (p_key->state != M_TB_KEY_STATE_P1)
        {
            status = M_ERR_CANNOT_UPDATE;
   12126:	20b8      	movs	r0, #184	; 0xb8
            status = M_ERR_COMMAND_DISALLOWED;
            break;
        }

        // Retrieve Keys
        p_key = (m_tb_key_net_t *)p_env->p_keys[net_key_lid];
   12128:	008a      	lsls	r2, r1, #2
   1212a:	58d3      	ldr	r3, [r2, r3]

        // Check that key is in an expected state
        if (p_key->state != M_TB_KEY_STATE_P1)
        {
            status = M_ERR_CANNOT_UPDATE;
   1212c:	0100      	lsls	r0, r0, #4

        // Retrieve Keys
        p_key = (m_tb_key_net_t *)p_env->p_keys[net_key_lid];

        // Check that key is in an expected state
        if (p_key->state != M_TB_KEY_STATE_P1)
   1212e:	785a      	ldrb	r2, [r3, #1]
   12130:	2a01      	cmp	r2, #1
   12132:	d10a      	bne.n	1214a <m_tb_key_net_use_new+0x42>
            status = M_ERR_CANNOT_UPDATE;
            break;
        }

        // Update key state
        p_key->state = M_TB_KEY_STATE_P2;
   12134:	3201      	adds	r2, #1

        // Inform the storage manager about the update
        m_tb_store_update_ind(M_TB_STORE_UPD_TYPE_NET_KEY_UPDATED, net_key_lid);
   12136:	0020      	movs	r0, r4
            status = M_ERR_CANNOT_UPDATE;
            break;
        }

        // Update key state
        p_key->state = M_TB_KEY_STATE_P2;
   12138:	705a      	strb	r2, [r3, #1]

        // Inform the storage manager about the update
        m_tb_store_update_ind(M_TB_STORE_UPD_TYPE_NET_KEY_UPDATED, net_key_lid);
   1213a:	f002 fd6d 	bl	14c18 <m_tb_store_update_ind>
}

uint16_t m_tb_key_net_use_new(m_lid_t net_key_lid)
{
    // Returned status
    uint16_t status = M_ERR_NO_ERROR;
   1213e:	0020      	movs	r0, r4
   12140:	e003      	b.n	1214a <m_tb_key_net_use_new+0x42>
        // Force having only the local index
        net_key_lid = GETF(net_key_lid, M_TB_KEY_LID);

        if((net_key_lid < M_TB_KEY_NET_START_LID) || (net_key_lid > M_TB_KEY_NET_END_LID))
        {
            status  = M_ERR_INVALID_NETKEY_ID;
   12142:	2090      	movs	r0, #144	; 0x90
   12144:	00c0      	lsls	r0, r0, #3
   12146:	e000      	b.n	1214a <m_tb_key_net_use_new+0x42>
        }

        // Ensure that no key creation are on-going
        if (GETB(p_env->status, M_TB_KEY_STATE_KEY_GEN))
        {
            status = M_ERR_COMMAND_DISALLOWED;
   12148:	4801      	ldr	r0, [pc, #4]	; (12150 <m_tb_key_net_use_new+0x48>)
        // Inform the storage manager about the update
        m_tb_store_update_ind(M_TB_STORE_UPD_TYPE_NET_KEY_UPDATED, net_key_lid);
    } while(0);

    return (status);
}
   1214a:	bd10      	pop	{r4, pc}
   1214c:	100126c0 	.word	0x100126c0
   12150:	00000282 	.word	0x00000282

00012154 <m_tb_key_net_revoke_old>:
        m_tb_key_env_t *p_env = p_m_tb_key_env;
        m_tb_key_net_t *p_old_key = NULL;
        m_tb_key_net_t *p_up_key = NULL;

        // Force having only the local index
        net_key_lid = GETF(net_key_lid, M_TB_KEY_LID);
   12154:	237f      	movs	r3, #127	; 0x7f

    return (status);
}

uint16_t m_tb_key_net_revoke_old(m_lid_t net_key_lid)
{
   12156:	b5f0      	push	{r4, r5, r6, r7, lr}
        m_tb_key_env_t *p_env = p_m_tb_key_env;
        m_tb_key_net_t *p_old_key = NULL;
        m_tb_key_net_t *p_up_key = NULL;

        // Force having only the local index
        net_key_lid = GETF(net_key_lid, M_TB_KEY_LID);
   12158:	4018      	ands	r0, r3

        if ((net_key_lid < M_TB_KEY_NET_START_LID) || (net_key_lid > M_TB_KEY_NET_END_LID))
   1215a:	1e43      	subs	r3, r0, #1

    return (status);
}

uint16_t m_tb_key_net_revoke_old(m_lid_t net_key_lid)
{
   1215c:	b087      	sub	sp, #28
        m_tb_key_env_t *p_env = p_m_tb_key_env;
        m_tb_key_net_t *p_old_key = NULL;
        m_tb_key_net_t *p_up_key = NULL;

        // Force having only the local index
        net_key_lid = GETF(net_key_lid, M_TB_KEY_LID);
   1215e:	0004      	movs	r4, r0

        if ((net_key_lid < M_TB_KEY_NET_START_LID) || (net_key_lid > M_TB_KEY_NET_END_LID))
   12160:	2b01      	cmp	r3, #1
   12162:	d900      	bls.n	12166 <m_tb_key_net_revoke_old+0x12>
   12164:	e082      	b.n	1226c <m_tb_key_net_revoke_old+0x118>
    // Returned status
    uint16_t status = M_ERR_NO_ERROR;

    do
    {
        m_tb_key_env_t *p_env = p_m_tb_key_env;
   12166:	4b46      	ldr	r3, [pc, #280]	; (12280 <m_tb_key_net_revoke_old+0x12c>)
   12168:	681d      	ldr	r5, [r3, #0]
            status  = M_ERR_INVALID_NETKEY_ID;
            break;
        }

        // Ensure that no key creation is on-going
        if (GETB(p_env->status, M_TB_KEY_STATE_KEY_GEN))
   1216a:	002b      	movs	r3, r5
   1216c:	33b9      	adds	r3, #185	; 0xb9
   1216e:	781a      	ldrb	r2, [r3, #0]
   12170:	2308      	movs	r3, #8
   12172:	4013      	ands	r3, r2
   12174:	d17d      	bne.n	12272 <m_tb_key_net_revoke_old+0x11e>
            status = M_ERR_COMMAND_DISALLOWED;
            break;
        }

        // Check if key is under update
        if (p_env->p_up == NULL)
   12176:	6b6a      	ldr	r2, [r5, #52]	; 0x34
   12178:	2a00      	cmp	r2, #0
   1217a:	d07c      	beq.n	12276 <m_tb_key_net_revoke_old+0x122>
   1217c:	0081      	lsls	r1, r0, #2
   1217e:	1868      	adds	r0, r5, r1
   12180:	9004      	str	r0, [sp, #16]
            status = M_ERR_CANNOT_UPDATE;
            break;
        }

        // Retrieve keys
        p_old_key = (m_tb_key_net_t *)p_env->p_keys[net_key_lid];
   12182:	6800      	ldr	r0, [r0, #0]
   12184:	9001      	str	r0, [sp, #4]
        p_up_key = (m_tb_key_net_t *)p_env->p_up->p_keys[net_key_lid];

        // Check that keys is in expected
        if (p_old_key->state != M_TB_KEY_STATE_P2)
   12186:	7840      	ldrb	r0, [r0, #1]
   12188:	2802      	cmp	r0, #2
   1218a:	d174      	bne.n	12276 <m_tb_key_net_revoke_old+0x122>
            break;
        }

        // Retrieve keys
        p_old_key = (m_tb_key_net_t *)p_env->p_keys[net_key_lid];
        p_up_key = (m_tb_key_net_t *)p_env->p_up->p_keys[net_key_lid];
   1218c:	588a      	ldr	r2, [r1, r2]
   1218e:	9203      	str	r2, [sp, #12]
        {
            status = M_ERR_CANNOT_UPDATE;
            break;
        }

        p_old_key->state = M_TB_KEY_STATE_NORMAL;
   12190:	9a01      	ldr	r2, [sp, #4]
   12192:	7053      	strb	r3, [r2, #1]

        if (p_old_key->nb_app_keys)
   12194:	0013      	movs	r3, r2
   12196:	334e      	adds	r3, #78	; 0x4e
   12198:	781b      	ldrb	r3, [r3, #0]
   1219a:	2b00      	cmp	r3, #0
   1219c:	d125      	bne.n	121ea <m_tb_key_net_revoke_old+0x96>
            }
        }

        // Go to normal state
        p_env->p_keys[net_key_lid] = (m_tb_key_t *)p_up_key;
        p_up_key->state = M_TB_KEY_STATE_NORMAL;
   1219e:	2600      	movs	r6, #0
                m_tb_store_update_ind(M_TB_STORE_UPD_TYPE_APP_KEY_UPDATED, i);
            }
        }

        // Go to normal state
        p_env->p_keys[net_key_lid] = (m_tb_key_t *)p_up_key;
   121a0:	9a03      	ldr	r2, [sp, #12]
   121a2:	9b04      	ldr	r3, [sp, #16]
        p_up_key->state = M_TB_KEY_STATE_NORMAL;

        // Only Keep valid NID
        m_tb_key_nid_tbl_del(net_key_lid);
   121a4:	0020      	movs	r0, r4
                m_tb_store_update_ind(M_TB_STORE_UPD_TYPE_APP_KEY_UPDATED, i);
            }
        }

        // Go to normal state
        p_env->p_keys[net_key_lid] = (m_tb_key_t *)p_up_key;
   121a6:	601a      	str	r2, [r3, #0]
        p_up_key->state = M_TB_KEY_STATE_NORMAL;
   121a8:	7056      	strb	r6, [r2, #1]

        // Only Keep valid NID
        m_tb_key_nid_tbl_del(net_key_lid);
   121aa:	f7ff fb3d 	bl	11828 <m_tb_key_nid_tbl_del>
        m_tb_key_nid_tbl_del(net_key_lid | M_TB_KEY_NEW_BIT);
   121ae:	2080      	movs	r0, #128	; 0x80
   121b0:	4320      	orrs	r0, r4
   121b2:	f7ff fb39 	bl	11828 <m_tb_key_nid_tbl_del>
        m_tb_key_nid_tbl_add(net_key_lid, p_up_key->nid);
   121b6:	9b03      	ldr	r3, [sp, #12]
   121b8:	0020      	movs	r0, r4
   121ba:	3342      	adds	r3, #66	; 0x42
   121bc:	7819      	ldrb	r1, [r3, #0]
   121be:	f7ff fb09 	bl	117d4 <m_tb_key_nid_tbl_add>

        // Delete old network key
        m_al_free(p_old_key);
   121c2:	9801      	ldr	r0, [sp, #4]
   121c4:	f7f3 fa0a 	bl	55dc <m_al_free>
        p_env->p_up->p_keys[net_key_lid] = NULL;
   121c8:	6b6b      	ldr	r3, [r5, #52]	; 0x34
   121ca:	00a2      	lsls	r2, r4, #2
   121cc:	50d6      	str	r6, [r2, r3]
        p_env->p_up->nb_key--;
   121ce:	3334      	adds	r3, #52	; 0x34
   121d0:	781a      	ldrb	r2, [r3, #0]
   121d2:	3a01      	subs	r2, #1
   121d4:	701a      	strb	r2, [r3, #0]

        // If there is no more key to update, remove update table
        if (p_env->p_up->nb_key == 0)
   121d6:	6b68      	ldr	r0, [r5, #52]	; 0x34
   121d8:	0003      	movs	r3, r0
   121da:	3334      	adds	r3, #52	; 0x34
   121dc:	781e      	ldrb	r6, [r3, #0]
   121de:	2e00      	cmp	r6, #0
   121e0:	d13e      	bne.n	12260 <m_tb_key_net_revoke_old+0x10c>
        {
            m_al_free(p_env->p_up);
   121e2:	f7f3 f9fb 	bl	55dc <m_al_free>
            p_env->p_up = NULL;
   121e6:	636e      	str	r6, [r5, #52]	; 0x34
   121e8:	e03a      	b.n	12260 <m_tb_key_net_revoke_old+0x10c>
   121ea:	002e      	movs	r6, r5
            break;
        }

        p_old_key->state = M_TB_KEY_STATE_NORMAL;

        if (p_old_key->nb_app_keys)
   121ec:	2703      	movs	r7, #3
   121ee:	360c      	adds	r6, #12
            m_lid_t i;

            for (i = M_TB_KEY_APP_START_LID; i < M_TB_KEY_APP_END_LID; i++)
            {
                // Get application key
                m_tb_key_app_t *p_key_app = (m_tb_key_app_t *)p_env->p_keys[i];
   121f0:	6833      	ldr	r3, [r6, #0]
   121f2:	9302      	str	r3, [sp, #8]
                // Updated application key
                m_tb_key_app_t *p_up_app_key;

                // Check if key exists and is bound with the network key
                if ((p_key_app == NULL)
   121f4:	2b00      	cmp	r3, #0
   121f6:	d02e      	beq.n	12256 <m_tb_key_net_revoke_old+0x102>
                        || (p_key_app->net_key_lid != net_key_lid))
   121f8:	7d9b      	ldrb	r3, [r3, #22]
   121fa:	42a3      	cmp	r3, r4
   121fc:	d12b      	bne.n	12256 <m_tb_key_net_revoke_old+0x102>
                {
                    continue;
                }

                // Remove binding information in the NetKeyLID/AID/AppKeyLID table
                m_tb_key_aid_tbl_del(net_key_lid, i);
   121fe:	b2f9      	uxtb	r1, r7
   12200:	0020      	movs	r0, r4
   12202:	f7ff fb95 	bl	11930 <m_tb_key_aid_tbl_del>

                // Try to get updated application key
                p_up_app_key = (m_tb_key_app_t *)p_env->p_up->p_keys[i];
   12206:	00bb      	lsls	r3, r7, #2
   12208:	9305      	str	r3, [sp, #20]
   1220a:	6b6b      	ldr	r3, [r5, #52]	; 0x34
   1220c:	00ba      	lsls	r2, r7, #2
   1220e:	58d3      	ldr	r3, [r2, r3]

                // Check that key is being updated
                if (p_up_app_key)
   12210:	2b00      	cmp	r3, #0
   12212:	d016      	beq.n	12242 <m_tb_key_net_revoke_old+0xee>
                    // The updated key is now the normal key
                    p_env->p_keys[i] = (m_tb_key_t *)p_up_app_key;
                    p_up_app_key->nb_models = p_key_app->nb_models;

                    // Remove binding information in the NetKeyLID/AID/AppKeyLID table
                    m_tb_key_aid_tbl_del(net_key_lid, i | M_TB_KEY_NEW_BIT);
   12214:	2180      	movs	r1, #128	; 0x80
                // Check that key is being updated
                if (p_up_app_key)
                {
                    // The updated key is now the normal key
                    p_env->p_keys[i] = (m_tb_key_t *)p_up_app_key;
                    p_up_app_key->nb_models = p_key_app->nb_models;
   12216:	9a02      	ldr	r2, [sp, #8]

                // Check that key is being updated
                if (p_up_app_key)
                {
                    // The updated key is now the normal key
                    p_env->p_keys[i] = (m_tb_key_t *)p_up_app_key;
   12218:	6033      	str	r3, [r6, #0]
                    p_up_app_key->nb_models = p_key_app->nb_models;
   1221a:	7c92      	ldrb	r2, [r2, #18]

                    // Remove binding information in the NetKeyLID/AID/AppKeyLID table
                    m_tb_key_aid_tbl_del(net_key_lid, i | M_TB_KEY_NEW_BIT);
   1221c:	4249      	negs	r1, r1
                // Check that key is being updated
                if (p_up_app_key)
                {
                    // The updated key is now the normal key
                    p_env->p_keys[i] = (m_tb_key_t *)p_up_app_key;
                    p_up_app_key->nb_models = p_key_app->nb_models;
   1221e:	749a      	strb	r2, [r3, #18]

                    // Remove binding information in the NetKeyLID/AID/AppKeyLID table
                    m_tb_key_aid_tbl_del(net_key_lid, i | M_TB_KEY_NEW_BIT);
   12220:	b2fb      	uxtb	r3, r7
   12222:	4319      	orrs	r1, r3
   12224:	b2c9      	uxtb	r1, r1
   12226:	0020      	movs	r0, r4
   12228:	f7ff fb82 	bl	11930 <m_tb_key_aid_tbl_del>

                    // Delete old application key
                    m_al_free(p_key_app);
   1222c:	9802      	ldr	r0, [sp, #8]
   1222e:	f7f3 f9d5 	bl	55dc <m_al_free>
                    p_env->p_up->p_keys[i] = NULL;
   12232:	2200      	movs	r2, #0
   12234:	6b6b      	ldr	r3, [r5, #52]	; 0x34
   12236:	00b9      	lsls	r1, r7, #2
   12238:	50ca      	str	r2, [r1, r3]
                    p_env->p_up->nb_key--;
   1223a:	3334      	adds	r3, #52	; 0x34
   1223c:	781a      	ldrb	r2, [r3, #0]
   1223e:	3a01      	subs	r2, #1
   12240:	701a      	strb	r2, [r3, #0]
                }

                // Add binding information in the NetKeyLID/AID/AppKeyLID table
                p_key_app = (m_tb_key_app_t *)p_env->p_keys[i];
                m_tb_key_aid_tbl_add(net_key_lid, i, p_key_app->aid);
   12242:	6833      	ldr	r3, [r6, #0]
   12244:	b2f9      	uxtb	r1, r7
   12246:	0020      	movs	r0, r4
   12248:	7cda      	ldrb	r2, [r3, #19]
   1224a:	f7ff fb21 	bl	11890 <m_tb_key_aid_tbl_add>

                // Inform the storage manager about the update
                m_tb_store_update_ind(M_TB_STORE_UPD_TYPE_APP_KEY_UPDATED, i);
   1224e:	0039      	movs	r1, r7
   12250:	2002      	movs	r0, #2
   12252:	f002 fce1 	bl	14c18 <m_tb_store_update_ind>
   12256:	3701      	adds	r7, #1
   12258:	3604      	adds	r6, #4
        if (p_old_key->nb_app_keys)
        {
            // Counter
            m_lid_t i;

            for (i = M_TB_KEY_APP_START_LID; i < M_TB_KEY_APP_END_LID; i++)
   1225a:	2f0c      	cmp	r7, #12
   1225c:	d1c8      	bne.n	121f0 <m_tb_key_net_revoke_old+0x9c>
   1225e:	e79e      	b.n	1219e <m_tb_key_net_revoke_old+0x4a>
        // Update friendship security credentials
        m_tb_key_friend_revoke_old(net_key_lid);
        #endif //(BLE_MESH_FRIEND || BLE_MESH_LPN)

        // Inform the storage manager about the update
        m_tb_store_update_ind(M_TB_STORE_UPD_TYPE_NET_KEY_UPDATED, net_key_lid);
   12260:	2000      	movs	r0, #0
   12262:	0021      	movs	r1, r4
   12264:	f002 fcd8 	bl	14c18 <m_tb_store_update_ind>
}

uint16_t m_tb_key_net_revoke_old(m_lid_t net_key_lid)
{
    // Returned status
    uint16_t status = M_ERR_NO_ERROR;
   12268:	2000      	movs	r0, #0
   1226a:	e006      	b.n	1227a <m_tb_key_net_revoke_old+0x126>
        // Force having only the local index
        net_key_lid = GETF(net_key_lid, M_TB_KEY_LID);

        if ((net_key_lid < M_TB_KEY_NET_START_LID) || (net_key_lid > M_TB_KEY_NET_END_LID))
        {
            status  = M_ERR_INVALID_NETKEY_ID;
   1226c:	2090      	movs	r0, #144	; 0x90
   1226e:	00c0      	lsls	r0, r0, #3
   12270:	e003      	b.n	1227a <m_tb_key_net_revoke_old+0x126>
        }

        // Ensure that no key creation is on-going
        if (GETB(p_env->status, M_TB_KEY_STATE_KEY_GEN))
        {
            status = M_ERR_COMMAND_DISALLOWED;
   12272:	4804      	ldr	r0, [pc, #16]	; (12284 <m_tb_key_net_revoke_old+0x130>)
   12274:	e001      	b.n	1227a <m_tb_key_net_revoke_old+0x126>
        }

        // Check if key is under update
        if (p_env->p_up == NULL)
        {
            status = M_ERR_CANNOT_UPDATE;
   12276:	20b8      	movs	r0, #184	; 0xb8
   12278:	0100      	lsls	r0, r0, #4
        // Inform the storage manager about the update
        m_tb_store_update_ind(M_TB_STORE_UPD_TYPE_NET_KEY_UPDATED, net_key_lid);
    } while(0);

    return (status);
}
   1227a:	b007      	add	sp, #28
   1227c:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1227e:	46c0      	nop			; (mov r8, r8)
   12280:	100126c0 	.word	0x100126c0
   12284:	00000282 	.word	0x00000282

00012288 <m_tb_key_net_find>:

uint16_t m_tb_key_net_find(uint16_t net_key_id, m_lid_t *p_net_key_lid)
{
    uint16_t        status = M_ERR_INVALID_NETKEY_ID;
    m_tb_key_env_t* p_env  = p_m_tb_key_env;
   12288:	4b0d      	ldr	r3, [pc, #52]	; (122c0 <m_tb_key_net_find+0x38>)
   1228a:	681a      	ldr	r2, [r3, #0]
    m_lid_t         i;

    // Seek for a key that have searched net key index
    for(i = M_TB_KEY_NET_START_LID; i <= M_TB_KEY_NET_END_LID; i++)
    {
        p_key = (m_tb_key_net_t*) p_env->p_keys[i];
   1228c:	6853      	ldr	r3, [r2, #4]

        if(p_key != NULL)
   1228e:	2b00      	cmp	r3, #0
   12290:	d003      	beq.n	1229a <m_tb_key_net_find+0x12>
        {
            // Network index found
            if(p_key->net_key_id == net_key_id)
   12292:	3306      	adds	r3, #6
   12294:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
   12296:	4283      	cmp	r3, r0
   12298:	d00a      	beq.n	122b0 <m_tb_key_net_find+0x28>
    m_lid_t         i;

    // Seek for a key that have searched net key index
    for(i = M_TB_KEY_NET_START_LID; i <= M_TB_KEY_NET_END_LID; i++)
    {
        p_key = (m_tb_key_net_t*) p_env->p_keys[i];
   1229a:	6893      	ldr	r3, [r2, #8]

        if(p_key != NULL)
   1229c:	2b00      	cmp	r3, #0
   1229e:	d00b      	beq.n	122b8 <m_tb_key_net_find+0x30>
        {
            // Network index found
            if(p_key->net_key_id == net_key_id)
   122a0:	3306      	adds	r3, #6
   122a2:	8fda      	ldrh	r2, [r3, #62]	; 0x3e
    return (status);
}

uint16_t m_tb_key_net_find(uint16_t net_key_id, m_lid_t *p_net_key_lid)
{
    uint16_t        status = M_ERR_INVALID_NETKEY_ID;
   122a4:	2390      	movs	r3, #144	; 0x90
   122a6:	00db      	lsls	r3, r3, #3
        p_key = (m_tb_key_net_t*) p_env->p_keys[i];

        if(p_key != NULL)
        {
            // Network index found
            if(p_key->net_key_id == net_key_id)
   122a8:	4282      	cmp	r2, r0
   122aa:	d107      	bne.n	122bc <m_tb_key_net_find+0x34>
    m_tb_key_env_t* p_env  = p_m_tb_key_env;
    m_tb_key_net_t* p_key  = NULL;
    m_lid_t         i;

    // Seek for a key that have searched net key index
    for(i = M_TB_KEY_NET_START_LID; i <= M_TB_KEY_NET_END_LID; i++)
   122ac:	2302      	movs	r3, #2
   122ae:	e000      	b.n	122b2 <m_tb_key_net_find+0x2a>
   122b0:	2301      	movs	r3, #1
        if(p_key != NULL)
        {
            // Network index found
            if(p_key->net_key_id == net_key_id)
            {
                *p_net_key_lid = i;
   122b2:	700b      	strb	r3, [r1, #0]
                status      = M_ERR_NO_ERROR;
   122b4:	2300      	movs	r3, #0
                break;
   122b6:	e001      	b.n	122bc <m_tb_key_net_find+0x34>
    return (status);
}

uint16_t m_tb_key_net_find(uint16_t net_key_id, m_lid_t *p_net_key_lid)
{
    uint16_t        status = M_ERR_INVALID_NETKEY_ID;
   122b8:	2390      	movs	r3, #144	; 0x90
   122ba:	00db      	lsls	r3, r3, #3
            }
        }
    }

    return (status);
}
   122bc:	0018      	movs	r0, r3
   122be:	4770      	bx	lr
   122c0:	100126c0 	.word	0x100126c0

000122c4 <m_tb_key_net_next>:
 ****************************************************************************************
 */
uint16_t m_tb_key_net_next(m_lid_t* p_net_key_lid, const m_tb_key_net_t** pp_net_key)
{
    uint16_t        status = M_ERR_INVALID_NETKEY_ID;
    m_tb_key_env_t* p_env  = p_m_tb_key_env;
   122c4:	4b12      	ldr	r3, [pc, #72]	; (12310 <m_tb_key_net_next+0x4c>)
 *
 * @return Execution status (@see enum m_error)
 ****************************************************************************************
 */
uint16_t m_tb_key_net_next(m_lid_t* p_net_key_lid, const m_tb_key_net_t** pp_net_key)
{
   122c6:	b530      	push	{r4, r5, lr}
    uint16_t        status = M_ERR_INVALID_NETKEY_ID;
    m_tb_key_env_t* p_env  = p_m_tb_key_env;
   122c8:	681c      	ldr	r4, [r3, #0]

    // Ensure that one key is available
    if(p_env->nb_net_keys > 0)
   122ca:	0023      	movs	r3, r4
   122cc:	33b8      	adds	r3, #184	; 0xb8
   122ce:	781b      	ldrb	r3, [r3, #0]
   122d0:	2b00      	cmp	r3, #0
   122d2:	d019      	beq.n	12308 <m_tb_key_net_next+0x44>
    {
        // force having only the local identifier index
        *p_net_key_lid = GETF(*p_net_key_lid, M_TB_KEY_LID);
   122d4:	237f      	movs	r3, #127	; 0x7f
   122d6:	7802      	ldrb	r2, [r0, #0]
   122d8:	4013      	ands	r3, r2

        // Update range
        if((*p_net_key_lid >  M_TB_KEY_NET_END_LID) || (*p_net_key_lid <  M_TB_KEY_NET_START_LID))
   122da:	1e5a      	subs	r2, r3, #1
   122dc:	2a01      	cmp	r2, #1
   122de:	d900      	bls.n	122e2 <m_tb_key_net_next+0x1e>
        {
            *p_net_key_lid = M_TB_KEY_NET_START_LID;
   122e0:	2301      	movs	r3, #1
        {
            // Check Next Key
            (*p_net_key_lid)++;
            if((*p_net_key_lid >  M_TB_KEY_NET_END_LID))
            {
                *p_net_key_lid = M_TB_KEY_NET_START_LID;
   122e2:	2501      	movs	r5, #1
   122e4:	7003      	strb	r3, [r0, #0]
        {
            *p_net_key_lid = M_TB_KEY_NET_START_LID;
        }

        // Find first available key
        while(p_env->p_keys[*p_net_key_lid] == NULL)
   122e6:	7803      	ldrb	r3, [r0, #0]
   122e8:	009a      	lsls	r2, r3, #2
   122ea:	5912      	ldr	r2, [r2, r4]
   122ec:	2a00      	cmp	r2, #0
   122ee:	d106      	bne.n	122fe <m_tb_key_net_next+0x3a>
        {
            // Check Next Key
            (*p_net_key_lid)++;
   122f0:	3301      	adds	r3, #1
   122f2:	b2db      	uxtb	r3, r3
   122f4:	7003      	strb	r3, [r0, #0]
            if((*p_net_key_lid >  M_TB_KEY_NET_END_LID))
   122f6:	2b02      	cmp	r3, #2
   122f8:	d9f5      	bls.n	122e6 <m_tb_key_net_next+0x22>
            {
                *p_net_key_lid = M_TB_KEY_NET_START_LID;
   122fa:	7005      	strb	r5, [r0, #0]
   122fc:	e7f3      	b.n	122e6 <m_tb_key_net_next+0x22>
        if(pp_net_key != NULL)
        {
            *pp_net_key = (m_tb_key_net_t*) p_env->p_keys[*p_net_key_lid];
        }

        status = M_ERR_NO_ERROR;
   122fe:	1e08      	subs	r0, r1, #0
                *p_net_key_lid = M_TB_KEY_NET_START_LID;
            }
        }

        // Return available key
        if(pp_net_key != NULL)
   12300:	d004      	beq.n	1230c <m_tb_key_net_next+0x48>
        {
            *pp_net_key = (m_tb_key_net_t*) p_env->p_keys[*p_net_key_lid];
   12302:	600a      	str	r2, [r1, #0]
        }

        status = M_ERR_NO_ERROR;
   12304:	2000      	movs	r0, #0
   12306:	e001      	b.n	1230c <m_tb_key_net_next+0x48>
 * @return Execution status (@see enum m_error)
 ****************************************************************************************
 */
uint16_t m_tb_key_net_next(m_lid_t* p_net_key_lid, const m_tb_key_net_t** pp_net_key)
{
    uint16_t        status = M_ERR_INVALID_NETKEY_ID;
   12308:	2090      	movs	r0, #144	; 0x90
   1230a:	00c0      	lsls	r0, r0, #3

        status = M_ERR_NO_ERROR;
    }

    return (status);
}
   1230c:	bd30      	pop	{r4, r5, pc}
   1230e:	46c0      	nop			; (mov r8, r8)
   12310:	100126c0 	.word	0x100126c0

00012314 <m_tb_key_net_get>:

uint16_t m_tb_key_net_get(m_lid_t net_key_lid, const m_tb_key_net_t **pp_net_key, bool tx)
{
   12314:	b5f0      	push	{r4, r5, r6, r7, lr}
	M_PRINTF(L_TB, "net_key_lid = 0x%x", net_key_lid);
   12316:	4b25      	ldr	r3, [pc, #148]	; (123ac <m_tb_key_net_get+0x98>)

    return (status);
}

uint16_t m_tb_key_net_get(m_lid_t net_key_lid, const m_tb_key_net_t **pp_net_key, bool tx)
{
   12318:	b085      	sub	sp, #20
	M_PRINTF(L_TB, "net_key_lid = 0x%x", net_key_lid);
   1231a:	681b      	ldr	r3, [r3, #0]

    return (status);
}

uint16_t m_tb_key_net_get(m_lid_t net_key_lid, const m_tb_key_net_t **pp_net_key, bool tx)
{
   1231c:	0004      	movs	r4, r0
   1231e:	9103      	str	r1, [sp, #12]
   12320:	0017      	movs	r7, r2
	M_PRINTF(L_TB, "net_key_lid = 0x%x", net_key_lid);
   12322:	079b      	lsls	r3, r3, #30
   12324:	d516      	bpl.n	12354 <m_tb_key_net_get+0x40>
   12326:	4e22      	ldr	r6, [pc, #136]	; (123b0 <m_tb_key_net_get+0x9c>)
   12328:	4d22      	ldr	r5, [pc, #136]	; (123b4 <m_tb_key_net_get+0xa0>)
   1232a:	0033      	movs	r3, r6
   1232c:	002a      	movs	r2, r5
   1232e:	0028      	movs	r0, r5
   12330:	332c      	adds	r3, #44	; 0x2c
   12332:	3237      	adds	r2, #55	; 0x37
   12334:	9300      	str	r3, [sp, #0]
   12336:	0029      	movs	r1, r5
   12338:	4b1f      	ldr	r3, [pc, #124]	; (123b8 <m_tb_key_net_get+0xa4>)
   1233a:	3042      	adds	r0, #66	; 0x42
   1233c:	f7f2 fb36 	bl	49ac <m_print>
   12340:	0030      	movs	r0, r6
   12342:	0021      	movs	r1, r4
   12344:	303d      	adds	r0, #61	; 0x3d
   12346:	f7f2 fb31 	bl	49ac <m_print>
   1234a:	481c      	ldr	r0, [pc, #112]	; (123bc <m_tb_key_net_get+0xa8>)
   1234c:	1da9      	adds	r1, r5, #6
   1234e:	3003      	adds	r0, #3
   12350:	f7f2 fb2c 	bl	49ac <m_print>
    // Returned status
    uint16_t status = M_ERR_NO_ERROR;

    do
    {
        m_tb_key_env_t *p_env = p_m_tb_key_env;
   12354:	4b1a      	ldr	r3, [pc, #104]	; (123c0 <m_tb_key_net_get+0xac>)
   12356:	6819      	ldr	r1, [r3, #0]
        m_tb_key_t *p_key = NULL;
        m_lid_t base_lid = GETF(net_key_lid, M_TB_KEY_LID);
   12358:	237f      	movs	r3, #127	; 0x7f
   1235a:	4023      	ands	r3, r4

        // Sanity check
        ASSERT_INFO((base_lid >= M_TB_KEY_NET_START_LID) && (base_lid <= M_TB_KEY_NET_END_LID), base_lid, 0);
   1235c:	1e5a      	subs	r2, r3, #1
   1235e:	b2d2      	uxtb	r2, r2
   12360:	2a01      	cmp	r2, #1
   12362:	d8fd      	bhi.n	12360 <m_tb_key_net_get+0x4c>

        // Retrieve key
        p_key = p_env->p_keys[base_lid];
   12364:	009b      	lsls	r3, r3, #2
   12366:	585a      	ldr	r2, [r3, r1]

        if (p_key == NULL)
   12368:	2a00      	cmp	r2, #0
   1236a:	d018      	beq.n	1239e <m_tb_key_net_get+0x8a>
            status  = M_ERR_INVALID_NETKEY_ID;
            break;
        }

        // Check if key in update table should be returned
        if (p_key->state != M_TB_KEY_STATE_NORMAL)
   1236c:	7850      	ldrb	r0, [r2, #1]
   1236e:	2800      	cmp	r0, #0
   12370:	d00c      	beq.n	1238c <m_tb_key_net_get+0x78>
        {
            if (tx)
   12372:	2f00      	cmp	r7, #0
   12374:	d002      	beq.n	1237c <m_tb_key_net_get+0x68>
            {
                if (p_key->state == M_TB_KEY_STATE_P2)
   12376:	2802      	cmp	r0, #2
   12378:	d10d      	bne.n	12396 <m_tb_key_net_get+0x82>
   1237a:	e002      	b.n	12382 <m_tb_key_net_get+0x6e>
                    p_key = p_env->p_up->p_keys[base_lid];
                }
            }
            else
            {
                if (GETB(net_key_lid, M_TB_KEY_NEW))
   1237c:	b264      	sxtb	r4, r4
   1237e:	2c00      	cmp	r4, #0
   12380:	da09      	bge.n	12396 <m_tb_key_net_get+0x82>
                {
                    p_key = p_env->p_up->p_keys[base_lid];
   12382:	6b4a      	ldr	r2, [r1, #52]	; 0x34
   12384:	589a      	ldr	r2, [r3, r2]
                }
            }

            // Sanity check
            ASSERT_INFO(p_key, tx, net_key_lid);
   12386:	2a00      	cmp	r2, #0
   12388:	d105      	bne.n	12396 <m_tb_key_net_get+0x82>
   1238a:	e7fe      	b.n	1238a <m_tb_key_net_get+0x76>
        }
        else
        {
            if (!tx && GETB(net_key_lid, M_TB_KEY_NEW))
   1238c:	2f00      	cmp	r7, #0
   1238e:	d102      	bne.n	12396 <m_tb_key_net_get+0x82>
   12390:	b264      	sxtb	r4, r4
   12392:	2c00      	cmp	r4, #0
   12394:	db06      	blt.n	123a4 <m_tb_key_net_get+0x90>
                status  = M_ERR_NOT_FOUND;
                break;
            }
        }

        *pp_net_key = (const m_tb_key_net_t *)p_key;
   12396:	9b03      	ldr	r3, [sp, #12]

uint16_t m_tb_key_net_get(m_lid_t net_key_lid, const m_tb_key_net_t **pp_net_key, bool tx)
{
	M_PRINTF(L_TB, "net_key_lid = 0x%x", net_key_lid);
    // Returned status
    uint16_t status = M_ERR_NO_ERROR;
   12398:	2000      	movs	r0, #0
                status  = M_ERR_NOT_FOUND;
                break;
            }
        }

        *pp_net_key = (const m_tb_key_net_t *)p_key;
   1239a:	601a      	str	r2, [r3, #0]
   1239c:	e003      	b.n	123a6 <m_tb_key_net_get+0x92>
        // Retrieve key
        p_key = p_env->p_keys[base_lid];

        if (p_key == NULL)
        {
            status  = M_ERR_INVALID_NETKEY_ID;
   1239e:	2090      	movs	r0, #144	; 0x90
   123a0:	00c0      	lsls	r0, r0, #3
   123a2:	e000      	b.n	123a6 <m_tb_key_net_get+0x92>
        }
        else
        {
            if (!tx && GETB(net_key_lid, M_TB_KEY_NEW))
            {
                status  = M_ERR_NOT_FOUND;
   123a4:	4807      	ldr	r0, [pc, #28]	; (123c4 <m_tb_key_net_get+0xb0>)

        *pp_net_key = (const m_tb_key_net_t *)p_key;
    } while(0);

    return (status);
}
   123a6:	b005      	add	sp, #20
   123a8:	bdf0      	pop	{r4, r5, r6, r7, pc}
   123aa:	46c0      	nop			; (mov r8, r8)
   123ac:	10010514 	.word	0x10010514
   123b0:	00022744 	.word	0x00022744
   123b4:	00022644 	.word	0x00022644
   123b8:	0000083a 	.word	0x0000083a
   123bc:	000226c4 	.word	0x000226c4
   123c0:	100126c0 	.word	0x100126c0
   123c4:	00000682 	.word	0x00000682

000123c8 <m_tb_key_net_get_ids>:
    uint32_t wr_val = 0;

    // Loop over all network keys
    for (cnt = M_TB_KEY_NET_START_LID; cnt <= M_TB_KEY_NET_END_LID; cnt++)
    {
        if (p_m_tb_key_env->p_keys[cnt])
   123c8:	4b14      	ldr	r3, [pc, #80]	; (1241c <m_tb_key_net_get_ids+0x54>)

    return (status);
}

void m_tb_key_net_get_ids(uint8_t *p_netkey_ids)
{
   123ca:	b5f0      	push	{r4, r5, r6, r7, lr}
    uint32_t wr_val = 0;

    // Loop over all network keys
    for (cnt = M_TB_KEY_NET_START_LID; cnt <= M_TB_KEY_NET_END_LID; cnt++)
    {
        if (p_m_tb_key_env->p_keys[cnt])
   123cc:	681c      	ldr	r4, [r3, #0]
    // Counter
    uint8_t cnt;
    // Number of provided NetKey indexes
    uint8_t prov_net_keys = 0;
    // Value to write
    uint32_t wr_val = 0;
   123ce:	2300      	movs	r3, #0
   123d0:	0026      	movs	r6, r4
void m_tb_key_net_get_ids(uint8_t *p_netkey_ids)
{
    // Counter
    uint8_t cnt;
    // Number of provided NetKey indexes
    uint8_t prov_net_keys = 0;
   123d2:	0019      	movs	r1, r3
            // Network key information
            m_tb_key_net_t *p_key_net = (m_tb_key_net_t *)(p_m_tb_key_env->p_keys[cnt]);
            // Get NetKey index
            uint16_t netkey_id = p_key_net->net_key_id;

            if (prov_net_keys & 0x1)
   123d4:	2701      	movs	r7, #1
   123d6:	1d25      	adds	r5, r4, #4
   123d8:	360c      	adds	r6, #12
            }

            // Increment number of provided keys
            prov_net_keys++;

            if (prov_net_keys == p_m_tb_key_env->nb_net_keys)
   123da:	34b8      	adds	r4, #184	; 0xb8
    uint32_t wr_val = 0;

    // Loop over all network keys
    for (cnt = M_TB_KEY_NET_START_LID; cnt <= M_TB_KEY_NET_END_LID; cnt++)
    {
        if (p_m_tb_key_env->p_keys[cnt])
   123dc:	682a      	ldr	r2, [r5, #0]
   123de:	2a00      	cmp	r2, #0
   123e0:	d013      	beq.n	1240a <m_tb_key_net_get_ids+0x42>
        {
            // Network key information
            m_tb_key_net_t *p_key_net = (m_tb_key_net_t *)(p_m_tb_key_env->p_keys[cnt]);
            // Get NetKey index
            uint16_t netkey_id = p_key_net->net_key_id;
   123e2:	3206      	adds	r2, #6
   123e4:	8fd2      	ldrh	r2, [r2, #62]	; 0x3e

            if (prov_net_keys & 0x1)
   123e6:	4239      	tst	r1, r7
   123e8:	d009      	beq.n	123fe <m_tb_key_net_get_ids+0x36>
            {
                wr_val |= ((uint32_t)netkey_id << 12);
   123ea:	0312      	lsls	r2, r2, #12
   123ec:	4313      	orrs	r3, r2
 */
__INLINE_S__ void co_write24p(void const *ptr24, uint32_t value)
{
    uint8_t *ptr=(uint8_t*)ptr24;

    *ptr++ = (uint8_t)(value&0xff);
   123ee:	7003      	strb	r3, [r0, #0]
    *ptr++ = (uint8_t)((value&0xff00)>>8);
   123f0:	0a1a      	lsrs	r2, r3, #8
    *ptr++ = (uint8_t)((value&0xff0000)>>16);
   123f2:	0c1b      	lsrs	r3, r3, #16
   123f4:	7083      	strb	r3, [r0, #2]
__INLINE_S__ void co_write24p(void const *ptr24, uint32_t value)
{
    uint8_t *ptr=(uint8_t*)ptr24;

    *ptr++ = (uint8_t)(value&0xff);
    *ptr++ = (uint8_t)((value&0xff00)>>8);
   123f6:	7042      	strb	r2, [r0, #1]

                // Write the last two indexes
                co_write24p(p_netkey_ids, wr_val);
                wr_val = 0;
   123f8:	2300      	movs	r3, #0

                // Move pointer
                p_netkey_ids += 3;
   123fa:	3003      	adds	r0, #3
   123fc:	e000      	b.n	12400 <m_tb_key_net_get_ids+0x38>
            }
            else
            {
                wr_val = (uint32_t)netkey_id;
   123fe:	0013      	movs	r3, r2
            }

            // Increment number of provided keys
            prov_net_keys++;
   12400:	3101      	adds	r1, #1

            if (prov_net_keys == p_m_tb_key_env->nb_net_keys)
   12402:	7822      	ldrb	r2, [r4, #0]
            {
                wr_val = (uint32_t)netkey_id;
            }

            // Increment number of provided keys
            prov_net_keys++;
   12404:	b2c9      	uxtb	r1, r1

            if (prov_net_keys == p_m_tb_key_env->nb_net_keys)
   12406:	4291      	cmp	r1, r2
   12408:	d002      	beq.n	12410 <m_tb_key_net_get_ids+0x48>
   1240a:	3504      	adds	r5, #4
    uint8_t prov_net_keys = 0;
    // Value to write
    uint32_t wr_val = 0;

    // Loop over all network keys
    for (cnt = M_TB_KEY_NET_START_LID; cnt <= M_TB_KEY_NET_END_LID; cnt++)
   1240c:	42b5      	cmp	r5, r6
   1240e:	d1e5      	bne.n	123dc <m_tb_key_net_get_ids+0x14>
                break;
            }
        }
    }

    if (prov_net_keys & 0x1)
   12410:	07ca      	lsls	r2, r1, #31
   12412:	d502      	bpl.n	1241a <m_tb_key_net_get_ids+0x52>
 */
__INLINE_S__ void co_write16p(void const *ptr16, uint16_t value)
{
    uint8_t *ptr=(uint8_t*)ptr16;

    *ptr++ = value&0xff;
   12414:	7003      	strb	r3, [r0, #0]
    *ptr = (value&0xff00)>>8;
   12416:	0a1b      	lsrs	r3, r3, #8
   12418:	7043      	strb	r3, [r0, #1]
    {
        // Write the index
        co_write16p(p_netkey_ids, wr_val);
    }
}
   1241a:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1241c:	100126c0 	.word	0x100126c0

00012420 <m_tb_key_net_lid_from_nid>:

m_lid_t m_tb_key_net_lid_from_nid(uint8_t nid, uint8_t offset)
{
    int8_t i;
    m_tb_key_env_t* p_env  = p_m_tb_key_env;
   12420:	4b12      	ldr	r3, [pc, #72]	; (1246c <m_tb_key_net_lid_from_nid+0x4c>)
        co_write16p(p_netkey_ids, wr_val);
    }
}

m_lid_t m_tb_key_net_lid_from_nid(uint8_t nid, uint8_t offset)
{
   12422:	b530      	push	{r4, r5, lr}
    int8_t i;
    m_tb_key_env_t* p_env  = p_m_tb_key_env;
   12424:	681c      	ldr	r4, [r3, #0]
    m_lid_t         net_lid = M_INVALID_LID;

    // browse list in reverse order
    for(i = 0 ; i < p_env->nb_nids ; i++)
   12426:	0023      	movs	r3, r4
   12428:	33b5      	adds	r3, #181	; 0xb5
   1242a:	781d      	ldrb	r5, [r3, #0]
   1242c:	2300      	movs	r3, #0
   1242e:	42ab      	cmp	r3, r5
   12430:	da0b      	bge.n	1244a <m_tb_key_net_lid_from_nid+0x2a>
    {
        // Find a valid NID
        if(p_env->map_nid_nk[i].nid == nid)
   12432:	001a      	movs	r2, r3
   12434:	3220      	adds	r2, #32
   12436:	0052      	lsls	r2, r2, #1
   12438:	5d12      	ldrb	r2, [r2, r4]
   1243a:	4282      	cmp	r2, r0
   1243c:	d005      	beq.n	1244a <m_tb_key_net_lid_from_nid+0x2a>
        {
            break;
        }
        // NID not found - stop search
        else if(p_env->map_nid_nk[i].nid > nid)
   1243e:	d901      	bls.n	12444 <m_tb_key_net_lid_from_nid+0x24>
        {
            i = p_env->nb_nids;
   12440:	b26b      	sxtb	r3, r5
            break;
   12442:	e002      	b.n	1244a <m_tb_key_net_lid_from_nid+0x2a>
   12444:	1c5a      	adds	r2, r3, #1
   12446:	b253      	sxtb	r3, r2
   12448:	e7f1      	b.n	1242e <m_tb_key_net_lid_from_nid+0xe>
        }
    }

    // add offset to the requested NID
    i += offset;
   1244a:	18c9      	adds	r1, r1, r3
   1244c:	b249      	sxtb	r1, r1

m_lid_t m_tb_key_net_lid_from_nid(uint8_t nid, uint8_t offset)
{
    int8_t i;
    m_tb_key_env_t* p_env  = p_m_tb_key_env;
    m_lid_t         net_lid = M_INVALID_LID;
   1244e:	22ff      	movs	r2, #255	; 0xff

    // add offset to the requested NID
    i += offset;

    // Check that requested value is valid
    if((i < p_env->nb_nids) && (p_env->map_nid_nk[i].nid == nid))
   12450:	428d      	cmp	r5, r1
   12452:	dd08      	ble.n	12466 <m_tb_key_net_lid_from_nid+0x46>
   12454:	0049      	lsls	r1, r1, #1
   12456:	1863      	adds	r3, r4, r1
   12458:	0019      	movs	r1, r3
   1245a:	3140      	adds	r1, #64	; 0x40
   1245c:	7809      	ldrb	r1, [r1, #0]
   1245e:	4281      	cmp	r1, r0
   12460:	d101      	bne.n	12466 <m_tb_key_net_lid_from_nid+0x46>
    {
        net_lid = p_env->map_nid_nk[i].net_key_lid;
   12462:	3341      	adds	r3, #65	; 0x41
   12464:	781a      	ldrb	r2, [r3, #0]
    }

    return net_lid;
}
   12466:	0010      	movs	r0, r2
   12468:	bd30      	pop	{r4, r5, pc}
   1246a:	46c0      	nop			; (mov r8, r8)
   1246c:	100126c0 	.word	0x100126c0

00012470 <m_tb_key_app_add>:

uint16_t m_tb_key_app_add(uint16_t app_key_id, const uint8_t *p_app_key, m_lid_t net_key_lid,
                          m_tb_key_added_cb res_cb)
{
   12470:	b5f0      	push	{r4, r5, r6, r7, lr}
   12472:	b085      	sub	sp, #20
   12474:	9303      	str	r3, [sp, #12]
	M_PRINTF(L_TB, "");
   12476:	4b3a      	ldr	r3, [pc, #232]	; (12560 <m_tb_key_app_add+0xf0>)
    return net_lid;
}

uint16_t m_tb_key_app_add(uint16_t app_key_id, const uint8_t *p_app_key, m_lid_t net_key_lid,
                          m_tb_key_added_cb res_cb)
{
   12478:	9002      	str	r0, [sp, #8]
	M_PRINTF(L_TB, "");
   1247a:	681b      	ldr	r3, [r3, #0]
    return net_lid;
}

uint16_t m_tb_key_app_add(uint16_t app_key_id, const uint8_t *p_app_key, m_lid_t net_key_lid,
                          m_tb_key_added_cb res_cb)
{
   1247c:	000f      	movs	r7, r1
   1247e:	0016      	movs	r6, r2
	M_PRINTF(L_TB, "");
   12480:	079b      	lsls	r3, r3, #30
   12482:	d515      	bpl.n	124b0 <m_tb_key_app_add+0x40>
   12484:	4d37      	ldr	r5, [pc, #220]	; (12564 <m_tb_key_app_add+0xf4>)
   12486:	4c38      	ldr	r4, [pc, #224]	; (12568 <m_tb_key_app_add+0xf8>)
   12488:	002b      	movs	r3, r5
   1248a:	0022      	movs	r2, r4
   1248c:	0020      	movs	r0, r4
   1248e:	3350      	adds	r3, #80	; 0x50
   12490:	0021      	movs	r1, r4
   12492:	3237      	adds	r2, #55	; 0x37
   12494:	9300      	str	r3, [sp, #0]
   12496:	3042      	adds	r0, #66	; 0x42
   12498:	4b34      	ldr	r3, [pc, #208]	; (1256c <m_tb_key_app_add+0xfc>)
   1249a:	f7f2 fa87 	bl	49ac <m_print>
   1249e:	0028      	movs	r0, r5
   124a0:	301a      	adds	r0, #26
   124a2:	f7f2 fa83 	bl	49ac <m_print>
   124a6:	4832      	ldr	r0, [pc, #200]	; (12570 <m_tb_key_app_add+0x100>)
   124a8:	1da1      	adds	r1, r4, #6
   124aa:	3003      	adds	r0, #3
   124ac:	f7f2 fa7e 	bl	49ac <m_print>
    // Returned status
    uint16_t status = M_ERR_NO_ERROR;

    do
    {
        m_tb_key_env_t *p_env = p_m_tb_key_env;
   124b0:	4b30      	ldr	r3, [pc, #192]	; (12574 <m_tb_key_app_add+0x104>)
   124b2:	681a      	ldr	r2, [r3, #0]
        m_lid_t ava_lid = M_TB_KEY_INVALID_LID;
        m_tb_key_app_t *p_key;
        m_lid_t i;

        // Ensure that no other key are under creation
        if (GETB(p_env->status, M_TB_KEY_STATE_KEY_GEN))
   124b4:	0013      	movs	r3, r2
   124b6:	33b9      	adds	r3, #185	; 0xb9
   124b8:	781b      	ldrb	r3, [r3, #0]
   124ba:	071b      	lsls	r3, r3, #28
   124bc:	d423      	bmi.n	12506 <m_tb_key_app_add+0x96>
            status = M_ERR_COMMAND_DISALLOWED;
            break;
        }

        // Get the network key identifier
        net_key_lid = GETF(net_key_lid, M_TB_KEY_LID);
   124be:	237f      	movs	r3, #127	; 0x7f
    uint16_t status = M_ERR_NO_ERROR;

    do
    {
        m_tb_key_env_t *p_env = p_m_tb_key_env;
        m_lid_t ava_lid = M_TB_KEY_INVALID_LID;
   124c0:	25ff      	movs	r5, #255	; 0xff
            status = M_ERR_COMMAND_DISALLOWED;
            break;
        }

        // Get the network key identifier
        net_key_lid = GETF(net_key_lid, M_TB_KEY_LID);
   124c2:	401e      	ands	r6, r3
   124c4:	320c      	adds	r2, #12

        for (i = M_TB_KEY_APP_START_LID; i <= M_TB_KEY_APP_END_LID; i++)
   124c6:	3b7c      	subs	r3, #124	; 0x7c
        {
            p_key = (m_tb_key_app_t *)p_env->p_keys[i];
   124c8:	6810      	ldr	r0, [r2, #0]

            if (p_key != NULL)
   124ca:	2800      	cmp	r0, #0
   124cc:	d012      	beq.n	124f4 <m_tb_key_app_add+0x84>
            {
                // Check if provided application key already exists
                if (p_key->app_key_id == app_key_id)
   124ce:	8a81      	ldrh	r1, [r0, #20]
   124d0:	9c02      	ldr	r4, [sp, #8]
   124d2:	42a1      	cmp	r1, r4
   124d4:	d111      	bne.n	124fa <m_tb_key_app_add+0x8a>
                {
                    // Check that application key is well bound with provided network key
                    if (GETF(p_key->net_key_lid, M_TB_KEY_LID) == net_key_lid)
   124d6:	237f      	movs	r3, #127	; 0x7f
   124d8:	7d82      	ldrb	r2, [r0, #22]
   124da:	4013      	ands	r3, r2
   124dc:	42b3      	cmp	r3, r6
   124de:	d114      	bne.n	1250a <m_tb_key_app_add+0x9a>
                    {
                        // Check if key is modified
                        if (!memcmp(&p_key->key[0], p_app_key, M_KEY_LEN))
   124e0:	3002      	adds	r0, #2
   124e2:	2210      	movs	r2, #16
   124e4:	0039      	movs	r1, r7
   124e6:	f003 fa4b 	bl	15980 <memcmp>
   124ea:	2800      	cmp	r0, #0
   124ec:	d010      	beq.n	12510 <m_tb_key_app_add+0xa0>
                            status = M_ERR_NO_EFFECT;
                        }
                        else
                        {
                            // Key already exists
                            status = M_ERR_KEY_ID_ALREADY_STORED;
   124ee:	20d0      	movs	r0, #208	; 0xd0
   124f0:	00c0      	lsls	r0, r0, #3
   124f2:	e032      	b.n	1255a <m_tb_key_app_add+0xea>
                    }

                    break;
                }
            }
            else if (ava_lid ==  M_TB_KEY_INVALID_LID)
   124f4:	2dff      	cmp	r5, #255	; 0xff
   124f6:	d100      	bne.n	124fa <m_tb_key_app_add+0x8a>
   124f8:	001d      	movs	r5, r3
        }

        // Get the network key identifier
        net_key_lid = GETF(net_key_lid, M_TB_KEY_LID);

        for (i = M_TB_KEY_APP_START_LID; i <= M_TB_KEY_APP_END_LID; i++)
   124fa:	3301      	adds	r3, #1
   124fc:	b2db      	uxtb	r3, r3
   124fe:	3204      	adds	r2, #4
   12500:	2b0d      	cmp	r3, #13
   12502:	d1e1      	bne.n	124c8 <m_tb_key_app_add+0x58>
   12504:	e006      	b.n	12514 <m_tb_key_app_add+0xa4>
        m_lid_t i;

        // Ensure that no other key are under creation
        if (GETB(p_env->status, M_TB_KEY_STATE_KEY_GEN))
        {
            status = M_ERR_COMMAND_DISALLOWED;
   12506:	481c      	ldr	r0, [pc, #112]	; (12578 <m_tb_key_app_add+0x108>)
   12508:	e027      	b.n	1255a <m_tb_key_app_add+0xea>
                        }
                    }
                    else
                    {
                        // Application key not bound with indicated network key
                        status = M_ERR_INVALID_NETKEY_ID;
   1250a:	2090      	movs	r0, #144	; 0x90
   1250c:	00c0      	lsls	r0, r0, #3
   1250e:	e024      	b.n	1255a <m_tb_key_app_add+0xea>
                    {
                        // Check if key is modified
                        if (!memcmp(&p_key->key[0], p_app_key, M_KEY_LEN))
                        {
                            // No need to add the key as it already exists
                            status = M_ERR_NO_EFFECT;
   12510:	481a      	ldr	r0, [pc, #104]	; (1257c <m_tb_key_app_add+0x10c>)

        // Use k4 algorithm to generate AID
        m_tb_sec_k4_start(M_TB_SEC_TOKEN_KEY_MANAGER, m_tb_key_k4_ready_cb, m_tb_key_finished_cb);
    } while (0);

    return (status);
   12512:	e022      	b.n	1255a <m_tb_key_app_add+0xea>
        {
            break;
        }

        // Check if a key identifier has been found
        if (ava_lid == M_TB_KEY_INVALID_LID)
   12514:	2dff      	cmp	r5, #255	; 0xff
   12516:	d01e      	beq.n	12556 <m_tb_key_app_add+0xe6>
            status = M_ERR_INSUFFICIENT_RESOURCES;
            break;
        }

        // Allocate new key
        p_key = (m_tb_key_app_t *)m_al_malloc(sizeof(m_tb_key_app_t));
   12518:	2018      	movs	r0, #24
   1251a:	f7f3 f85a 	bl	55d2 <m_al_malloc>

        // Fill key information
        p_key->key_type = M_TB_KEY_APPLICATION;
   1251e:	2302      	movs	r3, #2
            status = M_ERR_INSUFFICIENT_RESOURCES;
            break;
        }

        // Allocate new key
        p_key = (m_tb_key_app_t *)m_al_malloc(sizeof(m_tb_key_app_t));
   12520:	0004      	movs	r4, r0

        // Fill key information
        p_key->key_type = M_TB_KEY_APPLICATION;
   12522:	7003      	strb	r3, [r0, #0]
        memcpy(p_key->key, p_app_key, M_KEY_LEN);
   12524:	2210      	movs	r2, #16
   12526:	18c0      	adds	r0, r0, r3
   12528:	0039      	movs	r1, r7
   1252a:	f003 fa51 	bl	159d0 <memcpy>
        p_key->app_key_id = app_key_id;
   1252e:	466b      	mov	r3, sp
   12530:	891b      	ldrh	r3, [r3, #8]
        p_key->net_key_lid = net_key_lid;
   12532:	75a6      	strb	r6, [r4, #22]
        p_key = (m_tb_key_app_t *)m_al_malloc(sizeof(m_tb_key_app_t));

        // Fill key information
        p_key->key_type = M_TB_KEY_APPLICATION;
        memcpy(p_key->key, p_app_key, M_KEY_LEN);
        p_key->app_key_id = app_key_id;
   12534:	82a3      	strh	r3, [r4, #20]
        p_key->net_key_lid = net_key_lid;
        p_key->nb_models = 0;
   12536:	2600      	movs	r6, #0
        p_key->state = M_TB_KEY_STATE_APP_GEN_AID;
   12538:	2306      	movs	r3, #6

        m_tb_key_create_start(ava_lid, (m_tb_key_t*) p_key, res_cb);
   1253a:	9a03      	ldr	r2, [sp, #12]
        p_key->key_type = M_TB_KEY_APPLICATION;
        memcpy(p_key->key, p_app_key, M_KEY_LEN);
        p_key->app_key_id = app_key_id;
        p_key->net_key_lid = net_key_lid;
        p_key->nb_models = 0;
        p_key->state = M_TB_KEY_STATE_APP_GEN_AID;
   1253c:	7063      	strb	r3, [r4, #1]

        m_tb_key_create_start(ava_lid, (m_tb_key_t*) p_key, res_cb);
   1253e:	0021      	movs	r1, r4
   12540:	0028      	movs	r0, r5
        // Fill key information
        p_key->key_type = M_TB_KEY_APPLICATION;
        memcpy(p_key->key, p_app_key, M_KEY_LEN);
        p_key->app_key_id = app_key_id;
        p_key->net_key_lid = net_key_lid;
        p_key->nb_models = 0;
   12542:	74a6      	strb	r6, [r4, #18]
        p_key->state = M_TB_KEY_STATE_APP_GEN_AID;

        m_tb_key_create_start(ava_lid, (m_tb_key_t*) p_key, res_cb);
   12544:	f7ff f936 	bl	117b4 <m_tb_key_create_start>

        // Use k4 algorithm to generate AID
        m_tb_sec_k4_start(M_TB_SEC_TOKEN_KEY_MANAGER, m_tb_key_k4_ready_cb, m_tb_key_finished_cb);
   12548:	4a0d      	ldr	r2, [pc, #52]	; (12580 <m_tb_key_app_add+0x110>)
   1254a:	490e      	ldr	r1, [pc, #56]	; (12584 <m_tb_key_app_add+0x114>)
   1254c:	2004      	movs	r0, #4
   1254e:	f001 fd4b 	bl	13fe8 <m_tb_sec_k4_start>
   12552:	0030      	movs	r0, r6
   12554:	e001      	b.n	1255a <m_tb_key_app_add+0xea>
        }

        // Check if a key identifier has been found
        if (ava_lid == M_TB_KEY_INVALID_LID)
        {
            status = M_ERR_INSUFFICIENT_RESOURCES;
   12556:	20b0      	movs	r0, #176	; 0xb0
   12558:	00c0      	lsls	r0, r0, #3
        // Use k4 algorithm to generate AID
        m_tb_sec_k4_start(M_TB_SEC_TOKEN_KEY_MANAGER, m_tb_key_k4_ready_cb, m_tb_key_finished_cb);
    } while (0);

    return (status);
}
   1255a:	b005      	add	sp, #20
   1255c:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1255e:	46c0      	nop			; (mov r8, r8)
   12560:	10010514 	.word	0x10010514
   12564:	00022744 	.word	0x00022744
   12568:	00022644 	.word	0x00022644
   1256c:	000008ce 	.word	0x000008ce
   12570:	000226c4 	.word	0x000226c4
   12574:	100126c0 	.word	0x100126c0
   12578:	00000282 	.word	0x00000282
   1257c:	00000c82 	.word	0x00000c82
   12580:	00011ab1 	.word	0x00011ab1
   12584:	00011a91 	.word	0x00011a91

00012588 <m_tb_key_app_delete>:
    uint16_t status = M_ERR_NO_ERROR;

    do
    {
        m_lid_t i;
        m_tb_key_env_t *p_env = p_m_tb_key_env;
   12588:	4b4b      	ldr	r3, [pc, #300]	; (126b8 <m_tb_key_app_delete+0x130>)

    return (status);
}

uint16_t m_tb_key_app_delete(m_lid_t app_key_lid, m_lid_t net_key_lid)
{
   1258a:	b5f0      	push	{r4, r5, r6, r7, lr}
    uint16_t status = M_ERR_NO_ERROR;

    do
    {
        m_lid_t i;
        m_tb_key_env_t *p_env = p_m_tb_key_env;
   1258c:	681d      	ldr	r5, [r3, #0]

    return (status);
}

uint16_t m_tb_key_app_delete(m_lid_t app_key_lid, m_lid_t net_key_lid)
{
   1258e:	b085      	sub	sp, #20
        m_tb_key_env_t *p_env = p_m_tb_key_env;
        m_tb_key_net_t *p_net_key;
        m_tb_key_app_t *p_app_key;

        // Ensure that no key creation is on-going
        if (GETB(p_env->status, M_TB_KEY_STATE_KEY_GEN))
   12590:	002b      	movs	r3, r5
   12592:	33b9      	adds	r3, #185	; 0xb9
   12594:	781b      	ldrb	r3, [r3, #0]
   12596:	071b      	lsls	r3, r3, #28
   12598:	d500      	bpl.n	1259c <m_tb_key_app_delete+0x14>
   1259a:	e086      	b.n	126aa <m_tb_key_app_delete+0x122>
        {
            status = M_ERR_COMMAND_DISALLOWED;
            break;
        }

        app_key_lid = GETF(app_key_lid, M_TB_KEY_LID);
   1259c:	237f      	movs	r3, #127	; 0x7f
        net_key_lid = GETF(net_key_lid, M_TB_KEY_LID);
   1259e:	4019      	ands	r1, r3
        {
            status = M_ERR_COMMAND_DISALLOWED;
            break;
        }

        app_key_lid = GETF(app_key_lid, M_TB_KEY_LID);
   125a0:	4018      	ands	r0, r3
        net_key_lid = GETF(net_key_lid, M_TB_KEY_LID);

        // Sanity check
        ASSERT_INFO((net_key_lid >= M_TB_KEY_NET_START_LID)
   125a2:	000b      	movs	r3, r1
   125a4:	3b01      	subs	r3, #1
        {
            status = M_ERR_COMMAND_DISALLOWED;
            break;
        }

        app_key_lid = GETF(app_key_lid, M_TB_KEY_LID);
   125a6:	9000      	str	r0, [sp, #0]
        net_key_lid = GETF(net_key_lid, M_TB_KEY_LID);
   125a8:	9101      	str	r1, [sp, #4]

        // Sanity check
        ASSERT_INFO((net_key_lid >= M_TB_KEY_NET_START_LID)
   125aa:	b2db      	uxtb	r3, r3
   125ac:	2b01      	cmp	r3, #1
   125ae:	d8fd      	bhi.n	125ac <m_tb_key_app_delete+0x24>
                            && (net_key_lid <= M_TB_KEY_NET_END_LID), net_key_lid, 0);
        ASSERT_INFO((app_key_lid >= M_TB_KEY_APP_START_LID)
   125b0:	9b00      	ldr	r3, [sp, #0]
   125b2:	3b03      	subs	r3, #3
   125b4:	b2db      	uxtb	r3, r3
   125b6:	2b09      	cmp	r3, #9
   125b8:	d8fd      	bhi.n	125b6 <m_tb_key_app_delete+0x2e>
   125ba:	9b00      	ldr	r3, [sp, #0]
   125bc:	009e      	lsls	r6, r3, #2

        // Retrieve application key
        p_app_key = (m_tb_key_app_t *)p_env->p_keys[app_key_lid];

        // Check binding
        if (GETF(p_app_key->net_key_lid, M_TB_KEY_LID) != net_key_lid)
   125be:	237f      	movs	r3, #127	; 0x7f
   125c0:	19ae      	adds	r6, r5, r6
                            && (net_key_lid <= M_TB_KEY_NET_END_LID), net_key_lid, 0);
        ASSERT_INFO((app_key_lid >= M_TB_KEY_APP_START_LID)
                            && (app_key_lid <= M_TB_KEY_APP_END_LID), app_key_lid, 0);

        // Retrieve application key
        p_app_key = (m_tb_key_app_t *)p_env->p_keys[app_key_lid];
   125c2:	6834      	ldr	r4, [r6, #0]

        // Check binding
        if (GETF(p_app_key->net_key_lid, M_TB_KEY_LID) != net_key_lid)
   125c4:	7da7      	ldrb	r7, [r4, #22]
   125c6:	401f      	ands	r7, r3
   125c8:	9b01      	ldr	r3, [sp, #4]
   125ca:	429f      	cmp	r7, r3
   125cc:	d16f      	bne.n	126ae <m_tb_key_app_delete+0x126>
            status = M_ERR_INVALID_NETKEY_ID;
            break;
        }

        // Retrieve network key
        p_net_key = (m_tb_key_net_t*) p_env->p_keys[net_key_lid];
   125ce:	009b      	lsls	r3, r3, #2
   125d0:	595b      	ldr	r3, [r3, r5]
   125d2:	9303      	str	r3, [sp, #12]

        // Remove model bindings
        if (p_app_key->nb_models > 0)
   125d4:	7ca3      	ldrb	r3, [r4, #18]
   125d6:	2b00      	cmp	r3, #0
   125d8:	d031      	beq.n	1263e <m_tb_key_app_delete+0xb6>
        {
            // Search presence of an existing bind
            for (i = 0 ; i < p_env->nb_mids; i++)
   125da:	002b      	movs	r3, r5
   125dc:	33b7      	adds	r3, #183	; 0xb7
   125de:	781b      	ldrb	r3, [r3, #0]
   125e0:	002a      	movs	r2, r5
   125e2:	9302      	str	r3, [sp, #8]
   125e4:	2300      	movs	r3, #0
   125e6:	3284      	adds	r2, #132	; 0x84
   125e8:	9902      	ldr	r1, [sp, #8]
   125ea:	428b      	cmp	r3, r1
   125ec:	d008      	beq.n	12600 <m_tb_key_app_delete+0x78>
   125ee:	3202      	adds	r2, #2
            {
                if (p_env->map_ak_mid[i].app_key_lid == app_key_lid)
   125f0:	1e90      	subs	r0, r2, #2
   125f2:	7800      	ldrb	r0, [r0, #0]
   125f4:	9900      	ldr	r1, [sp, #0]
   125f6:	4288      	cmp	r0, r1
   125f8:	d002      	beq.n	12600 <m_tb_key_app_delete+0x78>

        // Remove model bindings
        if (p_app_key->nb_models > 0)
        {
            // Search presence of an existing bind
            for (i = 0 ; i < p_env->nb_mids; i++)
   125fa:	3301      	adds	r3, #1
   125fc:	b2db      	uxtb	r3, r3
   125fe:	e7f3      	b.n	125e8 <m_tb_key_app_delete+0x60>
                    break;
                }
            }

            // Browse array in order to remove all bindings for specific application key
            for( ; i < p_env->nb_mids - p_app_key->nb_models ; i++)
   12600:	7ca2      	ldrb	r2, [r4, #18]
   12602:	9902      	ldr	r1, [sp, #8]
   12604:	1a88      	subs	r0, r1, r2
   12606:	4283      	cmp	r3, r0
   12608:	da16      	bge.n	12638 <m_tb_key_app_delete+0xb0>
            {
                // Push following element in current element
                p_env->map_ak_mid[i].app_key_lid = p_env->map_ak_mid[i+p_app_key->nb_models].app_key_lid ;
   1260a:	189a      	adds	r2, r3, r2
   1260c:	3240      	adds	r2, #64	; 0x40
   1260e:	0052      	lsls	r2, r2, #1
   12610:	18aa      	adds	r2, r5, r2
   12612:	7912      	ldrb	r2, [r2, #4]
   12614:	0058      	lsls	r0, r3, #1
   12616:	4694      	mov	ip, r2
   12618:	1828      	adds	r0, r5, r0
   1261a:	0002      	movs	r2, r0
   1261c:	4661      	mov	r1, ip
   1261e:	3284      	adds	r2, #132	; 0x84
   12620:	7011      	strb	r1, [r2, #0]
                p_env->map_ak_mid[i].model_lid = p_env->map_ak_mid[i+p_app_key->nb_models].model_lid;
   12622:	7ca2      	ldrb	r2, [r4, #18]
   12624:	3085      	adds	r0, #133	; 0x85
   12626:	189a      	adds	r2, r3, r2
   12628:	3240      	adds	r2, #64	; 0x40
   1262a:	0052      	lsls	r2, r2, #1
   1262c:	18aa      	adds	r2, r5, r2
   1262e:	7952      	ldrb	r2, [r2, #5]
                    break;
                }
            }

            // Browse array in order to remove all bindings for specific application key
            for( ; i < p_env->nb_mids - p_app_key->nb_models ; i++)
   12630:	3301      	adds	r3, #1
            {
                // Push following element in current element
                p_env->map_ak_mid[i].app_key_lid = p_env->map_ak_mid[i+p_app_key->nb_models].app_key_lid ;
                p_env->map_ak_mid[i].model_lid = p_env->map_ak_mid[i+p_app_key->nb_models].model_lid;
   12632:	7002      	strb	r2, [r0, #0]
                    break;
                }
            }

            // Browse array in order to remove all bindings for specific application key
            for( ; i < p_env->nb_mids - p_app_key->nb_models ; i++)
   12634:	b2db      	uxtb	r3, r3
   12636:	e7e3      	b.n	12600 <m_tb_key_app_delete+0x78>
                p_env->map_ak_mid[i].app_key_lid = p_env->map_ak_mid[i+p_app_key->nb_models].app_key_lid ;
                p_env->map_ak_mid[i].model_lid = p_env->map_ak_mid[i+p_app_key->nb_models].model_lid;
            }

            // Mark array of bindings equals zero
            p_env->nb_mids -= p_app_key->nb_models;
   12638:	002b      	movs	r3, r5
   1263a:	33b7      	adds	r3, #183	; 0xb7
   1263c:	7018      	strb	r0, [r3, #0]
        }

        // Remove key info from the net_lid/AID/app_lid table
        m_tb_key_aid_tbl_del(net_key_lid, app_key_lid);
   1263e:	9900      	ldr	r1, [sp, #0]
   12640:	9801      	ldr	r0, [sp, #4]
   12642:	f7ff f975 	bl	11930 <m_tb_key_aid_tbl_del>

        // Inform the storage manager about the update
        m_tb_store_update_ind(M_TB_STORE_UPD_TYPE_APP_KEY_DELETED, app_key_lid);
   12646:	9900      	ldr	r1, [sp, #0]
   12648:	2003      	movs	r0, #3
   1264a:	f002 fae5 	bl	14c18 <m_tb_store_update_ind>

        p_net_key->nb_app_keys--;
   1264e:	9a03      	ldr	r2, [sp, #12]
        p_env->p_keys[app_key_lid] = NULL;

        m_al_free(p_app_key);
   12650:	0020      	movs	r0, r4
        m_tb_key_aid_tbl_del(net_key_lid, app_key_lid);

        // Inform the storage manager about the update
        m_tb_store_update_ind(M_TB_STORE_UPD_TYPE_APP_KEY_DELETED, app_key_lid);

        p_net_key->nb_app_keys--;
   12652:	324e      	adds	r2, #78	; 0x4e
   12654:	7813      	ldrb	r3, [r2, #0]
   12656:	3b01      	subs	r3, #1
   12658:	7013      	strb	r3, [r2, #0]
        p_env->p_keys[app_key_lid] = NULL;
   1265a:	2300      	movs	r3, #0
   1265c:	6033      	str	r3, [r6, #0]

        m_al_free(p_app_key);
   1265e:	f7f2 ffbd 	bl	55dc <m_al_free>

        if (p_env->p_up)
   12662:	6b6b      	ldr	r3, [r5, #52]	; 0x34
}

uint16_t m_tb_key_app_delete(m_lid_t app_key_lid, m_lid_t net_key_lid)
{
    // Returned status
    uint16_t status = M_ERR_NO_ERROR;
   12664:	1e18      	subs	r0, r3, #0
        p_net_key->nb_app_keys--;
        p_env->p_keys[app_key_lid] = NULL;

        m_al_free(p_app_key);

        if (p_env->p_up)
   12666:	d024      	beq.n	126b2 <m_tb_key_app_delete+0x12a>
        {
            p_net_key = (m_tb_key_net_t *)p_env->p_up->p_keys[net_key_lid];
   12668:	00bf      	lsls	r7, r7, #2
   1266a:	58fc      	ldr	r4, [r7, r3]
}

uint16_t m_tb_key_app_delete(m_lid_t app_key_lid, m_lid_t net_key_lid)
{
    // Returned status
    uint16_t status = M_ERR_NO_ERROR;
   1266c:	1e20      	subs	r0, r4, #0
        if (p_env->p_up)
        {
            p_net_key = (m_tb_key_net_t *)p_env->p_up->p_keys[net_key_lid];

            // Network  key is under update procedure
            if (p_net_key != NULL)
   1266e:	d020      	beq.n	126b2 <m_tb_key_app_delete+0x12a>
            {
                p_app_key = (m_tb_key_app_t *)p_env->p_up->p_keys[app_key_lid];
   12670:	9a00      	ldr	r2, [sp, #0]
   12672:	0097      	lsls	r7, r2, #2
   12674:	58fe      	ldr	r6, [r7, r3]
}

uint16_t m_tb_key_app_delete(m_lid_t app_key_lid, m_lid_t net_key_lid)
{
    // Returned status
    uint16_t status = M_ERR_NO_ERROR;
   12676:	1e30      	subs	r0, r6, #0
            if (p_net_key != NULL)
            {
                p_app_key = (m_tb_key_app_t *)p_env->p_up->p_keys[app_key_lid];

                // Application key is also under update procedure
                if (p_app_key != NULL)
   12678:	d01b      	beq.n	126b2 <m_tb_key_app_delete+0x12a>
                {
                    // remove key info from the net_lid/AID/app_lid table
                    m_tb_key_aid_tbl_del(net_key_lid, app_key_lid | M_TB_KEY_NEW_BIT);
   1267a:	0013      	movs	r3, r2
   1267c:	2180      	movs	r1, #128	; 0x80
   1267e:	430b      	orrs	r3, r1
   12680:	0019      	movs	r1, r3
   12682:	9801      	ldr	r0, [sp, #4]

                    // Clean-up application key
                    p_net_key->nb_app_keys--;
   12684:	344e      	adds	r4, #78	; 0x4e

                // Application key is also under update procedure
                if (p_app_key != NULL)
                {
                    // remove key info from the net_lid/AID/app_lid table
                    m_tb_key_aid_tbl_del(net_key_lid, app_key_lid | M_TB_KEY_NEW_BIT);
   12686:	f7ff f953 	bl	11930 <m_tb_key_aid_tbl_del>

                    // Clean-up application key
                    p_net_key->nb_app_keys--;
   1268a:	7823      	ldrb	r3, [r4, #0]
                    p_env->p_up->nb_key--;
                    p_env->p_up->p_keys[GETF(app_key_lid, M_TB_KEY_LID)] = NULL;

                    m_al_free(p_app_key);
   1268c:	0030      	movs	r0, r6
                {
                    // remove key info from the net_lid/AID/app_lid table
                    m_tb_key_aid_tbl_del(net_key_lid, app_key_lid | M_TB_KEY_NEW_BIT);

                    // Clean-up application key
                    p_net_key->nb_app_keys--;
   1268e:	3b01      	subs	r3, #1
   12690:	7023      	strb	r3, [r4, #0]
                    p_env->p_up->nb_key--;
   12692:	6b6b      	ldr	r3, [r5, #52]	; 0x34
   12694:	3334      	adds	r3, #52	; 0x34
   12696:	781a      	ldrb	r2, [r3, #0]
   12698:	3a01      	subs	r2, #1
   1269a:	701a      	strb	r2, [r3, #0]
                    p_env->p_up->p_keys[GETF(app_key_lid, M_TB_KEY_LID)] = NULL;
   1269c:	2200      	movs	r2, #0
   1269e:	6b6b      	ldr	r3, [r5, #52]	; 0x34
   126a0:	50fa      	str	r2, [r7, r3]

                    m_al_free(p_app_key);
   126a2:	f7f2 ff9b 	bl	55dc <m_al_free>
}

uint16_t m_tb_key_app_delete(m_lid_t app_key_lid, m_lid_t net_key_lid)
{
    // Returned status
    uint16_t status = M_ERR_NO_ERROR;
   126a6:	2000      	movs	r0, #0
   126a8:	e003      	b.n	126b2 <m_tb_key_app_delete+0x12a>
        m_tb_key_app_t *p_app_key;

        // Ensure that no key creation is on-going
        if (GETB(p_env->status, M_TB_KEY_STATE_KEY_GEN))
        {
            status = M_ERR_COMMAND_DISALLOWED;
   126aa:	4804      	ldr	r0, [pc, #16]	; (126bc <m_tb_key_app_delete+0x134>)
   126ac:	e001      	b.n	126b2 <m_tb_key_app_delete+0x12a>
        p_app_key = (m_tb_key_app_t *)p_env->p_keys[app_key_lid];

        // Check binding
        if (GETF(p_app_key->net_key_lid, M_TB_KEY_LID) != net_key_lid)
        {
            status = M_ERR_INVALID_NETKEY_ID;
   126ae:	2090      	movs	r0, #144	; 0x90
   126b0:	00c0      	lsls	r0, r0, #3
            }
        }
    } while (0);

    return (status);
}
   126b2:	b005      	add	sp, #20
   126b4:	bdf0      	pop	{r4, r5, r6, r7, pc}
   126b6:	46c0      	nop			; (mov r8, r8)
   126b8:	100126c0 	.word	0x100126c0
   126bc:	00000282 	.word	0x00000282

000126c0 <m_tb_key_app_update>:

uint16_t m_tb_key_app_update(uint16_t app_key_id, const uint8_t *p_app_key, m_lid_t net_key_lid,
                             m_tb_key_added_cb res_cb)
{
   126c0:	b5f0      	push	{r4, r5, r6, r7, lr}
   126c2:	b085      	sub	sp, #20
   126c4:	9301      	str	r3, [sp, #4]
    // Returned status
    uint16_t status = M_ERR_NO_ERROR;

    do
    {
        m_tb_key_env_t *p_env = p_m_tb_key_env;
   126c6:	4b2e      	ldr	r3, [pc, #184]	; (12780 <m_tb_key_app_update+0xc0>)
    return (status);
}

uint16_t m_tb_key_app_update(uint16_t app_key_id, const uint8_t *p_app_key, m_lid_t net_key_lid,
                             m_tb_key_added_cb res_cb)
{
   126c8:	9200      	str	r2, [sp, #0]
    // Returned status
    uint16_t status = M_ERR_NO_ERROR;

    do
    {
        m_tb_key_env_t *p_env = p_m_tb_key_env;
   126ca:	681d      	ldr	r5, [r3, #0]
    return (status);
}

uint16_t m_tb_key_app_update(uint16_t app_key_id, const uint8_t *p_app_key, m_lid_t net_key_lid,
                             m_tb_key_added_cb res_cb)
{
   126cc:	000f      	movs	r7, r1
        m_tb_key_app_t *p_old_app_key;
        m_tb_key_app_t *p_new_app_key;
        m_lid_t app_key_lid;

        // Ensure that no key creation is on-going
        if (GETB(p_env->status, M_TB_KEY_STATE_KEY_GEN))
   126ce:	002b      	movs	r3, r5
   126d0:	33b9      	adds	r3, #185	; 0xb9
   126d2:	781b      	ldrb	r3, [r3, #0]
   126d4:	071b      	lsls	r3, r3, #28
   126d6:	d446      	bmi.n	12766 <m_tb_key_app_update+0xa6>
            status = M_ERR_COMMAND_DISALLOWED;
            break;
        }

        // Look for indicated application key
        status = m_tb_key_app_find(app_key_id, &app_key_lid);
   126d8:	ab02      	add	r3, sp, #8
   126da:	1dde      	adds	r6, r3, #7
   126dc:	0031      	movs	r1, r6
   126de:	f000 f88d 	bl	127fc <m_tb_key_app_find>
   126e2:	1e04      	subs	r4, r0, #0

        if (status != M_ERR_NO_ERROR)
   126e4:	d148      	bne.n	12778 <m_tb_key_app_update+0xb8>
        {
            // Key has not been found
            break;
        }

        app_key_lid = GETF(app_key_lid, M_TB_KEY_LID);
   126e6:	237f      	movs	r3, #127	; 0x7f
        net_key_lid = GETF(net_key_lid, M_TB_KEY_LID);
   126e8:	9900      	ldr	r1, [sp, #0]
        {
            // Key has not been found
            break;
        }

        app_key_lid = GETF(app_key_lid, M_TB_KEY_LID);
   126ea:	7832      	ldrb	r2, [r6, #0]
        net_key_lid = GETF(net_key_lid, M_TB_KEY_LID);
   126ec:	4019      	ands	r1, r3
        {
            // Key has not been found
            break;
        }

        app_key_lid = GETF(app_key_lid, M_TB_KEY_LID);
   126ee:	401a      	ands	r2, r3
        net_key_lid = GETF(net_key_lid, M_TB_KEY_LID);
   126f0:	000b      	movs	r3, r1

        // Sanity checks
        ASSERT_INFO((net_key_lid >= M_TB_KEY_NET_START_LID)
   126f2:	3901      	subs	r1, #1
        {
            // Key has not been found
            break;
        }

        app_key_lid = GETF(app_key_lid, M_TB_KEY_LID);
   126f4:	7032      	strb	r2, [r6, #0]
        net_key_lid = GETF(net_key_lid, M_TB_KEY_LID);

        // Sanity checks
        ASSERT_INFO((net_key_lid >= M_TB_KEY_NET_START_LID)
   126f6:	b2c9      	uxtb	r1, r1
   126f8:	2901      	cmp	r1, #1
   126fa:	d8fd      	bhi.n	126f8 <m_tb_key_app_update+0x38>
                            && (net_key_lid <= M_TB_KEY_NET_END_LID), net_key_lid, 0);

        // Retrieve old application key
        p_old_app_key = (m_tb_key_app_t *)p_env->p_keys[app_key_lid];
   126fc:	0092      	lsls	r2, r2, #2
   126fe:	5950      	ldr	r0, [r2, r5]

        // Sanity check
        ASSERT_INFO(p_old_app_key, app_key_lid, 0);
   12700:	2800      	cmp	r0, #0
   12702:	d100      	bne.n	12706 <m_tb_key_app_update+0x46>
   12704:	e7fe      	b.n	12704 <m_tb_key_app_update+0x44>

        // Check binding
        if (GETF(p_old_app_key->net_key_lid, M_TB_KEY_LID) != net_key_lid)
   12706:	227f      	movs	r2, #127	; 0x7f
   12708:	7d81      	ldrb	r1, [r0, #22]
   1270a:	400a      	ands	r2, r1
   1270c:	429a      	cmp	r2, r3
   1270e:	d12c      	bne.n	1276a <m_tb_key_app_update+0xaa>
            status = M_ERR_INVALID_BINDING;
            break;
        }

        // Cannot update if no key under update
        if (p_env->p_up == NULL)
   12710:	6b6a      	ldr	r2, [r5, #52]	; 0x34
   12712:	2a00      	cmp	r2, #0
   12714:	d02c      	beq.n	12770 <m_tb_key_app_update+0xb0>
            status = M_ERR_CANNOT_UPDATE;
            break;
        }

        // Retrieve network key
        p_net_key  = (m_tb_key_net_t *)p_env->p_keys[net_key_lid];
   12716:	009b      	lsls	r3, r3, #2
   12718:	595b      	ldr	r3, [r3, r5]

        // Check that network key exist and is well under update state
        if ((p_net_key == NULL)
   1271a:	2b00      	cmp	r3, #0
   1271c:	d028      	beq.n	12770 <m_tb_key_app_update+0xb0>
                || (p_net_key->state != M_TB_KEY_STATE_P1))
   1271e:	785b      	ldrb	r3, [r3, #1]
   12720:	2b01      	cmp	r3, #1
   12722:	d125      	bne.n	12770 <m_tb_key_app_update+0xb0>
            status = M_ERR_CANNOT_UPDATE;
            break;
        }

        // Check that provided key is different than stored one
        if (!memcmp(&p_old_app_key->key[0], p_app_key, M_KEY_LEN))
   12724:	3002      	adds	r0, #2
   12726:	2210      	movs	r2, #16
   12728:	0039      	movs	r1, r7
   1272a:	f003 f929 	bl	15980 <memcmp>
   1272e:	2800      	cmp	r0, #0
   12730:	d021      	beq.n	12776 <m_tb_key_app_update+0xb6>
            status = M_ERR_NO_EFFECT;
            break;
        }

        // Allocate new key
        p_new_app_key = (m_tb_key_app_t *)m_al_malloc(sizeof(m_tb_key_app_t));
   12732:	2018      	movs	r0, #24
   12734:	f7f2 ff4d 	bl	55d2 <m_al_malloc>

        // Fill key information
        p_new_app_key->key_type = M_TB_KEY_APPLICATION;
   12738:	2302      	movs	r3, #2
            status = M_ERR_NO_EFFECT;
            break;
        }

        // Allocate new key
        p_new_app_key = (m_tb_key_app_t *)m_al_malloc(sizeof(m_tb_key_app_t));
   1273a:	0005      	movs	r5, r0

        // Fill key information
        p_new_app_key->key_type = M_TB_KEY_APPLICATION;
   1273c:	7003      	strb	r3, [r0, #0]
        memcpy(p_new_app_key->key, p_app_key, M_KEY_LEN);
   1273e:	0039      	movs	r1, r7
   12740:	18c0      	adds	r0, r0, r3
   12742:	2210      	movs	r2, #16
   12744:	f003 f944 	bl	159d0 <memcpy>
        p_new_app_key->state = M_TB_KEY_STATE_APP_GEN_AID;
   12748:	2306      	movs	r3, #6
        m_tb_key_create_start(app_key_lid | M_TB_KEY_NEW_BIT, (m_tb_key_t *)p_new_app_key, res_cb);
   1274a:	7830      	ldrb	r0, [r6, #0]
        p_new_app_key = (m_tb_key_app_t *)m_al_malloc(sizeof(m_tb_key_app_t));

        // Fill key information
        p_new_app_key->key_type = M_TB_KEY_APPLICATION;
        memcpy(p_new_app_key->key, p_app_key, M_KEY_LEN);
        p_new_app_key->state = M_TB_KEY_STATE_APP_GEN_AID;
   1274c:	706b      	strb	r3, [r5, #1]
        m_tb_key_create_start(app_key_lid | M_TB_KEY_NEW_BIT, (m_tb_key_t *)p_new_app_key, res_cb);
   1274e:	337a      	adds	r3, #122	; 0x7a
   12750:	4318      	orrs	r0, r3
   12752:	9a01      	ldr	r2, [sp, #4]
   12754:	0029      	movs	r1, r5
   12756:	f7ff f82d 	bl	117b4 <m_tb_key_create_start>

        // Use k4 algorithm to generate AID
        m_tb_sec_k4_start(M_TB_SEC_TOKEN_KEY_MANAGER, m_tb_key_k4_ready_cb, m_tb_key_finished_cb);
   1275a:	4a0a      	ldr	r2, [pc, #40]	; (12784 <m_tb_key_app_update+0xc4>)
   1275c:	490a      	ldr	r1, [pc, #40]	; (12788 <m_tb_key_app_update+0xc8>)
   1275e:	2004      	movs	r0, #4
   12760:	f001 fc42 	bl	13fe8 <m_tb_sec_k4_start>
   12764:	e008      	b.n	12778 <m_tb_key_app_update+0xb8>
        m_lid_t app_key_lid;

        // Ensure that no key creation is on-going
        if (GETB(p_env->status, M_TB_KEY_STATE_KEY_GEN))
        {
            status = M_ERR_COMMAND_DISALLOWED;
   12766:	4c09      	ldr	r4, [pc, #36]	; (1278c <m_tb_key_app_update+0xcc>)
   12768:	e006      	b.n	12778 <m_tb_key_app_update+0xb8>
        ASSERT_INFO(p_old_app_key, app_key_lid, 0);

        // Check binding
        if (GETF(p_old_app_key->net_key_lid, M_TB_KEY_LID) != net_key_lid)
        {
            status = M_ERR_INVALID_BINDING;
   1276a:	248c      	movs	r4, #140	; 0x8c
   1276c:	0164      	lsls	r4, r4, #5
   1276e:	e003      	b.n	12778 <m_tb_key_app_update+0xb8>
        }

        // Cannot update if no key under update
        if (p_env->p_up == NULL)
        {
            status = M_ERR_CANNOT_UPDATE;
   12770:	24b8      	movs	r4, #184	; 0xb8
   12772:	0124      	lsls	r4, r4, #4
   12774:	e000      	b.n	12778 <m_tb_key_app_update+0xb8>
        }

        // Check that provided key is different than stored one
        if (!memcmp(&p_old_app_key->key[0], p_app_key, M_KEY_LEN))
        {
            status = M_ERR_NO_EFFECT;
   12776:	4c06      	ldr	r4, [pc, #24]	; (12790 <m_tb_key_app_update+0xd0>)
        // Use k4 algorithm to generate AID
        m_tb_sec_k4_start(M_TB_SEC_TOKEN_KEY_MANAGER, m_tb_key_k4_ready_cb, m_tb_key_finished_cb);
    } while(0);

    return (status);
}
   12778:	0020      	movs	r0, r4
   1277a:	b005      	add	sp, #20
   1277c:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1277e:	46c0      	nop			; (mov r8, r8)
   12780:	100126c0 	.word	0x100126c0
   12784:	00011ab1 	.word	0x00011ab1
   12788:	00011a91 	.word	0x00011a91
   1278c:	00000282 	.word	0x00000282
   12790:	00000c82 	.word	0x00000c82

00012794 <m_tb_key_app_get>:
    // Returned status
    uint16_t status = M_ERR_NO_ERROR;

    do
    {
        m_tb_key_env_t *p_env = p_m_tb_key_env;
   12794:	4b17      	ldr	r3, [pc, #92]	; (127f4 <m_tb_key_app_get+0x60>)

    return (status);
}

uint16_t m_tb_key_app_get(m_lid_t app_key_lid, const m_tb_key_app_t **pp_app_key, bool tx)
{
   12796:	b570      	push	{r4, r5, r6, lr}
    // Returned status
    uint16_t status = M_ERR_NO_ERROR;

    do
    {
        m_tb_key_env_t *p_env = p_m_tb_key_env;
   12798:	681d      	ldr	r5, [r3, #0]
        m_tb_key_app_t *p_key_app;
        m_tb_key_net_t *p_key_net;
        m_lid_t base_lid = GETF(app_key_lid, M_TB_KEY_LID);
   1279a:	237f      	movs	r3, #127	; 0x7f
   1279c:	4003      	ands	r3, r0

        // Sanity check
        ASSERT_INFO((base_lid >= M_TB_KEY_APP_START_LID) && (base_lid <= M_TB_KEY_APP_END_LID), base_lid, 0);
   1279e:	1edc      	subs	r4, r3, #3
   127a0:	b2e4      	uxtb	r4, r4
   127a2:	2c09      	cmp	r4, #9
   127a4:	d8fd      	bhi.n	127a2 <m_tb_key_app_get+0xe>

        // Retrieve application key
        p_key_app = (m_tb_key_app_t *)p_env->p_keys[base_lid];
   127a6:	009b      	lsls	r3, r3, #2
   127a8:	595c      	ldr	r4, [r3, r5]

        if (p_key_app == NULL)
   127aa:	2c00      	cmp	r4, #0
   127ac:	d01d      	beq.n	127ea <m_tb_key_app_get+0x56>
            status = M_ERR_INVALID_APPKEY_ID;
            break;
        }

        // Get bound network key
        p_key_net = (m_tb_key_net_t *)p_env->p_keys[p_key_app->net_key_lid];
   127ae:	7da6      	ldrb	r6, [r4, #22]
   127b0:	00b6      	lsls	r6, r6, #2
   127b2:	5976      	ldr	r6, [r6, r5]

        // Sanity check
        ASSERT_INFO(p_key_net, app_key_lid, p_key_app->net_key_lid);
   127b4:	2e00      	cmp	r6, #0
   127b6:	d100      	bne.n	127ba <m_tb_key_app_get+0x26>
   127b8:	e7fe      	b.n	127b8 <m_tb_key_app_get+0x24>

        // Returned application key depends on network key state
        if (p_key_net->state != M_TB_KEY_STATE_NORMAL)
   127ba:	7876      	ldrb	r6, [r6, #1]
   127bc:	2e00      	cmp	r6, #0
   127be:	d00c      	beq.n	127da <m_tb_key_app_get+0x46>
        {
            if (tx)
   127c0:	2a00      	cmp	r2, #0
   127c2:	d002      	beq.n	127ca <m_tb_key_app_get+0x36>
            {
                if (p_key_net->state == M_TB_KEY_STATE_P2)
   127c4:	2e02      	cmp	r6, #2
   127c6:	d10d      	bne.n	127e4 <m_tb_key_app_get+0x50>
   127c8:	e002      	b.n	127d0 <m_tb_key_app_get+0x3c>
                    p_key_app = (m_tb_key_app_t *)p_env->p_up->p_keys[base_lid];
                }
            }
            else
            {
                if (GETB(app_key_lid, M_TB_KEY_NEW))
   127ca:	b240      	sxtb	r0, r0
   127cc:	2800      	cmp	r0, #0
   127ce:	da09      	bge.n	127e4 <m_tb_key_app_get+0x50>
                {
                    p_key_app = (m_tb_key_app_t *)p_env->p_up->p_keys[base_lid];
   127d0:	6b6a      	ldr	r2, [r5, #52]	; 0x34
   127d2:	58d4      	ldr	r4, [r2, r3]
                }
            }

            // Sanity check
            ASSERT_INFO(p_key_app, tx, app_key_lid);
   127d4:	2c00      	cmp	r4, #0
   127d6:	d105      	bne.n	127e4 <m_tb_key_app_get+0x50>
   127d8:	e7fe      	b.n	127d8 <m_tb_key_app_get+0x44>
        }
        else
        {
            if (!tx && GETB(app_key_lid, M_TB_KEY_NEW))
   127da:	2a00      	cmp	r2, #0
   127dc:	d102      	bne.n	127e4 <m_tb_key_app_get+0x50>
   127de:	b240      	sxtb	r0, r0
   127e0:	2800      	cmp	r0, #0
   127e2:	db05      	blt.n	127f0 <m_tb_key_app_get+0x5c>
                status  = M_ERR_NOT_FOUND;
                break;
            }
        }

        *pp_app_key = (const m_tb_key_app_t *)p_key_app;
   127e4:	600c      	str	r4, [r1, #0]
}

uint16_t m_tb_key_app_get(m_lid_t app_key_lid, const m_tb_key_app_t **pp_app_key, bool tx)
{
    // Returned status
    uint16_t status = M_ERR_NO_ERROR;
   127e6:	2000      	movs	r0, #0
   127e8:	e003      	b.n	127f2 <m_tb_key_app_get+0x5e>
        // Retrieve application key
        p_key_app = (m_tb_key_app_t *)p_env->p_keys[base_lid];

        if (p_key_app == NULL)
        {
            status = M_ERR_INVALID_APPKEY_ID;
   127ea:	20e0      	movs	r0, #224	; 0xe0
   127ec:	0080      	lsls	r0, r0, #2
   127ee:	e000      	b.n	127f2 <m_tb_key_app_get+0x5e>
        }
        else
        {
            if (!tx && GETB(app_key_lid, M_TB_KEY_NEW))
            {
                status  = M_ERR_NOT_FOUND;
   127f0:	4801      	ldr	r0, [pc, #4]	; (127f8 <m_tb_key_app_get+0x64>)

        *pp_app_key = (const m_tb_key_app_t *)p_key_app;
    } while(0);

    return (status);
}
   127f2:	bd70      	pop	{r4, r5, r6, pc}
   127f4:	100126c0 	.word	0x100126c0
   127f8:	00000682 	.word	0x00000682

000127fc <m_tb_key_app_find>:
    m_lid_t cnt;

    for (cnt = M_TB_KEY_APP_START_LID; cnt <= M_TB_KEY_APP_END_LID; cnt++)
    {
        // Get application key information
        m_tb_key_app_t *p_key_app = (m_tb_key_app_t*)p_m_tb_key_env->p_keys[cnt];
   127fc:	4b0a      	ldr	r3, [pc, #40]	; (12828 <m_tb_key_app_find+0x2c>)

    return (status);
}

uint16_t m_tb_key_app_find(uint16_t app_key_id, m_lid_t *p_app_key_lid)
{
   127fe:	b510      	push	{r4, lr}
   12800:	681a      	ldr	r2, [r3, #0]
    // Returned status
    uint16_t status = M_ERR_INVALID_APPKEY_ID;
    // Counter
    m_lid_t cnt;

    for (cnt = M_TB_KEY_APP_START_LID; cnt <= M_TB_KEY_APP_END_LID; cnt++)
   12802:	2303      	movs	r3, #3
   12804:	320c      	adds	r2, #12
    {
        // Get application key information
        m_tb_key_app_t *p_key_app = (m_tb_key_app_t*)p_m_tb_key_env->p_keys[cnt];
   12806:	6814      	ldr	r4, [r2, #0]

        if (p_key_app != NULL)
   12808:	2c00      	cmp	r4, #0
   1280a:	d005      	beq.n	12818 <m_tb_key_app_find+0x1c>
        {
            // Check AppKey index
            if (p_key_app->app_key_id == app_key_id)
   1280c:	8aa4      	ldrh	r4, [r4, #20]
   1280e:	4284      	cmp	r4, r0
   12810:	d102      	bne.n	12818 <m_tb_key_app_find+0x1c>
            {
                *p_app_key_lid = cnt;
   12812:	700b      	strb	r3, [r1, #0]
                status = M_ERR_NO_ERROR;
   12814:	2000      	movs	r0, #0
                break;
   12816:	e006      	b.n	12826 <m_tb_key_app_find+0x2a>
    // Returned status
    uint16_t status = M_ERR_INVALID_APPKEY_ID;
    // Counter
    m_lid_t cnt;

    for (cnt = M_TB_KEY_APP_START_LID; cnt <= M_TB_KEY_APP_END_LID; cnt++)
   12818:	3301      	adds	r3, #1
   1281a:	b2db      	uxtb	r3, r3
   1281c:	3204      	adds	r2, #4
   1281e:	2b0d      	cmp	r3, #13
   12820:	d1f1      	bne.n	12806 <m_tb_key_app_find+0xa>
}

uint16_t m_tb_key_app_find(uint16_t app_key_id, m_lid_t *p_app_key_lid)
{
    // Returned status
    uint16_t status = M_ERR_INVALID_APPKEY_ID;
   12822:	20e0      	movs	r0, #224	; 0xe0
   12824:	0080      	lsls	r0, r0, #2
            }
        }
    }

    return (status);
}
   12826:	bd10      	pop	{r4, pc}
   12828:	100126c0 	.word	0x100126c0

0001282c <m_tb_key_app_lid_from_net_aid>:

m_lid_t m_tb_key_app_lid_from_net_aid(m_lid_t net_lid, uint8_t aid, uint8_t offset)
{
    uint8_t i, j = 0;
    m_tb_key_env_t *p_env = p_m_tb_key_env;
   1282c:	4b21      	ldr	r3, [pc, #132]	; (128b4 <m_tb_key_app_lid_from_net_aid+0x88>)

    return (status);
}

m_lid_t m_tb_key_app_lid_from_net_aid(m_lid_t net_lid, uint8_t aid, uint8_t offset)
{
   1282e:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    uint8_t i, j = 0;
    m_tb_key_env_t *p_env = p_m_tb_key_env;
   12830:	681c      	ldr	r4, [r3, #0]
    m_lid_t app_lid = M_INVALID_LID;

    // Look for request network key local index in mapping table allowing to retrieve an
    // application key local index
    for (i = 0; i < p_env->nb_aids; i++)
   12832:	2500      	movs	r5, #0
   12834:	0023      	movs	r3, r4

    return (status);
}

m_lid_t m_tb_key_app_lid_from_net_aid(m_lid_t net_lid, uint8_t aid, uint8_t offset)
{
   12836:	9200      	str	r2, [sp, #0]
    m_tb_key_env_t *p_env = p_m_tb_key_env;
    m_lid_t app_lid = M_INVALID_LID;

    // Look for request network key local index in mapping table allowing to retrieve an
    // application key local index
    for (i = 0; i < p_env->nb_aids; i++)
   12838:	33b6      	adds	r3, #182	; 0xb6
   1283a:	781f      	ldrb	r7, [r3, #0]
   1283c:	3b6e      	subs	r3, #110	; 0x6e
   1283e:	b2ee      	uxtb	r6, r5
   12840:	42be      	cmp	r6, r7
   12842:	d224      	bcs.n	1288e <m_tb_key_app_lid_from_net_aid+0x62>
    {
        m_lid_t rd_net_lid = p_env->map_nk_ak[i].net_key_lid;
   12844:	781a      	ldrb	r2, [r3, #0]

        if (rd_net_lid == net_lid)
   12846:	4282      	cmp	r2, r0
   12848:	d118      	bne.n	1287c <m_tb_key_app_lid_from_net_aid+0x50>
        {
            // Get network key information
            m_tb_key_net_t *p_key_net = (m_tb_key_net_t *)p_env->p_keys[rd_net_lid];
   1284a:	0080      	lsls	r0, r0, #2

            // Now look for the required AID
            for (j = 0; j < p_key_net->nb_app_keys; j++)
   1284c:	5903      	ldr	r3, [r0, r4]
   1284e:	334e      	adds	r3, #78	; 0x4e
   12850:	781b      	ldrb	r3, [r3, #0]
   12852:	469c      	mov	ip, r3
   12854:	2303      	movs	r3, #3
   12856:	435d      	muls	r5, r3
   12858:	002a      	movs	r2, r5
   1285a:	2500      	movs	r5, #0
   1285c:	9301      	str	r3, [sp, #4]
   1285e:	b2eb      	uxtb	r3, r5
   12860:	4563      	cmp	r3, ip
   12862:	d215      	bcs.n	12890 <m_tb_key_app_lid_from_net_aid+0x64>
   12864:	9801      	ldr	r0, [sp, #4]
   12866:	4368      	muls	r0, r5
   12868:	1880      	adds	r0, r0, r2
            {
                uint8_t rd_aid = p_env->map_nk_ak[i + j].aid;
   1286a:	3049      	adds	r0, #73	; 0x49
   1286c:	5c20      	ldrb	r0, [r4, r0]

                if (rd_aid == aid)
   1286e:	4288      	cmp	r0, r1
   12870:	d00e      	beq.n	12890 <m_tb_key_app_lid_from_net_aid+0x64>
   12872:	3501      	adds	r5, #1
                {
                    break;
                }
                else if (rd_aid > aid)
   12874:	4288      	cmp	r0, r1
   12876:	d9f2      	bls.n	1285e <m_tb_key_app_lid_from_net_aid+0x32>
   12878:	4663      	mov	r3, ip
   1287a:	e009      	b.n	12890 <m_tb_key_app_lid_from_net_aid+0x64>
   1287c:	3501      	adds	r5, #1
   1287e:	3303      	adds	r3, #3
                }
            }

            break;
        }
        else if (rd_net_lid > net_lid)
   12880:	4282      	cmp	r2, r0
   12882:	d9dc      	bls.n	1283e <m_tb_key_app_lid_from_net_aid+0x12>
        {
            // Network key local index not found - stop research
            i = p_env->nb_nids;
   12884:	0023      	movs	r3, r4
   12886:	33b5      	adds	r3, #181	; 0xb5
   12888:	781e      	ldrb	r6, [r3, #0]
    return (status);
}

m_lid_t m_tb_key_app_lid_from_net_aid(m_lid_t net_lid, uint8_t aid, uint8_t offset)
{
    uint8_t i, j = 0;
   1288a:	2300      	movs	r3, #0
        }
        else if (rd_net_lid > net_lid)
        {
            // Network key local index not found - stop research
            i = p_env->nb_nids;
            break;
   1288c:	e000      	b.n	12890 <m_tb_key_app_lid_from_net_aid+0x64>
    return (status);
}

m_lid_t m_tb_key_app_lid_from_net_aid(m_lid_t net_lid, uint8_t aid, uint8_t offset)
{
    uint8_t i, j = 0;
   1288e:	2300      	movs	r3, #0
        }
    }

    // Add offset to the found position
    i += j;
    i += offset;
   12890:	9a00      	ldr	r2, [sp, #0]
            break;
        }
    }

    // Add offset to the found position
    i += j;
   12892:	18f3      	adds	r3, r6, r3
    i += offset;
   12894:	189b      	adds	r3, r3, r2
   12896:	b2da      	uxtb	r2, r3

m_lid_t m_tb_key_app_lid_from_net_aid(m_lid_t net_lid, uint8_t aid, uint8_t offset)
{
    uint8_t i, j = 0;
    m_tb_key_env_t *p_env = p_m_tb_key_env;
    m_lid_t app_lid = M_INVALID_LID;
   12898:	20ff      	movs	r0, #255	; 0xff
    // Add offset to the found position
    i += j;
    i += offset;

    // Check that position is valid
    if ((i < p_env->nb_aids) && (p_env->map_nk_ak[i].aid == aid))
   1289a:	4297      	cmp	r7, r2
   1289c:	d909      	bls.n	128b2 <m_tb_key_app_lid_from_net_aid+0x86>
   1289e:	2503      	movs	r5, #3
   128a0:	436a      	muls	r2, r5
   128a2:	18a4      	adds	r4, r4, r2
   128a4:	0023      	movs	r3, r4
   128a6:	3349      	adds	r3, #73	; 0x49
   128a8:	781b      	ldrb	r3, [r3, #0]
   128aa:	428b      	cmp	r3, r1
   128ac:	d101      	bne.n	128b2 <m_tb_key_app_lid_from_net_aid+0x86>
    {
        app_lid = p_env->map_nk_ak[i].app_key_lid;
   128ae:	344a      	adds	r4, #74	; 0x4a
   128b0:	7820      	ldrb	r0, [r4, #0]
    }

    return (app_lid);
}
   128b2:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
   128b4:	100126c0 	.word	0x100126c0

000128b8 <m_tb_key_app_get_ids>:
void m_tb_key_app_get_ids(m_lid_t net_key_lid, uint8_t *p_appkey_ids)
{
    // Counters
    uint8_t cnt, offset;
    // Get network key information
    m_tb_key_net_t *p_key_net = (m_tb_key_net_t *)(p_m_tb_key_env->p_keys[net_key_lid]);
   128b8:	4b1f      	ldr	r3, [pc, #124]	; (12938 <m_tb_key_app_get_ids+0x80>)

    return (app_lid);
}

void m_tb_key_app_get_ids(m_lid_t net_key_lid, uint8_t *p_appkey_ids)
{
   128ba:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    // Counters
    uint8_t cnt, offset;
    // Get network key information
    m_tb_key_net_t *p_key_net = (m_tb_key_net_t *)(p_m_tb_key_env->p_keys[net_key_lid]);
   128bc:	681d      	ldr	r5, [r3, #0]
   128be:	0083      	lsls	r3, r0, #2
   128c0:	595e      	ldr	r6, [r3, r5]
    // Value to write
    uint32_t wr_val = 0;

    // Look for network key local index in mapping table allowing to retrieve an application key local index
    for (cnt = 0; cnt < p_m_tb_key_env->nb_aids; cnt++)
   128c2:	002b      	movs	r3, r5
   128c4:	2400      	movs	r4, #0
   128c6:	33b6      	adds	r3, #182	; 0xb6
   128c8:	781a      	ldrb	r2, [r3, #0]
   128ca:	3b6e      	subs	r3, #110	; 0x6e
   128cc:	4294      	cmp	r4, r2
   128ce:	d004      	beq.n	128da <m_tb_key_app_get_ids+0x22>
   128d0:	3303      	adds	r3, #3
    {
        m_lid_t rd_net_lid = p_m_tb_key_env->map_nk_ak[cnt].net_key_lid;
   128d2:	1edf      	subs	r7, r3, #3

        if (rd_net_lid == net_key_lid)
   128d4:	783f      	ldrb	r7, [r7, #0]
   128d6:	4287      	cmp	r7, r0
   128d8:	d106      	bne.n	128e8 <m_tb_key_app_get_ids+0x30>
    m_tb_key_net_t *p_key_net = (m_tb_key_net_t *)(p_m_tb_key_env->p_keys[net_key_lid]);
    // Value to write
    uint32_t wr_val = 0;

    // Look for network key local index in mapping table allowing to retrieve an application key local index
    for (cnt = 0; cnt < p_m_tb_key_env->nb_aids; cnt++)
   128da:	2300      	movs	r3, #0
        // Application key information
        m_tb_key_app_t *p_key_app = (m_tb_key_app_t *)(p_m_tb_key_env->p_keys[app_key_lid]);
        // Get AppKey index
        uint16_t appkey_id = p_key_app->app_key_id;

        if (offset & 0x1)
   128dc:	2001      	movs	r0, #1
            break;
        }
    }

    // Loop over all application keys
    for (offset = 0; offset < p_key_net->nb_app_keys; offset++)
   128de:	364e      	adds	r6, #78	; 0x4e
    m_tb_key_net_t *p_key_net = (m_tb_key_net_t *)(p_m_tb_key_env->p_keys[net_key_lid]);
    // Value to write
    uint32_t wr_val = 0;

    // Look for network key local index in mapping table allowing to retrieve an application key local index
    for (cnt = 0; cnt < p_m_tb_key_env->nb_aids; cnt++)
   128e0:	001a      	movs	r2, r3
            break;
        }
    }

    // Loop over all application keys
    for (offset = 0; offset < p_key_net->nb_app_keys; offset++)
   128e2:	9601      	str	r6, [sp, #4]
        // Application key information
        m_tb_key_app_t *p_key_app = (m_tb_key_app_t *)(p_m_tb_key_env->p_keys[app_key_lid]);
        // Get AppKey index
        uint16_t appkey_id = p_key_app->app_key_id;

        if (offset & 0x1)
   128e4:	4684      	mov	ip, r0
   128e6:	e018      	b.n	1291a <m_tb_key_app_get_ids+0x62>
    m_tb_key_net_t *p_key_net = (m_tb_key_net_t *)(p_m_tb_key_env->p_keys[net_key_lid]);
    // Value to write
    uint32_t wr_val = 0;

    // Look for network key local index in mapping table allowing to retrieve an application key local index
    for (cnt = 0; cnt < p_m_tb_key_env->nb_aids; cnt++)
   128e8:	3401      	adds	r4, #1
   128ea:	b2e4      	uxtb	r4, r4
   128ec:	e7ee      	b.n	128cc <m_tb_key_app_get_ids+0x14>

    // Loop over all application keys
    for (offset = 0; offset < p_key_net->nb_app_keys; offset++)
    {
        // Get application key local index
        m_lid_t app_key_lid = p_m_tb_key_env->map_nk_ak[cnt + offset].app_key_lid;
   128ee:	2703      	movs	r7, #3
   128f0:	18a0      	adds	r0, r4, r2
   128f2:	4378      	muls	r0, r7
        // Application key information
        m_tb_key_app_t *p_key_app = (m_tb_key_app_t *)(p_m_tb_key_env->p_keys[app_key_lid]);
        // Get AppKey index
        uint16_t appkey_id = p_key_app->app_key_id;

        if (offset & 0x1)
   128f4:	4667      	mov	r7, ip

    // Loop over all application keys
    for (offset = 0; offset < p_key_net->nb_app_keys; offset++)
    {
        // Get application key local index
        m_lid_t app_key_lid = p_m_tb_key_env->map_nk_ak[cnt + offset].app_key_lid;
   128f6:	1828      	adds	r0, r5, r0
   128f8:	304a      	adds	r0, #74	; 0x4a
        // Application key information
        m_tb_key_app_t *p_key_app = (m_tb_key_app_t *)(p_m_tb_key_env->p_keys[app_key_lid]);
   128fa:	7800      	ldrb	r0, [r0, #0]
   128fc:	0080      	lsls	r0, r0, #2
        // Get AppKey index
        uint16_t appkey_id = p_key_app->app_key_id;
   128fe:	5940      	ldr	r0, [r0, r5]
   12900:	8a80      	ldrh	r0, [r0, #20]

        if (offset & 0x1)
   12902:	423a      	tst	r2, r7
   12904:	d00e      	beq.n	12924 <m_tb_key_app_get_ids+0x6c>
        {
            wr_val |= ((uint32_t)appkey_id << 12);
   12906:	0300      	lsls	r0, r0, #12
   12908:	4303      	orrs	r3, r0
__INLINE_S__ void co_write24p(void const *ptr24, uint32_t value)
{
    uint8_t *ptr=(uint8_t*)ptr24;

    *ptr++ = (uint8_t)(value&0xff);
    *ptr++ = (uint8_t)((value&0xff00)>>8);
   1290a:	0a18      	lsrs	r0, r3, #8
   1290c:	7048      	strb	r0, [r1, #1]
    *ptr++ = (uint8_t)((value&0xff0000)>>16);
   1290e:	0c18      	lsrs	r0, r3, #16
 */
__INLINE_S__ void co_write24p(void const *ptr24, uint32_t value)
{
    uint8_t *ptr=(uint8_t*)ptr24;

    *ptr++ = (uint8_t)(value&0xff);
   12910:	700b      	strb	r3, [r1, #0]
    *ptr++ = (uint8_t)((value&0xff00)>>8);
    *ptr++ = (uint8_t)((value&0xff0000)>>16);
   12912:	7088      	strb	r0, [r1, #2]

            // Write the last two indexes
            co_write24p(p_appkey_ids, wr_val);

            // Move pointer
            p_appkey_ids += 3;
   12914:	3103      	adds	r1, #3
            break;
        }
    }

    // Loop over all application keys
    for (offset = 0; offset < p_key_net->nb_app_keys; offset++)
   12916:	3201      	adds	r2, #1
   12918:	b2d2      	uxtb	r2, r2
   1291a:	9801      	ldr	r0, [sp, #4]
   1291c:	7806      	ldrb	r6, [r0, #0]
   1291e:	42b2      	cmp	r2, r6
   12920:	d3e5      	bcc.n	128ee <m_tb_key_app_get_ids+0x36>
   12922:	e007      	b.n	12934 <m_tb_key_app_get_ids+0x7c>
        }
        else
        {
            wr_val = (uint32_t)appkey_id;

            if (offset == (p_key_net->nb_app_keys - 1))
   12924:	3e01      	subs	r6, #1
            // Move pointer
            p_appkey_ids += 3;
        }
        else
        {
            wr_val = (uint32_t)appkey_id;
   12926:	0003      	movs	r3, r0

            if (offset == (p_key_net->nb_app_keys - 1))
   12928:	42b2      	cmp	r2, r6
   1292a:	d1f4      	bne.n	12916 <m_tb_key_app_get_ids+0x5e>
 */
__INLINE_S__ void co_write16p(void const *ptr16, uint16_t value)
{
    uint8_t *ptr=(uint8_t*)ptr16;

    *ptr++ = value&0xff;
   1292c:	7008      	strb	r0, [r1, #0]
    *ptr = (value&0xff00)>>8;
   1292e:	0a00      	lsrs	r0, r0, #8
   12930:	7048      	strb	r0, [r1, #1]
   12932:	e7f0      	b.n	12916 <m_tb_key_app_get_ids+0x5e>
                // Write the index
                co_write16p(p_appkey_ids, wr_val);
            }
        }
    }
}
   12934:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
   12936:	46c0      	nop			; (mov r8, r8)
   12938:	100126c0 	.word	0x100126c0

0001293c <m_tb_key_app_get_lids>:
void m_tb_key_app_get_lids(m_lid_t net_key_lid, m_lid_t *p_appkey_lids)
{
    // Counters
    uint8_t cnt, offset;
    // Get network key information
    m_tb_key_net_t *p_key_net = (m_tb_key_net_t *)(p_m_tb_key_env->p_keys[net_key_lid]);
   1293c:	4b14      	ldr	r3, [pc, #80]	; (12990 <m_tb_key_app_get_lids+0x54>)
        }
    }
}

void m_tb_key_app_get_lids(m_lid_t net_key_lid, m_lid_t *p_appkey_lids)
{
   1293e:	b5f0      	push	{r4, r5, r6, r7, lr}
    // Counters
    uint8_t cnt, offset;
    // Get network key information
    m_tb_key_net_t *p_key_net = (m_tb_key_net_t *)(p_m_tb_key_env->p_keys[net_key_lid]);
   12940:	681c      	ldr	r4, [r3, #0]
   12942:	0083      	lsls	r3, r0, #2
   12944:	591d      	ldr	r5, [r3, r4]

    // Look for network key local index in mapping table allowing to retrieve an application key local index
    for (cnt = 0; cnt < p_m_tb_key_env->nb_aids; cnt++)
   12946:	0023      	movs	r3, r4
   12948:	2200      	movs	r2, #0
   1294a:	33b6      	adds	r3, #182	; 0xb6
   1294c:	781e      	ldrb	r6, [r3, #0]
   1294e:	3b6e      	subs	r3, #110	; 0x6e
   12950:	42b2      	cmp	r2, r6
   12952:	d004      	beq.n	1295e <m_tb_key_app_get_lids+0x22>
   12954:	3303      	adds	r3, #3
    {
        m_lid_t rd_net_lid = p_m_tb_key_env->map_nk_ak[cnt].net_key_lid;
   12956:	1edf      	subs	r7, r3, #3

        if (rd_net_lid == net_key_lid)
   12958:	783f      	ldrb	r7, [r7, #0]
   1295a:	4287      	cmp	r7, r0
   1295c:	d104      	bne.n	12968 <m_tb_key_app_get_lids+0x2c>
    uint8_t cnt, offset;
    // Get network key information
    m_tb_key_net_t *p_key_net = (m_tb_key_net_t *)(p_m_tb_key_env->p_keys[net_key_lid]);

    // Look for network key local index in mapping table allowing to retrieve an application key local index
    for (cnt = 0; cnt < p_m_tb_key_env->nb_aids; cnt++)
   1295e:	2000      	movs	r0, #0
            break;
        }
    }

    // Loop over all application keys
    for (offset = 0; offset < p_key_net->nb_app_keys; offset++)
   12960:	354e      	adds	r5, #78	; 0x4e
    {
        *p_appkey_lids = p_m_tb_key_env->map_nk_ak[cnt + offset].app_key_lid;
   12962:	26ff      	movs	r6, #255	; 0xff
   12964:	2703      	movs	r7, #3
   12966:	e002      	b.n	1296e <m_tb_key_app_get_lids+0x32>
    uint8_t cnt, offset;
    // Get network key information
    m_tb_key_net_t *p_key_net = (m_tb_key_net_t *)(p_m_tb_key_env->p_keys[net_key_lid]);

    // Look for network key local index in mapping table allowing to retrieve an application key local index
    for (cnt = 0; cnt < p_m_tb_key_env->nb_aids; cnt++)
   12968:	3201      	adds	r2, #1
   1296a:	b2d2      	uxtb	r2, r2
   1296c:	e7f0      	b.n	12950 <m_tb_key_app_get_lids+0x14>
            break;
        }
    }

    // Loop over all application keys
    for (offset = 0; offset < p_key_net->nb_app_keys; offset++)
   1296e:	782b      	ldrb	r3, [r5, #0]
   12970:	469c      	mov	ip, r3
   12972:	b2c3      	uxtb	r3, r0
   12974:	459c      	cmp	ip, r3
   12976:	d909      	bls.n	1298c <m_tb_key_app_get_lids+0x50>
    {
        *p_appkey_lids = p_m_tb_key_env->map_nk_ak[cnt + offset].app_key_lid;
   12978:	0003      	movs	r3, r0
   1297a:	4033      	ands	r3, r6
   1297c:	189b      	adds	r3, r3, r2
   1297e:	437b      	muls	r3, r7
   12980:	18e3      	adds	r3, r4, r3
   12982:	334a      	adds	r3, #74	; 0x4a
   12984:	781b      	ldrb	r3, [r3, #0]
   12986:	540b      	strb	r3, [r1, r0]
   12988:	3001      	adds	r0, #1
   1298a:	e7f0      	b.n	1296e <m_tb_key_app_get_lids+0x32>
        p_appkey_lids++;
    }
}
   1298c:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1298e:	46c0      	nop			; (mov r8, r8)
   12990:	100126c0 	.word	0x100126c0

00012994 <m_tb_key_model_bind>:

uint16_t m_tb_key_model_bind(m_lid_t app_key_lid, m_lid_t model_lid)
{
   12994:	b5f0      	push	{r4, r5, r6, r7, lr}
	M_PRINTF(L_TB, "app_key_lid[0x%x]model_lid[0x%x]", app_key_lid, model_lid);
   12996:	4b5c      	ldr	r3, [pc, #368]	; (12b08 <m_tb_key_model_bind+0x174>)
        p_appkey_lids++;
    }
}

uint16_t m_tb_key_model_bind(m_lid_t app_key_lid, m_lid_t model_lid)
{
   12998:	b087      	sub	sp, #28
	M_PRINTF(L_TB, "app_key_lid[0x%x]model_lid[0x%x]", app_key_lid, model_lid);
   1299a:	681b      	ldr	r3, [r3, #0]
        p_appkey_lids++;
    }
}

uint16_t m_tb_key_model_bind(m_lid_t app_key_lid, m_lid_t model_lid)
{
   1299c:	0006      	movs	r6, r0
   1299e:	9103      	str	r1, [sp, #12]
	M_PRINTF(L_TB, "app_key_lid[0x%x]model_lid[0x%x]", app_key_lid, model_lid);
   129a0:	079b      	lsls	r3, r3, #30
   129a2:	d517      	bpl.n	129d4 <m_tb_key_model_bind+0x40>
   129a4:	4f59      	ldr	r7, [pc, #356]	; (12b0c <m_tb_key_model_bind+0x178>)
   129a6:	4d5a      	ldr	r5, [pc, #360]	; (12b10 <m_tb_key_model_bind+0x17c>)
   129a8:	003b      	movs	r3, r7
   129aa:	002a      	movs	r2, r5
   129ac:	0028      	movs	r0, r5
   129ae:	3361      	adds	r3, #97	; 0x61
   129b0:	3237      	adds	r2, #55	; 0x37
   129b2:	9300      	str	r3, [sp, #0]
   129b4:	0029      	movs	r1, r5
   129b6:	4b57      	ldr	r3, [pc, #348]	; (12b14 <m_tb_key_model_bind+0x180>)
   129b8:	3042      	adds	r0, #66	; 0x42
   129ba:	f7f1 fff7 	bl	49ac <m_print>
   129be:	0038      	movs	r0, r7
   129c0:	0031      	movs	r1, r6
   129c2:	3075      	adds	r0, #117	; 0x75
   129c4:	9a03      	ldr	r2, [sp, #12]
   129c6:	f7f1 fff1 	bl	49ac <m_print>
   129ca:	4853      	ldr	r0, [pc, #332]	; (12b18 <m_tb_key_model_bind+0x184>)
   129cc:	1da9      	adds	r1, r5, #6
   129ce:	3003      	adds	r0, #3
   129d0:	f7f1 ffec 	bl	49ac <m_print>
    {
        int8_t i;
        m_tb_key_env_t* p_env      = p_m_tb_key_env;
        m_tb_key_app_t* p_app_key  = NULL;

        app_key_lid = GETF(app_key_lid, M_TB_KEY_LID);//get app_key_lid low 7 bit
   129d4:	207f      	movs	r0, #127	; 0x7f
   129d6:	4030      	ands	r0, r6

        // check identifier range
        if(((app_key_lid < M_TB_KEY_APP_START_LID) || (app_key_lid > M_TB_KEY_APP_END_LID)) &&
   129d8:	1ec3      	subs	r3, r0, #3
   129da:	2b09      	cmp	r3, #9
   129dc:	d901      	bls.n	129e2 <m_tb_key_model_bind+0x4e>
   129de:	2800      	cmp	r0, #0
   129e0:	d16c      	bne.n	12abc <m_tb_key_model_bind+0x128>
    uint16_t        status     = M_ERR_NO_ERROR;

    do
    {
        int8_t i;
        m_tb_key_env_t* p_env      = p_m_tb_key_env;
   129e2:	4b4e      	ldr	r3, [pc, #312]	; (12b1c <m_tb_key_model_bind+0x188>)
   129e4:	681b      	ldr	r3, [r3, #0]
            status  = M_ERR_INVALID_APPKEY_ID;
            break;
        }

        // ensure that no key creation are on-going
        if (GETB(p_env->status, M_TB_KEY_STATE_KEY_GEN))
   129e6:	001a      	movs	r2, r3
   129e8:	32b9      	adds	r2, #185	; 0xb9
   129ea:	7811      	ldrb	r1, [r2, #0]
   129ec:	2208      	movs	r2, #8
   129ee:	4011      	ands	r1, r2
   129f0:	d162      	bne.n	12ab8 <m_tb_key_model_bind+0x124>
            status = M_ERR_COMMAND_DISALLOWED;
            break;
        }

        // Retrieve application key
        p_app_key = (m_tb_key_app_t*) p_env->p_keys[app_key_lid];
   129f2:	0082      	lsls	r2, r0, #2
   129f4:	58d6      	ldr	r6, [r2, r3]

        if(p_app_key == NULL)
   129f6:	2e00      	cmp	r6, #0
   129f8:	d060      	beq.n	12abc <m_tb_key_model_bind+0x128>
        {
            status = M_ERR_INVALID_APPKEY_ID;
            break;
        }

        if(p_env->nb_mids == M_TB_KEY_MAX_NB_APP_MODEL_BIND)
   129fa:	001a      	movs	r2, r3
   129fc:	32b7      	adds	r2, #183	; 0xb7
   129fe:	7812      	ldrb	r2, [r2, #0]
   12a00:	2a14      	cmp	r2, #20
   12a02:	d05e      	beq.n	12ac2 <m_tb_key_model_bind+0x12e>
            status = M_ERR_CANNOT_BIND;
            break;
        }

        // Search presence of an existing bind
        for(i = 0 ; i < p_env->nb_mids ; i++)
   12a04:	4291      	cmp	r1, r2
   12a06:	da0e      	bge.n	12a26 <m_tb_key_model_bind+0x92>
   12a08:	004d      	lsls	r5, r1, #1
   12a0a:	195d      	adds	r5, r3, r5
        {
            if(   (p_env->map_ak_mid[i].app_key_lid == app_key_lid)
   12a0c:	002f      	movs	r7, r5
   12a0e:	3784      	adds	r7, #132	; 0x84
   12a10:	783f      	ldrb	r7, [r7, #0]
   12a12:	4287      	cmp	r7, r0
   12a14:	d104      	bne.n	12a20 <m_tb_key_model_bind+0x8c>
               && (p_env->map_ak_mid[i].model_lid   == model_lid))
   12a16:	3585      	adds	r5, #133	; 0x85
   12a18:	782d      	ldrb	r5, [r5, #0]
   12a1a:	9c03      	ldr	r4, [sp, #12]
   12a1c:	42a5      	cmp	r5, r4
   12a1e:	d053      	beq.n	12ac8 <m_tb_key_model_bind+0x134>
   12a20:	3101      	adds	r1, #1
   12a22:	b249      	sxtb	r1, r1
   12a24:	e7ee      	b.n	12a04 <m_tb_key_model_bind+0x70>
                break;
            }
        }

        // binding already exist
        if(i != p_env->nb_mids)
   12a26:	4291      	cmp	r1, r2
   12a28:	d14e      	bne.n	12ac8 <m_tb_key_model_bind+0x134>
            status = M_ERR_INVALID_BINDING;
            break;
        }

        // browse list in reverse order move element till new element can be inserted.
        for(i = p_env->nb_mids ; i > 0 ; i--)
   12a2a:	b255      	sxtb	r5, r2
   12a2c:	0069      	lsls	r1, r5, #1
   12a2e:	9105      	str	r1, [sp, #20]
   12a30:	2d00      	cmp	r5, #0
   12a32:	dd08      	ble.n	12a46 <m_tb_key_model_bind+0xb2>
   12a34:	0069      	lsls	r1, r5, #1
   12a36:	1859      	adds	r1, r3, r1
        {
            // check if previous element has a greater application id or model identifier
            if(   (p_env->map_ak_mid[i-1].app_key_lid > app_key_lid)
   12a38:	000f      	movs	r7, r1
   12a3a:	3782      	adds	r7, #130	; 0x82
   12a3c:	783c      	ldrb	r4, [r7, #0]
   12a3e:	9404      	str	r4, [sp, #16]
   12a40:	42a0      	cmp	r0, r4
   12a42:	d31c      	bcc.n	12a7e <m_tb_key_model_bind+0xea>
               || ((p_env->map_ak_mid[i-1].app_key_lid == app_key_lid) && (p_env->map_ak_mid[i-1].model_lid > model_lid)))
   12a44:	d013      	beq.n	12a6e <m_tb_key_model_bind+0xda>
   12a46:	9905      	ldr	r1, [sp, #20]
            }
        }

        // Insert new element
        p_env->map_ak_mid[i].app_key_lid = app_key_lid;
        p_env->map_ak_mid[i].model_lid   = model_lid;
   12a48:	466c      	mov	r4, sp
   12a4a:	1859      	adds	r1, r3, r1
                break;
            }
        }

        // Insert new element
        p_env->map_ak_mid[i].app_key_lid = app_key_lid;
   12a4c:	000d      	movs	r5, r1
        p_env->map_ak_mid[i].model_lid   = model_lid;
   12a4e:	7b24      	ldrb	r4, [r4, #12]
   12a50:	3185      	adds	r1, #133	; 0x85
                break;
            }
        }

        // Insert new element
        p_env->map_ak_mid[i].app_key_lid = app_key_lid;
   12a52:	3584      	adds	r5, #132	; 0x84
   12a54:	7028      	strb	r0, [r5, #0]
        p_env->map_ak_mid[i].model_lid   = model_lid;
   12a56:	700c      	strb	r4, [r1, #0]
        p_env->nb_mids++;
   12a58:	0019      	movs	r1, r3
   12a5a:	3201      	adds	r2, #1
   12a5c:	31b7      	adds	r1, #183	; 0xb7
   12a5e:	700a      	strb	r2, [r1, #0]

        // update bind information of key
        p_app_key->nb_models++;
   12a60:	7cb2      	ldrb	r2, [r6, #18]
        // check if second key should be updated
        if(p_app_key->state != M_TB_KEY_STATE_NORMAL)
   12a62:	7874      	ldrb	r4, [r6, #1]
        p_env->map_ak_mid[i].app_key_lid = app_key_lid;
        p_env->map_ak_mid[i].model_lid   = model_lid;
        p_env->nb_mids++;

        // update bind information of key
        p_app_key->nb_models++;
   12a64:	3201      	adds	r2, #1
   12a66:	74b2      	strb	r2, [r6, #18]
        // check if second key should be updated
        if(p_app_key->state != M_TB_KEY_STATE_NORMAL)
   12a68:	2c00      	cmp	r4, #0
   12a6a:	d117      	bne.n	12a9c <m_tb_key_model_bind+0x108>
   12a6c:	e02e      	b.n	12acc <m_tb_key_model_bind+0x138>
        // browse list in reverse order move element till new element can be inserted.
        for(i = p_env->nb_mids ; i > 0 ; i--)
        {
            // check if previous element has a greater application id or model identifier
            if(   (p_env->map_ak_mid[i-1].app_key_lid > app_key_lid)
               || ((p_env->map_ak_mid[i-1].app_key_lid == app_key_lid) && (p_env->map_ak_mid[i-1].model_lid > model_lid)))
   12a6e:	2783      	movs	r7, #131	; 0x83
   12a70:	46bc      	mov	ip, r7
   12a72:	448c      	add	ip, r1
   12a74:	4667      	mov	r7, ip
   12a76:	9c03      	ldr	r4, [sp, #12]
   12a78:	783f      	ldrb	r7, [r7, #0]
   12a7a:	42a7      	cmp	r7, r4
   12a7c:	d9e3      	bls.n	12a46 <m_tb_key_model_bind+0xb2>
            {
                // push element in next
                p_env->map_ak_mid[i].app_key_lid = p_env->map_ak_mid[i-1].app_key_lid ;
   12a7e:	2784      	movs	r7, #132	; 0x84
   12a80:	46bc      	mov	ip, r7
   12a82:	466c      	mov	r4, sp
   12a84:	448c      	add	ip, r1
   12a86:	4667      	mov	r7, ip
   12a88:	7c24      	ldrb	r4, [r4, #16]
   12a8a:	3d01      	subs	r5, #1
   12a8c:	703c      	strb	r4, [r7, #0]
                p_env->map_ak_mid[i].model_lid   = p_env->map_ak_mid[i-1].model_lid;
   12a8e:	000f      	movs	r7, r1
   12a90:	3183      	adds	r1, #131	; 0x83
   12a92:	7809      	ldrb	r1, [r1, #0]
   12a94:	3785      	adds	r7, #133	; 0x85
   12a96:	7039      	strb	r1, [r7, #0]
   12a98:	b26d      	sxtb	r5, r5
   12a9a:	e7c7      	b.n	12a2c <m_tb_key_model_bind+0x98>
        // update bind information of key
        p_app_key->nb_models++;
        // check if second key should be updated
        if(p_app_key->state != M_TB_KEY_STATE_NORMAL)
        {
            ASSERT_ERR(p_env->p_up != NULL);
   12a9c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
   12a9e:	2b00      	cmp	r3, #0
   12aa0:	d100      	bne.n	12aa4 <m_tb_key_model_bind+0x110>
   12aa2:	e7fe      	b.n	12aa2 <m_tb_key_model_bind+0x10e>
            p_app_key = (m_tb_key_app_t*) p_env->p_up->p_keys[app_key_lid];
   12aa4:	0080      	lsls	r0, r0, #2
   12aa6:	58c3      	ldr	r3, [r0, r3]
            ASSERT_ERR(p_app_key != NULL);
   12aa8:	2b00      	cmp	r3, #0
   12aaa:	d100      	bne.n	12aae <m_tb_key_model_bind+0x11a>
   12aac:	e7fe      	b.n	12aac <m_tb_key_model_bind+0x118>
            p_app_key->nb_models++;
   12aae:	7c9a      	ldrb	r2, [r3, #18]
}

uint16_t m_tb_key_model_bind(m_lid_t app_key_lid, m_lid_t model_lid)
{
	M_PRINTF(L_TB, "app_key_lid[0x%x]model_lid[0x%x]", app_key_lid, model_lid);
    uint16_t        status     = M_ERR_NO_ERROR;
   12ab0:	2400      	movs	r4, #0
        if(p_app_key->state != M_TB_KEY_STATE_NORMAL)
        {
            ASSERT_ERR(p_env->p_up != NULL);
            p_app_key = (m_tb_key_app_t*) p_env->p_up->p_keys[app_key_lid];
            ASSERT_ERR(p_app_key != NULL);
            p_app_key->nb_models++;
   12ab2:	3201      	adds	r2, #1
   12ab4:	749a      	strb	r2, [r3, #18]
   12ab6:	e009      	b.n	12acc <m_tb_key_model_bind+0x138>
        }

        // ensure that no key creation are on-going
        if (GETB(p_env->status, M_TB_KEY_STATE_KEY_GEN))
        {
            status = M_ERR_COMMAND_DISALLOWED;
   12ab8:	4c19      	ldr	r4, [pc, #100]	; (12b20 <m_tb_key_model_bind+0x18c>)
   12aba:	e007      	b.n	12acc <m_tb_key_model_bind+0x138>

        // check identifier range
        if(((app_key_lid < M_TB_KEY_APP_START_LID) || (app_key_lid > M_TB_KEY_APP_END_LID)) &&
           (app_key_lid != M_TB_KEY_DEVICE_LID))
        {
            status  = M_ERR_INVALID_APPKEY_ID;
   12abc:	24e0      	movs	r4, #224	; 0xe0
   12abe:	00a4      	lsls	r4, r4, #2
   12ac0:	e004      	b.n	12acc <m_tb_key_model_bind+0x138>
            break;
        }

        if(p_env->nb_mids == M_TB_KEY_MAX_NB_APP_MODEL_BIND)
        {
            status = M_ERR_CANNOT_BIND;
   12ac2:	24d8      	movs	r4, #216	; 0xd8
   12ac4:	0124      	lsls	r4, r4, #4
   12ac6:	e001      	b.n	12acc <m_tb_key_model_bind+0x138>
        }

        // binding already exist
        if(i != p_env->nb_mids)
        {
            status = M_ERR_INVALID_BINDING;
   12ac8:	248c      	movs	r4, #140	; 0x8c
   12aca:	0164      	lsls	r4, r4, #5
            p_app_key = (m_tb_key_app_t*) p_env->p_up->p_keys[app_key_lid];
            ASSERT_ERR(p_app_key != NULL);
            p_app_key->nb_models++;
        }
    } while (0);
	M_PRINTF(L_TB, "status = %d", status);
   12acc:	4b0e      	ldr	r3, [pc, #56]	; (12b08 <m_tb_key_model_bind+0x174>)
   12ace:	681b      	ldr	r3, [r3, #0]
   12ad0:	079b      	lsls	r3, r3, #30
   12ad2:	d516      	bpl.n	12b02 <m_tb_key_model_bind+0x16e>
   12ad4:	4b0d      	ldr	r3, [pc, #52]	; (12b0c <m_tb_key_model_bind+0x178>)
   12ad6:	4d0e      	ldr	r5, [pc, #56]	; (12b10 <m_tb_key_model_bind+0x17c>)
   12ad8:	3361      	adds	r3, #97	; 0x61
   12ada:	9300      	str	r3, [sp, #0]
   12adc:	002a      	movs	r2, r5
   12ade:	0028      	movs	r0, r5
   12ae0:	23b3      	movs	r3, #179	; 0xb3
   12ae2:	3237      	adds	r2, #55	; 0x37
   12ae4:	011b      	lsls	r3, r3, #4
   12ae6:	0029      	movs	r1, r5
   12ae8:	3042      	adds	r0, #66	; 0x42
   12aea:	f7f1 ff5f 	bl	49ac <m_print>
   12aee:	480d      	ldr	r0, [pc, #52]	; (12b24 <m_tb_key_model_bind+0x190>)
   12af0:	0021      	movs	r1, r4
   12af2:	3016      	adds	r0, #22
   12af4:	f7f1 ff5a 	bl	49ac <m_print>
   12af8:	4807      	ldr	r0, [pc, #28]	; (12b18 <m_tb_key_model_bind+0x184>)
   12afa:	1da9      	adds	r1, r5, #6
   12afc:	3003      	adds	r0, #3
   12afe:	f7f1 ff55 	bl	49ac <m_print>
    return (status);
}
   12b02:	0020      	movs	r0, r4
   12b04:	b007      	add	sp, #28
   12b06:	bdf0      	pop	{r4, r5, r6, r7, pc}
   12b08:	10010514 	.word	0x10010514
   12b0c:	00022744 	.word	0x00022744
   12b10:	00022644 	.word	0x00022644
   12b14:	00000ad5 	.word	0x00000ad5
   12b18:	000226c4 	.word	0x000226c4
   12b1c:	100126c0 	.word	0x100126c0
   12b20:	00000282 	.word	0x00000282
   12b24:	000227c4 	.word	0x000227c4

00012b28 <m_tb_key_model_unbind>:
    {
        m_tb_key_env_t* p_env      = p_m_tb_key_env;
        m_tb_key_app_t* p_app_key  = NULL;
        int8_t i;

        app_key_lid = GETF(app_key_lid, M_TB_KEY_LID);
   12b28:	237f      	movs	r3, #127	; 0x7f
	M_PRINTF(L_TB, "status = %d", status);
    return (status);
}

uint16_t m_tb_key_model_unbind(m_lid_t app_key_lid, m_lid_t model_lid)
{
   12b2a:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    {
        m_tb_key_env_t* p_env      = p_m_tb_key_env;
        m_tb_key_app_t* p_app_key  = NULL;
        int8_t i;

        app_key_lid = GETF(app_key_lid, M_TB_KEY_LID);
   12b2c:	4018      	ands	r0, r3

        // check identifier range
        if((app_key_lid < M_TB_KEY_APP_START_LID) || (app_key_lid > M_TB_KEY_APP_END_LID))
   12b2e:	1ec3      	subs	r3, r0, #3
	M_PRINTF(L_TB, "status = %d", status);
    return (status);
}

uint16_t m_tb_key_model_unbind(m_lid_t app_key_lid, m_lid_t model_lid)
{
   12b30:	9101      	str	r1, [sp, #4]
        int8_t i;

        app_key_lid = GETF(app_key_lid, M_TB_KEY_LID);

        // check identifier range
        if((app_key_lid < M_TB_KEY_APP_START_LID) || (app_key_lid > M_TB_KEY_APP_END_LID))
   12b32:	2b09      	cmp	r3, #9
   12b34:	d84d      	bhi.n	12bd2 <m_tb_key_model_unbind+0xaa>
{
    uint16_t        status     = M_ERR_NO_ERROR;

    do
    {
        m_tb_key_env_t* p_env      = p_m_tb_key_env;
   12b36:	4b2a      	ldr	r3, [pc, #168]	; (12be0 <m_tb_key_model_unbind+0xb8>)
   12b38:	681c      	ldr	r4, [r3, #0]
            status  = M_ERR_INVALID_APPKEY_ID;
            break;
        }

        // ensure that no key creation are on-going
        if (GETB(p_env->status, M_TB_KEY_STATE_KEY_GEN))
   12b3a:	0023      	movs	r3, r4
   12b3c:	33b9      	adds	r3, #185	; 0xb9
   12b3e:	781a      	ldrb	r2, [r3, #0]
   12b40:	2308      	movs	r3, #8
   12b42:	4013      	ands	r3, r2
   12b44:	d143      	bne.n	12bce <m_tb_key_model_unbind+0xa6>
            status = M_ERR_COMMAND_DISALLOWED;
            break;
        }

        // Retrieve application key
        p_app_key = (m_tb_key_app_t*) p_env->p_keys[app_key_lid];
   12b46:	0086      	lsls	r6, r0, #2
   12b48:	5937      	ldr	r7, [r6, r4]

        if(p_app_key == NULL)
   12b4a:	2f00      	cmp	r7, #0
   12b4c:	d041      	beq.n	12bd2 <m_tb_key_model_unbind+0xaa>
            status = M_ERR_INVALID_APPKEY_ID;
            break;
        }

        // Search presence of an existing bind
        for(i = 0 ; i < p_env->nb_mids ; i++)
   12b4e:	0022      	movs	r2, r4
   12b50:	32b7      	adds	r2, #183	; 0xb7
   12b52:	7812      	ldrb	r2, [r2, #0]
   12b54:	4293      	cmp	r3, r2
   12b56:	da0d      	bge.n	12b74 <m_tb_key_model_unbind+0x4c>
        {
            if(   (p_env->map_ak_mid[i].app_key_lid == app_key_lid)
   12b58:	2184      	movs	r1, #132	; 0x84
   12b5a:	468c      	mov	ip, r1
   12b5c:	005d      	lsls	r5, r3, #1
   12b5e:	1965      	adds	r5, r4, r5
   12b60:	44ac      	add	ip, r5
   12b62:	4661      	mov	r1, ip
   12b64:	7809      	ldrb	r1, [r1, #0]
   12b66:	4281      	cmp	r1, r0
   12b68:	d108      	bne.n	12b7c <m_tb_key_model_unbind+0x54>
               && (p_env->map_ak_mid[i].model_lid   == model_lid))
   12b6a:	3585      	adds	r5, #133	; 0x85
   12b6c:	782d      	ldrb	r5, [r5, #0]
   12b6e:	9901      	ldr	r1, [sp, #4]
   12b70:	428d      	cmp	r5, r1
   12b72:	d103      	bne.n	12b7c <m_tb_key_model_unbind+0x54>
            status = M_ERR_INVALID_BINDING;
            break;
        }

        // browse list in reverse order move element till new element can be inserted.
        for( ; i < p_env->nb_mids-1 ; i++)
   12b74:	1e51      	subs	r1, r2, #1
                break;
            }
        }

        // binding does not exist exist
        if(i == p_env->nb_mids)
   12b76:	4293      	cmp	r3, r2
   12b78:	d103      	bne.n	12b82 <m_tb_key_model_unbind+0x5a>
   12b7a:	e02d      	b.n	12bd8 <m_tb_key_model_unbind+0xb0>
   12b7c:	3301      	adds	r3, #1
   12b7e:	b25b      	sxtb	r3, r3
   12b80:	e7e8      	b.n	12b54 <m_tb_key_model_unbind+0x2c>
            status = M_ERR_INVALID_BINDING;
            break;
        }

        // browse list in reverse order move element till new element can be inserted.
        for( ; i < p_env->nb_mids-1 ; i++)
   12b82:	428b      	cmp	r3, r1
   12b84:	da0d      	bge.n	12ba2 <m_tb_key_model_unbind+0x7a>
   12b86:	005a      	lsls	r2, r3, #1
   12b88:	18a2      	adds	r2, r4, r2
        {
            // push next element in current element
            p_env->map_ak_mid[i].app_key_lid = p_env->map_ak_mid[i+1].app_key_lid ;
   12b8a:	0015      	movs	r5, r2
   12b8c:	0010      	movs	r0, r2
   12b8e:	3586      	adds	r5, #134	; 0x86
   12b90:	782d      	ldrb	r5, [r5, #0]
   12b92:	3084      	adds	r0, #132	; 0x84
   12b94:	7005      	strb	r5, [r0, #0]
            p_env->map_ak_mid[i].model_lid   = p_env->map_ak_mid[i+1].model_lid;
   12b96:	3287      	adds	r2, #135	; 0x87
   12b98:	7812      	ldrb	r2, [r2, #0]
   12b9a:	3301      	adds	r3, #1
   12b9c:	7042      	strb	r2, [r0, #1]
   12b9e:	b25b      	sxtb	r3, r3
   12ba0:	e7ef      	b.n	12b82 <m_tb_key_model_unbind+0x5a>
        }

        // Mark element removed
        p_env->nb_mids--;
   12ba2:	0023      	movs	r3, r4
    return (status);
}

uint16_t m_tb_key_model_unbind(m_lid_t app_key_lid, m_lid_t model_lid)
{
    uint16_t        status     = M_ERR_NO_ERROR;
   12ba4:	2000      	movs	r0, #0
            p_env->map_ak_mid[i].app_key_lid = p_env->map_ak_mid[i+1].app_key_lid ;
            p_env->map_ak_mid[i].model_lid   = p_env->map_ak_mid[i+1].model_lid;
        }

        // Mark element removed
        p_env->nb_mids--;
   12ba6:	33b7      	adds	r3, #183	; 0xb7
   12ba8:	7019      	strb	r1, [r3, #0]

        // update bind information of key
        p_app_key->nb_models--;
   12baa:	7cbb      	ldrb	r3, [r7, #18]
   12bac:	3b01      	subs	r3, #1
   12bae:	74bb      	strb	r3, [r7, #18]
        // check if second key should be updated
        if(p_app_key->state != M_TB_KEY_STATE_NORMAL)
   12bb0:	787b      	ldrb	r3, [r7, #1]
   12bb2:	4283      	cmp	r3, r0
   12bb4:	d012      	beq.n	12bdc <m_tb_key_model_unbind+0xb4>
        {
            ASSERT_ERR(p_env->p_up != NULL);
   12bb6:	6b63      	ldr	r3, [r4, #52]	; 0x34
   12bb8:	4283      	cmp	r3, r0
   12bba:	d100      	bne.n	12bbe <m_tb_key_model_unbind+0x96>
   12bbc:	e7fe      	b.n	12bbc <m_tb_key_model_unbind+0x94>
            p_app_key = (m_tb_key_app_t*) p_env->p_up->p_keys[app_key_lid];
   12bbe:	599b      	ldr	r3, [r3, r6]
            ASSERT_ERR(p_app_key != NULL);
   12bc0:	2b00      	cmp	r3, #0
   12bc2:	d100      	bne.n	12bc6 <m_tb_key_model_unbind+0x9e>
   12bc4:	e7fe      	b.n	12bc4 <m_tb_key_model_unbind+0x9c>
            p_app_key->nb_models--;
   12bc6:	7c9a      	ldrb	r2, [r3, #18]
   12bc8:	3a01      	subs	r2, #1
   12bca:	749a      	strb	r2, [r3, #18]
   12bcc:	e006      	b.n	12bdc <m_tb_key_model_unbind+0xb4>
        }

        // ensure that no key creation are on-going
        if (GETB(p_env->status, M_TB_KEY_STATE_KEY_GEN))
        {
            status = M_ERR_COMMAND_DISALLOWED;
   12bce:	4805      	ldr	r0, [pc, #20]	; (12be4 <m_tb_key_model_unbind+0xbc>)
   12bd0:	e004      	b.n	12bdc <m_tb_key_model_unbind+0xb4>
        app_key_lid = GETF(app_key_lid, M_TB_KEY_LID);

        // check identifier range
        if((app_key_lid < M_TB_KEY_APP_START_LID) || (app_key_lid > M_TB_KEY_APP_END_LID))
        {
            status  = M_ERR_INVALID_APPKEY_ID;
   12bd2:	20e0      	movs	r0, #224	; 0xe0
   12bd4:	0080      	lsls	r0, r0, #2
   12bd6:	e001      	b.n	12bdc <m_tb_key_model_unbind+0xb4>
        }

        // binding does not exist exist
        if(i == p_env->nb_mids)
        {
            status = M_ERR_INVALID_BINDING;
   12bd8:	208c      	movs	r0, #140	; 0x8c
   12bda:	0140      	lsls	r0, r0, #5
            p_app_key->nb_models--;
        }
    } while (0);

    return (status);
}
   12bdc:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
   12bde:	46c0      	nop			; (mov r8, r8)
   12be0:	100126c0 	.word	0x100126c0
   12be4:	00000282 	.word	0x00000282

00012be8 <m_tb_key_model_bind_check>:

uint16_t m_tb_key_model_bind_check(m_lid_t app_key_lid, m_lid_t model_lid)
{
    int8_t i;
    uint16_t        status     = M_ERR_NO_ERROR;
    m_tb_key_env_t* p_env      = p_m_tb_key_env;
   12be8:	4b0f      	ldr	r3, [pc, #60]	; (12c28 <m_tb_key_model_bind_check+0x40>)

    return (status);
}

uint16_t m_tb_key_model_bind_check(m_lid_t app_key_lid, m_lid_t model_lid)
{
   12bea:	b570      	push	{r4, r5, r6, lr}
    int8_t i;
    uint16_t        status     = M_ERR_NO_ERROR;
    m_tb_key_env_t* p_env      = p_m_tb_key_env;
   12bec:	681d      	ldr	r5, [r3, #0]

    app_key_lid = GETF(app_key_lid, M_TB_KEY_LID);
   12bee:	237f      	movs	r3, #127	; 0x7f
   12bf0:	4018      	ands	r0, r3

    // Search presence of an existing bind
    for(i = 0 ; i < p_env->nb_mids ; i++)
   12bf2:	002b      	movs	r3, r5
   12bf4:	33b7      	adds	r3, #183	; 0xb7
   12bf6:	781c      	ldrb	r4, [r3, #0]
   12bf8:	2300      	movs	r3, #0
   12bfa:	42a3      	cmp	r3, r4
   12bfc:	da0a      	bge.n	12c14 <m_tb_key_model_bind_check+0x2c>
   12bfe:	005a      	lsls	r2, r3, #1
   12c00:	18aa      	adds	r2, r5, r2
    {
        if(   (p_env->map_ak_mid[i].app_key_lid == app_key_lid)
   12c02:	0016      	movs	r6, r2
   12c04:	3684      	adds	r6, #132	; 0x84
   12c06:	7836      	ldrb	r6, [r6, #0]
   12c08:	4286      	cmp	r6, r0
   12c0a:	d109      	bne.n	12c20 <m_tb_key_model_bind_check+0x38>
           && (p_env->map_ak_mid[i].model_lid   == model_lid))
   12c0c:	3285      	adds	r2, #133	; 0x85
   12c0e:	7812      	ldrb	r2, [r2, #0]
   12c10:	428a      	cmp	r2, r1
   12c12:	d105      	bne.n	12c20 <m_tb_key_model_bind_check+0x38>
}

uint16_t m_tb_key_model_bind_check(m_lid_t app_key_lid, m_lid_t model_lid)
{
    int8_t i;
    uint16_t        status     = M_ERR_NO_ERROR;
   12c14:	2000      	movs	r0, #0
            break;
        }
    }

    // binding does not exist
    if(i == p_env->nb_mids)
   12c16:	42a3      	cmp	r3, r4
   12c18:	d105      	bne.n	12c26 <m_tb_key_model_bind_check+0x3e>
    {
        status = M_ERR_INVALID_BINDING;
   12c1a:	208c      	movs	r0, #140	; 0x8c
   12c1c:	0140      	lsls	r0, r0, #5
   12c1e:	e002      	b.n	12c26 <m_tb_key_model_bind_check+0x3e>
   12c20:	3301      	adds	r3, #1
   12c22:	b25b      	sxtb	r3, r3
   12c24:	e7e9      	b.n	12bfa <m_tb_key_model_bind_check+0x12>
    }

    return (status);
}
   12c26:	bd70      	pop	{r4, r5, r6, pc}
   12c28:	100126c0 	.word	0x100126c0

00012c2c <m_tb_key_set_iv_seq>:

void m_tb_key_set_iv_seq(uint32_t iv, uint32_t seq)
{
    p_m_tb_key_env->iv = iv;
   12c2c:	4b03      	ldr	r3, [pc, #12]	; (12c3c <m_tb_key_set_iv_seq+0x10>)
   12c2e:	681b      	ldr	r3, [r3, #0]
   12c30:	001a      	movs	r2, r3
    p_m_tb_key_env->next_tx_seq = seq;
   12c32:	33b0      	adds	r3, #176	; 0xb0
    return (status);
}

void m_tb_key_set_iv_seq(uint32_t iv, uint32_t seq)
{
    p_m_tb_key_env->iv = iv;
   12c34:	32ac      	adds	r2, #172	; 0xac
   12c36:	6010      	str	r0, [r2, #0]
    p_m_tb_key_env->next_tx_seq = seq;
   12c38:	6019      	str	r1, [r3, #0]
}
   12c3a:	4770      	bx	lr
   12c3c:	100126c0 	.word	0x100126c0

00012c40 <m_tb_key_get_iv_seq>:

void m_tb_key_get_iv_seq(uint32_t *p_seq, uint32_t *p_iv)
{
    // Return stored sequence number value
    *p_seq = p_m_tb_key_env->next_tx_seq;
   12c40:	4b0a      	ldr	r3, [pc, #40]	; (12c6c <m_tb_key_get_iv_seq+0x2c>)
    p_m_tb_key_env->iv = iv;
    p_m_tb_key_env->next_tx_seq = seq;
}

void m_tb_key_get_iv_seq(uint32_t *p_seq, uint32_t *p_iv)
{
   12c42:	b510      	push	{r4, lr}
    // Return stored sequence number value
    *p_seq = p_m_tb_key_env->next_tx_seq;
   12c44:	681b      	ldr	r3, [r3, #0]
   12c46:	001a      	movs	r2, r3
   12c48:	32b0      	adds	r2, #176	; 0xb0
   12c4a:	6814      	ldr	r4, [r2, #0]
   12c4c:	6004      	str	r4, [r0, #0]

    // Increase sequence number value
    p_m_tb_key_env->next_tx_seq++;
   12c4e:	6810      	ldr	r0, [r2, #0]
   12c50:	3001      	adds	r0, #1
   12c52:	6010      	str	r0, [r2, #0]

    if (p_iv)
   12c54:	2900      	cmp	r1, #0
   12c56:	d008      	beq.n	12c6a <m_tb_key_get_iv_seq+0x2a>
    {
        *p_iv = p_m_tb_key_env->iv;
   12c58:	3a04      	subs	r2, #4
   12c5a:	6812      	ldr	r2, [r2, #0]

        // If IV Update is in progress, must transmit with IV - 1
        if (GETB(p_m_tb_key_env->status, M_TB_KEY_STATUS_IV_UPDATE))
   12c5c:	33b9      	adds	r3, #185	; 0xb9
    // Increase sequence number value
    p_m_tb_key_env->next_tx_seq++;

    if (p_iv)
    {
        *p_iv = p_m_tb_key_env->iv;
   12c5e:	600a      	str	r2, [r1, #0]

        // If IV Update is in progress, must transmit with IV - 1
        if (GETB(p_m_tb_key_env->status, M_TB_KEY_STATUS_IV_UPDATE))
   12c60:	781b      	ldrb	r3, [r3, #0]
   12c62:	07db      	lsls	r3, r3, #31
   12c64:	d501      	bpl.n	12c6a <m_tb_key_get_iv_seq+0x2a>
        {
            (*p_iv)--;
   12c66:	3a01      	subs	r2, #1
   12c68:	600a      	str	r2, [r1, #0]
        }
    }
}
   12c6a:	bd10      	pop	{r4, pc}
   12c6c:	100126c0 	.word	0x100126c0

00012c70 <m_tb_key_get_iv_rx>:
{
    // IV to be used for decryption
    uint32_t iv;

    // Check if IVI and current IV have same parity
    if ((uint32_t)ivi == (p_m_tb_key_env->iv & 0x1))
   12c70:	4b05      	ldr	r3, [pc, #20]	; (12c88 <m_tb_key_get_iv_rx+0x18>)
        }
    }
}

uint32_t m_tb_key_get_iv_rx(uint8_t ivi)
{
   12c72:	0002      	movs	r2, r0
    // IV to be used for decryption
    uint32_t iv;

    // Check if IVI and current IV have same parity
    if ((uint32_t)ivi == (p_m_tb_key_env->iv & 0x1))
   12c74:	681b      	ldr	r3, [r3, #0]
   12c76:	33ac      	adds	r3, #172	; 0xac
   12c78:	6818      	ldr	r0, [r3, #0]
   12c7a:	2301      	movs	r3, #1
   12c7c:	4003      	ands	r3, r0
    {
        iv = p_m_tb_key_env->iv;
    }
    else
    {
        iv = p_m_tb_key_env->iv - 1;
   12c7e:	1ad3      	subs	r3, r2, r3
   12c80:	1e5a      	subs	r2, r3, #1
   12c82:	4193      	sbcs	r3, r2
   12c84:	1ac0      	subs	r0, r0, r3
    }

    return (iv);
}
   12c86:	4770      	bx	lr
   12c88:	100126c0 	.word	0x100126c0

00012c8c <m_tb_key_get_nb_net_keys>:

uint8_t m_tb_key_get_nb_net_keys(void)
{
    return (p_m_tb_key_env->nb_net_keys);
   12c8c:	4b02      	ldr	r3, [pc, #8]	; (12c98 <m_tb_key_get_nb_net_keys+0xc>)
   12c8e:	681b      	ldr	r3, [r3, #0]
   12c90:	33b8      	adds	r3, #184	; 0xb8
   12c92:	7818      	ldrb	r0, [r3, #0]
}
   12c94:	4770      	bx	lr
   12c96:	46c0      	nop			; (mov r8, r8)
   12c98:	100126c0 	.word	0x100126c0

00012c9c <m_tb_key_get_nb_app_keys>:

uint8_t m_tb_key_get_nb_app_keys(m_lid_t net_key_lid)
{
    // Get network key information
    m_tb_key_net_t *p_key_net = (m_tb_key_net_t *)(p_m_tb_key_env->p_keys[net_key_lid]);
   12c9c:	4b03      	ldr	r3, [pc, #12]	; (12cac <m_tb_key_get_nb_app_keys+0x10>)
   12c9e:	0080      	lsls	r0, r0, #2
   12ca0:	681b      	ldr	r3, [r3, #0]

    // Return number of application keys bound with the network key
    return (p_key_net->nb_app_keys);
   12ca2:	58c3      	ldr	r3, [r0, r3]
   12ca4:	334e      	adds	r3, #78	; 0x4e
   12ca6:	7818      	ldrb	r0, [r3, #0]
}
   12ca8:	4770      	bx	lr
   12caa:	46c0      	nop			; (mov r8, r8)
   12cac:	100126c0 	.word	0x100126c0

00012cb0 <m_tb_key_get_model_appkey_ids>:

void m_tb_key_get_model_appkey_ids(m_lid_t model_lid, uint8_t exp_nb_ids, uint8_t *p_appkey_ids, bool pack)
{
   12cb0:	b5f0      	push	{r4, r5, r6, r7, lr}
   12cb2:	b085      	sub	sp, #20
   12cb4:	9000      	str	r0, [sp, #0]
    uint32_t wr_val = 0;
    // Number of found application keys
    uint8_t nb_ids = 0;

    // Go through application key/model mapping table
    for (cnt = 0; (cnt < p_m_tb_key_env->nb_mids) && (nb_ids < exp_nb_ids); cnt++)
   12cb6:	4822      	ldr	r0, [pc, #136]	; (12d40 <m_tb_key_get_model_appkey_ids+0x90>)
    // Return number of application keys bound with the network key
    return (p_key_net->nb_app_keys);
}

void m_tb_key_get_model_appkey_ids(m_lid_t model_lid, uint8_t exp_nb_ids, uint8_t *p_appkey_ids, bool pack)
{
   12cb8:	9301      	str	r3, [sp, #4]
    uint32_t wr_val = 0;
    // Number of found application keys
    uint8_t nb_ids = 0;

    // Go through application key/model mapping table
    for (cnt = 0; (cnt < p_m_tb_key_env->nb_mids) && (nb_ids < exp_nb_ids); cnt++)
   12cba:	6807      	ldr	r7, [r0, #0]
    // Counters
    uint8_t cnt;
    // Value to write
    uint32_t wr_val = 0;
    // Number of found application keys
    uint8_t nb_ids = 0;
   12cbc:	2000      	movs	r0, #0

    // Go through application key/model mapping table
    for (cnt = 0; (cnt < p_m_tb_key_env->nb_mids) && (nb_ids < exp_nb_ids); cnt++)
   12cbe:	003e      	movs	r6, r7
void m_tb_key_get_model_appkey_ids(m_lid_t model_lid, uint8_t exp_nb_ids, uint8_t *p_appkey_ids, bool pack)
{
    // Counters
    uint8_t cnt;
    // Value to write
    uint32_t wr_val = 0;
   12cc0:	0004      	movs	r4, r0
    // Number of found application keys
    uint8_t nb_ids = 0;

    // Go through application key/model mapping table
    for (cnt = 0; (cnt < p_m_tb_key_env->nb_mids) && (nb_ids < exp_nb_ids); cnt++)
   12cc2:	0005      	movs	r5, r0
   12cc4:	36b7      	adds	r6, #183	; 0xb7
   12cc6:	9602      	str	r6, [sp, #8]
            }
            else
            {
                wr_val = (uint32_t)(p_key_app->app_key_id);

                if (nb_ids == (exp_nb_ids - 1))
   12cc8:	1e4e      	subs	r6, r1, #1
   12cca:	9603      	str	r6, [sp, #12]
    uint32_t wr_val = 0;
    // Number of found application keys
    uint8_t nb_ids = 0;

    // Go through application key/model mapping table
    for (cnt = 0; (cnt < p_m_tb_key_env->nb_mids) && (nb_ids < exp_nb_ids); cnt++)
   12ccc:	9b02      	ldr	r3, [sp, #8]
   12cce:	781e      	ldrb	r6, [r3, #0]
   12cd0:	42ae      	cmp	r6, r5
   12cd2:	d933      	bls.n	12d3c <m_tb_key_get_model_appkey_ids+0x8c>
   12cd4:	4288      	cmp	r0, r1
   12cd6:	d231      	bcs.n	12d3c <m_tb_key_get_model_appkey_ids+0x8c>
        m_tb_key_bound_app_model_t *p_bind_info = &p_m_tb_key_env->map_ak_mid[cnt];
        // Application key information
        m_tb_key_app_t *p_key_app;

        // Check model local identifier
        if ((model_lid != p_bind_info->model_lid) || (p_bind_info->app_key_lid == M_TB_KEY_DEVICE_LID))
   12cd8:	2385      	movs	r3, #133	; 0x85
   12cda:	469c      	mov	ip, r3
   12cdc:	006e      	lsls	r6, r5, #1
   12cde:	19be      	adds	r6, r7, r6
   12ce0:	44b4      	add	ip, r6
   12ce2:	4663      	mov	r3, ip
   12ce4:	781b      	ldrb	r3, [r3, #0]
   12ce6:	469c      	mov	ip, r3
   12ce8:	9b00      	ldr	r3, [sp, #0]
   12cea:	459c      	cmp	ip, r3
   12cec:	d123      	bne.n	12d36 <m_tb_key_get_model_appkey_ids+0x86>
   12cee:	3684      	adds	r6, #132	; 0x84
   12cf0:	7836      	ldrb	r6, [r6, #0]
   12cf2:	2e00      	cmp	r6, #0
   12cf4:	d01f      	beq.n	12d36 <m_tb_key_get_model_appkey_ids+0x86>
        {
            continue;
        }

        // Get application key information
        p_key_app = (m_tb_key_app_t *)(p_m_tb_key_env->p_keys[p_bind_info->app_key_lid]);
   12cf6:	00b6      	lsls	r6, r6, #2
   12cf8:	59f6      	ldr	r6, [r6, r7]

        if (pack)
   12cfa:	9b01      	ldr	r3, [sp, #4]
   12cfc:	8ab6      	ldrh	r6, [r6, #20]
   12cfe:	2b00      	cmp	r3, #0
   12d00:	d013      	beq.n	12d2a <m_tb_key_get_model_appkey_ids+0x7a>
        {
            if (nb_ids & 0x1)
   12d02:	2301      	movs	r3, #1
   12d04:	4218      	tst	r0, r3
   12d06:	d008      	beq.n	12d1a <m_tb_key_get_model_appkey_ids+0x6a>
            {
                wr_val |= ((uint32_t)(p_key_app->app_key_id) << 12);
   12d08:	0336      	lsls	r6, r6, #12
   12d0a:	4334      	orrs	r4, r6
__INLINE_S__ void co_write24p(void const *ptr24, uint32_t value)
{
    uint8_t *ptr=(uint8_t*)ptr24;

    *ptr++ = (uint8_t)(value&0xff);
    *ptr++ = (uint8_t)((value&0xff00)>>8);
   12d0c:	0a26      	lsrs	r6, r4, #8
   12d0e:	7056      	strb	r6, [r2, #1]
    *ptr++ = (uint8_t)((value&0xff0000)>>16);
   12d10:	0c26      	lsrs	r6, r4, #16
 */
__INLINE_S__ void co_write24p(void const *ptr24, uint32_t value)
{
    uint8_t *ptr=(uint8_t*)ptr24;

    *ptr++ = (uint8_t)(value&0xff);
   12d12:	7014      	strb	r4, [r2, #0]
    *ptr++ = (uint8_t)((value&0xff00)>>8);
    *ptr++ = (uint8_t)((value&0xff0000)>>16);
   12d14:	7096      	strb	r6, [r2, #2]

                // Write the last two indexes
                co_write24p(p_appkey_ids, wr_val);

                // Move pointer
                p_appkey_ids += 3;
   12d16:	3203      	adds	r2, #3
   12d18:	e00b      	b.n	12d32 <m_tb_key_get_model_appkey_ids+0x82>
            }
            else
            {
                wr_val = (uint32_t)(p_key_app->app_key_id);

                if (nb_ids == (exp_nb_ids - 1))
   12d1a:	9b03      	ldr	r3, [sp, #12]
                // Move pointer
                p_appkey_ids += 3;
            }
            else
            {
                wr_val = (uint32_t)(p_key_app->app_key_id);
   12d1c:	0034      	movs	r4, r6

                if (nb_ids == (exp_nb_ids - 1))
   12d1e:	4298      	cmp	r0, r3
   12d20:	d107      	bne.n	12d32 <m_tb_key_get_model_appkey_ids+0x82>
 */
__INLINE_S__ void co_write16p(void const *ptr16, uint16_t value)
{
    uint8_t *ptr=(uint8_t*)ptr16;

    *ptr++ = value&0xff;
   12d22:	7016      	strb	r6, [r2, #0]
    *ptr = (value&0xff00)>>8;
   12d24:	0a36      	lsrs	r6, r6, #8
   12d26:	7056      	strb	r6, [r2, #1]
   12d28:	e003      	b.n	12d32 <m_tb_key_get_model_appkey_ids+0x82>
 */
__INLINE_S__ void co_write16p(void const *ptr16, uint16_t value)
{
    uint8_t *ptr=(uint8_t*)ptr16;

    *ptr++ = value&0xff;
   12d2a:	7016      	strb	r6, [r2, #0]
    *ptr = (value&0xff00)>>8;
   12d2c:	0a36      	lsrs	r6, r6, #8
   12d2e:	7056      	strb	r6, [r2, #1]
        else
        {
            // Write the index
            co_write16p(p_appkey_ids, p_key_app->app_key_id);
            // Move pointer
            p_appkey_ids += 2;
   12d30:	3202      	adds	r2, #2
        }

        nb_ids++;
   12d32:	3001      	adds	r0, #1
   12d34:	b2c0      	uxtb	r0, r0
    uint32_t wr_val = 0;
    // Number of found application keys
    uint8_t nb_ids = 0;

    // Go through application key/model mapping table
    for (cnt = 0; (cnt < p_m_tb_key_env->nb_mids) && (nb_ids < exp_nb_ids); cnt++)
   12d36:	3501      	adds	r5, #1
   12d38:	b2ed      	uxtb	r5, r5
   12d3a:	e7c7      	b.n	12ccc <m_tb_key_get_model_appkey_ids+0x1c>
            p_appkey_ids += 2;
        }

        nb_ids++;
    }
}
   12d3c:	b005      	add	sp, #20
   12d3e:	bdf0      	pop	{r4, r5, r6, r7, pc}
   12d40:	100126c0 	.word	0x100126c0

00012d44 <m_tb_key_get_netkey_id>:

uint16_t m_tb_key_get_netkey_id(m_lid_t net_key_lid)
{
    // Get network key information
    m_tb_key_net_t *p_key_net = (m_tb_key_net_t *)(p_m_tb_key_env->p_keys[net_key_lid]);
   12d44:	4b03      	ldr	r3, [pc, #12]	; (12d54 <m_tb_key_get_netkey_id+0x10>)
   12d46:	0080      	lsls	r0, r0, #2
   12d48:	681b      	ldr	r3, [r3, #0]

    // Return NetKey Index
    return (p_key_net->net_key_id);
   12d4a:	58c3      	ldr	r3, [r0, r3]
   12d4c:	3306      	adds	r3, #6
   12d4e:	8fd8      	ldrh	r0, [r3, #62]	; 0x3e
}
   12d50:	4770      	bx	lr
   12d52:	46c0      	nop			; (mov r8, r8)
   12d54:	100126c0 	.word	0x100126c0

00012d58 <m_tb_key_get_node_identity>:
        // Return not supported status
        state = M_CONF_NODE_ID_NOT_SUPPORTED;
    }

    return (state);
}
   12d58:	2002      	movs	r0, #2
   12d5a:	4770      	bx	lr

00012d5c <m_tb_key_get_net_from_net_id>:
    return (status);
}
#endif //(BLE_MESH_GATT_PROXY)

uint16_t m_tb_key_get_net_from_net_id(uint8_t *p_net_id, m_lid_t *p_net_key_lid)
{
   12d5c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   12d5e:	0007      	movs	r7, r0
    m_lid_t cursor;

    for (cursor = M_TB_KEY_NET_START_LID; cursor <= M_TB_KEY_NET_END_LID; cursor++)
    {
        // Search for a key that have provided network ID in the list of used network keys
        p_key = (m_tb_key_net_t *)p_m_tb_key_env->p_keys[cursor];
   12d60:	2401      	movs	r4, #1
   12d62:	4b18      	ldr	r3, [pc, #96]	; (12dc4 <m_tb_key_get_net_from_net_id+0x68>)
    return (status);
}
#endif //(BLE_MESH_GATT_PROXY)

uint16_t m_tb_key_get_net_from_net_id(uint8_t *p_net_id, m_lid_t *p_net_key_lid)
{
   12d64:	9100      	str	r1, [sp, #0]
    m_lid_t cursor;

    for (cursor = M_TB_KEY_NET_START_LID; cursor <= M_TB_KEY_NET_END_LID; cursor++)
    {
        // Search for a key that have provided network ID in the list of used network keys
        p_key = (m_tb_key_net_t *)p_m_tb_key_env->p_keys[cursor];
   12d66:	681e      	ldr	r6, [r3, #0]
   12d68:	00a3      	lsls	r3, r4, #2
   12d6a:	58f0      	ldr	r0, [r6, r3]
   12d6c:	b2e5      	uxtb	r5, r4
   12d6e:	9301      	str	r3, [sp, #4]

        if ((p_key != NULL)
   12d70:	2800      	cmp	r0, #0
   12d72:	d006      	beq.n	12d82 <m_tb_key_get_net_from_net_id+0x26>
                && (memcmp(&p_key->net_id[0], p_net_id, M_NET_ID_LEN) == 0))
   12d74:	3046      	adds	r0, #70	; 0x46
   12d76:	2208      	movs	r2, #8
   12d78:	0039      	movs	r1, r7
   12d7a:	f002 fe01 	bl	15980 <memcmp>
   12d7e:	2800      	cmp	r0, #0
   12d80:	d016      	beq.n	12db0 <m_tb_key_get_net_from_net_id+0x54>
        {
            // Key has been found
            break;
        }

        if (p_m_tb_key_env->p_up != NULL)
   12d82:	6b73      	ldr	r3, [r6, #52]	; 0x34
   12d84:	2b00      	cmp	r3, #0
   12d86:	d00f      	beq.n	12da8 <m_tb_key_get_net_from_net_id+0x4c>
        {
            // Search for a key that have provided network ID in the list of new keys
            p_key = (m_tb_key_net_t *)p_m_tb_key_env->p_up->p_keys[cursor];
   12d88:	9a01      	ldr	r2, [sp, #4]
   12d8a:	5898      	ldr	r0, [r3, r2]

            if ((p_key != NULL)
   12d8c:	2800      	cmp	r0, #0
   12d8e:	d00b      	beq.n	12da8 <m_tb_key_get_net_from_net_id+0x4c>
                    && (memcmp(&p_key->net_id[0], p_net_id, M_NET_ID_LEN) == 0))
   12d90:	3046      	adds	r0, #70	; 0x46
   12d92:	2208      	movs	r2, #8
   12d94:	0039      	movs	r1, r7
   12d96:	f002 fdf3 	bl	15980 <memcmp>
   12d9a:	2800      	cmp	r0, #0
   12d9c:	d104      	bne.n	12da8 <m_tb_key_get_net_from_net_id+0x4c>
            {
                // Key has been found
                SETB(cursor, M_TB_KEY_NEW, 1);
   12d9e:	2380      	movs	r3, #128	; 0x80
   12da0:	425b      	negs	r3, r3
   12da2:	431d      	orrs	r5, r3
   12da4:	b2ed      	uxtb	r5, r5
                break;
   12da6:	e003      	b.n	12db0 <m_tb_key_get_net_from_net_id+0x54>
   12da8:	3401      	adds	r4, #1
    // Found key
    m_tb_key_net_t *p_key = NULL;
    // Counter
    m_lid_t cursor;

    for (cursor = M_TB_KEY_NET_START_LID; cursor <= M_TB_KEY_NET_END_LID; cursor++)
   12daa:	2c03      	cmp	r4, #3
   12dac:	d1dc      	bne.n	12d68 <m_tb_key_get_net_from_net_id+0xc>
   12dae:	0025      	movs	r5, r4
            }
        }
    }

    // Check if required key has been found
    if (GETF(cursor, M_TB_KEY_LID) <= M_TB_KEY_NET_END_LID)
   12db0:	237f      	movs	r3, #127	; 0x7f
   12db2:	402b      	ands	r3, r5
   12db4:	2b02      	cmp	r3, #2
   12db6:	d803      	bhi.n	12dc0 <m_tb_key_get_net_from_net_id+0x64>
    {
        // Return the found local index
        *p_net_key_lid = cursor;
   12db8:	9b00      	ldr	r3, [sp, #0]

        // Key has been found
        status = M_ERR_NO_ERROR;
   12dba:	2000      	movs	r0, #0

    // Check if required key has been found
    if (GETF(cursor, M_TB_KEY_LID) <= M_TB_KEY_NET_END_LID)
    {
        // Return the found local index
        *p_net_key_lid = cursor;
   12dbc:	701d      	strb	r5, [r3, #0]
   12dbe:	e000      	b.n	12dc2 <m_tb_key_get_net_from_net_id+0x66>
#endif //(BLE_MESH_GATT_PROXY)

uint16_t m_tb_key_get_net_from_net_id(uint8_t *p_net_id, m_lid_t *p_net_key_lid)
{
    // Returned status
    uint16_t status = M_ERR_NOT_FOUND;
   12dc0:	4801      	ldr	r0, [pc, #4]	; (12dc8 <m_tb_key_get_net_from_net_id+0x6c>)
        // Key has been found
        status = M_ERR_NO_ERROR;
    }

    return (status);
}
   12dc2:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
   12dc4:	100126c0 	.word	0x100126c0
   12dc8:	00000682 	.word	0x00000682

00012dcc <m_tb_key_get_phase>:
uint8_t m_tb_key_get_phase(m_lid_t net_key_lid)
{
    // Base local index
    m_lid_t base_lid = GETF(net_key_lid, M_TB_KEY_LID);
    // Get network key information
    m_tb_key_net_t *p_key = (m_tb_key_net_t *)(p_m_tb_key_env->p_keys[base_lid]);
   12dcc:	4b03      	ldr	r3, [pc, #12]	; (12ddc <m_tb_key_get_phase+0x10>)
   12dce:	681a      	ldr	r2, [r3, #0]
   12dd0:	237f      	movs	r3, #127	; 0x7f
   12dd2:	4018      	ands	r0, r3
   12dd4:	0080      	lsls	r0, r0, #2

    // Return phase value
    return (p_key->state);
   12dd6:	5883      	ldr	r3, [r0, r2]
   12dd8:	7858      	ldrb	r0, [r3, #1]
}
   12dda:	4770      	bx	lr
   12ddc:	100126c0 	.word	0x100126c0

00012de0 <m_tb_key_secure_bcn_rx_ind>:

void m_tb_key_secure_bcn_rx_ind(m_lid_t net_key_lid, uint8_t flags, uint32_t iv)
{
   12de0:	b5f0      	push	{r4, r5, r6, r7, lr}
	m_printf(L_TB, "net_key_lid[%d] flags[%d] iv[%d]", net_key_lid, flags, iv);
   12de2:	000b      	movs	r3, r1
    // Return phase value
    return (p_key->state);
}

void m_tb_key_secure_bcn_rx_ind(m_lid_t net_key_lid, uint8_t flags, uint32_t iv)
{
   12de4:	000e      	movs	r6, r1
	m_printf(L_TB, "net_key_lid[%d] flags[%d] iv[%d]", net_key_lid, flags, iv);
   12de6:	493e      	ldr	r1, [pc, #248]	; (12ee0 <m_tb_key_secure_bcn_rx_ind+0x100>)
    // Return phase value
    return (p_key->state);
}

void m_tb_key_secure_bcn_rx_ind(m_lid_t net_key_lid, uint8_t flags, uint32_t iv)
{
   12de8:	b087      	sub	sp, #28
   12dea:	0005      	movs	r5, r0
	m_printf(L_TB, "net_key_lid[%d] flags[%d] iv[%d]", net_key_lid, flags, iv);
   12dec:	9200      	str	r2, [sp, #0]
    // Return phase value
    return (p_key->state);
}

void m_tb_key_secure_bcn_rx_ind(m_lid_t net_key_lid, uint8_t flags, uint32_t iv)
{
   12dee:	0014      	movs	r4, r2
	m_printf(L_TB, "net_key_lid[%d] flags[%d] iv[%d]", net_key_lid, flags, iv);
   12df0:	3122      	adds	r1, #34	; 0x22
   12df2:	0002      	movs	r2, r0
   12df4:	2002      	movs	r0, #2
   12df6:	f7f1 fdfb 	bl	49f0 <m_printf>
    // Base local index
    m_lid_t base_lid = GETF(net_key_lid, M_TB_KEY_LID);
    // Get network key information
    m_tb_key_net_t *p_key = (m_tb_key_net_t *)(p_m_tb_key_env->p_keys[base_lid]);
   12dfa:	227f      	movs	r2, #127	; 0x7f
   12dfc:	4f39      	ldr	r7, [pc, #228]	; (12ee4 <m_tb_key_secure_bcn_rx_ind+0x104>)
   12dfe:	402a      	ands	r2, r5
   12e00:	683b      	ldr	r3, [r7, #0]
   12e02:	0092      	lsls	r2, r2, #2
   12e04:	58d2      	ldr	r2, [r2, r3]
   12e06:	9202      	str	r2, [sp, #8]

    // Do not consider beacon received on secondary if part of primary
    if (!(GETB(p_m_tb_key_env->status, M_TB_KEY_STATUS_PRIM)
   12e08:	001a      	movs	r2, r3
   12e0a:	32b9      	adds	r2, #185	; 0xb9
   12e0c:	7810      	ldrb	r0, [r2, #0]
   12e0e:	9703      	str	r7, [sp, #12]
   12e10:	0782      	lsls	r2, r0, #30
   12e12:	d504      	bpl.n	12e1e <m_tb_key_secure_bcn_rx_ind+0x3e>
            && (p_key->net_key_id != M_TB_KEY_PRIM_NETKEY_ID)))
   12e14:	9a02      	ldr	r2, [sp, #8]
   12e16:	3206      	adds	r2, #6
    m_lid_t base_lid = GETF(net_key_lid, M_TB_KEY_LID);
    // Get network key information
    m_tb_key_net_t *p_key = (m_tb_key_net_t *)(p_m_tb_key_env->p_keys[base_lid]);

    // Do not consider beacon received on secondary if part of primary
    if (!(GETB(p_m_tb_key_env->status, M_TB_KEY_STATUS_PRIM)
   12e18:	8fd2      	ldrh	r2, [r2, #62]	; 0x3e
   12e1a:	2a00      	cmp	r2, #0
   12e1c:	d15d      	bne.n	12eda <m_tb_key_secure_bcn_rx_ind+0xfa>
__STATIC bool m_tb_key_check_iv(uint32_t iv_rx, uint8_t flags)
{
    // Boolean indicating if secure network beacon must be ignored, false by default
    bool ignore = false;
    // Current IV
    uint32_t iv_cur = p_m_tb_key_env->iv;
   12e1e:	0019      	movs	r1, r3

    // Check if we are in Normal Operation or in IV Update in Progress operation
    if (GETB(p_m_tb_key_env->status, M_TB_KEY_STATUS_IV_UPDATE))
   12e20:	2701      	movs	r7, #1
__STATIC bool m_tb_key_check_iv(uint32_t iv_rx, uint8_t flags)
{
    // Boolean indicating if secure network beacon must be ignored, false by default
    bool ignore = false;
    // Current IV
    uint32_t iv_cur = p_m_tb_key_env->iv;
   12e22:	31ac      	adds	r1, #172	; 0xac
   12e24:	680a      	ldr	r2, [r1, #0]

    // Check if we are in Normal Operation or in IV Update in Progress operation
    if (GETB(p_m_tb_key_env->status, M_TB_KEY_STATUS_IV_UPDATE))
   12e26:	4238      	tst	r0, r7
   12e28:	d01e      	beq.n	12e68 <m_tb_key_secure_bcn_rx_ind+0x88>
    {
        // IV Update in Progress operation

        // Check received IV Update Flag
        if (!GETB(flags, M_TB_KEY_SECURE_BCN_IV))
   12e2a:	19ff      	adds	r7, r7, r7
   12e2c:	4037      	ands	r7, r6
   12e2e:	d13c      	bne.n	12eaa <m_tb_key_secure_bcn_rx_ind+0xca>
        {
            // Check that received IV is valid
            if (iv_rx == iv_cur)
   12e30:	4294      	cmp	r4, r2
   12e32:	d13a      	bne.n	12eaa <m_tb_key_secure_bcn_rx_ind+0xca>
                // Current time
                uint32_t cur_time_ms;
                uint16_t cur_nb_wrap;

                // Get current time
                m_tb_timer_get_cur_time(&cur_time_ms, &cur_nb_wrap);
   12e34:	240a      	movs	r4, #10
   12e36:	ab02      	add	r3, sp, #8
   12e38:	18e4      	adds	r4, r4, r3
   12e3a:	0021      	movs	r1, r4
   12e3c:	a805      	add	r0, sp, #20
   12e3e:	f002 fadd 	bl	153fc <m_tb_timer_get_cur_time>

                // Go back to Normal operation
                SETB(p_m_tb_key_env->status, M_TB_KEY_STATUS_IV_UPDATE, 0);
   12e42:	4b28      	ldr	r3, [pc, #160]	; (12ee4 <m_tb_key_secure_bcn_rx_ind+0x104>)
   12e44:	2001      	movs	r0, #1
   12e46:	681b      	ldr	r3, [r3, #0]
   12e48:	0019      	movs	r1, r3
   12e4a:	31b9      	adds	r1, #185	; 0xb9
   12e4c:	780a      	ldrb	r2, [r1, #0]
                // Reset the sequence number
                p_m_tb_key_env->next_tx_seq = 0;
   12e4e:	33b0      	adds	r3, #176	; 0xb0

                // Get current time
                m_tb_timer_get_cur_time(&cur_time_ms, &cur_nb_wrap);

                // Go back to Normal operation
                SETB(p_m_tb_key_env->status, M_TB_KEY_STATUS_IV_UPDATE, 0);
   12e50:	4382      	bics	r2, r0
   12e52:	700a      	strb	r2, [r1, #0]
                // Reset the sequence number
                p_m_tb_key_env->next_tx_seq = 0;

                // Inform the state manager that IV update procedure is finished
                m_tb_state_iv_update_ind(cur_time_ms, cur_nb_wrap);
   12e54:	9805      	ldr	r0, [sp, #20]
   12e56:	8821      	ldrh	r1, [r4, #0]
                m_tb_timer_get_cur_time(&cur_time_ms, &cur_nb_wrap);

                // Go back to Normal operation
                SETB(p_m_tb_key_env->status, M_TB_KEY_STATUS_IV_UPDATE, 0);
                // Reset the sequence number
                p_m_tb_key_env->next_tx_seq = 0;
   12e58:	601f      	str	r7, [r3, #0]

                // Inform the state manager that IV update procedure is finished
                m_tb_state_iv_update_ind(cur_time_ms, cur_nb_wrap);
   12e5a:	f001 fb73 	bl	14544 <m_tb_state_iv_update_ind>

                // Inform the storage manager
                m_tb_store_update_ind(M_TB_STORE_UPD_TYPE_STATE, M_TB_STORE_TYPE_IV_SEQ);
   12e5e:	2108      	movs	r1, #8
   12e60:	2007      	movs	r0, #7
   12e62:	f001 fed9 	bl	14c18 <m_tb_store_update_ind>
   12e66:	e020      	b.n	12eaa <m_tb_key_secure_bcn_rx_ind+0xca>
            /*
             * If a node in Normal Operation receives a Secure Network beacon with an IV index
             * less than the last known IV Index or greater than the last known IV Index + 42,
             * the Secure Network beacon shall be ignored.
             */
            if ((iv_rx < iv_cur) || (iv_rx > (iv_cur + 42)))
   12e68:	4294      	cmp	r4, r2
   12e6a:	d336      	bcc.n	12eda <m_tb_key_secure_bcn_rx_ind+0xfa>
   12e6c:	0010      	movs	r0, r2
   12e6e:	302a      	adds	r0, #42	; 0x2a
   12e70:	4284      	cmp	r4, r0
   12e72:	d832      	bhi.n	12eda <m_tb_key_secure_bcn_rx_ind+0xfa>
                ignore = true;
                break;
            }

            // Check if IV value has changed
            if (iv_rx == iv_cur)
   12e74:	4294      	cmp	r4, r2
   12e76:	d018      	beq.n	12eaa <m_tb_key_secure_bcn_rx_ind+0xca>
            {
                break;
            }

            if (GETB(flags, M_TB_KEY_SECURE_BCN_IV))
   12e78:	2202      	movs	r2, #2
   12e7a:	4032      	ands	r2, r6
   12e7c:	d00e      	beq.n	12e9c <m_tb_key_secure_bcn_rx_ind+0xbc>
            {
                // Check if switch to IV Update in Progress state is authorized
                if (!m_tb_state_is_iv_update_auth())
   12e7e:	f001 fb3f 	bl	14500 <m_tb_state_is_iv_update_auth>
   12e82:	2800      	cmp	r0, #0
   12e84:	d011      	beq.n	12eaa <m_tb_key_secure_bcn_rx_ind+0xca>
                {
                    break;
                }

                // Update IV index
                p_m_tb_key_env->iv = iv_rx;
   12e86:	9b03      	ldr	r3, [sp, #12]

                // And start IV Update in Progress operation
                SETB(p_m_tb_key_env->status, M_TB_KEY_STATUS_IV_UPDATE, 1);
   12e88:	2101      	movs	r1, #1
                {
                    break;
                }

                // Update IV index
                p_m_tb_key_env->iv = iv_rx;
   12e8a:	681b      	ldr	r3, [r3, #0]
   12e8c:	001a      	movs	r2, r3
   12e8e:	32ac      	adds	r2, #172	; 0xac
   12e90:	6014      	str	r4, [r2, #0]

                // And start IV Update in Progress operation
                SETB(p_m_tb_key_env->status, M_TB_KEY_STATUS_IV_UPDATE, 1);
   12e92:	33b9      	adds	r3, #185	; 0xb9
   12e94:	781a      	ldrb	r2, [r3, #0]
   12e96:	430a      	orrs	r2, r1
   12e98:	701a      	strb	r2, [r3, #0]
   12e9a:	e002      	b.n	12ea2 <m_tb_key_secure_bcn_rx_ind+0xc2>
                 * Network beacon.
                 */

                // Update IV index
                p_m_tb_key_env->iv = iv_rx;
                p_m_tb_key_env->next_tx_seq = 0;
   12e9c:	33b0      	adds	r3, #176	; 0xb0
                 * or it may initiate an IV Index Recovery procedure, or it may ignore the Secure
                 * Network beacon.
                 */

                // Update IV index
                p_m_tb_key_env->iv = iv_rx;
   12e9e:	600c      	str	r4, [r1, #0]
                p_m_tb_key_env->next_tx_seq = 0;
   12ea0:	601a      	str	r2, [r3, #0]
            }

            // Inform the storage manager
            m_tb_store_update_ind(M_TB_STORE_UPD_TYPE_STATE, M_TB_STORE_TYPE_IV_SEQ);
   12ea2:	2108      	movs	r1, #8
   12ea4:	2007      	movs	r0, #7
   12ea6:	f001 feb7 	bl	14c18 <m_tb_store_update_ind>
    {
        // Check received IV value
        if (!m_tb_key_check_iv(iv, flags))
        {
            // Check if beacon has been encrypted using a new key
            if (GETB(net_key_lid, M_TB_KEY_NEW))
   12eaa:	b26b      	sxtb	r3, r5
   12eac:	2401      	movs	r4, #1
   12eae:	2b00      	cmp	r3, #0
   12eb0:	da0c      	bge.n	12ecc <m_tb_key_secure_bcn_rx_ind+0xec>
            {
                // Next phase depends on received key refresh flag value and current phase
                if (p_key->state == M_TB_KEY_STATE_P1)
   12eb2:	9b02      	ldr	r3, [sp, #8]
   12eb4:	785b      	ldrb	r3, [r3, #1]
   12eb6:	2b01      	cmp	r3, #1
   12eb8:	d102      	bne.n	12ec0 <m_tb_key_secure_bcn_rx_ind+0xe0>
                {
                    // We are currently in phase 1

                    // Go to phase 2 - Switch to the new key
                    m_tb_key_net_use_new(net_key_lid);
   12eba:	0028      	movs	r0, r5
   12ebc:	f7ff f924 	bl	12108 <m_tb_key_net_use_new>
                }

                if (!GETB(flags, M_TB_KEY_SECURE_BCN_KEY))
   12ec0:	4226      	tst	r6, r4
   12ec2:	d10a      	bne.n	12eda <m_tb_key_secure_bcn_rx_ind+0xfa>
                {
                    // Go to phase 3 - Remove old key
                    m_tb_key_net_revoke_old(net_key_lid);
   12ec4:	0028      	movs	r0, r5
   12ec6:	f7ff f945 	bl	12154 <m_tb_key_net_revoke_old>
   12eca:	e006      	b.n	12eda <m_tb_key_secure_bcn_rx_ind+0xfa>
                }
            }
            else if (GETB(p_key->flags, M_MSG_FLAGS_KEY_REFRESH))
   12ecc:	9a02      	ldr	r2, [sp, #8]
   12ece:	3243      	adds	r2, #67	; 0x43
   12ed0:	7813      	ldrb	r3, [r2, #0]
   12ed2:	4223      	tst	r3, r4
   12ed4:	d001      	beq.n	12eda <m_tb_key_secure_bcn_rx_ind+0xfa>
            {
                SETB(p_key->flags, M_MSG_FLAGS_KEY_REFRESH, 0);
   12ed6:	43a3      	bics	r3, r4
   12ed8:	7013      	strb	r3, [r2, #0]
            }
        }
    }
}
   12eda:	b007      	add	sp, #28
   12edc:	bdf0      	pop	{r4, r5, r6, r7, pc}
   12ede:	46c0      	nop			; (mov r8, r8)
   12ee0:	000227c4 	.word	0x000227c4
   12ee4:	100126c0 	.word	0x100126c0

00012ee8 <m_tb_key_phase_transition_ind>:
uint16_t m_tb_key_phase_transition_ind(m_lid_t net_key_lid, uint8_t transition)
{
    // Status
    uint16_t status = M_ERR_NO_ERROR;

    if ((transition == 2) || (transition == 3))
   12ee8:	1e8b      	subs	r3, r1, #2
        }
    }
}

uint16_t m_tb_key_phase_transition_ind(m_lid_t net_key_lid, uint8_t transition)
{
   12eea:	b570      	push	{r4, r5, r6, lr}
   12eec:	0005      	movs	r5, r0
    // Status
    uint16_t status = M_ERR_NO_ERROR;

    if ((transition == 2) || (transition == 3))
   12eee:	2b01      	cmp	r3, #1
   12ef0:	d822      	bhi.n	12f38 <m_tb_key_phase_transition_ind+0x50>
    {
        // Base local index
        m_lid_t base_lid = GETF(net_key_lid, M_TB_KEY_LID);
        // Get network key information
        m_tb_key_net_t *p_key = (m_tb_key_net_t *)(p_m_tb_key_env->p_keys[base_lid]);
   12ef2:	4b13      	ldr	r3, [pc, #76]	; (12f40 <m_tb_key_phase_transition_ind+0x58>)
   12ef4:	681a      	ldr	r2, [r3, #0]
   12ef6:	237f      	movs	r3, #127	; 0x7f
   12ef8:	4003      	ands	r3, r0
   12efa:	009b      	lsls	r3, r3, #2

        if (p_key->state == M_TB_KEY_STATE_P1)
   12efc:	589b      	ldr	r3, [r3, r2]
   12efe:	785b      	ldrb	r3, [r3, #1]
   12f00:	2b01      	cmp	r3, #1
   12f02:	d10c      	bne.n	12f1e <m_tb_key_phase_transition_ind+0x36>
        {
            if (transition == 2)
   12f04:	2902      	cmp	r1, #2
   12f06:	d103      	bne.n	12f10 <m_tb_key_phase_transition_ind+0x28>
            {
                // Move from phase 1 to phase 2
                m_tb_key_net_use_new(net_key_lid);
   12f08:	f7ff f8fe 	bl	12108 <m_tb_key_net_use_new>
}

uint16_t m_tb_key_phase_transition_ind(m_lid_t net_key_lid, uint8_t transition)
{
    // Status
    uint16_t status = M_ERR_NO_ERROR;
   12f0c:	2400      	movs	r4, #0
   12f0e:	e015      	b.n	12f3c <m_tb_key_phase_transition_ind+0x54>
                m_tb_key_net_use_new(net_key_lid);
            }
            else
            {
                // Move from phase 1 to phase 3
                m_tb_key_net_use_new(net_key_lid);
   12f10:	f7ff f8fa 	bl	12108 <m_tb_key_net_use_new>
                m_tb_key_net_revoke_old(net_key_lid);
   12f14:	0028      	movs	r0, r5
   12f16:	f7ff f91d 	bl	12154 <m_tb_key_net_revoke_old>
}

uint16_t m_tb_key_phase_transition_ind(m_lid_t net_key_lid, uint8_t transition)
{
    // Status
    uint16_t status = M_ERR_NO_ERROR;
   12f1a:	2400      	movs	r4, #0
   12f1c:	e00e      	b.n	12f3c <m_tb_key_phase_transition_ind+0x54>
   12f1e:	2400      	movs	r4, #0
                // Move from phase 1 to phase 3
                m_tb_key_net_use_new(net_key_lid);
                m_tb_key_net_revoke_old(net_key_lid);
            }
        }
        else if (p_key->state == M_TB_KEY_STATE_P2)
   12f20:	2b02      	cmp	r3, #2
   12f22:	d104      	bne.n	12f2e <m_tb_key_phase_transition_ind+0x46>
        {
            if (transition == 3)
   12f24:	2903      	cmp	r1, #3
   12f26:	d109      	bne.n	12f3c <m_tb_key_phase_transition_ind+0x54>
            {
                // Move from phase 2 to phase 3
                m_tb_key_net_revoke_old(net_key_lid);
   12f28:	f7ff f914 	bl	12154 <m_tb_key_net_revoke_old>
   12f2c:	e006      	b.n	12f3c <m_tb_key_phase_transition_ind+0x54>
            }
            // else state remains the same
        }
        else
        {
            if (transition != 3)
   12f2e:	2903      	cmp	r1, #3
   12f30:	d004      	beq.n	12f3c <m_tb_key_phase_transition_ind+0x54>
            {
                status = M_ERR_INVALID_PARAM;
   12f32:	3483      	adds	r4, #131	; 0x83
   12f34:	34ff      	adds	r4, #255	; 0xff
   12f36:	e001      	b.n	12f3c <m_tb_key_phase_transition_ind+0x54>
   12f38:	24c1      	movs	r4, #193	; 0xc1
   12f3a:	0064      	lsls	r4, r4, #1
    {
        status = M_ERR_INVALID_PARAM;
    }

    return (status);
}
   12f3c:	0020      	movs	r0, r4
   12f3e:	bd70      	pop	{r4, r5, r6, pc}
   12f40:	100126c0 	.word	0x100126c0

00012f44 <m_tb_key_get_net_info>:

void m_tb_key_get_net_info(uint8_t net_key_lid, uint32_t *p_iv, uint8_t **p_net_id, uint8_t *p_flags)
{
   12f44:	b5f0      	push	{r4, r5, r6, r7, lr}
    // Base local index
    m_lid_t base_lid = GETF(net_key_lid, M_TB_KEY_LID);
    // Get network key information
    m_tb_key_net_t *p_key = (m_tb_key_net_t *)(p_m_tb_key_env->p_keys[base_lid]);
   12f46:	4c16      	ldr	r4, [pc, #88]	; (12fa0 <m_tb_key_get_net_info+0x5c>)
   12f48:	6826      	ldr	r6, [r4, #0]
   12f4a:	247f      	movs	r4, #127	; 0x7f

    // Provide request information
    *p_iv = p_m_tb_key_env->iv;
   12f4c:	0035      	movs	r5, r6
   12f4e:	35ac      	adds	r5, #172	; 0xac
   12f50:	682d      	ldr	r5, [r5, #0]
void m_tb_key_get_net_info(uint8_t net_key_lid, uint32_t *p_iv, uint8_t **p_net_id, uint8_t *p_flags)
{
    // Base local index
    m_lid_t base_lid = GETF(net_key_lid, M_TB_KEY_LID);
    // Get network key information
    m_tb_key_net_t *p_key = (m_tb_key_net_t *)(p_m_tb_key_env->p_keys[base_lid]);
   12f52:	4020      	ands	r0, r4
   12f54:	0080      	lsls	r0, r0, #2
   12f56:	5984      	ldr	r4, [r0, r6]

    // Provide request information
    *p_iv = p_m_tb_key_env->iv;
   12f58:	600d      	str	r5, [r1, #0]
    *p_flags = 0;
   12f5a:	2100      	movs	r1, #0
   12f5c:	7019      	strb	r1, [r3, #0]

    if (GETB(p_m_tb_key_env->status, M_TB_KEY_STATUS_IV_UPDATE))
   12f5e:	0031      	movs	r1, r6
   12f60:	31b9      	adds	r1, #185	; 0xb9
   12f62:	780d      	ldrb	r5, [r1, #0]
   12f64:	2101      	movs	r1, #1
   12f66:	4029      	ands	r1, r5
   12f68:	d000      	beq.n	12f6c <m_tb_key_get_net_info+0x28>
    {
        SETB(*p_flags, M_MSG_FLAGS_IV_UPDATE, 1);
   12f6a:	2102      	movs	r1, #2
   12f6c:	7019      	strb	r1, [r3, #0]
    }

    if (p_key->state == M_TB_KEY_STATE_P2)
   12f6e:	7867      	ldrb	r7, [r4, #1]
   12f70:	2501      	movs	r5, #1
   12f72:	2f02      	cmp	r7, #2
   12f74:	d106      	bne.n	12f84 <m_tb_key_get_net_info+0x40>
    {
        SETB(*p_flags, M_MSG_FLAGS_KEY_REFRESH, 1);
   12f76:	4329      	orrs	r1, r5
   12f78:	7019      	strb	r1, [r3, #0]

        // Sanity check
        ASSERT_INFO(p_m_tb_key_env->p_up && p_m_tb_key_env->p_up->p_keys[base_lid], net_key_lid, 0);
   12f7a:	6b73      	ldr	r3, [r6, #52]	; 0x34
   12f7c:	581c      	ldr	r4, [r3, r0]
   12f7e:	2c00      	cmp	r4, #0
   12f80:	d107      	bne.n	12f92 <m_tb_key_get_net_info+0x4e>
   12f82:	e7fe      	b.n	12f82 <m_tb_key_get_net_info+0x3e>

        // Get new key
        p_key = (m_tb_key_net_t *)(p_m_tb_key_env->p_up->p_keys[base_lid]);
    }
    else if (GETB(p_key->flags, M_MSG_FLAGS_KEY_REFRESH))
   12f84:	0020      	movs	r0, r4
   12f86:	3043      	adds	r0, #67	; 0x43
   12f88:	7800      	ldrb	r0, [r0, #0]
   12f8a:	4228      	tst	r0, r5
   12f8c:	d001      	beq.n	12f92 <m_tb_key_get_net_info+0x4e>
    {
        SETB(*p_flags, M_MSG_FLAGS_KEY_REFRESH, 1);
   12f8e:	4329      	orrs	r1, r5
   12f90:	7019      	strb	r1, [r3, #0]
    }

    if (p_net_id)
   12f92:	2a00      	cmp	r2, #0
   12f94:	d002      	beq.n	12f9c <m_tb_key_get_net_info+0x58>
    {
        *p_net_id = &p_key->net_id[0];
   12f96:	0023      	movs	r3, r4
   12f98:	3346      	adds	r3, #70	; 0x46
   12f9a:	6013      	str	r3, [r2, #0]
    }
}
   12f9c:	bdf0      	pop	{r4, r5, r6, r7, pc}
   12f9e:	46c0      	nop			; (mov r8, r8)
   12fa0:	100126c0 	.word	0x100126c0

00012fa4 <m_tb_key_iv_upd_test_mode_ind>:

void m_tb_key_iv_upd_test_mode_ind(bool update)
{
   12fa4:	b570      	push	{r4, r5, r6, lr}
    if (!GETB(p_m_tb_key_env->status, M_TB_KEY_STATUS_IV_UPDATE))
   12fa6:	4d0f      	ldr	r5, [pc, #60]	; (12fe4 <m_tb_key_iv_upd_test_mode_ind+0x40>)
        *p_net_id = &p_key->net_id[0];
    }
}

void m_tb_key_iv_upd_test_mode_ind(bool update)
{
   12fa8:	0004      	movs	r4, r0
    if (!GETB(p_m_tb_key_env->status, M_TB_KEY_STATUS_IV_UPDATE))
   12faa:	682b      	ldr	r3, [r5, #0]
   12fac:	001a      	movs	r2, r3
   12fae:	32b9      	adds	r2, #185	; 0xb9
   12fb0:	7812      	ldrb	r2, [r2, #0]
   12fb2:	07d2      	lsls	r2, r2, #31
   12fb4:	d406      	bmi.n	12fc4 <m_tb_key_iv_upd_test_mode_ind+0x20>
    {
        if (update)
   12fb6:	2800      	cmp	r0, #0
   12fb8:	d008      	beq.n	12fcc <m_tb_key_iv_upd_test_mode_ind+0x28>
        {
            // Increase IV
            p_m_tb_key_env->iv++;
   12fba:	33ac      	adds	r3, #172	; 0xac
   12fbc:	681a      	ldr	r2, [r3, #0]
   12fbe:	3201      	adds	r2, #1
   12fc0:	601a      	str	r2, [r3, #0]
   12fc2:	e003      	b.n	12fcc <m_tb_key_iv_upd_test_mode_ind+0x28>
        }
    }
    else
    {
        if (!update)
   12fc4:	2800      	cmp	r0, #0
   12fc6:	d101      	bne.n	12fcc <m_tb_key_iv_upd_test_mode_ind+0x28>
        {
            // New IV will now be used, reset sequence number
            p_m_tb_key_env->next_tx_seq = 0;
   12fc8:	33b0      	adds	r3, #176	; 0xb0
   12fca:	6018      	str	r0, [r3, #0]
        }
    }

    // Inform the storage manager
    m_tb_store_update_ind(M_TB_STORE_UPD_TYPE_STATE, M_TB_STORE_TYPE_IV_SEQ);
   12fcc:	2108      	movs	r1, #8
   12fce:	2007      	movs	r0, #7
   12fd0:	f001 fe22 	bl	14c18 <m_tb_store_update_ind>

    // Update flags value
    SETB(p_m_tb_key_env->status, M_TB_KEY_STATUS_IV_UPDATE, update);
   12fd4:	2101      	movs	r1, #1
   12fd6:	682b      	ldr	r3, [r5, #0]
   12fd8:	33b9      	adds	r3, #185	; 0xb9
   12fda:	781a      	ldrb	r2, [r3, #0]
   12fdc:	438a      	bics	r2, r1
   12fde:	4314      	orrs	r4, r2
   12fe0:	701c      	strb	r4, [r3, #0]
}
   12fe2:	bd70      	pop	{r4, r5, r6, pc}
   12fe4:	100126c0 	.word	0x100126c0

00012fe8 <m_tb_mio_subs_find_addr>:
 * @return Position at which the address has been found. If the address has not been found,
 * the returned value is the number of non-virtual addresses in the subscription list.
 ****************************************************************************************
 */
__STATIC uint16_t m_tb_mio_subs_find_addr(m_tb_mio_t *p_model_io, uint16_t addr)
{
   12fe8:	b570      	push	{r4, r5, r6, lr}
    // Found position
    uint16_t pos = p_model_io->nb_addr;
   12fea:	8a03      	ldrh	r3, [r0, #16]

    if (p_model_io->nb_addr == 1)
   12fec:	2b01      	cmp	r3, #1
   12fee:	d105      	bne.n	12ffc <m_tb_mio_subs_find_addr+0x14>
    {
        if (p_model_io->subs_list[0] == addr)
        {
            pos = 0;
   12ff0:	8b03      	ldrh	r3, [r0, #24]
   12ff2:	1a5b      	subs	r3, r3, r1
   12ff4:	1e59      	subs	r1, r3, #1
   12ff6:	418b      	sbcs	r3, r1
   12ff8:	b29b      	uxth	r3, r3
   12ffa:	e024      	b.n	13046 <m_tb_mio_subs_find_addr+0x5e>
        }
    }
    else if (p_model_io->nb_addr)
   12ffc:	2b00      	cmp	r3, #0
   12ffe:	d022      	beq.n	13046 <m_tb_mio_subs_find_addr+0x5e>
    {
        // Start index
        uint16_t start = 0;
   13000:	2200      	movs	r2, #0
        // End index
        uint16_t end = p_model_io->nb_addr - 1;
   13002:	1e5d      	subs	r5, r3, #1
   13004:	b2ad      	uxth	r5, r5

        while (true)
        {
            // Checked index
            uint16_t idx = start + ((end - start) >> 1);
   13006:	1aac      	subs	r4, r5, r2
   13008:	1064      	asrs	r4, r4, #1
   1300a:	18a4      	adds	r4, r4, r2
   1300c:	b2a4      	uxth	r4, r4

            if (p_model_io->subs_list[idx] == addr)
   1300e:	0026      	movs	r6, r4
   13010:	360c      	adds	r6, #12
   13012:	0076      	lsls	r6, r6, #1
   13014:	5a36      	ldrh	r6, [r6, r0]
   13016:	42b1      	cmp	r1, r6
   13018:	d012      	beq.n	13040 <m_tb_mio_subs_find_addr+0x58>
            {
                pos = idx;
                break;
            }

            if (p_model_io->subs_list[idx] < addr)
   1301a:	d801      	bhi.n	13020 <m_tb_mio_subs_find_addr+0x38>
        uint16_t end = p_model_io->nb_addr - 1;

        while (true)
        {
            // Checked index
            uint16_t idx = start + ((end - start) >> 1);
   1301c:	0025      	movs	r5, r4
   1301e:	e000      	b.n	13022 <m_tb_mio_subs_find_addr+0x3a>
   13020:	0022      	movs	r2, r4
            else
            {
                end = idx;
            }

            if (end == (start + 1))
   13022:	1c54      	adds	r4, r2, #1
   13024:	42a5      	cmp	r5, r4
   13026:	d1ee      	bne.n	13006 <m_tb_mio_subs_find_addr+0x1e>
            {
                if (p_model_io->subs_list[start] == addr)
   13028:	340b      	adds	r4, #11
   1302a:	0064      	lsls	r4, r4, #1
   1302c:	5a24      	ldrh	r4, [r4, r0]
   1302e:	428c      	cmp	r4, r1
   13030:	d008      	beq.n	13044 <m_tb_mio_subs_find_addr+0x5c>
                {
                    pos = start;
                }
                else if (p_model_io->subs_list[end] == addr)
   13032:	320d      	adds	r2, #13
   13034:	0052      	lsls	r2, r2, #1
   13036:	5a12      	ldrh	r2, [r2, r0]
   13038:	428a      	cmp	r2, r1
   1303a:	d104      	bne.n	13046 <m_tb_mio_subs_find_addr+0x5e>
   1303c:	002b      	movs	r3, r5
   1303e:	e002      	b.n	13046 <m_tb_mio_subs_find_addr+0x5e>
        uint16_t end = p_model_io->nb_addr - 1;

        while (true)
        {
            // Checked index
            uint16_t idx = start + ((end - start) >> 1);
   13040:	0023      	movs	r3, r4
   13042:	e000      	b.n	13046 <m_tb_mio_subs_find_addr+0x5e>
   13044:	0013      	movs	r3, r2
        }
    }

    // Return the found position
    return (pos);
}
   13046:	0018      	movs	r0, r3
   13048:	bd70      	pop	{r4, r5, r6, pc}

0001304a <m_tb_mio_find_label_uuid>:
 * @return M_INVALID_LID if label UUID has not been found, else the local index of the virtual
 * address information.
 ****************************************************************************************
 */
__STATIC m_lid_t m_tb_mio_find_label_uuid(uint8_t *p_label_uuid)
{
   1304a:	b570      	push	{r4, r5, r6, lr}
   1304c:	0006      	movs	r6, r0
    // Virtual address local index
    m_lid_t va_lid = M_INVALID_LID;
    // Counter
    m_lid_t cnt;

    for (cnt = 0; cnt < M_TB_MIO_VIRT_ADDR_LIST_SIZE; cnt++)
   1304e:	2400      	movs	r4, #0
    {
        // Get virtual address information
        m_tb_mio_virt_addr_t *p_virt_addr = &p_m_tb_mio_env->virt_addrs[cnt];
   13050:	4b0a      	ldr	r3, [pc, #40]	; (1307c <m_tb_mio_find_label_uuid+0x32>)
   13052:	681d      	ldr	r5, [r3, #0]
   13054:	35bb      	adds	r5, #187	; 0xbb
   13056:	35ff      	adds	r5, #255	; 0xff

        // Compare provided information with stored ones
        if (p_virt_addr->used_cnt &&
   13058:	7c2b      	ldrb	r3, [r5, #16]
   1305a:	2b00      	cmp	r3, #0
   1305c:	d006      	beq.n	1306c <m_tb_mio_find_label_uuid+0x22>
            !memcmp(&p_virt_addr->label_uuid[0], p_label_uuid, M_LABEL_UUID_LEN))
   1305e:	2210      	movs	r2, #16
   13060:	0031      	movs	r1, r6
   13062:	0028      	movs	r0, r5
   13064:	f002 fc8c 	bl	15980 <memcmp>
    {
        // Get virtual address information
        m_tb_mio_virt_addr_t *p_virt_addr = &p_m_tb_mio_env->virt_addrs[cnt];

        // Compare provided information with stored ones
        if (p_virt_addr->used_cnt &&
   13068:	2800      	cmp	r0, #0
   1306a:	d005      	beq.n	13078 <m_tb_mio_find_label_uuid+0x2e>
    // Virtual address local index
    m_lid_t va_lid = M_INVALID_LID;
    // Counter
    m_lid_t cnt;

    for (cnt = 0; cnt < M_TB_MIO_VIRT_ADDR_LIST_SIZE; cnt++)
   1306c:	3401      	adds	r4, #1
   1306e:	b2e4      	uxtb	r4, r4
   13070:	3514      	adds	r5, #20
   13072:	2c05      	cmp	r4, #5
   13074:	d1f0      	bne.n	13058 <m_tb_mio_find_label_uuid+0xe>
 ****************************************************************************************
 */
__STATIC m_lid_t m_tb_mio_find_label_uuid(uint8_t *p_label_uuid)
{
    // Virtual address local index
    m_lid_t va_lid = M_INVALID_LID;
   13076:	34fa      	adds	r4, #250	; 0xfa
        }
    }

    // Return found local index
    return (va_lid);
}
   13078:	0020      	movs	r0, r4
   1307a:	bd70      	pop	{r4, r5, r6, pc}
   1307c:	100126c4 	.word	0x100126c4

00013080 <m_tb_mio_add_virt_addr>:
 * @return M_INVALID_LID if no available position has been found for couple insertion, else
 * local index.
 ****************************************************************************************
 */
__STATIC m_lid_t m_tb_mio_add_virt_addr(uint16_t virt_addr, uint8_t *p_label_uuid)
{
   13080:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   13082:	0007      	movs	r7, r0
    // Check if provided label UUID is known
    m_lid_t va_lid = m_tb_mio_find_label_uuid(p_label_uuid);
   13084:	0008      	movs	r0, r1
 * @return M_INVALID_LID if no available position has been found for couple insertion, else
 * local index.
 ****************************************************************************************
 */
__STATIC m_lid_t m_tb_mio_add_virt_addr(uint16_t virt_addr, uint8_t *p_label_uuid)
{
   13086:	000d      	movs	r5, r1
    // Check if provided label UUID is known
    m_lid_t va_lid = m_tb_mio_find_label_uuid(p_label_uuid);
   13088:	f7ff ffdf 	bl	1304a <m_tb_mio_find_label_uuid>
   1308c:	4b1a      	ldr	r3, [pc, #104]	; (130f8 <m_tb_mio_add_virt_addr+0x78>)

    if (va_lid != M_INVALID_LID)
   1308e:	28ff      	cmp	r0, #255	; 0xff
   13090:	d009      	beq.n	130a6 <m_tb_mio_add_virt_addr+0x26>
    {
        // Address is already known, increase number of time the address is used
        p_m_tb_mio_env->virt_addrs[va_lid].used_cnt++;
   13092:	681a      	ldr	r2, [r3, #0]
   13094:	2314      	movs	r3, #20
   13096:	4343      	muls	r3, r0
   13098:	18d3      	adds	r3, r2, r3
   1309a:	33cb      	adds	r3, #203	; 0xcb
   1309c:	33ff      	adds	r3, #255	; 0xff
   1309e:	781a      	ldrb	r2, [r3, #0]
   130a0:	3201      	adds	r2, #1
   130a2:	701a      	strb	r2, [r3, #0]
   130a4:	e026      	b.n	130f4 <m_tb_mio_add_virt_addr+0x74>
    }
    else
    {
        // Check if address can be inserted
        if (p_m_tb_mio_env->nb_virt_addrs < M_TB_MIO_VIRT_ADDR_LIST_SIZE)
   130a6:	681c      	ldr	r4, [r3, #0]
   130a8:	2387      	movs	r3, #135	; 0x87
   130aa:	009b      	lsls	r3, r3, #2
   130ac:	5ce3      	ldrb	r3, [r4, r3]
   130ae:	2b04      	cmp	r3, #4
   130b0:	d820      	bhi.n	130f4 <m_tb_mio_add_virt_addr+0x74>
   130b2:	0023      	movs	r3, r4
   130b4:	2200      	movs	r2, #0
   130b6:	33cb      	adds	r3, #203	; 0xcb
   130b8:	33ff      	adds	r3, #255	; 0xff
            m_lid_t cnt;

            // Look for an available position
            for (cnt = 0; cnt < M_TB_MIO_VIRT_ADDR_LIST_SIZE; cnt++)
            {
                if (p_m_tb_mio_env->virt_addrs[cnt].used_cnt == 0)
   130ba:	7819      	ldrb	r1, [r3, #0]
   130bc:	b2d6      	uxtb	r6, r2
   130be:	2900      	cmp	r1, #0
   130c0:	d004      	beq.n	130cc <m_tb_mio_add_virt_addr+0x4c>
   130c2:	3201      	adds	r2, #1
   130c4:	3314      	adds	r3, #20
        {
            // Counter
            m_lid_t cnt;

            // Look for an available position
            for (cnt = 0; cnt < M_TB_MIO_VIRT_ADDR_LIST_SIZE; cnt++)
   130c6:	2a05      	cmp	r2, #5
   130c8:	d1f7      	bne.n	130ba <m_tb_mio_add_virt_addr+0x3a>
   130ca:	e013      	b.n	130f4 <m_tb_mio_add_virt_addr+0x74>
            {
                // Point to the found position
                m_tb_mio_virt_addr_t *p_virt_addr = &p_m_tb_mio_env->virt_addrs[va_lid];

                // And fill address information
                p_virt_addr->virt_addr = virt_addr;
   130cc:	2314      	movs	r3, #20
   130ce:	4353      	muls	r3, r2
   130d0:	0018      	movs	r0, r3
   130d2:	18e3      	adds	r3, r4, r3
   130d4:	33b9      	adds	r3, #185	; 0xb9
                memcpy(&p_virt_addr->label_uuid[0], p_label_uuid, M_LABEL_UUID_LEN);
   130d6:	1820      	adds	r0, r4, r0
            {
                // Point to the found position
                m_tb_mio_virt_addr_t *p_virt_addr = &p_m_tb_mio_env->virt_addrs[va_lid];

                // And fill address information
                p_virt_addr->virt_addr = virt_addr;
   130d8:	33ff      	adds	r3, #255	; 0xff
                memcpy(&p_virt_addr->label_uuid[0], p_label_uuid, M_LABEL_UUID_LEN);
   130da:	30bb      	adds	r0, #187	; 0xbb
            {
                // Point to the found position
                m_tb_mio_virt_addr_t *p_virt_addr = &p_m_tb_mio_env->virt_addrs[va_lid];

                // And fill address information
                p_virt_addr->virt_addr = virt_addr;
   130dc:	801f      	strh	r7, [r3, #0]
                memcpy(&p_virt_addr->label_uuid[0], p_label_uuid, M_LABEL_UUID_LEN);
   130de:	2210      	movs	r2, #16
   130e0:	30ff      	adds	r0, #255	; 0xff
   130e2:	0029      	movs	r1, r5
   130e4:	f002 fc74 	bl	159d0 <memcpy>

                // Increase number of used virtual addresses
                p_m_tb_mio_env->nb_virt_addrs++;
   130e8:	2287      	movs	r2, #135	; 0x87
   130ea:	0030      	movs	r0, r6
   130ec:	0092      	lsls	r2, r2, #2
   130ee:	5ca3      	ldrb	r3, [r4, r2]
   130f0:	3301      	adds	r3, #1
   130f2:	54a3      	strb	r3, [r4, r2]
            }
        }
    }

    return (va_lid);
}
   130f4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   130f6:	46c0      	nop			; (mov r8, r8)
   130f8:	100126c4 	.word	0x100126c4

000130fc <m_tb_mio_rem_virt_addr>:
 ****************************************************************************************
 */
__STATIC void m_tb_mio_rem_virt_addr(m_lid_t va_lid)
{
    // Virtual address information
    m_tb_mio_virt_addr_t *p_virt_addr = &p_m_tb_mio_env->virt_addrs[va_lid];
   130fc:	4b0a      	ldr	r3, [pc, #40]	; (13128 <m_tb_mio_rem_virt_addr+0x2c>)
   130fe:	681a      	ldr	r2, [r3, #0]

    if (p_virt_addr->used_cnt)
   13100:	2314      	movs	r3, #20
   13102:	4358      	muls	r0, r3
   13104:	1810      	adds	r0, r2, r0
   13106:	30cb      	adds	r0, #203	; 0xcb
   13108:	30ff      	adds	r0, #255	; 0xff
   1310a:	7803      	ldrb	r3, [r0, #0]
   1310c:	2b00      	cmp	r3, #0
   1310e:	d009      	beq.n	13124 <m_tb_mio_rem_virt_addr+0x28>
    {
        p_virt_addr->used_cnt--;
   13110:	3b01      	subs	r3, #1
   13112:	b2db      	uxtb	r3, r3
   13114:	7003      	strb	r3, [r0, #0]

        if (p_virt_addr->used_cnt == 0)
   13116:	2b00      	cmp	r3, #0
   13118:	d104      	bne.n	13124 <m_tb_mio_rem_virt_addr+0x28>
            #if (BLE_MESH_LPN)
            // Maintain list of addresses
            m_tb_mio_addr_list_rem(p_virt_addr->virt_addr);
            #endif //(BLE_MESH_LPN)

            p_m_tb_mio_env->nb_virt_addrs--;
   1311a:	2187      	movs	r1, #135	; 0x87
   1311c:	0089      	lsls	r1, r1, #2
   1311e:	5c53      	ldrb	r3, [r2, r1]
   13120:	3b01      	subs	r3, #1
   13122:	5453      	strb	r3, [r2, r1]
        }
    }
}
   13124:	4770      	bx	lr
   13126:	46c0      	nop			; (mov r8, r8)
   13128:	100126c4 	.word	0x100126c4

0001312c <m_tb_mio_init>:
 * GLOBAL FUNCTIONS
 ****************************************************************************************
 */

uint16_t m_tb_mio_init(bool reset, void* p_env, const m_cfg_t* p_cfg)
{
   1312c:	b510      	push	{r4, lr}
   1312e:	4b0a      	ldr	r3, [pc, #40]	; (13158 <m_tb_mio_init+0x2c>)
   13130:	000c      	movs	r4, r1
    if (!reset)
   13132:	2800      	cmp	r0, #0
   13134:	d10a      	bne.n	1314c <m_tb_mio_init+0x20>
    {
        // Get environment for Model IO Toolbox
        p_m_tb_mio_env = (m_tb_mio_env_t *)p_env;

        // Initialize environment
        memset(p_m_tb_mio_env, 0, sizeof(m_tb_mio_env_t));
   13136:	2289      	movs	r2, #137	; 0x89
uint16_t m_tb_mio_init(bool reset, void* p_env, const m_cfg_t* p_cfg)
{
    if (!reset)
    {
        // Get environment for Model IO Toolbox
        p_m_tb_mio_env = (m_tb_mio_env_t *)p_env;
   13138:	6019      	str	r1, [r3, #0]

        // Initialize environment
        memset(p_m_tb_mio_env, 0, sizeof(m_tb_mio_env_t));
   1313a:	0092      	lsls	r2, r2, #2
   1313c:	0001      	movs	r1, r0
   1313e:	0020      	movs	r0, r4
   13140:	f002 fc84 	bl	15a4c <memset>

        // Initialize number of elements (primary element is mandatory)
        p_m_tb_mio_env->nb_elements = 1;
   13144:	2201      	movs	r2, #1
   13146:	4b05      	ldr	r3, [pc, #20]	; (1315c <m_tb_mio_init+0x30>)
   13148:	54e2      	strb	r2, [r4, r3]
   1314a:	e001      	b.n	13150 <m_tb_mio_init+0x24>
        {
            m_al_free(p_m_tb_mio_env->p_addr_list);
        }
        #endif //(BLE_MESH_LPN)

        p_m_tb_mio_env = NULL;
   1314c:	2200      	movs	r2, #0
   1314e:	601a      	str	r2, [r3, #0]
    }
    return (sizeof(m_tb_mio_env_t));
}
   13150:	2089      	movs	r0, #137	; 0x89
   13152:	0080      	lsls	r0, r0, #2
   13154:	bd10      	pop	{r4, pc}
   13156:	46c0      	nop			; (mov r8, r8)
   13158:	100126c4 	.word	0x100126c4
   1315c:	0000021e 	.word	0x0000021e

00013160 <m_tb_mio_get_env_size>:

uint16_t m_tb_mio_get_env_size(const m_cfg_t* p_cfg)
{
    return (sizeof(m_tb_mio_env_t));
}
   13160:	2089      	movs	r0, #137	; 0x89
   13162:	0080      	lsls	r0, r0, #2
   13164:	4770      	bx	lr

00013166 <m_tb_mio_register_model>:

uint16_t m_tb_mio_register_model(uint32_t model_id, uint8_t addr_offset, bool vendor,
                                 const m_api_model_cb_t *p_cb, m_lid_t *p_model_lid)
{
   13166:	b5f0      	push	{r4, r5, r6, r7, lr}
   13168:	b087      	sub	sp, #28
   1316a:	9003      	str	r0, [sp, #12]
   1316c:	000c      	movs	r4, r1
   1316e:	9204      	str	r2, [sp, #16]
   13170:	9305      	str	r3, [sp, #20]
    // Returned status
    uint16_t status = M_ERR_COMMAND_DISALLOWED;

    if (p_cb == NULL)
   13172:	2b00      	cmp	r3, #0
   13174:	d048      	beq.n	13208 <m_tb_mio_register_model+0xa2>
    {
        status = M_ERR_INVALID_PARAM;
    }
    // Check if a new model instance can be added
    else if (p_m_tb_mio_env->nb_models < M_TB_MIO_MODEL_NB)
   13176:	4f26      	ldr	r7, [pc, #152]	; (13210 <m_tb_mio_register_model+0xaa>)
   13178:	4e26      	ldr	r6, [pc, #152]	; (13214 <m_tb_mio_register_model+0xae>)
   1317a:	683b      	ldr	r3, [r7, #0]
   1317c:	5d9a      	ldrb	r2, [r3, r6]
   1317e:	2a09      	cmp	r2, #9
   13180:	d901      	bls.n	13186 <m_tb_mio_register_model+0x20>

uint16_t m_tb_mio_register_model(uint32_t model_id, uint8_t addr_offset, bool vendor,
                                 const m_api_model_cb_t *p_cb, m_lid_t *p_model_lid)
{
    // Returned status
    uint16_t status = M_ERR_COMMAND_DISALLOWED;
   13182:	4825      	ldr	r0, [pc, #148]	; (13218 <m_tb_mio_register_model+0xb2>)
   13184:	e042      	b.n	1320c <m_tb_mio_register_model+0xa6>
    }
    // Check if a new model instance can be added
    else if (p_m_tb_mio_env->nb_models < M_TB_MIO_MODEL_NB)
    {
        // Check that model instance is not already registered
        if (m_tb_mio_get_local_id(p_m_tb_mio_env->prim_addr + addr_offset, model_id,
   13186:	2288      	movs	r2, #136	; 0x88
   13188:	0092      	lsls	r2, r2, #2
   1318a:	5a98      	ldrh	r0, [r3, r2]
   1318c:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   1318e:	1840      	adds	r0, r0, r1
   13190:	b280      	uxth	r0, r0
   13192:	9a04      	ldr	r2, [sp, #16]
   13194:	9903      	ldr	r1, [sp, #12]
   13196:	f000 f84f 	bl	13238 <m_tb_mio_get_local_id>
   1319a:	23a0      	movs	r3, #160	; 0xa0
   1319c:	009b      	lsls	r3, r3, #2
   1319e:	4298      	cmp	r0, r3
   131a0:	d1ef      	bne.n	13182 <m_tb_mio_register_model+0x1c>
        {
            // Get pointer to the model information structure
            m_tb_mio_t *p_model_io = &p_m_tb_mio_env->model_ios[p_m_tb_mio_env->nb_models];

            // Return the allocated index
            *p_model_lid = p_m_tb_mio_env->nb_models;
   131a2:	466a      	mov	r2, sp
        // Check that model instance is not already registered
        if (m_tb_mio_get_local_id(p_m_tb_mio_env->prim_addr + addr_offset, model_id,
                                  vendor, p_model_lid) == M_ERR_INVALID_MODEL)
        {
            // Get pointer to the model information structure
            m_tb_mio_t *p_model_io = &p_m_tb_mio_env->model_ios[p_m_tb_mio_env->nb_models];
   131a4:	683d      	ldr	r5, [r7, #0]

            // Initialize the model information structure
            p_model_io->addr_offset = addr_offset;
            p_model_io->model_id = model_id;
            p_model_io->nb_addr = 0;
            p_model_io->p_model_cb = p_cb;
   131a6:	9905      	ldr	r1, [sp, #20]
        // Check that model instance is not already registered
        if (m_tb_mio_get_local_id(p_m_tb_mio_env->prim_addr + addr_offset, model_id,
                                  vendor, p_model_lid) == M_ERR_INVALID_MODEL)
        {
            // Get pointer to the model information structure
            m_tb_mio_t *p_model_io = &p_m_tb_mio_env->model_ios[p_m_tb_mio_env->nb_models];
   131a8:	5dab      	ldrb	r3, [r5, r6]
            p_model_io->model_id = model_id;
            p_model_io->nb_addr = 0;
            p_model_io->p_model_cb = p_cb;
            p_model_io->status = 0;

			m_printf(L_TB, "lid[0x%x] offset[0x%x] model_id[0x%x]",
   131aa:	2002      	movs	r0, #2
        // Check that model instance is not already registered
        if (m_tb_mio_get_local_id(p_m_tb_mio_env->prim_addr + addr_offset, model_id,
                                  vendor, p_model_lid) == M_ERR_INVALID_MODEL)
        {
            // Get pointer to the model information structure
            m_tb_mio_t *p_model_io = &p_m_tb_mio_env->model_ios[p_m_tb_mio_env->nb_models];
   131ac:	9302      	str	r3, [sp, #8]

            // Return the allocated index
            *p_model_lid = p_m_tb_mio_env->nb_models;
   131ae:	7a12      	ldrb	r2, [r2, #8]
   131b0:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   131b2:	701a      	strb	r2, [r3, #0]

            // Increase number of registered models
            p_m_tb_mio_env->nb_models++;
   131b4:	5dab      	ldrb	r3, [r5, r6]

            // Initialize the model information structure
            p_model_io->addr_offset = addr_offset;
            p_model_io->model_id = model_id;
   131b6:	9a03      	ldr	r2, [sp, #12]

            // Return the allocated index
            *p_model_lid = p_m_tb_mio_env->nb_models;

            // Increase number of registered models
            p_m_tb_mio_env->nb_models++;
   131b8:	3301      	adds	r3, #1
   131ba:	55ab      	strb	r3, [r5, r6]

            // Initialize the model information structure
            p_model_io->addr_offset = addr_offset;
   131bc:	262c      	movs	r6, #44	; 0x2c
   131be:	9b02      	ldr	r3, [sp, #8]
   131c0:	4373      	muls	r3, r6
   131c2:	18eb      	adds	r3, r5, r3
            p_model_io->model_id = model_id;
   131c4:	601a      	str	r2, [r3, #0]
            p_model_io->nb_addr = 0;
   131c6:	2200      	movs	r2, #0
            p_model_io->p_model_cb = p_cb;
   131c8:	6059      	str	r1, [r3, #4]
            p_m_tb_mio_env->nb_models++;

            // Initialize the model information structure
            p_model_io->addr_offset = addr_offset;
            p_model_io->model_id = model_id;
            p_model_io->nb_addr = 0;
   131ca:	821a      	strh	r2, [r3, #16]
            p_model_io->p_model_cb = p_cb;
            p_model_io->status = 0;
   131cc:	751a      	strb	r2, [r3, #20]

			m_printf(L_TB, "lid[0x%x] offset[0x%x] model_id[0x%x]",
   131ce:	9903      	ldr	r1, [sp, #12]
   131d0:	9a0c      	ldr	r2, [sp, #48]	; 0x30

            // Increase number of registered models
            p_m_tb_mio_env->nb_models++;

            // Initialize the model information structure
            p_model_io->addr_offset = addr_offset;
   131d2:	759c      	strb	r4, [r3, #22]
            p_model_io->model_id = model_id;
            p_model_io->nb_addr = 0;
            p_model_io->p_model_cb = p_cb;
            p_model_io->status = 0;

			m_printf(L_TB, "lid[0x%x] offset[0x%x] model_id[0x%x]",
   131d4:	7812      	ldrb	r2, [r2, #0]
   131d6:	9100      	str	r1, [sp, #0]
   131d8:	4910      	ldr	r1, [pc, #64]	; (1321c <m_tb_mio_register_model+0xb6>)
   131da:	0023      	movs	r3, r4
   131dc:	3109      	adds	r1, #9
   131de:	f7f1 fc07 	bl	49f0 <m_printf>
					*p_model_lid,  p_model_io->addr_offset, model_id);

            // Update number of known elements
            if (addr_offset >= p_m_tb_mio_env->nb_elements)
   131e2:	683a      	ldr	r2, [r7, #0]
   131e4:	4b0e      	ldr	r3, [pc, #56]	; (13220 <m_tb_mio_register_model+0xba>)
   131e6:	5cd1      	ldrb	r1, [r2, r3]
   131e8:	42a1      	cmp	r1, r4
   131ea:	d801      	bhi.n	131f0 <m_tb_mio_register_model+0x8a>
            {
                p_m_tb_mio_env->nb_elements = addr_offset + 1;
   131ec:	3401      	adds	r4, #1
   131ee:	54d4      	strb	r4, [r2, r3]
            if (vendor)
            {
                SETB(p_model_io->status, M_TB_MIO_MODEL_ID_VENDOR, 1);
            }

            status = M_ERR_NO_ERROR;
   131f0:	2000      	movs	r0, #0
            if (addr_offset >= p_m_tb_mio_env->nb_elements)
            {
                p_m_tb_mio_env->nb_elements = addr_offset + 1;
            }

            if (vendor)
   131f2:	9b04      	ldr	r3, [sp, #16]
   131f4:	4283      	cmp	r3, r0
   131f6:	d009      	beq.n	1320c <m_tb_mio_register_model+0xa6>
            {
                SETB(p_model_io->status, M_TB_MIO_MODEL_ID_VENDOR, 1);
   131f8:	2202      	movs	r2, #2
   131fa:	9b02      	ldr	r3, [sp, #8]
   131fc:	435e      	muls	r6, r3
   131fe:	19ad      	adds	r5, r5, r6
   13200:	7d2b      	ldrb	r3, [r5, #20]
   13202:	4313      	orrs	r3, r2
   13204:	752b      	strb	r3, [r5, #20]
   13206:	e001      	b.n	1320c <m_tb_mio_register_model+0xa6>
    // Returned status
    uint16_t status = M_ERR_COMMAND_DISALLOWED;

    if (p_cb == NULL)
    {
        status = M_ERR_INVALID_PARAM;
   13208:	20c1      	movs	r0, #193	; 0xc1
   1320a:	0040      	lsls	r0, r0, #1
            status = M_ERR_NO_ERROR;
        }
    }

    return (status);
}
   1320c:	b007      	add	sp, #28
   1320e:	bdf0      	pop	{r4, r5, r6, r7, pc}
   13210:	100126c4 	.word	0x100126c4
   13214:	0000021d 	.word	0x0000021d
   13218:	00000282 	.word	0x00000282
   1321c:	00022808 	.word	0x00022808
   13220:	0000021e 	.word	0x0000021e

00013224 <m_tb_mio_get_nb_model>:

uint8_t m_tb_mio_get_nb_model(void)
{
    // Return current number of models
    return (p_m_tb_mio_env->nb_models);
   13224:	4b02      	ldr	r3, [pc, #8]	; (13230 <m_tb_mio_get_nb_model+0xc>)
   13226:	681a      	ldr	r2, [r3, #0]
   13228:	4b02      	ldr	r3, [pc, #8]	; (13234 <m_tb_mio_get_nb_model+0x10>)
   1322a:	5cd0      	ldrb	r0, [r2, r3]
}
   1322c:	4770      	bx	lr
   1322e:	46c0      	nop			; (mov r8, r8)
   13230:	100126c4 	.word	0x100126c4
   13234:	0000021d 	.word	0x0000021d

00013238 <m_tb_mio_get_local_id>:

uint16_t m_tb_mio_get_local_id(uint16_t element_addr, uint32_t model_id, bool vendor,
                               m_lid_t *p_model_lid)
{
   13238:	b5f0      	push	{r4, r5, r6, r7, lr}
   1323a:	b087      	sub	sp, #28
   1323c:	9103      	str	r1, [sp, #12]
   1323e:	9305      	str	r3, [sp, #20]
    // Returned status
    uint16_t status = M_ERR_INVALID_MODEL;
    // Counter
    m_lid_t cnt;
	m_printf(L_TB, "eaddr[0x%x] model_id[0x%x] vendor[%d]",element_addr,model_id,vendor);
   13240:	000b      	movs	r3, r1
   13242:	4925      	ldr	r1, [pc, #148]	; (132d8 <m_tb_mio_get_local_id+0xa0>)
    return (p_m_tb_mio_env->nb_models);
}

uint16_t m_tb_mio_get_local_id(uint16_t element_addr, uint32_t model_id, bool vendor,
                               m_lid_t *p_model_lid)
{
   13244:	9004      	str	r0, [sp, #16]
    // Returned status
    uint16_t status = M_ERR_INVALID_MODEL;
    // Counter
    m_lid_t cnt;
	m_printf(L_TB, "eaddr[0x%x] model_id[0x%x] vendor[%d]",element_addr,model_id,vendor);
   13246:	9200      	str	r2, [sp, #0]
    return (p_m_tb_mio_env->nb_models);
}

uint16_t m_tb_mio_get_local_id(uint16_t element_addr, uint32_t model_id, bool vendor,
                               m_lid_t *p_model_lid)
{
   13248:	0016      	movs	r6, r2
    // Returned status
    uint16_t status = M_ERR_INVALID_MODEL;
    // Counter
    m_lid_t cnt;
	m_printf(L_TB, "eaddr[0x%x] model_id[0x%x] vendor[%d]",element_addr,model_id,vendor);
   1324a:	312f      	adds	r1, #47	; 0x2f
   1324c:	0002      	movs	r2, r0
   1324e:	2002      	movs	r0, #2
   13250:	f7f1 fbce 	bl	49f0 <m_printf>
    for (cnt = 0; cnt < p_m_tb_mio_env->nb_models; cnt++)
   13254:	2400      	movs	r4, #0
   13256:	4f21      	ldr	r7, [pc, #132]	; (132dc <m_tb_mio_get_local_id+0xa4>)
   13258:	4b21      	ldr	r3, [pc, #132]	; (132e0 <m_tb_mio_get_local_id+0xa8>)
   1325a:	683a      	ldr	r2, [r7, #0]
   1325c:	5cd3      	ldrb	r3, [r2, r3]
   1325e:	42a3      	cmp	r3, r4
   13260:	d935      	bls.n	132ce <m_tb_mio_get_local_id+0x96>
   13262:	252c      	movs	r5, #44	; 0x2c
    {
        // Get model information
        m_tb_mio_t *p_model_io = &p_m_tb_mio_env->model_ios[cnt];
		m_printf(L_TB, "prim_addr[0x%x] addr_offset[0x%x] status[0x%x] model_id[0x%x]"
   13264:	2188      	movs	r1, #136	; 0x88
   13266:	4365      	muls	r5, r4
   13268:	0089      	lsls	r1, r1, #2
   1326a:	1955      	adds	r5, r2, r5
   1326c:	5a52      	ldrh	r2, [r2, r1]
   1326e:	6829      	ldr	r1, [r5, #0]
   13270:	7dab      	ldrb	r3, [r5, #22]
   13272:	9101      	str	r1, [sp, #4]
   13274:	7d29      	ldrb	r1, [r5, #20]
   13276:	2002      	movs	r0, #2
   13278:	9100      	str	r1, [sp, #0]
   1327a:	4917      	ldr	r1, [pc, #92]	; (132d8 <m_tb_mio_get_local_id+0xa0>)
   1327c:	3155      	adds	r1, #85	; 0x55
   1327e:	f7f1 fbb7 	bl	49f0 <m_printf>
					, p_m_tb_mio_env->prim_addr, p_model_io->addr_offset,p_model_io->status
					,p_model_io->model_id);
        if ((p_m_tb_mio_env->prim_addr + p_model_io->addr_offset) == element_addr)
   13282:	2288      	movs	r2, #136	; 0x88
   13284:	683b      	ldr	r3, [r7, #0]
   13286:	0092      	lsls	r2, r2, #2
   13288:	5a9a      	ldrh	r2, [r3, r2]
   1328a:	7dab      	ldrb	r3, [r5, #22]
   1328c:	18d3      	adds	r3, r2, r3
   1328e:	9a04      	ldr	r2, [sp, #16]
   13290:	429a      	cmp	r2, r3
   13292:	d119      	bne.n	132c8 <m_tb_mio_get_local_id+0x90>
        {
            // Check kind of model id
            if (vendor != (bool)GETB(p_model_io->status, M_TB_MIO_MODEL_ID_VENDOR))
   13294:	7d2b      	ldrb	r3, [r5, #20]
   13296:	079b      	lsls	r3, r3, #30
   13298:	0fdb      	lsrs	r3, r3, #31
   1329a:	429e      	cmp	r6, r3
   1329c:	d114      	bne.n	132c8 <m_tb_mio_get_local_id+0x90>
   1329e:	682b      	ldr	r3, [r5, #0]
            {
                continue;
            }

            // Check the model identifier
            if (vendor)
   132a0:	2e00      	cmp	r6, #0
   132a2:	d00c      	beq.n	132be <m_tb_mio_get_local_id+0x86>
            {
                if (model_id != p_model_io->model_id)
   132a4:	9a03      	ldr	r2, [sp, #12]
   132a6:	429a      	cmp	r2, r3
   132a8:	d10e      	bne.n	132c8 <m_tb_mio_get_local_id+0x90>
                }
            }


            // Return the found local index and keep the value in cache
            *p_model_lid = cnt;
   132aa:	9b05      	ldr	r3, [sp, #20]
			m_printf(L_TB, "p_model_lid[0x%x]",cnt);
   132ac:	490d      	ldr	r1, [pc, #52]	; (132e4 <m_tb_mio_get_local_id+0xac>)
                }
            }


            // Return the found local index and keep the value in cache
            *p_model_lid = cnt;
   132ae:	701c      	strb	r4, [r3, #0]
			m_printf(L_TB, "p_model_lid[0x%x]",cnt);
   132b0:	0022      	movs	r2, r4
   132b2:	3113      	adds	r1, #19
   132b4:	2002      	movs	r0, #2
   132b6:	f7f1 fb9b 	bl	49f0 <m_printf>
            status = M_ERR_NO_ERROR;
   132ba:	2000      	movs	r0, #0
            break;
   132bc:	e009      	b.n	132d2 <m_tb_mio_get_local_id+0x9a>
                    continue;
                }
            }
            else
            {
                if ((uint16_t)model_id != (uint16_t)p_model_io->model_id)
   132be:	466a      	mov	r2, sp
   132c0:	8992      	ldrh	r2, [r2, #12]
   132c2:	b29b      	uxth	r3, r3
   132c4:	4293      	cmp	r3, r2
   132c6:	d0f0      	beq.n	132aa <m_tb_mio_get_local_id+0x72>
    // Returned status
    uint16_t status = M_ERR_INVALID_MODEL;
    // Counter
    m_lid_t cnt;
	m_printf(L_TB, "eaddr[0x%x] model_id[0x%x] vendor[%d]",element_addr,model_id,vendor);
    for (cnt = 0; cnt < p_m_tb_mio_env->nb_models; cnt++)
   132c8:	3401      	adds	r4, #1
   132ca:	b2e4      	uxtb	r4, r4
   132cc:	e7c3      	b.n	13256 <m_tb_mio_get_local_id+0x1e>

uint16_t m_tb_mio_get_local_id(uint16_t element_addr, uint32_t model_id, bool vendor,
                               m_lid_t *p_model_lid)
{
    // Returned status
    uint16_t status = M_ERR_INVALID_MODEL;
   132ce:	20a0      	movs	r0, #160	; 0xa0
   132d0:	0080      	lsls	r0, r0, #2
            break;
        }
    }

    return (status);
}
   132d2:	b007      	add	sp, #28
   132d4:	bdf0      	pop	{r4, r5, r6, r7, pc}
   132d6:	46c0      	nop			; (mov r8, r8)
   132d8:	00022808 	.word	0x00022808
   132dc:	100126c4 	.word	0x100126c4
   132e0:	0000021d 	.word	0x0000021d
   132e4:	00022888 	.word	0x00022888

000132e8 <m_tb_mio_get_model_id>:

uint32_t m_tb_mio_get_model_id(m_lid_t model_lid, bool *p_vendor)
{
    // Get pointer to the model information structure
    m_tb_mio_t *p_model_io = &p_m_tb_mio_env->model_ios[model_lid];
   132e8:	4b05      	ldr	r3, [pc, #20]	; (13300 <m_tb_mio_get_model_id+0x18>)
   132ea:	681a      	ldr	r2, [r3, #0]

    // Return if model identifier is a SIG or a vendor one
    *p_vendor = GETB(p_model_io->status, M_TB_MIO_MODEL_ID_VENDOR);
   132ec:	232c      	movs	r3, #44	; 0x2c
   132ee:	4358      	muls	r0, r3
   132f0:	1813      	adds	r3, r2, r0
   132f2:	7d1b      	ldrb	r3, [r3, #20]
   132f4:	079b      	lsls	r3, r3, #30
   132f6:	0fdb      	lsrs	r3, r3, #31
   132f8:	700b      	strb	r3, [r1, #0]

    // Return the model identifier
    return (p_model_io->model_id);
   132fa:	5880      	ldr	r0, [r0, r2]
}
   132fc:	4770      	bx	lr
   132fe:	46c0      	nop			; (mov r8, r8)
   13300:	100126c4 	.word	0x100126c4

00013304 <m_tb_mio_get_element_addr>:
uint16_t m_tb_mio_get_element_addr(m_lid_t model_lid, uint16_t *p_elt_addr)
{
    // Returned status
    uint16_t status = M_ERR_INVALID_MODEL;

    if (model_lid < p_m_tb_mio_env->nb_models)
   13304:	4b09      	ldr	r3, [pc, #36]	; (1332c <m_tb_mio_get_element_addr+0x28>)
   13306:	681a      	ldr	r2, [r3, #0]
   13308:	4b09      	ldr	r3, [pc, #36]	; (13330 <m_tb_mio_get_element_addr+0x2c>)
   1330a:	5cd3      	ldrb	r3, [r2, r3]
   1330c:	4283      	cmp	r3, r0
   1330e:	d90a      	bls.n	13326 <m_tb_mio_get_element_addr+0x22>
    {
        // Get pointer to the model information structure
        m_tb_mio_t *p_model_io = &p_m_tb_mio_env->model_ios[model_lid];

        // Provide element address
        *p_elt_addr = p_m_tb_mio_env->prim_addr + p_model_io->addr_offset;
   13310:	232c      	movs	r3, #44	; 0x2c
   13312:	4358      	muls	r0, r3
   13314:	33f5      	adds	r3, #245	; 0xf5
   13316:	1810      	adds	r0, r2, r0
   13318:	33ff      	adds	r3, #255	; 0xff
   1331a:	7d80      	ldrb	r0, [r0, #22]
   1331c:	5ad3      	ldrh	r3, [r2, r3]
   1331e:	18c3      	adds	r3, r0, r3
   13320:	800b      	strh	r3, [r1, #0]

        status = M_ERR_NO_ERROR;
   13322:	2000      	movs	r0, #0
   13324:	e001      	b.n	1332a <m_tb_mio_get_element_addr+0x26>
}

uint16_t m_tb_mio_get_element_addr(m_lid_t model_lid, uint16_t *p_elt_addr)
{
    // Returned status
    uint16_t status = M_ERR_INVALID_MODEL;
   13326:	20a0      	movs	r0, #160	; 0xa0
   13328:	0080      	lsls	r0, r0, #2

        status = M_ERR_NO_ERROR;
    }

    return (status);
}
   1332a:	4770      	bx	lr
   1332c:	100126c4 	.word	0x100126c4
   13330:	0000021d 	.word	0x0000021d

00013334 <m_tb_mio_cb_get>:
uint16_t m_tb_mio_cb_get(m_lid_t model_lid, const m_api_model_cb_t **pp_model_cb)
{
    // Returned status
    uint16_t status = M_ERR_INVALID_MODEL;

    if (model_lid < p_m_tb_mio_env->nb_models)
   13334:	4b07      	ldr	r3, [pc, #28]	; (13354 <m_tb_mio_cb_get+0x20>)
   13336:	681a      	ldr	r2, [r3, #0]
   13338:	4b07      	ldr	r3, [pc, #28]	; (13358 <m_tb_mio_cb_get+0x24>)
   1333a:	5cd3      	ldrb	r3, [r2, r3]
   1333c:	4283      	cmp	r3, r0
   1333e:	d906      	bls.n	1334e <m_tb_mio_cb_get+0x1a>
    {
        // Get pointer to the model information structure
        m_tb_mio_t *p_model_io = &p_m_tb_mio_env->model_ios[model_lid];

        // Provide callback structure
        *pp_model_cb = p_model_io->p_model_cb;
   13340:	232c      	movs	r3, #44	; 0x2c
   13342:	4358      	muls	r0, r3
   13344:	1810      	adds	r0, r2, r0
   13346:	6843      	ldr	r3, [r0, #4]

        status = M_ERR_NO_ERROR;
   13348:	2000      	movs	r0, #0
    {
        // Get pointer to the model information structure
        m_tb_mio_t *p_model_io = &p_m_tb_mio_env->model_ios[model_lid];

        // Provide callback structure
        *pp_model_cb = p_model_io->p_model_cb;
   1334a:	600b      	str	r3, [r1, #0]
   1334c:	e001      	b.n	13352 <m_tb_mio_cb_get+0x1e>
}

uint16_t m_tb_mio_cb_get(m_lid_t model_lid, const m_api_model_cb_t **pp_model_cb)
{
    // Returned status
    uint16_t status = M_ERR_INVALID_MODEL;
   1334e:	20a0      	movs	r0, #160	; 0xa0
   13350:	0080      	lsls	r0, r0, #2

        status = M_ERR_NO_ERROR;
    }

    return (status);
}
   13352:	4770      	bx	lr
   13354:	100126c4 	.word	0x100126c4
   13358:	0000021d 	.word	0x0000021d

0001335c <m_tb_mio_set_publi_param>:

uint16_t m_tb_mio_set_publi_param(m_lid_t model_lid, uint16_t addr, uint8_t *p_label_uuid,
                                  uint8_t app_key_lid, uint8_t ttl, uint8_t period, uint8_t retx_params,
                                  uint8_t friend_cred)
{
   1335c:	b5f0      	push	{r4, r5, r6, r7, lr}
   1335e:	b087      	sub	sp, #28
   13360:	9302      	str	r3, [sp, #8]
   13362:	ab0c      	add	r3, sp, #48	; 0x30
   13364:	781b      	ldrb	r3, [r3, #0]
   13366:	0005      	movs	r5, r0
   13368:	9301      	str	r3, [sp, #4]
   1336a:	ab0d      	add	r3, sp, #52	; 0x34
   1336c:	781e      	ldrb	r6, [r3, #0]
   1336e:	ab0e      	add	r3, sp, #56	; 0x38
   13370:	781b      	ldrb	r3, [r3, #0]
   13372:	000c      	movs	r4, r1
   13374:	9303      	str	r3, [sp, #12]
   13376:	ab0f      	add	r3, sp, #60	; 0x3c
   13378:	781b      	ldrb	r3, [r3, #0]
   1337a:	9205      	str	r2, [sp, #20]
   1337c:	9304      	str	r3, [sp, #16]
    {
        // Get pointer to the model information structure
        m_tb_mio_t *p_model_io = &p_m_tb_mio_env->model_ios[model_lid];

        // Check if the provided TTL value is valid
        if ((ttl > M_TB_MIO_TTL_MAX) && (ttl != M_TB_MIO_TTL_USE_DEFAULT))
   1337e:	9b01      	ldr	r3, [sp, #4]
   13380:	3b80      	subs	r3, #128	; 0x80
   13382:	b2db      	uxtb	r3, r3
   13384:	2b7e      	cmp	r3, #126	; 0x7e
   13386:	d95b      	bls.n	13440 <m_tb_mio_set_publi_param+0xe4>
    uint16_t status = M_ERR_INVALID_PARAM;

    do
    {
        // Get pointer to the model information structure
        m_tb_mio_t *p_model_io = &p_m_tb_mio_env->model_ios[model_lid];
   13388:	4b31      	ldr	r3, [pc, #196]	; (13450 <m_tb_mio_set_publi_param+0xf4>)
   1338a:	681f      	ldr	r7, [r3, #0]
        if ((ttl > M_TB_MIO_TTL_MAX) && (ttl != M_TB_MIO_TTL_USE_DEFAULT))
        {
            break;
        }

        if (GETB(p_model_io->status, M_TB_MIO_PUBLI_PARAM_SET))
   1338c:	232c      	movs	r3, #44	; 0x2c
   1338e:	4343      	muls	r3, r0
   13390:	18fb      	adds	r3, r7, r3
   13392:	7d1a      	ldrb	r2, [r3, #20]
   13394:	07d2      	lsls	r2, r2, #31
   13396:	d506      	bpl.n	133a6 <m_tb_mio_set_publi_param+0x4a>
        {
            // Check if model currently use a virtual address as publish address
            if (M_IS_VIRTUAL_ADDR(p_model_io->publi_params.addr))
   13398:	891a      	ldrh	r2, [r3, #8]
   1339a:	0b92      	lsrs	r2, r2, #14
   1339c:	2a02      	cmp	r2, #2
   1339e:	d102      	bne.n	133a6 <m_tb_mio_set_publi_param+0x4a>
            {
                // Remove virtual address information
                m_tb_mio_rem_virt_addr(p_model_io->publi_params.va_lid);
   133a0:	7bd8      	ldrb	r0, [r3, #15]
   133a2:	f7ff feab 	bl	130fc <m_tb_mio_rem_virt_addr>
            }
        }

        if (M_IS_VIRTUAL_ADDR(addr))
   133a6:	0ba3      	lsrs	r3, r4, #14
   133a8:	2b02      	cmp	r3, #2
   133aa:	d10a      	bne.n	133c2 <m_tb_mio_set_publi_param+0x66>
        {
            // Add virtual address information
            p_model_io->publi_params.va_lid
                           = m_tb_mio_add_virt_addr(addr, p_label_uuid);
   133ac:	9905      	ldr	r1, [sp, #20]
   133ae:	0020      	movs	r0, r4
   133b0:	f7ff fe66 	bl	13080 <m_tb_mio_add_virt_addr>
   133b4:	232c      	movs	r3, #44	; 0x2c
   133b6:	436b      	muls	r3, r5
   133b8:	18fb      	adds	r3, r7, r3
   133ba:	73d8      	strb	r0, [r3, #15]

            if (p_model_io->publi_params.va_lid == M_INVALID_LID)
   133bc:	28ff      	cmp	r0, #255	; 0xff
   133be:	d10c      	bne.n	133da <m_tb_mio_set_publi_param+0x7e>
   133c0:	e041      	b.n	13446 <m_tb_mio_set_publi_param+0xea>
                break;
            }
        }
        else
        {
            p_model_io->publi_params.va_lid = M_INVALID_LID;
   133c2:	232c      	movs	r3, #44	; 0x2c
   133c4:	22ff      	movs	r2, #255	; 0xff
   133c6:	436b      	muls	r3, r5
   133c8:	18fb      	adds	r3, r7, r3
   133ca:	73da      	strb	r2, [r3, #15]
        }

        // Update parameters if sending of publication has been stopped
        if (addr == M_UNASSIGNED_ADDR)
   133cc:	2c00      	cmp	r4, #0
   133ce:	d104      	bne.n	133da <m_tb_mio_set_publi_param+0x7e>
        {
            period = 0;
   133d0:	0026      	movs	r6, r4
            app_key_lid = M_INVALID_LID;
            ttl = 0;
            friend_cred = 0;
   133d2:	9404      	str	r4, [sp, #16]
            retx_params = 0;
   133d4:	9403      	str	r4, [sp, #12]
        // Update parameters if sending of publication has been stopped
        if (addr == M_UNASSIGNED_ADDR)
        {
            period = 0;
            app_key_lid = M_INVALID_LID;
            ttl = 0;
   133d6:	9401      	str	r4, [sp, #4]

        // Update parameters if sending of publication has been stopped
        if (addr == M_UNASSIGNED_ADDR)
        {
            period = 0;
            app_key_lid = M_INVALID_LID;
   133d8:	9202      	str	r2, [sp, #8]
            friend_cred = 0;
            retx_params = 0;
        }

        // Check if publication period will be modified and inform the model if it is the case
        if (p_model_io->p_model_cb->cb_publish_period)
   133da:	232c      	movs	r3, #44	; 0x2c
   133dc:	436b      	muls	r3, r5
   133de:	18fb      	adds	r3, r7, r3
   133e0:	685a      	ldr	r2, [r3, #4]
   133e2:	68d2      	ldr	r2, [r2, #12]
   133e4:	2a00      	cmp	r2, #0
   133e6:	d010      	beq.n	1340a <m_tb_mio_set_publi_param+0xae>
        {
            if (!GETB(p_model_io->status, M_TB_MIO_PUBLI_PARAM_SET) ||
   133e8:	7d19      	ldrb	r1, [r3, #20]
   133ea:	07c9      	lsls	r1, r1, #31
   133ec:	d502      	bpl.n	133f4 <m_tb_mio_set_publi_param+0x98>
   133ee:	7b1b      	ldrb	r3, [r3, #12]
   133f0:	42b3      	cmp	r3, r6
   133f2:	d00a      	beq.n	1340a <m_tb_mio_set_publi_param+0xae>
   133f4:	09b3      	lsrs	r3, r6, #6
   133f6:	4917      	ldr	r1, [pc, #92]	; (13454 <m_tb_mio_set_publi_param+0xf8>)
   133f8:	b2db      	uxtb	r3, r3
   133fa:	009b      	lsls	r3, r3, #2
   133fc:	18cb      	adds	r3, r1, r3
            {
                // Convert the received period value is milliseconds
                uint32_t period_ms = m_tb_mio_convert_period(period);

                // Inform the model
                p_model_io->p_model_cb->cb_publish_period(model_lid, period_ms);
   133fe:	213f      	movs	r1, #63	; 0x3f
   13400:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   13402:	4031      	ands	r1, r6
   13404:	4359      	muls	r1, r3
   13406:	0028      	movs	r0, r5
   13408:	4790      	blx	r2
            }
        }

        p_model_io->publi_params.addr = addr;
   1340a:	232c      	movs	r3, #44	; 0x2c
   1340c:	436b      	muls	r3, r5
   1340e:	18ff      	adds	r7, r7, r3
        p_model_io->publi_params.app_key_lid = app_key_lid;
   13410:	466b      	mov	r3, sp
   13412:	7a1b      	ldrb	r3, [r3, #8]
        p_model_io->publi_params.friend_cred = friend_cred;
        p_model_io->publi_params.period = period;
        p_model_io->publi_params.retx_params = retx_params;

        // Indicate that publication parameters have been set
        SETB(p_model_io->status, M_TB_MIO_PUBLI_PARAM_SET, 1);
   13414:	2201      	movs	r2, #1
                p_model_io->p_model_cb->cb_publish_period(model_lid, period_ms);
            }
        }

        p_model_io->publi_params.addr = addr;
        p_model_io->publi_params.app_key_lid = app_key_lid;
   13416:	72bb      	strb	r3, [r7, #10]
        p_model_io->publi_params.ttl = ttl;
   13418:	466b      	mov	r3, sp
   1341a:	791b      	ldrb	r3, [r3, #4]

        // Indicate that publication parameters have been set
        SETB(p_model_io->status, M_TB_MIO_PUBLI_PARAM_SET, 1);

        // Inform the storage manager about the update
        m_tb_store_update_ind(M_TB_STORE_UPD_TYPE_PUBLI_PARAM, model_lid);
   1341c:	2004      	movs	r0, #4
            }
        }

        p_model_io->publi_params.addr = addr;
        p_model_io->publi_params.app_key_lid = app_key_lid;
        p_model_io->publi_params.ttl = ttl;
   1341e:	72fb      	strb	r3, [r7, #11]
        p_model_io->publi_params.friend_cred = friend_cred;
   13420:	466b      	mov	r3, sp
   13422:	7c1b      	ldrb	r3, [r3, #16]
                // Inform the model
                p_model_io->p_model_cb->cb_publish_period(model_lid, period_ms);
            }
        }

        p_model_io->publi_params.addr = addr;
   13424:	813c      	strh	r4, [r7, #8]
        p_model_io->publi_params.app_key_lid = app_key_lid;
        p_model_io->publi_params.ttl = ttl;
        p_model_io->publi_params.friend_cred = friend_cred;
   13426:	73bb      	strb	r3, [r7, #14]
        p_model_io->publi_params.period = period;
        p_model_io->publi_params.retx_params = retx_params;
   13428:	466b      	mov	r3, sp
   1342a:	7b1b      	ldrb	r3, [r3, #12]

        p_model_io->publi_params.addr = addr;
        p_model_io->publi_params.app_key_lid = app_key_lid;
        p_model_io->publi_params.ttl = ttl;
        p_model_io->publi_params.friend_cred = friend_cred;
        p_model_io->publi_params.period = period;
   1342c:	733e      	strb	r6, [r7, #12]
        p_model_io->publi_params.retx_params = retx_params;
   1342e:	737b      	strb	r3, [r7, #13]

        // Indicate that publication parameters have been set
        SETB(p_model_io->status, M_TB_MIO_PUBLI_PARAM_SET, 1);
   13430:	7d3b      	ldrb	r3, [r7, #20]

        // Inform the storage manager about the update
        m_tb_store_update_ind(M_TB_STORE_UPD_TYPE_PUBLI_PARAM, model_lid);
   13432:	0029      	movs	r1, r5
        p_model_io->publi_params.friend_cred = friend_cred;
        p_model_io->publi_params.period = period;
        p_model_io->publi_params.retx_params = retx_params;

        // Indicate that publication parameters have been set
        SETB(p_model_io->status, M_TB_MIO_PUBLI_PARAM_SET, 1);
   13434:	4313      	orrs	r3, r2
   13436:	753b      	strb	r3, [r7, #20]

        // Inform the storage manager about the update
        m_tb_store_update_ind(M_TB_STORE_UPD_TYPE_PUBLI_PARAM, model_lid);
   13438:	f001 fbee 	bl	14c18 <m_tb_store_update_ind>

        status = M_ERR_NO_ERROR;
   1343c:	2000      	movs	r0, #0
   1343e:	e004      	b.n	1344a <m_tb_mio_set_publi_param+0xee>
uint16_t m_tb_mio_set_publi_param(m_lid_t model_lid, uint16_t addr, uint8_t *p_label_uuid,
                                  uint8_t app_key_lid, uint8_t ttl, uint8_t period, uint8_t retx_params,
                                  uint8_t friend_cred)
{
    // Returned status
    uint16_t status = M_ERR_INVALID_PARAM;
   13440:	20c1      	movs	r0, #193	; 0xc1
   13442:	0040      	lsls	r0, r0, #1
   13444:	e001      	b.n	1344a <m_tb_mio_set_publi_param+0xee>
            p_model_io->publi_params.va_lid
                           = m_tb_mio_add_virt_addr(addr, p_label_uuid);

            if (p_model_io->publi_params.va_lid == M_INVALID_LID)
            {
                status = M_ERR_INSUFFICIENT_RESOURCES;
   13446:	20b0      	movs	r0, #176	; 0xb0
   13448:	00c0      	lsls	r0, r0, #3

        status = M_ERR_NO_ERROR;
    } while (0);

    return (status);
}
   1344a:	b007      	add	sp, #28
   1344c:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1344e:	46c0      	nop			; (mov r8, r8)
   13450:	100126c4 	.word	0x100126c4
   13454:	00022888 	.word	0x00022888

00013458 <m_tb_mio_get_publi_param>:

uint16_t m_tb_mio_get_publi_param(m_lid_t model_lid, uint16_t *p_addr, uint8_t* p_va_lid,
                                  uint8_t *p_app_key_lid, uint8_t *p_ttl, uint8_t *p_period,
                                  uint8_t *p_retx_params, uint8_t *p_friend_cred)
{
   13458:	b530      	push	{r4, r5, lr}
    // Returned status
    uint16_t status = M_ERR_INVALID_MODEL;

    if(model_lid < p_m_tb_mio_env->nb_models)
   1345a:	4c13      	ldr	r4, [pc, #76]	; (134a8 <m_tb_mio_get_publi_param+0x50>)
   1345c:	6825      	ldr	r5, [r4, #0]
   1345e:	4c13      	ldr	r4, [pc, #76]	; (134ac <m_tb_mio_get_publi_param+0x54>)
   13460:	5d2c      	ldrb	r4, [r5, r4]
   13462:	4284      	cmp	r4, r0
   13464:	d919      	bls.n	1349a <m_tb_mio_get_publi_param+0x42>
    {
        // Get pointer to the model information structure
        m_tb_mio_t *p_model_io = &p_m_tb_mio_env->model_ios[model_lid];

        // Check if publication parameters have been set for this model instance
        if (GETB(p_model_io->status, M_TB_MIO_PUBLI_PARAM_SET))
   13466:	242c      	movs	r4, #44	; 0x2c
   13468:	4360      	muls	r0, r4
   1346a:	1828      	adds	r0, r5, r0
   1346c:	7d04      	ldrb	r4, [r0, #20]
   1346e:	07e4      	lsls	r4, r4, #31
   13470:	d516      	bpl.n	134a0 <m_tb_mio_get_publi_param+0x48>
        {
            // Return the requested parameters
            *p_addr = p_model_io->publi_params.addr;
   13472:	8904      	ldrh	r4, [r0, #8]
   13474:	800c      	strh	r4, [r1, #0]
            *p_va_lid = p_model_io->publi_params.va_lid;
   13476:	7bc1      	ldrb	r1, [r0, #15]
   13478:	7011      	strb	r1, [r2, #0]
            *p_app_key_lid = p_model_io->publi_params.app_key_lid;
   1347a:	7a82      	ldrb	r2, [r0, #10]
   1347c:	701a      	strb	r2, [r3, #0]
            *p_ttl = p_model_io->publi_params.ttl;
   1347e:	7ac3      	ldrb	r3, [r0, #11]
   13480:	9a03      	ldr	r2, [sp, #12]
   13482:	7013      	strb	r3, [r2, #0]
            *p_friend_cred = p_model_io->publi_params.friend_cred;
   13484:	7b83      	ldrb	r3, [r0, #14]
   13486:	9a06      	ldr	r2, [sp, #24]
   13488:	7013      	strb	r3, [r2, #0]
            *p_period = p_model_io->publi_params.period;
   1348a:	7b03      	ldrb	r3, [r0, #12]
   1348c:	9a04      	ldr	r2, [sp, #16]
   1348e:	7013      	strb	r3, [r2, #0]
            *p_retx_params = p_model_io->publi_params.retx_params;
   13490:	7b43      	ldrb	r3, [r0, #13]
   13492:	9a05      	ldr	r2, [sp, #20]

            status = M_ERR_NO_ERROR;
   13494:	2000      	movs	r0, #0
            *p_va_lid = p_model_io->publi_params.va_lid;
            *p_app_key_lid = p_model_io->publi_params.app_key_lid;
            *p_ttl = p_model_io->publi_params.ttl;
            *p_friend_cred = p_model_io->publi_params.friend_cred;
            *p_period = p_model_io->publi_params.period;
            *p_retx_params = p_model_io->publi_params.retx_params;
   13496:	7013      	strb	r3, [r2, #0]
   13498:	e004      	b.n	134a4 <m_tb_mio_get_publi_param+0x4c>
uint16_t m_tb_mio_get_publi_param(m_lid_t model_lid, uint16_t *p_addr, uint8_t* p_va_lid,
                                  uint8_t *p_app_key_lid, uint8_t *p_ttl, uint8_t *p_period,
                                  uint8_t *p_retx_params, uint8_t *p_friend_cred)
{
    // Returned status
    uint16_t status = M_ERR_INVALID_MODEL;
   1349a:	20a0      	movs	r0, #160	; 0xa0
   1349c:	0080      	lsls	r0, r0, #2
   1349e:	e001      	b.n	134a4 <m_tb_mio_get_publi_param+0x4c>

            status = M_ERR_NO_ERROR;
        }
        else
        {
            status = M_ERR_INVALID_PUBLISH_PARAMS;
   134a0:	20f0      	movs	r0, #240	; 0xf0
   134a2:	00c0      	lsls	r0, r0, #3
        }
    }

    return (status);
}
   134a4:	bd30      	pop	{r4, r5, pc}
   134a6:	46c0      	nop			; (mov r8, r8)
   134a8:	100126c4 	.word	0x100126c4
   134ac:	0000021d 	.word	0x0000021d

000134b0 <m_tb_mio_add_subscription>:
    uint16_t status = M_ERR_INSUFFICIENT_RESOURCES;

    do
    {
        // Get pointer to the model information structure
        m_tb_mio_t *p_model_io = &p_m_tb_mio_env->model_ios[model_lid];
   134b0:	4b39      	ldr	r3, [pc, #228]	; (13598 <m_tb_mio_add_subscription+0xe8>)

    return (status);
}

uint16_t m_tb_mio_add_subscription(m_lid_t model_lid, uint16_t addr)
{
   134b2:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    uint16_t status = M_ERR_INSUFFICIENT_RESOURCES;

    do
    {
        // Get pointer to the model information structure
        m_tb_mio_t *p_model_io = &p_m_tb_mio_env->model_ios[model_lid];
   134b4:	681d      	ldr	r5, [r3, #0]
        // Insertion position
        uint16_t insert_idx;

        // Check if a new address can be inserted in the subscription list
        if ((p_model_io->nb_addr + p_model_io->nb_virt_addr) >= M_TB_MIO_SUBS_LIST_SIZE)
   134b6:	232c      	movs	r3, #44	; 0x2c
   134b8:	4343      	muls	r3, r0
   134ba:	18eb      	adds	r3, r5, r3
   134bc:	8a1c      	ldrh	r4, [r3, #16]
   134be:	9301      	str	r3, [sp, #4]
   134c0:	8a5b      	ldrh	r3, [r3, #18]

    return (status);
}

uint16_t m_tb_mio_add_subscription(m_lid_t model_lid, uint16_t addr)
{
   134c2:	0006      	movs	r6, r0
        m_tb_mio_t *p_model_io = &p_m_tb_mio_env->model_ios[model_lid];
        // Insertion position
        uint16_t insert_idx;

        // Check if a new address can be inserted in the subscription list
        if ((p_model_io->nb_addr + p_model_io->nb_virt_addr) >= M_TB_MIO_SUBS_LIST_SIZE)
   134c4:	191b      	adds	r3, r3, r4

    return (status);
}

uint16_t m_tb_mio_add_subscription(m_lid_t model_lid, uint16_t addr)
{
   134c6:	000f      	movs	r7, r1
        m_tb_mio_t *p_model_io = &p_m_tb_mio_env->model_ios[model_lid];
        // Insertion position
        uint16_t insert_idx;

        // Check if a new address can be inserted in the subscription list
        if ((p_model_io->nb_addr + p_model_io->nb_virt_addr) >= M_TB_MIO_SUBS_LIST_SIZE)
   134c8:	2b09      	cmp	r3, #9
   134ca:	dc61      	bgt.n	13590 <m_tb_mio_add_subscription+0xe0>
        {
            break;
        }

        // Check if address if not already in the list
        if (m_tb_mio_subs_find_addr(p_model_io, addr) < p_model_io->nb_addr)
   134cc:	9801      	ldr	r0, [sp, #4]
   134ce:	f7ff fd8b 	bl	12fe8 <m_tb_mio_subs_find_addr>
   134d2:	0003      	movs	r3, r0
        {
            status = M_ERR_NO_ERROR;
   134d4:	2000      	movs	r0, #0
        {
            break;
        }

        // Check if address if not already in the list
        if (m_tb_mio_subs_find_addr(p_model_io, addr) < p_model_io->nb_addr)
   134d6:	429c      	cmp	r4, r3
   134d8:	d85c      	bhi.n	13594 <m_tb_mio_add_subscription+0xe4>
__STATIC uint16_t m_tb_mio_subs_find_insert_pos(m_tb_mio_t *p_model_io, uint16_t addr)
{
    // Position at which the address will be inserted
    uint16_t pos = 0;

    if (p_model_io->nb_addr == 1)
   134da:	2c01      	cmp	r4, #1
   134dc:	d106      	bne.n	134ec <m_tb_mio_add_subscription+0x3c>
    {
        if (p_model_io->subs_list[0] < addr)
   134de:	9b01      	ldr	r3, [sp, #4]
   134e0:	8b1a      	ldrh	r2, [r3, #24]
        {
            pos = 1;
   134e2:	0023      	movs	r3, r4
    // Position at which the address will be inserted
    uint16_t pos = 0;

    if (p_model_io->nb_addr == 1)
    {
        if (p_model_io->subs_list[0] < addr)
   134e4:	42ba      	cmp	r2, r7
   134e6:	d341      	bcc.n	1356c <m_tb_mio_add_subscription+0xbc>
 ****************************************************************************************
 */
__STATIC uint16_t m_tb_mio_subs_find_insert_pos(m_tb_mio_t *p_model_io, uint16_t addr)
{
    // Position at which the address will be inserted
    uint16_t pos = 0;
   134e8:	0003      	movs	r3, r0
   134ea:	e02c      	b.n	13546 <m_tb_mio_add_subscription+0x96>
   134ec:	0003      	movs	r3, r0
        if (p_model_io->subs_list[0] < addr)
        {
            pos = 1;
        }
    }
    else if (p_model_io->nb_addr)
   134ee:	2c00      	cmp	r4, #0
   134f0:	d03c      	beq.n	1356c <m_tb_mio_add_subscription+0xbc>
        while (true)
        {
            // Checked index
            uint16_t idx = start + ((end - start) >> 1);

            if (p_model_io->subs_list[idx] < addr)
   134f2:	2216      	movs	r2, #22
   134f4:	4372      	muls	r2, r6
   134f6:	4694      	mov	ip, r2
    else if (p_model_io->nb_addr)
    {
        // Start index
        uint16_t start = 0;
        // End index
        uint16_t end = p_model_io->nb_addr - 1;
   134f8:	1e63      	subs	r3, r4, #1
   134fa:	b29b      	uxth	r3, r3
        while (true)
        {
            // Checked index
            uint16_t idx = start + ((end - start) >> 1);

            if (p_model_io->subs_list[idx] < addr)
   134fc:	4661      	mov	r1, ip
        uint16_t end = p_model_io->nb_addr - 1;

        while (true)
        {
            // Checked index
            uint16_t idx = start + ((end - start) >> 1);
   134fe:	1a1a      	subs	r2, r3, r0
   13500:	1052      	asrs	r2, r2, #1
   13502:	1812      	adds	r2, r2, r0
   13504:	b292      	uxth	r2, r2

            if (p_model_io->subs_list[idx] < addr)
   13506:	1889      	adds	r1, r1, r2
   13508:	310c      	adds	r1, #12
   1350a:	0049      	lsls	r1, r1, #1
   1350c:	5b49      	ldrh	r1, [r1, r5]
   1350e:	42b9      	cmp	r1, r7
   13510:	d301      	bcc.n	13516 <m_tb_mio_add_subscription+0x66>
            {
                start = idx;
            }
            else
            {
                end = idx;
   13512:	0013      	movs	r3, r2
   13514:	e000      	b.n	13518 <m_tb_mio_add_subscription+0x68>
            // Checked index
            uint16_t idx = start + ((end - start) >> 1);

            if (p_model_io->subs_list[idx] < addr)
            {
                start = idx;
   13516:	0010      	movs	r0, r2
            else
            {
                end = idx;
            }

            if (end == (start + 1))
   13518:	1c42      	adds	r2, r0, #1
   1351a:	4293      	cmp	r3, r2
   1351c:	d1ee      	bne.n	134fc <m_tb_mio_add_subscription+0x4c>
            {
                if (p_model_io->subs_list[start] > addr)
   1351e:	2216      	movs	r2, #22
   13520:	4372      	muls	r2, r6
   13522:	1811      	adds	r1, r2, r0
   13524:	310c      	adds	r1, #12
   13526:	0049      	lsls	r1, r1, #1
   13528:	5b49      	ldrh	r1, [r1, r5]
   1352a:	42b9      	cmp	r1, r7
   1352c:	d808      	bhi.n	13540 <m_tb_mio_add_subscription+0x90>
                {
                    pos = start;
                }
                else if (p_model_io->subs_list[end] > addr)
   1352e:	18d2      	adds	r2, r2, r3
   13530:	320c      	adds	r2, #12
   13532:	0052      	lsls	r2, r2, #1
   13534:	5b52      	ldrh	r2, [r2, r5]
   13536:	42ba      	cmp	r2, r7
   13538:	d803      	bhi.n	13542 <m_tb_mio_add_subscription+0x92>
                {
                    pos = end;
                }
                else
                {
                    pos = end + 1;
   1353a:	3301      	adds	r3, #1
   1353c:	b29b      	uxth	r3, r3
   1353e:	e000      	b.n	13542 <m_tb_mio_add_subscription+0x92>
                end = idx;
            }

            if (end == (start + 1))
            {
                if (p_model_io->subs_list[start] > addr)
   13540:	0003      	movs	r3, r0

        // Find index at which the address can be inserted
        insert_idx = m_tb_mio_subs_find_insert_pos(p_model_io, addr);

        // Check if address will be inserted in last position
        if (p_model_io->nb_addr != insert_idx)
   13542:	429c      	cmp	r4, r3
   13544:	d012      	beq.n	1356c <m_tb_mio_add_subscription+0xbc>
            // Counter
            uint16_t cnt;

            for (cnt = (p_model_io->nb_addr - 1); cnt >= insert_idx; cnt--)
            {
                p_model_io->subs_list[cnt + 1] = p_model_io->subs_list[cnt];
   13546:	2116      	movs	r1, #22
   13548:	4371      	muls	r1, r6
        if (p_model_io->nb_addr != insert_idx)
        {
            // Counter
            uint16_t cnt;

            for (cnt = (p_model_io->nb_addr - 1); cnt >= insert_idx; cnt--)
   1354a:	3c01      	subs	r4, #1
   1354c:	b2a4      	uxth	r4, r4
   1354e:	429c      	cmp	r4, r3
   13550:	d30c      	bcc.n	1356c <m_tb_mio_add_subscription+0xbc>
            {
                p_model_io->subs_list[cnt + 1] = p_model_io->subs_list[cnt];
   13552:	190a      	adds	r2, r1, r4
   13554:	0010      	movs	r0, r2
   13556:	300c      	adds	r0, #12
   13558:	0040      	lsls	r0, r0, #1
   1355a:	5b40      	ldrh	r0, [r0, r5]
   1355c:	320d      	adds	r2, #13
   1355e:	0052      	lsls	r2, r2, #1
   13560:	5350      	strh	r0, [r2, r5]

                if (!cnt)
   13562:	2c00      	cmp	r4, #0
   13564:	d002      	beq.n	1356c <m_tb_mio_add_subscription+0xbc>
        if (p_model_io->nb_addr != insert_idx)
        {
            // Counter
            uint16_t cnt;

            for (cnt = (p_model_io->nb_addr - 1); cnt >= insert_idx; cnt--)
   13566:	3c01      	subs	r4, #1
   13568:	b2a4      	uxth	r4, r4
   1356a:	e7f0      	b.n	1354e <m_tb_mio_add_subscription+0x9e>
        }

        status = M_ERR_NO_ERROR;

        // Insert the address at indicated position
        p_model_io->subs_list[insert_idx] = addr;
   1356c:	2216      	movs	r2, #22
   1356e:	4372      	muls	r2, r6
   13570:	18d3      	adds	r3, r2, r3
   13572:	330c      	adds	r3, #12
   13574:	005b      	lsls	r3, r3, #1
   13576:	535f      	strh	r7, [r3, r5]
        // Increase number of addresses in the list
        p_model_io->nb_addr++;
   13578:	232c      	movs	r3, #44	; 0x2c
   1357a:	4373      	muls	r3, r6
   1357c:	18ed      	adds	r5, r5, r3
   1357e:	8a2b      	ldrh	r3, [r5, #16]
        // Maintain list of addresses
        m_tb_mio_addr_list_add(addr);
        #endif //(BLE_MESH_LPN)

        // Inform the storage manager about the update
        m_tb_store_update_ind(M_TB_STORE_UPD_TYPE_SUBS_LIST, model_lid);
   13580:	2005      	movs	r0, #5
        status = M_ERR_NO_ERROR;

        // Insert the address at indicated position
        p_model_io->subs_list[insert_idx] = addr;
        // Increase number of addresses in the list
        p_model_io->nb_addr++;
   13582:	3301      	adds	r3, #1
   13584:	822b      	strh	r3, [r5, #16]
        // Maintain list of addresses
        m_tb_mio_addr_list_add(addr);
        #endif //(BLE_MESH_LPN)

        // Inform the storage manager about the update
        m_tb_store_update_ind(M_TB_STORE_UPD_TYPE_SUBS_LIST, model_lid);
   13586:	0031      	movs	r1, r6
   13588:	f001 fb46 	bl	14c18 <m_tb_store_update_ind>
                    break;
                }
            }
        }

        status = M_ERR_NO_ERROR;
   1358c:	2000      	movs	r0, #0
   1358e:	e001      	b.n	13594 <m_tb_mio_add_subscription+0xe4>
}

uint16_t m_tb_mio_add_subscription(m_lid_t model_lid, uint16_t addr)
{
    // Returned status
    uint16_t status = M_ERR_INSUFFICIENT_RESOURCES;
   13590:	20b0      	movs	r0, #176	; 0xb0
   13592:	00c0      	lsls	r0, r0, #3
        // Inform the storage manager about the update
        m_tb_store_update_ind(M_TB_STORE_UPD_TYPE_SUBS_LIST, model_lid);
    } while (0);

    return (status);
}
   13594:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
   13596:	46c0      	nop			; (mov r8, r8)
   13598:	100126c4 	.word	0x100126c4

0001359c <m_tb_mio_add_subscription_virt>:
    uint16_t status = M_ERR_INSUFFICIENT_RESOURCES;

    do
    {
        // Get pointer to the model information structure
        m_tb_mio_t *p_model_io = &p_m_tb_mio_env->model_ios[model_lid];
   1359c:	4b26      	ldr	r3, [pc, #152]	; (13638 <m_tb_mio_add_subscription_virt+0x9c>)

    return (status);
}

uint16_t m_tb_mio_add_subscription_virt(m_lid_t model_lid, uint16_t addr, uint8_t *p_label_uuid)
{
   1359e:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    uint16_t status = M_ERR_INSUFFICIENT_RESOURCES;

    do
    {
        // Get pointer to the model information structure
        m_tb_mio_t *p_model_io = &p_m_tb_mio_env->model_ios[model_lid];
   135a0:	681d      	ldr	r5, [r3, #0]
        // Local index of virtual address information entry
        m_lid_t va_lid;

        // Check if a new address can be inserted in the subscription list
        if ((p_model_io->nb_addr + p_model_io->nb_virt_addr) >= M_TB_MIO_SUBS_LIST_SIZE)
   135a2:	232c      	movs	r3, #44	; 0x2c
   135a4:	4343      	muls	r3, r0
   135a6:	18eb      	adds	r3, r5, r3
   135a8:	8a5f      	ldrh	r7, [r3, #18]
   135aa:	8a1b      	ldrh	r3, [r3, #16]

    return (status);
}

uint16_t m_tb_mio_add_subscription_virt(m_lid_t model_lid, uint16_t addr, uint8_t *p_label_uuid)
{
   135ac:	0004      	movs	r4, r0
        m_tb_mio_t *p_model_io = &p_m_tb_mio_env->model_ios[model_lid];
        // Local index of virtual address information entry
        m_lid_t va_lid;

        // Check if a new address can be inserted in the subscription list
        if ((p_model_io->nb_addr + p_model_io->nb_virt_addr) >= M_TB_MIO_SUBS_LIST_SIZE)
   135ae:	19db      	adds	r3, r3, r7

    return (status);
}

uint16_t m_tb_mio_add_subscription_virt(m_lid_t model_lid, uint16_t addr, uint8_t *p_label_uuid)
{
   135b0:	9101      	str	r1, [sp, #4]
   135b2:	0016      	movs	r6, r2
        m_tb_mio_t *p_model_io = &p_m_tb_mio_env->model_ios[model_lid];
        // Local index of virtual address information entry
        m_lid_t va_lid;

        // Check if a new address can be inserted in the subscription list
        if ((p_model_io->nb_addr + p_model_io->nb_virt_addr) >= M_TB_MIO_SUBS_LIST_SIZE)
   135b4:	2b09      	cmp	r3, #9
   135b6:	dd02      	ble.n	135be <m_tb_mio_add_subscription_virt+0x22>
}

uint16_t m_tb_mio_add_subscription_virt(m_lid_t model_lid, uint16_t addr, uint8_t *p_label_uuid)
{
    // Returned status
    uint16_t status = M_ERR_INSUFFICIENT_RESOURCES;
   135b8:	22b0      	movs	r2, #176	; 0xb0
   135ba:	00d2      	lsls	r2, r2, #3
   135bc:	e03a      	b.n	13634 <m_tb_mio_add_subscription_virt+0x98>
        {
            break;
        }

        // Check if label UUID is already known
        va_lid = m_tb_mio_find_label_uuid(p_label_uuid);
   135be:	0010      	movs	r0, r2
   135c0:	f7ff fd43 	bl	1304a <m_tb_mio_find_label_uuid>

        if (va_lid == M_INVALID_LID)
   135c4:	28ff      	cmp	r0, #255	; 0xff
   135c6:	d106      	bne.n	135d6 <m_tb_mio_add_subscription_virt+0x3a>
        {
            // Try to add a new virtual address information entry
            va_lid = m_tb_mio_add_virt_addr(addr, p_label_uuid);
   135c8:	0031      	movs	r1, r6
   135ca:	9801      	ldr	r0, [sp, #4]
   135cc:	f7ff fd58 	bl	13080 <m_tb_mio_add_virt_addr>

            if (va_lid == M_INVALID_LID)
   135d0:	28ff      	cmp	r0, #255	; 0xff
   135d2:	d115      	bne.n	13600 <m_tb_mio_add_subscription_virt+0x64>
   135d4:	e7f0      	b.n	135b8 <m_tb_mio_add_subscription_virt+0x1c>
    // Counter
    uint16_t cnt;

    for (cnt = M_TB_MIO_SUBS_LIST_SIZE - 1; cnt >= last_pos; cnt--)
    {
        if (p_model_io->subs_list[cnt] == va_lid)
   135d6:	2616      	movs	r6, #22
__STATIC uint16_t m_tb_mio_subs_find_va_lid(m_tb_mio_t *p_model_io, m_lid_t va_lid)
{
    // Start at end of the subscription list
    uint16_t pos = M_TB_MIO_SUBS_LIST_SIZE;
    // Position of last virtual address in the subscription list
    uint16_t last_pos = M_TB_MIO_SUBS_LIST_SIZE - p_model_io->nb_virt_addr;
   135d8:	220a      	movs	r2, #10
    // Counter
    uint16_t cnt;

    for (cnt = M_TB_MIO_SUBS_LIST_SIZE - 1; cnt >= last_pos; cnt--)
   135da:	2309      	movs	r3, #9
    {
        if (p_model_io->subs_list[cnt] == va_lid)
   135dc:	4366      	muls	r6, r4
__STATIC uint16_t m_tb_mio_subs_find_va_lid(m_tb_mio_t *p_model_io, m_lid_t va_lid)
{
    // Start at end of the subscription list
    uint16_t pos = M_TB_MIO_SUBS_LIST_SIZE;
    // Position of last virtual address in the subscription list
    uint16_t last_pos = M_TB_MIO_SUBS_LIST_SIZE - p_model_io->nb_virt_addr;
   135de:	1bd2      	subs	r2, r2, r7
   135e0:	b292      	uxth	r2, r2
    // Counter
    uint16_t cnt;

    for (cnt = M_TB_MIO_SUBS_LIST_SIZE - 1; cnt >= last_pos; cnt--)
    {
        if (p_model_io->subs_list[cnt] == va_lid)
   135e2:	b287      	uxth	r7, r0
    // Position of last virtual address in the subscription list
    uint16_t last_pos = M_TB_MIO_SUBS_LIST_SIZE - p_model_io->nb_virt_addr;
    // Counter
    uint16_t cnt;

    for (cnt = M_TB_MIO_SUBS_LIST_SIZE - 1; cnt >= last_pos; cnt--)
   135e4:	429a      	cmp	r2, r3
   135e6:	d80b      	bhi.n	13600 <m_tb_mio_add_subscription_virt+0x64>
    {
        if (p_model_io->subs_list[cnt] == va_lid)
   135e8:	18f1      	adds	r1, r6, r3
   135ea:	310c      	adds	r1, #12
   135ec:	0049      	lsls	r1, r1, #1
   135ee:	5b49      	ldrh	r1, [r1, r5]
   135f0:	42b9      	cmp	r1, r7
   135f2:	d002      	beq.n	135fa <m_tb_mio_add_subscription_virt+0x5e>
    // Position of last virtual address in the subscription list
    uint16_t last_pos = M_TB_MIO_SUBS_LIST_SIZE - p_model_io->nb_virt_addr;
    // Counter
    uint16_t cnt;

    for (cnt = M_TB_MIO_SUBS_LIST_SIZE - 1; cnt >= last_pos; cnt--)
   135f4:	3b01      	subs	r3, #1
   135f6:	b29b      	uxth	r3, r3
   135f8:	e7f4      	b.n	135e4 <m_tb_mio_add_subscription_virt+0x48>
        else
        {
            // Check if found local index if not already in the subscription list
            if (m_tb_mio_subs_find_va_lid(p_model_io, va_lid) != M_TB_MIO_SUBS_LIST_SIZE)
            {
                status = M_ERR_NO_ERROR;
   135fa:	2200      	movs	r2, #0
            }
        }
        else
        {
            // Check if found local index if not already in the subscription list
            if (m_tb_mio_subs_find_va_lid(p_model_io, va_lid) != M_TB_MIO_SUBS_LIST_SIZE)
   135fc:	2b0a      	cmp	r3, #10
   135fe:	d119      	bne.n	13634 <m_tb_mio_add_subscription_virt+0x98>
            }
        }


        // Insert the local index in the subscription list
        p_model_io->nb_virt_addr++;
   13600:	212c      	movs	r1, #44	; 0x2c
   13602:	4361      	muls	r1, r4
   13604:	1869      	adds	r1, r5, r1
   13606:	8a4b      	ldrh	r3, [r1, #18]
   13608:	3301      	adds	r3, #1
   1360a:	b29a      	uxth	r2, r3
        p_model_io->subs_list[M_TB_MIO_SUBS_LIST_SIZE - p_model_io->nb_virt_addr] = va_lid;
   1360c:	2316      	movs	r3, #22
   1360e:	4363      	muls	r3, r4
   13610:	1a9b      	subs	r3, r3, r2
   13612:	3316      	adds	r3, #22
   13614:	005b      	lsls	r3, r3, #1
            }
        }


        // Insert the local index in the subscription list
        p_model_io->nb_virt_addr++;
   13616:	824a      	strh	r2, [r1, #18]
        p_model_io->subs_list[M_TB_MIO_SUBS_LIST_SIZE - p_model_io->nb_virt_addr] = va_lid;
   13618:	5358      	strh	r0, [r3, r5]

        // Increase number of time the virtual address is used
        p_m_tb_mio_env->virt_addrs[va_lid].used_cnt++;
   1361a:	2314      	movs	r3, #20
   1361c:	4358      	muls	r0, r3
   1361e:	182d      	adds	r5, r5, r0
   13620:	35cb      	adds	r5, #203	; 0xcb
   13622:	35ff      	adds	r5, #255	; 0xff
   13624:	782b      	ldrb	r3, [r5, #0]
        // Maintain list of addresses
        m_tb_mio_addr_list_add(addr);
        #endif //(BLE_MESH_LPN)

        // Inform the storage manager about the update
        m_tb_store_update_ind(M_TB_STORE_UPD_TYPE_SUBS_LIST, model_lid);
   13626:	0021      	movs	r1, r4
        // Insert the local index in the subscription list
        p_model_io->nb_virt_addr++;
        p_model_io->subs_list[M_TB_MIO_SUBS_LIST_SIZE - p_model_io->nb_virt_addr] = va_lid;

        // Increase number of time the virtual address is used
        p_m_tb_mio_env->virt_addrs[va_lid].used_cnt++;
   13628:	3301      	adds	r3, #1
   1362a:	702b      	strb	r3, [r5, #0]
        // Maintain list of addresses
        m_tb_mio_addr_list_add(addr);
        #endif //(BLE_MESH_LPN)

        // Inform the storage manager about the update
        m_tb_store_update_ind(M_TB_STORE_UPD_TYPE_SUBS_LIST, model_lid);
   1362c:	2005      	movs	r0, #5
   1362e:	f001 faf3 	bl	14c18 <m_tb_store_update_ind>
        p_model_io->subs_list[M_TB_MIO_SUBS_LIST_SIZE - p_model_io->nb_virt_addr] = va_lid;

        // Increase number of time the virtual address is used
        p_m_tb_mio_env->virt_addrs[va_lid].used_cnt++;

        status = M_ERR_NO_ERROR;
   13632:	2200      	movs	r2, #0
        // Inform the storage manager about the update
        m_tb_store_update_ind(M_TB_STORE_UPD_TYPE_SUBS_LIST, model_lid);
    } while (0);

    return (status);
}
   13634:	0010      	movs	r0, r2
   13636:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
   13638:	100126c4 	.word	0x100126c4

0001363c <m_tb_mio_delete_subscription>:

void m_tb_mio_delete_subscription(m_lid_t model_lid, uint16_t addr)
{
   1363c:	b570      	push	{r4, r5, r6, lr}
    // Get pointer to the model information structure
    m_tb_mio_t *p_model_io = &p_m_tb_mio_env->model_ios[model_lid];
   1363e:	242c      	movs	r4, #44	; 0x2c
   13640:	4b11      	ldr	r3, [pc, #68]	; (13688 <m_tb_mio_delete_subscription+0x4c>)
   13642:	4344      	muls	r4, r0
   13644:	681e      	ldr	r6, [r3, #0]

    return (status);
}

void m_tb_mio_delete_subscription(m_lid_t model_lid, uint16_t addr)
{
   13646:	0005      	movs	r5, r0
    // Get pointer to the model information structure
    m_tb_mio_t *p_model_io = &p_m_tb_mio_env->model_ios[model_lid];
   13648:	1934      	adds	r4, r6, r4
    // Index of the provided address in the subscription list
    uint16_t pos = m_tb_mio_subs_find_addr(p_model_io, addr);
   1364a:	0020      	movs	r0, r4
   1364c:	f7ff fccc 	bl	12fe8 <m_tb_mio_subs_find_addr>

    // Check if address has been found
    if (pos < p_model_io->nb_addr)
   13650:	8a23      	ldrh	r3, [r4, #16]
   13652:	4283      	cmp	r3, r0
   13654:	d917      	bls.n	13686 <m_tb_mio_delete_subscription+0x4a>
        uint16_t cnt;

        // Delete the address from the subscription list
        for (cnt = pos; cnt < (p_model_io->nb_addr - 1); cnt++)
        {
            p_model_io->subs_list[cnt] = p_model_io->subs_list[cnt + 1];
   13656:	2216      	movs	r2, #22
   13658:	436a      	muls	r2, r5
    {
        // Counter
        uint16_t cnt;

        // Delete the address from the subscription list
        for (cnt = pos; cnt < (p_model_io->nb_addr - 1); cnt++)
   1365a:	0021      	movs	r1, r4
   1365c:	8a23      	ldrh	r3, [r4, #16]
   1365e:	3110      	adds	r1, #16
   13660:	3b01      	subs	r3, #1
   13662:	4298      	cmp	r0, r3
   13664:	da0a      	bge.n	1367c <m_tb_mio_delete_subscription+0x40>
        {
            p_model_io->subs_list[cnt] = p_model_io->subs_list[cnt + 1];
   13666:	1813      	adds	r3, r2, r0
   13668:	0019      	movs	r1, r3
   1366a:	310d      	adds	r1, #13
   1366c:	0049      	lsls	r1, r1, #1
   1366e:	5b89      	ldrh	r1, [r1, r6]
   13670:	330c      	adds	r3, #12
   13672:	005b      	lsls	r3, r3, #1
    {
        // Counter
        uint16_t cnt;

        // Delete the address from the subscription list
        for (cnt = pos; cnt < (p_model_io->nb_addr - 1); cnt++)
   13674:	3001      	adds	r0, #1
        {
            p_model_io->subs_list[cnt] = p_model_io->subs_list[cnt + 1];
   13676:	5399      	strh	r1, [r3, r6]
    {
        // Counter
        uint16_t cnt;

        // Delete the address from the subscription list
        for (cnt = pos; cnt < (p_model_io->nb_addr - 1); cnt++)
   13678:	b280      	uxth	r0, r0
   1367a:	e7ee      	b.n	1365a <m_tb_mio_delete_subscription+0x1e>
        {
            p_model_io->subs_list[cnt] = p_model_io->subs_list[cnt + 1];
        }

        // Decrease number of addresses in the list
        p_model_io->nb_addr--;
   1367c:	800b      	strh	r3, [r1, #0]
        // Maintain list of addresses
        m_tb_mio_addr_list_rem(addr);
        #endif //(BLE_MESH_LPN)

        // Inform the storage manager about the update
        m_tb_store_update_ind(M_TB_STORE_UPD_TYPE_SUBS_LIST, model_lid);
   1367e:	2005      	movs	r0, #5
   13680:	0029      	movs	r1, r5
   13682:	f001 fac9 	bl	14c18 <m_tb_store_update_ind>
    }
}
   13686:	bd70      	pop	{r4, r5, r6, pc}
   13688:	100126c4 	.word	0x100126c4

0001368c <m_tb_mio_delete_subscription_virt>:

void m_tb_mio_delete_subscription_virt(m_lid_t model_lid, uint8_t *p_label_uuid, uint16_t *p_addr)
{
   1368c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    // Get pointer to the model information structure
    m_tb_mio_t *p_model_io = &p_m_tb_mio_env->model_ios[model_lid];
   1368e:	4b26      	ldr	r3, [pc, #152]	; (13728 <m_tb_mio_delete_subscription_virt+0x9c>)
        m_tb_store_update_ind(M_TB_STORE_UPD_TYPE_SUBS_LIST, model_lid);
    }
}

void m_tb_mio_delete_subscription_virt(m_lid_t model_lid, uint8_t *p_label_uuid, uint16_t *p_addr)
{
   13690:	0007      	movs	r7, r0
    // Get pointer to the model information structure
    m_tb_mio_t *p_model_io = &p_m_tb_mio_env->model_ios[model_lid];
    // Local index of virtual address information entry
    m_lid_t va_lid = m_tb_mio_find_label_uuid(p_label_uuid);
   13692:	0008      	movs	r0, r1
        m_tb_store_update_ind(M_TB_STORE_UPD_TYPE_SUBS_LIST, model_lid);
    }
}

void m_tb_mio_delete_subscription_virt(m_lid_t model_lid, uint8_t *p_label_uuid, uint16_t *p_addr)
{
   13694:	9201      	str	r2, [sp, #4]
    // Get pointer to the model information structure
    m_tb_mio_t *p_model_io = &p_m_tb_mio_env->model_ios[model_lid];
   13696:	681e      	ldr	r6, [r3, #0]
    // Local index of virtual address information entry
    m_lid_t va_lid = m_tb_mio_find_label_uuid(p_label_uuid);
   13698:	f7ff fcd7 	bl	1304a <m_tb_mio_find_label_uuid>

    // Initialize value of deleted address
    *p_addr = M_UNASSIGNED_ADDR;
   1369c:	2300      	movs	r3, #0
   1369e:	9a01      	ldr	r2, [sp, #4]
   136a0:	8013      	strh	r3, [r2, #0]

    // Check if label UUID is known
    if (va_lid != M_INVALID_LID)
   136a2:	28ff      	cmp	r0, #255	; 0xff
   136a4:	d03f      	beq.n	13726 <m_tb_mio_delete_subscription_virt+0x9a>
__STATIC uint16_t m_tb_mio_subs_find_va_lid(m_tb_mio_t *p_model_io, m_lid_t va_lid)
{
    // Start at end of the subscription list
    uint16_t pos = M_TB_MIO_SUBS_LIST_SIZE;
    // Position of last virtual address in the subscription list
    uint16_t last_pos = M_TB_MIO_SUBS_LIST_SIZE - p_model_io->nb_virt_addr;
   136a6:	332c      	adds	r3, #44	; 0x2c
   136a8:	437b      	muls	r3, r7
    // Counter
    uint16_t cnt;

    for (cnt = M_TB_MIO_SUBS_LIST_SIZE - 1; cnt >= last_pos; cnt--)
    {
        if (p_model_io->subs_list[cnt] == va_lid)
   136aa:	2216      	movs	r2, #22
__STATIC uint16_t m_tb_mio_subs_find_va_lid(m_tb_mio_t *p_model_io, m_lid_t va_lid)
{
    // Start at end of the subscription list
    uint16_t pos = M_TB_MIO_SUBS_LIST_SIZE;
    // Position of last virtual address in the subscription list
    uint16_t last_pos = M_TB_MIO_SUBS_LIST_SIZE - p_model_io->nb_virt_addr;
   136ac:	18f3      	adds	r3, r6, r3
   136ae:	8a5d      	ldrh	r5, [r3, #18]
   136b0:	230a      	movs	r3, #10
    // Counter
    uint16_t cnt;

    for (cnt = M_TB_MIO_SUBS_LIST_SIZE - 1; cnt >= last_pos; cnt--)
   136b2:	2409      	movs	r4, #9
    {
        if (p_model_io->subs_list[cnt] == va_lid)
   136b4:	437a      	muls	r2, r7
__STATIC uint16_t m_tb_mio_subs_find_va_lid(m_tb_mio_t *p_model_io, m_lid_t va_lid)
{
    // Start at end of the subscription list
    uint16_t pos = M_TB_MIO_SUBS_LIST_SIZE;
    // Position of last virtual address in the subscription list
    uint16_t last_pos = M_TB_MIO_SUBS_LIST_SIZE - p_model_io->nb_virt_addr;
   136b6:	1b5d      	subs	r5, r3, r5
   136b8:	b2ad      	uxth	r5, r5
    // Counter
    uint16_t cnt;

    for (cnt = M_TB_MIO_SUBS_LIST_SIZE - 1; cnt >= last_pos; cnt--)
    {
        if (p_model_io->subs_list[cnt] == va_lid)
   136ba:	b281      	uxth	r1, r0
    // Position of last virtual address in the subscription list
    uint16_t last_pos = M_TB_MIO_SUBS_LIST_SIZE - p_model_io->nb_virt_addr;
    // Counter
    uint16_t cnt;

    for (cnt = M_TB_MIO_SUBS_LIST_SIZE - 1; cnt >= last_pos; cnt--)
   136bc:	42a5      	cmp	r5, r4
   136be:	d832      	bhi.n	13726 <m_tb_mio_delete_subscription_virt+0x9a>
    {
        if (p_model_io->subs_list[cnt] == va_lid)
   136c0:	1913      	adds	r3, r2, r4
   136c2:	330c      	adds	r3, #12
   136c4:	005b      	lsls	r3, r3, #1
   136c6:	5b9b      	ldrh	r3, [r3, r6]
   136c8:	428b      	cmp	r3, r1
   136ca:	d002      	beq.n	136d2 <m_tb_mio_delete_subscription_virt+0x46>
    // Position of last virtual address in the subscription list
    uint16_t last_pos = M_TB_MIO_SUBS_LIST_SIZE - p_model_io->nb_virt_addr;
    // Counter
    uint16_t cnt;

    for (cnt = M_TB_MIO_SUBS_LIST_SIZE - 1; cnt >= last_pos; cnt--)
   136cc:	3c01      	subs	r4, #1
   136ce:	b2a4      	uxth	r4, r4
   136d0:	e7f4      	b.n	136bc <m_tb_mio_delete_subscription_virt+0x30>
    if (va_lid != M_INVALID_LID)
    {
        // Look for the found local index in the subscription list
        uint16_t pos = m_tb_mio_subs_find_va_lid(p_model_io, va_lid);

        if (pos != M_TB_MIO_SUBS_LIST_SIZE)
   136d2:	2c0a      	cmp	r4, #10
   136d4:	d027      	beq.n	13726 <m_tb_mio_delete_subscription_virt+0x9a>
            uint8_t cnt;
            // Index of last virtual address in the subscription list
            uint16_t last_va_pos = M_TB_MIO_SUBS_LIST_SIZE - p_model_io->nb_virt_addr;

            // Provide the deleted virtual address
            *p_addr = p_m_tb_mio_env->virt_addrs[va_lid].virt_addr;
   136d6:	2314      	movs	r3, #20
   136d8:	4343      	muls	r3, r0
   136da:	18f3      	adds	r3, r6, r3
   136dc:	33b9      	adds	r3, #185	; 0xb9
   136de:	33ff      	adds	r3, #255	; 0xff
   136e0:	881b      	ldrh	r3, [r3, #0]
   136e2:	9a01      	ldr	r2, [sp, #4]
   136e4:	8013      	strh	r3, [r2, #0]

            // Decrease number of use for this label UUID
            m_tb_mio_rem_virt_addr(va_lid);
   136e6:	f7ff fd09 	bl	130fc <m_tb_mio_rem_virt_addr>

            // Remove local index from the subscription list
            if (pos > last_va_pos)
   136ea:	42a5      	cmp	r5, r4
   136ec:	d30a      	bcc.n	13704 <m_tb_mio_delete_subscription_virt+0x78>
                    p_model_io->subs_list[cnt + 1] = p_model_io->subs_list[cnt];
                }
            }

            // Decrease number of virtual addresses in the subscription list
            p_model_io->nb_virt_addr--;
   136ee:	232c      	movs	r3, #44	; 0x2c
   136f0:	437b      	muls	r3, r7
   136f2:	18f6      	adds	r6, r6, r3
   136f4:	8a73      	ldrh	r3, [r6, #18]

            // Inform the storage manager about the update
            m_tb_store_update_ind(M_TB_STORE_UPD_TYPE_SUBS_LIST, model_lid);
   136f6:	0039      	movs	r1, r7
                    p_model_io->subs_list[cnt + 1] = p_model_io->subs_list[cnt];
                }
            }

            // Decrease number of virtual addresses in the subscription list
            p_model_io->nb_virt_addr--;
   136f8:	3b01      	subs	r3, #1
   136fa:	8273      	strh	r3, [r6, #18]

            // Inform the storage manager about the update
            m_tb_store_update_ind(M_TB_STORE_UPD_TYPE_SUBS_LIST, model_lid);
   136fc:	2005      	movs	r0, #5
   136fe:	f001 fa8b 	bl	14c18 <m_tb_store_update_ind>
   13702:	e010      	b.n	13726 <m_tb_mio_delete_subscription_virt+0x9a>
            // Remove local index from the subscription list
            if (pos > last_va_pos)
            {
                for (cnt = pos - 1; cnt >= last_va_pos; cnt--)
                {
                    p_model_io->subs_list[cnt + 1] = p_model_io->subs_list[cnt];
   13704:	2216      	movs	r2, #22
   13706:	437a      	muls	r2, r7
            m_tb_mio_rem_virt_addr(va_lid);

            // Remove local index from the subscription list
            if (pos > last_va_pos)
            {
                for (cnt = pos - 1; cnt >= last_va_pos; cnt--)
   13708:	3c01      	subs	r4, #1
   1370a:	b2e4      	uxtb	r4, r4
   1370c:	42ac      	cmp	r4, r5
   1370e:	d3ee      	bcc.n	136ee <m_tb_mio_delete_subscription_virt+0x62>
                {
                    p_model_io->subs_list[cnt + 1] = p_model_io->subs_list[cnt];
   13710:	1913      	adds	r3, r2, r4
   13712:	0019      	movs	r1, r3
   13714:	310c      	adds	r1, #12
   13716:	0049      	lsls	r1, r1, #1
   13718:	5b89      	ldrh	r1, [r1, r6]
   1371a:	330d      	adds	r3, #13
   1371c:	005b      	lsls	r3, r3, #1
            m_tb_mio_rem_virt_addr(va_lid);

            // Remove local index from the subscription list
            if (pos > last_va_pos)
            {
                for (cnt = pos - 1; cnt >= last_va_pos; cnt--)
   1371e:	3c01      	subs	r4, #1
                {
                    p_model_io->subs_list[cnt + 1] = p_model_io->subs_list[cnt];
   13720:	5399      	strh	r1, [r3, r6]
            m_tb_mio_rem_virt_addr(va_lid);

            // Remove local index from the subscription list
            if (pos > last_va_pos)
            {
                for (cnt = pos - 1; cnt >= last_va_pos; cnt--)
   13722:	b2e4      	uxtb	r4, r4
   13724:	e7f2      	b.n	1370c <m_tb_mio_delete_subscription_virt+0x80>

            // Inform the storage manager about the update
            m_tb_store_update_ind(M_TB_STORE_UPD_TYPE_SUBS_LIST, model_lid);
        }
    }
}
   13726:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
   13728:	100126c4 	.word	0x100126c4

0001372c <m_tb_mio_delete_all_subscription>:

void m_tb_mio_delete_all_subscription(m_lid_t model_lid)
{
    // Get pointer to the model information structure
    m_tb_mio_t *p_model_io = &p_m_tb_mio_env->model_ios[model_lid];
   1372c:	4b13      	ldr	r3, [pc, #76]	; (1377c <m_tb_mio_delete_all_subscription+0x50>)
        }
    }
}

void m_tb_mio_delete_all_subscription(m_lid_t model_lid)
{
   1372e:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    // Get pointer to the model information structure
    m_tb_mio_t *p_model_io = &p_m_tb_mio_env->model_ios[model_lid];
   13730:	681e      	ldr	r6, [r3, #0]
    // Index of last virtual address in the subscription list
    uint16_t last_va_pos = M_TB_MIO_SUBS_LIST_SIZE - p_model_io->nb_virt_addr;
   13732:	232c      	movs	r3, #44	; 0x2c
   13734:	220a      	movs	r2, #10
   13736:	4343      	muls	r3, r0
   13738:	18f3      	adds	r3, r6, r3
   1373a:	8a59      	ldrh	r1, [r3, #18]
        }
    }
}

void m_tb_mio_delete_all_subscription(m_lid_t model_lid)
{
   1373c:	0005      	movs	r5, r0
    // Get pointer to the model information structure
    m_tb_mio_t *p_model_io = &p_m_tb_mio_env->model_ios[model_lid];
    // Index of last virtual address in the subscription list
    uint16_t last_va_pos = M_TB_MIO_SUBS_LIST_SIZE - p_model_io->nb_virt_addr;
   1373e:	1a52      	subs	r2, r2, r1
   13740:	b292      	uxth	r2, r2
   13742:	9201      	str	r2, [sp, #4]
    // Counter
    m_lid_t cnt;

    // Clear number of address in the subscription list
    p_model_io->nb_addr = 0;
   13744:	2200      	movs	r2, #0

    // Remove all virtual addresses
    for (cnt = M_TB_MIO_SUBS_LIST_SIZE - 1; cnt >= last_va_pos; cnt--)
   13746:	2409      	movs	r4, #9
    {
        m_tb_mio_rem_virt_addr((m_lid_t)p_model_io->subs_list[cnt]);
   13748:	2716      	movs	r7, #22
    uint16_t last_va_pos = M_TB_MIO_SUBS_LIST_SIZE - p_model_io->nb_virt_addr;
    // Counter
    m_lid_t cnt;

    // Clear number of address in the subscription list
    p_model_io->nb_addr = 0;
   1374a:	821a      	strh	r2, [r3, #16]

    // Remove all virtual addresses
    for (cnt = M_TB_MIO_SUBS_LIST_SIZE - 1; cnt >= last_va_pos; cnt--)
   1374c:	9b01      	ldr	r3, [sp, #4]
   1374e:	42a3      	cmp	r3, r4
   13750:	d80a      	bhi.n	13768 <m_tb_mio_delete_all_subscription+0x3c>
    {
        m_tb_mio_rem_virt_addr((m_lid_t)p_model_io->subs_list[cnt]);
   13752:	003b      	movs	r3, r7
   13754:	436b      	muls	r3, r5
   13756:	191b      	adds	r3, r3, r4
   13758:	330c      	adds	r3, #12
   1375a:	005b      	lsls	r3, r3, #1
   1375c:	5cf0      	ldrb	r0, [r6, r3]

    // Clear number of address in the subscription list
    p_model_io->nb_addr = 0;

    // Remove all virtual addresses
    for (cnt = M_TB_MIO_SUBS_LIST_SIZE - 1; cnt >= last_va_pos; cnt--)
   1375e:	3c01      	subs	r4, #1
    {
        m_tb_mio_rem_virt_addr((m_lid_t)p_model_io->subs_list[cnt]);
   13760:	f7ff fccc 	bl	130fc <m_tb_mio_rem_virt_addr>

    // Clear number of address in the subscription list
    p_model_io->nb_addr = 0;

    // Remove all virtual addresses
    for (cnt = M_TB_MIO_SUBS_LIST_SIZE - 1; cnt >= last_va_pos; cnt--)
   13764:	b2e4      	uxtb	r4, r4
   13766:	e7f1      	b.n	1374c <m_tb_mio_delete_all_subscription+0x20>
    {
        m_tb_mio_rem_virt_addr((m_lid_t)p_model_io->subs_list[cnt]);
    }

    p_model_io->nb_virt_addr = 0;
   13768:	232c      	movs	r3, #44	; 0x2c
   1376a:	436b      	muls	r3, r5
   1376c:	18f6      	adds	r6, r6, r3
   1376e:	2300      	movs	r3, #0
    // Maintain list of addresses
    m_tb_mio_addr_list_rem(M_UNASSIGNED_ADDR);
    #endif //(BLE_MESH_LPN)

    // Inform the storage manager about the update
    m_tb_store_update_ind(M_TB_STORE_UPD_TYPE_SUBS_LIST, model_lid);
   13770:	0029      	movs	r1, r5
    for (cnt = M_TB_MIO_SUBS_LIST_SIZE - 1; cnt >= last_va_pos; cnt--)
    {
        m_tb_mio_rem_virt_addr((m_lid_t)p_model_io->subs_list[cnt]);
    }

    p_model_io->nb_virt_addr = 0;
   13772:	8273      	strh	r3, [r6, #18]
    // Maintain list of addresses
    m_tb_mio_addr_list_rem(M_UNASSIGNED_ADDR);
    #endif //(BLE_MESH_LPN)

    // Inform the storage manager about the update
    m_tb_store_update_ind(M_TB_STORE_UPD_TYPE_SUBS_LIST, model_lid);
   13774:	2005      	movs	r0, #5
   13776:	f001 fa4f 	bl	14c18 <m_tb_store_update_ind>
}
   1377a:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
   1377c:	100126c4 	.word	0x100126c4

00013780 <m_tb_mio_get_subscription_list_size>:

uint16_t m_tb_mio_get_subscription_list_size(m_lid_t model_lid)
{
    // Get pointer to the model information structure
    m_tb_mio_t *p_model_io = &p_m_tb_mio_env->model_ios[model_lid];
   13780:	4b04      	ldr	r3, [pc, #16]	; (13794 <m_tb_mio_get_subscription_list_size+0x14>)
   13782:	681a      	ldr	r2, [r3, #0]

    // Return length of subscription list
    return (p_model_io->nb_addr + p_model_io->nb_virt_addr);
   13784:	232c      	movs	r3, #44	; 0x2c
   13786:	4358      	muls	r0, r3
   13788:	1810      	adds	r0, r2, r0
   1378a:	8a02      	ldrh	r2, [r0, #16]
   1378c:	8a43      	ldrh	r3, [r0, #18]
   1378e:	18d0      	adds	r0, r2, r3
   13790:	b280      	uxth	r0, r0
}
   13792:	4770      	bx	lr
   13794:	100126c4 	.word	0x100126c4

00013798 <m_tb_mio_get_subscription_list_size_vaddr>:

uint16_t m_tb_mio_get_subscription_list_size_vaddr(m_lid_t model_lid)
{
    // Get pointer to the model information structure
    m_tb_mio_t *p_model_io = &p_m_tb_mio_env->model_ios[model_lid];
   13798:	4b03      	ldr	r3, [pc, #12]	; (137a8 <m_tb_mio_get_subscription_list_size_vaddr+0x10>)

    // Return number of virtual addresses in the subscription list
    return (p_model_io->nb_virt_addr);
   1379a:	681a      	ldr	r2, [r3, #0]
   1379c:	232c      	movs	r3, #44	; 0x2c
   1379e:	4358      	muls	r0, r3
   137a0:	1810      	adds	r0, r2, r0
   137a2:	8a40      	ldrh	r0, [r0, #18]
}
   137a4:	4770      	bx	lr
   137a6:	46c0      	nop			; (mov r8, r8)
   137a8:	100126c4 	.word	0x100126c4

000137ac <m_tb_mio_get_subscription_list>:

void m_tb_mio_get_subscription_list(m_lid_t model_lid, uint8_t *p_addr, bool label_uuid)
{
   137ac:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   137ae:	9200      	str	r2, [sp, #0]
    // Get pointer to the model information structure
    m_tb_mio_t *p_model_io = &p_m_tb_mio_env->model_ios[model_lid];
    // Counter
    uint16_t cnt;

    for (cnt = 0; cnt < p_model_io->nb_addr; cnt++)
   137b0:	222c      	movs	r2, #44	; 0x2c
    // Return number of virtual addresses in the subscription list
    return (p_model_io->nb_virt_addr);
}

void m_tb_mio_get_subscription_list(m_lid_t model_lid, uint8_t *p_addr, bool label_uuid)
{
   137b2:	0007      	movs	r7, r0
    // Get pointer to the model information structure
    m_tb_mio_t *p_model_io = &p_m_tb_mio_env->model_ios[model_lid];
    // Counter
    uint16_t cnt;

    for (cnt = 0; cnt < p_model_io->nb_addr; cnt++)
   137b4:	4342      	muls	r2, r0
    {
        // Copy the address
        co_write16p(p_addr, p_model_io->subs_list[cnt]);
   137b6:	2016      	movs	r0, #22
}

void m_tb_mio_get_subscription_list(m_lid_t model_lid, uint8_t *p_addr, bool label_uuid)
{
    // Get pointer to the model information structure
    m_tb_mio_t *p_model_io = &p_m_tb_mio_env->model_ios[model_lid];
   137b8:	4b1e      	ldr	r3, [pc, #120]	; (13834 <m_tb_mio_get_subscription_list+0x88>)
    // Return number of virtual addresses in the subscription list
    return (p_model_io->nb_virt_addr);
}

void m_tb_mio_get_subscription_list(m_lid_t model_lid, uint8_t *p_addr, bool label_uuid)
{
   137ba:	000c      	movs	r4, r1
    // Get pointer to the model information structure
    m_tb_mio_t *p_model_io = &p_m_tb_mio_env->model_ios[model_lid];
   137bc:	681e      	ldr	r6, [r3, #0]
    // Counter
    uint16_t cnt;

    for (cnt = 0; cnt < p_model_io->nb_addr; cnt++)
   137be:	2300      	movs	r3, #0
    {
        // Copy the address
        co_write16p(p_addr, p_model_io->subs_list[cnt]);
   137c0:	4378      	muls	r0, r7
    // Get pointer to the model information structure
    m_tb_mio_t *p_model_io = &p_m_tb_mio_env->model_ios[model_lid];
    // Counter
    uint16_t cnt;

    for (cnt = 0; cnt < p_model_io->nb_addr; cnt++)
   137c2:	18b2      	adds	r2, r6, r2
   137c4:	8a11      	ldrh	r1, [r2, #16]
   137c6:	4299      	cmp	r1, r3
   137c8:	d90a      	bls.n	137e0 <m_tb_mio_get_subscription_list+0x34>
    {
        // Copy the address
        co_write16p(p_addr, p_model_io->subs_list[cnt]);
   137ca:	18c1      	adds	r1, r0, r3
   137cc:	310c      	adds	r1, #12
   137ce:	0049      	lsls	r1, r1, #1
   137d0:	5b89      	ldrh	r1, [r1, r6]
    // Get pointer to the model information structure
    m_tb_mio_t *p_model_io = &p_m_tb_mio_env->model_ios[model_lid];
    // Counter
    uint16_t cnt;

    for (cnt = 0; cnt < p_model_io->nb_addr; cnt++)
   137d2:	3301      	adds	r3, #1
 */
__INLINE_S__ void co_write16p(void const *ptr16, uint16_t value)
{
    uint8_t *ptr=(uint8_t*)ptr16;

    *ptr++ = value&0xff;
   137d4:	7021      	strb	r1, [r4, #0]
    *ptr = (value&0xff00)>>8;
   137d6:	0a09      	lsrs	r1, r1, #8
   137d8:	7061      	strb	r1, [r4, #1]
   137da:	b29b      	uxth	r3, r3
    {
        // Copy the address
        co_write16p(p_addr, p_model_io->subs_list[cnt]);
        p_addr += sizeof(uint16_t);
   137dc:	3402      	adds	r4, #2
   137de:	e7f1      	b.n	137c4 <m_tb_mio_get_subscription_list+0x18>
    }

    for (cnt = 0; cnt < p_model_io->nb_virt_addr; cnt++)
   137e0:	232c      	movs	r3, #44	; 0x2c
   137e2:	2500      	movs	r5, #0
   137e4:	437b      	muls	r3, r7
   137e6:	18f3      	adds	r3, r6, r3
   137e8:	3312      	adds	r3, #18
   137ea:	9301      	str	r3, [sp, #4]
   137ec:	9b01      	ldr	r3, [sp, #4]
   137ee:	881b      	ldrh	r3, [r3, #0]
   137f0:	42ab      	cmp	r3, r5
   137f2:	d91e      	bls.n	13832 <m_tb_mio_get_subscription_list+0x86>
    {
        // Get virtual address local index
        m_lid_t va_lid = p_model_io->subs_list[M_TB_MIO_SUBS_LIST_SIZE - cnt - 1];
   137f4:	2216      	movs	r2, #22
   137f6:	2309      	movs	r3, #9
   137f8:	437a      	muls	r2, r7
   137fa:	1b5b      	subs	r3, r3, r5
   137fc:	18d3      	adds	r3, r2, r3
   137fe:	330c      	adds	r3, #12
   13800:	005b      	lsls	r3, r3, #1
        // Copy the address
        co_write16p(p_addr, p_m_tb_mio_env->virt_addrs[va_lid].virt_addr);
   13802:	5cf1      	ldrb	r1, [r6, r3]
   13804:	2314      	movs	r3, #20
   13806:	4359      	muls	r1, r3
   13808:	1873      	adds	r3, r6, r1
   1380a:	33b9      	adds	r3, #185	; 0xb9
   1380c:	33ff      	adds	r3, #255	; 0xff
   1380e:	881b      	ldrh	r3, [r3, #0]
 */
__INLINE_S__ void co_write16p(void const *ptr16, uint16_t value)
{
    uint8_t *ptr=(uint8_t*)ptr16;

    *ptr++ = value&0xff;
   13810:	7023      	strb	r3, [r4, #0]
    *ptr = (value&0xff00)>>8;
   13812:	0a1b      	lsrs	r3, r3, #8
   13814:	7063      	strb	r3, [r4, #1]
        p_addr += sizeof(uint16_t);
        // If required copy the associated label UUID
        if (label_uuid)
   13816:	9b00      	ldr	r3, [sp, #0]
    {
        // Get virtual address local index
        m_lid_t va_lid = p_model_io->subs_list[M_TB_MIO_SUBS_LIST_SIZE - cnt - 1];
        // Copy the address
        co_write16p(p_addr, p_m_tb_mio_env->virt_addrs[va_lid].virt_addr);
        p_addr += sizeof(uint16_t);
   13818:	3402      	adds	r4, #2
        // If required copy the associated label UUID
        if (label_uuid)
   1381a:	2b00      	cmp	r3, #0
   1381c:	d006      	beq.n	1382c <m_tb_mio_get_subscription_list+0x80>
        {
            memcpy(p_addr, &p_m_tb_mio_env->virt_addrs[va_lid].label_uuid, M_LABEL_UUID_LEN);
   1381e:	1871      	adds	r1, r6, r1
   13820:	31bb      	adds	r1, #187	; 0xbb
   13822:	31ff      	adds	r1, #255	; 0xff
   13824:	2210      	movs	r2, #16
   13826:	0020      	movs	r0, r4
   13828:	f002 f8d2 	bl	159d0 <memcpy>
        // Copy the address
        co_write16p(p_addr, p_model_io->subs_list[cnt]);
        p_addr += sizeof(uint16_t);
    }

    for (cnt = 0; cnt < p_model_io->nb_virt_addr; cnt++)
   1382c:	3501      	adds	r5, #1
   1382e:	b2ad      	uxth	r5, r5
   13830:	e7dc      	b.n	137ec <m_tb_mio_get_subscription_list+0x40>
        if (label_uuid)
        {
            memcpy(p_addr, &p_m_tb_mio_env->virt_addrs[va_lid].label_uuid, M_LABEL_UUID_LEN);
        }
    }
}
   13832:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
   13834:	100126c4 	.word	0x100126c4

00013838 <m_tb_mio_is_dest_addr>:

bool m_tb_mio_is_dest_addr(m_lid_t model_lid, uint16_t addr, m_lid_t va_lid)
{
   13838:	b570      	push	{r4, r5, r6, lr}
    bool res = false;

    if (model_lid < p_m_tb_mio_env->nb_models)
   1383a:	4b24      	ldr	r3, [pc, #144]	; (138cc <m_tb_mio_is_dest_addr+0x94>)
   1383c:	681c      	ldr	r4, [r3, #0]
   1383e:	4b24      	ldr	r3, [pc, #144]	; (138d0 <m_tb_mio_is_dest_addr+0x98>)
   13840:	5ce5      	ldrb	r5, [r4, r3]
    }
}

bool m_tb_mio_is_dest_addr(m_lid_t model_lid, uint16_t addr, m_lid_t va_lid)
{
    bool res = false;
   13842:	2300      	movs	r3, #0

    if (model_lid < p_m_tb_mio_env->nb_models)
   13844:	4285      	cmp	r5, r0
   13846:	d93e      	bls.n	138c6 <m_tb_mio_is_dest_addr+0x8e>
    {
        // Get pointer to the model information structure
        m_tb_mio_t *p_model_io = &(p_m_tb_mio_env->model_ios[model_lid]);

        if (M_IS_UNICAST_ADDR(addr))
   13848:	b20d      	sxth	r5, r1
   1384a:	429d      	cmp	r5, r3
   1384c:	db0c      	blt.n	13868 <m_tb_mio_is_dest_addr+0x30>
        {
            // Check element address
            if (addr == (p_m_tb_mio_env->prim_addr + p_model_io->addr_offset))
   1384e:	222c      	movs	r2, #44	; 0x2c
   13850:	2388      	movs	r3, #136	; 0x88
   13852:	4350      	muls	r0, r2
   13854:	009b      	lsls	r3, r3, #2
   13856:	5ae3      	ldrh	r3, [r4, r3]
   13858:	1824      	adds	r4, r4, r0
   1385a:	7da2      	ldrb	r2, [r4, #22]
   1385c:	189b      	adds	r3, r3, r2
   1385e:	1a5b      	subs	r3, r3, r1
   13860:	4259      	negs	r1, r3
   13862:	414b      	adcs	r3, r1
   13864:	b2db      	uxtb	r3, r3
   13866:	e02e      	b.n	138c6 <m_tb_mio_is_dest_addr+0x8e>
   13868:	0b8d      	lsrs	r5, r1, #14
            {
                res = true;
            }
        }
        else if (M_IS_GROUP_ADDR(addr))
   1386a:	03ae      	lsls	r6, r5, #14
   1386c:	2d03      	cmp	r5, #3
   1386e:	d10a      	bne.n	13886 <m_tb_mio_is_dest_addr+0x4e>
    bool res = false;

    if (model_lid < p_m_tb_mio_env->nb_models)
    {
        // Get pointer to the model information structure
        m_tb_mio_t *p_model_io = &(p_m_tb_mio_env->model_ios[model_lid]);
   13870:	222c      	movs	r2, #44	; 0x2c
   13872:	4350      	muls	r0, r2
   13874:	1824      	adds	r4, r4, r0
            }
        }
        else if (M_IS_GROUP_ADDR(addr))
        {
            // Look for the provided address in the subscription list
            if (m_tb_mio_subs_find_addr(p_model_io, addr) < p_model_io->nb_addr)
   13876:	0020      	movs	r0, r4
   13878:	f7ff fbb6 	bl	12fe8 <m_tb_mio_subs_find_addr>
   1387c:	8a23      	ldrh	r3, [r4, #16]
   1387e:	4298      	cmp	r0, r3
   13880:	419b      	sbcs	r3, r3
   13882:	425b      	negs	r3, r3
   13884:	e01f      	b.n	138c6 <m_tb_mio_is_dest_addr+0x8e>
            {
                res = true;
            }
        }
        else if (M_IS_VIRTUAL_ADDR(addr))
   13886:	2180      	movs	r1, #128	; 0x80
   13888:	0209      	lsls	r1, r1, #8
   1388a:	428e      	cmp	r6, r1
   1388c:	d11b      	bne.n	138c6 <m_tb_mio_is_dest_addr+0x8e>
__STATIC uint16_t m_tb_mio_subs_find_va_lid(m_tb_mio_t *p_model_io, m_lid_t va_lid)
{
    // Start at end of the subscription list
    uint16_t pos = M_TB_MIO_SUBS_LIST_SIZE;
    // Position of last virtual address in the subscription list
    uint16_t last_pos = M_TB_MIO_SUBS_LIST_SIZE - p_model_io->nb_virt_addr;
   1388e:	232c      	movs	r3, #44	; 0x2c
   13890:	4343      	muls	r3, r0
   13892:	18e3      	adds	r3, r4, r3
   13894:	8a59      	ldrh	r1, [r3, #18]
   13896:	230a      	movs	r3, #10
   13898:	1a5b      	subs	r3, r3, r1
    // Counter
    uint16_t cnt;

    for (cnt = M_TB_MIO_SUBS_LIST_SIZE - 1; cnt >= last_pos; cnt--)
    {
        if (p_model_io->subs_list[cnt] == va_lid)
   1389a:	2116      	movs	r1, #22
__STATIC uint16_t m_tb_mio_subs_find_va_lid(m_tb_mio_t *p_model_io, m_lid_t va_lid)
{
    // Start at end of the subscription list
    uint16_t pos = M_TB_MIO_SUBS_LIST_SIZE;
    // Position of last virtual address in the subscription list
    uint16_t last_pos = M_TB_MIO_SUBS_LIST_SIZE - p_model_io->nb_virt_addr;
   1389c:	b29d      	uxth	r5, r3
    // Counter
    uint16_t cnt;

    for (cnt = M_TB_MIO_SUBS_LIST_SIZE - 1; cnt >= last_pos; cnt--)
   1389e:	2309      	movs	r3, #9
    {
        if (p_model_io->subs_list[cnt] == va_lid)
   138a0:	4348      	muls	r0, r1
   138a2:	b292      	uxth	r2, r2
    // Position of last virtual address in the subscription list
    uint16_t last_pos = M_TB_MIO_SUBS_LIST_SIZE - p_model_io->nb_virt_addr;
    // Counter
    uint16_t cnt;

    for (cnt = M_TB_MIO_SUBS_LIST_SIZE - 1; cnt >= last_pos; cnt--)
   138a4:	429d      	cmp	r5, r3
   138a6:	d808      	bhi.n	138ba <m_tb_mio_is_dest_addr+0x82>
    {
        if (p_model_io->subs_list[cnt] == va_lid)
   138a8:	18c1      	adds	r1, r0, r3
   138aa:	310c      	adds	r1, #12
   138ac:	0049      	lsls	r1, r1, #1
   138ae:	5b09      	ldrh	r1, [r1, r4]
   138b0:	4291      	cmp	r1, r2
   138b2:	d003      	beq.n	138bc <m_tb_mio_is_dest_addr+0x84>
    // Position of last virtual address in the subscription list
    uint16_t last_pos = M_TB_MIO_SUBS_LIST_SIZE - p_model_io->nb_virt_addr;
    // Counter
    uint16_t cnt;

    for (cnt = M_TB_MIO_SUBS_LIST_SIZE - 1; cnt >= last_pos; cnt--)
   138b4:	3b01      	subs	r3, #1
   138b6:	b29b      	uxth	r3, r3
   138b8:	e7f4      	b.n	138a4 <m_tb_mio_is_dest_addr+0x6c>
 ****************************************************************************************
 */
__STATIC uint16_t m_tb_mio_subs_find_va_lid(m_tb_mio_t *p_model_io, m_lid_t va_lid)
{
    // Start at end of the subscription list
    uint16_t pos = M_TB_MIO_SUBS_LIST_SIZE;
   138ba:	230a      	movs	r3, #10
        else if (M_IS_VIRTUAL_ADDR(addr))
        {
            // Position of local index in the subscription list
            m_lid_t pos = m_tb_mio_subs_find_va_lid(p_model_io, va_lid);

            res = (pos != M_TB_MIO_SUBS_LIST_SIZE);
   138bc:	b2db      	uxtb	r3, r3
   138be:	3b0a      	subs	r3, #10
   138c0:	1e58      	subs	r0, r3, #1
   138c2:	4183      	sbcs	r3, r0
   138c4:	b2db      	uxtb	r3, r3
        }
    }

    return (res);
}
   138c6:	0018      	movs	r0, r3
   138c8:	bd70      	pop	{r4, r5, r6, pc}
   138ca:	46c0      	nop			; (mov r8, r8)
   138cc:	100126c4 	.word	0x100126c4
   138d0:	0000021d 	.word	0x0000021d

000138d4 <m_tb_mio_get_label_uuid>:
    m_lid_t cnt;

    for (cnt = 0; cnt < M_TB_MIO_VIRT_ADDR_LIST_SIZE; cnt++)
    {
        // Get virtual address information
        m_tb_mio_virt_addr_t *p_virt_addr = &p_m_tb_mio_env->virt_addrs[cnt];
   138d4:	4b10      	ldr	r3, [pc, #64]	; (13918 <m_tb_mio_get_label_uuid+0x44>)

    return (res);
}

m_lid_t m_tb_mio_get_label_uuid(uint16_t virt_addr, m_lid_t skip, uint8_t **pp_label_uuid)
{
   138d6:	b5f0      	push	{r4, r5, r6, r7, lr}
    m_lid_t cnt;

    for (cnt = 0; cnt < M_TB_MIO_VIRT_ADDR_LIST_SIZE; cnt++)
    {
        // Get virtual address information
        m_tb_mio_virt_addr_t *p_virt_addr = &p_m_tb_mio_env->virt_addrs[cnt];
   138d8:	681d      	ldr	r5, [r3, #0]

    return (res);
}

m_lid_t m_tb_mio_get_label_uuid(uint16_t virt_addr, m_lid_t skip, uint8_t **pp_label_uuid)
{
   138da:	0006      	movs	r6, r0
   138dc:	002c      	movs	r4, r5
    m_lid_t cnt;

    for (cnt = 0; cnt < M_TB_MIO_VIRT_ADDR_LIST_SIZE; cnt++)
    {
        // Get virtual address information
        m_tb_mio_virt_addr_t *p_virt_addr = &p_m_tb_mio_env->virt_addrs[cnt];
   138de:	2300      	movs	r3, #0
   138e0:	34b9      	adds	r4, #185	; 0xb9
   138e2:	34ff      	adds	r4, #255	; 0xff

        // Compare provided information with stored ones
        if (p_virt_addr->used_cnt && (p_virt_addr->virt_addr == virt_addr))
   138e4:	7ca7      	ldrb	r7, [r4, #18]
   138e6:	b2d8      	uxtb	r0, r3
   138e8:	2f00      	cmp	r7, #0
   138ea:	d006      	beq.n	138fa <m_tb_mio_get_label_uuid+0x26>
   138ec:	8827      	ldrh	r7, [r4, #0]
   138ee:	42b7      	cmp	r7, r6
   138f0:	d103      	bne.n	138fa <m_tb_mio_get_label_uuid+0x26>
        {
            if (skip == 0)
   138f2:	2900      	cmp	r1, #0
   138f4:	d007      	beq.n	13906 <m_tb_mio_get_label_uuid+0x32>
                va_lid = cnt;
                break;
            }
            else
            {
                skip--;
   138f6:	3901      	subs	r1, #1
   138f8:	b2c9      	uxtb	r1, r1
   138fa:	3301      	adds	r3, #1
   138fc:	3414      	adds	r4, #20
    // Virtual address local index
    m_lid_t va_lid = M_INVALID_LID;
    // Counter
    m_lid_t cnt;

    for (cnt = 0; cnt < M_TB_MIO_VIRT_ADDR_LIST_SIZE; cnt++)
   138fe:	2b05      	cmp	r3, #5
   13900:	d1f0      	bne.n	138e4 <m_tb_mio_get_label_uuid+0x10>
 ****************************************************************************************
 */
__STATIC m_lid_t m_tb_mio_find_virt_addr(uint16_t virt_addr, m_lid_t skip)
{
    // Virtual address local index
    m_lid_t va_lid = M_INVALID_LID;
   13902:	20ff      	movs	r0, #255	; 0xff
   13904:	e007      	b.n	13916 <m_tb_mio_get_label_uuid+0x42>
m_lid_t m_tb_mio_get_label_uuid(uint16_t virt_addr, m_lid_t skip, uint8_t **pp_label_uuid)
{
    // Counter
    m_lid_t cnt = m_tb_mio_find_virt_addr(virt_addr, skip);

    if ((cnt != M_INVALID_LID) && pp_label_uuid)
   13906:	2a00      	cmp	r2, #0
   13908:	d005      	beq.n	13916 <m_tb_mio_get_label_uuid+0x42>
    {
        m_tb_mio_virt_addr_t *p_virt_addr = &p_m_tb_mio_env->virt_addrs[cnt];

        *pp_label_uuid = &p_virt_addr->label_uuid[0];
   1390a:	2114      	movs	r1, #20
   1390c:	434b      	muls	r3, r1
   1390e:	18eb      	adds	r3, r5, r3
   13910:	33bb      	adds	r3, #187	; 0xbb
   13912:	33ff      	adds	r3, #255	; 0xff
   13914:	6013      	str	r3, [r2, #0]
    }

    return (cnt);
}
   13916:	bdf0      	pop	{r4, r5, r6, r7, pc}
   13918:	100126c4 	.word	0x100126c4

0001391c <m_tb_mio_bind>:

void m_tb_mio_bind(m_lid_t model_lid)
{
    // Get pointer to the model information structure
    m_tb_mio_t *p_model_io = &p_m_tb_mio_env->model_ios[model_lid];
   1391c:	4b07      	ldr	r3, [pc, #28]	; (1393c <m_tb_mio_bind+0x20>)

    return (cnt);
}

void m_tb_mio_bind(m_lid_t model_lid)
{
   1391e:	b510      	push	{r4, lr}
    // Get pointer to the model information structure
    m_tb_mio_t *p_model_io = &p_m_tb_mio_env->model_ios[model_lid];
   13920:	681a      	ldr	r2, [r3, #0]
   13922:	232c      	movs	r3, #44	; 0x2c
   13924:	4343      	muls	r3, r0
   13926:	18d3      	adds	r3, r2, r3

    return (cnt);
}

void m_tb_mio_bind(m_lid_t model_lid)
{
   13928:	0001      	movs	r1, r0
    // Get pointer to the model information structure
    m_tb_mio_t *p_model_io = &p_m_tb_mio_env->model_ios[model_lid];

    if (p_model_io)
   1392a:	2b00      	cmp	r3, #0
   1392c:	d005      	beq.n	1393a <m_tb_mio_bind+0x1e>
    {
        // Increment number of application keys bound with this model
        p_model_io->nb_bound_app++;
   1392e:	7d5a      	ldrb	r2, [r3, #21]

        // Inform the storage manager about the update
        m_tb_store_update_ind(M_TB_STORE_UPD_TYPE_BINDING, model_lid);
   13930:	2006      	movs	r0, #6
    m_tb_mio_t *p_model_io = &p_m_tb_mio_env->model_ios[model_lid];

    if (p_model_io)
    {
        // Increment number of application keys bound with this model
        p_model_io->nb_bound_app++;
   13932:	3201      	adds	r2, #1
   13934:	755a      	strb	r2, [r3, #21]

        // Inform the storage manager about the update
        m_tb_store_update_ind(M_TB_STORE_UPD_TYPE_BINDING, model_lid);
   13936:	f001 f96f 	bl	14c18 <m_tb_store_update_ind>
    }
}
   1393a:	bd10      	pop	{r4, pc}
   1393c:	100126c4 	.word	0x100126c4

00013940 <m_tb_mio_unbind>:

void m_tb_mio_unbind(m_lid_t model_lid, m_lid_t app_key_lid)
{
    // Get pointer to the model information structure
    m_tb_mio_t *p_model_io = &p_m_tb_mio_env->model_ios[model_lid];
   13940:	4b14      	ldr	r3, [pc, #80]	; (13994 <m_tb_mio_unbind+0x54>)
        m_tb_store_update_ind(M_TB_STORE_UPD_TYPE_BINDING, model_lid);
    }
}

void m_tb_mio_unbind(m_lid_t model_lid, m_lid_t app_key_lid)
{
   13942:	b530      	push	{r4, r5, lr}
    // Get pointer to the model information structure
    m_tb_mio_t *p_model_io = &p_m_tb_mio_env->model_ios[model_lid];
   13944:	681d      	ldr	r5, [r3, #0]
   13946:	232c      	movs	r3, #44	; 0x2c
   13948:	4343      	muls	r3, r0
   1394a:	18eb      	adds	r3, r5, r3
        m_tb_store_update_ind(M_TB_STORE_UPD_TYPE_BINDING, model_lid);
    }
}

void m_tb_mio_unbind(m_lid_t model_lid, m_lid_t app_key_lid)
{
   1394c:	b085      	sub	sp, #20
   1394e:	0004      	movs	r4, r0
    // Get pointer to the model information structure
    m_tb_mio_t *p_model_io = &p_m_tb_mio_env->model_ios[model_lid];

    if (p_model_io)
   13950:	2b00      	cmp	r3, #0
   13952:	d01c      	beq.n	1398e <m_tb_mio_unbind+0x4e>
    {
        // Sanity check
        ASSERT_INFO(p_model_io->nb_bound_app != 0, p_model_io->nb_bound_app, 0);
   13954:	7d5a      	ldrb	r2, [r3, #21]
   13956:	2a00      	cmp	r2, #0
   13958:	d100      	bne.n	1395c <m_tb_mio_unbind+0x1c>
   1395a:	e7fe      	b.n	1395a <m_tb_mio_unbind+0x1a>

        // Check if published messages are sent using the application key
        if ((p_model_io->publi_params.addr != M_UNASSIGNED_ADDR)
   1395c:	891a      	ldrh	r2, [r3, #8]
   1395e:	2a00      	cmp	r2, #0
   13960:	d00b      	beq.n	1397a <m_tb_mio_unbind+0x3a>
                && (app_key_lid == p_model_io->publi_params.app_key_lid))
   13962:	7a9b      	ldrb	r3, [r3, #10]
   13964:	428b      	cmp	r3, r1
   13966:	d108      	bne.n	1397a <m_tb_mio_unbind+0x3a>
        {
            // Disable publications
            m_tb_mio_set_publi_param(model_lid, M_UNASSIGNED_ADDR, NULL, M_INVALID_LID, 0, 0, 0, 0);
   13968:	2100      	movs	r1, #0
   1396a:	23ff      	movs	r3, #255	; 0xff
   1396c:	9103      	str	r1, [sp, #12]
   1396e:	9102      	str	r1, [sp, #8]
   13970:	9101      	str	r1, [sp, #4]
   13972:	9100      	str	r1, [sp, #0]
   13974:	000a      	movs	r2, r1
   13976:	f7ff fcf1 	bl	1335c <m_tb_mio_set_publi_param>
        }

        // Decrement number of application keys bound with this model
        p_model_io->nb_bound_app--;
   1397a:	232c      	movs	r3, #44	; 0x2c
   1397c:	4363      	muls	r3, r4
   1397e:	18ed      	adds	r5, r5, r3
   13980:	7d6b      	ldrb	r3, [r5, #21]

        // Inform the storage manager about the update
        m_tb_store_update_ind(M_TB_STORE_UPD_TYPE_BINDING, model_lid);
   13982:	0021      	movs	r1, r4
            // Disable publications
            m_tb_mio_set_publi_param(model_lid, M_UNASSIGNED_ADDR, NULL, M_INVALID_LID, 0, 0, 0, 0);
        }

        // Decrement number of application keys bound with this model
        p_model_io->nb_bound_app--;
   13984:	3b01      	subs	r3, #1
   13986:	756b      	strb	r3, [r5, #21]

        // Inform the storage manager about the update
        m_tb_store_update_ind(M_TB_STORE_UPD_TYPE_BINDING, model_lid);
   13988:	2006      	movs	r0, #6
   1398a:	f001 f945 	bl	14c18 <m_tb_store_update_ind>
    }
}
   1398e:	b005      	add	sp, #20
   13990:	bd30      	pop	{r4, r5, pc}
   13992:	46c0      	nop			; (mov r8, r8)
   13994:	100126c4 	.word	0x100126c4

00013998 <m_tb_mio_get_nb_bound_app>:

uint8_t m_tb_mio_get_nb_bound_app(m_lid_t model_lid)
{
    // Get pointer to the model information structure
    m_tb_mio_t *p_model_io = &p_m_tb_mio_env->model_ios[model_lid];
   13998:	4b03      	ldr	r3, [pc, #12]	; (139a8 <m_tb_mio_get_nb_bound_app+0x10>)

    // Return number of application keys currently bound with the model
    return (p_model_io->nb_bound_app);
   1399a:	681a      	ldr	r2, [r3, #0]
   1399c:	232c      	movs	r3, #44	; 0x2c
   1399e:	4358      	muls	r0, r3
   139a0:	1810      	adds	r0, r2, r0
   139a2:	7d40      	ldrb	r0, [r0, #21]
}
   139a4:	4770      	bx	lr
   139a6:	46c0      	nop			; (mov r8, r8)
   139a8:	100126c4 	.word	0x100126c4

000139ac <m_tb_mio_get_period>:

uint32_t m_tb_mio_get_period(m_lid_t model_lid)
{
    // Get pointer to the model information structure
    m_tb_mio_t *p_model_io = &p_m_tb_mio_env->model_ios[model_lid];
   139ac:	4b07      	ldr	r3, [pc, #28]	; (139cc <m_tb_mio_get_period+0x20>)

    // Return publish period in milliseconds
    return (m_tb_mio_convert_period(p_model_io->publi_params.period));
   139ae:	681a      	ldr	r2, [r3, #0]
   139b0:	232c      	movs	r3, #44	; 0x2c
   139b2:	4358      	muls	r0, r3
   139b4:	1810      	adds	r0, r2, r0
   139b6:	7b00      	ldrb	r0, [r0, #12]
   139b8:	4a05      	ldr	r2, [pc, #20]	; (139d0 <m_tb_mio_get_period+0x24>)
   139ba:	0983      	lsrs	r3, r0, #6
   139bc:	009b      	lsls	r3, r3, #2
   139be:	18d3      	adds	r3, r2, r3
   139c0:	223f      	movs	r2, #63	; 0x3f
   139c2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   139c4:	4010      	ands	r0, r2
   139c6:	4358      	muls	r0, r3
}
   139c8:	4770      	bx	lr
   139ca:	46c0      	nop			; (mov r8, r8)
   139cc:	100126c4 	.word	0x100126c4
   139d0:	00022888 	.word	0x00022888

000139d4 <m_tb_mio_set_prim_addr>:

void m_tb_mio_set_prim_addr(uint16_t prim_addr)
{
	M_PRINTF(L_TB, "prim_addr = 0x%04x", prim_addr);
   139d4:	4b12      	ldr	r3, [pc, #72]	; (13a20 <m_tb_mio_set_prim_addr+0x4c>)
    // Return publish period in milliseconds
    return (m_tb_mio_convert_period(p_model_io->publi_params.period));
}

void m_tb_mio_set_prim_addr(uint16_t prim_addr)
{
   139d6:	b573      	push	{r0, r1, r4, r5, r6, lr}
	M_PRINTF(L_TB, "prim_addr = 0x%04x", prim_addr);
   139d8:	681b      	ldr	r3, [r3, #0]
    // Return publish period in milliseconds
    return (m_tb_mio_convert_period(p_model_io->publi_params.period));
}

void m_tb_mio_set_prim_addr(uint16_t prim_addr)
{
   139da:	0005      	movs	r5, r0
	M_PRINTF(L_TB, "prim_addr = 0x%04x", prim_addr);
   139dc:	079b      	lsls	r3, r3, #30
   139de:	d515      	bpl.n	13a0c <m_tb_mio_set_prim_addr+0x38>
   139e0:	4b10      	ldr	r3, [pc, #64]	; (13a24 <m_tb_mio_set_prim_addr+0x50>)
   139e2:	4c11      	ldr	r4, [pc, #68]	; (13a28 <m_tb_mio_set_prim_addr+0x54>)
   139e4:	001a      	movs	r2, r3
   139e6:	0018      	movs	r0, r3
   139e8:	3369      	adds	r3, #105	; 0x69
   139ea:	324f      	adds	r2, #79	; 0x4f
   139ec:	9300      	str	r3, [sp, #0]
   139ee:	0021      	movs	r1, r4
   139f0:	4b0e      	ldr	r3, [pc, #56]	; (13a2c <m_tb_mio_set_prim_addr+0x58>)
   139f2:	305a      	adds	r0, #90	; 0x5a
   139f4:	f7f0 ffda 	bl	49ac <m_print>
   139f8:	4e0d      	ldr	r6, [pc, #52]	; (13a30 <m_tb_mio_set_prim_addr+0x5c>)
   139fa:	0029      	movs	r1, r5
   139fc:	0030      	movs	r0, r6
   139fe:	f7f0 ffd5 	bl	49ac <m_print>
   13a02:	0030      	movs	r0, r6
   13a04:	1da1      	adds	r1, r4, #6
   13a06:	3013      	adds	r0, #19
   13a08:	f7f0 ffd0 	bl	49ac <m_print>
    p_m_tb_mio_env->prim_addr = prim_addr;
   13a0c:	4b09      	ldr	r3, [pc, #36]	; (13a34 <m_tb_mio_set_prim_addr+0x60>)

    // Inform the storage manager about the update
    m_tb_store_update_ind(M_TB_STORE_UPD_TYPE_STATE, M_TB_STORE_TYPE_UNICAST_ADDR);
   13a0e:	2100      	movs	r1, #0
}

void m_tb_mio_set_prim_addr(uint16_t prim_addr)
{
	M_PRINTF(L_TB, "prim_addr = 0x%04x", prim_addr);
    p_m_tb_mio_env->prim_addr = prim_addr;
   13a10:	681a      	ldr	r2, [r3, #0]
   13a12:	2388      	movs	r3, #136	; 0x88
   13a14:	009b      	lsls	r3, r3, #2
   13a16:	52d5      	strh	r5, [r2, r3]

    // Inform the storage manager about the update
    m_tb_store_update_ind(M_TB_STORE_UPD_TYPE_STATE, M_TB_STORE_TYPE_UNICAST_ADDR);
   13a18:	2007      	movs	r0, #7
   13a1a:	f001 f8fd 	bl	14c18 <m_tb_store_update_ind>
}
   13a1e:	bd73      	pop	{r0, r1, r4, r5, r6, pc}
   13a20:	10010514 	.word	0x10010514
   13a24:	00022888 	.word	0x00022888
   13a28:	00022808 	.word	0x00022808
   13a2c:	0000058b 	.word	0x0000058b
   13a30:	00022908 	.word	0x00022908
   13a34:	100126c4 	.word	0x100126c4

00013a38 <m_tb_mio_get_prim_addr>:

uint16_t m_tb_mio_get_prim_addr(void)
{
    return (p_m_tb_mio_env->prim_addr);
   13a38:	4b02      	ldr	r3, [pc, #8]	; (13a44 <m_tb_mio_get_prim_addr+0xc>)
   13a3a:	681a      	ldr	r2, [r3, #0]
   13a3c:	2388      	movs	r3, #136	; 0x88
   13a3e:	009b      	lsls	r3, r3, #2
   13a40:	5ad0      	ldrh	r0, [r2, r3]
}
   13a42:	4770      	bx	lr
   13a44:	100126c4 	.word	0x100126c4

00013a48 <m_tb_mio_is_local_addr>:

bool m_tb_mio_is_local_addr(uint16_t addr)
{
    // Return if provided address is address of a known element
    return ((addr >= p_m_tb_mio_env->prim_addr) &&
   13a48:	4b0a      	ldr	r3, [pc, #40]	; (13a74 <m_tb_mio_is_local_addr+0x2c>)
{
    return (p_m_tb_mio_env->prim_addr);
}

bool m_tb_mio_is_local_addr(uint16_t addr)
{
   13a4a:	b510      	push	{r4, lr}
    // Return if provided address is address of a known element
    return ((addr >= p_m_tb_mio_env->prim_addr) &&
   13a4c:	6819      	ldr	r1, [r3, #0]
   13a4e:	2388      	movs	r3, #136	; 0x88
   13a50:	009b      	lsls	r3, r3, #2
   13a52:	5acb      	ldrh	r3, [r1, r3]
   13a54:	2200      	movs	r2, #0
   13a56:	4283      	cmp	r3, r0
   13a58:	d807      	bhi.n	13a6a <m_tb_mio_is_local_addr+0x22>
            (addr < (p_m_tb_mio_env->prim_addr + p_m_tb_mio_env->nb_elements)));
   13a5a:	4c07      	ldr	r4, [pc, #28]	; (13a78 <m_tb_mio_is_local_addr+0x30>)
}

bool m_tb_mio_is_local_addr(uint16_t addr)
{
    // Return if provided address is address of a known element
    return ((addr >= p_m_tb_mio_env->prim_addr) &&
   13a5c:	5d09      	ldrb	r1, [r1, r4]
   13a5e:	18cb      	adds	r3, r1, r3
   13a60:	2101      	movs	r1, #1
   13a62:	4298      	cmp	r0, r3
   13a64:	db00      	blt.n	13a68 <m_tb_mio_is_local_addr+0x20>
   13a66:	0011      	movs	r1, r2
   13a68:	000a      	movs	r2, r1
   13a6a:	2301      	movs	r3, #1
   13a6c:	401a      	ands	r2, r3
   13a6e:	0010      	movs	r0, r2
            (addr < (p_m_tb_mio_env->prim_addr + p_m_tb_mio_env->nb_elements)));
}
   13a70:	bd10      	pop	{r4, pc}
   13a72:	46c0      	nop			; (mov r8, r8)
   13a74:	100126c4 	.word	0x100126c4
   13a78:	0000021e 	.word	0x0000021e

00013a7c <m_tb_mio_get_vaddr>:

uint8_t *m_tb_mio_get_vaddr(m_lid_t va_lid)
{
    return (&p_m_tb_mio_env->virt_addrs[va_lid].label_uuid[0]);
   13a7c:	2314      	movs	r3, #20
   13a7e:	4358      	muls	r0, r3
   13a80:	4b02      	ldr	r3, [pc, #8]	; (13a8c <m_tb_mio_get_vaddr+0x10>)
   13a82:	681b      	ldr	r3, [r3, #0]
   13a84:	1818      	adds	r0, r3, r0
   13a86:	30bb      	adds	r0, #187	; 0xbb
   13a88:	30ff      	adds	r0, #255	; 0xff
}
   13a8a:	4770      	bx	lr
   13a8c:	100126c4 	.word	0x100126c4

00013a90 <m_tb_mio_get_nb_elements>:

uint8_t m_tb_mio_get_nb_elements(void)
{
    return (p_m_tb_mio_env->nb_elements);
   13a90:	4b02      	ldr	r3, [pc, #8]	; (13a9c <m_tb_mio_get_nb_elements+0xc>)
   13a92:	681a      	ldr	r2, [r3, #0]
   13a94:	4b02      	ldr	r3, [pc, #8]	; (13aa0 <m_tb_mio_get_nb_elements+0x10>)
   13a96:	5cd0      	ldrb	r0, [r2, r3]
}
   13a98:	4770      	bx	lr
   13a9a:	46c0      	nop			; (mov r8, r8)
   13a9c:	100126c4 	.word	0x100126c4
   13aa0:	0000021e 	.word	0x0000021e

00013aa4 <m_tb_mio_get_nb_models>:
{
    // Counter
    uint8_t cnt;

    // Initialize provided values
    *p_nb_sig_models = 0;
   13aa4:	2300      	movs	r3, #0
{
    return (p_m_tb_mio_env->nb_elements);
}

void m_tb_mio_get_nb_models(uint8_t *p_nb_sig_models, uint8_t *p_nb_vendor_models)
{
   13aa6:	b5f0      	push	{r4, r5, r6, r7, lr}
    for (cnt = 0; cnt < p_m_tb_mio_env->nb_models; cnt++)
    {
        // Get Model information
        m_tb_mio_t *p_model_io = &p_m_tb_mio_env->model_ios[cnt];

        if (GETB(p_model_io->status, M_TB_MIO_MODEL_ID_VENDOR))
   13aa8:	262c      	movs	r6, #44	; 0x2c
   13aaa:	2702      	movs	r7, #2
    // Initialize provided values
    *p_nb_sig_models = 0;
    *p_nb_vendor_models = 0;

    // Loop over registered Models
    for (cnt = 0; cnt < p_m_tb_mio_env->nb_models; cnt++)
   13aac:	4a0c      	ldr	r2, [pc, #48]	; (13ae0 <m_tb_mio_get_nb_models+0x3c>)
   13aae:	4d0d      	ldr	r5, [pc, #52]	; (13ae4 <m_tb_mio_get_nb_models+0x40>)
   13ab0:	6814      	ldr	r4, [r2, #0]
{
    // Counter
    uint8_t cnt;

    // Initialize provided values
    *p_nb_sig_models = 0;
   13ab2:	7003      	strb	r3, [r0, #0]
    *p_nb_vendor_models = 0;
   13ab4:	700b      	strb	r3, [r1, #0]

    // Loop over registered Models
    for (cnt = 0; cnt < p_m_tb_mio_env->nb_models; cnt++)
   13ab6:	5d62      	ldrb	r2, [r4, r5]
   13ab8:	429a      	cmp	r2, r3
   13aba:	d90f      	bls.n	13adc <m_tb_mio_get_nb_models+0x38>
    {
        // Get Model information
        m_tb_mio_t *p_model_io = &p_m_tb_mio_env->model_ios[cnt];

        if (GETB(p_model_io->status, M_TB_MIO_MODEL_ID_VENDOR))
   13abc:	0032      	movs	r2, r6
   13abe:	435a      	muls	r2, r3
   13ac0:	18a2      	adds	r2, r4, r2
   13ac2:	7d12      	ldrb	r2, [r2, #20]
   13ac4:	423a      	tst	r2, r7
   13ac6:	d003      	beq.n	13ad0 <m_tb_mio_get_nb_models+0x2c>
        {
            (*p_nb_vendor_models)++;
   13ac8:	780a      	ldrb	r2, [r1, #0]
   13aca:	3201      	adds	r2, #1
   13acc:	700a      	strb	r2, [r1, #0]
   13ace:	e002      	b.n	13ad6 <m_tb_mio_get_nb_models+0x32>
        }
        else
        {
            (*p_nb_sig_models)++;
   13ad0:	7802      	ldrb	r2, [r0, #0]
   13ad2:	3201      	adds	r2, #1
   13ad4:	7002      	strb	r2, [r0, #0]
    // Initialize provided values
    *p_nb_sig_models = 0;
    *p_nb_vendor_models = 0;

    // Loop over registered Models
    for (cnt = 0; cnt < p_m_tb_mio_env->nb_models; cnt++)
   13ad6:	3301      	adds	r3, #1
   13ad8:	b2db      	uxtb	r3, r3
   13ada:	e7ec      	b.n	13ab6 <m_tb_mio_get_nb_models+0x12>
        else
        {
            (*p_nb_sig_models)++;
        }
    }
}
   13adc:	bdf0      	pop	{r4, r5, r6, r7, pc}
   13ade:	46c0      	nop			; (mov r8, r8)
   13ae0:	100126c4 	.word	0x100126c4
   13ae4:	0000021d 	.word	0x0000021d

00013ae8 <m_tb_mio_get_model_ids>:
{
    // Counter
    uint8_t cnt;

    // Loop over registered Models
    for (cnt = 0; cnt < p_m_tb_mio_env->nb_models; cnt++)
   13ae8:	4b13      	ldr	r3, [pc, #76]	; (13b38 <m_tb_mio_get_model_ids+0x50>)
        }
    }
}

void m_tb_mio_get_model_ids(uint8_t *p_data, bool vendor)
{
   13aea:	b5f0      	push	{r4, r5, r6, r7, lr}
    // Counter
    uint8_t cnt;

    // Loop over registered Models
    for (cnt = 0; cnt < p_m_tb_mio_env->nb_models; cnt++)
   13aec:	681c      	ldr	r4, [r3, #0]
   13aee:	252c      	movs	r5, #44	; 0x2c
   13af0:	2300      	movs	r3, #0
                p_data += 2;
            }
        }
        else
        {
            if (GETB(p_model_io->status, M_TB_MIO_MODEL_ID_VENDOR))
   13af2:	2602      	movs	r6, #2
{
    // Counter
    uint8_t cnt;

    // Loop over registered Models
    for (cnt = 0; cnt < p_m_tb_mio_env->nb_models; cnt++)
   13af4:	4a11      	ldr	r2, [pc, #68]	; (13b3c <m_tb_mio_get_model_ids+0x54>)
   13af6:	5ca2      	ldrb	r2, [r4, r2]
   13af8:	429a      	cmp	r2, r3
   13afa:	d91b      	bls.n	13b34 <m_tb_mio_get_model_ids+0x4c>
        // Get Model information
        m_tb_mio_t *p_model_io = &p_m_tb_mio_env->model_ios[cnt];

        if (!vendor)
        {
            if (!GETB(p_model_io->status, M_TB_MIO_MODEL_ID_VENDOR))
   13afc:	002a      	movs	r2, r5
   13afe:	435a      	muls	r2, r3
   13b00:	18a7      	adds	r7, r4, r2
   13b02:	7d3f      	ldrb	r7, [r7, #20]
    for (cnt = 0; cnt < p_m_tb_mio_env->nb_models; cnt++)
    {
        // Get Model information
        m_tb_mio_t *p_model_io = &p_m_tb_mio_env->model_ios[cnt];

        if (!vendor)
   13b04:	2900      	cmp	r1, #0
   13b06:	d107      	bne.n	13b18 <m_tb_mio_get_model_ids+0x30>
        {
            if (!GETB(p_model_io->status, M_TB_MIO_MODEL_ID_VENDOR))
   13b08:	4237      	tst	r7, r6
   13b0a:	d110      	bne.n	13b2e <m_tb_mio_get_model_ids+0x46>
            {
                // Write SIG Model ID
                co_write16p(p_data, p_model_io->model_id);
   13b0c:	5912      	ldr	r2, [r2, r4]
 */
__INLINE_S__ void co_write16p(void const *ptr16, uint16_t value)
{
    uint8_t *ptr=(uint8_t*)ptr16;

    *ptr++ = value&0xff;
   13b0e:	7002      	strb	r2, [r0, #0]
    *ptr = (value&0xff00)>>8;
   13b10:	0a12      	lsrs	r2, r2, #8
   13b12:	7042      	strb	r2, [r0, #1]
                p_data += 2;
   13b14:	3002      	adds	r0, #2
   13b16:	e00a      	b.n	13b2e <m_tb_mio_get_model_ids+0x46>
            }
        }
        else
        {
            if (GETB(p_model_io->status, M_TB_MIO_MODEL_ID_VENDOR))
   13b18:	4237      	tst	r7, r6
   13b1a:	d008      	beq.n	13b2e <m_tb_mio_get_model_ids+0x46>
            {
                // Write Vendor Model ID
                co_write32p(p_data, p_model_io->model_id);
   13b1c:	5912      	ldr	r2, [r2, r4]
__INLINE_S__ void co_write32p(void const *ptr32, uint32_t value)
{
    uint8_t *ptr=(uint8_t*)ptr32;

    *ptr++ = (uint8_t)(value&0xff);
    *ptr++ = (uint8_t)((value&0xff00)>>8);
   13b1e:	0a17      	lsrs	r7, r2, #8
 */
__INLINE_S__ void co_write32p(void const *ptr32, uint32_t value)
{
    uint8_t *ptr=(uint8_t*)ptr32;

    *ptr++ = (uint8_t)(value&0xff);
   13b20:	7002      	strb	r2, [r0, #0]
    *ptr++ = (uint8_t)((value&0xff00)>>8);
   13b22:	7047      	strb	r7, [r0, #1]
    *ptr++ = (uint8_t)((value&0xff0000)>>16);
   13b24:	0c17      	lsrs	r7, r2, #16
    *ptr = (uint8_t)((value&0xff000000)>>24);
   13b26:	0e12      	lsrs	r2, r2, #24
{
    uint8_t *ptr=(uint8_t*)ptr32;

    *ptr++ = (uint8_t)(value&0xff);
    *ptr++ = (uint8_t)((value&0xff00)>>8);
    *ptr++ = (uint8_t)((value&0xff0000)>>16);
   13b28:	7087      	strb	r7, [r0, #2]
    *ptr = (uint8_t)((value&0xff000000)>>24);
   13b2a:	70c2      	strb	r2, [r0, #3]
                p_data += 4;
   13b2c:	3004      	adds	r0, #4
{
    // Counter
    uint8_t cnt;

    // Loop over registered Models
    for (cnt = 0; cnt < p_m_tb_mio_env->nb_models; cnt++)
   13b2e:	3301      	adds	r3, #1
   13b30:	b2db      	uxtb	r3, r3
   13b32:	e7df      	b.n	13af4 <m_tb_mio_get_model_ids+0xc>
                co_write32p(p_data, p_model_io->model_id);
                p_data += 4;
            }
        }
    }
}
   13b34:	bdf0      	pop	{r4, r5, r6, r7, pc}
   13b36:	46c0      	nop			; (mov r8, r8)
   13b38:	100126c4 	.word	0x100126c4
   13b3c:	0000021d 	.word	0x0000021d

00013b40 <m_tb_mio_app_key_rem_ind>:
    return (status);
}
#endif //(BLE_MESH_LPN)

void m_tb_mio_app_key_rem_ind(m_lid_t app_key_lid)
{
   13b40:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
   13b42:	0005      	movs	r5, r0
    // Counter
    m_lid_t cnt;

    for (cnt = 0; cnt < p_m_tb_mio_env->nb_models; cnt++)
   13b44:	2400      	movs	r4, #0
    {
        // Get model information
        m_tb_mio_t *p_model_io = &p_m_tb_mio_env->model_ios[cnt];

        if ((p_model_io->publi_params.addr != M_UNASSIGNED_ADDR)
   13b46:	262c      	movs	r6, #44	; 0x2c
void m_tb_mio_app_key_rem_ind(m_lid_t app_key_lid)
{
    // Counter
    m_lid_t cnt;

    for (cnt = 0; cnt < p_m_tb_mio_env->nb_models; cnt++)
   13b48:	4b0e      	ldr	r3, [pc, #56]	; (13b84 <m_tb_mio_app_key_rem_ind+0x44>)
   13b4a:	681a      	ldr	r2, [r3, #0]
   13b4c:	4b0e      	ldr	r3, [pc, #56]	; (13b88 <m_tb_mio_app_key_rem_ind+0x48>)
   13b4e:	5cd3      	ldrb	r3, [r2, r3]
   13b50:	42a3      	cmp	r3, r4
   13b52:	d915      	bls.n	13b80 <m_tb_mio_app_key_rem_ind+0x40>
    {
        // Get model information
        m_tb_mio_t *p_model_io = &p_m_tb_mio_env->model_ios[cnt];

        if ((p_model_io->publi_params.addr != M_UNASSIGNED_ADDR)
   13b54:	0033      	movs	r3, r6
   13b56:	4363      	muls	r3, r4
   13b58:	18d3      	adds	r3, r2, r3
   13b5a:	891a      	ldrh	r2, [r3, #8]
   13b5c:	2a00      	cmp	r2, #0
   13b5e:	d00c      	beq.n	13b7a <m_tb_mio_app_key_rem_ind+0x3a>
                && (app_key_lid == p_model_io->publi_params.app_key_lid))
   13b60:	7a9b      	ldrb	r3, [r3, #10]
   13b62:	42ab      	cmp	r3, r5
   13b64:	d109      	bne.n	13b7a <m_tb_mio_app_key_rem_ind+0x3a>
        {
            // Disable publications
            m_tb_mio_set_publi_param(cnt, M_UNASSIGNED_ADDR, NULL, M_INVALID_LID, 0, 0, 0, 0);
   13b66:	2100      	movs	r1, #0
   13b68:	23ff      	movs	r3, #255	; 0xff
   13b6a:	9103      	str	r1, [sp, #12]
   13b6c:	9102      	str	r1, [sp, #8]
   13b6e:	9101      	str	r1, [sp, #4]
   13b70:	9100      	str	r1, [sp, #0]
   13b72:	000a      	movs	r2, r1
   13b74:	0020      	movs	r0, r4
   13b76:	f7ff fbf1 	bl	1335c <m_tb_mio_set_publi_param>
void m_tb_mio_app_key_rem_ind(m_lid_t app_key_lid)
{
    // Counter
    m_lid_t cnt;

    for (cnt = 0; cnt < p_m_tb_mio_env->nb_models; cnt++)
   13b7a:	3401      	adds	r4, #1
   13b7c:	b2e4      	uxtb	r4, r4
   13b7e:	e7e3      	b.n	13b48 <m_tb_mio_app_key_rem_ind+0x8>
        {
            // Disable publications
            m_tb_mio_set_publi_param(cnt, M_UNASSIGNED_ADDR, NULL, M_INVALID_LID, 0, 0, 0, 0);
        }
    }
}
   13b80:	bd7f      	pop	{r0, r1, r2, r3, r4, r5, r6, pc}
   13b82:	46c0      	nop			; (mov r8, r8)
   13b84:	100126c4 	.word	0x100126c4
   13b88:	0000021d 	.word	0x0000021d

00013b8c <m_tb_sec_ready_rand_cb>:
 */
__STATIC uint16_t m_tb_sec_ready_rand_cb(uint8_t token_id)
{
    // Nothing to do - not used
    return (M_ERR_NO_ERROR);
}
   13b8c:	2000      	movs	r0, #0
   13b8e:	4770      	bx	lr

00013b90 <m_tb_sec_func_end_handler>:
 *                      (@note length is variable and depends on security function used)
 *                      (@note equals NULL for AES-CCM encrypt and decrypt functions)
 ****************************************************************************************
 */
__STATIC void m_tb_sec_func_end_handler(uint16_t status, const uint8_t* p_enc_val)
{
   13b90:	b5f0      	push	{r4, r5, r6, r7, lr}
    m_tb_sec_env_t* p_env = p_m_tb_sec_env;
   13b92:	4b19      	ldr	r3, [pc, #100]	; (13bf8 <m_tb_sec_func_end_handler+0x68>)
 *                      (@note length is variable and depends on security function used)
 *                      (@note equals NULL for AES-CCM encrypt and decrypt functions)
 ****************************************************************************************
 */
__STATIC void m_tb_sec_func_end_handler(uint16_t status, const uint8_t* p_enc_val)
{
   13b94:	b085      	sub	sp, #20
    m_tb_sec_env_t* p_env = p_m_tb_sec_env;
   13b96:	681e      	ldr	r6, [r3, #0]
 *                      (@note length is variable and depends on security function used)
 *                      (@note equals NULL for AES-CCM encrypt and decrypt functions)
 ****************************************************************************************
 */
__STATIC void m_tb_sec_func_end_handler(uint16_t status, const uint8_t* p_enc_val)
{
   13b98:	9003      	str	r0, [sp, #12]
    m_tb_sec_env_t* p_env = p_m_tb_sec_env;
    m_tb_sec_token_t* p_token = (m_tb_sec_token_t*) co_list_pop_front(&(p_env->wait_tokens));
   13b9a:	0030      	movs	r0, r6
   13b9c:	3078      	adds	r0, #120	; 0x78
 *                      (@note length is variable and depends on security function used)
 *                      (@note equals NULL for AES-CCM encrypt and decrypt functions)
 ****************************************************************************************
 */
__STATIC void m_tb_sec_func_end_handler(uint16_t status, const uint8_t* p_enc_val)
{
   13b9e:	000f      	movs	r7, r1
    m_tb_sec_env_t* p_env = p_m_tb_sec_env;
    m_tb_sec_token_t* p_token = (m_tb_sec_token_t*) co_list_pop_front(&(p_env->wait_tokens));
   13ba0:	f7f0 fc24 	bl	43ec <co_list_pop_front>
	M_PRINTF(L_TB, "p_token = %p token_id = 0x%02x", p_token, p_token->token_id);
   13ba4:	4b15      	ldr	r3, [pc, #84]	; (13bfc <m_tb_sec_func_end_handler+0x6c>)
 ****************************************************************************************
 */
__STATIC void m_tb_sec_func_end_handler(uint16_t status, const uint8_t* p_enc_val)
{
    m_tb_sec_env_t* p_env = p_m_tb_sec_env;
    m_tb_sec_token_t* p_token = (m_tb_sec_token_t*) co_list_pop_front(&(p_env->wait_tokens));
   13ba6:	0005      	movs	r5, r0
	M_PRINTF(L_TB, "p_token = %p token_id = 0x%02x", p_token, p_token->token_id);
   13ba8:	681b      	ldr	r3, [r3, #0]
   13baa:	079b      	lsls	r3, r3, #30
   13bac:	d516      	bpl.n	13bdc <m_tb_sec_func_end_handler+0x4c>
   13bae:	4c14      	ldr	r4, [pc, #80]	; (13c00 <m_tb_sec_func_end_handler+0x70>)
   13bb0:	0023      	movs	r3, r4
   13bb2:	0022      	movs	r2, r4
   13bb4:	0020      	movs	r0, r4
   13bb6:	333a      	adds	r3, #58	; 0x3a
   13bb8:	3220      	adds	r2, #32
   13bba:	9300      	str	r3, [sp, #0]
   13bbc:	0021      	movs	r1, r4
   13bbe:	2395      	movs	r3, #149	; 0x95
   13bc0:	302b      	adds	r0, #43	; 0x2b
   13bc2:	f7f0 fef3 	bl	49ac <m_print>
   13bc6:	0020      	movs	r0, r4
   13bc8:	0029      	movs	r1, r5
   13bca:	7b2a      	ldrb	r2, [r5, #12]
   13bcc:	3054      	adds	r0, #84	; 0x54
   13bce:	f7f0 feed 	bl	49ac <m_print>
   13bd2:	0020      	movs	r0, r4
   13bd4:	1da1      	adds	r1, r4, #6
   13bd6:	3073      	adds	r0, #115	; 0x73
   13bd8:	f7f0 fee8 	bl	49ac <m_print>
	// mark the function execution over
    p_token->func_type = M_TB_SEC_NONE;
   13bdc:	2400      	movs	r4, #0
    // inform requester about end of Security function execution
    p_token->cb_finished(p_token->token_id, status, p_enc_val);
   13bde:	7b28      	ldrb	r0, [r5, #12]
   13be0:	68ab      	ldr	r3, [r5, #8]
   13be2:	003a      	movs	r2, r7
   13be4:	9903      	ldr	r1, [sp, #12]
{
    m_tb_sec_env_t* p_env = p_m_tb_sec_env;
    m_tb_sec_token_t* p_token = (m_tb_sec_token_t*) co_list_pop_front(&(p_env->wait_tokens));
	M_PRINTF(L_TB, "p_token = %p token_id = 0x%02x", p_token, p_token->token_id);
	// mark the function execution over
    p_token->func_type = M_TB_SEC_NONE;
   13be6:	736c      	strb	r4, [r5, #13]
    // inform requester about end of Security function execution
    p_token->cb_finished(p_token->token_id, status, p_enc_val);
   13be8:	4798      	blx	r3
    // Mark Security toolbox available
    p_env->busy = false;
   13bea:	0033      	movs	r3, r6
   13bec:	3380      	adds	r3, #128	; 0x80
   13bee:	701c      	strb	r4, [r3, #0]

    // Execute Security function in wait state
    m_tb_sec_execute();
   13bf0:	f000 f818 	bl	13c24 <m_tb_sec_execute>
}
   13bf4:	b005      	add	sp, #20
   13bf6:	bdf0      	pop	{r4, r5, r6, r7, pc}
   13bf8:	100126c8 	.word	0x100126c8
   13bfc:	10010514 	.word	0x10010514
   13c00:	0002291e 	.word	0x0002291e

00013c04 <m_tb_sec_aes_res_cb>:
 *
 * @param[in] aes_res      16 bytes block result
 ****************************************************************************************
 */
__STATIC void m_tb_sec_aes_res_cb(const uint8_t* p_aes_res)
{
   13c04:	b510      	push	{r4, lr}
   13c06:	0001      	movs	r1, r0
    m_tb_sec_func_end_handler(M_ERR_NO_ERROR, p_aes_res);
   13c08:	2000      	movs	r0, #0
   13c0a:	f7ff ffc1 	bl	13b90 <m_tb_sec_func_end_handler>
}
   13c0e:	bd10      	pop	{r4, pc}

00013c10 <m_tb_sec_aes_ccm_cb>:
 * @param[in] mic_error  True if a MIC error detected when Decipher, False else
 *                       In case of MIC error output message is considered invalid
 ****************************************************************************************
 */
__STATIC void m_tb_sec_aes_ccm_cb (bool mic_error)
{
   13c10:	b510      	push	{r4, lr}
    m_tb_sec_func_end_handler(mic_error ? M_ERR_MIC_ERROR : M_ERR_NO_ERROR, NULL);
   13c12:	2800      	cmp	r0, #0
   13c14:	d000      	beq.n	13c18 <m_tb_sec_aes_ccm_cb+0x8>
   13c16:	4802      	ldr	r0, [pc, #8]	; (13c20 <m_tb_sec_aes_ccm_cb+0x10>)
   13c18:	2100      	movs	r1, #0
   13c1a:	f7ff ffb9 	bl	13b90 <m_tb_sec_func_end_handler>
}
   13c1e:	bd10      	pop	{r4, pc}
   13c20:	00000382 	.word	0x00000382

00013c24 <m_tb_sec_execute>:
 ****************************************************************************************
 * @brief Process Execution of an security function
 ****************************************************************************************
 */
__STATIC void m_tb_sec_execute(void)
{
   13c24:	b5f0      	push	{r4, r5, r6, r7, lr}
    uint16_t          status = M_ERR_NO_ERROR;
    m_tb_sec_env_t*   p_env  = p_m_tb_sec_env;
   13c26:	4b70      	ldr	r3, [pc, #448]	; (13de8 <m_tb_sec_execute+0x1c4>)
 ****************************************************************************************
 * @brief Process Execution of an security function
 ****************************************************************************************
 */
__STATIC void m_tb_sec_execute(void)
{
   13c28:	b08d      	sub	sp, #52	; 0x34
    uint16_t          status = M_ERR_NO_ERROR;
    m_tb_sec_env_t*   p_env  = p_m_tb_sec_env;
   13c2a:	681e      	ldr	r6, [r3, #0]
   13c2c:	6fb5      	ldr	r5, [r6, #120]	; 0x78
    m_tb_sec_token_t* p_token;

    while(!co_list_is_empty(&(p_env->wait_tokens)))
   13c2e:	2d00      	cmp	r5, #0
   13c30:	d100      	bne.n	13c34 <m_tb_sec_execute+0x10>
   13c32:	e0d7      	b.n	13de4 <m_tb_sec_execute+0x1c0>
    {
        // Get information of token to execute
        p_token = (m_tb_sec_token_t*) co_list_pick(&(p_env->wait_tokens));
        // Mark execution busy
        p_env->busy = true;
   13c34:	0033      	movs	r3, r6
   13c36:	2201      	movs	r2, #1
   13c38:	3380      	adds	r3, #128	; 0x80
   13c3a:	701a      	strb	r2, [r3, #0]

        switch(p_token->func_type)
   13c3c:	7b6a      	ldrb	r2, [r5, #13]
   13c3e:	1e50      	subs	r0, r2, #1
   13c40:	2809      	cmp	r0, #9
   13c42:	d900      	bls.n	13c46 <m_tb_sec_execute+0x22>
   13c44:	e0be      	b.n	13dc4 <m_tb_sec_execute+0x1a0>
   13c46:	7b2c      	ldrb	r4, [r5, #12]
   13c48:	f00a f884 	bl	1dd54 <__gnu_thumb1_case_uqi>
   13c4c:	24241305 	.word	0x24241305
   13c50:	9d8d7567 	.word	0x9d8d7567
   13c54:	b3a8      	.short	0xb3a8
            {
                const uint8_t* p_key;
                const uint8_t* p_val;

                // request execution parameters
                status = ((m_tb_sec_aes_ready_cb)p_token->cb_ready)(p_token->token_id, &p_key, &p_val);
   13c56:	0020      	movs	r0, r4
   13c58:	aa0b      	add	r2, sp, #44	; 0x2c
   13c5a:	a90a      	add	r1, sp, #40	; 0x28
   13c5c:	686b      	ldr	r3, [r5, #4]
   13c5e:	4798      	blx	r3
   13c60:	1e04      	subs	r4, r0, #0

                // Start execution of the function
                if(status == M_ERR_NO_ERROR)
   13c62:	d000      	beq.n	13c66 <m_tb_sec_execute+0x42>
   13c64:	e0af      	b.n	13dc6 <m_tb_sec_execute+0x1a2>
                {
                    m_al_sec_aes(p_key, p_val, m_tb_sec_aes_res_cb);
   13c66:	4a61      	ldr	r2, [pc, #388]	; (13dec <m_tb_sec_execute+0x1c8>)
   13c68:	990b      	ldr	r1, [sp, #44]	; 0x2c
   13c6a:	980a      	ldr	r0, [sp, #40]	; 0x28
   13c6c:	f7f1 f8ab 	bl	4dc6 <m_al_sec_aes>
                }
            } break;
   13c70:	e0b8      	b.n	13de4 <m_tb_sec_execute+0x1c0>
            {
                const uint8_t* p_key;
                const uint8_t* p_msg;
                uint16_t       msg_len;

                status = ((m_tb_sec_cmac_ready_cb)p_token->cb_ready)(p_token->token_id, &p_key, &p_msg, &msg_len);
   13c72:	af09      	add	r7, sp, #36	; 0x24
   13c74:	0020      	movs	r0, r4
   13c76:	003b      	movs	r3, r7
   13c78:	686c      	ldr	r4, [r5, #4]
   13c7a:	aa0b      	add	r2, sp, #44	; 0x2c
   13c7c:	a90a      	add	r1, sp, #40	; 0x28
   13c7e:	47a0      	blx	r4
   13c80:	1e04      	subs	r4, r0, #0

                // Start execution of the function
                if(status == M_ERR_NO_ERROR)
   13c82:	d000      	beq.n	13c86 <m_tb_sec_execute+0x62>
   13c84:	e09f      	b.n	13dc6 <m_tb_sec_execute+0x1a2>
                {
                    m_al_sec_aes_cmac(p_key, p_msg, msg_len, m_tb_sec_aes_res_cb);
   13c86:	883a      	ldrh	r2, [r7, #0]
   13c88:	4b58      	ldr	r3, [pc, #352]	; (13dec <m_tb_sec_execute+0x1c8>)
   13c8a:	990b      	ldr	r1, [sp, #44]	; 0x2c
   13c8c:	980a      	ldr	r0, [sp, #40]	; 0x28
   13c8e:	f7f1 f8f5 	bl	4e7c <m_al_sec_aes_cmac>
                }
            } break;
   13c92:	e0a7      	b.n	13de4 <m_tb_sec_execute+0x1c0>
   13c94:	ab0b      	add	r3, sp, #44	; 0x2c
                uint8_t        mic_len;
                uint8_t        auth_data_len;
                bool           cipher;

                // request execution parameters
                if(p_token->func_type == M_TB_SEC_CCM_ENC)
   13c96:	2a03      	cmp	r2, #3
   13c98:	d113      	bne.n	13cc2 <m_tb_sec_execute+0x9e>
                {
                    cipher = true;
                    status =  ((m_tb_sec_ccm_enc_ready_cb)p_token->cb_ready)(p_token->token_id, &p_key, &p_nonce,
   13c9a:	3216      	adds	r2, #22
   13c9c:	446a      	add	r2, sp
   13c9e:	9204      	str	r2, [sp, #16]
   13ca0:	aa0a      	add	r2, sp, #40	; 0x28
   13ca2:	9203      	str	r2, [sp, #12]
   13ca4:	aa06      	add	r2, sp, #24
   13ca6:	9202      	str	r2, [sp, #8]
   13ca8:	221a      	movs	r2, #26
   13caa:	446a      	add	r2, sp
   13cac:	9201      	str	r2, [sp, #4]
   13cae:	9300      	str	r3, [sp, #0]
   13cb0:	0020      	movs	r0, r4
   13cb2:	ab09      	add	r3, sp, #36	; 0x24
   13cb4:	686c      	ldr	r4, [r5, #4]
   13cb6:	aa08      	add	r2, sp, #32
   13cb8:	a907      	add	r1, sp, #28
   13cba:	47a0      	blx	r4
                bool           cipher;

                // request execution parameters
                if(p_token->func_type == M_TB_SEC_CCM_ENC)
                {
                    cipher = true;
   13cbc:	2301      	movs	r3, #1
                    status =  ((m_tb_sec_ccm_enc_ready_cb)p_token->cb_ready)(p_token->token_id, &p_key, &p_nonce,
   13cbe:	0004      	movs	r4, r0
   13cc0:	e012      	b.n	13ce8 <m_tb_sec_execute+0xc4>
                                                                             &p_auth_data, &auth_data_len);
                }
                else
                {
                    cipher = false;
                    status = ((m_tb_sec_ccm_dec_ready_cb)p_token->cb_ready)(p_token->token_id, &p_key, &p_nonce,
   13cc2:	2219      	movs	r2, #25
   13cc4:	446a      	add	r2, sp
   13cc6:	9204      	str	r2, [sp, #16]
   13cc8:	aa0a      	add	r2, sp, #40	; 0x28
   13cca:	9203      	str	r2, [sp, #12]
   13ccc:	aa06      	add	r2, sp, #24
   13cce:	9202      	str	r2, [sp, #8]
   13cd0:	221a      	movs	r2, #26
   13cd2:	446a      	add	r2, sp
   13cd4:	9201      	str	r2, [sp, #4]
   13cd6:	9300      	str	r3, [sp, #0]
   13cd8:	0020      	movs	r0, r4
   13cda:	ab09      	add	r3, sp, #36	; 0x24
   13cdc:	686c      	ldr	r4, [r5, #4]
   13cde:	aa08      	add	r2, sp, #32
   13ce0:	a907      	add	r1, sp, #28
   13ce2:	47a0      	blx	r4
                                                                             &p_in_msg, &p_out_msg, &msg_len, &mic_len,
                                                                             &p_auth_data, &auth_data_len);
                }
                else
                {
                    cipher = false;
   13ce4:	2300      	movs	r3, #0
                    status = ((m_tb_sec_ccm_dec_ready_cb)p_token->cb_ready)(p_token->token_id, &p_key, &p_nonce,
   13ce6:	0004      	movs	r4, r0
                                                                            &p_in_msg, &p_out_msg, &msg_len, &mic_len,
                                                                            &p_auth_data, &auth_data_len);
                }

                // Start execution of the function
                if(status == M_ERR_NO_ERROR)
   13ce8:	2c00      	cmp	r4, #0
   13cea:	d16c      	bne.n	13dc6 <m_tb_sec_execute+0x1a2>
                {
                    m_al_sec_aes_ccm(p_key, p_nonce, p_in_msg, p_out_msg, msg_len, mic_len, cipher, p_auth_data,
   13cec:	4a40      	ldr	r2, [pc, #256]	; (13df0 <m_tb_sec_execute+0x1cc>)
   13cee:	9908      	ldr	r1, [sp, #32]
   13cf0:	9205      	str	r2, [sp, #20]
   13cf2:	2219      	movs	r2, #25
   13cf4:	446a      	add	r2, sp
   13cf6:	7812      	ldrb	r2, [r2, #0]
   13cf8:	9302      	str	r3, [sp, #8]
   13cfa:	9204      	str	r2, [sp, #16]
   13cfc:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   13cfe:	ab06      	add	r3, sp, #24
   13d00:	9203      	str	r2, [sp, #12]
   13d02:	781b      	ldrb	r3, [r3, #0]
   13d04:	9a09      	ldr	r2, [sp, #36]	; 0x24
   13d06:	9301      	str	r3, [sp, #4]
   13d08:	231a      	movs	r3, #26
   13d0a:	446b      	add	r3, sp
   13d0c:	881b      	ldrh	r3, [r3, #0]
   13d0e:	9807      	ldr	r0, [sp, #28]
   13d10:	9300      	str	r3, [sp, #0]
   13d12:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   13d14:	f7f1 fa72 	bl	51fc <m_al_sec_aes_ccm>
                                     auth_data_len, m_tb_sec_aes_ccm_cb);
                }
            } break;
   13d18:	e064      	b.n	13de4 <m_tb_sec_execute+0x1c0>
            case M_TB_SEC_S1:
            {
                const uint8_t* p_msg;
                uint8_t        msg_len;

                status = ((m_tb_sec_s1_ready_cb) p_token->cb_ready)(p_token->token_id, &p_msg, &msg_len);
   13d1a:	af0a      	add	r7, sp, #40	; 0x28
   13d1c:	0020      	movs	r0, r4
   13d1e:	003a      	movs	r2, r7
   13d20:	a90b      	add	r1, sp, #44	; 0x2c
   13d22:	686b      	ldr	r3, [r5, #4]
   13d24:	4798      	blx	r3
   13d26:	1e04      	subs	r4, r0, #0

                // Start execution of the function
                if(status == M_ERR_NO_ERROR)
   13d28:	d14d      	bne.n	13dc6 <m_tb_sec_execute+0x1a2>
                {
                    m_al_sec_aes_s1(p_msg, msg_len, m_tb_sec_aes_res_cb);
   13d2a:	7839      	ldrb	r1, [r7, #0]
   13d2c:	4a2f      	ldr	r2, [pc, #188]	; (13dec <m_tb_sec_execute+0x1c8>)
   13d2e:	980b      	ldr	r0, [sp, #44]	; 0x2c
   13d30:	f7f1 f8e0 	bl	4ef4 <m_al_sec_aes_s1>
                }
            }break;
   13d34:	e056      	b.n	13de4 <m_tb_sec_execute+0x1c0>
                const uint8_t* p_n;
                const uint8_t* p_p;
                uint8_t n_len;
                uint8_t p_len;

                status = ((m_tb_sec_k1_ready_cb) p_token->cb_ready)(p_token->token_id, &p_salt, &p_n, &n_len, &p_p, &p_len);
   13d36:	ab0b      	add	r3, sp, #44	; 0x2c
   13d38:	af08      	add	r7, sp, #32
   13d3a:	9300      	str	r3, [sp, #0]
   13d3c:	9701      	str	r7, [sp, #4]
   13d3e:	0020      	movs	r0, r4
   13d40:	ab07      	add	r3, sp, #28
   13d42:	686c      	ldr	r4, [r5, #4]
   13d44:	aa0a      	add	r2, sp, #40	; 0x28
   13d46:	a909      	add	r1, sp, #36	; 0x24
   13d48:	47a0      	blx	r4
   13d4a:	1e04      	subs	r4, r0, #0

                // Start execution of the function
                if(status == M_ERR_NO_ERROR)
   13d4c:	d13b      	bne.n	13dc6 <m_tb_sec_execute+0x1a2>
                {
                    m_al_sec_aes_k1(p_salt, p_n, n_len, p_p, p_len, m_tb_sec_aes_res_cb);
   13d4e:	466b      	mov	r3, sp
   13d50:	7f1a      	ldrb	r2, [r3, #28]
   13d52:	4b26      	ldr	r3, [pc, #152]	; (13dec <m_tb_sec_execute+0x1c8>)
   13d54:	990a      	ldr	r1, [sp, #40]	; 0x28
   13d56:	9301      	str	r3, [sp, #4]
   13d58:	783b      	ldrb	r3, [r7, #0]
   13d5a:	9809      	ldr	r0, [sp, #36]	; 0x24
   13d5c:	9300      	str	r3, [sp, #0]
   13d5e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   13d60:	f7f1 f914 	bl	4f8c <m_al_sec_aes_k1>
                }
            }break;
   13d64:	e03e      	b.n	13de4 <m_tb_sec_execute+0x1c0>
            {
                const uint8_t* p_n;
                const uint8_t* p_p;
                uint8_t p_len;

                status = ((m_tb_sec_k2_ready_cb) p_token->cb_ready)(p_token->token_id, &p_n, &p_p, &p_len);
   13d66:	af09      	add	r7, sp, #36	; 0x24
   13d68:	0020      	movs	r0, r4
   13d6a:	003b      	movs	r3, r7
   13d6c:	686c      	ldr	r4, [r5, #4]
   13d6e:	aa0b      	add	r2, sp, #44	; 0x2c
   13d70:	a90a      	add	r1, sp, #40	; 0x28
   13d72:	47a0      	blx	r4
   13d74:	1e04      	subs	r4, r0, #0

                // Start execution of the function
                if(status == M_ERR_NO_ERROR)
   13d76:	d126      	bne.n	13dc6 <m_tb_sec_execute+0x1a2>
                {
                    m_al_sec_aes_k2(p_n, p_p, p_len, m_tb_sec_aes_res_cb);
   13d78:	783a      	ldrb	r2, [r7, #0]
   13d7a:	4b1c      	ldr	r3, [pc, #112]	; (13dec <m_tb_sec_execute+0x1c8>)
   13d7c:	990b      	ldr	r1, [sp, #44]	; 0x2c
   13d7e:	980a      	ldr	r0, [sp, #40]	; 0x28
   13d80:	f7f1 f97a 	bl	5078 <m_al_sec_aes_k2>
                }
            }break;
   13d84:	e02e      	b.n	13de4 <m_tb_sec_execute+0x1c0>
            /// k3 function
            case M_TB_SEC_K3:
            {
                const uint8_t* p_n;

                status = ((m_tb_sec_k3_ready_cb) p_token->cb_ready)(p_token->token_id, &p_n);
   13d86:	0020      	movs	r0, r4
   13d88:	a90b      	add	r1, sp, #44	; 0x2c
   13d8a:	686b      	ldr	r3, [r5, #4]
   13d8c:	4798      	blx	r3
   13d8e:	1e04      	subs	r4, r0, #0

                // Start execution of the function
                if(status == M_ERR_NO_ERROR)
   13d90:	d119      	bne.n	13dc6 <m_tb_sec_execute+0x1a2>
                {
                    m_al_sec_aes_k3(p_n, m_tb_sec_aes_res_cb);
   13d92:	4916      	ldr	r1, [pc, #88]	; (13dec <m_tb_sec_execute+0x1c8>)
   13d94:	980b      	ldr	r0, [sp, #44]	; 0x2c
   13d96:	f7f1 f9cb 	bl	5130 <m_al_sec_aes_k3>
                }
            }break;
   13d9a:	e023      	b.n	13de4 <m_tb_sec_execute+0x1c0>
            /// k4 function
            case M_TB_SEC_K4:
            {
                const uint8_t* p_n;

                status = ((m_tb_sec_k4_ready_cb) p_token->cb_ready)(p_token->token_id, &p_n);
   13d9c:	0020      	movs	r0, r4
   13d9e:	a90b      	add	r1, sp, #44	; 0x2c
   13da0:	686b      	ldr	r3, [r5, #4]
   13da2:	4798      	blx	r3
   13da4:	1e04      	subs	r4, r0, #0

                // Start execution of the function
                if(status == M_ERR_NO_ERROR)
   13da6:	d10e      	bne.n	13dc6 <m_tb_sec_execute+0x1a2>
                {
                    m_al_sec_aes_k4(p_n, m_tb_sec_aes_res_cb);
   13da8:	4910      	ldr	r1, [pc, #64]	; (13dec <m_tb_sec_execute+0x1c8>)
   13daa:	980b      	ldr	r0, [sp, #44]	; 0x2c
   13dac:	f7f1 f9fe 	bl	51ac <m_al_sec_aes_k4>
                }
            }break;
   13db0:	e018      	b.n	13de4 <m_tb_sec_execute+0x1c0>

            /// Random function
            case M_TB_SEC_RAND:
            {
                status = p_token->cb_ready(p_token->token_id);
   13db2:	0020      	movs	r0, r4
   13db4:	686b      	ldr	r3, [r5, #4]
   13db6:	4798      	blx	r3
   13db8:	1e04      	subs	r4, r0, #0

                // Start execution of the function
                if(status == M_ERR_NO_ERROR)
   13dba:	d104      	bne.n	13dc6 <m_tb_sec_execute+0x1a2>
                {
                    m_al_sec_rand(m_tb_sec_aes_res_cb);
   13dbc:	480b      	ldr	r0, [pc, #44]	; (13dec <m_tb_sec_execute+0x1c8>)
   13dbe:	f7f1 f84b 	bl	4e58 <m_al_sec_rand>
   13dc2:	e00f      	b.n	13de4 <m_tb_sec_execute+0x1c0>
   13dc4:	e7fe      	b.n	13dc4 <m_tb_sec_execute+0x1a0>

        // an error occurs consider action done
        if(status != M_ERR_NO_ERROR)
        {
            // remove current token from wait list
            co_list_pop_front(&(p_env->wait_tokens));
   13dc6:	0030      	movs	r0, r6
            // mark the function execution over
            p_token->func_type = M_TB_SEC_NONE;
   13dc8:	2700      	movs	r7, #0

        // an error occurs consider action done
        if(status != M_ERR_NO_ERROR)
        {
            // remove current token from wait list
            co_list_pop_front(&(p_env->wait_tokens));
   13dca:	3078      	adds	r0, #120	; 0x78
   13dcc:	f7f0 fb0e 	bl	43ec <co_list_pop_front>
            // mark the function execution over
            p_token->func_type = M_TB_SEC_NONE;
            // inform requester about end of Security function execution - with error
            p_token->cb_finished(p_token->token_id, status, NULL);
   13dd0:	68ab      	ldr	r3, [r5, #8]
        if(status != M_ERR_NO_ERROR)
        {
            // remove current token from wait list
            co_list_pop_front(&(p_env->wait_tokens));
            // mark the function execution over
            p_token->func_type = M_TB_SEC_NONE;
   13dd2:	736f      	strb	r7, [r5, #13]
            // inform requester about end of Security function execution - with error
            p_token->cb_finished(p_token->token_id, status, NULL);
   13dd4:	7b28      	ldrb	r0, [r5, #12]
   13dd6:	003a      	movs	r2, r7
   13dd8:	0021      	movs	r1, r4
   13dda:	4798      	blx	r3
            // Mark Security toolbox available
            p_env->busy = false;
   13ddc:	0033      	movs	r3, r6
   13dde:	3380      	adds	r3, #128	; 0x80
   13de0:	701f      	strb	r7, [r3, #0]
   13de2:	e723      	b.n	13c2c <m_tb_sec_execute+0x8>
        else
        {
            break;
        }
    }
}
   13de4:	b00d      	add	sp, #52	; 0x34
   13de6:	bdf0      	pop	{r4, r5, r6, r7, pc}
   13de8:	100126c8 	.word	0x100126c8
   13dec:	00013c05 	.word	0x00013c05
   13df0:	00013c11 	.word	0x00013c11

00013df4 <m_tb_sec_start>:
 * @return Status of function execution request (@see enum m_error)
 ****************************************************************************************
 */
__STATIC uint16_t m_tb_sec_start(uint8_t token_id, uint8_t func_type, m_tb_sec_ready_cb cb_ready,
                                 m_tb_sec_finished_cb cb_finished)
{
   13df4:	b5f0      	push	{r4, r5, r6, r7, lr}
   13df6:	b085      	sub	sp, #20
   13df8:	9303      	str	r3, [sp, #12]
    uint16_t status       = M_ERR_INVALID_PARAM;
    m_tb_sec_env_t* p_env = p_m_tb_sec_env;
   13dfa:	4b4b      	ldr	r3, [pc, #300]	; (13f28 <m_tb_sec_start+0x134>)
 * @return Status of function execution request (@see enum m_error)
 ****************************************************************************************
 */
__STATIC uint16_t m_tb_sec_start(uint8_t token_id, uint8_t func_type, m_tb_sec_ready_cb cb_ready,
                                 m_tb_sec_finished_cb cb_finished)
{
   13dfc:	0004      	movs	r4, r0
    uint16_t status       = M_ERR_INVALID_PARAM;
    m_tb_sec_env_t* p_env = p_m_tb_sec_env;
   13dfe:	681d      	ldr	r5, [r3, #0]
	M_PRINTF(L_TB, "token_id = %d func_type = %d", token_id, func_type);
   13e00:	4b4a      	ldr	r3, [pc, #296]	; (13f2c <m_tb_sec_start+0x138>)
 * @return Status of function execution request (@see enum m_error)
 ****************************************************************************************
 */
__STATIC uint16_t m_tb_sec_start(uint8_t token_id, uint8_t func_type, m_tb_sec_ready_cb cb_ready,
                                 m_tb_sec_finished_cb cb_finished)
{
   13e02:	000e      	movs	r6, r1
    uint16_t status       = M_ERR_INVALID_PARAM;
    m_tb_sec_env_t* p_env = p_m_tb_sec_env;
	M_PRINTF(L_TB, "token_id = %d func_type = %d", token_id, func_type);
   13e04:	681b      	ldr	r3, [r3, #0]
 * @return Status of function execution request (@see enum m_error)
 ****************************************************************************************
 */
__STATIC uint16_t m_tb_sec_start(uint8_t token_id, uint8_t func_type, m_tb_sec_ready_cb cb_ready,
                                 m_tb_sec_finished_cb cb_finished)
{
   13e06:	9202      	str	r2, [sp, #8]
    uint16_t status       = M_ERR_INVALID_PARAM;
    m_tb_sec_env_t* p_env = p_m_tb_sec_env;
	M_PRINTF(L_TB, "token_id = %d func_type = %d", token_id, func_type);
   13e08:	079b      	lsls	r3, r3, #30
   13e0a:	d517      	bpl.n	13e3c <m_tb_sec_start+0x48>
   13e0c:	4f48      	ldr	r7, [pc, #288]	; (13f30 <m_tb_sec_start+0x13c>)
   13e0e:	003b      	movs	r3, r7
   13e10:	3376      	adds	r3, #118	; 0x76
   13e12:	9300      	str	r3, [sp, #0]
   13e14:	003a      	movs	r2, r7
   13e16:	0038      	movs	r0, r7
   13e18:	23ca      	movs	r3, #202	; 0xca
   13e1a:	3220      	adds	r2, #32
   13e1c:	005b      	lsls	r3, r3, #1
   13e1e:	0039      	movs	r1, r7
   13e20:	302b      	adds	r0, #43	; 0x2b
   13e22:	f7f0 fdc3 	bl	49ac <m_print>
   13e26:	4843      	ldr	r0, [pc, #268]	; (13f34 <m_tb_sec_start+0x140>)
   13e28:	0021      	movs	r1, r4
   13e2a:	0032      	movs	r2, r6
   13e2c:	3005      	adds	r0, #5
   13e2e:	f7f0 fdbd 	bl	49ac <m_print>
   13e32:	0038      	movs	r0, r7
   13e34:	1db9      	adds	r1, r7, #6
   13e36:	3073      	adds	r0, #115	; 0x73
   13e38:	f7f0 fdb8 	bl	49ac <m_print>
    if((token_id < M_TB_SEC_TOKEN_MAX) && (cb_ready != NULL) && (cb_finished != NULL))
   13e3c:	2c06      	cmp	r4, #6
   13e3e:	d86c      	bhi.n	13f1a <m_tb_sec_start+0x126>
   13e40:	9b02      	ldr	r3, [sp, #8]
   13e42:	2b00      	cmp	r3, #0
   13e44:	d069      	beq.n	13f1a <m_tb_sec_start+0x126>
   13e46:	9b03      	ldr	r3, [sp, #12]
   13e48:	2b00      	cmp	r3, #0
   13e4a:	d066      	beq.n	13f1a <m_tb_sec_start+0x126>
    {
        m_tb_sec_token_t* p_token = &(p_env->tokens[token_id]);
        // ensure that function isn't busy or on wait queue
        if(p_token->func_type != M_TB_SEC_NONE)
   13e4c:	0124      	lsls	r4, r4, #4
   13e4e:	192b      	adds	r3, r5, r4
   13e50:	7b59      	ldrb	r1, [r3, #13]
   13e52:	4a36      	ldr	r2, [pc, #216]	; (13f2c <m_tb_sec_start+0x138>)
   13e54:	2302      	movs	r3, #2
        {
            status = M_ERR_BUSY;
			M_PRINTF(L_TB, "ERR M_TB_SEC_NONE");
   13e56:	6812      	ldr	r2, [r2, #0]
	M_PRINTF(L_TB, "token_id = %d func_type = %d", token_id, func_type);
    if((token_id < M_TB_SEC_TOKEN_MAX) && (cb_ready != NULL) && (cb_finished != NULL))
    {
        m_tb_sec_token_t* p_token = &(p_env->tokens[token_id]);
        // ensure that function isn't busy or on wait queue
        if(p_token->func_type != M_TB_SEC_NONE)
   13e58:	2900      	cmp	r1, #0
   13e5a:	d019      	beq.n	13e90 <m_tb_sec_start+0x9c>
        {
            status = M_ERR_BUSY;
			M_PRINTF(L_TB, "ERR M_TB_SEC_NONE");
   13e5c:	421a      	tst	r2, r3
   13e5e:	d05f      	beq.n	13f20 <m_tb_sec_start+0x12c>
   13e60:	4c33      	ldr	r4, [pc, #204]	; (13f30 <m_tb_sec_start+0x13c>)
   13e62:	0023      	movs	r3, r4
   13e64:	3376      	adds	r3, #118	; 0x76
   13e66:	0022      	movs	r2, r4
   13e68:	0020      	movs	r0, r4
   13e6a:	9300      	str	r3, [sp, #0]
   13e6c:	23ce      	movs	r3, #206	; 0xce
   13e6e:	0021      	movs	r1, r4
   13e70:	3220      	adds	r2, #32
   13e72:	005b      	lsls	r3, r3, #1
   13e74:	302b      	adds	r0, #43	; 0x2b
   13e76:	f7f0 fd99 	bl	49ac <m_print>
   13e7a:	482e      	ldr	r0, [pc, #184]	; (13f34 <m_tb_sec_start+0x140>)
   13e7c:	3022      	adds	r0, #34	; 0x22
   13e7e:	f7f0 fd95 	bl	49ac <m_print>
   13e82:	0020      	movs	r0, r4
   13e84:	1da1      	adds	r1, r4, #6
   13e86:	3073      	adds	r0, #115	; 0x73
   13e88:	f7f0 fd90 	bl	49ac <m_print>
    {
        m_tb_sec_token_t* p_token = &(p_env->tokens[token_id]);
        // ensure that function isn't busy or on wait queue
        if(p_token->func_type != M_TB_SEC_NONE)
        {
            status = M_ERR_BUSY;
   13e8c:	4c2a      	ldr	r4, [pc, #168]	; (13f38 <m_tb_sec_start+0x144>)
   13e8e:	e048      	b.n	13f22 <m_tb_sec_start+0x12e>
			M_PRINTF(L_TB, "ERR M_TB_SEC_NONE");
        }
        else
        {
        	M_PRINTF(L_TB, "M_TB_SEC_NONE");
   13e90:	421a      	tst	r2, r3
   13e92:	d015      	beq.n	13ec0 <m_tb_sec_start+0xcc>
   13e94:	4f26      	ldr	r7, [pc, #152]	; (13f30 <m_tb_sec_start+0x13c>)
   13e96:	003b      	movs	r3, r7
   13e98:	3376      	adds	r3, #118	; 0x76
   13e9a:	9300      	str	r3, [sp, #0]
   13e9c:	003a      	movs	r2, r7
   13e9e:	0038      	movs	r0, r7
   13ea0:	23d0      	movs	r3, #208	; 0xd0
   13ea2:	0039      	movs	r1, r7
   13ea4:	3220      	adds	r2, #32
   13ea6:	005b      	lsls	r3, r3, #1
   13ea8:	302b      	adds	r0, #43	; 0x2b
   13eaa:	f7f0 fd7f 	bl	49ac <m_print>
   13eae:	4821      	ldr	r0, [pc, #132]	; (13f34 <m_tb_sec_start+0x140>)
   13eb0:	3034      	adds	r0, #52	; 0x34
   13eb2:	f7f0 fd7b 	bl	49ac <m_print>
   13eb6:	0038      	movs	r0, r7
   13eb8:	1db9      	adds	r1, r7, #6
   13eba:	3073      	adds	r0, #115	; 0x73
   13ebc:	f7f0 fd76 	bl	49ac <m_print>
            p_token->func_type   = func_type;
            p_token->cb_ready    = cb_ready;
            p_token->cb_finished = cb_finished;

            // push function at end of security list
            co_list_push_back(&(p_env->wait_tokens), &(p_token->hdr));
   13ec0:	0028      	movs	r0, r5
        else
        {
        	M_PRINTF(L_TB, "M_TB_SEC_NONE");
            // copy token settings
            p_token->func_type   = func_type;
            p_token->cb_ready    = cb_ready;
   13ec2:	9b02      	ldr	r3, [sp, #8]
        }
        else
        {
        	M_PRINTF(L_TB, "M_TB_SEC_NONE");
            // copy token settings
            p_token->func_type   = func_type;
   13ec4:	1929      	adds	r1, r5, r4
            p_token->cb_ready    = cb_ready;
   13ec6:	604b      	str	r3, [r1, #4]
            p_token->cb_finished = cb_finished;
   13ec8:	9b03      	ldr	r3, [sp, #12]
        }
        else
        {
        	M_PRINTF(L_TB, "M_TB_SEC_NONE");
            // copy token settings
            p_token->func_type   = func_type;
   13eca:	734e      	strb	r6, [r1, #13]
            p_token->cb_ready    = cb_ready;
            p_token->cb_finished = cb_finished;
   13ecc:	608b      	str	r3, [r1, #8]

            // push function at end of security list
            co_list_push_back(&(p_env->wait_tokens), &(p_token->hdr));
   13ece:	3078      	adds	r0, #120	; 0x78
   13ed0:	f7f0 fa61 	bl	4396 <co_list_push_back>
			M_PRINTF(L_TB, "busy = %d", p_env->busy);
   13ed4:	4b15      	ldr	r3, [pc, #84]	; (13f2c <m_tb_sec_start+0x138>)
   13ed6:	3580      	adds	r5, #128	; 0x80
   13ed8:	681b      	ldr	r3, [r3, #0]
   13eda:	079b      	lsls	r3, r3, #30
   13edc:	d516      	bpl.n	13f0c <m_tb_sec_start+0x118>
   13ede:	4c14      	ldr	r4, [pc, #80]	; (13f30 <m_tb_sec_start+0x13c>)
   13ee0:	0023      	movs	r3, r4
   13ee2:	3376      	adds	r3, #118	; 0x76
   13ee4:	9300      	str	r3, [sp, #0]
   13ee6:	0022      	movs	r2, r4
   13ee8:	0020      	movs	r0, r4
   13eea:	23d4      	movs	r3, #212	; 0xd4
   13eec:	3220      	adds	r2, #32
   13eee:	005b      	lsls	r3, r3, #1
   13ef0:	0021      	movs	r1, r4
   13ef2:	302b      	adds	r0, #43	; 0x2b
   13ef4:	f7f0 fd5a 	bl	49ac <m_print>
   13ef8:	480e      	ldr	r0, [pc, #56]	; (13f34 <m_tb_sec_start+0x140>)
   13efa:	7829      	ldrb	r1, [r5, #0]
   13efc:	3042      	adds	r0, #66	; 0x42
   13efe:	f7f0 fd55 	bl	49ac <m_print>
   13f02:	0020      	movs	r0, r4
   13f04:	1da1      	adds	r1, r4, #6
   13f06:	3073      	adds	r0, #115	; 0x73
   13f08:	f7f0 fd50 	bl	49ac <m_print>
            {
                m_tb_sec_execute();
            }
			

            status = M_ERR_NO_ERROR;
   13f0c:	2400      	movs	r4, #0

            // push function at end of security list
            co_list_push_back(&(p_env->wait_tokens), &(p_token->hdr));
			M_PRINTF(L_TB, "busy = %d", p_env->busy);
            // check if function can be immediately executed
            if(!p_env->busy)
   13f0e:	782b      	ldrb	r3, [r5, #0]
   13f10:	42a3      	cmp	r3, r4
   13f12:	d106      	bne.n	13f22 <m_tb_sec_start+0x12e>
            {
                m_tb_sec_execute();
   13f14:	f7ff fe86 	bl	13c24 <m_tb_sec_execute>
   13f18:	e003      	b.n	13f22 <m_tb_sec_start+0x12e>
 ****************************************************************************************
 */
__STATIC uint16_t m_tb_sec_start(uint8_t token_id, uint8_t func_type, m_tb_sec_ready_cb cb_ready,
                                 m_tb_sec_finished_cb cb_finished)
{
    uint16_t status       = M_ERR_INVALID_PARAM;
   13f1a:	24c1      	movs	r4, #193	; 0xc1
   13f1c:	0064      	lsls	r4, r4, #1
   13f1e:	e000      	b.n	13f22 <m_tb_sec_start+0x12e>
    {
        m_tb_sec_token_t* p_token = &(p_env->tokens[token_id]);
        // ensure that function isn't busy or on wait queue
        if(p_token->func_type != M_TB_SEC_NONE)
        {
            status = M_ERR_BUSY;
   13f20:	4c05      	ldr	r4, [pc, #20]	; (13f38 <m_tb_sec_start+0x144>)
            status = M_ERR_NO_ERROR;
        }
    }

    return (status);
}
   13f22:	0020      	movs	r0, r4
   13f24:	b005      	add	sp, #20
   13f26:	bdf0      	pop	{r4, r5, r6, r7, pc}
   13f28:	100126c8 	.word	0x100126c8
   13f2c:	10010514 	.word	0x10010514
   13f30:	0002291e 	.word	0x0002291e
   13f34:	0002299e 	.word	0x0002299e
   13f38:	00000482 	.word	0x00000482

00013f3c <m_tb_sec_get_env_size>:
 */

uint16_t m_tb_sec_get_env_size(const m_cfg_t* p_cfg)
{
    return (sizeof(m_tb_sec_env_t));
}
   13f3c:	2084      	movs	r0, #132	; 0x84
   13f3e:	4770      	bx	lr

00013f40 <m_tb_sec_init>:

uint16_t m_tb_sec_init(bool reset, void* p_env, const m_cfg_t* p_cfg)
{
   13f40:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   13f42:	0004      	movs	r4, r0
   13f44:	000d      	movs	r5, r1
    // initialization
    if(!reset)
   13f46:	2800      	cmp	r0, #0
   13f48:	d11c      	bne.n	13f84 <m_tb_sec_init+0x44>
        uint8_t i;
        m_tb_sec_token_t* p_token;
        m_tb_sec_env_t* p_sec_env = (m_tb_sec_env_t*) p_env;

        // Initialize Environment variables
        co_list_init(&(p_sec_env->free_tokens));
   13f4a:	000f      	movs	r7, r1
   13f4c:	3770      	adds	r7, #112	; 0x70
   13f4e:	0038      	movs	r0, r7
   13f50:	f7f0 f9e6 	bl	4320 <co_list_init>
        co_list_init(&(p_sec_env->wait_tokens));
   13f54:	0028      	movs	r0, r5
   13f56:	3078      	adds	r0, #120	; 0x78
   13f58:	f7f0 f9e2 	bl	4320 <co_list_init>
   13f5c:	002e      	movs	r6, r5
        for(i = 0 ; i < M_TB_SEC_TOKEN_MAX ; i++)
        {
            p_token = &(p_sec_env->tokens[i]);
            p_token->func_type = M_TB_SEC_NONE;
   13f5e:	2300      	movs	r3, #0
            p_token->token_id  = i;
   13f60:	7334      	strb	r4, [r6, #12]
        m_tb_sec_env_t* p_sec_env = (m_tb_sec_env_t*) p_env;

        // Initialize Environment variables
        co_list_init(&(p_sec_env->free_tokens));
        co_list_init(&(p_sec_env->wait_tokens));
        for(i = 0 ; i < M_TB_SEC_TOKEN_MAX ; i++)
   13f62:	3401      	adds	r4, #1
        {
            p_token = &(p_sec_env->tokens[i]);
            p_token->func_type = M_TB_SEC_NONE;
   13f64:	7373      	strb	r3, [r6, #13]
            p_token->token_id  = i;

            co_list_push_back(&(p_sec_env->free_tokens), &(p_token->hdr));
   13f66:	0031      	movs	r1, r6
   13f68:	0038      	movs	r0, r7
        m_tb_sec_env_t* p_sec_env = (m_tb_sec_env_t*) p_env;

        // Initialize Environment variables
        co_list_init(&(p_sec_env->free_tokens));
        co_list_init(&(p_sec_env->wait_tokens));
        for(i = 0 ; i < M_TB_SEC_TOKEN_MAX ; i++)
   13f6a:	b2e4      	uxtb	r4, r4
        {
            p_token = &(p_sec_env->tokens[i]);
            p_token->func_type = M_TB_SEC_NONE;
            p_token->token_id  = i;

            co_list_push_back(&(p_sec_env->free_tokens), &(p_token->hdr));
   13f6c:	f7f0 fa13 	bl	4396 <co_list_push_back>
   13f70:	3610      	adds	r6, #16
        m_tb_sec_env_t* p_sec_env = (m_tb_sec_env_t*) p_env;

        // Initialize Environment variables
        co_list_init(&(p_sec_env->free_tokens));
        co_list_init(&(p_sec_env->wait_tokens));
        for(i = 0 ; i < M_TB_SEC_TOKEN_MAX ; i++)
   13f72:	2c07      	cmp	r4, #7
   13f74:	d1f3      	bne.n	13f5e <m_tb_sec_init+0x1e>
            p_token->func_type = M_TB_SEC_NONE;
            p_token->token_id  = i;

            co_list_push_back(&(p_sec_env->free_tokens), &(p_token->hdr));
        }
        p_sec_env->busy = false;
   13f76:	002b      	movs	r3, r5
   13f78:	2200      	movs	r2, #0
   13f7a:	3380      	adds	r3, #128	; 0x80
   13f7c:	701a      	strb	r2, [r3, #0]

        // Keep toolbox environment variable into a cache
        p_m_tb_sec_env = p_sec_env;
   13f7e:	4b04      	ldr	r3, [pc, #16]	; (13f90 <m_tb_sec_init+0x50>)
   13f80:	601d      	str	r5, [r3, #0]
   13f82:	e002      	b.n	13f8a <m_tb_sec_init+0x4a>
    }
    else
    {
        p_m_tb_sec_env = NULL;
   13f84:	2200      	movs	r2, #0
   13f86:	4b02      	ldr	r3, [pc, #8]	; (13f90 <m_tb_sec_init+0x50>)
   13f88:	601a      	str	r2, [r3, #0]
    }
    return (sizeof(m_tb_sec_env_t));
}
   13f8a:	2084      	movs	r0, #132	; 0x84
   13f8c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   13f8e:	46c0      	nop			; (mov r8, r8)
   13f90:	100126c8 	.word	0x100126c8

00013f94 <m_tb_sec_aes_start>:

uint16_t m_tb_sec_aes_start(uint8_t token_id, m_tb_sec_aes_ready_cb cb_ready, m_tb_sec_finished_cb cb_finished)
{
   13f94:	b510      	push	{r4, lr}
   13f96:	0013      	movs	r3, r2
	return m_tb_sec_start(token_id, M_TB_SEC_AES, (m_tb_sec_ready_cb) cb_ready, cb_finished);
   13f98:	000a      	movs	r2, r1
   13f9a:	2101      	movs	r1, #1
   13f9c:	f7ff ff2a 	bl	13df4 <m_tb_sec_start>
}
   13fa0:	bd10      	pop	{r4, pc}

00013fa2 <m_tb_sec_cmac_start>:

uint16_t m_tb_sec_cmac_start(uint8_t token_id, m_tb_sec_cmac_ready_cb cb_ready, m_tb_sec_finished_cb cb_finished)
{
   13fa2:	b510      	push	{r4, lr}
   13fa4:	0013      	movs	r3, r2
	return m_tb_sec_start(token_id, M_TB_SEC_CMAC, (m_tb_sec_ready_cb) cb_ready, cb_finished);
   13fa6:	000a      	movs	r2, r1
   13fa8:	2102      	movs	r1, #2
   13faa:	f7ff ff23 	bl	13df4 <m_tb_sec_start>
}
   13fae:	bd10      	pop	{r4, pc}

00013fb0 <m_tb_sec_s1_start>:

uint16_t m_tb_sec_s1_start(uint8_t token_id, m_tb_sec_s1_ready_cb cb_ready, m_tb_sec_finished_cb cb_finished)
{
   13fb0:	b510      	push	{r4, lr}
   13fb2:	0013      	movs	r3, r2
	return m_tb_sec_start(token_id, M_TB_SEC_S1, (m_tb_sec_ready_cb) cb_ready, cb_finished);
   13fb4:	000a      	movs	r2, r1
   13fb6:	2105      	movs	r1, #5
   13fb8:	f7ff ff1c 	bl	13df4 <m_tb_sec_start>
}
   13fbc:	bd10      	pop	{r4, pc}

00013fbe <m_tb_sec_k1_start>:

uint16_t m_tb_sec_k1_start(uint8_t token_id, m_tb_sec_k1_ready_cb cb_ready, m_tb_sec_finished_cb cb_finished)
{
   13fbe:	b510      	push	{r4, lr}
   13fc0:	0013      	movs	r3, r2
	return m_tb_sec_start(token_id, M_TB_SEC_K1, (m_tb_sec_ready_cb) cb_ready, cb_finished);
   13fc2:	000a      	movs	r2, r1
   13fc4:	2106      	movs	r1, #6
   13fc6:	f7ff ff15 	bl	13df4 <m_tb_sec_start>
}
   13fca:	bd10      	pop	{r4, pc}

00013fcc <m_tb_sec_k2_start>:

uint16_t m_tb_sec_k2_start(uint8_t token_id, m_tb_sec_k2_ready_cb cb_ready, m_tb_sec_finished_cb cb_finished)
{
   13fcc:	b510      	push	{r4, lr}
   13fce:	0013      	movs	r3, r2
	return m_tb_sec_start(token_id, M_TB_SEC_K2, (m_tb_sec_ready_cb) cb_ready, cb_finished);
   13fd0:	000a      	movs	r2, r1
   13fd2:	2107      	movs	r1, #7
   13fd4:	f7ff ff0e 	bl	13df4 <m_tb_sec_start>
}
   13fd8:	bd10      	pop	{r4, pc}

00013fda <m_tb_sec_k3_start>:

uint16_t m_tb_sec_k3_start(uint8_t token_id, m_tb_sec_k3_ready_cb cb_ready, m_tb_sec_finished_cb cb_finished)
{
   13fda:	b510      	push	{r4, lr}
   13fdc:	0013      	movs	r3, r2
	return m_tb_sec_start(token_id, M_TB_SEC_K3, (m_tb_sec_ready_cb) cb_ready, cb_finished);
   13fde:	000a      	movs	r2, r1
   13fe0:	2108      	movs	r1, #8
   13fe2:	f7ff ff07 	bl	13df4 <m_tb_sec_start>
}
   13fe6:	bd10      	pop	{r4, pc}

00013fe8 <m_tb_sec_k4_start>:

uint16_t m_tb_sec_k4_start(uint8_t token_id, m_tb_sec_k4_ready_cb cb_ready, m_tb_sec_finished_cb cb_finished)
{
   13fe8:	b510      	push	{r4, lr}
   13fea:	0013      	movs	r3, r2
	return m_tb_sec_start(token_id, M_TB_SEC_K4, (m_tb_sec_ready_cb) cb_ready, cb_finished);
   13fec:	000a      	movs	r2, r1
   13fee:	2109      	movs	r1, #9
   13ff0:	f7ff ff00 	bl	13df4 <m_tb_sec_start>
}
   13ff4:	bd10      	pop	{r4, pc}

00013ff6 <m_tb_sec_rand_start>:

uint16_t m_tb_sec_rand_start(uint8_t token_id, m_tb_sec_finished_cb cb_finished)
{
   13ff6:	b510      	push	{r4, lr}
   13ff8:	000b      	movs	r3, r1
    return m_tb_sec_start(token_id, M_TB_SEC_RAND, (m_tb_sec_ready_cb) m_tb_sec_ready_rand_cb, cb_finished);
   13ffa:	4a02      	ldr	r2, [pc, #8]	; (14004 <m_tb_sec_rand_start+0xe>)
   13ffc:	210a      	movs	r1, #10
   13ffe:	f7ff fef9 	bl	13df4 <m_tb_sec_start>
}
   14002:	bd10      	pop	{r4, pc}
   14004:	00013b8d 	.word	0x00013b8d

00014008 <m_tb_sec_ccm_enc_start>:

uint16_t m_tb_sec_ccm_enc_start(uint8_t token_id, m_tb_sec_ccm_enc_ready_cb cb_ready, m_tb_sec_finished_cb cb_finished)
{
   14008:	b510      	push	{r4, lr}
   1400a:	0013      	movs	r3, r2
    return m_tb_sec_start(token_id, M_TB_SEC_CCM_ENC, (m_tb_sec_ready_cb) cb_ready, cb_finished);
   1400c:	000a      	movs	r2, r1
   1400e:	2103      	movs	r1, #3
   14010:	f7ff fef0 	bl	13df4 <m_tb_sec_start>
}
   14014:	bd10      	pop	{r4, pc}

00014016 <m_tb_sec_ccm_dec_start>:

uint16_t m_tb_sec_ccm_dec_start(uint8_t token_id, m_tb_sec_ccm_dec_ready_cb cb_ready, m_tb_sec_finished_cb cb_finished)
{
   14016:	b510      	push	{r4, lr}
   14018:	0013      	movs	r3, r2
    return m_tb_sec_start(token_id, M_TB_SEC_CCM_DEC, (m_tb_sec_ready_cb) cb_ready, cb_finished);
   1401a:	000a      	movs	r2, r1
   1401c:	2104      	movs	r1, #4
   1401e:	f7ff fee9 	bl	13df4 <m_tb_sec_start>
}
   14022:	bd10      	pop	{r4, pc}

00014024 <m_tb_state_cb_timer_attention>:
 ****************************************************************************************
 */
__STATIC void m_tb_state_cb_timer_attention(void *p_env)
{
    // Decrement attention timer value
    p_m_tb_state_env->attention_state--;
   14024:	4b09      	ldr	r3, [pc, #36]	; (1404c <m_tb_state_cb_timer_attention+0x28>)
 ****************************************************************************************
 * @brief Handle attention timer expiration
 ****************************************************************************************
 */
__STATIC void m_tb_state_cb_timer_attention(void *p_env)
{
   14026:	b510      	push	{r4, lr}
    // Decrement attention timer value
    p_m_tb_state_env->attention_state--;
   14028:	681b      	ldr	r3, [r3, #0]
   1402a:	001a      	movs	r2, r3
   1402c:	3249      	adds	r2, #73	; 0x49
   1402e:	7810      	ldrb	r0, [r2, #0]
   14030:	3801      	subs	r0, #1
   14032:	b2c0      	uxtb	r0, r0
   14034:	7010      	strb	r0, [r2, #0]

    // Check if timer must be restarted for one second
    if (p_m_tb_state_env->attention_state)
   14036:	2800      	cmp	r0, #0
   14038:	d005      	beq.n	14046 <m_tb_state_cb_timer_attention+0x22>
    {
        // Restart the timer
        m_tb_timer_set(&p_m_tb_state_env->timer_attention, 1000);
   1403a:	21fa      	movs	r1, #250	; 0xfa
   1403c:	1d18      	adds	r0, r3, #4
   1403e:	0089      	lsls	r1, r1, #2
   14040:	f001 f960 	bl	15304 <m_tb_timer_set>
   14044:	e001      	b.n	1404a <m_tb_state_cb_timer_attention+0x26>
    }
    else
    {
        // Inform the application about updated attention state
        bc_m_send_attention_update_ind(0);
   14046:	f7f4 ffa9 	bl	8f9c <bc_m_send_attention_update_ind>
    }
}
   1404a:	bd10      	pop	{r4, pc}
   1404c:	100126cc 	.word	0x100126cc

00014050 <m_tb_state_init>:
 * GLOBAL FUNCTIONS
 ****************************************************************************************
 */

uint16_t m_tb_state_init(bool reset, void *p_env, const m_cfg_t *p_cfg)
{
   14050:	b570      	push	{r4, r5, r6, lr}
   14052:	4b1d      	ldr	r3, [pc, #116]	; (140c8 <m_tb_state_init+0x78>)
   14054:	0006      	movs	r6, r0
   14056:	000c      	movs	r4, r1
   14058:	0015      	movs	r5, r2
    if (!reset)
   1405a:	2800      	cmp	r0, #0
   1405c:	d130      	bne.n	140c0 <m_tb_state_init+0x70>
    {
        // Keep pointer to environment reserved for State Manager
        p_m_tb_state_env = (m_tb_state_env_t *)p_env;
   1405e:	6019      	str	r1, [r3, #0]

        // Clear the memory
        memset(p_m_tb_state_env, 0, sizeof(m_tb_state_env_t));
   14060:	224c      	movs	r2, #76	; 0x4c
   14062:	0001      	movs	r1, r0
   14064:	0020      	movs	r0, r4
   14066:	f001 fcf1 	bl	15a4c <memset>

        // Initialize states
        p_m_tb_state_env->info = 0;
        p_m_tb_state_env->default_ttl = M_TTL_DEFAULT;
   1406a:	0023      	movs	r3, r4
   1406c:	210b      	movs	r1, #11

        // Set attention timer callback
        p_m_tb_state_env->timer_attention.cb = m_tb_state_cb_timer_attention;

        // Keep information provided by the application
        p_m_tb_state_env->features = p_cfg->features & BLE_MESH_FEAT_MASK;
   1406e:	2001      	movs	r0, #1
        // Clear the memory
        memset(p_m_tb_state_env, 0, sizeof(m_tb_state_env_t));

        // Initialize states
        p_m_tb_state_env->info = 0;
        p_m_tb_state_env->default_ttl = M_TTL_DEFAULT;
   14070:	3346      	adds	r3, #70	; 0x46

        // Clear the memory
        memset(p_m_tb_state_env, 0, sizeof(m_tb_state_env_t));

        // Initialize states
        p_m_tb_state_env->info = 0;
   14072:	8766      	strh	r6, [r4, #58]	; 0x3a
        p_m_tb_state_env->default_ttl = M_TTL_DEFAULT;
   14074:	7019      	strb	r1, [r3, #0]
        #if (BLE_MESH_RELAY)
        p_m_tb_state_env->relay_retx_state = 0x66;
   14076:	315b      	adds	r1, #91	; 0x5b
   14078:	7059      	strb	r1, [r3, #1]
        #endif //(BLE_MESH_RELAY)
        p_m_tb_state_env->net_tx_state = M_TB_STATE_NET_TX(M_ADV_NB_TX, M_ADV_INTERVAL);
   1407a:	3960      	subs	r1, #96	; 0x60
   1407c:	7099      	strb	r1, [r3, #2]
        p_m_tb_state_env->attention_state = 0;
   1407e:	70de      	strb	r6, [r3, #3]

        // Set attention timer callback
        p_m_tb_state_env->timer_attention.cb = m_tb_state_cb_timer_attention;
   14080:	4b12      	ldr	r3, [pc, #72]	; (140cc <m_tb_state_init+0x7c>)
        // Clear the memory
        memset(p_m_tb_state_env, 0, sizeof(m_tb_state_env_t));

        // Initialize states
        p_m_tb_state_env->info = 0;
        p_m_tb_state_env->default_ttl = M_TTL_DEFAULT;
   14082:	1da2      	adds	r2, r4, #6
        #endif //(BLE_MESH_RELAY)
        p_m_tb_state_env->net_tx_state = M_TB_STATE_NET_TX(M_ADV_NB_TX, M_ADV_INTERVAL);
        p_m_tb_state_env->attention_state = 0;

        // Set attention timer callback
        p_m_tb_state_env->timer_attention.cb = m_tb_state_cb_timer_attention;
   14084:	60a3      	str	r3, [r4, #8]

        // Keep information provided by the application
        p_m_tb_state_env->features = p_cfg->features & BLE_MESH_FEAT_MASK;
   14086:	882b      	ldrh	r3, [r5, #0]
   14088:	4003      	ands	r3, r0
   1408a:	87a3      	strh	r3, [r4, #60]	; 0x3c
        p_m_tb_state_env->cid = p_cfg->cid;
   1408c:	8869      	ldrh	r1, [r5, #2]
   1408e:	87e1      	strh	r1, [r4, #62]	; 0x3e
        p_m_tb_state_env->pid = p_cfg->pid;
   14090:	88ae      	ldrh	r6, [r5, #4]
   14092:	1ca1      	adds	r1, r4, #2
   14094:	87ce      	strh	r6, [r1, #62]	; 0x3e
        p_m_tb_state_env->vid = p_cfg->vid;
   14096:	88ee      	ldrh	r6, [r5, #6]
   14098:	1d21      	adds	r1, r4, #4
   1409a:	87ce      	strh	r6, [r1, #62]	; 0x3e
        p_m_tb_state_env->loc = p_cfg->loc;
   1409c:	8929      	ldrh	r1, [r5, #8]
   1409e:	87d1      	strh	r1, [r2, #62]	; 0x3e
        p_m_tb_state_env->nb_cdata_page = p_cfg->nb_cdata_page;
   140a0:	7aa9      	ldrb	r1, [r5, #10]
   140a2:	3244      	adds	r2, #68	; 0x44

        // Make sure number of pages in the composition data is not 0
        if (p_m_tb_state_env->nb_cdata_page == 0)
   140a4:	2900      	cmp	r1, #0
   140a6:	d001      	beq.n	140ac <m_tb_state_init+0x5c>
        p_m_tb_state_env->features = p_cfg->features & BLE_MESH_FEAT_MASK;
        p_m_tb_state_env->cid = p_cfg->cid;
        p_m_tb_state_env->pid = p_cfg->pid;
        p_m_tb_state_env->vid = p_cfg->vid;
        p_m_tb_state_env->loc = p_cfg->loc;
        p_m_tb_state_env->nb_cdata_page = p_cfg->nb_cdata_page;
   140a8:	7011      	strb	r1, [r2, #0]
   140aa:	e000      	b.n	140ae <m_tb_state_init+0x5e>

        // Make sure number of pages in the composition data is not 0
        if (p_m_tb_state_env->nb_cdata_page == 0)
        {
            p_m_tb_state_env->nb_cdata_page = 1;
   140ac:	7010      	strb	r0, [r2, #0]
        }

        // Initialize network key local index for publication parameters
        p_m_tb_state_env->pub_params.net_key_lid = M_INVALID_LID;
   140ae:	0022      	movs	r2, r4
   140b0:	21ff      	movs	r1, #255	; 0xff
   140b2:	3208      	adds	r2, #8
   140b4:	77d1      	strb	r1, [r2, #31]

#if (BLE_MESH_RELAY)
		if ((p_m_tb_state_env->features & M_FEAT_RELAY_NODE_SUP) != 0){
   140b6:	2b00      	cmp	r3, #0
   140b8:	d004      	beq.n	140c4 <m_tb_state_init+0x74>
	        SETB(p_m_tb_state_env->info, M_TB_STATE_INFO_RELAY, 1);
   140ba:	2310      	movs	r3, #16
   140bc:	8763      	strh	r3, [r4, #58]	; 0x3a
   140be:	e001      	b.n	140c4 <m_tb_state_init+0x74>
		}
#endif
    }
    else
    {
        p_m_tb_state_env = NULL;
   140c0:	2200      	movs	r2, #0
   140c2:	601a      	str	r2, [r3, #0]
    }
    return (sizeof(m_tb_state_env_t));
}
   140c4:	204c      	movs	r0, #76	; 0x4c
   140c6:	bd70      	pop	{r4, r5, r6, pc}
   140c8:	100126cc 	.word	0x100126cc
   140cc:	00014025 	.word	0x00014025

000140d0 <m_tb_state_get_env_size>:

uint16_t m_tb_state_get_env_size(const m_cfg_t *p_cfg)
{
    return (sizeof(m_tb_state_env_t));
}
   140d0:	204c      	movs	r0, #76	; 0x4c
   140d2:	4770      	bx	lr

000140d4 <m_tb_state_set_hb_cb>:

void m_tb_state_set_hb_cb(const m_tb_state_hb_cb_t *p_cb_hb)
{
    p_m_tb_state_env->p_cb_hb = p_cb_hb;
   140d4:	4b01      	ldr	r3, [pc, #4]	; (140dc <m_tb_state_set_hb_cb+0x8>)
   140d6:	681b      	ldr	r3, [r3, #0]
   140d8:	6018      	str	r0, [r3, #0]
}
   140da:	4770      	bx	lr
   140dc:	100126cc 	.word	0x100126cc

000140e0 <m_tb_state_set_enabled>:
}
#endif //(BLE_MESH_FRIEND)

void m_tb_state_set_enabled(bool enabled)
{
    SETB(p_m_tb_state_env->info, M_TB_STATE_INFO_ENABLED, enabled);
   140e0:	2104      	movs	r1, #4
   140e2:	4b04      	ldr	r3, [pc, #16]	; (140f4 <m_tb_state_set_enabled+0x14>)
   140e4:	0080      	lsls	r0, r0, #2
   140e6:	681a      	ldr	r2, [r3, #0]
   140e8:	8f53      	ldrh	r3, [r2, #58]	; 0x3a
   140ea:	438b      	bics	r3, r1
   140ec:	4318      	orrs	r0, r3
   140ee:	8750      	strh	r0, [r2, #58]	; 0x3a
	//M_PRINTF(L_APP, "%x", p_m_tb_state_env->info);
}
   140f0:	4770      	bx	lr
   140f2:	46c0      	nop			; (mov r8, r8)
   140f4:	100126cc 	.word	0x100126cc

000140f8 <m_tb_state_set_prov_state>:

void m_tb_state_set_prov_state(uint8_t prov_state)
{
    SETF(p_m_tb_state_env->info, M_TB_STATE_INFO_PROV, prov_state);
   140f8:	2303      	movs	r3, #3
    SETB(p_m_tb_state_env->info, M_TB_STATE_INFO_ENABLED, enabled);
	//M_PRINTF(L_APP, "%x", p_m_tb_state_env->info);
}

void m_tb_state_set_prov_state(uint8_t prov_state)
{
   140fa:	b537      	push	{r0, r1, r2, r4, r5, lr}
    SETF(p_m_tb_state_env->info, M_TB_STATE_INFO_PROV, prov_state);
   140fc:	0002      	movs	r2, r0
   140fe:	439a      	bics	r2, r3
   14100:	0013      	movs	r3, r2
   14102:	2b00      	cmp	r3, #0
   14104:	d1fd      	bne.n	14102 <m_tb_state_set_prov_state+0xa>
   14106:	2103      	movs	r1, #3
   14108:	4d11      	ldr	r5, [pc, #68]	; (14150 <m_tb_state_set_prov_state+0x58>)
   1410a:	682a      	ldr	r2, [r5, #0]
   1410c:	8f53      	ldrh	r3, [r2, #58]	; 0x3a
   1410e:	438b      	bics	r3, r1
   14110:	4318      	orrs	r0, r3
	M_PRINTF(L_TB, "info = 0x%04d", p_m_tb_state_env->info);
   14112:	4b10      	ldr	r3, [pc, #64]	; (14154 <m_tb_state_set_prov_state+0x5c>)
	//M_PRINTF(L_APP, "%x", p_m_tb_state_env->info);
}

void m_tb_state_set_prov_state(uint8_t prov_state)
{
    SETF(p_m_tb_state_env->info, M_TB_STATE_INFO_PROV, prov_state);
   14114:	8750      	strh	r0, [r2, #58]	; 0x3a
	M_PRINTF(L_TB, "info = 0x%04d", p_m_tb_state_env->info);
   14116:	681b      	ldr	r3, [r3, #0]
   14118:	079b      	lsls	r3, r3, #30
   1411a:	d517      	bpl.n	1414c <m_tb_state_set_prov_state+0x54>
   1411c:	4c0e      	ldr	r4, [pc, #56]	; (14158 <m_tb_state_set_prov_state+0x60>)
   1411e:	0023      	movs	r3, r4
   14120:	333c      	adds	r3, #60	; 0x3c
   14122:	9300      	str	r3, [sp, #0]
   14124:	0022      	movs	r2, r4
   14126:	0020      	movs	r0, r4
   14128:	2398      	movs	r3, #152	; 0x98
   1412a:	3220      	adds	r2, #32
   1412c:	005b      	lsls	r3, r3, #1
   1412e:	0021      	movs	r1, r4
   14130:	302d      	adds	r0, #45	; 0x2d
   14132:	f7f0 fc3b 	bl	49ac <m_print>
   14136:	0020      	movs	r0, r4
   14138:	682b      	ldr	r3, [r5, #0]
   1413a:	3056      	adds	r0, #86	; 0x56
   1413c:	8f59      	ldrh	r1, [r3, #58]	; 0x3a
   1413e:	f7f0 fc35 	bl	49ac <m_print>
   14142:	0020      	movs	r0, r4
   14144:	1da1      	adds	r1, r4, #6
   14146:	3064      	adds	r0, #100	; 0x64
   14148:	f7f0 fc30 	bl	49ac <m_print>
}
   1414c:	bd37      	pop	{r0, r1, r2, r4, r5, pc}
   1414e:	46c0      	nop			; (mov r8, r8)
   14150:	100126cc 	.word	0x100126cc
   14154:	10010514 	.word	0x10010514
   14158:	000229ea 	.word	0x000229ea

0001415c <m_tb_state_set_default_ttl>:

void m_tb_state_set_default_ttl(uint8_t default_ttl)
{
    p_m_tb_state_env->default_ttl = default_ttl;
   1415c:	4b04      	ldr	r3, [pc, #16]	; (14170 <m_tb_state_set_default_ttl+0x14>)
    SETF(p_m_tb_state_env->info, M_TB_STATE_INFO_PROV, prov_state);
	M_PRINTF(L_TB, "info = 0x%04d", p_m_tb_state_env->info);
}

void m_tb_state_set_default_ttl(uint8_t default_ttl)
{
   1415e:	b510      	push	{r4, lr}
    p_m_tb_state_env->default_ttl = default_ttl;
   14160:	681b      	ldr	r3, [r3, #0]

    // Inform storage manager about the update
    m_tb_store_update_ind(M_TB_STORE_UPD_TYPE_STATE, M_TB_STORE_TYPE_DEFAULT_TTL_STATE);
   14162:	2101      	movs	r1, #1
	M_PRINTF(L_TB, "info = 0x%04d", p_m_tb_state_env->info);
}

void m_tb_state_set_default_ttl(uint8_t default_ttl)
{
    p_m_tb_state_env->default_ttl = default_ttl;
   14164:	3346      	adds	r3, #70	; 0x46
   14166:	7018      	strb	r0, [r3, #0]

    // Inform storage manager about the update
    m_tb_store_update_ind(M_TB_STORE_UPD_TYPE_STATE, M_TB_STORE_TYPE_DEFAULT_TTL_STATE);
   14168:	2007      	movs	r0, #7
   1416a:	f000 fd55 	bl	14c18 <m_tb_store_update_ind>
}
   1416e:	bd10      	pop	{r4, pc}
   14170:	100126cc 	.word	0x100126cc

00014174 <m_tb_state_set_beacon_state>:

void m_tb_state_set_beacon_state(uint8_t bcn_state)
{
    // Check provided state
    SETB(p_m_tb_state_env->info, M_TB_STATE_INFO_BCN, bcn_state);
   14174:	00c0      	lsls	r0, r0, #3
   14176:	2308      	movs	r3, #8
   14178:	0002      	movs	r2, r0
   1417a:	439a      	bics	r2, r3
   1417c:	0013      	movs	r3, r2
    // Inform storage manager about the update
    m_tb_store_update_ind(M_TB_STORE_UPD_TYPE_STATE, M_TB_STORE_TYPE_DEFAULT_TTL_STATE);
}

void m_tb_state_set_beacon_state(uint8_t bcn_state)
{
   1417e:	b510      	push	{r4, lr}
    // Check provided state
    SETB(p_m_tb_state_env->info, M_TB_STATE_INFO_BCN, bcn_state);
   14180:	2b00      	cmp	r3, #0
   14182:	d1fd      	bne.n	14180 <m_tb_state_set_beacon_state+0xc>
   14184:	2108      	movs	r1, #8
   14186:	4b06      	ldr	r3, [pc, #24]	; (141a0 <m_tb_state_set_beacon_state+0x2c>)
   14188:	681a      	ldr	r2, [r3, #0]
   1418a:	8f53      	ldrh	r3, [r2, #58]	; 0x3a
   1418c:	438b      	bics	r3, r1
   1418e:	4318      	orrs	r0, r3
   14190:	8750      	strh	r0, [r2, #58]	; 0x3a

    // Inform storage manager about the update
    m_tb_store_update_ind(M_TB_STORE_UPD_TYPE_STATE, M_TB_STORE_TYPE_SEC_BCN_STATE);
   14192:	3906      	subs	r1, #6
   14194:	2007      	movs	r0, #7
   14196:	f000 fd3f 	bl	14c18 <m_tb_store_update_ind>

    // Update state of beacon
    m_bcn_state_update();
   1419a:	f7f5 fcd7 	bl	9b4c <m_bcn_state_update>
}
   1419e:	bd10      	pop	{r4, pc}
   141a0:	100126cc 	.word	0x100126cc

000141a4 <m_tb_state_set_relay_state>:
}
#endif //(BLE_MESH_GATT_PROXY)

#if (BLE_MESH_RELAY)
void m_tb_state_set_relay_state(uint8_t relay_state, uint8_t relay_retx_state)
{
   141a4:	b570      	push	{r4, r5, r6, lr}
   141a6:	0004      	movs	r4, r0
    // Check provided state value is valid and state can be updated
    if (m_tb_state_is_feature_sup(M_FEAT_RELAY_NODE_SUP))
   141a8:	2001      	movs	r0, #1
}
#endif //(BLE_MESH_GATT_PROXY)

#if (BLE_MESH_RELAY)
void m_tb_state_set_relay_state(uint8_t relay_state, uint8_t relay_retx_state)
{
   141aa:	000d      	movs	r5, r1
    // Check provided state value is valid and state can be updated
    if (m_tb_state_is_feature_sup(M_FEAT_RELAY_NODE_SUP))
   141ac:	f000 f99e 	bl	144ec <m_tb_state_is_feature_sup>
   141b0:	2800      	cmp	r0, #0
   141b2:	d01a      	beq.n	141ea <m_tb_state_set_relay_state+0x46>
    {
        p_m_tb_state_env->relay_retx_state = relay_retx_state;
   141b4:	4b0d      	ldr	r3, [pc, #52]	; (141ec <m_tb_state_set_relay_state+0x48>)
   141b6:	681b      	ldr	r3, [r3, #0]
   141b8:	001a      	movs	r2, r3
   141ba:	3247      	adds	r2, #71	; 0x47
   141bc:	7015      	strb	r5, [r2, #0]

        if (GETB(p_m_tb_state_env->info, M_TB_STATE_INFO_RELAY) != relay_state)
   141be:	2501      	movs	r5, #1
   141c0:	8f5a      	ldrh	r2, [r3, #58]	; 0x3a
   141c2:	1110      	asrs	r0, r2, #4
   141c4:	4028      	ands	r0, r5
   141c6:	42a0      	cmp	r0, r4
   141c8:	d00b      	beq.n	141e2 <m_tb_state_set_relay_state+0x3e>
        {
            // Keep in mind that Relay state has been updated
            SETB(p_m_tb_state_env->hb_feat_upd, M_HBEAT_PUB_FEAT_RELAY, 1);
   141ca:	8f19      	ldrh	r1, [r3, #56]	; 0x38

            // Update state
            SETB(p_m_tb_state_env->info, M_TB_STATE_INFO_RELAY, relay_state);
   141cc:	0124      	lsls	r4, r4, #4
        p_m_tb_state_env->relay_retx_state = relay_retx_state;

        if (GETB(p_m_tb_state_env->info, M_TB_STATE_INFO_RELAY) != relay_state)
        {
            // Keep in mind that Relay state has been updated
            SETB(p_m_tb_state_env->hb_feat_upd, M_HBEAT_PUB_FEAT_RELAY, 1);
   141ce:	4329      	orrs	r1, r5
   141d0:	8719      	strh	r1, [r3, #56]	; 0x38

            // Update state
            SETB(p_m_tb_state_env->info, M_TB_STATE_INFO_RELAY, relay_state);
   141d2:	0020      	movs	r0, r4
   141d4:	2110      	movs	r1, #16
   141d6:	4388      	bics	r0, r1
   141d8:	2800      	cmp	r0, #0
   141da:	d1fd      	bne.n	141d8 <m_tb_state_set_relay_state+0x34>
   141dc:	438a      	bics	r2, r1
   141de:	4314      	orrs	r4, r2
   141e0:	875c      	strh	r4, [r3, #58]	; 0x3a
        }

        // Inform storage manager about the update
        m_tb_store_update_ind(M_TB_STORE_UPD_TYPE_STATE, M_TB_STORE_TYPE_RELAY_STATE);
   141e2:	2104      	movs	r1, #4
   141e4:	2007      	movs	r0, #7
   141e6:	f000 fd17 	bl	14c18 <m_tb_store_update_ind>
    }
}
   141ea:	bd70      	pop	{r4, r5, r6, pc}
   141ec:	100126cc 	.word	0x100126cc

000141f0 <m_tb_state_set_net_tx_state>:
}
#endif //(BLE_MESH_FRIEND)

void m_tb_state_set_net_tx_state(uint8_t net_tx_state)
{
    p_m_tb_state_env->net_tx_state = net_tx_state;
   141f0:	4b04      	ldr	r3, [pc, #16]	; (14204 <m_tb_state_set_net_tx_state+0x14>)
    }
}
#endif //(BLE_MESH_FRIEND)

void m_tb_state_set_net_tx_state(uint8_t net_tx_state)
{
   141f2:	b510      	push	{r4, lr}
    p_m_tb_state_env->net_tx_state = net_tx_state;
   141f4:	681b      	ldr	r3, [r3, #0]

    // Inform storage manager about the update
    m_tb_store_update_ind(M_TB_STORE_UPD_TYPE_STATE, M_TB_STORE_TYPE_NET_TX_STATE);
   141f6:	2103      	movs	r1, #3
}
#endif //(BLE_MESH_FRIEND)

void m_tb_state_set_net_tx_state(uint8_t net_tx_state)
{
    p_m_tb_state_env->net_tx_state = net_tx_state;
   141f8:	3348      	adds	r3, #72	; 0x48
   141fa:	7018      	strb	r0, [r3, #0]

    // Inform storage manager about the update
    m_tb_store_update_ind(M_TB_STORE_UPD_TYPE_STATE, M_TB_STORE_TYPE_NET_TX_STATE);
   141fc:	2007      	movs	r0, #7
   141fe:	f000 fd0b 	bl	14c18 <m_tb_store_update_ind>
}
   14202:	bd10      	pop	{r4, pc}
   14204:	100126cc 	.word	0x100126cc

00014208 <m_tb_state_set_attention_state>:

void m_tb_state_set_attention_state(uint8_t attention_state)
{
	M_PRINTF(L_TB, "");
   14208:	4b17      	ldr	r3, [pc, #92]	; (14268 <m_tb_state_set_attention_state+0x60>)
    // Inform storage manager about the update
    m_tb_store_update_ind(M_TB_STORE_UPD_TYPE_STATE, M_TB_STORE_TYPE_NET_TX_STATE);
}

void m_tb_state_set_attention_state(uint8_t attention_state)
{
   1420a:	b537      	push	{r0, r1, r2, r4, r5, lr}
	M_PRINTF(L_TB, "");
   1420c:	681b      	ldr	r3, [r3, #0]
    // Inform storage manager about the update
    m_tb_store_update_ind(M_TB_STORE_UPD_TYPE_STATE, M_TB_STORE_TYPE_NET_TX_STATE);
}

void m_tb_state_set_attention_state(uint8_t attention_state)
{
   1420e:	0005      	movs	r5, r0
	M_PRINTF(L_TB, "");
   14210:	079b      	lsls	r3, r3, #30
   14212:	d515      	bpl.n	14240 <m_tb_state_set_attention_state+0x38>
   14214:	4c15      	ldr	r4, [pc, #84]	; (1426c <m_tb_state_set_attention_state+0x64>)
   14216:	0023      	movs	r3, r4
   14218:	3367      	adds	r3, #103	; 0x67
   1421a:	9300      	str	r3, [sp, #0]
   1421c:	0022      	movs	r2, r4
   1421e:	0020      	movs	r0, r4
   14220:	23cc      	movs	r3, #204	; 0xcc
   14222:	0021      	movs	r1, r4
   14224:	3220      	adds	r2, #32
   14226:	005b      	lsls	r3, r3, #1
   14228:	302d      	adds	r0, #45	; 0x2d
   1422a:	f7f0 fbbf 	bl	49ac <m_print>
   1422e:	4810      	ldr	r0, [pc, #64]	; (14270 <m_tb_state_set_attention_state+0x68>)
   14230:	3006      	adds	r0, #6
   14232:	f7f0 fbbb 	bl	49ac <m_print>
   14236:	0020      	movs	r0, r4
   14238:	1da1      	adds	r1, r4, #6
   1423a:	3064      	adds	r0, #100	; 0x64
   1423c:	f7f0 fbb6 	bl	49ac <m_print>
    // Cancel timer
    m_tb_timer_clear(&p_m_tb_state_env->timer_attention);
   14240:	4c0c      	ldr	r4, [pc, #48]	; (14274 <m_tb_state_set_attention_state+0x6c>)
   14242:	6823      	ldr	r3, [r4, #0]
   14244:	1d18      	adds	r0, r3, #4
   14246:	f001 f8a7 	bl	15398 <m_tb_timer_clear>

    // Update attention state
    p_m_tb_state_env->attention_state = attention_state;
   1424a:	6820      	ldr	r0, [r4, #0]
   1424c:	0003      	movs	r3, r0
   1424e:	3349      	adds	r3, #73	; 0x49
   14250:	701d      	strb	r5, [r3, #0]

    // Check if timer must be restarted
    if (attention_state != 0)
   14252:	2d00      	cmp	r5, #0
   14254:	d004      	beq.n	14260 <m_tb_state_set_attention_state+0x58>
    {
        // Start the timer for 1s
        m_tb_timer_set(&p_m_tb_state_env->timer_attention, 1000);
   14256:	21fa      	movs	r1, #250	; 0xfa
   14258:	3004      	adds	r0, #4
   1425a:	0089      	lsls	r1, r1, #2
   1425c:	f001 f852 	bl	15304 <m_tb_timer_set>
    }

    // Inform the application about updated attention state
    bc_m_send_attention_update_ind(attention_state);
   14260:	0028      	movs	r0, r5
   14262:	f7f4 fe9b 	bl	8f9c <bc_m_send_attention_update_ind>
}
   14266:	bd37      	pop	{r0, r1, r2, r4, r5, pc}
   14268:	10010514 	.word	0x10010514
   1426c:	000229ea 	.word	0x000229ea
   14270:	00022a6a 	.word	0x00022a6a
   14274:	100126cc 	.word	0x100126cc

00014278 <m_tb_state_set_hb_pub_params>:

uint16_t m_tb_state_set_hb_pub_params(uint16_t dst_addr, uint8_t count_log, uint8_t period_log,
                                      uint8_t ttl, uint16_t features, m_lid_t net_key_lid)
{
   14278:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1427a:	ac06      	add	r4, sp, #24
   1427c:	8824      	ldrh	r4, [r4, #0]
   1427e:	46a4      	mov	ip, r4
   14280:	ac07      	add	r4, sp, #28
   14282:	7827      	ldrb	r7, [r4, #0]
    {
        // Point to heartbeat publication parameters
        m_tb_state_hb_pub_t *p_pub_params = &p_m_tb_state_env->pub_params;

        // Check provided destination address, cannot be a virtual address
        if (M_IS_VIRTUAL_ADDR(dst_addr))
   14284:	0b84      	lsrs	r4, r0, #14
   14286:	2c02      	cmp	r4, #2
   14288:	d039      	beq.n	142fe <m_tb_state_set_hb_pub_params+0x86>
            status = M_ERR_INVALID_ADDR;
            break;
        }

        // Check provided Period Log and TTL value
        if (((count_log > M_TB_STATE_HB_PUB_COUNT_LOG_MAX) && (count_log != 0xFF))
   1428a:	000c      	movs	r4, r1
   1428c:	3c12      	subs	r4, #18
   1428e:	b2e4      	uxtb	r4, r4
   14290:	2cec      	cmp	r4, #236	; 0xec
   14292:	d937      	bls.n	14304 <m_tb_state_set_hb_pub_params+0x8c>
                || (period_log > M_TB_STATE_HB_PUB_PERIOD_LOG_MAX)
   14294:	2a11      	cmp	r2, #17
   14296:	d835      	bhi.n	14304 <m_tb_state_set_hb_pub_params+0x8c>
                || (ttl > M_MSG_TTL_MASK))
   14298:	b25c      	sxtb	r4, r3
   1429a:	2c00      	cmp	r4, #0
   1429c:	db32      	blt.n	14304 <m_tb_state_set_hb_pub_params+0x8c>
    uint16_t status = M_ERR_NO_ERROR;

    do
    {
        // Point to heartbeat publication parameters
        m_tb_state_hb_pub_t *p_pub_params = &p_m_tb_state_env->pub_params;
   1429e:	4c1b      	ldr	r4, [pc, #108]	; (1430c <m_tb_state_set_hb_pub_params+0x94>)
   142a0:	6824      	ldr	r4, [r4, #0]
   142a2:	0025      	movs	r5, r4
            status = M_ERR_INVALID_PARAM;
            break;
        }

        // Set publication parameters
        p_pub_params->dst_addr = dst_addr;
   142a4:	8420      	strh	r0, [r4, #32]
   142a6:	1de6      	adds	r6, r4, #7
   142a8:	3508      	adds	r5, #8

        if ((dst_addr == M_UNASSIGNED_ADDR) || (count_log == 0))
   142aa:	2800      	cmp	r0, #0
   142ac:	d001      	beq.n	142b2 <m_tb_state_set_hb_pub_params+0x3a>
   142ae:	2900      	cmp	r1, #0
   142b0:	d108      	bne.n	142c4 <m_tb_state_set_hb_pub_params+0x4c>
        {
            // Disable publication of heartbeat messages
            p_pub_params->dst_addr = M_UNASSIGNED_ADDR;
   142b2:	2300      	movs	r3, #0
            p_pub_params->ttl = 0;
            p_pub_params->features = 0;
            p_pub_params->net_key_lid = M_INVALID_LID;
   142b4:	22ff      	movs	r2, #255	; 0xff
        p_pub_params->dst_addr = dst_addr;

        if ((dst_addr == M_UNASSIGNED_ADDR) || (count_log == 0))
        {
            // Disable publication of heartbeat messages
            p_pub_params->dst_addr = M_UNASSIGNED_ADDR;
   142b6:	8423      	strh	r3, [r4, #32]
            p_pub_params->ttl = 0;
   142b8:	77f3      	strb	r3, [r6, #31]
            p_pub_params->features = 0;
   142ba:	8523      	strh	r3, [r4, #40]	; 0x28
            p_pub_params->net_key_lid = M_INVALID_LID;
   142bc:	77ea      	strb	r2, [r5, #31]
            p_pub_params->period_s = 0;
   142be:	84a3      	strh	r3, [r4, #36]	; 0x24
            p_pub_params->count = 0;
   142c0:	8463      	strh	r3, [r4, #34]	; 0x22
   142c2:	e016      	b.n	142f2 <m_tb_state_set_hb_pub_params+0x7a>
        }
        else
        {
            // Enable publication of heartbeat messages
            p_pub_params->ttl = ttl;
   142c4:	77f3      	strb	r3, [r6, #31]
            p_pub_params->features = features & 0x000F;
   142c6:	4660      	mov	r0, ip
   142c8:	230f      	movs	r3, #15
   142ca:	4018      	ands	r0, r3
            p_pub_params->net_key_lid = net_key_lid;
            p_pub_params->period_s = (period_log == 0) ? 0 : 1 << (period_log - 1);
   142cc:	2300      	movs	r3, #0
        }
        else
        {
            // Enable publication of heartbeat messages
            p_pub_params->ttl = ttl;
            p_pub_params->features = features & 0x000F;
   142ce:	8520      	strh	r0, [r4, #40]	; 0x28
            p_pub_params->net_key_lid = net_key_lid;
   142d0:	77ef      	strb	r7, [r5, #31]
            p_pub_params->period_s = (period_log == 0) ? 0 : 1 << (period_log - 1);
   142d2:	429a      	cmp	r2, r3
   142d4:	d003      	beq.n	142de <m_tb_state_set_hb_pub_params+0x66>
   142d6:	3a01      	subs	r2, #1
   142d8:	3301      	adds	r3, #1
   142da:	4093      	lsls	r3, r2
   142dc:	b29b      	uxth	r3, r3
   142de:	84a3      	strh	r3, [r4, #36]	; 0x24

            if (count_log == 0xFF)
            {
                p_pub_params->count = 0xFFFF;
   142e0:	2301      	movs	r3, #1
            p_pub_params->ttl = ttl;
            p_pub_params->features = features & 0x000F;
            p_pub_params->net_key_lid = net_key_lid;
            p_pub_params->period_s = (period_log == 0) ? 0 : 1 << (period_log - 1);

            if (count_log == 0xFF)
   142e2:	29ff      	cmp	r1, #255	; 0xff
   142e4:	d102      	bne.n	142ec <m_tb_state_set_hb_pub_params+0x74>
            {
                p_pub_params->count = 0xFFFF;
   142e6:	425b      	negs	r3, r3
   142e8:	8463      	strh	r3, [r4, #34]	; 0x22
   142ea:	e002      	b.n	142f2 <m_tb_state_set_hb_pub_params+0x7a>
            }
            else
            {
                p_pub_params->count = (1 << count_log) - 1;
   142ec:	408b      	lsls	r3, r1
   142ee:	3b01      	subs	r3, #1
   142f0:	8463      	strh	r3, [r4, #34]	; 0x22
            }
        }

        // Inform the layer responsible for transmission of heartbeat messages
        p_m_tb_state_env->p_cb_hb->updated(M_TB_STATE_UPDATE_HB_PUB);
   142f2:	6823      	ldr	r3, [r4, #0]
   142f4:	2000      	movs	r0, #0
   142f6:	681b      	ldr	r3, [r3, #0]
   142f8:	4798      	blx	r3

uint16_t m_tb_state_set_hb_pub_params(uint16_t dst_addr, uint8_t count_log, uint8_t period_log,
                                      uint8_t ttl, uint16_t features, m_lid_t net_key_lid)
{
    // Returned status
    uint16_t status = M_ERR_NO_ERROR;
   142fa:	2000      	movs	r0, #0
   142fc:	e004      	b.n	14308 <m_tb_state_set_hb_pub_params+0x90>
        m_tb_state_hb_pub_t *p_pub_params = &p_m_tb_state_env->pub_params;

        // Check provided destination address, cannot be a virtual address
        if (M_IS_VIRTUAL_ADDR(dst_addr))
        {
            status = M_ERR_INVALID_ADDR;
   142fe:	20c0      	movs	r0, #192	; 0xc0
   14300:	0040      	lsls	r0, r0, #1
   14302:	e001      	b.n	14308 <m_tb_state_set_hb_pub_params+0x90>
        // Check provided Period Log and TTL value
        if (((count_log > M_TB_STATE_HB_PUB_COUNT_LOG_MAX) && (count_log != 0xFF))
                || (period_log > M_TB_STATE_HB_PUB_PERIOD_LOG_MAX)
                || (ttl > M_MSG_TTL_MASK))
        {
            status = M_ERR_INVALID_PARAM;
   14304:	20c1      	movs	r0, #193	; 0xc1
   14306:	0040      	lsls	r0, r0, #1
        // Inform the layer responsible for transmission of heartbeat messages
        p_m_tb_state_env->p_cb_hb->updated(M_TB_STATE_UPDATE_HB_PUB);
    } while (0);

    return (status);
}
   14308:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1430a:	46c0      	nop			; (mov r8, r8)
   1430c:	100126cc 	.word	0x100126cc

00014310 <m_tb_state_set_hb_subs_params>:

uint16_t m_tb_state_set_hb_subs_params(uint16_t src_addr, uint16_t dst_addr, uint8_t period_log)
{
   14310:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   14312:	0015      	movs	r5, r2
    {
        // Point to heartbeat subscription parameters
        m_tb_state_hb_subs_t *p_subs_params = &p_m_tb_state_env->subs_params;

        // Check provided source address, shall be the unassigned or a unicast address
        if (M_IS_VIRTUAL_ADDR(src_addr) || M_IS_GROUP_ADDR(src_addr))
   14314:	2280      	movs	r2, #128	; 0x80

    return (status);
}

uint16_t m_tb_state_set_hb_subs_params(uint16_t src_addr, uint16_t dst_addr, uint8_t period_log)
{
   14316:	0007      	movs	r7, r0
   14318:	000c      	movs	r4, r1
    {
        // Point to heartbeat subscription parameters
        m_tb_state_hb_subs_t *p_subs_params = &p_m_tb_state_env->subs_params;

        // Check provided source address, shall be the unassigned or a unicast address
        if (M_IS_VIRTUAL_ADDR(src_addr) || M_IS_GROUP_ADDR(src_addr))
   1431a:	0bc3      	lsrs	r3, r0, #15
   1431c:	0212      	lsls	r2, r2, #8
   1431e:	2b00      	cmp	r3, #0
   14320:	d002      	beq.n	14328 <m_tb_state_set_hb_subs_params+0x18>
        {
            status = M_ERR_INVALID_ADDR;
   14322:	20c0      	movs	r0, #192	; 0xc0
   14324:	0040      	lsls	r0, r0, #1
   14326:	e04b      	b.n	143c0 <m_tb_state_set_hb_subs_params+0xb0>
            break;
        }

        // Check destination address, shall be the unassigned address, the primary unicast address of
        // the node or a group address
        if (M_IS_VIRTUAL_ADDR(dst_addr)
   14328:	23c0      	movs	r3, #192	; 0xc0
   1432a:	021b      	lsls	r3, r3, #8
   1432c:	400b      	ands	r3, r1
   1432e:	4293      	cmp	r3, r2
   14330:	d0f7      	beq.n	14322 <m_tb_state_set_hb_subs_params+0x12>
    uint16_t status = M_ERR_NO_ERROR;

    do
    {
        // Point to heartbeat subscription parameters
        m_tb_state_hb_subs_t *p_subs_params = &p_m_tb_state_env->subs_params;
   14332:	4a24      	ldr	r2, [pc, #144]	; (143c4 <m_tb_state_set_hb_subs_params+0xb4>)
        }

        // Check destination address, shall be the unassigned address, the primary unicast address of
        // the node or a group address
        if (M_IS_VIRTUAL_ADDR(dst_addr)
                || ((dst_addr != M_UNASSIGNED_ADDR)
   14334:	b20b      	sxth	r3, r1
    uint16_t status = M_ERR_NO_ERROR;

    do
    {
        // Point to heartbeat subscription parameters
        m_tb_state_hb_subs_t *p_subs_params = &p_m_tb_state_env->subs_params;
   14336:	6816      	ldr	r6, [r2, #0]
   14338:	9201      	str	r2, [sp, #4]
        }

        // Check destination address, shall be the unassigned address, the primary unicast address of
        // the node or a group address
        if (M_IS_VIRTUAL_ADDR(dst_addr)
                || ((dst_addr != M_UNASSIGNED_ADDR)
   1433a:	2b00      	cmp	r3, #0
   1433c:	dc02      	bgt.n	14344 <m_tb_state_set_hb_subs_params+0x34>
            status = M_ERR_INVALID_ADDR;
            break;
        }

        // Check provided Period Log value
        if (period_log > M_TB_STATE_HB_PUB_PERIOD_LOG_MAX)
   1433e:	2d11      	cmp	r5, #17
   14340:	d83c      	bhi.n	143bc <m_tb_state_set_hb_subs_params+0xac>
   14342:	e004      	b.n	1434e <m_tb_state_set_hb_subs_params+0x3e>
        // Check destination address, shall be the unassigned address, the primary unicast address of
        // the node or a group address
        if (M_IS_VIRTUAL_ADDR(dst_addr)
                || ((dst_addr != M_UNASSIGNED_ADDR)
                        && (M_IS_UNICAST_ADDR(dst_addr))
                        && (dst_addr != m_tb_mio_get_prim_addr())))
   14344:	f7ff fb78 	bl	13a38 <m_tb_mio_get_prim_addr>
   14348:	4284      	cmp	r4, r0
   1434a:	d1ea      	bne.n	14322 <m_tb_state_set_hb_subs_params+0x12>
   1434c:	e7f7      	b.n	1433e <m_tb_state_set_hb_subs_params+0x2e>
   1434e:	2300      	movs	r3, #0
        }

        // If destination address or destination address is set to an unassigned address,
        // both address must be set to unassigned address, and reception of heartbeat
        // message must be disabled.
        if ((dst_addr == M_UNASSIGNED_ADDR)
   14350:	429c      	cmp	r4, r3
   14352:	d01a      	beq.n	1438a <m_tb_state_set_hb_subs_params+0x7a>
                || (src_addr == M_UNASSIGNED_ADDR))
   14354:	429f      	cmp	r7, r3
   14356:	d01b      	beq.n	14390 <m_tb_state_set_hb_subs_params+0x80>
            // Count, MinHops and MaxHops must remain unchanged
            dst_addr = M_UNASSIGNED_ADDR;
            src_addr = M_UNASSIGNED_ADDR;
            period_log = 0;
        }
        else if (!period_log)
   14358:	429d      	cmp	r5, r3
   1435a:	d10f      	bne.n	1437c <m_tb_state_set_hb_subs_params+0x6c>
        {
            // Check if provided address are different than the current one
            if ((dst_addr != p_subs_params->dst_addr)
   1435c:	8e32      	ldrh	r2, [r6, #48]	; 0x30
   1435e:	002b      	movs	r3, r5
   14360:	42a2      	cmp	r2, r4
   14362:	d102      	bne.n	1436a <m_tb_state_set_hb_subs_params+0x5a>
                    || (src_addr != p_subs_params->src_addr))
   14364:	8e72      	ldrh	r2, [r6, #50]	; 0x32
   14366:	42ba      	cmp	r2, r7
   14368:	d015      	beq.n	14396 <m_tb_state_set_hb_subs_params+0x86>
            {
                // Reset statistics
                p_subs_params->max_hops = 0;
   1436a:	0032      	movs	r2, r6
                p_subs_params->min_hops = 0x7F;
   1436c:	217f      	movs	r1, #127	; 0x7f
                p_subs_params->count = 0;
            }

            dst_addr = M_UNASSIGNED_ADDR;
   1436e:	2400      	movs	r4, #0
            // Check if provided address are different than the current one
            if ((dst_addr != p_subs_params->dst_addr)
                    || (src_addr != p_subs_params->src_addr))
            {
                // Reset statistics
                p_subs_params->max_hops = 0;
   14370:	322c      	adds	r2, #44	; 0x2c
   14372:	72d3      	strb	r3, [r2, #11]
                p_subs_params->min_hops = 0x7F;
   14374:	7291      	strb	r1, [r2, #10]
                p_subs_params->count = 0;
            }

            dst_addr = M_UNASSIGNED_ADDR;
            src_addr = M_UNASSIGNED_ADDR;
   14376:	0027      	movs	r7, r4
                    || (src_addr != p_subs_params->src_addr))
            {
                // Reset statistics
                p_subs_params->max_hops = 0;
                p_subs_params->min_hops = 0x7F;
                p_subs_params->count = 0;
   14378:	86b3      	strh	r3, [r6, #52]	; 0x34
   1437a:	e00e      	b.n	1439a <m_tb_state_set_hb_subs_params+0x8a>
            src_addr = M_UNASSIGNED_ADDR;
        }
        else
        {
            // And reset statistics
            p_subs_params->max_hops = 0;
   1437c:	0032      	movs	r2, r6
            p_subs_params->min_hops = 0x7F;
   1437e:	217f      	movs	r1, #127	; 0x7f
            src_addr = M_UNASSIGNED_ADDR;
        }
        else
        {
            // And reset statistics
            p_subs_params->max_hops = 0;
   14380:	322c      	adds	r2, #44	; 0x2c
   14382:	72d3      	strb	r3, [r2, #11]
            p_subs_params->min_hops = 0x7F;
   14384:	7291      	strb	r1, [r2, #10]
            p_subs_params->count = 0;
   14386:	86b3      	strh	r3, [r6, #52]	; 0x34
   14388:	e007      	b.n	1439a <m_tb_state_set_hb_subs_params+0x8a>
                || (src_addr == M_UNASSIGNED_ADDR))
        {
            // Count, MinHops and MaxHops must remain unchanged
            dst_addr = M_UNASSIGNED_ADDR;
            src_addr = M_UNASSIGNED_ADDR;
            period_log = 0;
   1438a:	0025      	movs	r5, r4
        if ((dst_addr == M_UNASSIGNED_ADDR)
                || (src_addr == M_UNASSIGNED_ADDR))
        {
            // Count, MinHops and MaxHops must remain unchanged
            dst_addr = M_UNASSIGNED_ADDR;
            src_addr = M_UNASSIGNED_ADDR;
   1438c:	0027      	movs	r7, r4
   1438e:	e004      	b.n	1439a <m_tb_state_set_hb_subs_params+0x8a>
            period_log = 0;
   14390:	003d      	movs	r5, r7
        // message must be disabled.
        if ((dst_addr == M_UNASSIGNED_ADDR)
                || (src_addr == M_UNASSIGNED_ADDR))
        {
            // Count, MinHops and MaxHops must remain unchanged
            dst_addr = M_UNASSIGNED_ADDR;
   14392:	003c      	movs	r4, r7
   14394:	e001      	b.n	1439a <m_tb_state_set_hb_subs_params+0x8a>
   14396:	002c      	movs	r4, r5
            src_addr = M_UNASSIGNED_ADDR;
   14398:	002f      	movs	r7, r5
        }

        // Keep the parameters
        p_subs_params->dst_addr = dst_addr;
        p_subs_params->src_addr = src_addr;
        p_subs_params->period_s = (period_log) ? (1 << (period_log - 1)) : 0;
   1439a:	2300      	movs	r3, #0
            p_subs_params->min_hops = 0x7F;
            p_subs_params->count = 0;
        }

        // Keep the parameters
        p_subs_params->dst_addr = dst_addr;
   1439c:	8634      	strh	r4, [r6, #48]	; 0x30
        p_subs_params->src_addr = src_addr;
   1439e:	8677      	strh	r7, [r6, #50]	; 0x32
        p_subs_params->period_s = (period_log) ? (1 << (period_log - 1)) : 0;
   143a0:	429d      	cmp	r5, r3
   143a2:	d002      	beq.n	143aa <m_tb_state_set_hb_subs_params+0x9a>
   143a4:	3d01      	subs	r5, #1
   143a6:	3301      	adds	r3, #1
   143a8:	40ab      	lsls	r3, r5
   143aa:	62f3      	str	r3, [r6, #44]	; 0x2c

        // Inform the layer responsible for handling of received heartbeat messages
        p_m_tb_state_env->p_cb_hb->updated(M_TB_STATE_UPDATE_HB_SUBS);
   143ac:	9b01      	ldr	r3, [sp, #4]
   143ae:	2001      	movs	r0, #1
   143b0:	681b      	ldr	r3, [r3, #0]
   143b2:	681b      	ldr	r3, [r3, #0]
   143b4:	681b      	ldr	r3, [r3, #0]
   143b6:	4798      	blx	r3
}

uint16_t m_tb_state_set_hb_subs_params(uint16_t src_addr, uint16_t dst_addr, uint8_t period_log)
{
    // Returned status
    uint16_t status = M_ERR_NO_ERROR;
   143b8:	2000      	movs	r0, #0
   143ba:	e001      	b.n	143c0 <m_tb_state_set_hb_subs_params+0xb0>
        }

        // Check provided Period Log value
        if (period_log > M_TB_STATE_HB_PUB_PERIOD_LOG_MAX)
        {
            status = M_ERR_INVALID_PARAM;
   143bc:	20c1      	movs	r0, #193	; 0xc1
   143be:	0040      	lsls	r0, r0, #1
        // Inform the layer responsible for handling of received heartbeat messages
        p_m_tb_state_env->p_cb_hb->updated(M_TB_STATE_UPDATE_HB_SUBS);
    } while (0);

    return (status);
}
   143c0:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
   143c2:	46c0      	nop			; (mov r8, r8)
   143c4:	100126cc 	.word	0x100126cc

000143c8 <m_tb_state_get_prov_state>:
}
#endif //(BLE_MESH_LPN)

uint8_t m_tb_state_get_prov_state(void)
{
    return (GETF(p_m_tb_state_env->info, M_TB_STATE_INFO_PROV));
   143c8:	4b02      	ldr	r3, [pc, #8]	; (143d4 <m_tb_state_get_prov_state+0xc>)
   143ca:	681b      	ldr	r3, [r3, #0]
   143cc:	8f58      	ldrh	r0, [r3, #58]	; 0x3a
   143ce:	2303      	movs	r3, #3
   143d0:	4018      	ands	r0, r3
}
   143d2:	4770      	bx	lr
   143d4:	100126cc 	.word	0x100126cc

000143d8 <m_tb_state_get_default_ttl>:

uint8_t m_tb_state_get_default_ttl(void)
{
    return (p_m_tb_state_env->default_ttl);
   143d8:	4b02      	ldr	r3, [pc, #8]	; (143e4 <m_tb_state_get_default_ttl+0xc>)
   143da:	681b      	ldr	r3, [r3, #0]
   143dc:	3346      	adds	r3, #70	; 0x46
   143de:	7818      	ldrb	r0, [r3, #0]
}
   143e0:	4770      	bx	lr
   143e2:	46c0      	nop			; (mov r8, r8)
   143e4:	100126cc 	.word	0x100126cc

000143e8 <m_tb_state_get_beacon_state>:

uint8_t m_tb_state_get_beacon_state(void)
{
    return (GETB(p_m_tb_state_env->info, M_TB_STATE_INFO_BCN));
   143e8:	4b02      	ldr	r3, [pc, #8]	; (143f4 <m_tb_state_get_beacon_state+0xc>)
   143ea:	681b      	ldr	r3, [r3, #0]
   143ec:	8f58      	ldrh	r0, [r3, #58]	; 0x3a
   143ee:	0700      	lsls	r0, r0, #28
   143f0:	0fc0      	lsrs	r0, r0, #31
}
   143f2:	4770      	bx	lr
   143f4:	100126cc 	.word	0x100126cc

000143f8 <m_tb_state_get_gatt_proxy_state>:
   143f8:	2002      	movs	r0, #2
   143fa:	4770      	bx	lr

000143fc <m_tb_state_get_relay_state>:

    return (state);
}

uint8_t m_tb_state_get_relay_state(uint8_t *p_relay_retx_state)
{
   143fc:	b510      	push	{r4, lr}
   143fe:	0004      	movs	r4, r0
    uint8_t state;
    // Retransmission state
    uint8_t retx_state;

    #if (BLE_MESH_RELAY)
    if (m_tb_state_is_feature_sup(M_FEAT_RELAY_NODE_SUP))
   14400:	2001      	movs	r0, #1
   14402:	f000 f873 	bl	144ec <m_tb_state_is_feature_sup>
   14406:	2800      	cmp	r0, #0
   14408:	d007      	beq.n	1441a <m_tb_state_get_relay_state+0x1e>
    {
        state = GETB(p_m_tb_state_env->info, M_TB_STATE_INFO_RELAY);
   1440a:	4b07      	ldr	r3, [pc, #28]	; (14428 <m_tb_state_get_relay_state+0x2c>)
   1440c:	681b      	ldr	r3, [r3, #0]
   1440e:	8f58      	ldrh	r0, [r3, #58]	; 0x3a
        retx_state = p_m_tb_state_env->relay_retx_state;
   14410:	3347      	adds	r3, #71	; 0x47
    uint8_t retx_state;

    #if (BLE_MESH_RELAY)
    if (m_tb_state_is_feature_sup(M_FEAT_RELAY_NODE_SUP))
    {
        state = GETB(p_m_tb_state_env->info, M_TB_STATE_INFO_RELAY);
   14412:	06c0      	lsls	r0, r0, #27
   14414:	0fc0      	lsrs	r0, r0, #31
        retx_state = p_m_tb_state_env->relay_retx_state;
   14416:	781b      	ldrb	r3, [r3, #0]
   14418:	e001      	b.n	1441e <m_tb_state_get_relay_state+0x22>
    }
    else
    #endif //(BLE_MESH_RELAY)
    {
        state = M_CONF_RELAY_STATE_NOT_SUPPORTED;
        retx_state = 0;
   1441a:	0003      	movs	r3, r0
        retx_state = p_m_tb_state_env->relay_retx_state;
    }
    else
    #endif //(BLE_MESH_RELAY)
    {
        state = M_CONF_RELAY_STATE_NOT_SUPPORTED;
   1441c:	2002      	movs	r0, #2
        retx_state = 0;
    }

    if (p_relay_retx_state)
   1441e:	2c00      	cmp	r4, #0
   14420:	d000      	beq.n	14424 <m_tb_state_get_relay_state+0x28>
    {
        *p_relay_retx_state = retx_state;
   14422:	7023      	strb	r3, [r4, #0]
    }

    return (state);
}
   14424:	bd10      	pop	{r4, pc}
   14426:	46c0      	nop			; (mov r8, r8)
   14428:	100126cc 	.word	0x100126cc

0001442c <m_tb_state_get_friend_state>:
    {
        state = M_CONF_FRIEND_STATE_NOT_SUPPORTED;
    }

    return (state);
}
   1442c:	2002      	movs	r0, #2
   1442e:	4770      	bx	lr

00014430 <m_tb_state_get_net_tx_state>:

uint8_t m_tb_state_get_net_tx_state(void)
{
    return (p_m_tb_state_env->net_tx_state);
   14430:	4b02      	ldr	r3, [pc, #8]	; (1443c <m_tb_state_get_net_tx_state+0xc>)
   14432:	681b      	ldr	r3, [r3, #0]
   14434:	3348      	adds	r3, #72	; 0x48
   14436:	7818      	ldrb	r0, [r3, #0]
}
   14438:	4770      	bx	lr
   1443a:	46c0      	nop			; (mov r8, r8)
   1443c:	100126cc 	.word	0x100126cc

00014440 <m_tb_state_get_net_tx_params>:

void m_tb_state_get_net_tx_params(uint8_t *p_tx_count, uint16_t *p_intv_slots)
{
    // Deduce requested parameters from network transmit state
    *p_tx_count = GETF(p_m_tb_state_env->net_tx_state, M_TB_STATE_NET_TX_COUNT) + 1;
   14440:	4b07      	ldr	r3, [pc, #28]	; (14460 <m_tb_state_get_net_tx_params+0x20>)
{
    return (p_m_tb_state_env->net_tx_state);
}

void m_tb_state_get_net_tx_params(uint8_t *p_tx_count, uint16_t *p_intv_slots)
{
   14442:	b510      	push	{r4, lr}
    // Deduce requested parameters from network transmit state
    *p_tx_count = GETF(p_m_tb_state_env->net_tx_state, M_TB_STATE_NET_TX_COUNT) + 1;
   14444:	681a      	ldr	r2, [r3, #0]
   14446:	2307      	movs	r3, #7
   14448:	3248      	adds	r2, #72	; 0x48
   1444a:	7814      	ldrb	r4, [r2, #0]
   1444c:	4023      	ands	r3, r4
   1444e:	3301      	adds	r3, #1
   14450:	7003      	strb	r3, [r0, #0]
    // Value stored in multiple of 10ms, multiply by 16 in order to have value in slots
    *p_intv_slots = (GETF(p_m_tb_state_env->net_tx_state, M_TB_STATE_NET_TX_INTV) + 1) << 4;
   14452:	7813      	ldrb	r3, [r2, #0]
   14454:	08db      	lsrs	r3, r3, #3
   14456:	3301      	adds	r3, #1
   14458:	011b      	lsls	r3, r3, #4
   1445a:	800b      	strh	r3, [r1, #0]
}
   1445c:	bd10      	pop	{r4, pc}
   1445e:	46c0      	nop			; (mov r8, r8)
   14460:	100126cc 	.word	0x100126cc

00014464 <m_tb_state_get_attention_state>:

uint8_t m_tb_state_get_attention_state(void)
{
    return (p_m_tb_state_env->attention_state);
   14464:	4b02      	ldr	r3, [pc, #8]	; (14470 <m_tb_state_get_attention_state+0xc>)
   14466:	681b      	ldr	r3, [r3, #0]
   14468:	3349      	adds	r3, #73	; 0x49
   1446a:	7818      	ldrb	r0, [r3, #0]
}
   1446c:	4770      	bx	lr
   1446e:	46c0      	nop			; (mov r8, r8)
   14470:	100126cc 	.word	0x100126cc

00014474 <m_tb_state_get_nb_cdata_page>:

uint8_t m_tb_state_get_nb_cdata_page(void)
{
    return (p_m_tb_state_env->nb_cdata_page);
   14474:	4b02      	ldr	r3, [pc, #8]	; (14480 <m_tb_state_get_nb_cdata_page+0xc>)
   14476:	681b      	ldr	r3, [r3, #0]
   14478:	334a      	adds	r3, #74	; 0x4a
   1447a:	7818      	ldrb	r0, [r3, #0]
}
   1447c:	4770      	bx	lr
   1447e:	46c0      	nop			; (mov r8, r8)
   14480:	100126cc 	.word	0x100126cc

00014484 <m_tb_state_get_compo_info>:
void m_tb_state_get_compo_info(uint16_t *p_cid, uint16_t *p_pid, uint16_t *p_vid,
                               uint16_t *p_features, uint16_t *p_loc)
{
   14484:	b530      	push	{r4, r5, lr}
    *p_cid = p_m_tb_state_env->cid;
   14486:	4c09      	ldr	r4, [pc, #36]	; (144ac <m_tb_state_get_compo_info+0x28>)
   14488:	6824      	ldr	r4, [r4, #0]
   1448a:	8fe5      	ldrh	r5, [r4, #62]	; 0x3e
   1448c:	8005      	strh	r5, [r0, #0]
    *p_pid = p_m_tb_state_env->pid;
   1448e:	1ca0      	adds	r0, r4, #2
   14490:	8fc0      	ldrh	r0, [r0, #62]	; 0x3e
   14492:	8008      	strh	r0, [r1, #0]
    *p_vid = p_m_tb_state_env->vid;
   14494:	1d21      	adds	r1, r4, #4
   14496:	8fc9      	ldrh	r1, [r1, #62]	; 0x3e
   14498:	8011      	strh	r1, [r2, #0]
    *p_loc = p_m_tb_state_env->loc;
   1449a:	1da2      	adds	r2, r4, #6
   1449c:	8fd2      	ldrh	r2, [r2, #62]	; 0x3e
   1449e:	9903      	ldr	r1, [sp, #12]
   144a0:	800a      	strh	r2, [r1, #0]
    *p_features = p_m_tb_state_env->features & (M_FEAT_RELAY_NODE_SUP
   144a2:	220f      	movs	r2, #15
   144a4:	8fa1      	ldrh	r1, [r4, #60]	; 0x3c
   144a6:	400a      	ands	r2, r1
   144a8:	801a      	strh	r2, [r3, #0]
                                                    | M_FEAT_PROXY_NODE_SUP
                                                    | M_FEAT_FRIEND_NODE_SUP
                                                    | M_FEAT_LOW_POWER_NODE_SUP);
}
   144aa:	bd30      	pop	{r4, r5, pc}
   144ac:	100126cc 	.word	0x100126cc

000144b0 <m_tb_state_get_hb_pub_params>:

m_tb_state_hb_pub_t *m_tb_state_get_hb_pub_params(void)
{
    // Return pointer to heartbeat publication parameters
    return (&p_m_tb_state_env->pub_params);
   144b0:	4b01      	ldr	r3, [pc, #4]	; (144b8 <m_tb_state_get_hb_pub_params+0x8>)
   144b2:	6818      	ldr	r0, [r3, #0]
   144b4:	3020      	adds	r0, #32
}
   144b6:	4770      	bx	lr
   144b8:	100126cc 	.word	0x100126cc

000144bc <m_tb_state_get_hb_subs_params>:

m_tb_state_hb_subs_t *m_tb_state_get_hb_subs_params(void)
{
    // Return pointer to heartbeat subscription parameters
    return (&p_m_tb_state_env->subs_params);
   144bc:	4b01      	ldr	r3, [pc, #4]	; (144c4 <m_tb_state_get_hb_subs_params+0x8>)
   144be:	6818      	ldr	r0, [r3, #0]
   144c0:	302c      	adds	r0, #44	; 0x2c
}
   144c2:	4770      	bx	lr
   144c4:	100126cc 	.word	0x100126cc

000144c8 <m_tb_state_get_hb_feat_upd>:
{
    // Get current value
    uint8_t current_val = p_m_tb_state_env->hb_feat_upd;

    // Reset value
    p_m_tb_state_env->hb_feat_upd = 0;
   144c8:	2200      	movs	r2, #0
#endif //(BLE_MESH_DBG)

uint8_t m_tb_state_get_hb_feat_upd(void)
{
    // Get current value
    uint8_t current_val = p_m_tb_state_env->hb_feat_upd;
   144ca:	4b03      	ldr	r3, [pc, #12]	; (144d8 <m_tb_state_get_hb_feat_upd+0x10>)
   144cc:	681b      	ldr	r3, [r3, #0]
   144ce:	8f18      	ldrh	r0, [r3, #56]	; 0x38

    // Reset value
    p_m_tb_state_env->hb_feat_upd = 0;
   144d0:	871a      	strh	r2, [r3, #56]	; 0x38
#endif //(BLE_MESH_DBG)

uint8_t m_tb_state_get_hb_feat_upd(void)
{
    // Get current value
    uint8_t current_val = p_m_tb_state_env->hb_feat_upd;
   144d2:	b2c0      	uxtb	r0, r0

    // Reset value
    p_m_tb_state_env->hb_feat_upd = 0;

    return (current_val);
}
   144d4:	4770      	bx	lr
   144d6:	46c0      	nop			; (mov r8, r8)
   144d8:	100126cc 	.word	0x100126cc

000144dc <m_tb_state_is_enabled>:

bool m_tb_state_is_enabled(void)
{
	//M_PRINTF(L_APP, "%x", p_m_tb_state_env->info);
    return (GETB(p_m_tb_state_env->info, M_TB_STATE_INFO_ENABLED));
   144dc:	4b02      	ldr	r3, [pc, #8]	; (144e8 <m_tb_state_is_enabled+0xc>)
   144de:	681b      	ldr	r3, [r3, #0]
   144e0:	8f58      	ldrh	r0, [r3, #58]	; 0x3a
   144e2:	0740      	lsls	r0, r0, #29
   144e4:	0fc0      	lsrs	r0, r0, #31
}
   144e6:	4770      	bx	lr
   144e8:	100126cc 	.word	0x100126cc

000144ec <m_tb_state_is_feature_sup>:

bool m_tb_state_is_feature_sup(uint16_t feature)
{
    return ((p_m_tb_state_env->features & feature) != 0);
   144ec:	4b03      	ldr	r3, [pc, #12]	; (144fc <m_tb_state_is_feature_sup+0x10>)
   144ee:	681b      	ldr	r3, [r3, #0]
   144f0:	8f9b      	ldrh	r3, [r3, #60]	; 0x3c
   144f2:	4018      	ands	r0, r3
   144f4:	1e43      	subs	r3, r0, #1
   144f6:	4198      	sbcs	r0, r3
   144f8:	b2c0      	uxtb	r0, r0
}
   144fa:	4770      	bx	lr
   144fc:	100126cc 	.word	0x100126cc

00014500 <m_tb_state_is_iv_update_auth>:

bool m_tb_state_is_iv_update_auth(void)
{
   14500:	b573      	push	{r0, r1, r4, r5, r6, lr}
    // Indicate if update is authorized
    bool auth;

    // Check if IV has already been updated
    if (GETB(p_m_tb_state_env->info, M_TB_STATE_INFO_IV_UPDATE))
   14502:	4b0e      	ldr	r3, [pc, #56]	; (1453c <m_tb_state_is_iv_update_auth+0x3c>)
            auth = false;
        }
    }
    else
    {
        auth = true;
   14504:	2001      	movs	r0, #1
{
    // Indicate if update is authorized
    bool auth;

    // Check if IV has already been updated
    if (GETB(p_m_tb_state_env->info, M_TB_STATE_INFO_IV_UPDATE))
   14506:	681b      	ldr	r3, [r3, #0]
   14508:	8f5a      	ldrh	r2, [r3, #58]	; 0x3a
   1450a:	05d2      	lsls	r2, r2, #23
   1450c:	d515      	bpl.n	1453a <m_tb_state_is_iv_update_auth+0x3a>
    {
        // Current time
        uint32_t cur_time_ms;
        uint16_t cur_nb_wrap;
        // Next time at which IV update is allowed (initialize with last update time)
        uint32_t next_time_ms = p_m_tb_state_env->iv_time.time_ms;
   1450e:	699a      	ldr	r2, [r3, #24]
        uint16_t next_nb_wrap = p_m_tb_state_env->iv_time.nb_wrap;
   14510:	8b9c      	ldrh	r4, [r3, #28]

        // Add 96 hours to last IV update time
        next_time_ms += M_TB_STATE_96_HOURS_MS;
   14512:	4b0b      	ldr	r3, [pc, #44]	; (14540 <m_tb_state_is_iv_update_auth+0x40>)
   14514:	18d5      	adds	r5, r2, r3

        // Check if value has wrapped
        if (next_time_ms < p_m_tb_state_env->iv_time.time_ms)
   14516:	42aa      	cmp	r2, r5
   14518:	d901      	bls.n	1451e <m_tb_state_is_iv_update_auth+0x1e>
        {
            next_nb_wrap++;
   1451a:	1824      	adds	r4, r4, r0
   1451c:	b2a4      	uxth	r4, r4
        }

        // Get current time
        m_tb_timer_get_cur_time(&cur_time_ms, &cur_nb_wrap);
   1451e:	466b      	mov	r3, sp
   14520:	1c9e      	adds	r6, r3, #2
   14522:	a801      	add	r0, sp, #4
   14524:	0031      	movs	r1, r6
   14526:	f000 ff69 	bl	153fc <m_tb_timer_get_cur_time>

        // Check if 96 hours has elapsed since last IV update
        if ((cur_nb_wrap > next_nb_wrap)
   1452a:	8833      	ldrh	r3, [r6, #0]
                || (cur_time_ms > next_time_ms))
        {
            auth = true;
   1452c:	2001      	movs	r0, #1

        // Get current time
        m_tb_timer_get_cur_time(&cur_time_ms, &cur_nb_wrap);

        // Check if 96 hours has elapsed since last IV update
        if ((cur_nb_wrap > next_nb_wrap)
   1452e:	42a3      	cmp	r3, r4
   14530:	d803      	bhi.n	1453a <m_tb_state_is_iv_update_auth+0x3a>
                || (cur_time_ms > next_time_ms))
   14532:	9b01      	ldr	r3, [sp, #4]
   14534:	429d      	cmp	r5, r3
   14536:	41ad      	sbcs	r5, r5
   14538:	4268      	negs	r0, r5
    {
        auth = true;
    }

    return (auth);
}
   1453a:	bd76      	pop	{r1, r2, r4, r5, r6, pc}
   1453c:	100126cc 	.word	0x100126cc
   14540:	14997000 	.word	0x14997000

00014544 <m_tb_state_iv_update_ind>:

void m_tb_state_iv_update_ind(uint32_t time_ms, uint16_t nb_wrap)
{
   14544:	b510      	push	{r4, lr}
    // Keep in mind that IV has been updated
    SETB(p_m_tb_state_env->info, M_TB_STATE_INFO_IV_UPDATE, 1);
   14546:	2480      	movs	r4, #128	; 0x80
   14548:	4b04      	ldr	r3, [pc, #16]	; (1455c <m_tb_state_iv_update_ind+0x18>)
   1454a:	0064      	lsls	r4, r4, #1
   1454c:	681b      	ldr	r3, [r3, #0]
   1454e:	8f5a      	ldrh	r2, [r3, #58]	; 0x3a

    // Keep update time
    p_m_tb_state_env->iv_time.nb_wrap = nb_wrap;
   14550:	8399      	strh	r1, [r3, #28]
}

void m_tb_state_iv_update_ind(uint32_t time_ms, uint16_t nb_wrap)
{
    // Keep in mind that IV has been updated
    SETB(p_m_tb_state_env->info, M_TB_STATE_INFO_IV_UPDATE, 1);
   14552:	4322      	orrs	r2, r4
   14554:	875a      	strh	r2, [r3, #58]	; 0x3a

    // Keep update time
    p_m_tb_state_env->iv_time.nb_wrap = nb_wrap;
    p_m_tb_state_env->iv_time.time_ms = time_ms;
   14556:	6198      	str	r0, [r3, #24]
}
   14558:	bd10      	pop	{r4, pc}
   1455a:	46c0      	nop			; (mov r8, r8)
   1455c:	100126cc 	.word	0x100126cc

00014560 <m_tb_state_net_key_rem_ind>:

void m_tb_state_net_key_rem_ind(m_lid_t net_key_lid)
{
   14560:	b510      	push	{r4, lr}
    // Point to heartbeat publication parameters
    m_tb_state_hb_pub_t *p_pub_params = &p_m_tb_state_env->pub_params;
   14562:	4b08      	ldr	r3, [pc, #32]	; (14584 <m_tb_state_net_key_rem_ind+0x24>)
   14564:	681b      	ldr	r3, [r3, #0]

    // Check if publication of heartbeat messages is enabled and if removed key was used
    // for that purpose
    if ((p_pub_params->count != 0)
   14566:	8c5a      	ldrh	r2, [r3, #34]	; 0x22
   14568:	2a00      	cmp	r2, #0
   1456a:	d009      	beq.n	14580 <m_tb_state_net_key_rem_ind+0x20>
            && (p_pub_params->net_key_lid == net_key_lid))
   1456c:	001a      	movs	r2, r3
   1456e:	3208      	adds	r2, #8
   14570:	7fd2      	ldrb	r2, [r2, #31]
   14572:	4282      	cmp	r2, r0
   14574:	d104      	bne.n	14580 <m_tb_state_net_key_rem_ind+0x20>
    {
        // Disable publication of heartbeat messages
        p_pub_params->count = 0;
   14576:	2000      	movs	r0, #0
   14578:	8458      	strh	r0, [r3, #34]	; 0x22

        // Inform the layer responsible for publication of heartbeat messages
        p_m_tb_state_env->p_cb_hb->updated(M_TB_STATE_UPDATE_HB_PUB);
   1457a:	681b      	ldr	r3, [r3, #0]
   1457c:	681b      	ldr	r3, [r3, #0]
   1457e:	4798      	blx	r3
    }
}
   14580:	bd10      	pop	{r4, pc}
   14582:	46c0      	nop			; (mov r8, r8)
   14584:	100126cc 	.word	0x100126cc

00014588 <m_tb_state_hb_rx_ind>:

void m_tb_state_hb_rx_ind(uint8_t hops)
{
    // Point to heartbeat subscription parameters
    m_tb_state_hb_subs_t *p_subs_params = &p_m_tb_state_env->subs_params;
   14588:	4b0b      	ldr	r3, [pc, #44]	; (145b8 <m_tb_state_hb_rx_ind+0x30>)

    // Increase number of received heartbeat messages, counter is not supposed to wrap
    if (p_subs_params->count != 0xFFFF)
   1458a:	490c      	ldr	r1, [pc, #48]	; (145bc <m_tb_state_hb_rx_ind+0x34>)
}

void m_tb_state_hb_rx_ind(uint8_t hops)
{
    // Point to heartbeat subscription parameters
    m_tb_state_hb_subs_t *p_subs_params = &p_m_tb_state_env->subs_params;
   1458c:	681b      	ldr	r3, [r3, #0]

    // Increase number of received heartbeat messages, counter is not supposed to wrap
    if (p_subs_params->count != 0xFFFF)
   1458e:	8e9a      	ldrh	r2, [r3, #52]	; 0x34
   14590:	428a      	cmp	r2, r1
   14592:	d001      	beq.n	14598 <m_tb_state_hb_rx_ind+0x10>
    {
        p_subs_params->count++;
   14594:	3201      	adds	r2, #1
   14596:	869a      	strh	r2, [r3, #52]	; 0x34
    }

    if (p_subs_params->count == 1)
   14598:	8e9a      	ldrh	r2, [r3, #52]	; 0x34
   1459a:	332c      	adds	r3, #44	; 0x2c
   1459c:	2a01      	cmp	r2, #1
   1459e:	d102      	bne.n	145a6 <m_tb_state_hb_rx_ind+0x1e>
    {
        p_subs_params->min_hops = hops;
   145a0:	7298      	strb	r0, [r3, #10]
        p_subs_params->max_hops = hops;
   145a2:	72d8      	strb	r0, [r3, #11]
   145a4:	e007      	b.n	145b6 <m_tb_state_hb_rx_ind+0x2e>
    }
    else
    {
        // Update min and max hops values if needed
        if (hops < p_subs_params->min_hops)
   145a6:	7a9a      	ldrb	r2, [r3, #10]
   145a8:	4290      	cmp	r0, r2
   145aa:	d201      	bcs.n	145b0 <m_tb_state_hb_rx_ind+0x28>
        {
            p_subs_params->min_hops = hops;
   145ac:	7298      	strb	r0, [r3, #10]
   145ae:	e002      	b.n	145b6 <m_tb_state_hb_rx_ind+0x2e>
        }
        else if (hops > p_subs_params->min_hops)
   145b0:	4290      	cmp	r0, r2
   145b2:	d900      	bls.n	145b6 <m_tb_state_hb_rx_ind+0x2e>
        {
            p_subs_params->max_hops = hops;
   145b4:	72d8      	strb	r0, [r3, #11]
        }
    }
}
   145b6:	4770      	bx	lr
   145b8:	100126cc 	.word	0x100126cc
   145bc:	0000ffff 	.word	0x0000ffff

000145c0 <m_tb_state_hb_tx_ind>:

void m_tb_state_hb_tx_ind(void)
{
    // Point to heartbeat publication parameters
    m_tb_state_hb_pub_t *p_pub_params = &p_m_tb_state_env->pub_params;
   145c0:	4b04      	ldr	r3, [pc, #16]	; (145d4 <m_tb_state_hb_tx_ind+0x14>)

    if ((p_pub_params->count != 0xFFFF)
   145c2:	4905      	ldr	r1, [pc, #20]	; (145d8 <m_tb_state_hb_tx_ind+0x18>)
}

void m_tb_state_hb_tx_ind(void)
{
    // Point to heartbeat publication parameters
    m_tb_state_hb_pub_t *p_pub_params = &p_m_tb_state_env->pub_params;
   145c4:	681a      	ldr	r2, [r3, #0]

    if ((p_pub_params->count != 0xFFFF)
             && (p_pub_params->count != 0))
   145c6:	8c53      	ldrh	r3, [r2, #34]	; 0x22
   145c8:	3b01      	subs	r3, #1
   145ca:	b29b      	uxth	r3, r3
void m_tb_state_hb_tx_ind(void)
{
    // Point to heartbeat publication parameters
    m_tb_state_hb_pub_t *p_pub_params = &p_m_tb_state_env->pub_params;

    if ((p_pub_params->count != 0xFFFF)
   145cc:	428b      	cmp	r3, r1
   145ce:	d800      	bhi.n	145d2 <m_tb_state_hb_tx_ind+0x12>
             && (p_pub_params->count != 0))
    {
        p_pub_params->count--;
   145d0:	8453      	strh	r3, [r2, #34]	; 0x22
    }
}
   145d2:	4770      	bx	lr
   145d4:	100126cc 	.word	0x100126cc
   145d8:	0000fffd 	.word	0x0000fffd

000145dc <m_tb_state_hb_check_features>:

void m_tb_state_hb_check_features(void)
{
   145dc:	b510      	push	{r4, lr}
    // Point to heartbeat publication parameters
    m_tb_state_hb_pub_t *p_pub_params = &p_m_tb_state_env->pub_params;
   145de:	4c08      	ldr	r4, [pc, #32]	; (14600 <m_tb_state_hb_check_features+0x24>)
   145e0:	6823      	ldr	r3, [r4, #0]

    // Check if Heartbeat publication parameters have been set
    if (p_pub_params->dst_addr != M_UNASSIGNED_ADDR)
   145e2:	8c1a      	ldrh	r2, [r3, #32]
   145e4:	2a00      	cmp	r2, #0
   145e6:	d00a      	beq.n	145fe <m_tb_state_hb_check_features+0x22>
    {
        if (p_pub_params->features & p_m_tb_state_env->hb_feat_upd)
   145e8:	8d1a      	ldrh	r2, [r3, #40]	; 0x28
   145ea:	8f19      	ldrh	r1, [r3, #56]	; 0x38
   145ec:	4211      	tst	r1, r2
   145ee:	d006      	beq.n	145fe <m_tb_state_hb_check_features+0x22>
        {
            // Inform the layer responsible for publication of heartbeat messages
            p_m_tb_state_env->p_cb_hb->updated(M_TB_STATE_UPDATE_HB_FEATURE);
   145f0:	681b      	ldr	r3, [r3, #0]
   145f2:	2002      	movs	r0, #2
   145f4:	681b      	ldr	r3, [r3, #0]
   145f6:	4798      	blx	r3

            // Reset the bitfield
            p_m_tb_state_env->hb_feat_upd = 0;
   145f8:	2200      	movs	r2, #0
   145fa:	6823      	ldr	r3, [r4, #0]
   145fc:	871a      	strh	r2, [r3, #56]	; 0x38
        }
    }
}
   145fe:	bd10      	pop	{r4, pc}
   14600:	100126cc 	.word	0x100126cc

00014604 <m_tb_store_cb_netkey_added>:
    // Free the allocated structure
    m_al_free(p_binding_entry);
}

__STATIC void m_tb_store_cb_netkey_added(uint16_t status, m_lid_t net_key_lid)
{
   14604:	b570      	push	{r4, r5, r6, lr}
   14606:	000c      	movs	r4, r1
    do
    {
        if (status == M_ERR_NO_ERROR)
   14608:	2800      	cmp	r0, #0
   1460a:	d11b      	bne.n	14644 <m_tb_store_cb_netkey_added+0x40>
            m_tb_store_load_info_t *p_load_info = p_m_tb_store_env->p_load_info;
            // Get network key information
            m_tb_store_netkey_upd_t *p_net_key = (m_tb_store_netkey_upd_t *)p_load_info->p_entry;

            // Check if key is under update state
            if (GETB(p_net_key->info, M_TB_STORE_NETKEY_INFO_UPD))
   1460c:	2504      	movs	r5, #4
    do
    {
        if (status == M_ERR_NO_ERROR)
        {
            // Get loading procedure information
            m_tb_store_load_info_t *p_load_info = p_m_tb_store_env->p_load_info;
   1460e:	4b0f      	ldr	r3, [pc, #60]	; (1464c <m_tb_store_cb_netkey_added+0x48>)
   14610:	681b      	ldr	r3, [r3, #0]
   14612:	685b      	ldr	r3, [r3, #4]
            // Get network key information
            m_tb_store_netkey_upd_t *p_net_key = (m_tb_store_netkey_upd_t *)p_load_info->p_entry;
   14614:	6899      	ldr	r1, [r3, #8]

            // Check if key is under update state
            if (GETB(p_net_key->info, M_TB_STORE_NETKEY_INFO_UPD))
   14616:	784a      	ldrb	r2, [r1, #1]
   14618:	422a      	tst	r2, r5
   1461a:	d007      	beq.n	1462c <m_tb_store_cb_netkey_added+0x28>
            {
                // Clear update bit
                SETB(p_net_key->info, M_TB_STORE_NETKEY_INFO_UPD, 0);
   1461c:	43aa      	bics	r2, r5
   1461e:	704a      	strb	r2, [r1, #1]

                // Update the key
                status = m_tb_key_net_update(net_key_lid, &p_net_key->new_key[0], m_tb_store_cb_netkey_added);
   14620:	0020      	movs	r0, r4
   14622:	3114      	adds	r1, #20
   14624:	4a0a      	ldr	r2, [pc, #40]	; (14650 <m_tb_store_cb_netkey_added+0x4c>)
   14626:	f7fd fd1f 	bl	12068 <m_tb_key_net_update>
                break;
   1462a:	e00d      	b.n	14648 <m_tb_store_cb_netkey_added+0x44>
            }
            else
            {
                p_load_info->rem_section_len -= p_net_key->length;
   1462c:	7809      	ldrb	r1, [r1, #0]
   1462e:	899a      	ldrh	r2, [r3, #12]
   14630:	1a52      	subs	r2, r2, r1
   14632:	b292      	uxth	r2, r2
   14634:	819a      	strh	r2, [r3, #12]

                // Check if more network keys have to be added
                if (!p_load_info->rem_section_len)
   14636:	2a00      	cmp	r2, #0
   14638:	d104      	bne.n	14644 <m_tb_store_cb_netkey_added+0x40>
                {
                    // Reset stored entry pointer
                    p_load_info->p_entry = NULL;

                    // Move on next section
                    p_load_info->p_section = M_TB_STORE_GET_NEXT_SECTION(p_load_info->p_section);
   1463a:	6859      	ldr	r1, [r3, #4]

                // Check if more network keys have to be added
                if (!p_load_info->rem_section_len)
                {
                    // Reset stored entry pointer
                    p_load_info->p_entry = NULL;
   1463c:	6098      	str	r0, [r3, #8]

                    // Move on next section
                    p_load_info->p_section = M_TB_STORE_GET_NEXT_SECTION(p_load_info->p_section);
   1463e:	880a      	ldrh	r2, [r1, #0]
   14640:	188a      	adds	r2, r1, r2
   14642:	605a      	str	r2, [r3, #4]
                }
            }
        }

        m_tb_store_load_fsm(status);
   14644:	f000 f838 	bl	146b8 <m_tb_store_load_fsm>
    } while (0);
}
   14648:	bd70      	pop	{r4, r5, r6, pc}
   1464a:	46c0      	nop			; (mov r8, r8)
   1464c:	100126d0 	.word	0x100126d0
   14650:	00014605 	.word	0x00014605

00014654 <m_tb_store_cb_appkey_added>:

__STATIC void m_tb_store_cb_appkey_added(uint16_t status, m_lid_t app_key_lid)
{
   14654:	b573      	push	{r0, r1, r4, r5, r6, lr}
    do
    {
        if (status == M_ERR_NO_ERROR)
   14656:	2800      	cmp	r0, #0
   14658:	d126      	bne.n	146a8 <m_tb_store_cb_appkey_added+0x54>
            m_tb_store_load_info_t *p_load_info = p_m_tb_store_env->p_load_info;
            // Get application key information
            m_tb_store_appkey_upd_t *p_app_key = (m_tb_store_appkey_upd_t *)p_load_info->p_entry;

            // Check if key is under update state
            if (GETB(p_app_key->info, M_TB_STORE_APPKEY_INFO_UPD))
   1465a:	2501      	movs	r5, #1
    do
    {
        if (status == M_ERR_NO_ERROR)
        {
            // Get loading procedure information
            m_tb_store_load_info_t *p_load_info = p_m_tb_store_env->p_load_info;
   1465c:	4b14      	ldr	r3, [pc, #80]	; (146b0 <m_tb_store_cb_appkey_added+0x5c>)
   1465e:	681b      	ldr	r3, [r3, #0]
   14660:	685b      	ldr	r3, [r3, #4]
            // Get application key information
            m_tb_store_appkey_upd_t *p_app_key = (m_tb_store_appkey_upd_t *)p_load_info->p_entry;
   14662:	689c      	ldr	r4, [r3, #8]

            // Check if key is under update state
            if (GETB(p_app_key->info, M_TB_STORE_APPKEY_INFO_UPD))
   14664:	7862      	ldrb	r2, [r4, #1]
   14666:	422a      	tst	r2, r5
   14668:	d012      	beq.n	14690 <m_tb_store_cb_appkey_added+0x3c>
            {
                // Network key local index
                m_lid_t net_key_lid;

                // Seek for network key
                status = m_tb_key_net_find(p_app_key->netkey_id, &net_key_lid);
   1466a:	466b      	mov	r3, sp
   1466c:	1dde      	adds	r6, r3, #7
   1466e:	8860      	ldrh	r0, [r4, #2]
   14670:	0031      	movs	r1, r6
   14672:	f7fd fe09 	bl	12288 <m_tb_key_net_find>

                if (status != M_ERR_NO_ERROR)
   14676:	2800      	cmp	r0, #0
   14678:	d118      	bne.n	146ac <m_tb_store_cb_appkey_added+0x58>

                // Clear update bit
                SETB(p_app_key->info, M_TB_STORE_APPKEY_INFO_UPD, 0);

                // Update the key
                status = m_tb_key_app_update(p_app_key->appkey_id, &p_app_key->new_key[0], net_key_lid,
   1467a:	0021      	movs	r1, r4
                {
                    break;
                }

                // Clear update bit
                SETB(p_app_key->info, M_TB_STORE_APPKEY_INFO_UPD, 0);
   1467c:	7863      	ldrb	r3, [r4, #1]

                // Update the key
                status = m_tb_key_app_update(p_app_key->appkey_id, &p_app_key->new_key[0], net_key_lid,
   1467e:	7832      	ldrb	r2, [r6, #0]
                {
                    break;
                }

                // Clear update bit
                SETB(p_app_key->info, M_TB_STORE_APPKEY_INFO_UPD, 0);
   14680:	43ab      	bics	r3, r5
   14682:	7063      	strb	r3, [r4, #1]

                // Update the key
                status = m_tb_key_app_update(p_app_key->appkey_id, &p_app_key->new_key[0], net_key_lid,
   14684:	3116      	adds	r1, #22
   14686:	88a0      	ldrh	r0, [r4, #4]
   14688:	4b0a      	ldr	r3, [pc, #40]	; (146b4 <m_tb_store_cb_appkey_added+0x60>)
   1468a:	f7fe f819 	bl	126c0 <m_tb_key_app_update>
                                             m_tb_store_cb_appkey_added);
                break;
   1468e:	e00d      	b.n	146ac <m_tb_store_cb_appkey_added+0x58>
            }
            else
            {
                p_load_info->rem_section_len -= p_app_key->length;
   14690:	7821      	ldrb	r1, [r4, #0]
   14692:	899a      	ldrh	r2, [r3, #12]
   14694:	1a52      	subs	r2, r2, r1
   14696:	b292      	uxth	r2, r2
   14698:	819a      	strh	r2, [r3, #12]

                // Check if more application keys have to be added
                if (!p_load_info->rem_section_len)
   1469a:	2a00      	cmp	r2, #0
   1469c:	d104      	bne.n	146a8 <m_tb_store_cb_appkey_added+0x54>
                {
                    // Reset stored entry pointer
                    p_load_info->p_entry = NULL;

                    // Move on next section
                    p_load_info->p_section = M_TB_STORE_GET_NEXT_SECTION(p_load_info->p_section);
   1469e:	6859      	ldr	r1, [r3, #4]

                // Check if more application keys have to be added
                if (!p_load_info->rem_section_len)
                {
                    // Reset stored entry pointer
                    p_load_info->p_entry = NULL;
   146a0:	6098      	str	r0, [r3, #8]

                    // Move on next section
                    p_load_info->p_section = M_TB_STORE_GET_NEXT_SECTION(p_load_info->p_section);
   146a2:	880a      	ldrh	r2, [r1, #0]
   146a4:	188a      	adds	r2, r1, r2
   146a6:	605a      	str	r2, [r3, #4]
                }
            }
        }

        m_tb_store_load_fsm(status);
   146a8:	f000 f806 	bl	146b8 <m_tb_store_load_fsm>
    } while (0);
}
   146ac:	bd73      	pop	{r0, r1, r4, r5, r6, pc}
   146ae:	46c0      	nop			; (mov r8, r8)
   146b0:	100126d0 	.word	0x100126d0
   146b4:	00014655 	.word	0x00014655

000146b8 <m_tb_store_load_fsm>:

    return (status);
}

__STATIC void m_tb_store_load_fsm(uint16_t status)
{
   146b8:	b5f0      	push	{r4, r5, r6, r7, lr}
	ASSERT_ERR(p_m_tb_store_env->p_load_info != NULL);
   146ba:	4bcd      	ldr	r3, [pc, #820]	; (149f0 <m_tb_store_load_fsm+0x338>)

    return (status);
}

__STATIC void m_tb_store_load_fsm(uint16_t status)
{
   146bc:	b08d      	sub	sp, #52	; 0x34
	ASSERT_ERR(p_m_tb_store_env->p_load_info != NULL);
   146be:	681b      	ldr	r3, [r3, #0]

    return (status);
}

__STATIC void m_tb_store_load_fsm(uint16_t status)
{
   146c0:	9005      	str	r0, [sp, #20]
	ASSERT_ERR(p_m_tb_store_env->p_load_info != NULL);
   146c2:	685b      	ldr	r3, [r3, #4]
   146c4:	9304      	str	r3, [sp, #16]
   146c6:	2b00      	cmp	r3, #0
   146c8:	d118      	bne.n	146fc <m_tb_store_load_fsm+0x44>
   146ca:	e7fe      	b.n	146ca <m_tb_store_load_fsm+0x12>
    // Get loading information
    m_tb_store_load_info_t *p_load_info = p_m_tb_store_env->p_load_info;

    while ((status == M_ERR_NO_ERROR) && (p_load_info->rem_nb_section))
   146cc:	9b04      	ldr	r3, [sp, #16]
   146ce:	7b9b      	ldrb	r3, [r3, #14]
   146d0:	2b00      	cmp	r3, #0
   146d2:	d100      	bne.n	146d6 <m_tb_store_load_fsm+0x1e>
   146d4:	e159      	b.n	1498a <m_tb_store_load_fsm+0x2d2>
    {
        // Perform next operation
        switch (p_load_info->p_section->type)
   146d6:	9b04      	ldr	r3, [sp, #16]
   146d8:	9c05      	ldr	r4, [sp, #20]
   146da:	685b      	ldr	r3, [r3, #4]
   146dc:	9306      	str	r3, [sp, #24]
   146de:	7898      	ldrb	r0, [r3, #2]
   146e0:	2805      	cmp	r0, #5
   146e2:	d90f      	bls.n	14704 <m_tb_store_load_fsm+0x4c>
            default:
            {
            } break;
        }

        if (p_load_info->p_entry == NULL)
   146e4:	9b04      	ldr	r3, [sp, #16]
   146e6:	689b      	ldr	r3, [r3, #8]
   146e8:	9306      	str	r3, [sp, #24]
   146ea:	2b00      	cmp	r3, #0
   146ec:	d000      	beq.n	146f0 <m_tb_store_load_fsm+0x38>
   146ee:	e151      	b.n	14994 <m_tb_store_load_fsm+0x2dc>
        {
            p_load_info->rem_nb_section--;
   146f0:	9b04      	ldr	r3, [sp, #16]
   146f2:	9a04      	ldr	r2, [sp, #16]
   146f4:	7b9b      	ldrb	r3, [r3, #14]
   146f6:	9405      	str	r4, [sp, #20]
   146f8:	3b01      	subs	r3, #1
   146fa:	7393      	strb	r3, [r2, #14]
{
	ASSERT_ERR(p_m_tb_store_env->p_load_info != NULL);
    // Get loading information
    m_tb_store_load_info_t *p_load_info = p_m_tb_store_env->p_load_info;

    while ((status == M_ERR_NO_ERROR) && (p_load_info->rem_nb_section))
   146fc:	9b05      	ldr	r3, [sp, #20]
   146fe:	2b00      	cmp	r3, #0
   14700:	d0e4      	beq.n	146cc <m_tb_store_load_fsm+0x14>
   14702:	e168      	b.n	149d6 <m_tb_store_load_fsm+0x31e>
   14704:	4bba      	ldr	r3, [pc, #744]	; (149f0 <m_tb_store_load_fsm+0x338>)
}

__STATIC uint16_t m_tb_store_load_binding(void)
{
    // Get loading procedure information
    m_tb_store_load_info_t *p_load_info = p_m_tb_store_env->p_load_info;
   14706:	681b      	ldr	r3, [r3, #0]
    m_tb_store_load_info_t *p_load_info = p_m_tb_store_env->p_load_info;

    while ((status == M_ERR_NO_ERROR) && (p_load_info->rem_nb_section))
    {
        // Perform next operation
        switch (p_load_info->p_section->type)
   14708:	f009 fb2e 	bl	1dd68 <__gnu_thumb1_case_uhi>
   1470c:	00460006 	.word	0x00460006
   14710:	007e005d 	.word	0x007e005d
   14714:	010300bf 	.word	0x010300bf
__STATIC uint16_t m_tb_store_load_states(void)
{
    // Status
    uint16_t status = M_ERR_NO_ERROR;
    // Get loading procedure information
    m_tb_store_load_info_t *p_load_info = p_m_tb_store_env->p_load_info;
   14718:	685f      	ldr	r7, [r3, #4]
    // Get first entry in the section
    m_tb_store_state_t *p_entry = (m_tb_store_state_t *)M_TB_STORE_GET_FIRST_ENTRY(p_section);
    // Counter
    uint8_t cnt;

    for (cnt = 0; cnt < p_section->nb_entries; cnt++)
   1471a:	2300      	movs	r3, #0
    // Status
    uint16_t status = M_ERR_NO_ERROR;
    // Get loading procedure information
    m_tb_store_load_info_t *p_load_info = p_m_tb_store_env->p_load_info;
    // Get pointer to section
    m_tb_store_hdr_t *p_section = p_load_info->p_section;
   1471c:	687e      	ldr	r6, [r7, #4]
    // Get first entry in the section
    m_tb_store_state_t *p_entry = (m_tb_store_state_t *)M_TB_STORE_GET_FIRST_ENTRY(p_section);
    // Counter
    uint8_t cnt;

    for (cnt = 0; cnt < p_section->nb_entries; cnt++)
   1471e:	9306      	str	r3, [sp, #24]
    // Get loading procedure information
    m_tb_store_load_info_t *p_load_info = p_m_tb_store_env->p_load_info;
    // Get pointer to section
    m_tb_store_hdr_t *p_section = p_load_info->p_section;
    // Get first entry in the section
    m_tb_store_state_t *p_entry = (m_tb_store_state_t *)M_TB_STORE_GET_FIRST_ENTRY(p_section);
   14720:	0035      	movs	r5, r6
   14722:	3508      	adds	r5, #8
    // Counter
    uint8_t cnt;

    for (cnt = 0; cnt < p_section->nb_entries; cnt++)
   14724:	78f3      	ldrb	r3, [r6, #3]
   14726:	9a06      	ldr	r2, [sp, #24]
   14728:	4293      	cmp	r3, r2
   1472a:	d800      	bhi.n	1472e <m_tb_store_load_fsm+0x76>
   1472c:	e16d      	b.n	14a0a <m_tb_store_load_fsm+0x352>
    {
        switch (p_entry->type)
   1472e:	7868      	ldrb	r0, [r5, #1]
   14730:	2808      	cmp	r0, #8
   14732:	d900      	bls.n	14736 <m_tb_store_load_fsm+0x7e>
   14734:	e166      	b.n	14a04 <m_tb_store_load_fsm+0x34c>
   14736:	f009 fb17 	bl	1dd68 <__gnu_thumb1_case_uhi>
   1473a:	0009      	.short	0x0009
   1473c:	00140010 	.word	0x00140010
   14740:	001c0018 	.word	0x001c0018
   14744:	01650165 	.word	0x01650165
   14748:	002a0021 	.word	0x002a0021
        {
            case (M_TB_STORE_TYPE_UNICAST_ADDR):
            {
                m_tb_mio_set_prim_addr(co_read16p(&p_entry->val[0]));
   1474c:	78e8      	ldrb	r0, [r5, #3]
   1474e:	78ab      	ldrb	r3, [r5, #2]
   14750:	0200      	lsls	r0, r0, #8
   14752:	4318      	orrs	r0, r3
   14754:	f7ff f93e 	bl	139d4 <m_tb_mio_set_prim_addr>
   14758:	e142      	b.n	149e0 <m_tb_store_load_fsm+0x328>
            } break;

            case (M_TB_STORE_TYPE_DEFAULT_TTL_STATE):
            {
                m_tb_state_set_default_ttl(p_entry->val[0]);
   1475a:	78a8      	ldrb	r0, [r5, #2]
   1475c:	f7ff fcfe 	bl	1415c <m_tb_state_set_default_ttl>
   14760:	e13e      	b.n	149e0 <m_tb_store_load_fsm+0x328>
            } break;

            case (M_TB_STORE_TYPE_SEC_BCN_STATE):
            {
                m_tb_state_set_beacon_state(p_entry->val[0]);
   14762:	78a8      	ldrb	r0, [r5, #2]
   14764:	f7ff fd06 	bl	14174 <m_tb_state_set_beacon_state>
   14768:	e13a      	b.n	149e0 <m_tb_store_load_fsm+0x328>
            } break;

            case (M_TB_STORE_TYPE_NET_TX_STATE):
            {
                m_tb_state_set_net_tx_state(p_entry->val[0]);
   1476a:	78a8      	ldrb	r0, [r5, #2]
   1476c:	f7ff fd40 	bl	141f0 <m_tb_state_set_net_tx_state>
   14770:	e136      	b.n	149e0 <m_tb_store_load_fsm+0x328>
            } break;

            #if (BLE_MESH_RELAY)
            case (M_TB_STORE_TYPE_RELAY_STATE):
            {
                m_tb_state_set_relay_state(p_entry->val[0], p_entry->val[1]);
   14772:	78e9      	ldrb	r1, [r5, #3]
   14774:	78a8      	ldrb	r0, [r5, #2]
   14776:	f7ff fd15 	bl	141a4 <m_tb_state_set_relay_state>
   1477a:	e131      	b.n	149e0 <m_tb_store_load_fsm+0x328>
            } break;
            #endif //(BLE_MESH_FRIEND)

            case (M_TB_STORE_TYPE_DEV_KEY):
            {
                status = m_tb_key_dev_add(&p_entry->val[0]);
   1477c:	1ca8      	adds	r0, r5, #2
   1477e:	f7fd fb25 	bl	11dcc <m_tb_key_dev_add>
   14782:	1e04      	subs	r4, r0, #0

                if (status == M_ERR_NO_ERROR)
   14784:	d1ae      	bne.n	146e4 <m_tb_store_load_fsm+0x2c>
                {
                    m_tb_key_model_bind(M_TB_KEY_DEVICE_LID, 0);
   14786:	0001      	movs	r1, r0
   14788:	f7fe f904 	bl	12994 <m_tb_key_model_bind>
   1478c:	e128      	b.n	149e0 <m_tb_store_load_fsm+0x328>
            {
                // Map another structure on the received data
                m_tb_store_state_iv_seq_t *p_entry_iv_seq
                                                = (m_tb_store_state_iv_seq_t *)p_entry;

                m_tb_key_set_iv_seq(p_entry_iv_seq->iv, p_entry_iv_seq->seq);
   1478e:	68e9      	ldr	r1, [r5, #12]
   14790:	68a8      	ldr	r0, [r5, #8]
   14792:	f7fe fa4b 	bl	12c2c <m_tb_key_set_iv_seq>
   14796:	e123      	b.n	149e0 <m_tb_store_load_fsm+0x328>
__STATIC uint16_t m_tb_store_load_next_net_key(void)
{
    // Status
    uint16_t status;
    // Get loading procedure information
    m_tb_store_load_info_t *p_load_info = p_m_tb_store_env->p_load_info;
   14798:	685a      	ldr	r2, [r3, #4]
    // Get pointer to section
    m_tb_store_hdr_t *p_section = p_load_info->p_section;
    // Pointer to network key information
    m_tb_store_netkey_t *p_net_key;

    if (p_load_info->p_entry == NULL)
   1479a:	6891      	ldr	r1, [r2, #8]
   1479c:	2900      	cmp	r1, #0
   1479e:	d106      	bne.n	147ae <m_tb_store_load_fsm+0xf6>
    // Status
    uint16_t status;
    // Get loading procedure information
    m_tb_store_load_info_t *p_load_info = p_m_tb_store_env->p_load_info;
    // Get pointer to section
    m_tb_store_hdr_t *p_section = p_load_info->p_section;
   147a0:	6853      	ldr	r3, [r2, #4]
    // Pointer to network key information
    m_tb_store_netkey_t *p_net_key;

    if (p_load_info->p_entry == NULL)
    {
        p_load_info->rem_section_len = p_section->length - sizeof(m_tb_store_hdr_t);
   147a2:	8819      	ldrh	r1, [r3, #0]
        // Point on first entry
        p_load_info->p_entry = M_TB_STORE_GET_FIRST_ENTRY(p_section);
   147a4:	3308      	adds	r3, #8
    // Pointer to network key information
    m_tb_store_netkey_t *p_net_key;

    if (p_load_info->p_entry == NULL)
    {
        p_load_info->rem_section_len = p_section->length - sizeof(m_tb_store_hdr_t);
   147a6:	3908      	subs	r1, #8
   147a8:	8191      	strh	r1, [r2, #12]
        // Point on first entry
        p_load_info->p_entry = M_TB_STORE_GET_FIRST_ENTRY(p_section);
   147aa:	6093      	str	r3, [r2, #8]
   147ac:	e002      	b.n	147b4 <m_tb_store_load_fsm+0xfc>
    }
    else
    {
        // Get next entry
        p_load_info->p_entry = M_TB_STORE_GET_NEXT_ENTRY(p_load_info->p_entry);
   147ae:	780b      	ldrb	r3, [r1, #0]
   147b0:	18cb      	adds	r3, r1, r3
   147b2:	6093      	str	r3, [r2, #8]
    }

    p_net_key = (m_tb_store_netkey_t *)p_load_info->p_entry;
   147b4:	6893      	ldr	r3, [r2, #8]

    // Add network key
    // TODO [LT] - Use flags value
    status = m_tb_key_net_add(p_net_key->netkey_id, &p_net_key->key[0], 0,
   147b6:	2200      	movs	r2, #0
   147b8:	1d19      	adds	r1, r3, #4
   147ba:	8858      	ldrh	r0, [r3, #2]
   147bc:	4b8d      	ldr	r3, [pc, #564]	; (149f4 <m_tb_store_load_fsm+0x33c>)
   147be:	f7fd fb55 	bl	11e6c <m_tb_key_net_add>
   147c2:	0004      	movs	r4, r0
            } break;

            case (M_TB_STORE_SECT_TYPE_NET_KEY):
            {
                status = m_tb_store_load_next_net_key();
            } break;
   147c4:	e78e      	b.n	146e4 <m_tb_store_load_fsm+0x2c>
__STATIC uint16_t m_tb_store_load_next_app_key(void)
{
    // Status
    uint16_t status;
    // Get loading procedure information
    m_tb_store_load_info_t *p_load_info = p_m_tb_store_env->p_load_info;
   147c6:	685a      	ldr	r2, [r3, #4]
    // Pointer to application key information
    m_tb_store_appkey_t *p_app_key;
    // Network key local index
    m_lid_t net_key_lid;

    if (p_load_info->p_entry == NULL)
   147c8:	6891      	ldr	r1, [r2, #8]
   147ca:	2900      	cmp	r1, #0
   147cc:	d106      	bne.n	147dc <m_tb_store_load_fsm+0x124>
    // Status
    uint16_t status;
    // Get loading procedure information
    m_tb_store_load_info_t *p_load_info = p_m_tb_store_env->p_load_info;
    // Get pointer to section
    m_tb_store_hdr_t *p_section = p_load_info->p_section;
   147ce:	6853      	ldr	r3, [r2, #4]
    // Network key local index
    m_lid_t net_key_lid;

    if (p_load_info->p_entry == NULL)
    {
        p_load_info->rem_section_len = p_section->length - sizeof(m_tb_store_hdr_t);
   147d0:	8819      	ldrh	r1, [r3, #0]
        // Point on first entry
        p_load_info->p_entry = M_TB_STORE_GET_FIRST_ENTRY(p_section);
   147d2:	3308      	adds	r3, #8
    // Network key local index
    m_lid_t net_key_lid;

    if (p_load_info->p_entry == NULL)
    {
        p_load_info->rem_section_len = p_section->length - sizeof(m_tb_store_hdr_t);
   147d4:	3908      	subs	r1, #8
   147d6:	8191      	strh	r1, [r2, #12]
        // Point on first entry
        p_load_info->p_entry = M_TB_STORE_GET_FIRST_ENTRY(p_section);
   147d8:	6093      	str	r3, [r2, #8]
   147da:	e002      	b.n	147e2 <m_tb_store_load_fsm+0x12a>
    }
    else
    {
        // Get next entry
        p_load_info->p_entry = M_TB_STORE_GET_NEXT_ENTRY(p_load_info->p_entry);
   147dc:	780b      	ldrb	r3, [r1, #0]
   147de:	18cb      	adds	r3, r1, r3
   147e0:	6093      	str	r3, [r2, #8]
    }

    p_app_key = (m_tb_store_appkey_t *)p_load_info->p_entry;

    // Seek for network key
    status = m_tb_key_net_find(p_app_key->netkey_id, &net_key_lid);
   147e2:	2617      	movs	r6, #23
    {
        // Get next entry
        p_load_info->p_entry = M_TB_STORE_GET_NEXT_ENTRY(p_load_info->p_entry);
    }

    p_app_key = (m_tb_store_appkey_t *)p_load_info->p_entry;
   147e4:	6895      	ldr	r5, [r2, #8]

    // Seek for network key
    status = m_tb_key_net_find(p_app_key->netkey_id, &net_key_lid);
   147e6:	ab06      	add	r3, sp, #24
   147e8:	18f6      	adds	r6, r6, r3
   147ea:	8868      	ldrh	r0, [r5, #2]
   147ec:	0031      	movs	r1, r6
   147ee:	f7fd fd4b 	bl	12288 <m_tb_key_net_find>
   147f2:	1e04      	subs	r4, r0, #0

    if (status == M_ERR_NO_ERROR)
   147f4:	d000      	beq.n	147f8 <m_tb_store_load_fsm+0x140>
   147f6:	e775      	b.n	146e4 <m_tb_store_load_fsm+0x2c>
    {
        // Add application key
        status = m_tb_key_app_add(p_app_key->appkey_id,
   147f8:	7832      	ldrb	r2, [r6, #0]
                                  &p_app_key->key[0], net_key_lid, m_tb_store_cb_appkey_added);
   147fa:	1da9      	adds	r1, r5, #6
    status = m_tb_key_net_find(p_app_key->netkey_id, &net_key_lid);

    if (status == M_ERR_NO_ERROR)
    {
        // Add application key
        status = m_tb_key_app_add(p_app_key->appkey_id,
   147fc:	88a8      	ldrh	r0, [r5, #4]
   147fe:	4b7e      	ldr	r3, [pc, #504]	; (149f8 <m_tb_store_load_fsm+0x340>)
   14800:	f7fd fe36 	bl	12470 <m_tb_key_app_add>
   14804:	0004      	movs	r4, r0
            } break;

            case (M_TB_STORE_SECT_TYPE_APP_KEY):
            {
                status = m_tb_store_load_next_app_key();
            } break;
   14806:	e76d      	b.n	146e4 <m_tb_store_load_fsm+0x2c>
}

__STATIC uint16_t m_tb_store_load_publi_param(void)
{
    // Get loading procedure information
    m_tb_store_load_info_t *p_load_info = p_m_tb_store_env->p_load_info;
   14808:	685e      	ldr	r6, [r3, #4]
    // Status
    uint16_t status = M_ERR_NO_ERROR;
    // Counter
    uint8_t cnt;

    for (cnt = 0; cnt < p_section->nb_entries; cnt++)
   1480a:	2300      	movs	r3, #0
__STATIC uint16_t m_tb_store_load_publi_param(void)
{
    // Get loading procedure information
    m_tb_store_load_info_t *p_load_info = p_m_tb_store_env->p_load_info;
    // Get pointer to section
    m_tb_store_hdr_t *p_section = p_load_info->p_section;
   1480c:	6877      	ldr	r7, [r6, #4]
    // Status
    uint16_t status = M_ERR_NO_ERROR;
    // Counter
    uint8_t cnt;

    for (cnt = 0; cnt < p_section->nb_entries; cnt++)
   1480e:	9306      	str	r3, [sp, #24]
    // Get loading procedure information
    m_tb_store_load_info_t *p_load_info = p_m_tb_store_env->p_load_info;
    // Get pointer to section
    m_tb_store_hdr_t *p_section = p_load_info->p_section;
    // Get first publication parameters entry
    m_tb_store_publi_virt_t *p_publi_param = (m_tb_store_publi_virt_t *)M_TB_STORE_GET_FIRST_ENTRY(p_section);
   14810:	003d      	movs	r5, r7
   14812:	3508      	adds	r5, #8
    // Status
    uint16_t status = M_ERR_NO_ERROR;
    // Counter
    uint8_t cnt;

    for (cnt = 0; cnt < p_section->nb_entries; cnt++)
   14814:	78fb      	ldrb	r3, [r7, #3]
   14816:	9a06      	ldr	r2, [sp, #24]
   14818:	4293      	cmp	r3, r2
   1481a:	d800      	bhi.n	1481e <m_tb_store_load_fsm+0x166>
   1481c:	e0fa      	b.n	14a14 <m_tb_store_load_fsm+0x35c>
    {
        // Get model local index
        m_lid_t model_lid;

        status = m_tb_mio_get_local_id(p_publi_param->element_addr, p_publi_param->model_id,
   1481e:	2301      	movs	r3, #1
   14820:	786a      	ldrb	r2, [r5, #1]
   14822:	a906      	add	r1, sp, #24
   14824:	401a      	ands	r2, r3
   14826:	3316      	adds	r3, #22
   14828:	185b      	adds	r3, r3, r1
   1482a:	8868      	ldrh	r0, [r5, #2]
   1482c:	6869      	ldr	r1, [r5, #4]
   1482e:	f7fe fd03 	bl	13238 <m_tb_mio_get_local_id>
   14832:	1e04      	subs	r4, r0, #0
                                       GETB(p_publi_param->info, M_TB_STORE_PUBLI_INFO_VENDOR),
                                       &model_lid);

        if (status != M_ERR_NO_ERROR)
   14834:	d000      	beq.n	14838 <m_tb_store_load_fsm+0x180>
   14836:	e755      	b.n	146e4 <m_tb_store_load_fsm+0x2c>
        {
            break;
        }

        // Get application key local index
        m_tb_key_app_find(p_publi_param->appkey_id, &app_key_lid);
   14838:	2316      	movs	r3, #22
   1483a:	aa06      	add	r2, sp, #24
   1483c:	189b      	adds	r3, r3, r2
   1483e:	0019      	movs	r1, r3
   14840:	8968      	ldrh	r0, [r5, #10]
   14842:	f7fd ffdb 	bl	127fc <m_tb_key_app_find>

        // Set publication parameters
        status = m_tb_mio_set_publi_param(model_lid, p_publi_param->addr,
   14846:	0022      	movs	r2, r4
   14848:	2480      	movs	r4, #128	; 0x80
                                          M_IS_VIRTUAL_ADDR(p_publi_param->addr) ? &p_publi_param->label_uuid[0] : NULL,
   1484a:	8929      	ldrh	r1, [r5, #8]

        // Get application key local index
        m_tb_key_app_find(p_publi_param->appkey_id, &app_key_lid);

        // Set publication parameters
        status = m_tb_mio_set_publi_param(model_lid, p_publi_param->addr,
   1484c:	ab06      	add	r3, sp, #24
   1484e:	7dd8      	ldrb	r0, [r3, #23]
   14850:	0b8b      	lsrs	r3, r1, #14
   14852:	039b      	lsls	r3, r3, #14
   14854:	0224      	lsls	r4, r4, #8
   14856:	42a3      	cmp	r3, r4
   14858:	d101      	bne.n	1485e <m_tb_store_load_fsm+0x1a6>
   1485a:	002a      	movs	r2, r5
   1485c:	3210      	adds	r2, #16
   1485e:	7bec      	ldrb	r4, [r5, #15]
   14860:	ab06      	add	r3, sp, #24
   14862:	7d9b      	ldrb	r3, [r3, #22]
   14864:	9403      	str	r4, [sp, #12]
   14866:	7bac      	ldrb	r4, [r5, #14]
   14868:	9402      	str	r4, [sp, #8]
   1486a:	7b6c      	ldrb	r4, [r5, #13]
   1486c:	9401      	str	r4, [sp, #4]
   1486e:	7b2c      	ldrb	r4, [r5, #12]
   14870:	9400      	str	r4, [sp, #0]
   14872:	f7fe fd73 	bl	1335c <m_tb_mio_set_publi_param>
   14876:	1e04      	subs	r4, r0, #0
                                          M_IS_VIRTUAL_ADDR(p_publi_param->addr) ? &p_publi_param->label_uuid[0] : NULL,
                                          app_key_lid, p_publi_param->ttl, p_publi_param->period,
                                          p_publi_param->retx_params, p_publi_param->friend_cred);

        if (status != M_ERR_NO_ERROR)
   14878:	d000      	beq.n	1487c <m_tb_store_load_fsm+0x1c4>
   1487a:	e733      	b.n	146e4 <m_tb_store_load_fsm+0x2c>
        {
            break;
        }

        // Get next entry
        p_publi_param = (m_tb_store_publi_virt_t *)M_TB_STORE_GET_NEXT_ENTRY(p_publi_param);
   1487c:	782b      	ldrb	r3, [r5, #0]
   1487e:	18ed      	adds	r5, r5, r3
    // Status
    uint16_t status = M_ERR_NO_ERROR;
    // Counter
    uint8_t cnt;

    for (cnt = 0; cnt < p_section->nb_entries; cnt++)
   14880:	9b06      	ldr	r3, [sp, #24]
   14882:	3301      	adds	r3, #1
   14884:	b2db      	uxtb	r3, r3
   14886:	9306      	str	r3, [sp, #24]
   14888:	e7c4      	b.n	14814 <m_tb_store_load_fsm+0x15c>
}

__STATIC uint16_t m_tb_store_load_subs_list(void)
{
    // Get loading procedure information
    m_tb_store_load_info_t *p_load_info = p_m_tb_store_env->p_load_info;
   1488a:	685f      	ldr	r7, [r3, #4]
    // Get pointer to section
    m_tb_store_hdr_t *p_section = p_load_info->p_section;
   1488c:	687b      	ldr	r3, [r7, #4]
    // Get first subscription list entry
    m_tb_store_subs_t *p_subs_list = (m_tb_store_subs_t *)M_TB_STORE_GET_FIRST_ENTRY(p_section);
   1488e:	001d      	movs	r5, r3
__STATIC uint16_t m_tb_store_load_subs_list(void)
{
    // Get loading procedure information
    m_tb_store_load_info_t *p_load_info = p_m_tb_store_env->p_load_info;
    // Get pointer to section
    m_tb_store_hdr_t *p_section = p_load_info->p_section;
   14890:	9306      	str	r3, [sp, #24]
    // Status
    uint16_t status = M_ERR_NO_ERROR;
    // Counter
    uint8_t cnt;

    for (cnt = 0; cnt < p_section->nb_entries; cnt++)
   14892:	2300      	movs	r3, #0
    // Get loading procedure information
    m_tb_store_load_info_t *p_load_info = p_m_tb_store_env->p_load_info;
    // Get pointer to section
    m_tb_store_hdr_t *p_section = p_load_info->p_section;
    // Get first subscription list entry
    m_tb_store_subs_t *p_subs_list = (m_tb_store_subs_t *)M_TB_STORE_GET_FIRST_ENTRY(p_section);
   14894:	3508      	adds	r5, #8
    // Status
    uint16_t status = M_ERR_NO_ERROR;
    // Counter
    uint8_t cnt;

    for (cnt = 0; cnt < p_section->nb_entries; cnt++)
   14896:	9308      	str	r3, [sp, #32]
   14898:	9b06      	ldr	r3, [sp, #24]
   1489a:	9a08      	ldr	r2, [sp, #32]
   1489c:	78db      	ldrb	r3, [r3, #3]
   1489e:	4293      	cmp	r3, r2
   148a0:	d800      	bhi.n	148a4 <m_tb_store_load_fsm+0x1ec>
   148a2:	e0ca      	b.n	14a3a <m_tb_store_load_fsm+0x382>
        uint8_t nb_rem_addr;
        // Read pointer
        uint8_t *p_read;

        // Get model local index
        status = m_tb_mio_get_local_id(p_subs_list->element_addr, p_subs_list->model_id,
   148a4:	2317      	movs	r3, #23
   148a6:	786a      	ldrb	r2, [r5, #1]
   148a8:	a906      	add	r1, sp, #24
   148aa:	185b      	adds	r3, r3, r1
   148ac:	09d2      	lsrs	r2, r2, #7
   148ae:	8868      	ldrh	r0, [r5, #2]
   148b0:	6869      	ldr	r1, [r5, #4]
   148b2:	f7fe fcc1 	bl	13238 <m_tb_mio_get_local_id>
   148b6:	1e04      	subs	r4, r0, #0
                                       GETB(p_subs_list->info, M_TB_STORE_SUBS_INFO_VENDOR),
                                       &model_lid);

        if (status != M_ERR_NO_ERROR)
   148b8:	d000      	beq.n	148bc <m_tb_store_load_fsm+0x204>
   148ba:	e713      	b.n	146e4 <m_tb_store_load_fsm+0x2c>
        {
            break;
        }

        nb_rem_addr = GETF(p_subs_list->info, M_TB_STORE_SUBS_INFO_NB_ADDR);
   148bc:	227f      	movs	r2, #127	; 0x7f
        p_read = &p_subs_list->list[0];
   148be:	002e      	movs	r6, r5
        if (status != M_ERR_NO_ERROR)
        {
            break;
        }

        nb_rem_addr = GETF(p_subs_list->info, M_TB_STORE_SUBS_INFO_NB_ADDR);
   148c0:	786b      	ldrb	r3, [r5, #1]
        p_read = &p_subs_list->list[0];
   148c2:	3608      	adds	r6, #8
        if (status != M_ERR_NO_ERROR)
        {
            break;
        }

        nb_rem_addr = GETF(p_subs_list->info, M_TB_STORE_SUBS_INFO_NB_ADDR);
   148c4:	401a      	ands	r2, r3
   148c6:	9207      	str	r2, [sp, #28]
        p_read = &p_subs_list->list[0];

        // Add all provided addresses
        while (nb_rem_addr--)
   148c8:	9b07      	ldr	r3, [sp, #28]
   148ca:	3b01      	subs	r3, #1
   148cc:	b2db      	uxtb	r3, r3
   148ce:	9307      	str	r3, [sp, #28]
   148d0:	2bff      	cmp	r3, #255	; 0xff
   148d2:	d100      	bne.n	148d6 <m_tb_store_load_fsm+0x21e>
   148d4:	e0a3      	b.n	14a1e <m_tb_store_load_fsm+0x366>
   148d6:	2217      	movs	r2, #23
   148d8:	a806      	add	r0, sp, #24
   148da:	1812      	adds	r2, r2, r0
            // Read address
            uint16_t addr = co_read16p(p_read);

            p_read += sizeof(uint16_t);

            if (M_IS_VIRTUAL_ADDR(addr))
   148dc:	2080      	movs	r0, #128	; 0x80
 * @return The 16 bits value.
 ****************************************************************************************
 */
__INLINE_S__ uint16_t co_read16p(void const *ptr16)
{
    uint16_t value = ((uint8_t *)ptr16)[0] | ((uint8_t *)ptr16)[1] << 8;
   148de:	7871      	ldrb	r1, [r6, #1]
   148e0:	7833      	ldrb	r3, [r6, #0]
   148e2:	0209      	lsls	r1, r1, #8
   148e4:	4319      	orrs	r1, r3
        while (nb_rem_addr--)
        {
            // Read address
            uint16_t addr = co_read16p(p_read);

            p_read += sizeof(uint16_t);
   148e6:	1cb3      	adds	r3, r6, #2
   148e8:	9309      	str	r3, [sp, #36]	; 0x24

            if (M_IS_VIRTUAL_ADDR(addr))
   148ea:	0b8b      	lsrs	r3, r1, #14
   148ec:	039b      	lsls	r3, r3, #14
   148ee:	0200      	lsls	r0, r0, #8
   148f0:	4283      	cmp	r3, r0
   148f2:	d106      	bne.n	14902 <m_tb_store_load_fsm+0x24a>
            {
                status = m_tb_mio_add_subscription_virt(model_lid, addr, p_read);
   148f4:	7810      	ldrb	r0, [r2, #0]
   148f6:	1cb2      	adds	r2, r6, #2
   148f8:	f7fe fe50 	bl	1359c <m_tb_mio_add_subscription_virt>
                p_read += M_LABEL_UUID_LEN;
   148fc:	3612      	adds	r6, #18

            p_read += sizeof(uint16_t);

            if (M_IS_VIRTUAL_ADDR(addr))
            {
                status = m_tb_mio_add_subscription_virt(model_lid, addr, p_read);
   148fe:	0004      	movs	r4, r0
   14900:	e004      	b.n	1490c <m_tb_store_load_fsm+0x254>
                p_read += M_LABEL_UUID_LEN;
            }
            else
            {
                status = m_tb_mio_add_subscription(model_lid, addr);
   14902:	7810      	ldrb	r0, [r2, #0]
   14904:	f7fe fdd4 	bl	134b0 <m_tb_mio_add_subscription>
   14908:	0004      	movs	r4, r0
        while (nb_rem_addr--)
        {
            // Read address
            uint16_t addr = co_read16p(p_read);

            p_read += sizeof(uint16_t);
   1490a:	9e09      	ldr	r6, [sp, #36]	; 0x24
            else
            {
                status = m_tb_mio_add_subscription(model_lid, addr);
            }

            if (status != M_ERR_NO_ERROR)
   1490c:	2c00      	cmp	r4, #0
   1490e:	d0db      	beq.n	148c8 <m_tb_store_load_fsm+0x210>
   14910:	e6e8      	b.n	146e4 <m_tb_store_load_fsm+0x2c>
}

__STATIC uint16_t m_tb_store_load_binding(void)
{
    // Get loading procedure information
    m_tb_store_load_info_t *p_load_info = p_m_tb_store_env->p_load_info;
   14912:	685f      	ldr	r7, [r3, #4]
    // Get pointer to section
    m_tb_store_hdr_t *p_section = p_load_info->p_section;
   14914:	687b      	ldr	r3, [r7, #4]
    // Get first model/key binding entry
    m_tb_store_binding_t *p_binding = (m_tb_store_binding_t *)M_TB_STORE_GET_FIRST_ENTRY(p_section);
   14916:	001d      	movs	r5, r3
__STATIC uint16_t m_tb_store_load_binding(void)
{
    // Get loading procedure information
    m_tb_store_load_info_t *p_load_info = p_m_tb_store_env->p_load_info;
    // Get pointer to section
    m_tb_store_hdr_t *p_section = p_load_info->p_section;
   14918:	9306      	str	r3, [sp, #24]
    // Status
    uint16_t status = M_ERR_NO_ERROR;
    // Counter
    uint8_t cnt;

    for (cnt = 0; cnt < p_section->nb_entries; cnt++)
   1491a:	2300      	movs	r3, #0
    // Get loading procedure information
    m_tb_store_load_info_t *p_load_info = p_m_tb_store_env->p_load_info;
    // Get pointer to section
    m_tb_store_hdr_t *p_section = p_load_info->p_section;
    // Get first model/key binding entry
    m_tb_store_binding_t *p_binding = (m_tb_store_binding_t *)M_TB_STORE_GET_FIRST_ENTRY(p_section);
   1491c:	3508      	adds	r5, #8
    // Status
    uint16_t status = M_ERR_NO_ERROR;
    // Counter
    uint8_t cnt;

    for (cnt = 0; cnt < p_section->nb_entries; cnt++)
   1491e:	9308      	str	r3, [sp, #32]
   14920:	9b06      	ldr	r3, [sp, #24]
   14922:	9a08      	ldr	r2, [sp, #32]
   14924:	78db      	ldrb	r3, [r3, #3]
   14926:	4293      	cmp	r3, r2
   14928:	d800      	bhi.n	1492c <m_tb_store_load_fsm+0x274>
   1492a:	e086      	b.n	14a3a <m_tb_store_load_fsm+0x382>
        uint8_t rem_app_ids;
        // Read pointer
        uint16_t *p_appkey_id;

        // Get model local index
        status = m_tb_mio_get_local_id(p_binding->element_addr, p_binding->model_id,
   1492c:	2316      	movs	r3, #22
   1492e:	786a      	ldrb	r2, [r5, #1]
   14930:	a906      	add	r1, sp, #24
   14932:	185b      	adds	r3, r3, r1
   14934:	09d2      	lsrs	r2, r2, #7
   14936:	8868      	ldrh	r0, [r5, #2]
   14938:	6869      	ldr	r1, [r5, #4]
   1493a:	f7fe fc7d 	bl	13238 <m_tb_mio_get_local_id>
   1493e:	1e04      	subs	r4, r0, #0
                                       GETB(p_binding->info, M_TB_STORE_BINDING_INFO_VENDOR),
                                       &model_lid);

        if (status != M_ERR_NO_ERROR)
   14940:	d000      	beq.n	14944 <m_tb_store_load_fsm+0x28c>
   14942:	e6cf      	b.n	146e4 <m_tb_store_load_fsm+0x2c>
        {
            break;
        }

        rem_app_ids = GETF(p_binding->info, M_TB_STORE_BINDING_INFO_NB_APP_IDS);
   14944:	237f      	movs	r3, #127	; 0x7f
   14946:	786e      	ldrb	r6, [r5, #1]
   14948:	401e      	ands	r6, r3
        p_appkey_id = &p_binding->appkey_ids[0];
   1494a:	002b      	movs	r3, r5
   1494c:	3308      	adds	r3, #8
   1494e:	9307      	str	r3, [sp, #28]

        while (rem_app_ids--)
   14950:	3e01      	subs	r6, #1
   14952:	b2f6      	uxtb	r6, r6
   14954:	2eff      	cmp	r6, #255	; 0xff
   14956:	d069      	beq.n	14a2c <m_tb_store_load_fsm+0x374>
        {
            // Application key local index
            m_lid_t app_key_lid;

            // Get application key local index
            status = m_tb_key_app_find(*p_appkey_id, &app_key_lid);
   14958:	9b07      	ldr	r3, [sp, #28]
   1495a:	aa06      	add	r2, sp, #24
   1495c:	8818      	ldrh	r0, [r3, #0]
   1495e:	2317      	movs	r3, #23
   14960:	189b      	adds	r3, r3, r2
   14962:	0019      	movs	r1, r3
   14964:	f7fd ff4a 	bl	127fc <m_tb_key_app_find>
   14968:	1e04      	subs	r4, r0, #0

            if (status != M_ERR_NO_ERROR)
   1496a:	d000      	beq.n	1496e <m_tb_store_load_fsm+0x2b6>
   1496c:	e6ba      	b.n	146e4 <m_tb_store_load_fsm+0x2c>
            {
                break;
            }

            // Bind the model and the application key
            m_tb_key_model_bind(app_key_lid, model_lid);
   1496e:	ab06      	add	r3, sp, #24
   14970:	3416      	adds	r4, #22
   14972:	18e4      	adds	r4, r4, r3
   14974:	7dd8      	ldrb	r0, [r3, #23]
   14976:	7821      	ldrb	r1, [r4, #0]
   14978:	f7fe f80c 	bl	12994 <m_tb_key_model_bind>
            m_tb_mio_bind(model_lid);
   1497c:	7820      	ldrb	r0, [r4, #0]
   1497e:	f7fe ffcd 	bl	1391c <m_tb_mio_bind>

            p_appkey_id++;
   14982:	9b07      	ldr	r3, [sp, #28]
   14984:	3302      	adds	r3, #2
   14986:	9307      	str	r3, [sp, #28]
   14988:	e7e2      	b.n	14950 <m_tb_store_load_fsm+0x298>
        {
            break;
        }
    }

    if ((status != M_ERR_NO_ERROR) || (p_load_info->rem_nb_section == 0))
   1498a:	9b04      	ldr	r3, [sp, #16]
   1498c:	7b9b      	ldrb	r3, [r3, #14]
   1498e:	2b00      	cmp	r3, #0
   14990:	d004      	beq.n	1499c <m_tb_store_load_fsm+0x2e4>
   14992:	e059      	b.n	14a48 <m_tb_store_load_fsm+0x390>
   14994:	2c00      	cmp	r4, #0
   14996:	d0f8      	beq.n	1498a <m_tb_store_load_fsm+0x2d2>
   14998:	9405      	str	r4, [sp, #20]
   1499a:	e01c      	b.n	149d6 <m_tb_store_load_fsm+0x31e>
    {
        if (status == M_ERR_NO_ERROR)
        {
        	M_PRINTF(L_TB, "set state prov");
   1499c:	4b17      	ldr	r3, [pc, #92]	; (149fc <m_tb_store_load_fsm+0x344>)
   1499e:	681b      	ldr	r3, [r3, #0]
   149a0:	079b      	lsls	r3, r3, #30
   149a2:	d515      	bpl.n	149d0 <m_tb_store_load_fsm+0x318>
   149a4:	4c16      	ldr	r4, [pc, #88]	; (14a00 <m_tb_store_load_fsm+0x348>)
   149a6:	0023      	movs	r3, r4
   149a8:	3340      	adds	r3, #64	; 0x40
   149aa:	9300      	str	r3, [sp, #0]
   149ac:	0022      	movs	r2, r4
   149ae:	0020      	movs	r0, r4
   149b0:	23a2      	movs	r3, #162	; 0xa2
   149b2:	0021      	movs	r1, r4
   149b4:	3220      	adds	r2, #32
   149b6:	00db      	lsls	r3, r3, #3
   149b8:	3031      	adds	r0, #49	; 0x31
   149ba:	f7ef fff7 	bl	49ac <m_print>
   149be:	0020      	movs	r0, r4
   149c0:	3054      	adds	r0, #84	; 0x54
   149c2:	f7ef fff3 	bl	49ac <m_print>
   149c6:	0020      	movs	r0, r4
   149c8:	1da1      	adds	r1, r4, #6
   149ca:	3063      	adds	r0, #99	; 0x63
   149cc:	f7ef ffee 	bl	49ac <m_print>
            // If we are here it means that the device is provisioned
            m_tb_state_set_prov_state(M_TB_STATE_PROV_STATE_PROV);
   149d0:	2002      	movs	r0, #2
   149d2:	f7ff fb91 	bl	140f8 <m_tb_state_set_prov_state>
        }

        // Call the callback
        p_load_info->cb_load(status);
   149d6:	9b04      	ldr	r3, [sp, #16]
   149d8:	9805      	ldr	r0, [sp, #20]
   149da:	681b      	ldr	r3, [r3, #0]
   149dc:	4798      	blx	r3
    }
}
   149de:	e033      	b.n	14a48 <m_tb_store_load_fsm+0x390>
        {
            break;
        }

        // Get next entry
        p_entry = (m_tb_store_state_t *)M_TB_STORE_GET_NEXT_ENTRY(p_entry);
   149e0:	782b      	ldrb	r3, [r5, #0]
   149e2:	18ed      	adds	r5, r5, r3
    // Get first entry in the section
    m_tb_store_state_t *p_entry = (m_tb_store_state_t *)M_TB_STORE_GET_FIRST_ENTRY(p_section);
    // Counter
    uint8_t cnt;

    for (cnt = 0; cnt < p_section->nb_entries; cnt++)
   149e4:	9b06      	ldr	r3, [sp, #24]
   149e6:	3301      	adds	r3, #1
   149e8:	b2db      	uxtb	r3, r3
   149ea:	9306      	str	r3, [sp, #24]
   149ec:	e69a      	b.n	14724 <m_tb_store_load_fsm+0x6c>
   149ee:	46c0      	nop			; (mov r8, r8)
   149f0:	100126d0 	.word	0x100126d0
   149f4:	00014605 	.word	0x00014605
   149f8:	00014655 	.word	0x00014655
   149fc:	10010514 	.word	0x10010514
   14a00:	00022a71 	.word	0x00022a71
                m_tb_key_set_iv_seq(p_entry_iv_seq->iv, p_entry_iv_seq->seq);
            } break;

            default:
            {
                status = M_ERR_INVALID_PARAM;
   14a04:	24c1      	movs	r4, #193	; 0xc1
   14a06:	0064      	lsls	r4, r4, #1
   14a08:	e66c      	b.n	146e4 <m_tb_store_load_fsm+0x2c>
    }

    if (status == M_ERR_NO_ERROR)
    {
        // Move on next section
        p_load_info->p_section = M_TB_STORE_GET_NEXT_SECTION(p_section);
   14a0a:	8833      	ldrh	r3, [r6, #0]
   14a0c:	2400      	movs	r4, #0
   14a0e:	18f6      	adds	r6, r6, r3
   14a10:	607e      	str	r6, [r7, #4]
   14a12:	e667      	b.n	146e4 <m_tb_store_load_fsm+0x2c>
    }

    if (status == M_ERR_NO_ERROR)
    {
        // Move on next section
        p_load_info->p_section = M_TB_STORE_GET_NEXT_SECTION(p_section);
   14a14:	883b      	ldrh	r3, [r7, #0]
   14a16:	2400      	movs	r4, #0
   14a18:	18fb      	adds	r3, r7, r3
   14a1a:	6073      	str	r3, [r6, #4]
   14a1c:	e662      	b.n	146e4 <m_tb_store_load_fsm+0x2c>
        {
            break;
        }

        // Get next entry
        p_subs_list = (m_tb_store_subs_t *)M_TB_STORE_GET_NEXT_ENTRY(p_subs_list);
   14a1e:	782b      	ldrb	r3, [r5, #0]
   14a20:	18ed      	adds	r5, r5, r3
    // Status
    uint16_t status = M_ERR_NO_ERROR;
    // Counter
    uint8_t cnt;

    for (cnt = 0; cnt < p_section->nb_entries; cnt++)
   14a22:	9b08      	ldr	r3, [sp, #32]
   14a24:	3301      	adds	r3, #1
   14a26:	b2db      	uxtb	r3, r3
   14a28:	9308      	str	r3, [sp, #32]
   14a2a:	e735      	b.n	14898 <m_tb_store_load_fsm+0x1e0>
        {
            break;
        }

        // Get next entry
        p_binding = (m_tb_store_binding_t *)M_TB_STORE_GET_NEXT_ENTRY(p_binding);
   14a2c:	782b      	ldrb	r3, [r5, #0]
   14a2e:	18ed      	adds	r5, r5, r3
    // Status
    uint16_t status = M_ERR_NO_ERROR;
    // Counter
    uint8_t cnt;

    for (cnt = 0; cnt < p_section->nb_entries; cnt++)
   14a30:	9b08      	ldr	r3, [sp, #32]
   14a32:	3301      	adds	r3, #1
   14a34:	b2db      	uxtb	r3, r3
   14a36:	9308      	str	r3, [sp, #32]
   14a38:	e772      	b.n	14920 <m_tb_store_load_fsm+0x268>
    }

    if (status == M_ERR_NO_ERROR)
    {
        // Move on next section
        p_load_info->p_section = M_TB_STORE_GET_NEXT_SECTION(p_section);
   14a3a:	9b06      	ldr	r3, [sp, #24]
   14a3c:	9a06      	ldr	r2, [sp, #24]
   14a3e:	881b      	ldrh	r3, [r3, #0]
   14a40:	2400      	movs	r4, #0
   14a42:	18d3      	adds	r3, r2, r3
   14a44:	607b      	str	r3, [r7, #4]
   14a46:	e64d      	b.n	146e4 <m_tb_store_load_fsm+0x2c>
        }

        // Call the callback
        p_load_info->cb_load(status);
    }
}
   14a48:	b00d      	add	sp, #52	; 0x34
   14a4a:	bdf0      	pop	{r4, r5, r6, r7, pc}

00014a4c <m_tb_store_init>:
 * GLOBAL FUNCTIONS
 ****************************************************************************************
 */

uint16_t m_tb_store_init(bool reset, void *p_env)
{
   14a4c:	4b04      	ldr	r3, [pc, #16]	; (14a60 <m_tb_store_init+0x14>)
    if (!reset)
   14a4e:	2800      	cmp	r0, #0
   14a50:	d102      	bne.n	14a58 <m_tb_store_init+0xc>
    {
        // Get environment for Storage Manager Toolbox
        p_m_tb_store_env = (m_tb_store_env_t *)p_env;
   14a52:	6019      	str	r1, [r3, #0]

        // Initialize environment
        p_m_tb_store_env->p_load_info = NULL;
   14a54:	6048      	str	r0, [r1, #4]
   14a56:	e001      	b.n	14a5c <m_tb_store_init+0x10>
        SETB(p_m_tb_store_env->config, M_TB_STORE_CONFIG_UPD_IND_EN, 1);
        #endif //(BLE_MESH_DBG)
    }
    else
    {
        p_m_tb_store_env = NULL;
   14a58:	2200      	movs	r2, #0
   14a5a:	601a      	str	r2, [r3, #0]
    }

    return (sizeof(m_tb_store_env_t));
}
   14a5c:	2008      	movs	r0, #8
   14a5e:	4770      	bx	lr
   14a60:	100126d0 	.word	0x100126d0

00014a64 <m_tb_store_get_env_size>:

uint16_t m_tb_store_get_env_size(const m_cfg_t* p_cfg)
{
    return (sizeof(m_tb_store_env_t));
}
   14a64:	2008      	movs	r0, #8
   14a66:	4770      	bx	lr

00014a68 <m_tb_store_load>:
    p_m_tb_store_env->config = config;
}
#endif //(BLE_MESH_DBG)

uint16_t m_tb_store_load(uint16_t length, uint8_t *p_data, m_tb_store_cb_load_t cb_load)
{
   14a68:	b5f0      	push	{r4, r5, r6, r7, lr}
        m_tb_store_load_info_t *p_load_info;
        // Number of sections
        uint8_t nb_section;

        // Check that no loading procedure is currently performed
        if (p_m_tb_store_env->p_load_info != NULL)
   14a6a:	4b62      	ldr	r3, [pc, #392]	; (14bf4 <m_tb_store_load+0x18c>)
    p_m_tb_store_env->config = config;
}
#endif //(BLE_MESH_DBG)

uint16_t m_tb_store_load(uint16_t length, uint8_t *p_data, m_tb_store_cb_load_t cb_load)
{
   14a6c:	b087      	sub	sp, #28
        m_tb_store_load_info_t *p_load_info;
        // Number of sections
        uint8_t nb_section;

        // Check that no loading procedure is currently performed
        if (p_m_tb_store_env->p_load_info != NULL)
   14a6e:	681b      	ldr	r3, [r3, #0]
    p_m_tb_store_env->config = config;
}
#endif //(BLE_MESH_DBG)

uint16_t m_tb_store_load(uint16_t length, uint8_t *p_data, m_tb_store_cb_load_t cb_load)
{
   14a70:	9002      	str	r0, [sp, #8]
        m_tb_store_load_info_t *p_load_info;
        // Number of sections
        uint8_t nb_section;

        // Check that no loading procedure is currently performed
        if (p_m_tb_store_env->p_load_info != NULL)
   14a72:	685b      	ldr	r3, [r3, #4]
    p_m_tb_store_env->config = config;
}
#endif //(BLE_MESH_DBG)

uint16_t m_tb_store_load(uint16_t length, uint8_t *p_data, m_tb_store_cb_load_t cb_load)
{
   14a74:	9103      	str	r1, [sp, #12]
   14a76:	9205      	str	r2, [sp, #20]
        m_tb_store_load_info_t *p_load_info;
        // Number of sections
        uint8_t nb_section;

        // Check that no loading procedure is currently performed
        if (p_m_tb_store_env->p_load_info != NULL)
   14a78:	2b00      	cmp	r3, #0
   14a7a:	d000      	beq.n	14a7e <m_tb_store_load+0x16>
   14a7c:	e0b3      	b.n	14be6 <m_tb_store_load+0x17e>

__STATIC uint16_t m_tb_check_stored_info(uint8_t *p_data, uint16_t length, uint8_t *p_nb_section)
{
    // Status
    uint16_t status = M_ERR_INVALID_PARAM;
	M_PRINTF(L_TB, "data pointer = 0x%08x length = %d", p_data, length);
   14a7e:	4b5e      	ldr	r3, [pc, #376]	; (14bf8 <m_tb_store_load+0x190>)
   14a80:	681b      	ldr	r3, [r3, #0]
   14a82:	079b      	lsls	r3, r3, #30
   14a84:	d516      	bpl.n	14ab4 <m_tb_store_load+0x4c>
   14a86:	4c5d      	ldr	r4, [pc, #372]	; (14bfc <m_tb_store_load+0x194>)
   14a88:	0023      	movs	r3, r4
   14a8a:	0022      	movs	r2, r4
   14a8c:	0020      	movs	r0, r4
   14a8e:	3366      	adds	r3, #102	; 0x66
   14a90:	3220      	adds	r2, #32
   14a92:	9300      	str	r3, [sp, #0]
   14a94:	0021      	movs	r1, r4
   14a96:	4b5a      	ldr	r3, [pc, #360]	; (14c00 <m_tb_store_load+0x198>)
   14a98:	3031      	adds	r0, #49	; 0x31
   14a9a:	f7ef ff87 	bl	49ac <m_print>
   14a9e:	0020      	movs	r0, r4
   14aa0:	9903      	ldr	r1, [sp, #12]
   14aa2:	307d      	adds	r0, #125	; 0x7d
   14aa4:	9a02      	ldr	r2, [sp, #8]
   14aa6:	f7ef ff81 	bl	49ac <m_print>
   14aaa:	0020      	movs	r0, r4
   14aac:	1da1      	adds	r1, r4, #6
   14aae:	3063      	adds	r0, #99	; 0x63
   14ab0:	f7ef ff7c 	bl	49ac <m_print>
    p_m_tb_store_env->config = config;
}
#endif //(BLE_MESH_DBG)

uint16_t m_tb_store_load(uint16_t length, uint8_t *p_data, m_tb_store_cb_load_t cb_load)
{
   14ab4:	2700      	movs	r7, #0
   14ab6:	0038      	movs	r0, r7
   14ab8:	9b03      	ldr	r3, [sp, #12]

        // Check that provided length matches with end of a section
        while (total_length < length)
        {
            // Check pattern value - Use co_read32p in case, length was not valid
            if (co_read32p(&p_section->pattern) != M_TB_STORE_SECTION_PATTERN)
   14aba:	4c52      	ldr	r4, [pc, #328]	; (14c04 <m_tb_store_load+0x19c>)
        uint8_t nb_section = 0;
        // Counter
        uint8_t cnt;

        // Check that provided length matches with end of a section
        while (total_length < length)
   14abc:	9a02      	ldr	r2, [sp, #8]
   14abe:	4282      	cmp	r2, r0
   14ac0:	d915      	bls.n	14aee <m_tb_store_load+0x86>
        {
            // Check pattern value - Use co_read32p in case, length was not valid
            if (co_read32p(&p_section->pattern) != M_TB_STORE_SECTION_PATTERN)
   14ac2:	79d9      	ldrb	r1, [r3, #7]
   14ac4:	799a      	ldrb	r2, [r3, #6]
   14ac6:	0209      	lsls	r1, r1, #8
   14ac8:	4311      	orrs	r1, r2
   14aca:	795a      	ldrb	r2, [r3, #5]
   14acc:	791d      	ldrb	r5, [r3, #4]
   14ace:	0212      	lsls	r2, r2, #8
   14ad0:	0409      	lsls	r1, r1, #16
   14ad2:	432a      	orrs	r2, r5
   14ad4:	4311      	orrs	r1, r2
   14ad6:	42a1      	cmp	r1, r4
   14ad8:	d128      	bne.n	14b2c <m_tb_store_load+0xc4>
            {
                break;
            }

            // Check section type
            if (p_section->type > M_TB_STORE_SECT_TYPE_BINDING)
   14ada:	789a      	ldrb	r2, [r3, #2]
   14adc:	2a05      	cmp	r2, #5
   14ade:	d825      	bhi.n	14b2c <m_tb_store_load+0xc4>
            {
                break;
            }

            // Increment number of sections
            nb_section++;
   14ae0:	1c7a      	adds	r2, r7, #1
   14ae2:	b2d7      	uxtb	r7, r2
            // Update total length
            total_length += p_section->length;
   14ae4:	881a      	ldrh	r2, [r3, #0]
   14ae6:	1810      	adds	r0, r2, r0
   14ae8:	b280      	uxth	r0, r0
            // Move on next section
            p_section = M_TB_STORE_GET_NEXT_SECTION(p_section);
   14aea:	189b      	adds	r3, r3, r2
   14aec:	e7e6      	b.n	14abc <m_tb_store_load+0x54>
        }

        if (total_length != length)
   14aee:	4282      	cmp	r2, r0
   14af0:	d11c      	bne.n	14b2c <m_tb_store_load+0xc4>
   14af2:	2200      	movs	r2, #0
   14af4:	9903      	ldr	r1, [sp, #12]

        // Go back on first section
        p_section = (m_tb_store_hdr_t *)p_data;

        // For each section, check that entry lengths are valid
        for (cnt = 0; cnt < nb_section; cnt++)
   14af6:	4297      	cmp	r7, r2
   14af8:	d016      	beq.n	14b28 <m_tb_store_load+0xc0>
            // Point to first entry
            m_tb_store_entry_t *p_entry = (m_tb_store_entry_t *)M_TB_STORE_GET_FIRST_ENTRY(p_section);

            total_length = 0;

            for (entries_cnt = 0; entries_cnt < p_section->nb_entries; entries_cnt++)
   14afa:	2300      	movs	r3, #0
        for (cnt = 0; cnt < nb_section; cnt++)
        {
            // Entries counter
            uint8_t entries_cnt;
            // Point to first entry
            m_tb_store_entry_t *p_entry = (m_tb_store_entry_t *)M_TB_STORE_GET_FIRST_ENTRY(p_section);
   14afc:	000c      	movs	r4, r1

            total_length = 0;
   14afe:	0018      	movs	r0, r3

            for (entries_cnt = 0; entries_cnt < p_section->nb_entries; entries_cnt++)
   14b00:	78ce      	ldrb	r6, [r1, #3]
        for (cnt = 0; cnt < nb_section; cnt++)
        {
            // Entries counter
            uint8_t entries_cnt;
            // Point to first entry
            m_tb_store_entry_t *p_entry = (m_tb_store_entry_t *)M_TB_STORE_GET_FIRST_ENTRY(p_section);
   14b02:	3408      	adds	r4, #8

            total_length = 0;

            for (entries_cnt = 0; entries_cnt < p_section->nb_entries; entries_cnt++)
   14b04:	42b3      	cmp	r3, r6
   14b06:	d006      	beq.n	14b16 <m_tb_store_load+0xae>
            {
                // Update total length
                total_length += p_entry->length;
   14b08:	7825      	ldrb	r5, [r4, #0]
            // Point to first entry
            m_tb_store_entry_t *p_entry = (m_tb_store_entry_t *)M_TB_STORE_GET_FIRST_ENTRY(p_section);

            total_length = 0;

            for (entries_cnt = 0; entries_cnt < p_section->nb_entries; entries_cnt++)
   14b0a:	3301      	adds	r3, #1
            {
                // Update total length
                total_length += p_entry->length;
   14b0c:	1940      	adds	r0, r0, r5
   14b0e:	b280      	uxth	r0, r0
                // Move on next entry
                p_entry = (m_tb_store_entry_t *)M_TB_STORE_GET_NEXT_ENTRY(p_entry);
   14b10:	1964      	adds	r4, r4, r5
            // Point to first entry
            m_tb_store_entry_t *p_entry = (m_tb_store_entry_t *)M_TB_STORE_GET_FIRST_ENTRY(p_section);

            total_length = 0;

            for (entries_cnt = 0; entries_cnt < p_section->nb_entries; entries_cnt++)
   14b12:	b2db      	uxtb	r3, r3
   14b14:	e7f6      	b.n	14b04 <m_tb_store_load+0x9c>
                total_length += p_entry->length;
                // Move on next entry
                p_entry = (m_tb_store_entry_t *)M_TB_STORE_GET_NEXT_ENTRY(p_entry);
            }

            if (total_length != (p_section->length - sizeof(m_tb_store_hdr_t)))
   14b16:	880b      	ldrh	r3, [r1, #0]
   14b18:	001c      	movs	r4, r3
   14b1a:	3c08      	subs	r4, #8
   14b1c:	42a0      	cmp	r0, r4
   14b1e:	d105      	bne.n	14b2c <m_tb_store_load+0xc4>

        // Go back on first section
        p_section = (m_tb_store_hdr_t *)p_data;

        // For each section, check that entry lengths are valid
        for (cnt = 0; cnt < nb_section; cnt++)
   14b20:	3201      	adds	r2, #1
            {
                break;
            }

            // Move on next section
            p_section = M_TB_STORE_GET_NEXT_SECTION(p_section);
   14b22:	18c9      	adds	r1, r1, r3

        // Go back on first section
        p_section = (m_tb_store_hdr_t *)p_data;

        // For each section, check that entry lengths are valid
        for (cnt = 0; cnt < nb_section; cnt++)
   14b24:	b2d2      	uxtb	r2, r2
   14b26:	e7e6      	b.n	14af6 <m_tb_store_load+0x8e>
        if (cnt < nb_section)
        {
            break;
        }

        status = M_ERR_NO_ERROR;
   14b28:	2400      	movs	r4, #0
   14b2a:	e001      	b.n	14b30 <m_tb_store_load+0xc8>
}

__STATIC uint16_t m_tb_check_stored_info(uint8_t *p_data, uint16_t length, uint8_t *p_nb_section)
{
    // Status
    uint16_t status = M_ERR_INVALID_PARAM;
   14b2c:	24c1      	movs	r4, #193	; 0xc1
   14b2e:	0064      	lsls	r4, r4, #1
        }

        status = M_ERR_NO_ERROR;
        *p_nb_section = nb_section;
    } while (0);
	M_PRINTF(L_TB, "ret=%d", status);
   14b30:	4b31      	ldr	r3, [pc, #196]	; (14bf8 <m_tb_store_load+0x190>)
   14b32:	681b      	ldr	r3, [r3, #0]
   14b34:	079b      	lsls	r3, r3, #30
   14b36:	d515      	bpl.n	14b64 <m_tb_store_load+0xfc>
   14b38:	4d30      	ldr	r5, [pc, #192]	; (14bfc <m_tb_store_load+0x194>)
   14b3a:	002b      	movs	r3, r5
   14b3c:	002a      	movs	r2, r5
   14b3e:	0028      	movs	r0, r5
   14b40:	3366      	adds	r3, #102	; 0x66
   14b42:	3220      	adds	r2, #32
   14b44:	9300      	str	r3, [sp, #0]
   14b46:	0029      	movs	r1, r5
   14b48:	4b2f      	ldr	r3, [pc, #188]	; (14c08 <m_tb_store_load+0x1a0>)
   14b4a:	3031      	adds	r0, #49	; 0x31
   14b4c:	f7ef ff2e 	bl	49ac <m_print>
   14b50:	482e      	ldr	r0, [pc, #184]	; (14c0c <m_tb_store_load+0x1a4>)
   14b52:	0021      	movs	r1, r4
   14b54:	301f      	adds	r0, #31
   14b56:	f7ef ff29 	bl	49ac <m_print>
   14b5a:	0028      	movs	r0, r5
   14b5c:	1da9      	adds	r1, r5, #6
   14b5e:	3063      	adds	r0, #99	; 0x63
   14b60:	f7ef ff24 	bl	49ac <m_print>
        }

        // Check received information
        status = m_tb_check_stored_info(p_data, length, &nb_section);

        if (status != M_ERR_NO_ERROR)
   14b64:	2c00      	cmp	r4, #0
   14b66:	d142      	bne.n	14bee <m_tb_store_load+0x186>
        {
            break;
        }

        // Allocate structure that will contain the parsing information
        p_m_tb_store_env->p_load_info = m_al_malloc(sizeof(m_tb_store_load_info_t) + length);
   14b68:	9802      	ldr	r0, [sp, #8]
   14b6a:	4e22      	ldr	r6, [pc, #136]	; (14bf4 <m_tb_store_load+0x18c>)
   14b6c:	3010      	adds	r0, #16
   14b6e:	b280      	uxth	r0, r0
   14b70:	6835      	ldr	r5, [r6, #0]
   14b72:	f7f0 fd2e 	bl	55d2 <m_al_malloc>

        if (p_m_tb_store_env->p_load_info == NULL)
   14b76:	6833      	ldr	r3, [r6, #0]
        {
            break;
        }

        // Allocate structure that will contain the parsing information
        p_m_tb_store_env->p_load_info = m_al_malloc(sizeof(m_tb_store_load_info_t) + length);
   14b78:	6068      	str	r0, [r5, #4]

        if (p_m_tb_store_env->p_load_info == NULL)
   14b7a:	685d      	ldr	r5, [r3, #4]
   14b7c:	2d00      	cmp	r5, #0
   14b7e:	d034      	beq.n	14bea <m_tb_store_load+0x182>
            break;
        }

        // Initialize the allocated structure
        p_load_info = p_m_tb_store_env->p_load_info;
        memcpy(&p_load_info->data[0], p_data, length);
   14b80:	002b      	movs	r3, r5
   14b82:	3310      	adds	r3, #16
   14b84:	9a02      	ldr	r2, [sp, #8]
   14b86:	9903      	ldr	r1, [sp, #12]
   14b88:	0018      	movs	r0, r3
   14b8a:	9304      	str	r3, [sp, #16]
   14b8c:	f000 ff20 	bl	159d0 <memcpy>
        p_load_info->cb_load = cb_load;
   14b90:	9b05      	ldr	r3, [sp, #20]
        p_load_info->p_entry = NULL;
        p_load_info->rem_section_len = p_load_info->p_section->length;
        p_load_info->rem_nb_section = nb_section;

        // Start loading procedure
        m_tb_store_load_fsm(M_ERR_NO_ERROR);
   14b92:	0020      	movs	r0, r4
        }

        // Initialize the allocated structure
        p_load_info = p_m_tb_store_env->p_load_info;
        memcpy(&p_load_info->data[0], p_data, length);
        p_load_info->cb_load = cb_load;
   14b94:	602b      	str	r3, [r5, #0]
        p_load_info->p_section = (m_tb_store_hdr_t *)&p_load_info->data[0];
   14b96:	9b04      	ldr	r3, [sp, #16]
        p_load_info->p_entry = NULL;
   14b98:	60ac      	str	r4, [r5, #8]

        // Initialize the allocated structure
        p_load_info = p_m_tb_store_env->p_load_info;
        memcpy(&p_load_info->data[0], p_data, length);
        p_load_info->cb_load = cb_load;
        p_load_info->p_section = (m_tb_store_hdr_t *)&p_load_info->data[0];
   14b9a:	606b      	str	r3, [r5, #4]
        p_load_info->p_entry = NULL;
        p_load_info->rem_section_len = p_load_info->p_section->length;
   14b9c:	8a2b      	ldrh	r3, [r5, #16]
        p_load_info->rem_nb_section = nb_section;
   14b9e:	73af      	strb	r7, [r5, #14]
        p_load_info = p_m_tb_store_env->p_load_info;
        memcpy(&p_load_info->data[0], p_data, length);
        p_load_info->cb_load = cb_load;
        p_load_info->p_section = (m_tb_store_hdr_t *)&p_load_info->data[0];
        p_load_info->p_entry = NULL;
        p_load_info->rem_section_len = p_load_info->p_section->length;
   14ba0:	81ab      	strh	r3, [r5, #12]
        p_load_info->rem_nb_section = nb_section;

        // Start loading procedure
        m_tb_store_load_fsm(M_ERR_NO_ERROR);
   14ba2:	f7ff fd89 	bl	146b8 <m_tb_store_load_fsm>
		m_al_free(p_m_tb_store_env->p_load_info);
   14ba6:	6833      	ldr	r3, [r6, #0]
   14ba8:	6858      	ldr	r0, [r3, #4]
   14baa:	f7f0 fd17 	bl	55dc <m_al_free>
        M_PRINTF(L_TB, "status=%d", status);
   14bae:	4b12      	ldr	r3, [pc, #72]	; (14bf8 <m_tb_store_load+0x190>)
   14bb0:	681b      	ldr	r3, [r3, #0]
   14bb2:	079b      	lsls	r3, r3, #30
   14bb4:	d51b      	bpl.n	14bee <m_tb_store_load+0x186>
   14bb6:	4e15      	ldr	r6, [pc, #84]	; (14c0c <m_tb_store_load+0x1a4>)
   14bb8:	4d10      	ldr	r5, [pc, #64]	; (14bfc <m_tb_store_load+0x194>)
   14bba:	0033      	movs	r3, r6
   14bbc:	002a      	movs	r2, r5
   14bbe:	0028      	movs	r0, r5
   14bc0:	3326      	adds	r3, #38	; 0x26
   14bc2:	3220      	adds	r2, #32
   14bc4:	9300      	str	r3, [sp, #0]
   14bc6:	0029      	movs	r1, r5
   14bc8:	4b11      	ldr	r3, [pc, #68]	; (14c10 <m_tb_store_load+0x1a8>)
   14bca:	3031      	adds	r0, #49	; 0x31
   14bcc:	f7ef feee 	bl	49ac <m_print>
   14bd0:	0030      	movs	r0, r6
   14bd2:	0021      	movs	r1, r4
   14bd4:	3036      	adds	r0, #54	; 0x36
   14bd6:	f7ef fee9 	bl	49ac <m_print>
   14bda:	0028      	movs	r0, r5
   14bdc:	1da9      	adds	r1, r5, #6
   14bde:	3063      	adds	r0, #99	; 0x63
   14be0:	f7ef fee4 	bl	49ac <m_print>
   14be4:	e003      	b.n	14bee <m_tb_store_load+0x186>
        uint8_t nb_section;

        // Check that no loading procedure is currently performed
        if (p_m_tb_store_env->p_load_info != NULL)
        {
            status = M_ERR_COMMAND_DISALLOWED;
   14be6:	4c0b      	ldr	r4, [pc, #44]	; (14c14 <m_tb_store_load+0x1ac>)
   14be8:	e001      	b.n	14bee <m_tb_store_load+0x186>
        p_m_tb_store_env->p_load_info = m_al_malloc(sizeof(m_tb_store_load_info_t) + length);

        if (p_m_tb_store_env->p_load_info == NULL)
        {
            // No resources found for allocation
            status = M_ERR_INSUFFICIENT_RESOURCES;
   14bea:	24b0      	movs	r4, #176	; 0xb0
   14bec:	00e4      	lsls	r4, r4, #3
		m_al_free(p_m_tb_store_env->p_load_info);
        M_PRINTF(L_TB, "status=%d", status);
    } while (0);

    return (status);
}
   14bee:	0020      	movs	r0, r4
   14bf0:	b007      	add	sp, #28
   14bf2:	bdf0      	pop	{r4, r5, r6, r7, pc}
   14bf4:	100126d0 	.word	0x100126d0
   14bf8:	10010514 	.word	0x10010514
   14bfc:	00022a71 	.word	0x00022a71
   14c00:	0000051e 	.word	0x0000051e
   14c04:	baabfafa 	.word	0xbaabfafa
   14c08:	0000056c 	.word	0x0000056c
   14c0c:	00022af1 	.word	0x00022af1
   14c10:	000005c9 	.word	0x000005c9
   14c14:	00000282 	.word	0x00000282

00014c18 <m_tb_store_update_ind>:

void m_tb_store_update_ind(uint8_t upd_type, uint32_t dummy)
{
    // Do not indicate an update if stored information are being loaded
    if ((p_m_tb_store_env->p_load_info == NULL)
   14c18:	4bdb      	ldr	r3, [pc, #876]	; (14f88 <m_tb_store_update_ind+0x370>)

    return (status);
}

void m_tb_store_update_ind(uint8_t upd_type, uint32_t dummy)
{
   14c1a:	b5f0      	push	{r4, r5, r6, r7, lr}
    // Do not indicate an update if stored information are being loaded
    if ((p_m_tb_store_env->p_load_info == NULL)
   14c1c:	681b      	ldr	r3, [r3, #0]

    return (status);
}

void m_tb_store_update_ind(uint8_t upd_type, uint32_t dummy)
{
   14c1e:	b095      	sub	sp, #84	; 0x54
    // Do not indicate an update if stored information are being loaded
    if ((p_m_tb_store_env->p_load_info == NULL)
   14c20:	685b      	ldr	r3, [r3, #4]

    return (status);
}

void m_tb_store_update_ind(uint8_t upd_type, uint32_t dummy)
{
   14c22:	0006      	movs	r6, r0
    // Do not indicate an update if stored information are being loaded
    if ((p_m_tb_store_env->p_load_info == NULL)
   14c24:	2b00      	cmp	r3, #0
   14c26:	d000      	beq.n	14c2a <m_tb_store_update_ind+0x12>
   14c28:	e1c0      	b.n	14fac <m_tb_store_update_ind+0x394>
        #if (BLE_MESH_DBG)
            && (GETB(p_m_tb_store_env->config, M_TB_STORE_CONFIG_UPD_IND_EN))
        #endif //(BLE_MESH_DBG)
            )
    {
        switch (upd_type)
   14c2a:	2807      	cmp	r0, #7
   14c2c:	d900      	bls.n	14c30 <m_tb_store_update_ind+0x18>
   14c2e:	e1bd      	b.n	14fac <m_tb_store_update_ind+0x394>
   14c30:	b2cd      	uxtb	r5, r1
   14c32:	ac0a      	add	r4, sp, #40	; 0x28
   14c34:	f009 f898 	bl	1dd68 <__gnu_thumb1_case_uhi>
   14c38:	00080008 	.word	0x00080008
   14c3c:	003c003c 	.word	0x003c003c
   14c40:	00e1007a 	.word	0x00e1007a
   14c44:	0155011e 	.word	0x0155011e
    // Network key information entry
    m_tb_store_netkey_upd_t net_key_entry;
    // Network key information
    const m_tb_key_net_t *p_key_net;

    m_tb_key_net_get(net_key_lid, &p_key_net, false);
   14c48:	2200      	movs	r2, #0
   14c4a:	a908      	add	r1, sp, #32
   14c4c:	0028      	movs	r0, r5
   14c4e:	f7fd fb61 	bl	12314 <m_tb_key_net_get>

    // Fill information
    net_key_entry.info = 0x00;
   14c52:	2200      	movs	r2, #0
    net_key_entry.netkey_id = p_key_net->net_key_id;
   14c54:	9908      	ldr	r1, [sp, #32]
    const m_tb_key_net_t *p_key_net;

    m_tb_key_net_get(net_key_lid, &p_key_net, false);

    // Fill information
    net_key_entry.info = 0x00;
   14c56:	7062      	strb	r2, [r4, #1]
    net_key_entry.netkey_id = p_key_net->net_key_id;
   14c58:	1d8b      	adds	r3, r1, #6
   14c5a:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
   14c5c:	8063      	strh	r3, [r4, #2]

    if (p_key_net->state != M_TB_KEY_STATE_NORMAL)
   14c5e:	784b      	ldrb	r3, [r1, #1]
   14c60:	4293      	cmp	r3, r2
   14c62:	d01d      	beq.n	14ca0 <m_tb_store_update_ind+0x88>
    {
        // Update key information
        const m_tb_key_net_t *p_key_net_upd;

        m_tb_key_net_get(net_key_lid | 0x80, &p_key_net_upd, false);
   14c64:	2080      	movs	r0, #128	; 0x80
   14c66:	a909      	add	r1, sp, #36	; 0x24
   14c68:	4328      	orrs	r0, r5
   14c6a:	f7fd fb53 	bl	12314 <m_tb_key_net_get>

        // Inform that network key is being updated
        SETB(net_key_entry.info, M_TB_STORE_NETKEY_INFO_UPD, 1);
   14c6e:	2204      	movs	r2, #4
   14c70:	7863      	ldrb	r3, [r4, #1]

        if (p_key_net->state == M_TB_KEY_STATE_P2)
   14c72:	9908      	ldr	r1, [sp, #32]
        const m_tb_key_net_t *p_key_net_upd;

        m_tb_key_net_get(net_key_lid | 0x80, &p_key_net_upd, false);

        // Inform that network key is being updated
        SETB(net_key_entry.info, M_TB_STORE_NETKEY_INFO_UPD, 1);
   14c74:	431a      	orrs	r2, r3
   14c76:	7062      	strb	r2, [r4, #1]

        if (p_key_net->state == M_TB_KEY_STATE_P2)
   14c78:	784a      	ldrb	r2, [r1, #1]
   14c7a:	2a02      	cmp	r2, #2
   14c7c:	d102      	bne.n	14c84 <m_tb_store_update_ind+0x6c>
        {
            SETB(net_key_entry.info, M_TB_STORE_NETKEY_INFO_P2, 1);
   14c7e:	320a      	adds	r2, #10
   14c80:	4313      	orrs	r3, r2
   14c82:	7063      	strb	r3, [r4, #1]
        }

        // Provide the two network keys
        memcpy(&net_key_entry.key[0], &p_key_net->key[0], M_KEY_LEN);
   14c84:	3102      	adds	r1, #2
   14c86:	2210      	movs	r2, #16
   14c88:	a80b      	add	r0, sp, #44	; 0x2c
   14c8a:	f000 fea1 	bl	159d0 <memcpy>
        memcpy(&net_key_entry.new_key[0], &p_key_net_upd->key[0], M_KEY_LEN);
   14c8e:	9b09      	ldr	r3, [sp, #36]	; 0x24
   14c90:	2210      	movs	r2, #16
   14c92:	1c99      	adds	r1, r3, #2
   14c94:	a80f      	add	r0, sp, #60	; 0x3c
   14c96:	f000 fe9b 	bl	159d0 <memcpy>

        net_key_entry.length = CO_ALIGN4_HI(sizeof(m_tb_store_netkey_upd_t));
   14c9a:	2324      	movs	r3, #36	; 0x24
   14c9c:	7023      	strb	r3, [r4, #0]
   14c9e:	e03f      	b.n	14d20 <m_tb_store_update_ind+0x108>
    }
    else
    {
        // Copy the network key
        memcpy(&net_key_entry.key[0], &p_key_net->key[0], M_KEY_LEN);
   14ca0:	3102      	adds	r1, #2
   14ca2:	2210      	movs	r2, #16
   14ca4:	a80b      	add	r0, sp, #44	; 0x2c
   14ca6:	f000 fe93 	bl	159d0 <memcpy>
        net_key_entry.length = CO_ALIGN4_HI(sizeof(m_tb_store_netkey_t));
   14caa:	2314      	movs	r3, #20
   14cac:	7023      	strb	r3, [r4, #0]
   14cae:	e037      	b.n	14d20 <m_tb_store_update_ind+0x108>
    // Application key information
    const m_tb_key_app_t *p_key_app;
    // Network key information
    const m_tb_key_net_t *p_key_net;

    m_tb_key_app_get(app_key_lid, &p_key_app, false);
   14cb0:	2200      	movs	r2, #0
   14cb2:	a907      	add	r1, sp, #28
   14cb4:	0028      	movs	r0, r5
   14cb6:	f7fd fd6d 	bl	12794 <m_tb_key_app_get>
    m_tb_key_net_get(p_key_app->net_key_lid, &p_key_net, false);
   14cba:	9b07      	ldr	r3, [sp, #28]
   14cbc:	2200      	movs	r2, #0
   14cbe:	7d98      	ldrb	r0, [r3, #22]
   14cc0:	a908      	add	r1, sp, #32
   14cc2:	f7fd fb27 	bl	12314 <m_tb_key_net_get>
    // Fill information
    app_key_entry.netkey_id = p_key_net->net_key_id;
    app_key_entry.appkey_id = p_key_app->app_key_id;
    app_key_entry.info = 0;

    memcpy(&app_key_entry.key[0], &p_key_app->key[0], M_KEY_LEN);
   14cc6:	2026      	movs	r0, #38	; 0x26
    m_tb_key_net_get(p_key_app->net_key_lid, &p_key_net, false);

    // Fill information
    app_key_entry.netkey_id = p_key_net->net_key_id;
    app_key_entry.appkey_id = p_key_app->app_key_id;
    app_key_entry.info = 0;
   14cc8:	2700      	movs	r7, #0

    m_tb_key_app_get(app_key_lid, &p_key_app, false);
    m_tb_key_net_get(p_key_app->net_key_lid, &p_key_net, false);

    // Fill information
    app_key_entry.netkey_id = p_key_net->net_key_id;
   14cca:	9b08      	ldr	r3, [sp, #32]
    app_key_entry.appkey_id = p_key_app->app_key_id;
   14ccc:	9907      	ldr	r1, [sp, #28]

    m_tb_key_app_get(app_key_lid, &p_key_app, false);
    m_tb_key_net_get(p_key_app->net_key_lid, &p_key_net, false);

    // Fill information
    app_key_entry.netkey_id = p_key_net->net_key_id;
   14cce:	9304      	str	r3, [sp, #16]
   14cd0:	3306      	adds	r3, #6
   14cd2:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
    app_key_entry.appkey_id = p_key_app->app_key_id;
    app_key_entry.info = 0;

    memcpy(&app_key_entry.key[0], &p_key_app->key[0], M_KEY_LEN);
   14cd4:	3102      	adds	r1, #2

    m_tb_key_app_get(app_key_lid, &p_key_app, false);
    m_tb_key_net_get(p_key_app->net_key_lid, &p_key_net, false);

    // Fill information
    app_key_entry.netkey_id = p_key_net->net_key_id;
   14cd6:	8063      	strh	r3, [r4, #2]
    app_key_entry.appkey_id = p_key_app->app_key_id;
   14cd8:	8a4b      	ldrh	r3, [r1, #18]
    app_key_entry.info = 0;

    memcpy(&app_key_entry.key[0], &p_key_app->key[0], M_KEY_LEN);
   14cda:	2210      	movs	r2, #16
    m_tb_key_app_get(app_key_lid, &p_key_app, false);
    m_tb_key_net_get(p_key_app->net_key_lid, &p_key_net, false);

    // Fill information
    app_key_entry.netkey_id = p_key_net->net_key_id;
    app_key_entry.appkey_id = p_key_app->app_key_id;
   14cdc:	80a3      	strh	r3, [r4, #4]
    app_key_entry.info = 0;

    memcpy(&app_key_entry.key[0], &p_key_app->key[0], M_KEY_LEN);
   14cde:	ab02      	add	r3, sp, #8
   14ce0:	18c0      	adds	r0, r0, r3
    m_tb_key_net_get(p_key_app->net_key_lid, &p_key_net, false);

    // Fill information
    app_key_entry.netkey_id = p_key_net->net_key_id;
    app_key_entry.appkey_id = p_key_app->app_key_id;
    app_key_entry.info = 0;
   14ce2:	7067      	strb	r7, [r4, #1]

    memcpy(&app_key_entry.key[0], &p_key_app->key[0], M_KEY_LEN);
   14ce4:	f000 fe74 	bl	159d0 <memcpy>
    app_key_entry.length = CO_ALIGN4_HI(sizeof(m_tb_store_appkey_t));
   14ce8:	2318      	movs	r3, #24
   14cea:	7023      	strb	r3, [r4, #0]

    if (p_key_net->state != M_TB_KEY_STATE_NORMAL)
   14cec:	9b04      	ldr	r3, [sp, #16]
   14cee:	785b      	ldrb	r3, [r3, #1]
   14cf0:	42bb      	cmp	r3, r7
   14cf2:	d015      	beq.n	14d20 <m_tb_store_update_ind+0x108>
    {
        // Update key information
        const m_tb_key_app_t *p_key_app_upd;

        if (m_tb_key_app_get(app_key_lid | 0x80, &p_key_app_upd, false) == M_ERR_NO_ERROR)
   14cf4:	2080      	movs	r0, #128	; 0x80
   14cf6:	003a      	movs	r2, r7
   14cf8:	4328      	orrs	r0, r5
   14cfa:	a909      	add	r1, sp, #36	; 0x24
   14cfc:	f7fd fd4a 	bl	12794 <m_tb_key_app_get>
   14d00:	42b8      	cmp	r0, r7
   14d02:	d10d      	bne.n	14d20 <m_tb_store_update_ind+0x108>
        {
            // Inform that network key is being updated
            SETB(app_key_entry.info, M_TB_STORE_APPKEY_INFO_UPD, 1);
   14d04:	2201      	movs	r2, #1

            // Provide the two application keys
            memcpy(&app_key_entry.new_key[0], &p_key_app_upd->key[0], M_KEY_LEN);
   14d06:	2036      	movs	r0, #54	; 0x36
        const m_tb_key_app_t *p_key_app_upd;

        if (m_tb_key_app_get(app_key_lid | 0x80, &p_key_app_upd, false) == M_ERR_NO_ERROR)
        {
            // Inform that network key is being updated
            SETB(app_key_entry.info, M_TB_STORE_APPKEY_INFO_UPD, 1);
   14d08:	7863      	ldrb	r3, [r4, #1]
   14d0a:	4313      	orrs	r3, r2
   14d0c:	7063      	strb	r3, [r4, #1]

            // Provide the two application keys
            memcpy(&app_key_entry.new_key[0], &p_key_app_upd->key[0], M_KEY_LEN);
   14d0e:	9b09      	ldr	r3, [sp, #36]	; 0x24
   14d10:	320f      	adds	r2, #15
   14d12:	1c99      	adds	r1, r3, #2
   14d14:	ab02      	add	r3, sp, #8
   14d16:	18c0      	adds	r0, r0, r3
   14d18:	f000 fe5a 	bl	159d0 <memcpy>

            app_key_entry.length = CO_ALIGN4_HI(sizeof(m_tb_store_appkey_upd_t));
   14d1c:	2328      	movs	r3, #40	; 0x28
   14d1e:	7023      	strb	r3, [r4, #0]
        }
    }

    bc_m_send_update_ind(upd_type, app_key_entry.length, (uint8_t *)&app_key_entry);
   14d20:	7821      	ldrb	r1, [r4, #0]
   14d22:	0022      	movs	r2, r4
   14d24:	0030      	movs	r0, r6
   14d26:	f7f4 fa15 	bl	9154 <bc_m_send_update_ind>
   14d2a:	e13f      	b.n	14fac <m_tb_store_update_ind+0x394>
    m_lid_t va_lid;
    // Indicate if model ID is a SIG or a vendor model ID
    bool is_vendor;

    // Get element address
    m_tb_mio_get_element_addr(model_lid, &publi_entry.element_addr);
   14d2c:	2122      	movs	r1, #34	; 0x22
   14d2e:	ab02      	add	r3, sp, #8
   14d30:	18c9      	adds	r1, r1, r3
    // Get model ID
    publi_entry.model_id = m_tb_mio_get_model_id(model_lid, &is_vendor);
   14d32:	ae08      	add	r6, sp, #32
    m_lid_t va_lid;
    // Indicate if model ID is a SIG or a vendor model ID
    bool is_vendor;

    // Get element address
    m_tb_mio_get_element_addr(model_lid, &publi_entry.element_addr);
   14d34:	0028      	movs	r0, r5
   14d36:	f7fe fae5 	bl	13304 <m_tb_mio_get_element_addr>
    // Get model ID
    publi_entry.model_id = m_tb_mio_get_model_id(model_lid, &is_vendor);
   14d3a:	0031      	movs	r1, r6
   14d3c:	0028      	movs	r0, r5
   14d3e:	f7fe fad3 	bl	132e8 <m_tb_mio_get_model_id>
    // Set entry information
    publi_entry.info = 0;
    SETB(publi_entry.info, M_TB_STORE_PUBLI_INFO_VENDOR, is_vendor);
   14d42:	7833      	ldrb	r3, [r6, #0]
    // Get publication parameters
    m_tb_mio_get_publi_param(model_lid, &publi_entry.addr, &va_lid, &app_key_lid, &publi_entry.ttl,
   14d44:	2613      	movs	r6, #19
    m_tb_mio_get_element_addr(model_lid, &publi_entry.element_addr);
    // Get model ID
    publi_entry.model_id = m_tb_mio_get_model_id(model_lid, &is_vendor);
    // Set entry information
    publi_entry.info = 0;
    SETB(publi_entry.info, M_TB_STORE_PUBLI_INFO_VENDOR, is_vendor);
   14d46:	7063      	strb	r3, [r4, #1]
    // Get publication parameters
    m_tb_mio_get_publi_param(model_lid, &publi_entry.addr, &va_lid, &app_key_lid, &publi_entry.ttl,
   14d48:	ab02      	add	r3, sp, #8
   14d4a:	18f6      	adds	r6, r6, r3
   14d4c:	232f      	movs	r3, #47	; 0x2f
   14d4e:	aa02      	add	r2, sp, #8
   14d50:	189b      	adds	r3, r3, r2
    bool is_vendor;

    // Get element address
    m_tb_mio_get_element_addr(model_lid, &publi_entry.element_addr);
    // Get model ID
    publi_entry.model_id = m_tb_mio_get_model_id(model_lid, &is_vendor);
   14d52:	6060      	str	r0, [r4, #4]
    // Set entry information
    publi_entry.info = 0;
    SETB(publi_entry.info, M_TB_STORE_PUBLI_INFO_VENDOR, is_vendor);
    // Get publication parameters
    m_tb_mio_get_publi_param(model_lid, &publi_entry.addr, &va_lid, &app_key_lid, &publi_entry.ttl,
   14d54:	9303      	str	r3, [sp, #12]
   14d56:	232e      	movs	r3, #46	; 0x2e
   14d58:	189b      	adds	r3, r3, r2
   14d5a:	9302      	str	r3, [sp, #8]
   14d5c:	232d      	movs	r3, #45	; 0x2d
   14d5e:	189b      	adds	r3, r3, r2
   14d60:	9301      	str	r3, [sp, #4]
   14d62:	ab0d      	add	r3, sp, #52	; 0x34
   14d64:	9300      	str	r3, [sp, #0]
   14d66:	aa07      	add	r2, sp, #28
   14d68:	0033      	movs	r3, r6
   14d6a:	a90c      	add	r1, sp, #48	; 0x30
   14d6c:	0028      	movs	r0, r5
   14d6e:	f7fe fb73 	bl	13458 <m_tb_mio_get_publi_param>
                             &publi_entry.period, &publi_entry.retx_params, &publi_entry.friend_cred);
	M_PRINTF(L_TB, "app_key_lid[%x]", app_key_lid);
   14d72:	4b86      	ldr	r3, [pc, #536]	; (14f8c <m_tb_store_update_ind+0x374>)
   14d74:	681b      	ldr	r3, [r3, #0]
   14d76:	079b      	lsls	r3, r3, #30
   14d78:	d517      	bpl.n	14daa <m_tb_store_update_ind+0x192>
   14d7a:	4f85      	ldr	r7, [pc, #532]	; (14f90 <m_tb_store_update_ind+0x378>)
   14d7c:	4d85      	ldr	r5, [pc, #532]	; (14f94 <m_tb_store_update_ind+0x37c>)
   14d7e:	003b      	movs	r3, r7
   14d80:	3340      	adds	r3, #64	; 0x40
   14d82:	9300      	str	r3, [sp, #0]
   14d84:	002a      	movs	r2, r5
   14d86:	0028      	movs	r0, r5
   14d88:	23a8      	movs	r3, #168	; 0xa8
   14d8a:	3220      	adds	r2, #32
   14d8c:	009b      	lsls	r3, r3, #2
   14d8e:	0029      	movs	r1, r5
   14d90:	3031      	adds	r0, #49	; 0x31
   14d92:	f7ef fe0b 	bl	49ac <m_print>
   14d96:	0038      	movs	r0, r7
   14d98:	7831      	ldrb	r1, [r6, #0]
   14d9a:	3062      	adds	r0, #98	; 0x62
   14d9c:	f7ef fe06 	bl	49ac <m_print>
   14da0:	0028      	movs	r0, r5
   14da2:	1da9      	adds	r1, r5, #6
   14da4:	3063      	adds	r0, #99	; 0x63
   14da6:	f7ef fe01 	bl	49ac <m_print>
    if (app_key_lid != M_INVALID_LID)
   14daa:	2313      	movs	r3, #19
   14dac:	aa02      	add	r2, sp, #8
   14dae:	189b      	adds	r3, r3, r2
   14db0:	7818      	ldrb	r0, [r3, #0]
   14db2:	28ff      	cmp	r0, #255	; 0xff
   14db4:	d007      	beq.n	14dc6 <m_tb_store_update_ind+0x1ae>
    {
        // Get application key information in order to retrieve AppKey ID value
        m_tb_key_app_get(app_key_lid, &p_key_app, false);
   14db6:	2200      	movs	r2, #0
   14db8:	a909      	add	r1, sp, #36	; 0x24
   14dba:	f7fd fceb 	bl	12794 <m_tb_key_app_get>
        publi_entry.appkey_id = p_key_app->app_key_id;
   14dbe:	9b09      	ldr	r3, [sp, #36]	; 0x24
   14dc0:	8a9b      	ldrh	r3, [r3, #20]
   14dc2:	8163      	strh	r3, [r4, #10]
   14dc4:	e001      	b.n	14dca <m_tb_store_update_ind+0x1b2>
    }
    else
    {
        publi_entry.appkey_id = 0;
   14dc6:	2300      	movs	r3, #0
   14dc8:	8163      	strh	r3, [r4, #10]
    }

    // Check if publication address is a virtual address
    if (M_IS_VIRTUAL_ADDR(publi_entry.addr))
   14dca:	8923      	ldrh	r3, [r4, #8]
   14dcc:	0b9b      	lsrs	r3, r3, #14
   14dce:	2b02      	cmp	r3, #2
   14dd0:	d10b      	bne.n	14dea <m_tb_store_update_ind+0x1d2>
    {
        // Get Label UUID
        memcpy(&publi_entry.label_uuid[0], m_tb_mio_get_vaddr(va_lid), M_LABEL_UUID_LEN);
   14dd2:	ab02      	add	r3, sp, #8
   14dd4:	7d18      	ldrb	r0, [r3, #20]
   14dd6:	f7fe fe51 	bl	13a7c <m_tb_mio_get_vaddr>
   14dda:	2210      	movs	r2, #16
   14ddc:	0001      	movs	r1, r0
   14dde:	a80e      	add	r0, sp, #56	; 0x38
   14de0:	f000 fdf6 	bl	159d0 <memcpy>
        publi_entry.length = CO_ALIGN4_HI(sizeof(m_tb_store_publi_virt_t));
   14de4:	2320      	movs	r3, #32
   14de6:	7023      	strb	r3, [r4, #0]
   14de8:	e001      	b.n	14dee <m_tb_store_update_ind+0x1d6>
    }
    else
    {
        publi_entry.length = CO_ALIGN4_HI(sizeof(m_tb_store_publi_t));
   14dea:	2310      	movs	r3, #16
   14dec:	7023      	strb	r3, [r4, #0]
    }

    bc_m_send_update_ind(M_TB_STORE_UPD_TYPE_PUBLI_PARAM, publi_entry.length, (uint8_t *)&publi_entry);
   14dee:	7821      	ldrb	r1, [r4, #0]
   14df0:	0022      	movs	r2, r4
   14df2:	2004      	movs	r0, #4
   14df4:	f7f4 f9ae 	bl	9154 <bc_m_send_update_ind>
   14df8:	e0d8      	b.n	14fac <m_tb_store_update_ind+0x394>
}

__STATIC void m_tb_store_update_subs_list_ind(m_lid_t model_lid)
{
    // Get number of addresses (virtual and non-virtual) in the subscription list
    uint8_t nb_addrs = m_tb_mio_get_subscription_list_size(model_lid);
   14dfa:	0028      	movs	r0, r5
   14dfc:	f7fe fcc0 	bl	13780 <m_tb_mio_get_subscription_list_size>
   14e00:	0007      	movs	r7, r0
    // Length of entry
    uint8_t dyn_len = CO_ALIGN4_HI(sizeof(m_tb_store_subs_t) + (M_ADDR_LEN * nb_addrs) +
   14e02:	0028      	movs	r0, r5
   14e04:	f7fe fcc8 	bl	13798 <m_tb_mio_get_subscription_list_size_vaddr>
   14e08:	b2fb      	uxtb	r3, r7
   14e0a:	00c0      	lsls	r0, r0, #3
   14e0c:	1818      	adds	r0, r3, r0
   14e0e:	23fc      	movs	r3, #252	; 0xfc
   14e10:	0040      	lsls	r0, r0, #1
   14e12:	300b      	adds	r0, #11
   14e14:	4018      	ands	r0, r3
                                   (M_LABEL_UUID_LEN * m_tb_mio_get_subscription_list_size_vaddr(model_lid)));
    // Subscription list information entry
    m_tb_store_subs_t *p_subs_entry = m_al_malloc(dyn_len);
   14e16:	466b      	mov	r3, sp
__STATIC void m_tb_store_update_subs_list_ind(m_lid_t model_lid)
{
    // Get number of addresses (virtual and non-virtual) in the subscription list
    uint8_t nb_addrs = m_tb_mio_get_subscription_list_size(model_lid);
    // Length of entry
    uint8_t dyn_len = CO_ALIGN4_HI(sizeof(m_tb_store_subs_t) + (M_ADDR_LEN * nb_addrs) +
   14e18:	9004      	str	r0, [sp, #16]
                                   (M_LABEL_UUID_LEN * m_tb_mio_get_subscription_list_size_vaddr(model_lid)));
    // Subscription list information entry
    m_tb_store_subs_t *p_subs_entry = m_al_malloc(dyn_len);
   14e1a:	8a1b      	ldrh	r3, [r3, #16]
   14e1c:	0018      	movs	r0, r3
   14e1e:	9305      	str	r3, [sp, #20]
   14e20:	f7f0 fbd7 	bl	55d2 <m_al_malloc>
    // Indicate if model ID is a SIG or a vendor model ID
    bool is_vendor;

    // Get element address
    m_tb_mio_get_element_addr(model_lid, &p_subs_entry->element_addr);
   14e24:	1c81      	adds	r1, r0, #2
    uint8_t nb_addrs = m_tb_mio_get_subscription_list_size(model_lid);
    // Length of entry
    uint8_t dyn_len = CO_ALIGN4_HI(sizeof(m_tb_store_subs_t) + (M_ADDR_LEN * nb_addrs) +
                                   (M_LABEL_UUID_LEN * m_tb_mio_get_subscription_list_size_vaddr(model_lid)));
    // Subscription list information entry
    m_tb_store_subs_t *p_subs_entry = m_al_malloc(dyn_len);
   14e26:	0006      	movs	r6, r0
    // Indicate if model ID is a SIG or a vendor model ID
    bool is_vendor;

    // Get element address
    m_tb_mio_get_element_addr(model_lid, &p_subs_entry->element_addr);
   14e28:	0028      	movs	r0, r5
   14e2a:	f7fe fa6b 	bl	13304 <m_tb_mio_get_element_addr>
    // Get model ID
    p_subs_entry->model_id = m_tb_mio_get_model_id(model_lid, &is_vendor);
   14e2e:	0021      	movs	r1, r4
   14e30:	0028      	movs	r0, r5
   14e32:	f7fe fa59 	bl	132e8 <m_tb_mio_get_model_id>
    // Set entry information
    p_subs_entry->info = 0;
    SETF(p_subs_entry->info, M_TB_STORE_SUBS_INFO_NB_ADDR, nb_addrs);
   14e36:	237f      	movs	r3, #127	; 0x7f
   14e38:	b2fa      	uxtb	r2, r7
   14e3a:	439a      	bics	r2, r3
   14e3c:	0013      	movs	r3, r2
    bool is_vendor;

    // Get element address
    m_tb_mio_get_element_addr(model_lid, &p_subs_entry->element_addr);
    // Get model ID
    p_subs_entry->model_id = m_tb_mio_get_model_id(model_lid, &is_vendor);
   14e3e:	6070      	str	r0, [r6, #4]
    // Set entry information
    p_subs_entry->info = 0;
    SETF(p_subs_entry->info, M_TB_STORE_SUBS_INFO_NB_ADDR, nb_addrs);
   14e40:	2b00      	cmp	r3, #0
   14e42:	d1fd      	bne.n	14e40 <m_tb_store_update_ind+0x228>
    SETB(p_subs_entry->info, M_TB_STORE_SUBS_INFO_VENDOR, is_vendor);
    // Retrieve subscription list content
    m_tb_mio_get_subscription_list(model_lid, &p_subs_entry->list[0], true);
   14e44:	0031      	movs	r1, r6
    // Get model ID
    p_subs_entry->model_id = m_tb_mio_get_model_id(model_lid, &is_vendor);
    // Set entry information
    p_subs_entry->info = 0;
    SETF(p_subs_entry->info, M_TB_STORE_SUBS_INFO_NB_ADDR, nb_addrs);
    SETB(p_subs_entry->info, M_TB_STORE_SUBS_INFO_VENDOR, is_vendor);
   14e46:	7822      	ldrb	r2, [r4, #0]
   14e48:	337f      	adds	r3, #127	; 0x7f
   14e4a:	401f      	ands	r7, r3
   14e4c:	01d2      	lsls	r2, r2, #7
   14e4e:	4317      	orrs	r7, r2
    // Retrieve subscription list content
    m_tb_mio_get_subscription_list(model_lid, &p_subs_entry->list[0], true);
   14e50:	0028      	movs	r0, r5
    // Get model ID
    p_subs_entry->model_id = m_tb_mio_get_model_id(model_lid, &is_vendor);
    // Set entry information
    p_subs_entry->info = 0;
    SETF(p_subs_entry->info, M_TB_STORE_SUBS_INFO_NB_ADDR, nb_addrs);
    SETB(p_subs_entry->info, M_TB_STORE_SUBS_INFO_VENDOR, is_vendor);
   14e52:	7077      	strb	r7, [r6, #1]
    // Retrieve subscription list content
    m_tb_mio_get_subscription_list(model_lid, &p_subs_entry->list[0], true);
   14e54:	3108      	adds	r1, #8
   14e56:	2201      	movs	r2, #1
   14e58:	f7fe fca8 	bl	137ac <m_tb_mio_get_subscription_list>
    // Set length
    p_subs_entry->length = dyn_len;
   14e5c:	466b      	mov	r3, sp
   14e5e:	7c1b      	ldrb	r3, [r3, #16]

    // Inform the application
    bc_m_send_update_ind(M_TB_STORE_UPD_TYPE_SUBS_LIST, dyn_len, (uint8_t *)p_subs_entry);
   14e60:	0032      	movs	r2, r6
    SETF(p_subs_entry->info, M_TB_STORE_SUBS_INFO_NB_ADDR, nb_addrs);
    SETB(p_subs_entry->info, M_TB_STORE_SUBS_INFO_VENDOR, is_vendor);
    // Retrieve subscription list content
    m_tb_mio_get_subscription_list(model_lid, &p_subs_entry->list[0], true);
    // Set length
    p_subs_entry->length = dyn_len;
   14e62:	7033      	strb	r3, [r6, #0]

    // Inform the application
    bc_m_send_update_ind(M_TB_STORE_UPD_TYPE_SUBS_LIST, dyn_len, (uint8_t *)p_subs_entry);
   14e64:	9905      	ldr	r1, [sp, #20]
   14e66:	2005      	movs	r0, #5
   14e68:	f7f4 f974 	bl	9154 <bc_m_send_update_ind>

    // Free the allocated structure
    m_al_free(p_subs_entry);
   14e6c:	0030      	movs	r0, r6
   14e6e:	f7f0 fbb5 	bl	55dc <m_al_free>
   14e72:	e09b      	b.n	14fac <m_tb_store_update_ind+0x394>
}

__STATIC void m_tb_store_update_binding_ind(m_lid_t model_lid)
{
    // Get number of application keys bound with the model
    uint8_t nb_app_keys = m_tb_mio_get_nb_bound_app(model_lid);
   14e74:	0028      	movs	r0, r5
   14e76:	f7fe fd8f 	bl	13998 <m_tb_mio_get_nb_bound_app>
    // Length of entry
    uint8_t dyn_len = CO_ALIGN4_HI(sizeof(m_tb_store_binding_t) + (M_KEY_ID_LEN * nb_app_keys));
   14e7a:	22fc      	movs	r2, #252	; 0xfc
   14e7c:	0043      	lsls	r3, r0, #1
   14e7e:	330b      	adds	r3, #11
   14e80:	4013      	ands	r3, r2
   14e82:	9304      	str	r3, [sp, #16]
    // Subscription list information entry
    m_tb_store_binding_t *p_binding_entry = m_al_malloc(dyn_len);
   14e84:	466b      	mov	r3, sp
   14e86:	8a1b      	ldrh	r3, [r3, #16]
}

__STATIC void m_tb_store_update_binding_ind(m_lid_t model_lid)
{
    // Get number of application keys bound with the model
    uint8_t nb_app_keys = m_tb_mio_get_nb_bound_app(model_lid);
   14e88:	0007      	movs	r7, r0
    // Length of entry
    uint8_t dyn_len = CO_ALIGN4_HI(sizeof(m_tb_store_binding_t) + (M_KEY_ID_LEN * nb_app_keys));
    // Subscription list information entry
    m_tb_store_binding_t *p_binding_entry = m_al_malloc(dyn_len);
   14e8a:	0018      	movs	r0, r3
   14e8c:	9305      	str	r3, [sp, #20]
   14e8e:	f7f0 fba0 	bl	55d2 <m_al_malloc>
    // Indicate if model ID is a SIG or a vendor model ID
    bool is_vendor;

    // Get element address
    m_tb_mio_get_element_addr(model_lid, &p_binding_entry->element_addr);
   14e92:	1c81      	adds	r1, r0, #2
    // Get number of application keys bound with the model
    uint8_t nb_app_keys = m_tb_mio_get_nb_bound_app(model_lid);
    // Length of entry
    uint8_t dyn_len = CO_ALIGN4_HI(sizeof(m_tb_store_binding_t) + (M_KEY_ID_LEN * nb_app_keys));
    // Subscription list information entry
    m_tb_store_binding_t *p_binding_entry = m_al_malloc(dyn_len);
   14e94:	0006      	movs	r6, r0
    // Indicate if model ID is a SIG or a vendor model ID
    bool is_vendor;

    // Get element address
    m_tb_mio_get_element_addr(model_lid, &p_binding_entry->element_addr);
   14e96:	0028      	movs	r0, r5
   14e98:	f7fe fa34 	bl	13304 <m_tb_mio_get_element_addr>
    // Get model ID
    p_binding_entry->model_id = m_tb_mio_get_model_id(model_lid, &is_vendor);
   14e9c:	0021      	movs	r1, r4
   14e9e:	0028      	movs	r0, r5
   14ea0:	f7fe fa22 	bl	132e8 <m_tb_mio_get_model_id>
    // Set entry information
    p_binding_entry->info = 0;
    SETF(p_binding_entry->info, M_TB_STORE_BINDING_INFO_NB_APP_IDS, nb_app_keys);
   14ea4:	237f      	movs	r3, #127	; 0x7f
   14ea6:	003a      	movs	r2, r7
   14ea8:	439a      	bics	r2, r3
   14eaa:	0013      	movs	r3, r2
    bool is_vendor;

    // Get element address
    m_tb_mio_get_element_addr(model_lid, &p_binding_entry->element_addr);
    // Get model ID
    p_binding_entry->model_id = m_tb_mio_get_model_id(model_lid, &is_vendor);
   14eac:	6070      	str	r0, [r6, #4]
    // Set entry information
    p_binding_entry->info = 0;
    SETF(p_binding_entry->info, M_TB_STORE_BINDING_INFO_NB_APP_IDS, nb_app_keys);
   14eae:	2b00      	cmp	r3, #0
   14eb0:	d1fd      	bne.n	14eae <m_tb_store_update_ind+0x296>
    SETB(p_binding_entry->info, M_TB_STORE_BINDING_INFO_VENDOR, is_vendor);
   14eb2:	7822      	ldrb	r2, [r4, #0]
    // Get AppKey IDs
    m_tb_key_get_model_appkey_ids(model_lid, nb_app_keys, (uint8_t *)&p_binding_entry->appkey_ids[0], false);
   14eb4:	0028      	movs	r0, r5
    // Get model ID
    p_binding_entry->model_id = m_tb_mio_get_model_id(model_lid, &is_vendor);
    // Set entry information
    p_binding_entry->info = 0;
    SETF(p_binding_entry->info, M_TB_STORE_BINDING_INFO_NB_APP_IDS, nb_app_keys);
    SETB(p_binding_entry->info, M_TB_STORE_BINDING_INFO_VENDOR, is_vendor);
   14eb6:	01d1      	lsls	r1, r2, #7
   14eb8:	227f      	movs	r2, #127	; 0x7f
   14eba:	403a      	ands	r2, r7
   14ebc:	430a      	orrs	r2, r1
   14ebe:	7072      	strb	r2, [r6, #1]
    // Get AppKey IDs
    m_tb_key_get_model_appkey_ids(model_lid, nb_app_keys, (uint8_t *)&p_binding_entry->appkey_ids[0], false);
   14ec0:	0032      	movs	r2, r6
   14ec2:	0039      	movs	r1, r7
   14ec4:	3208      	adds	r2, #8
   14ec6:	f7fd fef3 	bl	12cb0 <m_tb_key_get_model_appkey_ids>
    // Set length
    p_binding_entry->length = dyn_len;
   14eca:	466b      	mov	r3, sp
   14ecc:	7c1b      	ldrb	r3, [r3, #16]

    // Inform the application
    bc_m_send_update_ind(M_TB_STORE_UPD_TYPE_BINDING, dyn_len, (uint8_t *)p_binding_entry);
   14ece:	0032      	movs	r2, r6
    SETF(p_binding_entry->info, M_TB_STORE_BINDING_INFO_NB_APP_IDS, nb_app_keys);
    SETB(p_binding_entry->info, M_TB_STORE_BINDING_INFO_VENDOR, is_vendor);
    // Get AppKey IDs
    m_tb_key_get_model_appkey_ids(model_lid, nb_app_keys, (uint8_t *)&p_binding_entry->appkey_ids[0], false);
    // Set length
    p_binding_entry->length = dyn_len;
   14ed0:	7033      	strb	r3, [r6, #0]

    // Inform the application
    bc_m_send_update_ind(M_TB_STORE_UPD_TYPE_BINDING, dyn_len, (uint8_t *)p_binding_entry);
   14ed2:	9905      	ldr	r1, [sp, #20]
   14ed4:	2006      	movs	r0, #6
   14ed6:	f7f4 f93d 	bl	9154 <bc_m_send_update_ind>

    // Free the allocated structure
    m_al_free(p_binding_entry);
   14eda:	0030      	movs	r0, r6
   14edc:	f7f0 fb7e 	bl	55dc <m_al_free>
   14ee0:	e064      	b.n	14fac <m_tb_store_update_ind+0x394>
    // State information entry
    m_tb_store_state_t state_entry;

    // Fill information
    state_entry.type = state_type;
    state_entry.length = 2;
   14ee2:	2302      	movs	r3, #2
{
    // State information entry
    m_tb_store_state_t state_entry;

    // Fill information
    state_entry.type = state_type;
   14ee4:	7065      	strb	r5, [r4, #1]
    state_entry.length = 2;
   14ee6:	7023      	strb	r3, [r4, #0]

    switch (state_type)
   14ee8:	2d08      	cmp	r5, #8
   14eea:	d84b      	bhi.n	14f84 <m_tb_store_update_ind+0x36c>
   14eec:	0028      	movs	r0, r5
   14eee:	f008 ff31 	bl	1dd54 <__gnu_thumb1_case_uqi>
   14ef2:	0e05      	.short	0x0e05
   14ef4:	49231c15 	.word	0x49231c15
   14ef8:	2d49      	.short	0x2d49
   14efa:	3c          	.byte	0x3c
   14efb:	00          	.byte	0x00
    {
        case (M_TB_STORE_TYPE_UNICAST_ADDR):
        {
            co_write16p(&state_entry.val[0], m_tb_mio_get_prim_addr());
   14efc:	f7fe fd9c 	bl	13a38 <m_tb_mio_get_prim_addr>
            state_entry.length += M_ADDR_LEN;
   14f00:	7823      	ldrb	r3, [r4, #0]
 */
__INLINE_S__ void co_write16p(void const *ptr16, uint16_t value)
{
    uint8_t *ptr=(uint8_t*)ptr16;

    *ptr++ = value&0xff;
   14f02:	70a0      	strb	r0, [r4, #2]
   14f04:	3302      	adds	r3, #2
    *ptr = (value&0xff00)>>8;
   14f06:	0a00      	lsrs	r0, r0, #8
   14f08:	70e0      	strb	r0, [r4, #3]
   14f0a:	7023      	strb	r3, [r4, #0]
   14f0c:	e044      	b.n	14f98 <m_tb_store_update_ind+0x380>
        } break;

        case (M_TB_STORE_TYPE_DEFAULT_TTL_STATE):
        {
            state_entry.val[0] = m_tb_state_get_default_ttl();
   14f0e:	f7ff fa63 	bl	143d8 <m_tb_state_get_default_ttl>
            state_entry.length += 1;
   14f12:	7823      	ldrb	r3, [r4, #0]
            state_entry.length += M_ADDR_LEN;
        } break;

        case (M_TB_STORE_TYPE_DEFAULT_TTL_STATE):
        {
            state_entry.val[0] = m_tb_state_get_default_ttl();
   14f14:	70a0      	strb	r0, [r4, #2]
            state_entry.length += 1;
   14f16:	3301      	adds	r3, #1
   14f18:	7023      	strb	r3, [r4, #0]
   14f1a:	e03d      	b.n	14f98 <m_tb_store_update_ind+0x380>
        } break;

        case (M_TB_STORE_TYPE_SEC_BCN_STATE):
        {
            state_entry.val[0] = m_tb_state_get_beacon_state();
   14f1c:	f7ff fa64 	bl	143e8 <m_tb_state_get_beacon_state>
            state_entry.length += 1;
   14f20:	7823      	ldrb	r3, [r4, #0]
            state_entry.length += 1;
        } break;

        case (M_TB_STORE_TYPE_SEC_BCN_STATE):
        {
            state_entry.val[0] = m_tb_state_get_beacon_state();
   14f22:	70a0      	strb	r0, [r4, #2]
            state_entry.length += 1;
   14f24:	3301      	adds	r3, #1
   14f26:	7023      	strb	r3, [r4, #0]
   14f28:	e036      	b.n	14f98 <m_tb_store_update_ind+0x380>
        } break;

        case (M_TB_STORE_TYPE_NET_TX_STATE):
        {
            state_entry.val[0] = m_tb_state_get_net_tx_state();
   14f2a:	f7ff fa81 	bl	14430 <m_tb_state_get_net_tx_state>
            state_entry.length += 1;
   14f2e:	7823      	ldrb	r3, [r4, #0]
            state_entry.length += 1;
        } break;

        case (M_TB_STORE_TYPE_NET_TX_STATE):
        {
            state_entry.val[0] = m_tb_state_get_net_tx_state();
   14f30:	70a0      	strb	r0, [r4, #2]
            state_entry.length += 1;
   14f32:	3301      	adds	r3, #1
   14f34:	7023      	strb	r3, [r4, #0]
   14f36:	e02f      	b.n	14f98 <m_tb_store_update_ind+0x380>
        } break;

        #if (BLE_MESH_RELAY)
        case (M_TB_STORE_TYPE_RELAY_STATE):
        {
            state_entry.val[0] = m_tb_state_get_relay_state(&state_entry.val[1]);
   14f38:	2023      	movs	r0, #35	; 0x23
   14f3a:	ab02      	add	r3, sp, #8
   14f3c:	18c0      	adds	r0, r0, r3
   14f3e:	f7ff fa5d 	bl	143fc <m_tb_state_get_relay_state>
            state_entry.length += 2;
   14f42:	7823      	ldrb	r3, [r4, #0]
        } break;

        #if (BLE_MESH_RELAY)
        case (M_TB_STORE_TYPE_RELAY_STATE):
        {
            state_entry.val[0] = m_tb_state_get_relay_state(&state_entry.val[1]);
   14f44:	70a0      	strb	r0, [r4, #2]
            state_entry.length += 2;
   14f46:	3302      	adds	r3, #2
   14f48:	7023      	strb	r3, [r4, #0]
   14f4a:	e025      	b.n	14f98 <m_tb_store_update_ind+0x380>
        case (M_TB_STORE_TYPE_DEV_KEY):
        {
            // Get device key information
            const m_tb_key_dev_t *p_key_dev;

            m_tb_key_dev_get(&p_key_dev);
   14f4c:	a809      	add	r0, sp, #36	; 0x24
   14f4e:	f7fc ff7f 	bl	11e50 <m_tb_key_dev_get>

            // Get device key
            memcpy(&state_entry.val[0], &p_key_dev->key[0], M_KEY_LEN);
   14f52:	2022      	movs	r0, #34	; 0x22
   14f54:	9b09      	ldr	r3, [sp, #36]	; 0x24
   14f56:	2210      	movs	r2, #16
   14f58:	1c99      	adds	r1, r3, #2
   14f5a:	ab02      	add	r3, sp, #8
   14f5c:	18c0      	adds	r0, r0, r3
   14f5e:	f000 fd37 	bl	159d0 <memcpy>
            state_entry.length += M_KEY_LEN;
   14f62:	7823      	ldrb	r3, [r4, #0]
   14f64:	3310      	adds	r3, #16
   14f66:	7023      	strb	r3, [r4, #0]
   14f68:	e016      	b.n	14f98 <m_tb_store_update_ind+0x380>
        case (M_TB_STORE_TYPE_IV_SEQ):
        {
            m_tb_store_state_iv_seq_t *p_entry_iv_seq = (m_tb_store_state_iv_seq_t *)&state_entry;

            // Get IV and SEQ values
            m_tb_key_get_iv_seq(&p_entry_iv_seq->seq, &p_entry_iv_seq->iv);
   14f6a:	a90c      	add	r1, sp, #48	; 0x30
   14f6c:	a80d      	add	r0, sp, #52	; 0x34
   14f6e:	f7fd fe67 	bl	12c40 <m_tb_key_get_iv_seq>

            p_entry_iv_seq->seq += M_TB_STORE_SEQ_OFFSET;
   14f72:	68e3      	ldr	r3, [r4, #12]
   14f74:	3364      	adds	r3, #100	; 0x64
   14f76:	60e3      	str	r3, [r4, #12]
            p_entry_iv_seq->clock_ms = 0;
   14f78:	2300      	movs	r3, #0
   14f7a:	6063      	str	r3, [r4, #4]
            p_entry_iv_seq->nb_wrap = 0;
   14f7c:	8063      	strh	r3, [r4, #2]

            state_entry.length = CO_ALIGN4_HI(sizeof(m_tb_store_state_iv_seq_t));
   14f7e:	3310      	adds	r3, #16
   14f80:	7023      	strb	r3, [r4, #0]
   14f82:	e009      	b.n	14f98 <m_tb_store_update_ind+0x380>
   14f84:	e7fe      	b.n	14f84 <m_tb_store_update_ind+0x36c>
   14f86:	46c0      	nop			; (mov r8, r8)
   14f88:	100126d0 	.word	0x100126d0
   14f8c:	10010514 	.word	0x10010514
   14f90:	00022af1 	.word	0x00022af1
   14f94:	00022a71 	.word	0x00022a71
        {
            ASSERT_INFO(0, state_type, 0);
        } break;
    }

    state_entry.length = CO_ALIGN4_HI(state_entry.length);
   14f98:	23fc      	movs	r3, #252	; 0xfc
   14f9a:	7821      	ldrb	r1, [r4, #0]

    bc_m_send_update_ind(M_TB_STORE_UPD_TYPE_STATE, state_entry.length, (uint8_t *)&state_entry);
   14f9c:	0022      	movs	r2, r4
        {
            ASSERT_INFO(0, state_type, 0);
        } break;
    }

    state_entry.length = CO_ALIGN4_HI(state_entry.length);
   14f9e:	3103      	adds	r1, #3
   14fa0:	4019      	ands	r1, r3
   14fa2:	7021      	strb	r1, [r4, #0]

    bc_m_send_update_ind(M_TB_STORE_UPD_TYPE_STATE, state_entry.length, (uint8_t *)&state_entry);
   14fa4:	2007      	movs	r0, #7
   14fa6:	b289      	uxth	r1, r1
   14fa8:	f7f4 f8d4 	bl	9154 <bc_m_send_update_ind>
            default:
            {
            } break;
        }
    }
}
   14fac:	b015      	add	sp, #84	; 0x54
   14fae:	bdf0      	pop	{r4, r5, r6, r7, pc}

00014fb0 <m_tb_store_get_compo_data>:

void m_tb_store_get_compo_data(uint8_t page, m_tb_store_cb_compo_data_t cb)
{
   14fb0:	b510      	push	{r4, lr}
   14fb2:	000c      	movs	r4, r1
    // Inform the application that a page of composition data is required
    bc_m_send_compo_data_req_ind(page);
   14fb4:	f7f4 f818 	bl	8fe8 <bc_m_send_compo_data_req_ind>

    // Store the callback function to be called upon reception of the composition data
    p_m_tb_store_env->cb_compo_data = cb;
   14fb8:	4b01      	ldr	r3, [pc, #4]	; (14fc0 <m_tb_store_get_compo_data+0x10>)
   14fba:	681b      	ldr	r3, [r3, #0]
   14fbc:	601c      	str	r4, [r3, #0]
}
   14fbe:	bd10      	pop	{r4, pc}
   14fc0:	100126d0 	.word	0x100126d0

00014fc4 <m_tb_store_rx_compo_data>:

void m_tb_store_rx_compo_data(uint8_t page, uint8_t length, uint8_t *p_data)
{
   14fc4:	b510      	push	{r4, lr}
    if (p_m_tb_store_env->cb_compo_data != NULL)
   14fc6:	4c05      	ldr	r4, [pc, #20]	; (14fdc <m_tb_store_rx_compo_data+0x18>)
   14fc8:	6823      	ldr	r3, [r4, #0]
   14fca:	681b      	ldr	r3, [r3, #0]
   14fcc:	2b00      	cmp	r3, #0
   14fce:	d003      	beq.n	14fd8 <m_tb_store_rx_compo_data+0x14>
    {
        // Call the stored callback
        p_m_tb_store_env->cb_compo_data(page, length, p_data);
   14fd0:	4798      	blx	r3

        p_m_tb_store_env->cb_compo_data = NULL;
   14fd2:	2200      	movs	r2, #0
   14fd4:	6823      	ldr	r3, [r4, #0]
   14fd6:	601a      	str	r2, [r3, #0]
    }
}
   14fd8:	bd10      	pop	{r4, pc}
   14fda:	46c0      	nop			; (mov r8, r8)
   14fdc:	100126d0 	.word	0x100126d0

00014fe0 <m_tb_store_save>:

void m_tb_store_save(uint8_t upd_type, uint16_t length, uint8_t *p_data)
{
   14fe0:	b5f0      	push	{r4, r5, r6, r7, lr}
	M_PRINTF(L_TB, "upd_type = %d", upd_type);
   14fe2:	4b72      	ldr	r3, [pc, #456]	; (151ac <m_tb_store_save+0x1cc>)
        p_m_tb_store_env->cb_compo_data = NULL;
    }
}

void m_tb_store_save(uint8_t upd_type, uint16_t length, uint8_t *p_data)
{
   14fe4:	b089      	sub	sp, #36	; 0x24
	M_PRINTF(L_TB, "upd_type = %d", upd_type);
   14fe6:	681b      	ldr	r3, [r3, #0]
        p_m_tb_store_env->cb_compo_data = NULL;
    }
}

void m_tb_store_save(uint8_t upd_type, uint16_t length, uint8_t *p_data)
{
   14fe8:	0005      	movs	r5, r0
   14fea:	9103      	str	r1, [sp, #12]
   14fec:	9204      	str	r2, [sp, #16]
   14fee:	4e70      	ldr	r6, [pc, #448]	; (151b0 <m_tb_store_save+0x1d0>)
	M_PRINTF(L_TB, "upd_type = %d", upd_type);
   14ff0:	079b      	lsls	r3, r3, #30
   14ff2:	d514      	bpl.n	1501e <m_tb_store_save+0x3e>
   14ff4:	4c6f      	ldr	r4, [pc, #444]	; (151b4 <m_tb_store_save+0x1d4>)
   14ff6:	4b70      	ldr	r3, [pc, #448]	; (151b8 <m_tb_store_save+0x1d8>)
   14ff8:	0022      	movs	r2, r4
   14ffa:	0020      	movs	r0, r4
   14ffc:	3372      	adds	r3, #114	; 0x72
   14ffe:	3220      	adds	r2, #32
   15000:	9300      	str	r3, [sp, #0]
   15002:	0021      	movs	r1, r4
   15004:	4b6d      	ldr	r3, [pc, #436]	; (151bc <m_tb_store_save+0x1dc>)
   15006:	3031      	adds	r0, #49	; 0x31
   15008:	f7ef fcd0 	bl	49ac <m_print>
   1500c:	0029      	movs	r1, r5
   1500e:	1cb0      	adds	r0, r6, #2
   15010:	f7ef fccc 	bl	49ac <m_print>
   15014:	0020      	movs	r0, r4
   15016:	1da1      	adds	r1, r4, #6
   15018:	3063      	adds	r0, #99	; 0x63
   1501a:	f7ef fcc7 	bl	49ac <m_print>
	m_printf_hex(L_TB, "save config data", p_data, length);
   1501e:	0031      	movs	r1, r6
   15020:	9b03      	ldr	r3, [sp, #12]
   15022:	3110      	adds	r1, #16
   15024:	9a04      	ldr	r2, [sp, #16]
   15026:	2002      	movs	r0, #2
   15028:	f7ef fd20 	bl	4a6c <m_printf_hex>
   1502c:	ae06      	add	r6, sp, #24
	uint16_t tLen = sizeof(m_tb_store_hdr_t);
	m_tb_store_hdr_t section;
	uint8_t existed = 0;
	m_tb_store_entry_t *p_entry = NULL;

	switch(upd_type){
   1502e:	2d07      	cmp	r5, #7
   15030:	d878      	bhi.n	15124 <m_tb_store_save+0x144>
   15032:	0028      	movs	r0, r5
   15034:	f008 fe8e 	bl	1dd54 <__gnu_thumb1_case_uqi>
   15038:	78780404 	.word	0x78780404
   1503c:	0c0a0806 	.word	0x0c0a0806
		case M_TB_STORE_UPD_TYPE_NET_KEY_UPDATED:/// Network key updated
		case M_TB_STORE_UPD_TYPE_NET_KEY_DELETED:{/// Network key deleted
			sIndex = M_TB_STORE_SECT_TYPE_NET_KEY;
   15040:	2401      	movs	r4, #1
   15042:	e072      	b.n	1512a <m_tb_store_save+0x14a>
		case M_TB_STORE_UPD_TYPE_APP_KEY_UPDATED:/// Application key updated
		case M_TB_STORE_UPD_TYPE_APP_KEY_DELETED:{/// Application key deleted
			sIndex = M_TB_STORE_SECT_TYPE_APP_KEY;
		}break;
		case M_TB_STORE_UPD_TYPE_PUBLI_PARAM:{/// Model publication parameters updated
			sIndex = M_TB_STORE_SECT_TYPE_PUBLI_INFO;
   15044:	2403      	movs	r4, #3
		}break;
   15046:	e070      	b.n	1512a <m_tb_store_save+0x14a>
		case M_TB_STORE_UPD_TYPE_SUBS_LIST:{/// Model subscription list updated
			sIndex = M_TB_STORE_SECT_TYPE_SUBS_LIST;
   15048:	2404      	movs	r4, #4
		}break;
   1504a:	e06e      	b.n	1512a <m_tb_store_save+0x14a>
		case M_TB_STORE_UPD_TYPE_BINDING:{/// Model/application key binding updated
			sIndex = M_TB_STORE_SECT_TYPE_BINDING;
   1504c:	2405      	movs	r4, #5
		}break;
   1504e:	e06c      	b.n	1512a <m_tb_store_save+0x14a>
		case M_TB_STORE_UPD_TYPE_STATE:{/// State updated/add
			sIndex = M_TB_STORE_SECT_TYPE_STATE;
			m_tb_store_state_t* data_new = (m_tb_store_state_t*)p_data;
			m_tb_store_state_t* data_old = NULL;

			mesh_flash_read(SECTION_ADDR(sIndex), sizeof(section), (uint8_t*)&section);
   15050:	20fc      	movs	r0, #252	; 0xfc
   15052:	0032      	movs	r2, r6
   15054:	2108      	movs	r1, #8
   15056:	02c0      	lsls	r0, r0, #11
   15058:	f7f2 fdb6 	bl	7bc8 <mesh_flash_read>
	
			m_tb_store_hdr_t* p_section = (m_tb_store_hdr_t*)ke_malloc(section.length+length, 0);	
   1505c:	9b03      	ldr	r3, [sp, #12]
   1505e:	8830      	ldrh	r0, [r6, #0]
   15060:	2100      	movs	r1, #0
   15062:	18c0      	adds	r0, r0, r3
   15064:	f7f2 f93c 	bl	72e0 <ke_malloc>
   15068:	0004      	movs	r4, r0
			mesh_flash_read(SECTION_ADDR(sIndex), section.length, (uint8_t*)p_section);
   1506a:	0002      	movs	r2, r0
   1506c:	20fc      	movs	r0, #252	; 0xfc
   1506e:	8831      	ldrh	r1, [r6, #0]
   15070:	02c0      	lsls	r0, r0, #11
   15072:	f7f2 fda9 	bl	7bc8 <mesh_flash_read>
			if(p_section->nb_entries){
   15076:	78e3      	ldrb	r3, [r4, #3]
   15078:	2b00      	cmp	r3, #0
   1507a:	d03c      	beq.n	150f6 <m_tb_store_save+0x116>
		    	p_entry = (m_tb_store_entry_t *)M_TB_STORE_GET_FIRST_ENTRY(p_section);
   1507c:	0025      	movs	r5, r4
			    for (uint8_t cnt = 0; cnt < p_section->nb_entries; ++cnt){
   1507e:	2700      	movs	r7, #0
			mesh_flash_read(SECTION_ADDR(sIndex), sizeof(section), (uint8_t*)&section);
	
			m_tb_store_hdr_t* p_section = (m_tb_store_hdr_t*)ke_malloc(section.length+length, 0);	
			mesh_flash_read(SECTION_ADDR(sIndex), section.length, (uint8_t*)p_section);
			if(p_section->nb_entries){
		    	p_entry = (m_tb_store_entry_t *)M_TB_STORE_GET_FIRST_ENTRY(p_section);
   15080:	3508      	adds	r5, #8
			    for (uint8_t cnt = 0; cnt < p_section->nb_entries; ++cnt){
   15082:	78e3      	ldrb	r3, [r4, #3]
   15084:	42bb      	cmp	r3, r7
   15086:	d936      	bls.n	150f6 <m_tb_store_save+0x116>
					data_old = (m_tb_store_state_t*)p_entry;
					M_PRINTF(L_APP, "otype[%d] olength[%d] ntype[%d] nlength[%d]"
   15088:	2280      	movs	r2, #128	; 0x80
   1508a:	4b48      	ldr	r3, [pc, #288]	; (151ac <m_tb_store_save+0x1cc>)
   1508c:	0192      	lsls	r2, r2, #6
   1508e:	681b      	ldr	r3, [r3, #0]
   15090:	4213      	tst	r3, r2
   15092:	d01b      	beq.n	150cc <m_tb_store_save+0xec>
   15094:	4e47      	ldr	r6, [pc, #284]	; (151b4 <m_tb_store_save+0x1d4>)
   15096:	4b48      	ldr	r3, [pc, #288]	; (151b8 <m_tb_store_save+0x1d8>)
   15098:	0032      	movs	r2, r6
   1509a:	0030      	movs	r0, r6
   1509c:	3372      	adds	r3, #114	; 0x72
   1509e:	3220      	adds	r2, #32
   150a0:	9300      	str	r3, [sp, #0]
   150a2:	0031      	movs	r1, r6
   150a4:	4b46      	ldr	r3, [pc, #280]	; (151c0 <m_tb_store_save+0x1e0>)
   150a6:	3031      	adds	r0, #49	; 0x31
   150a8:	f7ef fc80 	bl	49ac <m_print>
   150ac:	9804      	ldr	r0, [sp, #16]
   150ae:	9b04      	ldr	r3, [sp, #16]
   150b0:	7800      	ldrb	r0, [r0, #0]
   150b2:	7869      	ldrb	r1, [r5, #1]
   150b4:	785b      	ldrb	r3, [r3, #1]
   150b6:	782a      	ldrb	r2, [r5, #0]
   150b8:	9000      	str	r0, [sp, #0]
   150ba:	483d      	ldr	r0, [pc, #244]	; (151b0 <m_tb_store_save+0x1d0>)
   150bc:	3021      	adds	r0, #33	; 0x21
   150be:	f7ef fc75 	bl	49ac <m_print>
   150c2:	0030      	movs	r0, r6
   150c4:	1db1      	adds	r1, r6, #6
   150c6:	3063      	adds	r0, #99	; 0x63
   150c8:	f7ef fc70 	bl	49ac <m_print>
									, data_old->type, data_old->length
									, data_new->type, data_new->length);
			    	if(data_old->type == data_new->type && 
   150cc:	9b04      	ldr	r3, [sp, #16]
   150ce:	786a      	ldrb	r2, [r5, #1]
   150d0:	785b      	ldrb	r3, [r3, #1]
   150d2:	429a      	cmp	r2, r3
   150d4:	d10a      	bne.n	150ec <m_tb_store_save+0x10c>
   150d6:	9b04      	ldr	r3, [sp, #16]
   150d8:	782a      	ldrb	r2, [r5, #0]
   150da:	781b      	ldrb	r3, [r3, #0]
   150dc:	429a      	cmp	r2, r3
   150de:	d105      	bne.n	150ec <m_tb_store_save+0x10c>
						data_old->length == data_new->length){//delete the same data
						existed = 1;
						memcpy(data_old, data_new, length);
   150e0:	9a03      	ldr	r2, [sp, #12]
   150e2:	9904      	ldr	r1, [sp, #16]
   150e4:	0028      	movs	r0, r5
   150e6:	f000 fc73 	bl	159d0 <memcpy>
   150ea:	e011      	b.n	15110 <m_tb_store_save+0x130>
						break;
					}
			        // Update total length
			        tLen += p_entry->length;
			        // Move on next entry
			        p_entry = (m_tb_store_entry_t *)M_TB_STORE_GET_NEXT_ENTRY(p_entry);
   150ec:	782b      	ldrb	r3, [r5, #0]
	
			m_tb_store_hdr_t* p_section = (m_tb_store_hdr_t*)ke_malloc(section.length+length, 0);	
			mesh_flash_read(SECTION_ADDR(sIndex), section.length, (uint8_t*)p_section);
			if(p_section->nb_entries){
		    	p_entry = (m_tb_store_entry_t *)M_TB_STORE_GET_FIRST_ENTRY(p_section);
			    for (uint8_t cnt = 0; cnt < p_section->nb_entries; ++cnt){
   150ee:	3701      	adds	r7, #1
						break;
					}
			        // Update total length
			        tLen += p_entry->length;
			        // Move on next entry
			        p_entry = (m_tb_store_entry_t *)M_TB_STORE_GET_NEXT_ENTRY(p_entry);
   150f0:	18ed      	adds	r5, r5, r3
	
			m_tb_store_hdr_t* p_section = (m_tb_store_hdr_t*)ke_malloc(section.length+length, 0);	
			mesh_flash_read(SECTION_ADDR(sIndex), section.length, (uint8_t*)p_section);
			if(p_section->nb_entries){
		    	p_entry = (m_tb_store_entry_t *)M_TB_STORE_GET_FIRST_ENTRY(p_section);
			    for (uint8_t cnt = 0; cnt < p_section->nb_entries; ++cnt){
   150f2:	b2ff      	uxtb	r7, r7
   150f4:	e7c5      	b.n	15082 <m_tb_store_save+0xa2>
			        // Move on next entry
			        p_entry = (m_tb_store_entry_t *)M_TB_STORE_GET_NEXT_ENTRY(p_entry);
			    }
			}
			if(!existed){
				memcpy((uint8_t*)p_section+p_section->length, p_data, length);
   150f6:	8820      	ldrh	r0, [r4, #0]
   150f8:	9904      	ldr	r1, [sp, #16]
   150fa:	1820      	adds	r0, r4, r0
   150fc:	9a03      	ldr	r2, [sp, #12]
   150fe:	f000 fc67 	bl	159d0 <memcpy>
				p_section->length += length;
   15102:	8821      	ldrh	r1, [r4, #0]
   15104:	9b03      	ldr	r3, [sp, #12]
   15106:	1859      	adds	r1, r3, r1
				p_section->nb_entries++;
   15108:	78e3      	ldrb	r3, [r4, #3]
			        p_entry = (m_tb_store_entry_t *)M_TB_STORE_GET_NEXT_ENTRY(p_entry);
			    }
			}
			if(!existed){
				memcpy((uint8_t*)p_section+p_section->length, p_data, length);
				p_section->length += length;
   1510a:	8021      	strh	r1, [r4, #0]
				p_section->nb_entries++;
   1510c:	3301      	adds	r3, #1
   1510e:	70e3      	strb	r3, [r4, #3]
			}
			mesh_flash_write(SECTION_ADDR(sIndex), p_section->length, (uint8_t*)p_section);
   15110:	20fc      	movs	r0, #252	; 0xfc
   15112:	8821      	ldrh	r1, [r4, #0]
   15114:	0022      	movs	r2, r4
   15116:	02c0      	lsls	r0, r0, #11
   15118:	f7f2 fd94 	bl	7c44 <mesh_flash_write>
			ke_free(p_section);
   1511c:	0020      	movs	r0, r4
   1511e:	f7f2 f8e3 	bl	72e8 <ke_free>
   15122:	e041      	b.n	151a8 <m_tb_store_save+0x1c8>

void m_tb_store_save(uint8_t upd_type, uint16_t length, uint8_t *p_data)
{
	M_PRINTF(L_TB, "upd_type = %d", upd_type);
	m_printf_hex(L_TB, "save config data", p_data, length);
	uint32_t sIndex = 0;
   15124:	2400      	movs	r4, #0
   15126:	e000      	b.n	1512a <m_tb_store_save+0x14a>
			sIndex = M_TB_STORE_SECT_TYPE_NET_KEY;
			
		}break;
		case M_TB_STORE_UPD_TYPE_APP_KEY_UPDATED:/// Application key updated
		case M_TB_STORE_UPD_TYPE_APP_KEY_DELETED:{/// Application key deleted
			sIndex = M_TB_STORE_SECT_TYPE_APP_KEY;
   15128:	2402      	movs	r4, #2
		}break;
		default:{
		}
		break;
	}
	mesh_flash_read(SECTION_ADDR(sIndex), sizeof(section), (uint8_t*)&section);
   1512a:	23fc      	movs	r3, #252	; 0xfc
   1512c:	00db      	lsls	r3, r3, #3
   1512e:	18e4      	adds	r4, r4, r3
   15130:	0224      	lsls	r4, r4, #8
   15132:	0032      	movs	r2, r6
   15134:	2108      	movs	r1, #8
   15136:	0020      	movs	r0, r4
   15138:	f7f2 fd46 	bl	7bc8 <mesh_flash_read>
	
	m_tb_store_hdr_t* p_section = (m_tb_store_hdr_t*)ke_malloc(section.length+length, 0);	
   1513c:	9b03      	ldr	r3, [sp, #12]
   1513e:	8830      	ldrh	r0, [r6, #0]
   15140:	2100      	movs	r1, #0
   15142:	18c0      	adds	r0, r0, r3
   15144:	f7f2 f8cc 	bl	72e0 <ke_malloc>
   15148:	0005      	movs	r5, r0
	mesh_flash_read(SECTION_ADDR(sIndex), section.length, (uint8_t*)p_section);
   1514a:	0002      	movs	r2, r0
   1514c:	8831      	ldrh	r1, [r6, #0]
   1514e:	0020      	movs	r0, r4
   15150:	f7f2 fd3a 	bl	7bc8 <mesh_flash_read>
	if(p_section->nb_entries){
   15154:	78eb      	ldrb	r3, [r5, #3]
   15156:	9305      	str	r3, [sp, #20]
   15158:	2b00      	cmp	r3, #0
   1515a:	d010      	beq.n	1517e <m_tb_store_save+0x19e>
    	p_entry = (m_tb_store_entry_t *)M_TB_STORE_GET_FIRST_ENTRY(p_section);
   1515c:	002f      	movs	r7, r5

	    for (uint8_t cnt = 0; cnt < p_section->nb_entries; ++cnt){
   1515e:	2600      	movs	r6, #0
	mesh_flash_read(SECTION_ADDR(sIndex), sizeof(section), (uint8_t*)&section);
	
	m_tb_store_hdr_t* p_section = (m_tb_store_hdr_t*)ke_malloc(section.length+length, 0);	
	mesh_flash_read(SECTION_ADDR(sIndex), section.length, (uint8_t*)p_section);
	if(p_section->nb_entries){
    	p_entry = (m_tb_store_entry_t *)M_TB_STORE_GET_FIRST_ENTRY(p_section);
   15160:	3708      	adds	r7, #8

	    for (uint8_t cnt = 0; cnt < p_section->nb_entries; ++cnt){
	    	if(0 == memcmp(p_data, p_entry, length)){//delete the same data
   15162:	9a03      	ldr	r2, [sp, #12]
   15164:	0039      	movs	r1, r7
   15166:	9804      	ldr	r0, [sp, #16]
   15168:	f000 fc0a 	bl	15980 <memcmp>
   1516c:	2800      	cmp	r0, #0
   1516e:	d018      	beq.n	151a2 <m_tb_store_save+0x1c2>
				break;
			}
	        // Update total length
	        tLen += p_entry->length;
	        // Move on next entry
	        p_entry = (m_tb_store_entry_t *)M_TB_STORE_GET_NEXT_ENTRY(p_entry);
   15170:	783b      	ldrb	r3, [r7, #0]
	m_tb_store_hdr_t* p_section = (m_tb_store_hdr_t*)ke_malloc(section.length+length, 0);	
	mesh_flash_read(SECTION_ADDR(sIndex), section.length, (uint8_t*)p_section);
	if(p_section->nb_entries){
    	p_entry = (m_tb_store_entry_t *)M_TB_STORE_GET_FIRST_ENTRY(p_section);

	    for (uint8_t cnt = 0; cnt < p_section->nb_entries; ++cnt){
   15172:	3601      	adds	r6, #1
				break;
			}
	        // Update total length
	        tLen += p_entry->length;
	        // Move on next entry
	        p_entry = (m_tb_store_entry_t *)M_TB_STORE_GET_NEXT_ENTRY(p_entry);
   15174:	18ff      	adds	r7, r7, r3
	m_tb_store_hdr_t* p_section = (m_tb_store_hdr_t*)ke_malloc(section.length+length, 0);	
	mesh_flash_read(SECTION_ADDR(sIndex), section.length, (uint8_t*)p_section);
	if(p_section->nb_entries){
    	p_entry = (m_tb_store_entry_t *)M_TB_STORE_GET_FIRST_ENTRY(p_section);

	    for (uint8_t cnt = 0; cnt < p_section->nb_entries; ++cnt){
   15176:	9b05      	ldr	r3, [sp, #20]
   15178:	b2f6      	uxtb	r6, r6
   1517a:	42b3      	cmp	r3, r6
   1517c:	d1f1      	bne.n	15162 <m_tb_store_save+0x182>
	        // Move on next entry
	        p_entry = (m_tb_store_entry_t *)M_TB_STORE_GET_NEXT_ENTRY(p_entry);
	    }
	}
	if(!existed){
		memcpy((uint8_t*)p_section+p_section->length, p_data, length);
   1517e:	8828      	ldrh	r0, [r5, #0]
   15180:	9a03      	ldr	r2, [sp, #12]
   15182:	9904      	ldr	r1, [sp, #16]
   15184:	1828      	adds	r0, r5, r0
   15186:	f000 fc23 	bl	159d0 <memcpy>
		p_section->length += length;
   1518a:	8829      	ldrh	r1, [r5, #0]
   1518c:	9b03      	ldr	r3, [sp, #12]
		p_section->nb_entries++;
		mesh_flash_write(SECTION_ADDR(sIndex), p_section->length, (uint8_t*)p_section);
   1518e:	002a      	movs	r2, r5
	        p_entry = (m_tb_store_entry_t *)M_TB_STORE_GET_NEXT_ENTRY(p_entry);
	    }
	}
	if(!existed){
		memcpy((uint8_t*)p_section+p_section->length, p_data, length);
		p_section->length += length;
   15190:	1859      	adds	r1, r3, r1
		p_section->nb_entries++;
   15192:	78eb      	ldrb	r3, [r5, #3]
	        p_entry = (m_tb_store_entry_t *)M_TB_STORE_GET_NEXT_ENTRY(p_entry);
	    }
	}
	if(!existed){
		memcpy((uint8_t*)p_section+p_section->length, p_data, length);
		p_section->length += length;
   15194:	b289      	uxth	r1, r1
		p_section->nb_entries++;
   15196:	3301      	adds	r3, #1
	        p_entry = (m_tb_store_entry_t *)M_TB_STORE_GET_NEXT_ENTRY(p_entry);
	    }
	}
	if(!existed){
		memcpy((uint8_t*)p_section+p_section->length, p_data, length);
		p_section->length += length;
   15198:	8029      	strh	r1, [r5, #0]
		p_section->nb_entries++;
   1519a:	70eb      	strb	r3, [r5, #3]
		mesh_flash_write(SECTION_ADDR(sIndex), p_section->length, (uint8_t*)p_section);
   1519c:	0020      	movs	r0, r4
   1519e:	f7f2 fd51 	bl	7c44 <mesh_flash_write>
	}
	ke_free(p_section);
   151a2:	0028      	movs	r0, r5
   151a4:	f7f2 f8a0 	bl	72e8 <ke_free>
}
   151a8:	b009      	add	sp, #36	; 0x24
   151aa:	bdf0      	pop	{r4, r5, r6, r7, pc}
   151ac:	10010514 	.word	0x10010514
   151b0:	00022b71 	.word	0x00022b71
   151b4:	00022a71 	.word	0x00022a71
   151b8:	00022af1 	.word	0x00022af1
   151bc:	00000629 	.word	0x00000629
   151c0:	00000653 	.word	0x00000653

000151c4 <m_tb_store_data_len>:

uint32_t m_tb_store_data_len(void)
{
   151c4:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	uint32_t i, l = 0;
   151c6:	2400      	movs	r4, #0
	m_tb_store_hdr_t section;
	for(i = 0; i < M_TB_STORE_SECT_TYPE_NUM_MAX; ++i){
   151c8:	0025      	movs	r5, r4
   151ca:	23fc      	movs	r3, #252	; 0xfc
   151cc:	00db      	lsls	r3, r3, #3
   151ce:	18ee      	adds	r6, r5, r3
   151d0:	0236      	lsls	r6, r6, #8
		mesh_flash_read(SECTION_ADDR(i), sizeof(section), (uint8_t*)&section);
   151d2:	aa02      	add	r2, sp, #8
   151d4:	2108      	movs	r1, #8
   151d6:	0030      	movs	r0, r6
   151d8:	f7f2 fcf6 	bl	7bc8 <mesh_flash_read>
		if(section.pattern != M_TB_STORE_SECTION_PATTERN){
   151dc:	9a03      	ldr	r2, [sp, #12]
   151de:	4b0e      	ldr	r3, [pc, #56]	; (15218 <m_tb_store_data_len+0x54>)
   151e0:	9201      	str	r2, [sp, #4]
   151e2:	429a      	cmp	r2, r3
   151e4:	d00b      	beq.n	151fe <m_tb_store_data_len+0x3a>
			section.length = sizeof(section);
   151e6:	2108      	movs	r1, #8
   151e8:	aa02      	add	r2, sp, #8
   151ea:	8011      	strh	r1, [r2, #0]
			section.nb_entries = 0;
   151ec:	2200      	movs	r2, #0
   151ee:	a802      	add	r0, sp, #8
   151f0:	70c2      	strb	r2, [r0, #3]
			section.pattern = M_TB_STORE_SECTION_PATTERN;
			section.type = i;
   151f2:	7085      	strb	r5, [r0, #2]
			mesh_flash_write(SECTION_ADDR(i), sizeof(section), (uint8_t*)&section);
   151f4:	0002      	movs	r2, r0
   151f6:	0030      	movs	r0, r6
	for(i = 0; i < M_TB_STORE_SECT_TYPE_NUM_MAX; ++i){
		mesh_flash_read(SECTION_ADDR(i), sizeof(section), (uint8_t*)&section);
		if(section.pattern != M_TB_STORE_SECTION_PATTERN){
			section.length = sizeof(section);
			section.nb_entries = 0;
			section.pattern = M_TB_STORE_SECTION_PATTERN;
   151f8:	9303      	str	r3, [sp, #12]
			section.type = i;
			mesh_flash_write(SECTION_ADDR(i), sizeof(section), (uint8_t*)&section);
   151fa:	f7f2 fd23 	bl	7c44 <mesh_flash_write>
		}
		l += section.length;
   151fe:	ab02      	add	r3, sp, #8
   15200:	881b      	ldrh	r3, [r3, #0]

uint32_t m_tb_store_data_len(void)
{
	uint32_t i, l = 0;
	m_tb_store_hdr_t section;
	for(i = 0; i < M_TB_STORE_SECT_TYPE_NUM_MAX; ++i){
   15202:	3501      	adds	r5, #1
			section.nb_entries = 0;
			section.pattern = M_TB_STORE_SECTION_PATTERN;
			section.type = i;
			mesh_flash_write(SECTION_ADDR(i), sizeof(section), (uint8_t*)&section);
		}
		l += section.length;
   15204:	18e4      	adds	r4, r4, r3

uint32_t m_tb_store_data_len(void)
{
	uint32_t i, l = 0;
	m_tb_store_hdr_t section;
	for(i = 0; i < M_TB_STORE_SECT_TYPE_NUM_MAX; ++i){
   15206:	2d06      	cmp	r5, #6
   15208:	d1df      	bne.n	151ca <m_tb_store_data_len+0x6>
			mesh_flash_write(SECTION_ADDR(i), sizeof(section), (uint8_t*)&section);
		}
		l += section.length;
	}
	if(l <= sizeof(m_tb_store_hdr_t)*(M_TB_STORE_SECT_TYPE_NUM_MAX)){
		return 0;
   1520a:	2000      	movs	r0, #0
			section.type = i;
			mesh_flash_write(SECTION_ADDR(i), sizeof(section), (uint8_t*)&section);
		}
		l += section.length;
	}
	if(l <= sizeof(m_tb_store_hdr_t)*(M_TB_STORE_SECT_TYPE_NUM_MAX)){
   1520c:	2c30      	cmp	r4, #48	; 0x30
   1520e:	d900      	bls.n	15212 <m_tb_store_data_len+0x4e>
   15210:	0020      	movs	r0, r4
		return 0;
	}
	
	return l;
}
   15212:	b004      	add	sp, #16
   15214:	bd70      	pop	{r4, r5, r6, pc}
   15216:	46c0      	nop			; (mov r8, r8)
   15218:	baabfafa 	.word	0xbaabfafa

0001521c <m_tb_store_get_data>:

uint32_t m_tb_store_get_data(uint32_t l, uint8_t* d)
{
   1521c:	b573      	push	{r0, r1, r4, r5, r6, lr}
   1521e:	24fc      	movs	r4, #252	; 0xfc
   15220:	000e      	movs	r6, r1
	uint32_t i;
	m_tb_store_hdr_t section;
	
	l = 0;
   15222:	2500      	movs	r5, #0
	
	return l;
}

uint32_t m_tb_store_get_data(uint32_t l, uint8_t* d)
{
   15224:	02e4      	lsls	r4, r4, #11
	uint32_t i;
	m_tb_store_hdr_t section;
	
	l = 0;
	for(i = 0; i < M_TB_STORE_SECT_TYPE_NUM_MAX; ++i){
		 mesh_flash_read(SECTION_ADDR(i), sizeof(section), (uint8_t*)&section);
   15226:	466a      	mov	r2, sp
   15228:	2108      	movs	r1, #8
   1522a:	0020      	movs	r0, r4
   1522c:	f7f2 fccc 	bl	7bc8 <mesh_flash_read>
		 mesh_flash_read(SECTION_ADDR(i), section.length, d+l);
   15230:	466b      	mov	r3, sp
   15232:	1972      	adds	r2, r6, r5
   15234:	8819      	ldrh	r1, [r3, #0]
   15236:	0020      	movs	r0, r4
   15238:	f7f2 fcc6 	bl	7bc8 <mesh_flash_read>
		 l += section.length;
   1523c:	466b      	mov	r3, sp
   1523e:	881b      	ldrh	r3, [r3, #0]
   15240:	3401      	adds	r4, #1
   15242:	18ed      	adds	r5, r5, r3
{
	uint32_t i;
	m_tb_store_hdr_t section;
	
	l = 0;
	for(i = 0; i < M_TB_STORE_SECT_TYPE_NUM_MAX; ++i){
   15244:	4b02      	ldr	r3, [pc, #8]	; (15250 <m_tb_store_get_data+0x34>)
   15246:	34ff      	adds	r4, #255	; 0xff
   15248:	429c      	cmp	r4, r3
   1524a:	d1ec      	bne.n	15226 <m_tb_store_get_data+0xa>
		 mesh_flash_read(SECTION_ADDR(i), section.length, d+l);
		 l += section.length;
	}
	
	return M_ERR_NO_ERROR;
}
   1524c:	2000      	movs	r0, #0
   1524e:	bd76      	pop	{r1, r2, r4, r5, r6, pc}
   15250:	0007e600 	.word	0x0007e600

00015254 <m_tb_store_data_clear>:
void m_tb_store_data_clear(void)
{
	for(uint8_t i = 0; i < M_TB_STORE_SECT_TYPE_NUM_MAX; ++i){
		mesh_flash_erase(SECTION_ADDR(i));
   15254:	20fc      	movs	r0, #252	; 0xfc
	}
	
	return M_ERR_NO_ERROR;
}
void m_tb_store_data_clear(void)
{
   15256:	b510      	push	{r4, lr}
	for(uint8_t i = 0; i < M_TB_STORE_SECT_TYPE_NUM_MAX; ++i){
		mesh_flash_erase(SECTION_ADDR(i));
   15258:	02c0      	lsls	r0, r0, #11
   1525a:	f7f2 fd91 	bl	7d80 <mesh_flash_erase>
   1525e:	4808      	ldr	r0, [pc, #32]	; (15280 <m_tb_store_data_clear+0x2c>)
   15260:	f7f2 fd8e 	bl	7d80 <mesh_flash_erase>
   15264:	4807      	ldr	r0, [pc, #28]	; (15284 <m_tb_store_data_clear+0x30>)
   15266:	f7f2 fd8b 	bl	7d80 <mesh_flash_erase>
   1526a:	4807      	ldr	r0, [pc, #28]	; (15288 <m_tb_store_data_clear+0x34>)
   1526c:	f7f2 fd88 	bl	7d80 <mesh_flash_erase>
   15270:	4806      	ldr	r0, [pc, #24]	; (1528c <m_tb_store_data_clear+0x38>)
   15272:	f7f2 fd85 	bl	7d80 <mesh_flash_erase>
   15276:	4806      	ldr	r0, [pc, #24]	; (15290 <m_tb_store_data_clear+0x3c>)
   15278:	f7f2 fd82 	bl	7d80 <mesh_flash_erase>
	}
}
   1527c:	bd10      	pop	{r4, pc}
   1527e:	46c0      	nop			; (mov r8, r8)
   15280:	0007e100 	.word	0x0007e100
   15284:	0007e200 	.word	0x0007e200
   15288:	0007e300 	.word	0x0007e300
   1528c:	0007e400 	.word	0x0007e400
   15290:	0007e500 	.word	0x0007e500

00015294 <m_tb_timer_prog>:
 ****************************************************************************************
 */
__STATIC void m_tb_timer_prog(void)
{
    // Get first timer in the list
    m_tb_timer_t *p_timer = M_TB_TIMER_GET_FIRST();
   15294:	4b09      	ldr	r3, [pc, #36]	; (152bc <m_tb_timer_prog+0x28>)
 * @brief Program the first timer present in the list of timers. If no timer present in the
 * list or if timer cannot be programmed, inform the abstraction layer that the timer can be stopped.
 ****************************************************************************************
 */
__STATIC void m_tb_timer_prog(void)
{
   15296:	b507      	push	{r0, r1, r2, lr}
   15298:	681b      	ldr	r3, [r3, #0]
   1529a:	681b      	ldr	r3, [r3, #0]
    // Get first timer in the list
    m_tb_timer_t *p_timer = M_TB_TIMER_GET_FIRST();

    do
    {
        if (p_timer)
   1529c:	2b00      	cmp	r3, #0
   1529e:	d00a      	beq.n	152b6 <m_tb_timer_prog+0x22>
        {
            // Delay value in milliseconds
            uint32_t delay_ms;

            // Check if timer can be programmed
            if (m_al_timer_get_delay(p_timer->time_ms, p_timer->nb_wrap, &delay_ms) == M_ERR_NO_ERROR)
   152a0:	8a19      	ldrh	r1, [r3, #16]
   152a2:	aa01      	add	r2, sp, #4
   152a4:	68d8      	ldr	r0, [r3, #12]
   152a6:	f7f0 f9dd 	bl	5664 <m_al_timer_get_delay>
   152aa:	2800      	cmp	r0, #0
   152ac:	d103      	bne.n	152b6 <m_tb_timer_prog+0x22>
            {
            	//M_PRINTF(L_TB, "delay_ms = %d", delay_ms);
                m_al_timer_set(delay_ms);
   152ae:	9801      	ldr	r0, [sp, #4]
   152b0:	f7f0 fa08 	bl	56c4 <m_al_timer_set>
   152b4:	e001      	b.n	152ba <m_tb_timer_prog+0x26>
                break;
            }
        }

        m_al_timer_clear();
   152b6:	f7f0 fa13 	bl	56e0 <m_al_timer_clear>
    } while (0);
}
   152ba:	bd07      	pop	{r0, r1, r2, pc}
   152bc:	100126d4 	.word	0x100126d4

000152c0 <m_tb_timer_remove>:
 *
 * @param[in] p_timer   Pointer to the timer to be remove.
 ****************************************************************************************
 */
__STATIC void m_tb_timer_remove(m_tb_timer_t *p_timer)
{
   152c0:	b570      	push	{r4, r5, r6, lr}
   152c2:	0004      	movs	r4, r0
    // Indicate if timer was programmed
    bool was_prog = false;

    // Check if timer is first in the list
    if (M_TB_TIMER_IS_NEXT(p_timer))
   152c4:	4b05      	ldr	r3, [pc, #20]	; (152dc <m_tb_timer_remove+0x1c>)
    {
        was_prog = true;
    }

    // Extract the timer from the list
    CO_LIST_POP_ELT(p_m_tb_timer_env->list_timer, p_timer);
   152c6:	0021      	movs	r1, r4
{
    // Indicate if timer was programmed
    bool was_prog = false;

    // Check if timer is first in the list
    if (M_TB_TIMER_IS_NEXT(p_timer))
   152c8:	6818      	ldr	r0, [r3, #0]
   152ca:	6805      	ldr	r5, [r0, #0]
    {
        was_prog = true;
    }

    // Extract the timer from the list
    CO_LIST_POP_ELT(p_m_tb_timer_env->list_timer, p_timer);
   152cc:	f7ef f898 	bl	4400 <co_list_extract>

    // If needed, program the next timer
    if (was_prog)
   152d0:	42ac      	cmp	r4, r5
   152d2:	d101      	bne.n	152d8 <m_tb_timer_remove+0x18>
    {
        m_tb_timer_prog();
   152d4:	f7ff ffde 	bl	15294 <m_tb_timer_prog>
    }
}
   152d8:	bd70      	pop	{r4, r5, r6, pc}
   152da:	46c0      	nop			; (mov r8, r8)
   152dc:	100126d4 	.word	0x100126d4

000152e0 <m_tb_timer_init>:
 * GLOBAL FUNCTIONS
 ****************************************************************************************
 */

uint16_t m_tb_timer_init(bool reset, void* p_env, const m_cfg_t* p_cfg)
{
   152e0:	b510      	push	{r4, lr}
   152e2:	4b06      	ldr	r3, [pc, #24]	; (152fc <m_tb_timer_init+0x1c>)
    if (!reset)
   152e4:	2800      	cmp	r0, #0
   152e6:	d104      	bne.n	152f2 <m_tb_timer_init+0x12>
    {
        // Get environment for Timer Manager Toolbox
        p_m_tb_timer_env = (m_tb_timer_env_t *)p_env;

        // Initialize the list of timers
        co_list_init(&p_m_tb_timer_env->list_timer);
   152e8:	0008      	movs	r0, r1
uint16_t m_tb_timer_init(bool reset, void* p_env, const m_cfg_t* p_cfg)
{
    if (!reset)
    {
        // Get environment for Timer Manager Toolbox
        p_m_tb_timer_env = (m_tb_timer_env_t *)p_env;
   152ea:	6019      	str	r1, [r3, #0]

        // Initialize the list of timers
        co_list_init(&p_m_tb_timer_env->list_timer);
   152ec:	f7ef f818 	bl	4320 <co_list_init>
   152f0:	e001      	b.n	152f6 <m_tb_timer_init+0x16>
    }
    else
    {
        p_m_tb_timer_env = NULL;
   152f2:	2200      	movs	r2, #0
   152f4:	601a      	str	r2, [r3, #0]
    }

    return (sizeof(m_tb_timer_env_t));
}
   152f6:	2008      	movs	r0, #8
   152f8:	bd10      	pop	{r4, pc}
   152fa:	46c0      	nop			; (mov r8, r8)
   152fc:	100126d4 	.word	0x100126d4

00015300 <m_tb_timer_get_env_size>:

uint16_t m_tb_timer_get_env_size(const m_cfg_t* p_cfg)
{
    return (sizeof(m_tb_timer_env_t));
}
   15300:	2008      	movs	r0, #8
   15302:	4770      	bx	lr

00015304 <m_tb_timer_set>:

void m_tb_timer_set(m_tb_timer_t *p_timer, uint32_t delay_ms)
{
   15304:	b570      	push	{r4, r5, r6, lr}
   15306:	0004      	movs	r4, r0
   15308:	000e      	movs	r6, r1
	//M_PRINTF(L_TB, "--------------start---------------p_timer[%p]", p_timer);
    // Remove timer from list of timers
    m_tb_timer_remove(p_timer);
   1530a:	f7ff ffd9 	bl	152c0 <m_tb_timer_remove>
	//M_PRINTF(L_TB, "------------remove ok-------------");
	m_tb_timer_t* p_list_timer = M_TB_TIMER_GET_FIRST();
   1530e:	4d21      	ldr	r5, [pc, #132]	; (15394 <m_tb_timer_set+0x90>)
   15310:	682b      	ldr	r3, [r5, #0]
   15312:	681b      	ldr	r3, [r3, #0]
	while (p_list_timer){
   15314:	2b00      	cmp	r3, #0
   15316:	d001      	beq.n	1531c <m_tb_timer_set+0x18>
    	//M_PRINTF(L_TB, "B = %p hdr = %p next = %p", p_list_timer, p_list_timer->hdr
		//									,  p_list_timer->hdr.next);
        // Get next timer
        p_list_timer = (m_tb_timer_t *)p_list_timer->hdr.next;
   15318:	681b      	ldr	r3, [r3, #0]
   1531a:	e7fb      	b.n	15314 <m_tb_timer_set+0x10>
    }
    // Get expiration time
    if (m_al_timer_get_time_ms(&p_timer->time_ms, &p_timer->nb_wrap, delay_ms))
   1531c:	0021      	movs	r1, r4
   1531e:	0020      	movs	r0, r4
   15320:	0032      	movs	r2, r6
   15322:	3110      	adds	r1, #16
   15324:	300c      	adds	r0, #12
   15326:	f7f0 f983 	bl	5630 <m_al_timer_get_time_ms>
   1532a:	2800      	cmp	r0, #0
   1532c:	d01e      	beq.n	1536c <m_tb_timer_set+0x68>
#define ASSERT_WARN(cond, param0, param1) {while(!(cond));}
#endif

__INLINE_S__ void GLOBAL_INT_DISABLE(void )
{
	__asm volatile ("cpsid i" : : : "memory");
   1532e:	b672      	cpsid	i
 */
__STATIC void m_tb_timer_insert(m_tb_timer_t *p_timer)
{
	//M_PRINTF(L_TB, "p_timer = %p hdr = %p", p_timer, p_timer->hdr);
    // Get first timer in the list of timers
    m_tb_timer_t *p_list_timer = M_TB_TIMER_GET_FIRST();
   15330:	6828      	ldr	r0, [r5, #0]
   15332:	6801      	ldr	r1, [r0, #0]

    if (p_list_timer)
   15334:	2900      	cmp	r1, #0
   15336:	d009      	beq.n	1534c <m_tb_timer_set+0x48>
__STATIC bool m_tb_timer_is_a_before_b(m_tb_timer_t *p_timer_a, m_tb_timer_t *p_timer_b)
{
    // Boolean indicating if timer a will expire before timer b
    bool is_before = true;

    if (p_timer_a->nb_wrap >= p_timer_b->nb_wrap)
   15338:	8a23      	ldrh	r3, [r4, #16]
   1533a:	8a0a      	ldrh	r2, [r1, #16]
   1533c:	4293      	cmp	r3, r2
   1533e:	d31c      	bcc.n	1537a <m_tb_timer_set+0x76>
    {
        if ((p_timer_a->nb_wrap != p_timer_b->nb_wrap) ||
   15340:	d11f      	bne.n	15382 <m_tb_timer_set+0x7e>
   15342:	68e2      	ldr	r2, [r4, #12]
   15344:	68ce      	ldr	r6, [r1, #12]
   15346:	42b2      	cmp	r2, r6
   15348:	d81b      	bhi.n	15382 <m_tb_timer_set+0x7e>
   1534a:	e016      	b.n	1537a <m_tb_timer_set+0x76>
    }
    else
    {
    	//M_PRINTF(L_TB, "-p_list_timer");
        // Insert the timer in front of the list
        co_list_push_front(&p_m_tb_timer_env->list_timer, &p_timer->hdr);
   1534c:	0021      	movs	r1, r4
   1534e:	f7ef f843 	bl	43d8 <co_list_push_front>
   15352:	682b      	ldr	r3, [r5, #0]
    }

    // If timer has been inserted in front of the list, program it
    if (M_TB_TIMER_IS_NEXT(p_timer))
   15354:	681b      	ldr	r3, [r3, #0]
   15356:	429c      	cmp	r4, r3
   15358:	d101      	bne.n	1535e <m_tb_timer_set+0x5a>
    {
        m_tb_timer_prog();
   1535a:	f7ff ff9b 	bl	15294 <m_tb_timer_prog>
}

__INLINE_S__ void GLOBAL_INT_RESTORE(void)
{
	__asm volatile ("cpsie i" : : : "memory");
   1535e:	b662      	cpsie	i
   15360:	682b      	ldr	r3, [r5, #0]
   15362:	681b      	ldr	r3, [r3, #0]
        // Insert in sorted timer list
        GLOBAL_INT_DISABLE();
        m_tb_timer_insert(p_timer);
		GLOBAL_INT_RESTORE();
		p_list_timer = M_TB_TIMER_GET_FIRST();
		while (p_list_timer){
   15364:	2b00      	cmp	r3, #0
   15366:	d013      	beq.n	15390 <m_tb_timer_set+0x8c>
	    	//M_PRINTF(L_TB, "A = %p hdr = %p next = %p", p_list_timer, p_list_timer->hdr
			//									,  p_list_timer->hdr.next);
	        // Get next timer
	        p_list_timer = (m_tb_timer_t *)p_list_timer->hdr.next;
   15368:	681b      	ldr	r3, [r3, #0]
   1536a:	e7fb      	b.n	15364 <m_tb_timer_set+0x60>
   		}
    }
    else
    {
        // Sanity check
        ASSERT_ERR(p_timer->cb);
   1536c:	6863      	ldr	r3, [r4, #4]
   1536e:	2b00      	cmp	r3, #0
   15370:	d100      	bne.n	15374 <m_tb_timer_set+0x70>
   15372:	e7fe      	b.n	15372 <m_tb_timer_set+0x6e>

        // Timer cannot be program, call the indicated callback
        p_timer->cb(p_timer->p_env);
   15374:	68a0      	ldr	r0, [r4, #8]
   15376:	4798      	blx	r3
    }
	//M_PRINTF(L_TB, "-------------set ok--------------");
}
   15378:	e00a      	b.n	15390 <m_tb_timer_set+0x8c>
            if (m_tb_timer_is_a_before_b(p_timer, p_list_timer))
            {
                // Insert the timer
                //M_PRINTF(L_TB, "a bdfore b %p %p %p %p", p_list_timer->hdr, p_list_timer->hdr.next
                //						, p_list_timer->hdr, p_list_timer->hdr.next);
                co_list_insert_before(&p_m_tb_timer_env->list_timer,
   1537a:	0022      	movs	r2, r4
   1537c:	f7ef f8a7 	bl	44ce <co_list_insert_before>
   15380:	e7e7      	b.n	15352 <m_tb_timer_set+0x4e>
                                      &p_list_timer->hdr, &p_timer->hdr);
                break;
            }

            // Get next timer
            p_list_timer = (m_tb_timer_t *)p_list_timer->hdr.next;
   15382:	6809      	ldr	r1, [r1, #0]
    // Get first timer in the list of timers
    m_tb_timer_t *p_list_timer = M_TB_TIMER_GET_FIRST();

    if (p_list_timer)
    {
        while (p_list_timer)
   15384:	2900      	cmp	r1, #0
   15386:	d1d8      	bne.n	1533a <m_tb_timer_set+0x36>

        if (!p_list_timer)
        {
        	//M_PRINTF(L_TB, "p_list_timer == NULL");
            // Insert the timer at end of the list
            co_list_push_back(&p_m_tb_timer_env->list_timer, &p_timer->hdr);
   15388:	0021      	movs	r1, r4
   1538a:	f7ef f804 	bl	4396 <co_list_push_back>
   1538e:	e7e0      	b.n	15352 <m_tb_timer_set+0x4e>

        // Timer cannot be program, call the indicated callback
        p_timer->cb(p_timer->p_env);
    }
	//M_PRINTF(L_TB, "-------------set ok--------------");
}
   15390:	bd70      	pop	{r4, r5, r6, pc}
   15392:	46c0      	nop			; (mov r8, r8)
   15394:	100126d4 	.word	0x100126d4

00015398 <m_tb_timer_clear>:

void m_tb_timer_clear(m_tb_timer_t *p_timer)
{
   15398:	b510      	push	{r4, lr}
	//M_PRINTF(L_TB, "--p_timer[%p]", p_timer);
    // Remove the timer from the list of timers
    m_tb_timer_remove(p_timer);
   1539a:	f7ff ff91 	bl	152c0 <m_tb_timer_remove>
}
   1539e:	bd10      	pop	{r4, pc}

000153a0 <m_tb_timer_expired>:

void m_tb_timer_expired(void)
{
   153a0:	b530      	push	{r4, r5, lr}
   153a2:	b085      	sub	sp, #20
    // List of timer that have expired or are about to expire
    co_list_t list_exp_timer;

    // Initialize list of expired timers
    co_list_init(&list_exp_timer);
   153a4:	a802      	add	r0, sp, #8
   153a6:	f7ee ffbb 	bl	4320 <co_list_init>

    // Remove all timers considered as expired
    while (true)
    {
        // Get next timer for which expiration was expected
        m_tb_timer_t *p_timer = M_TB_TIMER_GET_FIRST();
   153aa:	4d12      	ldr	r5, [pc, #72]	; (153f4 <m_tb_timer_expired+0x54>)
   153ac:	682b      	ldr	r3, [r5, #0]
   153ae:	681c      	ldr	r4, [r3, #0]
        // Delay value in milliseconds
        uint32_t delay_ms;

        // Check if timer can be considered as expired
        if (!p_timer)
   153b0:	2c00      	cmp	r4, #0
   153b2:	d00f      	beq.n	153d4 <m_tb_timer_expired+0x34>
        {
            break;
        }
		//M_PRINTF(L_TB, "p_timer=%p", p_timer);
        if (m_al_timer_get_delay(p_timer->time_ms, p_timer->nb_wrap, &delay_ms) != M_ERR_TIME_PAST)
   153b4:	8a21      	ldrh	r1, [r4, #16]
   153b6:	aa01      	add	r2, sp, #4
   153b8:	68e0      	ldr	r0, [r4, #12]
   153ba:	f7f0 f953 	bl	5664 <m_al_timer_get_delay>
   153be:	4b0e      	ldr	r3, [pc, #56]	; (153f8 <m_tb_timer_expired+0x58>)
   153c0:	4298      	cmp	r0, r3
   153c2:	d107      	bne.n	153d4 <m_tb_timer_expired+0x34>
        {
            break;
        }

        // Remove the timer from the list of timers
        co_list_pop_front(&p_m_tb_timer_env->list_timer);
   153c4:	6828      	ldr	r0, [r5, #0]
   153c6:	f7ef f811 	bl	43ec <co_list_pop_front>

        // Add it in the list of expired timers
        co_list_push_back(&list_exp_timer, &p_timer->hdr);
   153ca:	0021      	movs	r1, r4
   153cc:	a802      	add	r0, sp, #8
   153ce:	f7ee ffe2 	bl	4396 <co_list_push_back>
    }
   153d2:	e7ea      	b.n	153aa <m_tb_timer_expired+0xa>

    // Program next timer
    m_tb_timer_prog();
   153d4:	f7ff ff5e 	bl	15294 <m_tb_timer_prog>

    // Process expired timers
    while (true)
    {
        // Remove first timer in the list of expired timers
        m_tb_timer_t *p_timer = (m_tb_timer_t *)co_list_pop_front(&list_exp_timer);
   153d8:	a802      	add	r0, sp, #8
   153da:	f7ef f807 	bl	43ec <co_list_pop_front>

        // Check if all timers have been processed
        if (!p_timer)
   153de:	2800      	cmp	r0, #0
   153e0:	d006      	beq.n	153f0 <m_tb_timer_expired+0x50>
        {
            break;
        }

        // Sanity check
        ASSERT_ERR(p_timer->cb);
   153e2:	6843      	ldr	r3, [r0, #4]
   153e4:	2b00      	cmp	r3, #0
   153e6:	d100      	bne.n	153ea <m_tb_timer_expired+0x4a>
   153e8:	e7fe      	b.n	153e8 <m_tb_timer_expired+0x48>

        // Call the indicated callback
        p_timer->cb(p_timer->p_env);
   153ea:	6880      	ldr	r0, [r0, #8]
   153ec:	4798      	blx	r3
    }
   153ee:	e7f3      	b.n	153d8 <m_tb_timer_expired+0x38>
}
   153f0:	b005      	add	sp, #20
   153f2:	bd30      	pop	{r4, r5, pc}
   153f4:	100126d4 	.word	0x100126d4
   153f8:	00000582 	.word	0x00000582

000153fc <m_tb_timer_get_cur_time>:

void m_tb_timer_get_cur_time(uint32_t *p_time_ms, uint16_t *p_nb_wrap)
{
   153fc:	b510      	push	{r4, lr}
    m_al_timer_get_clock(p_time_ms, p_nb_wrap);
   153fe:	f7f0 f981 	bl	5704 <m_al_timer_get_clock>
}
   15402:	bd10      	pop	{r4, pc}

00015404 <malloc>:
   15404:	b510      	push	{r4, lr}
   15406:	4b03      	ldr	r3, [pc, #12]	; (15414 <malloc+0x10>)
   15408:	0001      	movs	r1, r0
   1540a:	6818      	ldr	r0, [r3, #0]
   1540c:	f000 f80e 	bl	1542c <_malloc_r>
   15410:	bd10      	pop	{r4, pc}
   15412:	46c0      	nop			; (mov r8, r8)
   15414:	10010df0 	.word	0x10010df0

00015418 <free>:
   15418:	b510      	push	{r4, lr}
   1541a:	4b03      	ldr	r3, [pc, #12]	; (15428 <free+0x10>)
   1541c:	0001      	movs	r1, r0
   1541e:	6818      	ldr	r0, [r3, #0]
   15420:	f003 fbc4 	bl	18bac <_free_r>
   15424:	bd10      	pop	{r4, pc}
   15426:	46c0      	nop			; (mov r8, r8)
   15428:	10010df0 	.word	0x10010df0

0001542c <_malloc_r>:
   1542c:	b5f0      	push	{r4, r5, r6, r7, lr}
   1542e:	465f      	mov	r7, fp
   15430:	464d      	mov	r5, r9
   15432:	4656      	mov	r6, sl
   15434:	4644      	mov	r4, r8
   15436:	b4f0      	push	{r4, r5, r6, r7}
   15438:	000d      	movs	r5, r1
   1543a:	350b      	adds	r5, #11
   1543c:	b083      	sub	sp, #12
   1543e:	0007      	movs	r7, r0
   15440:	2d16      	cmp	r5, #22
   15442:	d800      	bhi.n	15446 <_malloc_r+0x1a>
   15444:	e0a8      	b.n	15598 <_malloc_r+0x16c>
   15446:	2307      	movs	r3, #7
   15448:	439d      	bics	r5, r3
   1544a:	d500      	bpl.n	1544e <_malloc_r+0x22>
   1544c:	e0ce      	b.n	155ec <_malloc_r+0x1c0>
   1544e:	42a9      	cmp	r1, r5
   15450:	d900      	bls.n	15454 <_malloc_r+0x28>
   15452:	e0cb      	b.n	155ec <_malloc_r+0x1c0>
   15454:	f000 fb40 	bl	15ad8 <__malloc_lock>
   15458:	23f8      	movs	r3, #248	; 0xf8
   1545a:	33ff      	adds	r3, #255	; 0xff
   1545c:	429d      	cmp	r5, r3
   1545e:	d800      	bhi.n	15462 <_malloc_r+0x36>
   15460:	e284      	b.n	1596c <_malloc_r+0x540>
   15462:	0a6b      	lsrs	r3, r5, #9
   15464:	d100      	bne.n	15468 <_malloc_r+0x3c>
   15466:	e0c5      	b.n	155f4 <_malloc_r+0x1c8>
   15468:	2b04      	cmp	r3, #4
   1546a:	d900      	bls.n	1546e <_malloc_r+0x42>
   1546c:	e16c      	b.n	15748 <_malloc_r+0x31c>
   1546e:	2338      	movs	r3, #56	; 0x38
   15470:	09a9      	lsrs	r1, r5, #6
   15472:	469c      	mov	ip, r3
   15474:	3301      	adds	r3, #1
   15476:	4698      	mov	r8, r3
   15478:	4488      	add	r8, r1
   1547a:	4643      	mov	r3, r8
   1547c:	448c      	add	ip, r1
   1547e:	0059      	lsls	r1, r3, #1
   15480:	4ec9      	ldr	r6, [pc, #804]	; (157a8 <_malloc_r+0x37c>)
   15482:	0089      	lsls	r1, r1, #2
   15484:	1871      	adds	r1, r6, r1
   15486:	3908      	subs	r1, #8
   15488:	68cc      	ldr	r4, [r1, #12]
   1548a:	42a1      	cmp	r1, r4
   1548c:	d017      	beq.n	154be <_malloc_r+0x92>
   1548e:	2303      	movs	r3, #3
   15490:	6862      	ldr	r2, [r4, #4]
   15492:	439a      	bics	r2, r3
   15494:	0013      	movs	r3, r2
   15496:	1b52      	subs	r2, r2, r5
   15498:	2a0f      	cmp	r2, #15
   1549a:	dd00      	ble.n	1549e <_malloc_r+0x72>
   1549c:	e0b0      	b.n	15600 <_malloc_r+0x1d4>
   1549e:	2003      	movs	r0, #3
   154a0:	2a00      	cmp	r2, #0
   154a2:	db09      	blt.n	154b8 <_malloc_r+0x8c>
   154a4:	e08d      	b.n	155c2 <_malloc_r+0x196>
   154a6:	6863      	ldr	r3, [r4, #4]
   154a8:	4383      	bics	r3, r0
   154aa:	1b5a      	subs	r2, r3, r5
   154ac:	2a0f      	cmp	r2, #15
   154ae:	dd00      	ble.n	154b2 <_malloc_r+0x86>
   154b0:	e0a6      	b.n	15600 <_malloc_r+0x1d4>
   154b2:	2a00      	cmp	r2, #0
   154b4:	db00      	blt.n	154b8 <_malloc_r+0x8c>
   154b6:	e084      	b.n	155c2 <_malloc_r+0x196>
   154b8:	68e4      	ldr	r4, [r4, #12]
   154ba:	42a1      	cmp	r1, r4
   154bc:	d1f3      	bne.n	154a6 <_malloc_r+0x7a>
   154be:	4643      	mov	r3, r8
   154c0:	9300      	str	r3, [sp, #0]
   154c2:	0032      	movs	r2, r6
   154c4:	6934      	ldr	r4, [r6, #16]
   154c6:	3208      	adds	r2, #8
   154c8:	4294      	cmp	r4, r2
   154ca:	d100      	bne.n	154ce <_malloc_r+0xa2>
   154cc:	e18f      	b.n	157ee <_malloc_r+0x3c2>
   154ce:	2303      	movs	r3, #3
   154d0:	6861      	ldr	r1, [r4, #4]
   154d2:	4399      	bics	r1, r3
   154d4:	000b      	movs	r3, r1
   154d6:	1b48      	subs	r0, r1, r5
   154d8:	280f      	cmp	r0, #15
   154da:	dd00      	ble.n	154de <_malloc_r+0xb2>
   154dc:	e176      	b.n	157cc <_malloc_r+0x3a0>
   154de:	6172      	str	r2, [r6, #20]
   154e0:	6132      	str	r2, [r6, #16]
   154e2:	2800      	cmp	r0, #0
   154e4:	da71      	bge.n	155ca <_malloc_r+0x19e>
   154e6:	4ab1      	ldr	r2, [pc, #708]	; (157ac <_malloc_r+0x380>)
   154e8:	4291      	cmp	r1, r2
   154ea:	d900      	bls.n	154ee <_malloc_r+0xc2>
   154ec:	e134      	b.n	15758 <_malloc_r+0x32c>
   154ee:	2301      	movs	r3, #1
   154f0:	08c8      	lsrs	r0, r1, #3
   154f2:	1082      	asrs	r2, r0, #2
   154f4:	4093      	lsls	r3, r2
   154f6:	6872      	ldr	r2, [r6, #4]
   154f8:	431a      	orrs	r2, r3
   154fa:	00c3      	lsls	r3, r0, #3
   154fc:	199b      	adds	r3, r3, r6
   154fe:	6898      	ldr	r0, [r3, #8]
   15500:	6072      	str	r2, [r6, #4]
   15502:	60e3      	str	r3, [r4, #12]
   15504:	60a0      	str	r0, [r4, #8]
   15506:	609c      	str	r4, [r3, #8]
   15508:	0013      	movs	r3, r2
   1550a:	60c4      	str	r4, [r0, #12]
   1550c:	2001      	movs	r0, #1
   1550e:	9900      	ldr	r1, [sp, #0]
   15510:	108a      	asrs	r2, r1, #2
   15512:	4090      	lsls	r0, r2
   15514:	4298      	cmp	r0, r3
   15516:	d900      	bls.n	1551a <_malloc_r+0xee>
   15518:	e075      	b.n	15606 <_malloc_r+0x1da>
   1551a:	4203      	tst	r3, r0
   1551c:	d10c      	bne.n	15538 <_malloc_r+0x10c>
   1551e:	2203      	movs	r2, #3
   15520:	4391      	bics	r1, r2
   15522:	1d0a      	adds	r2, r1, #4
   15524:	0040      	lsls	r0, r0, #1
   15526:	9200      	str	r2, [sp, #0]
   15528:	4203      	tst	r3, r0
   1552a:	d105      	bne.n	15538 <_malloc_r+0x10c>
   1552c:	9a00      	ldr	r2, [sp, #0]
   1552e:	0040      	lsls	r0, r0, #1
   15530:	3204      	adds	r2, #4
   15532:	9200      	str	r2, [sp, #0]
   15534:	4203      	tst	r3, r0
   15536:	d0f9      	beq.n	1552c <_malloc_r+0x100>
   15538:	2303      	movs	r3, #3
   1553a:	4698      	mov	r8, r3
   1553c:	9a00      	ldr	r2, [sp, #0]
   1553e:	00d3      	lsls	r3, r2, #3
   15540:	4699      	mov	r9, r3
   15542:	44b1      	add	r9, r6
   15544:	46cc      	mov	ip, r9
   15546:	4692      	mov	sl, r2
   15548:	4663      	mov	r3, ip
   1554a:	68dc      	ldr	r4, [r3, #12]
   1554c:	45a4      	cmp	ip, r4
   1554e:	d107      	bne.n	15560 <_malloc_r+0x134>
   15550:	e14f      	b.n	157f2 <_malloc_r+0x3c6>
   15552:	2a00      	cmp	r2, #0
   15554:	db00      	blt.n	15558 <_malloc_r+0x12c>
   15556:	e15f      	b.n	15818 <_malloc_r+0x3ec>
   15558:	68e4      	ldr	r4, [r4, #12]
   1555a:	45a4      	cmp	ip, r4
   1555c:	d100      	bne.n	15560 <_malloc_r+0x134>
   1555e:	e148      	b.n	157f2 <_malloc_r+0x3c6>
   15560:	4642      	mov	r2, r8
   15562:	6863      	ldr	r3, [r4, #4]
   15564:	4393      	bics	r3, r2
   15566:	1b5a      	subs	r2, r3, r5
   15568:	2a0f      	cmp	r2, #15
   1556a:	ddf2      	ble.n	15552 <_malloc_r+0x126>
   1556c:	2101      	movs	r1, #1
   1556e:	1963      	adds	r3, r4, r5
   15570:	430d      	orrs	r5, r1
   15572:	6065      	str	r5, [r4, #4]
   15574:	68e0      	ldr	r0, [r4, #12]
   15576:	68a5      	ldr	r5, [r4, #8]
   15578:	3608      	adds	r6, #8
   1557a:	60e8      	str	r0, [r5, #12]
   1557c:	4311      	orrs	r1, r2
   1557e:	6085      	str	r5, [r0, #8]
   15580:	60f3      	str	r3, [r6, #12]
   15582:	60b3      	str	r3, [r6, #8]
   15584:	0038      	movs	r0, r7
   15586:	60de      	str	r6, [r3, #12]
   15588:	609e      	str	r6, [r3, #8]
   1558a:	6059      	str	r1, [r3, #4]
   1558c:	509a      	str	r2, [r3, r2]
   1558e:	f000 faa5 	bl	15adc <__malloc_unlock>
   15592:	0020      	movs	r0, r4
   15594:	3008      	adds	r0, #8
   15596:	e022      	b.n	155de <_malloc_r+0x1b2>
   15598:	2910      	cmp	r1, #16
   1559a:	d827      	bhi.n	155ec <_malloc_r+0x1c0>
   1559c:	0038      	movs	r0, r7
   1559e:	f000 fa9b 	bl	15ad8 <__malloc_lock>
   155a2:	2510      	movs	r5, #16
   155a4:	2306      	movs	r3, #6
   155a6:	2102      	movs	r1, #2
   155a8:	4e7f      	ldr	r6, [pc, #508]	; (157a8 <_malloc_r+0x37c>)
   155aa:	009b      	lsls	r3, r3, #2
   155ac:	18f3      	adds	r3, r6, r3
   155ae:	001a      	movs	r2, r3
   155b0:	685c      	ldr	r4, [r3, #4]
   155b2:	3a08      	subs	r2, #8
   155b4:	4294      	cmp	r4, r2
   155b6:	d100      	bne.n	155ba <_malloc_r+0x18e>
   155b8:	e127      	b.n	1580a <_malloc_r+0x3de>
   155ba:	2303      	movs	r3, #3
   155bc:	6862      	ldr	r2, [r4, #4]
   155be:	439a      	bics	r2, r3
   155c0:	0013      	movs	r3, r2
   155c2:	68e2      	ldr	r2, [r4, #12]
   155c4:	68a1      	ldr	r1, [r4, #8]
   155c6:	60ca      	str	r2, [r1, #12]
   155c8:	6091      	str	r1, [r2, #8]
   155ca:	2201      	movs	r2, #1
   155cc:	18e3      	adds	r3, r4, r3
   155ce:	6859      	ldr	r1, [r3, #4]
   155d0:	0038      	movs	r0, r7
   155d2:	430a      	orrs	r2, r1
   155d4:	605a      	str	r2, [r3, #4]
   155d6:	f000 fa81 	bl	15adc <__malloc_unlock>
   155da:	0020      	movs	r0, r4
   155dc:	3008      	adds	r0, #8
   155de:	b003      	add	sp, #12
   155e0:	bc3c      	pop	{r2, r3, r4, r5}
   155e2:	4690      	mov	r8, r2
   155e4:	4699      	mov	r9, r3
   155e6:	46a2      	mov	sl, r4
   155e8:	46ab      	mov	fp, r5
   155ea:	bdf0      	pop	{r4, r5, r6, r7, pc}
   155ec:	230c      	movs	r3, #12
   155ee:	2000      	movs	r0, #0
   155f0:	603b      	str	r3, [r7, #0]
   155f2:	e7f4      	b.n	155de <_malloc_r+0x1b2>
   155f4:	2340      	movs	r3, #64	; 0x40
   155f6:	4698      	mov	r8, r3
   155f8:	3b01      	subs	r3, #1
   155fa:	2180      	movs	r1, #128	; 0x80
   155fc:	469c      	mov	ip, r3
   155fe:	e73f      	b.n	15480 <_malloc_r+0x54>
   15600:	4663      	mov	r3, ip
   15602:	9300      	str	r3, [sp, #0]
   15604:	e75d      	b.n	154c2 <_malloc_r+0x96>
   15606:	2303      	movs	r3, #3
   15608:	68b4      	ldr	r4, [r6, #8]
   1560a:	6862      	ldr	r2, [r4, #4]
   1560c:	439a      	bics	r2, r3
   1560e:	4690      	mov	r8, r2
   15610:	42aa      	cmp	r2, r5
   15612:	d303      	bcc.n	1561c <_malloc_r+0x1f0>
   15614:	1b52      	subs	r2, r2, r5
   15616:	2a0f      	cmp	r2, #15
   15618:	dd00      	ble.n	1561c <_malloc_r+0x1f0>
   1561a:	e087      	b.n	1572c <_malloc_r+0x300>
   1561c:	0023      	movs	r3, r4
   1561e:	4443      	add	r3, r8
   15620:	4a63      	ldr	r2, [pc, #396]	; (157b0 <_malloc_r+0x384>)
   15622:	9301      	str	r3, [sp, #4]
   15624:	4b63      	ldr	r3, [pc, #396]	; (157b4 <_malloc_r+0x388>)
   15626:	4693      	mov	fp, r2
   15628:	681b      	ldr	r3, [r3, #0]
   1562a:	6812      	ldr	r2, [r2, #0]
   1562c:	18eb      	adds	r3, r5, r3
   1562e:	3201      	adds	r2, #1
   15630:	d100      	bne.n	15634 <_malloc_r+0x208>
   15632:	e157      	b.n	158e4 <_malloc_r+0x4b8>
   15634:	4a60      	ldr	r2, [pc, #384]	; (157b8 <_malloc_r+0x38c>)
   15636:	4694      	mov	ip, r2
   15638:	4463      	add	r3, ip
   1563a:	0b1b      	lsrs	r3, r3, #12
   1563c:	031b      	lsls	r3, r3, #12
   1563e:	9300      	str	r3, [sp, #0]
   15640:	9900      	ldr	r1, [sp, #0]
   15642:	0038      	movs	r0, r7
   15644:	f000 fad2 	bl	15bec <_sbrk_r>
   15648:	0003      	movs	r3, r0
   1564a:	4681      	mov	r9, r0
   1564c:	3301      	adds	r3, #1
   1564e:	d061      	beq.n	15714 <_malloc_r+0x2e8>
   15650:	9b01      	ldr	r3, [sp, #4]
   15652:	4283      	cmp	r3, r0
   15654:	d900      	bls.n	15658 <_malloc_r+0x22c>
   15656:	e0fd      	b.n	15854 <_malloc_r+0x428>
   15658:	4b58      	ldr	r3, [pc, #352]	; (157bc <_malloc_r+0x390>)
   1565a:	9a00      	ldr	r2, [sp, #0]
   1565c:	469a      	mov	sl, r3
   1565e:	681b      	ldr	r3, [r3, #0]
   15660:	469c      	mov	ip, r3
   15662:	4653      	mov	r3, sl
   15664:	4462      	add	r2, ip
   15666:	601a      	str	r2, [r3, #0]
   15668:	9b01      	ldr	r3, [sp, #4]
   1566a:	0011      	movs	r1, r2
   1566c:	454b      	cmp	r3, r9
   1566e:	d100      	bne.n	15672 <_malloc_r+0x246>
   15670:	e143      	b.n	158fa <_malloc_r+0x4ce>
   15672:	465b      	mov	r3, fp
   15674:	681b      	ldr	r3, [r3, #0]
   15676:	3301      	adds	r3, #1
   15678:	d100      	bne.n	1567c <_malloc_r+0x250>
   1567a:	e14f      	b.n	1591c <_malloc_r+0x4f0>
   1567c:	464b      	mov	r3, r9
   1567e:	9a01      	ldr	r2, [sp, #4]
   15680:	1a9b      	subs	r3, r3, r2
   15682:	1859      	adds	r1, r3, r1
   15684:	4653      	mov	r3, sl
   15686:	6019      	str	r1, [r3, #0]
   15688:	2307      	movs	r3, #7
   1568a:	464a      	mov	r2, r9
   1568c:	4013      	ands	r3, r2
   1568e:	d100      	bne.n	15692 <_malloc_r+0x266>
   15690:	e117      	b.n	158c2 <_malloc_r+0x496>
   15692:	2108      	movs	r1, #8
   15694:	4689      	mov	r9, r1
   15696:	494a      	ldr	r1, [pc, #296]	; (157c0 <_malloc_r+0x394>)
   15698:	1ad2      	subs	r2, r2, r3
   1569a:	4491      	add	r9, r2
   1569c:	1ac9      	subs	r1, r1, r3
   1569e:	9b00      	ldr	r3, [sp, #0]
   156a0:	0038      	movs	r0, r7
   156a2:	444b      	add	r3, r9
   156a4:	051b      	lsls	r3, r3, #20
   156a6:	0d1b      	lsrs	r3, r3, #20
   156a8:	1acb      	subs	r3, r1, r3
   156aa:	0019      	movs	r1, r3
   156ac:	469b      	mov	fp, r3
   156ae:	f000 fa9d 	bl	15bec <_sbrk_r>
   156b2:	1c43      	adds	r3, r0, #1
   156b4:	d100      	bne.n	156b8 <_malloc_r+0x28c>
   156b6:	e135      	b.n	15924 <_malloc_r+0x4f8>
   156b8:	464b      	mov	r3, r9
   156ba:	1ac0      	subs	r0, r0, r3
   156bc:	2301      	movs	r3, #1
   156be:	4458      	add	r0, fp
   156c0:	4318      	orrs	r0, r3
   156c2:	4653      	mov	r3, sl
   156c4:	681b      	ldr	r3, [r3, #0]
   156c6:	445b      	add	r3, fp
   156c8:	0019      	movs	r1, r3
   156ca:	4653      	mov	r3, sl
   156cc:	6019      	str	r1, [r3, #0]
   156ce:	464b      	mov	r3, r9
   156d0:	60b3      	str	r3, [r6, #8]
   156d2:	6058      	str	r0, [r3, #4]
   156d4:	42b4      	cmp	r4, r6
   156d6:	d013      	beq.n	15700 <_malloc_r+0x2d4>
   156d8:	4643      	mov	r3, r8
   156da:	2b0f      	cmp	r3, #15
   156dc:	d800      	bhi.n	156e0 <_malloc_r+0x2b4>
   156de:	e0e1      	b.n	158a4 <_malloc_r+0x478>
   156e0:	4643      	mov	r3, r8
   156e2:	2207      	movs	r2, #7
   156e4:	6860      	ldr	r0, [r4, #4]
   156e6:	3b0c      	subs	r3, #12
   156e8:	4393      	bics	r3, r2
   156ea:	3a06      	subs	r2, #6
   156ec:	4002      	ands	r2, r0
   156ee:	2005      	movs	r0, #5
   156f0:	431a      	orrs	r2, r3
   156f2:	6062      	str	r2, [r4, #4]
   156f4:	18e2      	adds	r2, r4, r3
   156f6:	6050      	str	r0, [r2, #4]
   156f8:	6090      	str	r0, [r2, #8]
   156fa:	2b0f      	cmp	r3, #15
   156fc:	d900      	bls.n	15700 <_malloc_r+0x2d4>
   156fe:	e115      	b.n	1592c <_malloc_r+0x500>
   15700:	4b30      	ldr	r3, [pc, #192]	; (157c4 <_malloc_r+0x398>)
   15702:	681a      	ldr	r2, [r3, #0]
   15704:	4291      	cmp	r1, r2
   15706:	d900      	bls.n	1570a <_malloc_r+0x2de>
   15708:	6019      	str	r1, [r3, #0]
   1570a:	4b2f      	ldr	r3, [pc, #188]	; (157c8 <_malloc_r+0x39c>)
   1570c:	681a      	ldr	r2, [r3, #0]
   1570e:	4291      	cmp	r1, r2
   15710:	d900      	bls.n	15714 <_malloc_r+0x2e8>
   15712:	6019      	str	r1, [r3, #0]
   15714:	2303      	movs	r3, #3
   15716:	68b4      	ldr	r4, [r6, #8]
   15718:	6862      	ldr	r2, [r4, #4]
   1571a:	439a      	bics	r2, r3
   1571c:	0013      	movs	r3, r2
   1571e:	1b52      	subs	r2, r2, r5
   15720:	429d      	cmp	r5, r3
   15722:	d900      	bls.n	15726 <_malloc_r+0x2fa>
   15724:	e0c1      	b.n	158aa <_malloc_r+0x47e>
   15726:	2a0f      	cmp	r2, #15
   15728:	dc00      	bgt.n	1572c <_malloc_r+0x300>
   1572a:	e0be      	b.n	158aa <_malloc_r+0x47e>
   1572c:	2301      	movs	r3, #1
   1572e:	0029      	movs	r1, r5
   15730:	1965      	adds	r5, r4, r5
   15732:	4319      	orrs	r1, r3
   15734:	4313      	orrs	r3, r2
   15736:	6061      	str	r1, [r4, #4]
   15738:	0038      	movs	r0, r7
   1573a:	60b5      	str	r5, [r6, #8]
   1573c:	606b      	str	r3, [r5, #4]
   1573e:	f000 f9cd 	bl	15adc <__malloc_unlock>
   15742:	0020      	movs	r0, r4
   15744:	3008      	adds	r0, #8
   15746:	e74a      	b.n	155de <_malloc_r+0x1b2>
   15748:	2b14      	cmp	r3, #20
   1574a:	d974      	bls.n	15836 <_malloc_r+0x40a>
   1574c:	2b54      	cmp	r3, #84	; 0x54
   1574e:	d900      	bls.n	15752 <_malloc_r+0x326>
   15750:	e0b0      	b.n	158b4 <_malloc_r+0x488>
   15752:	0b29      	lsrs	r1, r5, #12
   15754:	236e      	movs	r3, #110	; 0x6e
   15756:	e68c      	b.n	15472 <_malloc_r+0x46>
   15758:	0a4a      	lsrs	r2, r1, #9
   1575a:	2a04      	cmp	r2, #4
   1575c:	d974      	bls.n	15848 <_malloc_r+0x41c>
   1575e:	2a14      	cmp	r2, #20
   15760:	d900      	bls.n	15764 <_malloc_r+0x338>
   15762:	e0c2      	b.n	158ea <_malloc_r+0x4be>
   15764:	0010      	movs	r0, r2
   15766:	325c      	adds	r2, #92	; 0x5c
   15768:	305b      	adds	r0, #91	; 0x5b
   1576a:	0052      	lsls	r2, r2, #1
   1576c:	2108      	movs	r1, #8
   1576e:	4249      	negs	r1, r1
   15770:	468c      	mov	ip, r1
   15772:	0092      	lsls	r2, r2, #2
   15774:	18b2      	adds	r2, r6, r2
   15776:	4494      	add	ip, r2
   15778:	4662      	mov	r2, ip
   1577a:	6892      	ldr	r2, [r2, #8]
   1577c:	310b      	adds	r1, #11
   1577e:	4688      	mov	r8, r1
   15780:	4594      	cmp	ip, r2
   15782:	d100      	bne.n	15786 <_malloc_r+0x35a>
   15784:	e0a0      	b.n	158c8 <_malloc_r+0x49c>
   15786:	4641      	mov	r1, r8
   15788:	6850      	ldr	r0, [r2, #4]
   1578a:	4388      	bics	r0, r1
   1578c:	4283      	cmp	r3, r0
   1578e:	d202      	bcs.n	15796 <_malloc_r+0x36a>
   15790:	6892      	ldr	r2, [r2, #8]
   15792:	4594      	cmp	ip, r2
   15794:	d1f7      	bne.n	15786 <_malloc_r+0x35a>
   15796:	68d3      	ldr	r3, [r2, #12]
   15798:	469c      	mov	ip, r3
   1579a:	6873      	ldr	r3, [r6, #4]
   1579c:	4661      	mov	r1, ip
   1579e:	60a2      	str	r2, [r4, #8]
   157a0:	60e1      	str	r1, [r4, #12]
   157a2:	608c      	str	r4, [r1, #8]
   157a4:	60d4      	str	r4, [r2, #12]
   157a6:	e6b1      	b.n	1550c <_malloc_r+0xe0>
   157a8:	100105b8 	.word	0x100105b8
   157ac:	000001ff 	.word	0x000001ff
   157b0:	100109c4 	.word	0x100109c4
   157b4:	100126e0 	.word	0x100126e0
   157b8:	0000100f 	.word	0x0000100f
   157bc:	100126e4 	.word	0x100126e4
   157c0:	00001008 	.word	0x00001008
   157c4:	100126dc 	.word	0x100126dc
   157c8:	100126d8 	.word	0x100126d8
   157cc:	2101      	movs	r1, #1
   157ce:	1963      	adds	r3, r4, r5
   157d0:	430d      	orrs	r5, r1
   157d2:	4301      	orrs	r1, r0
   157d4:	6065      	str	r5, [r4, #4]
   157d6:	6173      	str	r3, [r6, #20]
   157d8:	6133      	str	r3, [r6, #16]
   157da:	60da      	str	r2, [r3, #12]
   157dc:	609a      	str	r2, [r3, #8]
   157de:	6059      	str	r1, [r3, #4]
   157e0:	5018      	str	r0, [r3, r0]
   157e2:	0038      	movs	r0, r7
   157e4:	f000 f97a 	bl	15adc <__malloc_unlock>
   157e8:	0020      	movs	r0, r4
   157ea:	3008      	adds	r0, #8
   157ec:	e6f7      	b.n	155de <_malloc_r+0x1b2>
   157ee:	6873      	ldr	r3, [r6, #4]
   157f0:	e68c      	b.n	1550c <_malloc_r+0xe0>
   157f2:	2308      	movs	r3, #8
   157f4:	469b      	mov	fp, r3
   157f6:	3b07      	subs	r3, #7
   157f8:	44dc      	add	ip, fp
   157fa:	469b      	mov	fp, r3
   157fc:	44da      	add	sl, fp
   157fe:	4643      	mov	r3, r8
   15800:	4652      	mov	r2, sl
   15802:	4213      	tst	r3, r2
   15804:	d000      	beq.n	15808 <_malloc_r+0x3dc>
   15806:	e69f      	b.n	15548 <_malloc_r+0x11c>
   15808:	e033      	b.n	15872 <_malloc_r+0x446>
   1580a:	68dc      	ldr	r4, [r3, #12]
   1580c:	1c8a      	adds	r2, r1, #2
   1580e:	9200      	str	r2, [sp, #0]
   15810:	42a3      	cmp	r3, r4
   15812:	d100      	bne.n	15816 <_malloc_r+0x3ea>
   15814:	e655      	b.n	154c2 <_malloc_r+0x96>
   15816:	e6d0      	b.n	155ba <_malloc_r+0x18e>
   15818:	2201      	movs	r2, #1
   1581a:	18e3      	adds	r3, r4, r3
   1581c:	6859      	ldr	r1, [r3, #4]
   1581e:	0038      	movs	r0, r7
   15820:	430a      	orrs	r2, r1
   15822:	605a      	str	r2, [r3, #4]
   15824:	68e3      	ldr	r3, [r4, #12]
   15826:	68a2      	ldr	r2, [r4, #8]
   15828:	60d3      	str	r3, [r2, #12]
   1582a:	609a      	str	r2, [r3, #8]
   1582c:	f000 f956 	bl	15adc <__malloc_unlock>
   15830:	0020      	movs	r0, r4
   15832:	3008      	adds	r0, #8
   15834:	e6d3      	b.n	155de <_malloc_r+0x1b2>
   15836:	225b      	movs	r2, #91	; 0x5b
   15838:	4694      	mov	ip, r2
   1583a:	3201      	adds	r2, #1
   1583c:	4690      	mov	r8, r2
   1583e:	4498      	add	r8, r3
   15840:	449c      	add	ip, r3
   15842:	4643      	mov	r3, r8
   15844:	0059      	lsls	r1, r3, #1
   15846:	e61b      	b.n	15480 <_malloc_r+0x54>
   15848:	098a      	lsrs	r2, r1, #6
   1584a:	0010      	movs	r0, r2
   1584c:	3239      	adds	r2, #57	; 0x39
   1584e:	3038      	adds	r0, #56	; 0x38
   15850:	0052      	lsls	r2, r2, #1
   15852:	e78b      	b.n	1576c <_malloc_r+0x340>
   15854:	42b4      	cmp	r4, r6
   15856:	d000      	beq.n	1585a <_malloc_r+0x42e>
   15858:	e75c      	b.n	15714 <_malloc_r+0x2e8>
   1585a:	e6fd      	b.n	15658 <_malloc_r+0x22c>
   1585c:	9b00      	ldr	r3, [sp, #0]
   1585e:	3b01      	subs	r3, #1
   15860:	9300      	str	r3, [sp, #0]
   15862:	2308      	movs	r3, #8
   15864:	425b      	negs	r3, r3
   15866:	469c      	mov	ip, r3
   15868:	44e1      	add	r9, ip
   1586a:	464b      	mov	r3, r9
   1586c:	689b      	ldr	r3, [r3, #8]
   1586e:	4599      	cmp	r9, r3
   15870:	d17a      	bne.n	15968 <_malloc_r+0x53c>
   15872:	4643      	mov	r3, r8
   15874:	9a00      	ldr	r2, [sp, #0]
   15876:	4213      	tst	r3, r2
   15878:	d1f0      	bne.n	1585c <_malloc_r+0x430>
   1587a:	6873      	ldr	r3, [r6, #4]
   1587c:	4383      	bics	r3, r0
   1587e:	6073      	str	r3, [r6, #4]
   15880:	0040      	lsls	r0, r0, #1
   15882:	4298      	cmp	r0, r3
   15884:	d900      	bls.n	15888 <_malloc_r+0x45c>
   15886:	e6be      	b.n	15606 <_malloc_r+0x1da>
   15888:	2800      	cmp	r0, #0
   1588a:	d100      	bne.n	1588e <_malloc_r+0x462>
   1588c:	e6bb      	b.n	15606 <_malloc_r+0x1da>
   1588e:	4203      	tst	r3, r0
   15890:	d170      	bne.n	15974 <_malloc_r+0x548>
   15892:	4652      	mov	r2, sl
   15894:	9200      	str	r2, [sp, #0]
   15896:	9a00      	ldr	r2, [sp, #0]
   15898:	0040      	lsls	r0, r0, #1
   1589a:	3204      	adds	r2, #4
   1589c:	9200      	str	r2, [sp, #0]
   1589e:	4203      	tst	r3, r0
   158a0:	d0f9      	beq.n	15896 <_malloc_r+0x46a>
   158a2:	e64b      	b.n	1553c <_malloc_r+0x110>
   158a4:	2301      	movs	r3, #1
   158a6:	464a      	mov	r2, r9
   158a8:	6053      	str	r3, [r2, #4]
   158aa:	0038      	movs	r0, r7
   158ac:	f000 f916 	bl	15adc <__malloc_unlock>
   158b0:	2000      	movs	r0, #0
   158b2:	e694      	b.n	155de <_malloc_r+0x1b2>
   158b4:	22aa      	movs	r2, #170	; 0xaa
   158b6:	0052      	lsls	r2, r2, #1
   158b8:	4293      	cmp	r3, r2
   158ba:	d80d      	bhi.n	158d8 <_malloc_r+0x4ac>
   158bc:	0be9      	lsrs	r1, r5, #15
   158be:	2377      	movs	r3, #119	; 0x77
   158c0:	e5d7      	b.n	15472 <_malloc_r+0x46>
   158c2:	2180      	movs	r1, #128	; 0x80
   158c4:	0149      	lsls	r1, r1, #5
   158c6:	e6ea      	b.n	1569e <_malloc_r+0x272>
   158c8:	2301      	movs	r3, #1
   158ca:	1080      	asrs	r0, r0, #2
   158cc:	4083      	lsls	r3, r0
   158ce:	6872      	ldr	r2, [r6, #4]
   158d0:	4313      	orrs	r3, r2
   158d2:	6073      	str	r3, [r6, #4]
   158d4:	4662      	mov	r2, ip
   158d6:	e761      	b.n	1579c <_malloc_r+0x370>
   158d8:	4a28      	ldr	r2, [pc, #160]	; (1597c <_malloc_r+0x550>)
   158da:	4293      	cmp	r3, r2
   158dc:	d818      	bhi.n	15910 <_malloc_r+0x4e4>
   158de:	0ca9      	lsrs	r1, r5, #18
   158e0:	237c      	movs	r3, #124	; 0x7c
   158e2:	e5c6      	b.n	15472 <_malloc_r+0x46>
   158e4:	3310      	adds	r3, #16
   158e6:	9300      	str	r3, [sp, #0]
   158e8:	e6aa      	b.n	15640 <_malloc_r+0x214>
   158ea:	2a54      	cmp	r2, #84	; 0x54
   158ec:	d826      	bhi.n	1593c <_malloc_r+0x510>
   158ee:	0b0a      	lsrs	r2, r1, #12
   158f0:	0010      	movs	r0, r2
   158f2:	326f      	adds	r2, #111	; 0x6f
   158f4:	306e      	adds	r0, #110	; 0x6e
   158f6:	0052      	lsls	r2, r2, #1
   158f8:	e738      	b.n	1576c <_malloc_r+0x340>
   158fa:	051b      	lsls	r3, r3, #20
   158fc:	d000      	beq.n	15900 <_malloc_r+0x4d4>
   158fe:	e6b8      	b.n	15672 <_malloc_r+0x246>
   15900:	9b00      	ldr	r3, [sp, #0]
   15902:	68b2      	ldr	r2, [r6, #8]
   15904:	4443      	add	r3, r8
   15906:	0018      	movs	r0, r3
   15908:	2301      	movs	r3, #1
   1590a:	4303      	orrs	r3, r0
   1590c:	6053      	str	r3, [r2, #4]
   1590e:	e6f7      	b.n	15700 <_malloc_r+0x2d4>
   15910:	237f      	movs	r3, #127	; 0x7f
   15912:	4698      	mov	r8, r3
   15914:	3b01      	subs	r3, #1
   15916:	21fe      	movs	r1, #254	; 0xfe
   15918:	469c      	mov	ip, r3
   1591a:	e5b1      	b.n	15480 <_malloc_r+0x54>
   1591c:	465b      	mov	r3, fp
   1591e:	464a      	mov	r2, r9
   15920:	601a      	str	r2, [r3, #0]
   15922:	e6b1      	b.n	15688 <_malloc_r+0x25c>
   15924:	2300      	movs	r3, #0
   15926:	2001      	movs	r0, #1
   15928:	469b      	mov	fp, r3
   1592a:	e6ca      	b.n	156c2 <_malloc_r+0x296>
   1592c:	0021      	movs	r1, r4
   1592e:	0038      	movs	r0, r7
   15930:	3108      	adds	r1, #8
   15932:	f003 f93b 	bl	18bac <_free_r>
   15936:	4653      	mov	r3, sl
   15938:	6819      	ldr	r1, [r3, #0]
   1593a:	e6e1      	b.n	15700 <_malloc_r+0x2d4>
   1593c:	20aa      	movs	r0, #170	; 0xaa
   1593e:	0040      	lsls	r0, r0, #1
   15940:	4282      	cmp	r2, r0
   15942:	d805      	bhi.n	15950 <_malloc_r+0x524>
   15944:	0bca      	lsrs	r2, r1, #15
   15946:	0010      	movs	r0, r2
   15948:	3278      	adds	r2, #120	; 0x78
   1594a:	3077      	adds	r0, #119	; 0x77
   1594c:	0052      	lsls	r2, r2, #1
   1594e:	e70d      	b.n	1576c <_malloc_r+0x340>
   15950:	480a      	ldr	r0, [pc, #40]	; (1597c <_malloc_r+0x550>)
   15952:	4282      	cmp	r2, r0
   15954:	d805      	bhi.n	15962 <_malloc_r+0x536>
   15956:	0c8a      	lsrs	r2, r1, #18
   15958:	0010      	movs	r0, r2
   1595a:	327d      	adds	r2, #125	; 0x7d
   1595c:	307c      	adds	r0, #124	; 0x7c
   1595e:	0052      	lsls	r2, r2, #1
   15960:	e704      	b.n	1576c <_malloc_r+0x340>
   15962:	22fe      	movs	r2, #254	; 0xfe
   15964:	207e      	movs	r0, #126	; 0x7e
   15966:	e701      	b.n	1576c <_malloc_r+0x340>
   15968:	6873      	ldr	r3, [r6, #4]
   1596a:	e789      	b.n	15880 <_malloc_r+0x454>
   1596c:	08e9      	lsrs	r1, r5, #3
   1596e:	1c4b      	adds	r3, r1, #1
   15970:	005b      	lsls	r3, r3, #1
   15972:	e619      	b.n	155a8 <_malloc_r+0x17c>
   15974:	4653      	mov	r3, sl
   15976:	9300      	str	r3, [sp, #0]
   15978:	e5e0      	b.n	1553c <_malloc_r+0x110>
   1597a:	46c0      	nop			; (mov r8, r8)
   1597c:	00000554 	.word	0x00000554

00015980 <memcmp>:
   15980:	b530      	push	{r4, r5, lr}
   15982:	2a03      	cmp	r2, #3
   15984:	d91e      	bls.n	159c4 <memcmp+0x44>
   15986:	0003      	movs	r3, r0
   15988:	430b      	orrs	r3, r1
   1598a:	079b      	lsls	r3, r3, #30
   1598c:	d011      	beq.n	159b2 <memcmp+0x32>
   1598e:	7804      	ldrb	r4, [r0, #0]
   15990:	780d      	ldrb	r5, [r1, #0]
   15992:	1c4b      	adds	r3, r1, #1
   15994:	188a      	adds	r2, r1, r2
   15996:	42ac      	cmp	r4, r5
   15998:	d006      	beq.n	159a8 <memcmp+0x28>
   1599a:	e016      	b.n	159ca <memcmp+0x4a>
   1599c:	3301      	adds	r3, #1
   1599e:	1e59      	subs	r1, r3, #1
   159a0:	7804      	ldrb	r4, [r0, #0]
   159a2:	780d      	ldrb	r5, [r1, #0]
   159a4:	42ac      	cmp	r4, r5
   159a6:	d110      	bne.n	159ca <memcmp+0x4a>
   159a8:	3001      	adds	r0, #1
   159aa:	4293      	cmp	r3, r2
   159ac:	d1f6      	bne.n	1599c <memcmp+0x1c>
   159ae:	2000      	movs	r0, #0
   159b0:	bd30      	pop	{r4, r5, pc}
   159b2:	6803      	ldr	r3, [r0, #0]
   159b4:	680c      	ldr	r4, [r1, #0]
   159b6:	42a3      	cmp	r3, r4
   159b8:	d1e9      	bne.n	1598e <memcmp+0xe>
   159ba:	3a04      	subs	r2, #4
   159bc:	3004      	adds	r0, #4
   159be:	3104      	adds	r1, #4
   159c0:	2a03      	cmp	r2, #3
   159c2:	d8f6      	bhi.n	159b2 <memcmp+0x32>
   159c4:	2a00      	cmp	r2, #0
   159c6:	d1e2      	bne.n	1598e <memcmp+0xe>
   159c8:	e7f1      	b.n	159ae <memcmp+0x2e>
   159ca:	1b60      	subs	r0, r4, r5
   159cc:	e7f0      	b.n	159b0 <memcmp+0x30>
   159ce:	46c0      	nop			; (mov r8, r8)

000159d0 <memcpy>:
   159d0:	b570      	push	{r4, r5, r6, lr}
   159d2:	2a0f      	cmp	r2, #15
   159d4:	d932      	bls.n	15a3c <memcpy+0x6c>
   159d6:	000c      	movs	r4, r1
   159d8:	4304      	orrs	r4, r0
   159da:	000b      	movs	r3, r1
   159dc:	07a4      	lsls	r4, r4, #30
   159de:	d131      	bne.n	15a44 <memcpy+0x74>
   159e0:	0015      	movs	r5, r2
   159e2:	0004      	movs	r4, r0
   159e4:	3d10      	subs	r5, #16
   159e6:	092d      	lsrs	r5, r5, #4
   159e8:	3501      	adds	r5, #1
   159ea:	012d      	lsls	r5, r5, #4
   159ec:	1949      	adds	r1, r1, r5
   159ee:	681e      	ldr	r6, [r3, #0]
   159f0:	6026      	str	r6, [r4, #0]
   159f2:	685e      	ldr	r6, [r3, #4]
   159f4:	6066      	str	r6, [r4, #4]
   159f6:	689e      	ldr	r6, [r3, #8]
   159f8:	60a6      	str	r6, [r4, #8]
   159fa:	68de      	ldr	r6, [r3, #12]
   159fc:	3310      	adds	r3, #16
   159fe:	60e6      	str	r6, [r4, #12]
   15a00:	3410      	adds	r4, #16
   15a02:	4299      	cmp	r1, r3
   15a04:	d1f3      	bne.n	159ee <memcpy+0x1e>
   15a06:	230f      	movs	r3, #15
   15a08:	1945      	adds	r5, r0, r5
   15a0a:	4013      	ands	r3, r2
   15a0c:	2b03      	cmp	r3, #3
   15a0e:	d91b      	bls.n	15a48 <memcpy+0x78>
   15a10:	1f1c      	subs	r4, r3, #4
   15a12:	2300      	movs	r3, #0
   15a14:	08a4      	lsrs	r4, r4, #2
   15a16:	3401      	adds	r4, #1
   15a18:	00a4      	lsls	r4, r4, #2
   15a1a:	58ce      	ldr	r6, [r1, r3]
   15a1c:	50ee      	str	r6, [r5, r3]
   15a1e:	3304      	adds	r3, #4
   15a20:	429c      	cmp	r4, r3
   15a22:	d1fa      	bne.n	15a1a <memcpy+0x4a>
   15a24:	2303      	movs	r3, #3
   15a26:	192d      	adds	r5, r5, r4
   15a28:	1909      	adds	r1, r1, r4
   15a2a:	401a      	ands	r2, r3
   15a2c:	d005      	beq.n	15a3a <memcpy+0x6a>
   15a2e:	2300      	movs	r3, #0
   15a30:	5ccc      	ldrb	r4, [r1, r3]
   15a32:	54ec      	strb	r4, [r5, r3]
   15a34:	3301      	adds	r3, #1
   15a36:	429a      	cmp	r2, r3
   15a38:	d1fa      	bne.n	15a30 <memcpy+0x60>
   15a3a:	bd70      	pop	{r4, r5, r6, pc}
   15a3c:	0005      	movs	r5, r0
   15a3e:	2a00      	cmp	r2, #0
   15a40:	d1f5      	bne.n	15a2e <memcpy+0x5e>
   15a42:	e7fa      	b.n	15a3a <memcpy+0x6a>
   15a44:	0005      	movs	r5, r0
   15a46:	e7f2      	b.n	15a2e <memcpy+0x5e>
   15a48:	001a      	movs	r2, r3
   15a4a:	e7f8      	b.n	15a3e <memcpy+0x6e>

00015a4c <memset>:
   15a4c:	b570      	push	{r4, r5, r6, lr}
   15a4e:	0783      	lsls	r3, r0, #30
   15a50:	d03f      	beq.n	15ad2 <memset+0x86>
   15a52:	1e54      	subs	r4, r2, #1
   15a54:	2a00      	cmp	r2, #0
   15a56:	d03b      	beq.n	15ad0 <memset+0x84>
   15a58:	b2ce      	uxtb	r6, r1
   15a5a:	0003      	movs	r3, r0
   15a5c:	2503      	movs	r5, #3
   15a5e:	e003      	b.n	15a68 <memset+0x1c>
   15a60:	1e62      	subs	r2, r4, #1
   15a62:	2c00      	cmp	r4, #0
   15a64:	d034      	beq.n	15ad0 <memset+0x84>
   15a66:	0014      	movs	r4, r2
   15a68:	3301      	adds	r3, #1
   15a6a:	1e5a      	subs	r2, r3, #1
   15a6c:	7016      	strb	r6, [r2, #0]
   15a6e:	422b      	tst	r3, r5
   15a70:	d1f6      	bne.n	15a60 <memset+0x14>
   15a72:	2c03      	cmp	r4, #3
   15a74:	d924      	bls.n	15ac0 <memset+0x74>
   15a76:	25ff      	movs	r5, #255	; 0xff
   15a78:	400d      	ands	r5, r1
   15a7a:	022a      	lsls	r2, r5, #8
   15a7c:	4315      	orrs	r5, r2
   15a7e:	042a      	lsls	r2, r5, #16
   15a80:	4315      	orrs	r5, r2
   15a82:	2c0f      	cmp	r4, #15
   15a84:	d911      	bls.n	15aaa <memset+0x5e>
   15a86:	0026      	movs	r6, r4
   15a88:	3e10      	subs	r6, #16
   15a8a:	0936      	lsrs	r6, r6, #4
   15a8c:	3601      	adds	r6, #1
   15a8e:	0136      	lsls	r6, r6, #4
   15a90:	001a      	movs	r2, r3
   15a92:	199b      	adds	r3, r3, r6
   15a94:	6015      	str	r5, [r2, #0]
   15a96:	6055      	str	r5, [r2, #4]
   15a98:	6095      	str	r5, [r2, #8]
   15a9a:	60d5      	str	r5, [r2, #12]
   15a9c:	3210      	adds	r2, #16
   15a9e:	4293      	cmp	r3, r2
   15aa0:	d1f8      	bne.n	15a94 <memset+0x48>
   15aa2:	220f      	movs	r2, #15
   15aa4:	4014      	ands	r4, r2
   15aa6:	2c03      	cmp	r4, #3
   15aa8:	d90a      	bls.n	15ac0 <memset+0x74>
   15aaa:	1f26      	subs	r6, r4, #4
   15aac:	08b6      	lsrs	r6, r6, #2
   15aae:	3601      	adds	r6, #1
   15ab0:	00b6      	lsls	r6, r6, #2
   15ab2:	001a      	movs	r2, r3
   15ab4:	199b      	adds	r3, r3, r6
   15ab6:	c220      	stmia	r2!, {r5}
   15ab8:	4293      	cmp	r3, r2
   15aba:	d1fc      	bne.n	15ab6 <memset+0x6a>
   15abc:	2203      	movs	r2, #3
   15abe:	4014      	ands	r4, r2
   15ac0:	2c00      	cmp	r4, #0
   15ac2:	d005      	beq.n	15ad0 <memset+0x84>
   15ac4:	b2c9      	uxtb	r1, r1
   15ac6:	191c      	adds	r4, r3, r4
   15ac8:	7019      	strb	r1, [r3, #0]
   15aca:	3301      	adds	r3, #1
   15acc:	429c      	cmp	r4, r3
   15ace:	d1fb      	bne.n	15ac8 <memset+0x7c>
   15ad0:	bd70      	pop	{r4, r5, r6, pc}
   15ad2:	0014      	movs	r4, r2
   15ad4:	0003      	movs	r3, r0
   15ad6:	e7cc      	b.n	15a72 <memset+0x26>

00015ad8 <__malloc_lock>:
   15ad8:	4770      	bx	lr
   15ada:	46c0      	nop			; (mov r8, r8)

00015adc <__malloc_unlock>:
   15adc:	4770      	bx	lr
   15ade:	46c0      	nop			; (mov r8, r8)

00015ae0 <_printf_r>:
   15ae0:	b40e      	push	{r1, r2, r3}
   15ae2:	b500      	push	{lr}
   15ae4:	b082      	sub	sp, #8
   15ae6:	ab03      	add	r3, sp, #12
   15ae8:	cb04      	ldmia	r3!, {r2}
   15aea:	6881      	ldr	r1, [r0, #8]
   15aec:	9301      	str	r3, [sp, #4]
   15aee:	f000 f8c3 	bl	15c78 <_vfprintf_r>
   15af2:	b002      	add	sp, #8
   15af4:	bc08      	pop	{r3}
   15af6:	b003      	add	sp, #12
   15af8:	4718      	bx	r3
   15afa:	46c0      	nop			; (mov r8, r8)

00015afc <printf>:
   15afc:	b40f      	push	{r0, r1, r2, r3}
   15afe:	b500      	push	{lr}
   15b00:	4906      	ldr	r1, [pc, #24]	; (15b1c <printf+0x20>)
   15b02:	b083      	sub	sp, #12
   15b04:	ab04      	add	r3, sp, #16
   15b06:	6808      	ldr	r0, [r1, #0]
   15b08:	cb04      	ldmia	r3!, {r2}
   15b0a:	6881      	ldr	r1, [r0, #8]
   15b0c:	9301      	str	r3, [sp, #4]
   15b0e:	f000 f8b3 	bl	15c78 <_vfprintf_r>
   15b12:	b003      	add	sp, #12
   15b14:	bc08      	pop	{r3}
   15b16:	b004      	add	sp, #16
   15b18:	4718      	bx	r3
   15b1a:	46c0      	nop			; (mov r8, r8)
   15b1c:	10010df0 	.word	0x10010df0

00015b20 <_puts_r>:
   15b20:	b530      	push	{r4, r5, lr}
   15b22:	0005      	movs	r5, r0
   15b24:	b089      	sub	sp, #36	; 0x24
   15b26:	0008      	movs	r0, r1
   15b28:	000c      	movs	r4, r1
   15b2a:	f000 f871 	bl	15c10 <strlen>
   15b2e:	ab04      	add	r3, sp, #16
   15b30:	4a15      	ldr	r2, [pc, #84]	; (15b88 <_puts_r+0x68>)
   15b32:	9301      	str	r3, [sp, #4]
   15b34:	2302      	movs	r3, #2
   15b36:	9206      	str	r2, [sp, #24]
   15b38:	2201      	movs	r2, #1
   15b3a:	9302      	str	r3, [sp, #8]
   15b3c:	6bab      	ldr	r3, [r5, #56]	; 0x38
   15b3e:	9005      	str	r0, [sp, #20]
   15b40:	3001      	adds	r0, #1
   15b42:	9404      	str	r4, [sp, #16]
   15b44:	9207      	str	r2, [sp, #28]
   15b46:	9003      	str	r0, [sp, #12]
   15b48:	68ac      	ldr	r4, [r5, #8]
   15b4a:	2b00      	cmp	r3, #0
   15b4c:	d017      	beq.n	15b7e <_puts_r+0x5e>
   15b4e:	220c      	movs	r2, #12
   15b50:	5ea3      	ldrsh	r3, [r4, r2]
   15b52:	2280      	movs	r2, #128	; 0x80
   15b54:	0192      	lsls	r2, r2, #6
   15b56:	4213      	tst	r3, r2
   15b58:	d105      	bne.n	15b66 <_puts_r+0x46>
   15b5a:	4313      	orrs	r3, r2
   15b5c:	81a3      	strh	r3, [r4, #12]
   15b5e:	6e62      	ldr	r2, [r4, #100]	; 0x64
   15b60:	4b0a      	ldr	r3, [pc, #40]	; (15b8c <_puts_r+0x6c>)
   15b62:	4013      	ands	r3, r2
   15b64:	6663      	str	r3, [r4, #100]	; 0x64
   15b66:	aa01      	add	r2, sp, #4
   15b68:	0021      	movs	r1, r4
   15b6a:	0028      	movs	r0, r5
   15b6c:	f003 f900 	bl	18d70 <__sfvwrite_r>
   15b70:	1e43      	subs	r3, r0, #1
   15b72:	4198      	sbcs	r0, r3
   15b74:	230a      	movs	r3, #10
   15b76:	4240      	negs	r0, r0
   15b78:	4318      	orrs	r0, r3
   15b7a:	b009      	add	sp, #36	; 0x24
   15b7c:	bd30      	pop	{r4, r5, pc}
   15b7e:	0028      	movs	r0, r5
   15b80:	f002 ff9c 	bl	18abc <__sinit>
   15b84:	e7e3      	b.n	15b4e <_puts_r+0x2e>
   15b86:	46c0      	nop			; (mov r8, r8)
   15b88:	00022bc0 	.word	0x00022bc0
   15b8c:	ffffdfff 	.word	0xffffdfff

00015b90 <puts>:
   15b90:	b510      	push	{r4, lr}
   15b92:	4b03      	ldr	r3, [pc, #12]	; (15ba0 <puts+0x10>)
   15b94:	0001      	movs	r1, r0
   15b96:	6818      	ldr	r0, [r3, #0]
   15b98:	f7ff ffc2 	bl	15b20 <_puts_r>
   15b9c:	bd10      	pop	{r4, pc}
   15b9e:	46c0      	nop			; (mov r8, r8)
   15ba0:	10010df0 	.word	0x10010df0

00015ba4 <srand>:
   15ba4:	2200      	movs	r2, #0
   15ba6:	4b03      	ldr	r3, [pc, #12]	; (15bb4 <srand+0x10>)
   15ba8:	681b      	ldr	r3, [r3, #0]
   15baa:	33a8      	adds	r3, #168	; 0xa8
   15bac:	6018      	str	r0, [r3, #0]
   15bae:	605a      	str	r2, [r3, #4]
   15bb0:	4770      	bx	lr
   15bb2:	46c0      	nop			; (mov r8, r8)
   15bb4:	10010df0 	.word	0x10010df0

00015bb8 <rand>:
   15bb8:	b510      	push	{r4, lr}
   15bba:	4b09      	ldr	r3, [pc, #36]	; (15be0 <rand+0x28>)
   15bbc:	4a09      	ldr	r2, [pc, #36]	; (15be4 <rand+0x2c>)
   15bbe:	681c      	ldr	r4, [r3, #0]
   15bc0:	4b09      	ldr	r3, [pc, #36]	; (15be8 <rand+0x30>)
   15bc2:	34a8      	adds	r4, #168	; 0xa8
   15bc4:	6820      	ldr	r0, [r4, #0]
   15bc6:	6861      	ldr	r1, [r4, #4]
   15bc8:	f008 f980 	bl	1decc <__aeabi_lmul>
   15bcc:	2201      	movs	r2, #1
   15bce:	2300      	movs	r3, #0
   15bd0:	1880      	adds	r0, r0, r2
   15bd2:	4159      	adcs	r1, r3
   15bd4:	6020      	str	r0, [r4, #0]
   15bd6:	6061      	str	r1, [r4, #4]
   15bd8:	0048      	lsls	r0, r1, #1
   15bda:	0840      	lsrs	r0, r0, #1
   15bdc:	bd10      	pop	{r4, pc}
   15bde:	46c0      	nop			; (mov r8, r8)
   15be0:	10010df0 	.word	0x10010df0
   15be4:	4c957f2d 	.word	0x4c957f2d
   15be8:	5851f42d 	.word	0x5851f42d

00015bec <_sbrk_r>:
   15bec:	2300      	movs	r3, #0
   15bee:	b570      	push	{r4, r5, r6, lr}
   15bf0:	4c06      	ldr	r4, [pc, #24]	; (15c0c <_sbrk_r+0x20>)
   15bf2:	0005      	movs	r5, r0
   15bf4:	0008      	movs	r0, r1
   15bf6:	6023      	str	r3, [r4, #0]
   15bf8:	f7ec fd23 	bl	2642 <_sbrk>
   15bfc:	1c43      	adds	r3, r0, #1
   15bfe:	d000      	beq.n	15c02 <_sbrk_r+0x16>
   15c00:	bd70      	pop	{r4, r5, r6, pc}
   15c02:	6823      	ldr	r3, [r4, #0]
   15c04:	2b00      	cmp	r3, #0
   15c06:	d0fb      	beq.n	15c00 <_sbrk_r+0x14>
   15c08:	602b      	str	r3, [r5, #0]
   15c0a:	e7f9      	b.n	15c00 <_sbrk_r+0x14>
   15c0c:	100128a8 	.word	0x100128a8

00015c10 <strlen>:
   15c10:	b510      	push	{r4, lr}
   15c12:	0783      	lsls	r3, r0, #30
   15c14:	d027      	beq.n	15c66 <strlen+0x56>
   15c16:	7803      	ldrb	r3, [r0, #0]
   15c18:	2b00      	cmp	r3, #0
   15c1a:	d026      	beq.n	15c6a <strlen+0x5a>
   15c1c:	0003      	movs	r3, r0
   15c1e:	2103      	movs	r1, #3
   15c20:	e002      	b.n	15c28 <strlen+0x18>
   15c22:	781a      	ldrb	r2, [r3, #0]
   15c24:	2a00      	cmp	r2, #0
   15c26:	d01c      	beq.n	15c62 <strlen+0x52>
   15c28:	3301      	adds	r3, #1
   15c2a:	420b      	tst	r3, r1
   15c2c:	d1f9      	bne.n	15c22 <strlen+0x12>
   15c2e:	6819      	ldr	r1, [r3, #0]
   15c30:	4a0f      	ldr	r2, [pc, #60]	; (15c70 <strlen+0x60>)
   15c32:	4c10      	ldr	r4, [pc, #64]	; (15c74 <strlen+0x64>)
   15c34:	188a      	adds	r2, r1, r2
   15c36:	438a      	bics	r2, r1
   15c38:	4222      	tst	r2, r4
   15c3a:	d10f      	bne.n	15c5c <strlen+0x4c>
   15c3c:	3304      	adds	r3, #4
   15c3e:	6819      	ldr	r1, [r3, #0]
   15c40:	4a0b      	ldr	r2, [pc, #44]	; (15c70 <strlen+0x60>)
   15c42:	188a      	adds	r2, r1, r2
   15c44:	438a      	bics	r2, r1
   15c46:	4222      	tst	r2, r4
   15c48:	d108      	bne.n	15c5c <strlen+0x4c>
   15c4a:	3304      	adds	r3, #4
   15c4c:	6819      	ldr	r1, [r3, #0]
   15c4e:	4a08      	ldr	r2, [pc, #32]	; (15c70 <strlen+0x60>)
   15c50:	188a      	adds	r2, r1, r2
   15c52:	438a      	bics	r2, r1
   15c54:	4222      	tst	r2, r4
   15c56:	d0f1      	beq.n	15c3c <strlen+0x2c>
   15c58:	e000      	b.n	15c5c <strlen+0x4c>
   15c5a:	3301      	adds	r3, #1
   15c5c:	781a      	ldrb	r2, [r3, #0]
   15c5e:	2a00      	cmp	r2, #0
   15c60:	d1fb      	bne.n	15c5a <strlen+0x4a>
   15c62:	1a18      	subs	r0, r3, r0
   15c64:	bd10      	pop	{r4, pc}
   15c66:	0003      	movs	r3, r0
   15c68:	e7e1      	b.n	15c2e <strlen+0x1e>
   15c6a:	2000      	movs	r0, #0
   15c6c:	e7fa      	b.n	15c64 <strlen+0x54>
   15c6e:	46c0      	nop			; (mov r8, r8)
   15c70:	fefefeff 	.word	0xfefefeff
   15c74:	80808080 	.word	0x80808080

00015c78 <_vfprintf_r>:
   15c78:	b5f0      	push	{r4, r5, r6, r7, lr}
   15c7a:	4644      	mov	r4, r8
   15c7c:	465f      	mov	r7, fp
   15c7e:	4656      	mov	r6, sl
   15c80:	464d      	mov	r5, r9
   15c82:	b4f0      	push	{r4, r5, r6, r7}
   15c84:	b0c3      	sub	sp, #268	; 0x10c
   15c86:	001c      	movs	r4, r3
   15c88:	9311      	str	r3, [sp, #68]	; 0x44
   15c8a:	4683      	mov	fp, r0
   15c8c:	4688      	mov	r8, r1
   15c8e:	920a      	str	r2, [sp, #40]	; 0x28
   15c90:	f003 fa46 	bl	19120 <_localeconv_r>
   15c94:	6800      	ldr	r0, [r0, #0]
   15c96:	9019      	str	r0, [sp, #100]	; 0x64
   15c98:	f7ff ffba 	bl	15c10 <strlen>
   15c9c:	465b      	mov	r3, fp
   15c9e:	9018      	str	r0, [sp, #96]	; 0x60
   15ca0:	2b00      	cmp	r3, #0
   15ca2:	d003      	beq.n	15cac <_vfprintf_r+0x34>
   15ca4:	6b9b      	ldr	r3, [r3, #56]	; 0x38
   15ca6:	2b00      	cmp	r3, #0
   15ca8:	d100      	bne.n	15cac <_vfprintf_r+0x34>
   15caa:	e0d9      	b.n	15e60 <_vfprintf_r+0x1e8>
   15cac:	4643      	mov	r3, r8
   15cae:	2180      	movs	r1, #128	; 0x80
   15cb0:	220c      	movs	r2, #12
   15cb2:	5e9a      	ldrsh	r2, [r3, r2]
   15cb4:	0189      	lsls	r1, r1, #6
   15cb6:	b293      	uxth	r3, r2
   15cb8:	420b      	tst	r3, r1
   15cba:	d109      	bne.n	15cd0 <_vfprintf_r+0x58>
   15cbc:	430a      	orrs	r2, r1
   15cbe:	4643      	mov	r3, r8
   15cc0:	4641      	mov	r1, r8
   15cc2:	819a      	strh	r2, [r3, #12]
   15cc4:	6e49      	ldr	r1, [r1, #100]	; 0x64
   15cc6:	4bbc      	ldr	r3, [pc, #752]	; (15fb8 <_vfprintf_r+0x340>)
   15cc8:	400b      	ands	r3, r1
   15cca:	4641      	mov	r1, r8
   15ccc:	664b      	str	r3, [r1, #100]	; 0x64
   15cce:	b293      	uxth	r3, r2
   15cd0:	071a      	lsls	r2, r3, #28
   15cd2:	d400      	bmi.n	15cd6 <_vfprintf_r+0x5e>
   15cd4:	e097      	b.n	15e06 <_vfprintf_r+0x18e>
   15cd6:	4642      	mov	r2, r8
   15cd8:	6912      	ldr	r2, [r2, #16]
   15cda:	2a00      	cmp	r2, #0
   15cdc:	d100      	bne.n	15ce0 <_vfprintf_r+0x68>
   15cde:	e092      	b.n	15e06 <_vfprintf_r+0x18e>
   15ce0:	221a      	movs	r2, #26
   15ce2:	4013      	ands	r3, r2
   15ce4:	2b0a      	cmp	r3, #10
   15ce6:	d100      	bne.n	15cea <_vfprintf_r+0x72>
   15ce8:	e09c      	b.n	15e24 <_vfprintf_r+0x1ac>
   15cea:	ab32      	add	r3, sp, #200	; 0xc8
   15cec:	9325      	str	r3, [sp, #148]	; 0x94
   15cee:	2300      	movs	r3, #0
   15cf0:	af25      	add	r7, sp, #148	; 0x94
   15cf2:	60bb      	str	r3, [r7, #8]
   15cf4:	607b      	str	r3, [r7, #4]
   15cf6:	9314      	str	r3, [sp, #80]	; 0x50
   15cf8:	9316      	str	r3, [sp, #88]	; 0x58
   15cfa:	9317      	str	r3, [sp, #92]	; 0x5c
   15cfc:	931a      	str	r3, [sp, #104]	; 0x68
   15cfe:	930c      	str	r3, [sp, #48]	; 0x30
   15d00:	465b      	mov	r3, fp
   15d02:	46c3      	mov	fp, r8
   15d04:	ae32      	add	r6, sp, #200	; 0xc8
   15d06:	9307      	str	r3, [sp, #28]
   15d08:	9c0a      	ldr	r4, [sp, #40]	; 0x28
   15d0a:	7823      	ldrb	r3, [r4, #0]
   15d0c:	2b00      	cmp	r3, #0
   15d0e:	d100      	bne.n	15d12 <_vfprintf_r+0x9a>
   15d10:	e0aa      	b.n	15e68 <_vfprintf_r+0x1f0>
   15d12:	2b25      	cmp	r3, #37	; 0x25
   15d14:	d102      	bne.n	15d1c <_vfprintf_r+0xa4>
   15d16:	e0a7      	b.n	15e68 <_vfprintf_r+0x1f0>
   15d18:	2b25      	cmp	r3, #37	; 0x25
   15d1a:	d003      	beq.n	15d24 <_vfprintf_r+0xac>
   15d1c:	3401      	adds	r4, #1
   15d1e:	7823      	ldrb	r3, [r4, #0]
   15d20:	2b00      	cmp	r3, #0
   15d22:	d1f9      	bne.n	15d18 <_vfprintf_r+0xa0>
   15d24:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   15d26:	1ae5      	subs	r5, r4, r3
   15d28:	d011      	beq.n	15d4e <_vfprintf_r+0xd6>
   15d2a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   15d2c:	6075      	str	r5, [r6, #4]
   15d2e:	6033      	str	r3, [r6, #0]
   15d30:	68bb      	ldr	r3, [r7, #8]
   15d32:	195b      	adds	r3, r3, r5
   15d34:	60bb      	str	r3, [r7, #8]
   15d36:	687b      	ldr	r3, [r7, #4]
   15d38:	3301      	adds	r3, #1
   15d3a:	607b      	str	r3, [r7, #4]
   15d3c:	2b07      	cmp	r3, #7
   15d3e:	dd00      	ble.n	15d42 <_vfprintf_r+0xca>
   15d40:	e083      	b.n	15e4a <_vfprintf_r+0x1d2>
   15d42:	3608      	adds	r6, #8
   15d44:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   15d46:	469c      	mov	ip, r3
   15d48:	44ac      	add	ip, r5
   15d4a:	4663      	mov	r3, ip
   15d4c:	930c      	str	r3, [sp, #48]	; 0x30
   15d4e:	7823      	ldrb	r3, [r4, #0]
   15d50:	2b00      	cmp	r3, #0
   15d52:	d101      	bne.n	15d58 <_vfprintf_r+0xe0>
   15d54:	f001 f8da 	bl	16f0c <_vfprintf_r+0x1294>
   15d58:	2300      	movs	r3, #0
   15d5a:	aa16      	add	r2, sp, #88	; 0x58
   15d5c:	77d3      	strb	r3, [r2, #31]
   15d5e:	2201      	movs	r2, #1
   15d60:	4252      	negs	r2, r2
   15d62:	920b      	str	r2, [sp, #44]	; 0x2c
   15d64:	2200      	movs	r2, #0
   15d66:	920d      	str	r2, [sp, #52]	; 0x34
   15d68:	9208      	str	r2, [sp, #32]
   15d6a:	3240      	adds	r2, #64	; 0x40
   15d6c:	4692      	mov	sl, r2
   15d6e:	3a38      	subs	r2, #56	; 0x38
   15d70:	4691      	mov	r9, r2
   15d72:	3278      	adds	r2, #120	; 0x78
   15d74:	1c61      	adds	r1, r4, #1
   15d76:	7863      	ldrb	r3, [r4, #1]
   15d78:	2000      	movs	r0, #0
   15d7a:	2400      	movs	r4, #0
   15d7c:	4694      	mov	ip, r2
   15d7e:	3101      	adds	r1, #1
   15d80:	001a      	movs	r2, r3
   15d82:	3a20      	subs	r2, #32
   15d84:	2a58      	cmp	r2, #88	; 0x58
   15d86:	d900      	bls.n	15d8a <_vfprintf_r+0x112>
   15d88:	e38d      	b.n	164a6 <_vfprintf_r+0x82e>
   15d8a:	4d8c      	ldr	r5, [pc, #560]	; (15fbc <_vfprintf_r+0x344>)
   15d8c:	0092      	lsls	r2, r2, #2
   15d8e:	58aa      	ldr	r2, [r5, r2]
   15d90:	4697      	mov	pc, r2
   15d92:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   15d94:	9211      	str	r2, [sp, #68]	; 0x44
   15d96:	425b      	negs	r3, r3
   15d98:	930d      	str	r3, [sp, #52]	; 0x34
   15d9a:	2304      	movs	r3, #4
   15d9c:	9a08      	ldr	r2, [sp, #32]
   15d9e:	431a      	orrs	r2, r3
   15da0:	9208      	str	r2, [sp, #32]
   15da2:	780b      	ldrb	r3, [r1, #0]
   15da4:	e7eb      	b.n	15d7e <_vfprintf_r+0x106>
   15da6:	2430      	movs	r4, #48	; 0x30
   15da8:	9b11      	ldr	r3, [sp, #68]	; 0x44
   15daa:	aa1e      	add	r2, sp, #120	; 0x78
   15dac:	7014      	strb	r4, [r2, #0]
   15dae:	1d18      	adds	r0, r3, #4
   15db0:	3448      	adds	r4, #72	; 0x48
   15db2:	681b      	ldr	r3, [r3, #0]
   15db4:	7054      	strb	r4, [r2, #1]
   15db6:	9d08      	ldr	r5, [sp, #32]
   15db8:	2200      	movs	r2, #0
   15dba:	930e      	str	r3, [sp, #56]	; 0x38
   15dbc:	2300      	movs	r3, #0
   15dbe:	910a      	str	r1, [sp, #40]	; 0x28
   15dc0:	0029      	movs	r1, r5
   15dc2:	ac16      	add	r4, sp, #88	; 0x58
   15dc4:	77e2      	strb	r2, [r4, #31]
   15dc6:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
   15dc8:	930f      	str	r3, [sp, #60]	; 0x3c
   15dca:	3302      	adds	r3, #2
   15dcc:	4319      	orrs	r1, r3
   15dce:	2a00      	cmp	r2, #0
   15dd0:	da00      	bge.n	15dd4 <_vfprintf_r+0x15c>
   15dd2:	e379      	b.n	164c8 <_vfprintf_r+0x850>
   15dd4:	2280      	movs	r2, #128	; 0x80
   15dd6:	4395      	bics	r5, r2
   15dd8:	002a      	movs	r2, r5
   15dda:	431a      	orrs	r2, r3
   15ddc:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   15dde:	9208      	str	r2, [sp, #32]
   15de0:	9011      	str	r0, [sp, #68]	; 0x44
   15de2:	2b00      	cmp	r3, #0
   15de4:	d000      	beq.n	15de8 <_vfprintf_r+0x170>
   15de6:	e358      	b.n	1649a <_vfprintf_r+0x822>
   15de8:	3378      	adds	r3, #120	; 0x78
   15dea:	4975      	ldr	r1, [pc, #468]	; (15fc0 <_vfprintf_r+0x348>)
   15dec:	9313      	str	r3, [sp, #76]	; 0x4c
   15dee:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   15df0:	4698      	mov	r8, r3
   15df2:	2b00      	cmp	r3, #0
   15df4:	d100      	bne.n	15df8 <_vfprintf_r+0x180>
   15df6:	e31e      	b.n	16436 <_vfprintf_r+0x7be>
   15df8:	2300      	movs	r3, #0
   15dfa:	4698      	mov	r8, r3
   15dfc:	2400      	movs	r4, #0
   15dfe:	2300      	movs	r3, #0
   15e00:	930e      	str	r3, [sp, #56]	; 0x38
   15e02:	940f      	str	r4, [sp, #60]	; 0x3c
   15e04:	e2c0      	b.n	16388 <_vfprintf_r+0x710>
   15e06:	4641      	mov	r1, r8
   15e08:	4658      	mov	r0, fp
   15e0a:	f001 fbd9 	bl	175c0 <__swsetup_r>
   15e0e:	2800      	cmp	r0, #0
   15e10:	d001      	beq.n	15e16 <_vfprintf_r+0x19e>
   15e12:	f001 f873 	bl	16efc <_vfprintf_r+0x1284>
   15e16:	4643      	mov	r3, r8
   15e18:	221a      	movs	r2, #26
   15e1a:	899b      	ldrh	r3, [r3, #12]
   15e1c:	4013      	ands	r3, r2
   15e1e:	2b0a      	cmp	r3, #10
   15e20:	d000      	beq.n	15e24 <_vfprintf_r+0x1ac>
   15e22:	e762      	b.n	15cea <_vfprintf_r+0x72>
   15e24:	4643      	mov	r3, r8
   15e26:	220e      	movs	r2, #14
   15e28:	5e9b      	ldrsh	r3, [r3, r2]
   15e2a:	2b00      	cmp	r3, #0
   15e2c:	da00      	bge.n	15e30 <_vfprintf_r+0x1b8>
   15e2e:	e75c      	b.n	15cea <_vfprintf_r+0x72>
   15e30:	0023      	movs	r3, r4
   15e32:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   15e34:	4641      	mov	r1, r8
   15e36:	4658      	mov	r0, fp
   15e38:	f001 fb3e 	bl	174b8 <__sbprintf>
   15e3c:	b043      	add	sp, #268	; 0x10c
   15e3e:	bc3c      	pop	{r2, r3, r4, r5}
   15e40:	4690      	mov	r8, r2
   15e42:	4699      	mov	r9, r3
   15e44:	46a2      	mov	sl, r4
   15e46:	46ab      	mov	fp, r5
   15e48:	bdf0      	pop	{r4, r5, r6, r7, pc}
   15e4a:	003a      	movs	r2, r7
   15e4c:	4659      	mov	r1, fp
   15e4e:	9807      	ldr	r0, [sp, #28]
   15e50:	f005 fe2e 	bl	1bab0 <__sprint_r>
   15e54:	2800      	cmp	r0, #0
   15e56:	d001      	beq.n	15e5c <_vfprintf_r+0x1e4>
   15e58:	f000 fd27 	bl	168aa <_vfprintf_r+0xc32>
   15e5c:	ae32      	add	r6, sp, #200	; 0xc8
   15e5e:	e771      	b.n	15d44 <_vfprintf_r+0xcc>
   15e60:	4658      	mov	r0, fp
   15e62:	f002 fe2b 	bl	18abc <__sinit>
   15e66:	e721      	b.n	15cac <_vfprintf_r+0x34>
   15e68:	9c0a      	ldr	r4, [sp, #40]	; 0x28
   15e6a:	e770      	b.n	15d4e <_vfprintf_r+0xd6>
   15e6c:	9b11      	ldr	r3, [sp, #68]	; 0x44
   15e6e:	1d1a      	adds	r2, r3, #4
   15e70:	681b      	ldr	r3, [r3, #0]
   15e72:	930d      	str	r3, [sp, #52]	; 0x34
   15e74:	2b00      	cmp	r3, #0
   15e76:	da00      	bge.n	15e7a <_vfprintf_r+0x202>
   15e78:	e78b      	b.n	15d92 <_vfprintf_r+0x11a>
   15e7a:	780b      	ldrb	r3, [r1, #0]
   15e7c:	9211      	str	r2, [sp, #68]	; 0x44
   15e7e:	e77e      	b.n	15d7e <_vfprintf_r+0x106>
   15e80:	1c4b      	adds	r3, r1, #1
   15e82:	4698      	mov	r8, r3
   15e84:	780b      	ldrb	r3, [r1, #0]
   15e86:	2b2a      	cmp	r3, #42	; 0x2a
   15e88:	d101      	bne.n	15e8e <_vfprintf_r+0x216>
   15e8a:	f001 fabb 	bl	17404 <_vfprintf_r+0x178c>
   15e8e:	001a      	movs	r2, r3
   15e90:	3a30      	subs	r2, #48	; 0x30
   15e92:	2100      	movs	r1, #0
   15e94:	2a09      	cmp	r2, #9
   15e96:	d901      	bls.n	15e9c <_vfprintf_r+0x224>
   15e98:	f001 fa60 	bl	1735c <_vfprintf_r+0x16e4>
   15e9c:	4643      	mov	r3, r8
   15e9e:	4680      	mov	r8, r0
   15ea0:	0008      	movs	r0, r1
   15ea2:	0081      	lsls	r1, r0, #2
   15ea4:	1809      	adds	r1, r1, r0
   15ea6:	0049      	lsls	r1, r1, #1
   15ea8:	3301      	adds	r3, #1
   15eaa:	1888      	adds	r0, r1, r2
   15eac:	1e5a      	subs	r2, r3, #1
   15eae:	7811      	ldrb	r1, [r2, #0]
   15eb0:	000a      	movs	r2, r1
   15eb2:	3a30      	subs	r2, #48	; 0x30
   15eb4:	2a09      	cmp	r2, #9
   15eb6:	d9f4      	bls.n	15ea2 <_vfprintf_r+0x22a>
   15eb8:	4642      	mov	r2, r8
   15eba:	4698      	mov	r8, r3
   15ebc:	000b      	movs	r3, r1
   15ebe:	0001      	movs	r1, r0
   15ec0:	0010      	movs	r0, r2
   15ec2:	2900      	cmp	r1, #0
   15ec4:	da01      	bge.n	15eca <_vfprintf_r+0x252>
   15ec6:	f001 f8fd 	bl	170c4 <_vfprintf_r+0x144c>
   15eca:	910b      	str	r1, [sp, #44]	; 0x2c
   15ecc:	4641      	mov	r1, r8
   15ece:	e757      	b.n	15d80 <_vfprintf_r+0x108>
   15ed0:	4662      	mov	r2, ip
   15ed2:	9b08      	ldr	r3, [sp, #32]
   15ed4:	4313      	orrs	r3, r2
   15ed6:	9308      	str	r3, [sp, #32]
   15ed8:	780b      	ldrb	r3, [r1, #0]
   15eda:	e750      	b.n	15d7e <_vfprintf_r+0x106>
   15edc:	2200      	movs	r2, #0
   15ede:	0015      	movs	r5, r2
   15ee0:	3b30      	subs	r3, #48	; 0x30
   15ee2:	4680      	mov	r8, r0
   15ee4:	001a      	movs	r2, r3
   15ee6:	0028      	movs	r0, r5
   15ee8:	0083      	lsls	r3, r0, #2
   15eea:	181b      	adds	r3, r3, r0
   15eec:	005b      	lsls	r3, r3, #1
   15eee:	3101      	adds	r1, #1
   15ef0:	18d0      	adds	r0, r2, r3
   15ef2:	1e4b      	subs	r3, r1, #1
   15ef4:	781b      	ldrb	r3, [r3, #0]
   15ef6:	001a      	movs	r2, r3
   15ef8:	3a30      	subs	r2, #48	; 0x30
   15efa:	2a09      	cmp	r2, #9
   15efc:	d9f4      	bls.n	15ee8 <_vfprintf_r+0x270>
   15efe:	900d      	str	r0, [sp, #52]	; 0x34
   15f00:	4640      	mov	r0, r8
   15f02:	e73d      	b.n	15d80 <_vfprintf_r+0x108>
   15f04:	9313      	str	r3, [sp, #76]	; 0x4c
   15f06:	910a      	str	r1, [sp, #40]	; 0x28
   15f08:	2800      	cmp	r0, #0
   15f0a:	d001      	beq.n	15f10 <_vfprintf_r+0x298>
   15f0c:	f001 faa7 	bl	1745e <_vfprintf_r+0x17e6>
   15f10:	2310      	movs	r3, #16
   15f12:	9a08      	ldr	r2, [sp, #32]
   15f14:	431a      	orrs	r2, r3
   15f16:	9208      	str	r2, [sp, #32]
   15f18:	9b08      	ldr	r3, [sp, #32]
   15f1a:	069b      	lsls	r3, r3, #26
   15f1c:	d401      	bmi.n	15f22 <_vfprintf_r+0x2aa>
   15f1e:	f000 fd9c 	bl	16a5a <_vfprintf_r+0xde2>
   15f22:	2307      	movs	r3, #7
   15f24:	9a11      	ldr	r2, [sp, #68]	; 0x44
   15f26:	3207      	adds	r2, #7
   15f28:	439a      	bics	r2, r3
   15f2a:	3301      	adds	r3, #1
   15f2c:	469c      	mov	ip, r3
   15f2e:	4494      	add	ip, r2
   15f30:	4663      	mov	r3, ip
   15f32:	9311      	str	r3, [sp, #68]	; 0x44
   15f34:	6853      	ldr	r3, [r2, #4]
   15f36:	6812      	ldr	r2, [r2, #0]
   15f38:	930f      	str	r3, [sp, #60]	; 0x3c
   15f3a:	920e      	str	r2, [sp, #56]	; 0x38
   15f3c:	2b00      	cmp	r3, #0
   15f3e:	da01      	bge.n	15f44 <_vfprintf_r+0x2cc>
   15f40:	f000 fe8e 	bl	16c60 <_vfprintf_r+0xfe8>
   15f44:	ab16      	add	r3, sp, #88	; 0x58
   15f46:	7fdb      	ldrb	r3, [r3, #31]
   15f48:	4698      	mov	r8, r3
   15f4a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   15f4c:	2b00      	cmp	r3, #0
   15f4e:	da01      	bge.n	15f54 <_vfprintf_r+0x2dc>
   15f50:	f000 fde3 	bl	16b1a <_vfprintf_r+0xea2>
   15f54:	2380      	movs	r3, #128	; 0x80
   15f56:	9a08      	ldr	r2, [sp, #32]
   15f58:	439a      	bics	r2, r3
   15f5a:	9208      	str	r2, [sp, #32]
   15f5c:	9a0e      	ldr	r2, [sp, #56]	; 0x38
   15f5e:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   15f60:	0011      	movs	r1, r2
   15f62:	4319      	orrs	r1, r3
   15f64:	d101      	bne.n	15f6a <_vfprintf_r+0x2f2>
   15f66:	f000 fcbd 	bl	168e4 <_vfprintf_r+0xc6c>
   15f6a:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   15f6c:	2b00      	cmp	r3, #0
   15f6e:	d101      	bne.n	15f74 <_vfprintf_r+0x2fc>
   15f70:	f001 f8a2 	bl	170b8 <_vfprintf_r+0x1440>
   15f74:	9c0e      	ldr	r4, [sp, #56]	; 0x38
   15f76:	9d0f      	ldr	r5, [sp, #60]	; 0x3c
   15f78:	ab32      	add	r3, sp, #200	; 0xc8
   15f7a:	46b1      	mov	r9, r6
   15f7c:	001e      	movs	r6, r3
   15f7e:	0020      	movs	r0, r4
   15f80:	0029      	movs	r1, r5
   15f82:	220a      	movs	r2, #10
   15f84:	2300      	movs	r3, #0
   15f86:	f007 ff81 	bl	1de8c <__aeabi_uldivmod>
   15f8a:	3e01      	subs	r6, #1
   15f8c:	3230      	adds	r2, #48	; 0x30
   15f8e:	7032      	strb	r2, [r6, #0]
   15f90:	2300      	movs	r3, #0
   15f92:	0020      	movs	r0, r4
   15f94:	0029      	movs	r1, r5
   15f96:	220a      	movs	r2, #10
   15f98:	f007 ff78 	bl	1de8c <__aeabi_uldivmod>
   15f9c:	0003      	movs	r3, r0
   15f9e:	0004      	movs	r4, r0
   15fa0:	000d      	movs	r5, r1
   15fa2:	430b      	orrs	r3, r1
   15fa4:	d1eb      	bne.n	15f7e <_vfprintf_r+0x306>
   15fa6:	0032      	movs	r2, r6
   15fa8:	ab32      	add	r3, sp, #200	; 0xc8
   15faa:	1a9b      	subs	r3, r3, r2
   15fac:	9612      	str	r6, [sp, #72]	; 0x48
   15fae:	940e      	str	r4, [sp, #56]	; 0x38
   15fb0:	950f      	str	r5, [sp, #60]	; 0x3c
   15fb2:	464e      	mov	r6, r9
   15fb4:	9310      	str	r3, [sp, #64]	; 0x40
   15fb6:	e0b1      	b.n	1611c <_vfprintf_r+0x4a4>
   15fb8:	ffffdfff 	.word	0xffffdfff
   15fbc:	00022bc4 	.word	0x00022bc4
   15fc0:	00022d5c 	.word	0x00022d5c
   15fc4:	9313      	str	r3, [sp, #76]	; 0x4c
   15fc6:	910a      	str	r1, [sp, #40]	; 0x28
   15fc8:	2800      	cmp	r0, #0
   15fca:	d001      	beq.n	15fd0 <_vfprintf_r+0x358>
   15fcc:	f001 fa32 	bl	17434 <_vfprintf_r+0x17bc>
   15fd0:	2207      	movs	r2, #7
   15fd2:	9b11      	ldr	r3, [sp, #68]	; 0x44
   15fd4:	3307      	adds	r3, #7
   15fd6:	4393      	bics	r3, r2
   15fd8:	3201      	adds	r2, #1
   15fda:	4694      	mov	ip, r2
   15fdc:	449c      	add	ip, r3
   15fde:	4662      	mov	r2, ip
   15fe0:	9211      	str	r2, [sp, #68]	; 0x44
   15fe2:	681a      	ldr	r2, [r3, #0]
   15fe4:	9216      	str	r2, [sp, #88]	; 0x58
   15fe6:	2201      	movs	r2, #1
   15fe8:	685b      	ldr	r3, [r3, #4]
   15fea:	9d16      	ldr	r5, [sp, #88]	; 0x58
   15fec:	9317      	str	r3, [sp, #92]	; 0x5c
   15fee:	9b17      	ldr	r3, [sp, #92]	; 0x5c
   15ff0:	4252      	negs	r2, r2
   15ff2:	005c      	lsls	r4, r3, #1
   15ff4:	0864      	lsrs	r4, r4, #1
   15ff6:	4bc2      	ldr	r3, [pc, #776]	; (16300 <_vfprintf_r+0x688>)
   15ff8:	0028      	movs	r0, r5
   15ffa:	0021      	movs	r1, r4
   15ffc:	f009 fd70 	bl	1fae0 <__aeabi_dcmpun>
   16000:	2800      	cmp	r0, #0
   16002:	d001      	beq.n	16008 <_vfprintf_r+0x390>
   16004:	f000 fe6c 	bl	16ce0 <_vfprintf_r+0x1068>
   16008:	2201      	movs	r2, #1
   1600a:	4bbd      	ldr	r3, [pc, #756]	; (16300 <_vfprintf_r+0x688>)
   1600c:	4252      	negs	r2, r2
   1600e:	0028      	movs	r0, r5
   16010:	0021      	movs	r1, r4
   16012:	f007 fedf 	bl	1ddd4 <__aeabi_dcmple>
   16016:	2800      	cmp	r0, #0
   16018:	d001      	beq.n	1601e <_vfprintf_r+0x3a6>
   1601a:	f000 fe61 	bl	16ce0 <_vfprintf_r+0x1068>
   1601e:	2200      	movs	r2, #0
   16020:	2300      	movs	r3, #0
   16022:	9816      	ldr	r0, [sp, #88]	; 0x58
   16024:	9917      	ldr	r1, [sp, #92]	; 0x5c
   16026:	f007 fecb 	bl	1ddc0 <__aeabi_dcmplt>
   1602a:	2800      	cmp	r0, #0
   1602c:	d001      	beq.n	16032 <_vfprintf_r+0x3ba>
   1602e:	f001 f91f 	bl	17270 <_vfprintf_r+0x15f8>
   16032:	ab16      	add	r3, sp, #88	; 0x58
   16034:	7fdb      	ldrb	r3, [r3, #31]
   16036:	4698      	mov	r8, r3
   16038:	9b13      	ldr	r3, [sp, #76]	; 0x4c
   1603a:	2b47      	cmp	r3, #71	; 0x47
   1603c:	dc01      	bgt.n	16042 <_vfprintf_r+0x3ca>
   1603e:	f000 ff72 	bl	16f26 <_vfprintf_r+0x12ae>
   16042:	4bb0      	ldr	r3, [pc, #704]	; (16304 <_vfprintf_r+0x68c>)
   16044:	9312      	str	r3, [sp, #72]	; 0x48
   16046:	2380      	movs	r3, #128	; 0x80
   16048:	9a08      	ldr	r2, [sp, #32]
   1604a:	439a      	bics	r2, r3
   1604c:	9208      	str	r2, [sp, #32]
   1604e:	3b7d      	subs	r3, #125	; 0x7d
   16050:	9309      	str	r3, [sp, #36]	; 0x24
   16052:	9310      	str	r3, [sp, #64]	; 0x40
   16054:	2300      	movs	r3, #0
   16056:	930b      	str	r3, [sp, #44]	; 0x2c
   16058:	9315      	str	r3, [sp, #84]	; 0x54
   1605a:	e068      	b.n	1612e <_vfprintf_r+0x4b6>
   1605c:	464a      	mov	r2, r9
   1605e:	9b08      	ldr	r3, [sp, #32]
   16060:	4313      	orrs	r3, r2
   16062:	9308      	str	r3, [sp, #32]
   16064:	780b      	ldrb	r3, [r1, #0]
   16066:	e68a      	b.n	15d7e <_vfprintf_r+0x106>
   16068:	9313      	str	r3, [sp, #76]	; 0x4c
   1606a:	910a      	str	r1, [sp, #40]	; 0x28
   1606c:	2800      	cmp	r0, #0
   1606e:	d001      	beq.n	16074 <_vfprintf_r+0x3fc>
   16070:	f001 f9e4 	bl	1743c <_vfprintf_r+0x17c4>
   16074:	2310      	movs	r3, #16
   16076:	9a08      	ldr	r2, [sp, #32]
   16078:	431a      	orrs	r2, r3
   1607a:	9208      	str	r2, [sp, #32]
   1607c:	2320      	movs	r3, #32
   1607e:	9908      	ldr	r1, [sp, #32]
   16080:	400b      	ands	r3, r1
   16082:	d101      	bne.n	16088 <_vfprintf_r+0x410>
   16084:	f000 fcc1 	bl	16a0a <_vfprintf_r+0xd92>
   16088:	2207      	movs	r2, #7
   1608a:	9b11      	ldr	r3, [sp, #68]	; 0x44
   1608c:	3307      	adds	r3, #7
   1608e:	4393      	bics	r3, r2
   16090:	3201      	adds	r2, #1
   16092:	4694      	mov	ip, r2
   16094:	449c      	add	ip, r3
   16096:	4662      	mov	r2, ip
   16098:	685c      	ldr	r4, [r3, #4]
   1609a:	681b      	ldr	r3, [r3, #0]
   1609c:	0025      	movs	r5, r4
   1609e:	001c      	movs	r4, r3
   160a0:	2300      	movs	r3, #0
   160a2:	9211      	str	r2, [sp, #68]	; 0x44
   160a4:	aa16      	add	r2, sp, #88	; 0x58
   160a6:	77d3      	strb	r3, [r2, #31]
   160a8:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   160aa:	940e      	str	r4, [sp, #56]	; 0x38
   160ac:	950f      	str	r5, [sp, #60]	; 0x3c
   160ae:	2b00      	cmp	r3, #0
   160b0:	da01      	bge.n	160b6 <_vfprintf_r+0x43e>
   160b2:	f000 fdfd 	bl	16cb0 <_vfprintf_r+0x1038>
   160b6:	2380      	movs	r3, #128	; 0x80
   160b8:	4399      	bics	r1, r3
   160ba:	9108      	str	r1, [sp, #32]
   160bc:	0021      	movs	r1, r4
   160be:	4329      	orrs	r1, r5
   160c0:	d101      	bne.n	160c6 <_vfprintf_r+0x44e>
   160c2:	f000 fcbd 	bl	16a40 <_vfprintf_r+0xdc8>
   160c6:	2300      	movs	r3, #0
   160c8:	4698      	mov	r8, r3
   160ca:	2207      	movs	r2, #7
   160cc:	46b4      	mov	ip, r6
   160ce:	ab32      	add	r3, sp, #200	; 0xc8
   160d0:	4692      	mov	sl, r2
   160d2:	001c      	movs	r4, r3
   160d4:	9a0e      	ldr	r2, [sp, #56]	; 0x38
   160d6:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   160d8:	0758      	lsls	r0, r3, #29
   160da:	08d6      	lsrs	r6, r2, #3
   160dc:	4651      	mov	r1, sl
   160de:	08dd      	lsrs	r5, r3, #3
   160e0:	4330      	orrs	r0, r6
   160e2:	002b      	movs	r3, r5
   160e4:	0005      	movs	r5, r0
   160e6:	4011      	ands	r1, r2
   160e8:	3c01      	subs	r4, #1
   160ea:	3130      	adds	r1, #48	; 0x30
   160ec:	7021      	strb	r1, [r4, #0]
   160ee:	0002      	movs	r2, r0
   160f0:	431d      	orrs	r5, r3
   160f2:	d1f1      	bne.n	160d8 <_vfprintf_r+0x460>
   160f4:	920e      	str	r2, [sp, #56]	; 0x38
   160f6:	930f      	str	r3, [sp, #60]	; 0x3c
   160f8:	9a08      	ldr	r2, [sp, #32]
   160fa:	9412      	str	r4, [sp, #72]	; 0x48
   160fc:	4666      	mov	r6, ip
   160fe:	07d2      	lsls	r2, r2, #31
   16100:	d400      	bmi.n	16104 <_vfprintf_r+0x48c>
   16102:	e15b      	b.n	163bc <_vfprintf_r+0x744>
   16104:	2930      	cmp	r1, #48	; 0x30
   16106:	d101      	bne.n	1610c <_vfprintf_r+0x494>
   16108:	f000 ff99 	bl	1703e <_vfprintf_r+0x13c6>
   1610c:	2330      	movs	r3, #48	; 0x30
   1610e:	9d12      	ldr	r5, [sp, #72]	; 0x48
   16110:	3d01      	subs	r5, #1
   16112:	702b      	strb	r3, [r5, #0]
   16114:	ab32      	add	r3, sp, #200	; 0xc8
   16116:	1b5b      	subs	r3, r3, r5
   16118:	9310      	str	r3, [sp, #64]	; 0x40
   1611a:	9512      	str	r5, [sp, #72]	; 0x48
   1611c:	9a10      	ldr	r2, [sp, #64]	; 0x40
   1611e:	0013      	movs	r3, r2
   16120:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
   16122:	4293      	cmp	r3, r2
   16124:	da00      	bge.n	16128 <_vfprintf_r+0x4b0>
   16126:	0013      	movs	r3, r2
   16128:	9309      	str	r3, [sp, #36]	; 0x24
   1612a:	2300      	movs	r3, #0
   1612c:	9315      	str	r3, [sp, #84]	; 0x54
   1612e:	4643      	mov	r3, r8
   16130:	2b00      	cmp	r3, #0
   16132:	d002      	beq.n	1613a <_vfprintf_r+0x4c2>
   16134:	9b09      	ldr	r3, [sp, #36]	; 0x24
   16136:	3301      	adds	r3, #1
   16138:	9309      	str	r3, [sp, #36]	; 0x24
   1613a:	2302      	movs	r3, #2
   1613c:	9a08      	ldr	r2, [sp, #32]
   1613e:	401a      	ands	r2, r3
   16140:	4692      	mov	sl, r2
   16142:	d002      	beq.n	1614a <_vfprintf_r+0x4d2>
   16144:	9b09      	ldr	r3, [sp, #36]	; 0x24
   16146:	3302      	adds	r3, #2
   16148:	9309      	str	r3, [sp, #36]	; 0x24
   1614a:	2384      	movs	r3, #132	; 0x84
   1614c:	9a08      	ldr	r2, [sp, #32]
   1614e:	401a      	ands	r2, r3
   16150:	4691      	mov	r9, r2
   16152:	d000      	beq.n	16156 <_vfprintf_r+0x4de>
   16154:	e1c7      	b.n	164e6 <_vfprintf_r+0x86e>
   16156:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   16158:	9a09      	ldr	r2, [sp, #36]	; 0x24
   1615a:	1a9c      	subs	r4, r3, r2
   1615c:	2c00      	cmp	r4, #0
   1615e:	dc00      	bgt.n	16162 <_vfprintf_r+0x4ea>
   16160:	e1c1      	b.n	164e6 <_vfprintf_r+0x86e>
   16162:	4969      	ldr	r1, [pc, #420]	; (16308 <_vfprintf_r+0x690>)
   16164:	68ba      	ldr	r2, [r7, #8]
   16166:	687b      	ldr	r3, [r7, #4]
   16168:	4688      	mov	r8, r1
   1616a:	2c10      	cmp	r4, #16
   1616c:	dd21      	ble.n	161b2 <_vfprintf_r+0x53a>
   1616e:	0031      	movs	r1, r6
   16170:	2510      	movs	r5, #16
   16172:	465e      	mov	r6, fp
   16174:	e003      	b.n	1617e <_vfprintf_r+0x506>
   16176:	3c10      	subs	r4, #16
   16178:	3108      	adds	r1, #8
   1617a:	2c10      	cmp	r4, #16
   1617c:	dd17      	ble.n	161ae <_vfprintf_r+0x536>
   1617e:	4640      	mov	r0, r8
   16180:	3210      	adds	r2, #16
   16182:	3301      	adds	r3, #1
   16184:	6008      	str	r0, [r1, #0]
   16186:	604d      	str	r5, [r1, #4]
   16188:	60ba      	str	r2, [r7, #8]
   1618a:	607b      	str	r3, [r7, #4]
   1618c:	2b07      	cmp	r3, #7
   1618e:	ddf2      	ble.n	16176 <_vfprintf_r+0x4fe>
   16190:	003a      	movs	r2, r7
   16192:	0031      	movs	r1, r6
   16194:	9807      	ldr	r0, [sp, #28]
   16196:	f005 fc8b 	bl	1bab0 <__sprint_r>
   1619a:	2800      	cmp	r0, #0
   1619c:	d001      	beq.n	161a2 <_vfprintf_r+0x52a>
   1619e:	f000 fc32 	bl	16a06 <_vfprintf_r+0xd8e>
   161a2:	3c10      	subs	r4, #16
   161a4:	68ba      	ldr	r2, [r7, #8]
   161a6:	687b      	ldr	r3, [r7, #4]
   161a8:	a932      	add	r1, sp, #200	; 0xc8
   161aa:	2c10      	cmp	r4, #16
   161ac:	dce7      	bgt.n	1617e <_vfprintf_r+0x506>
   161ae:	46b3      	mov	fp, r6
   161b0:	000e      	movs	r6, r1
   161b2:	4641      	mov	r1, r8
   161b4:	6074      	str	r4, [r6, #4]
   161b6:	3301      	adds	r3, #1
   161b8:	18a4      	adds	r4, r4, r2
   161ba:	6031      	str	r1, [r6, #0]
   161bc:	60bc      	str	r4, [r7, #8]
   161be:	607b      	str	r3, [r7, #4]
   161c0:	2b07      	cmp	r3, #7
   161c2:	dd01      	ble.n	161c8 <_vfprintf_r+0x550>
   161c4:	f000 fc11 	bl	169ea <_vfprintf_r+0xd72>
   161c8:	ab16      	add	r3, sp, #88	; 0x58
   161ca:	7fdb      	ldrb	r3, [r3, #31]
   161cc:	3608      	adds	r6, #8
   161ce:	4698      	mov	r8, r3
   161d0:	e18a      	b.n	164e8 <_vfprintf_r+0x870>
   161d2:	9313      	str	r3, [sp, #76]	; 0x4c
   161d4:	910a      	str	r1, [sp, #40]	; 0x28
   161d6:	2800      	cmp	r0, #0
   161d8:	d001      	beq.n	161de <_vfprintf_r+0x566>
   161da:	f001 f938 	bl	1744e <_vfprintf_r+0x17d6>
   161de:	2310      	movs	r3, #16
   161e0:	9a08      	ldr	r2, [sp, #32]
   161e2:	431a      	orrs	r2, r3
   161e4:	9208      	str	r2, [sp, #32]
   161e6:	2320      	movs	r3, #32
   161e8:	9908      	ldr	r1, [sp, #32]
   161ea:	400b      	ands	r3, r1
   161ec:	d100      	bne.n	161f0 <_vfprintf_r+0x578>
   161ee:	e35e      	b.n	168ae <_vfprintf_r+0xc36>
   161f0:	2207      	movs	r2, #7
   161f2:	9b11      	ldr	r3, [sp, #68]	; 0x44
   161f4:	3307      	adds	r3, #7
   161f6:	4393      	bics	r3, r2
   161f8:	3201      	adds	r2, #1
   161fa:	4694      	mov	ip, r2
   161fc:	449c      	add	ip, r3
   161fe:	4662      	mov	r2, ip
   16200:	685c      	ldr	r4, [r3, #4]
   16202:	681b      	ldr	r3, [r3, #0]
   16204:	0025      	movs	r5, r4
   16206:	001c      	movs	r4, r3
   16208:	2300      	movs	r3, #0
   1620a:	9211      	str	r2, [sp, #68]	; 0x44
   1620c:	aa16      	add	r2, sp, #88	; 0x58
   1620e:	77d3      	strb	r3, [r2, #31]
   16210:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   16212:	940e      	str	r4, [sp, #56]	; 0x38
   16214:	950f      	str	r5, [sp, #60]	; 0x3c
   16216:	2b00      	cmp	r3, #0
   16218:	da01      	bge.n	1621e <_vfprintf_r+0x5a6>
   1621a:	f000 fc7c 	bl	16b16 <_vfprintf_r+0xe9e>
   1621e:	2380      	movs	r3, #128	; 0x80
   16220:	4399      	bics	r1, r3
   16222:	9108      	str	r1, [sp, #32]
   16224:	0021      	movs	r1, r4
   16226:	4329      	orrs	r1, r5
   16228:	1e0b      	subs	r3, r1, #0
   1622a:	d100      	bne.n	1622e <_vfprintf_r+0x5b6>
   1622c:	e359      	b.n	168e2 <_vfprintf_r+0xc6a>
   1622e:	2300      	movs	r3, #0
   16230:	4698      	mov	r8, r3
   16232:	e69a      	b.n	15f6a <_vfprintf_r+0x2f2>
   16234:	9313      	str	r3, [sp, #76]	; 0x4c
   16236:	910a      	str	r1, [sp, #40]	; 0x28
   16238:	2800      	cmp	r0, #0
   1623a:	d100      	bne.n	1623e <_vfprintf_r+0x5c6>
   1623c:	e71e      	b.n	1607c <_vfprintf_r+0x404>
   1623e:	ab16      	add	r3, sp, #88	; 0x58
   16240:	77dc      	strb	r4, [r3, #31]
   16242:	e71b      	b.n	1607c <_vfprintf_r+0x404>
   16244:	2220      	movs	r2, #32
   16246:	9b08      	ldr	r3, [sp, #32]
   16248:	4313      	orrs	r3, r2
   1624a:	9308      	str	r3, [sp, #32]
   1624c:	780b      	ldrb	r3, [r1, #0]
   1624e:	e596      	b.n	15d7e <_vfprintf_r+0x106>
   16250:	9313      	str	r3, [sp, #76]	; 0x4c
   16252:	9b11      	ldr	r3, [sp, #68]	; 0x44
   16254:	910a      	str	r1, [sp, #40]	; 0x28
   16256:	1d1c      	adds	r4, r3, #4
   16258:	681b      	ldr	r3, [r3, #0]
   1625a:	a916      	add	r1, sp, #88	; 0x58
   1625c:	001a      	movs	r2, r3
   1625e:	9312      	str	r3, [sp, #72]	; 0x48
   16260:	2300      	movs	r3, #0
   16262:	77cb      	strb	r3, [r1, #31]
   16264:	2a00      	cmp	r2, #0
   16266:	d101      	bne.n	1626c <_vfprintf_r+0x5f4>
   16268:	f000 ffc6 	bl	171f8 <_vfprintf_r+0x1580>
   1626c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   1626e:	2b00      	cmp	r3, #0
   16270:	da01      	bge.n	16276 <_vfprintf_r+0x5fe>
   16272:	f000 feea 	bl	1704a <_vfprintf_r+0x13d2>
   16276:	001a      	movs	r2, r3
   16278:	2100      	movs	r1, #0
   1627a:	9812      	ldr	r0, [sp, #72]	; 0x48
   1627c:	f002 ffe0 	bl	19240 <memchr>
   16280:	2800      	cmp	r0, #0
   16282:	d101      	bne.n	16288 <_vfprintf_r+0x610>
   16284:	f001 f840 	bl	17308 <_vfprintf_r+0x1690>
   16288:	9b12      	ldr	r3, [sp, #72]	; 0x48
   1628a:	1ac3      	subs	r3, r0, r3
   1628c:	001a      	movs	r2, r3
   1628e:	9310      	str	r3, [sp, #64]	; 0x40
   16290:	43db      	mvns	r3, r3
   16292:	17db      	asrs	r3, r3, #31
   16294:	401a      	ands	r2, r3
   16296:	2300      	movs	r3, #0
   16298:	a916      	add	r1, sp, #88	; 0x58
   1629a:	7fc9      	ldrb	r1, [r1, #31]
   1629c:	9209      	str	r2, [sp, #36]	; 0x24
   1629e:	4688      	mov	r8, r1
   162a0:	9411      	str	r4, [sp, #68]	; 0x44
   162a2:	930b      	str	r3, [sp, #44]	; 0x2c
   162a4:	9315      	str	r3, [sp, #84]	; 0x54
   162a6:	e742      	b.n	1612e <_vfprintf_r+0x4b6>
   162a8:	9313      	str	r3, [sp, #76]	; 0x4c
   162aa:	910a      	str	r1, [sp, #40]	; 0x28
   162ac:	2800      	cmp	r0, #0
   162ae:	d100      	bne.n	162b2 <_vfprintf_r+0x63a>
   162b0:	e632      	b.n	15f18 <_vfprintf_r+0x2a0>
   162b2:	ab16      	add	r3, sp, #88	; 0x58
   162b4:	77dc      	strb	r4, [r3, #31]
   162b6:	e62f      	b.n	15f18 <_vfprintf_r+0x2a0>
   162b8:	4652      	mov	r2, sl
   162ba:	9b08      	ldr	r3, [sp, #32]
   162bc:	4313      	orrs	r3, r2
   162be:	9308      	str	r3, [sp, #32]
   162c0:	780b      	ldrb	r3, [r1, #0]
   162c2:	e55c      	b.n	15d7e <_vfprintf_r+0x106>
   162c4:	780b      	ldrb	r3, [r1, #0]
   162c6:	2b6c      	cmp	r3, #108	; 0x6c
   162c8:	d101      	bne.n	162ce <_vfprintf_r+0x656>
   162ca:	f000 fea4 	bl	17016 <_vfprintf_r+0x139e>
   162ce:	2510      	movs	r5, #16
   162d0:	9a08      	ldr	r2, [sp, #32]
   162d2:	432a      	orrs	r2, r5
   162d4:	9208      	str	r2, [sp, #32]
   162d6:	e552      	b.n	15d7e <_vfprintf_r+0x106>
   162d8:	910a      	str	r1, [sp, #40]	; 0x28
   162da:	2800      	cmp	r0, #0
   162dc:	d001      	beq.n	162e2 <_vfprintf_r+0x66a>
   162de:	f001 f8cb 	bl	17478 <_vfprintf_r+0x1800>
   162e2:	9b08      	ldr	r3, [sp, #32]
   162e4:	069b      	lsls	r3, r3, #26
   162e6:	d401      	bmi.n	162ec <_vfprintf_r+0x674>
   162e8:	f000 fd85 	bl	16df6 <_vfprintf_r+0x117e>
   162ec:	9911      	ldr	r1, [sp, #68]	; 0x44
   162ee:	9a0c      	ldr	r2, [sp, #48]	; 0x30
   162f0:	680b      	ldr	r3, [r1, #0]
   162f2:	601a      	str	r2, [r3, #0]
   162f4:	17d2      	asrs	r2, r2, #31
   162f6:	605a      	str	r2, [r3, #4]
   162f8:	000b      	movs	r3, r1
   162fa:	3304      	adds	r3, #4
   162fc:	9311      	str	r3, [sp, #68]	; 0x44
   162fe:	e503      	b.n	15d08 <_vfprintf_r+0x90>
   16300:	7fefffff 	.word	0x7fefffff
   16304:	00022d3c 	.word	0x00022d3c
   16308:	00022d7c 	.word	0x00022d7c
   1630c:	9313      	str	r3, [sp, #76]	; 0x4c
   1630e:	910a      	str	r1, [sp, #40]	; 0x28
   16310:	2800      	cmp	r0, #0
   16312:	d001      	beq.n	16318 <_vfprintf_r+0x6a0>
   16314:	f001 f89f 	bl	17456 <_vfprintf_r+0x17de>
   16318:	9b08      	ldr	r3, [sp, #32]
   1631a:	49b5      	ldr	r1, [pc, #724]	; (165f0 <_vfprintf_r+0x978>)
   1631c:	069b      	lsls	r3, r3, #26
   1631e:	d563      	bpl.n	163e8 <_vfprintf_r+0x770>
   16320:	2207      	movs	r2, #7
   16322:	9b11      	ldr	r3, [sp, #68]	; 0x44
   16324:	3307      	adds	r3, #7
   16326:	4393      	bics	r3, r2
   16328:	3201      	adds	r2, #1
   1632a:	4694      	mov	ip, r2
   1632c:	449c      	add	ip, r3
   1632e:	4662      	mov	r2, ip
   16330:	685c      	ldr	r4, [r3, #4]
   16332:	681b      	ldr	r3, [r3, #0]
   16334:	930e      	str	r3, [sp, #56]	; 0x38
   16336:	940f      	str	r4, [sp, #60]	; 0x3c
   16338:	2301      	movs	r3, #1
   1633a:	9211      	str	r2, [sp, #68]	; 0x44
   1633c:	9a08      	ldr	r2, [sp, #32]
   1633e:	4013      	ands	r3, r2
   16340:	d065      	beq.n	1640e <_vfprintf_r+0x796>
   16342:	9a0e      	ldr	r2, [sp, #56]	; 0x38
   16344:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   16346:	0010      	movs	r0, r2
   16348:	4318      	orrs	r0, r3
   1634a:	d101      	bne.n	16350 <_vfprintf_r+0x6d8>
   1634c:	f000 fd6c 	bl	16e28 <_vfprintf_r+0x11b0>
   16350:	2230      	movs	r2, #48	; 0x30
   16352:	ab1e      	add	r3, sp, #120	; 0x78
   16354:	701a      	strb	r2, [r3, #0]
   16356:	204c      	movs	r0, #76	; 0x4c
   16358:	466a      	mov	r2, sp
   1635a:	1812      	adds	r2, r2, r0
   1635c:	7812      	ldrb	r2, [r2, #0]
   1635e:	9c08      	ldr	r4, [sp, #32]
   16360:	705a      	strb	r2, [r3, #1]
   16362:	2200      	movs	r2, #0
   16364:	2302      	movs	r3, #2
   16366:	0020      	movs	r0, r4
   16368:	ad16      	add	r5, sp, #88	; 0x58
   1636a:	77ea      	strb	r2, [r5, #31]
   1636c:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
   1636e:	4318      	orrs	r0, r3
   16370:	2a00      	cmp	r2, #0
   16372:	da01      	bge.n	16378 <_vfprintf_r+0x700>
   16374:	f000 ff82 	bl	1727c <_vfprintf_r+0x1604>
   16378:	2280      	movs	r2, #128	; 0x80
   1637a:	0020      	movs	r0, r4
   1637c:	4390      	bics	r0, r2
   1637e:	0002      	movs	r2, r0
   16380:	431a      	orrs	r2, r3
   16382:	2300      	movs	r3, #0
   16384:	4698      	mov	r8, r3
   16386:	9208      	str	r2, [sp, #32]
   16388:	200f      	movs	r0, #15
   1638a:	468c      	mov	ip, r1
   1638c:	46b1      	mov	r9, r6
   1638e:	ab32      	add	r3, sp, #200	; 0xc8
   16390:	001c      	movs	r4, r3
   16392:	9a0e      	ldr	r2, [sp, #56]	; 0x38
   16394:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   16396:	0001      	movs	r1, r0
   16398:	4665      	mov	r5, ip
   1639a:	4011      	ands	r1, r2
   1639c:	5c69      	ldrb	r1, [r5, r1]
   1639e:	3c01      	subs	r4, #1
   163a0:	071e      	lsls	r6, r3, #28
   163a2:	7021      	strb	r1, [r4, #0]
   163a4:	0911      	lsrs	r1, r2, #4
   163a6:	091d      	lsrs	r5, r3, #4
   163a8:	430e      	orrs	r6, r1
   163aa:	002b      	movs	r3, r5
   163ac:	0035      	movs	r5, r6
   163ae:	0032      	movs	r2, r6
   163b0:	431d      	orrs	r5, r3
   163b2:	d1f0      	bne.n	16396 <_vfprintf_r+0x71e>
   163b4:	464e      	mov	r6, r9
   163b6:	920e      	str	r2, [sp, #56]	; 0x38
   163b8:	930f      	str	r3, [sp, #60]	; 0x3c
   163ba:	9412      	str	r4, [sp, #72]	; 0x48
   163bc:	ab32      	add	r3, sp, #200	; 0xc8
   163be:	1b1b      	subs	r3, r3, r4
   163c0:	9310      	str	r3, [sp, #64]	; 0x40
   163c2:	e6ab      	b.n	1611c <_vfprintf_r+0x4a4>
   163c4:	9313      	str	r3, [sp, #76]	; 0x4c
   163c6:	910a      	str	r1, [sp, #40]	; 0x28
   163c8:	2800      	cmp	r0, #0
   163ca:	d100      	bne.n	163ce <_vfprintf_r+0x756>
   163cc:	e70b      	b.n	161e6 <_vfprintf_r+0x56e>
   163ce:	ab16      	add	r3, sp, #88	; 0x58
   163d0:	77dc      	strb	r4, [r3, #31]
   163d2:	e708      	b.n	161e6 <_vfprintf_r+0x56e>
   163d4:	9313      	str	r3, [sp, #76]	; 0x4c
   163d6:	910a      	str	r1, [sp, #40]	; 0x28
   163d8:	2800      	cmp	r0, #0
   163da:	d001      	beq.n	163e0 <_vfprintf_r+0x768>
   163dc:	f001 f843 	bl	17466 <_vfprintf_r+0x17ee>
   163e0:	4984      	ldr	r1, [pc, #528]	; (165f4 <_vfprintf_r+0x97c>)
   163e2:	9b08      	ldr	r3, [sp, #32]
   163e4:	069b      	lsls	r3, r3, #26
   163e6:	d49b      	bmi.n	16320 <_vfprintf_r+0x6a8>
   163e8:	9b08      	ldr	r3, [sp, #32]
   163ea:	06db      	lsls	r3, r3, #27
   163ec:	d404      	bmi.n	163f8 <_vfprintf_r+0x780>
   163ee:	9b08      	ldr	r3, [sp, #32]
   163f0:	065b      	lsls	r3, r3, #25
   163f2:	d501      	bpl.n	163f8 <_vfprintf_r+0x780>
   163f4:	f000 fdcb 	bl	16f8e <_vfprintf_r+0x1316>
   163f8:	9b11      	ldr	r3, [sp, #68]	; 0x44
   163fa:	681a      	ldr	r2, [r3, #0]
   163fc:	920e      	str	r2, [sp, #56]	; 0x38
   163fe:	2200      	movs	r2, #0
   16400:	3304      	adds	r3, #4
   16402:	9311      	str	r3, [sp, #68]	; 0x44
   16404:	2301      	movs	r3, #1
   16406:	920f      	str	r2, [sp, #60]	; 0x3c
   16408:	9a08      	ldr	r2, [sp, #32]
   1640a:	4013      	ands	r3, r2
   1640c:	d199      	bne.n	16342 <_vfprintf_r+0x6ca>
   1640e:	a816      	add	r0, sp, #88	; 0x58
   16410:	77c3      	strb	r3, [r0, #31]
   16412:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   16414:	2b00      	cmp	r3, #0
   16416:	da01      	bge.n	1641c <_vfprintf_r+0x7a4>
   16418:	f000 fd6d 	bl	16ef6 <_vfprintf_r+0x127e>
   1641c:	2380      	movs	r3, #128	; 0x80
   1641e:	439a      	bics	r2, r3
   16420:	9208      	str	r2, [sp, #32]
   16422:	9a0e      	ldr	r2, [sp, #56]	; 0x38
   16424:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   16426:	0010      	movs	r0, r2
   16428:	4318      	orrs	r0, r3
   1642a:	d159      	bne.n	164e0 <_vfprintf_r+0x868>
   1642c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   1642e:	4698      	mov	r8, r3
   16430:	2b00      	cmp	r3, #0
   16432:	d000      	beq.n	16436 <_vfprintf_r+0x7be>
   16434:	e4e0      	b.n	15df8 <_vfprintf_r+0x180>
   16436:	2300      	movs	r3, #0
   16438:	930b      	str	r3, [sp, #44]	; 0x2c
   1643a:	9310      	str	r3, [sp, #64]	; 0x40
   1643c:	ab32      	add	r3, sp, #200	; 0xc8
   1643e:	9312      	str	r3, [sp, #72]	; 0x48
   16440:	e66c      	b.n	1611c <_vfprintf_r+0x4a4>
   16442:	780b      	ldrb	r3, [r1, #0]
   16444:	2c00      	cmp	r4, #0
   16446:	d000      	beq.n	1644a <_vfprintf_r+0x7d2>
   16448:	e499      	b.n	15d7e <_vfprintf_r+0x106>
   1644a:	2001      	movs	r0, #1
   1644c:	3420      	adds	r4, #32
   1644e:	e496      	b.n	15d7e <_vfprintf_r+0x106>
   16450:	2301      	movs	r3, #1
   16452:	9a08      	ldr	r2, [sp, #32]
   16454:	431a      	orrs	r2, r3
   16456:	9208      	str	r2, [sp, #32]
   16458:	780b      	ldrb	r3, [r1, #0]
   1645a:	e490      	b.n	15d7e <_vfprintf_r+0x106>
   1645c:	780b      	ldrb	r3, [r1, #0]
   1645e:	2001      	movs	r0, #1
   16460:	242b      	movs	r4, #43	; 0x2b
   16462:	e48c      	b.n	15d7e <_vfprintf_r+0x106>
   16464:	9a11      	ldr	r2, [sp, #68]	; 0x44
   16466:	9313      	str	r3, [sp, #76]	; 0x4c
   16468:	6813      	ldr	r3, [r2, #0]
   1646a:	910a      	str	r1, [sp, #40]	; 0x28
   1646c:	9309      	str	r3, [sp, #36]	; 0x24
   1646e:	2124      	movs	r1, #36	; 0x24
   16470:	466b      	mov	r3, sp
   16472:	185b      	adds	r3, r3, r1
   16474:	781b      	ldrb	r3, [r3, #0]
   16476:	ad28      	add	r5, sp, #160	; 0xa0
   16478:	702b      	strb	r3, [r5, #0]
   1647a:	2300      	movs	r3, #0
   1647c:	a916      	add	r1, sp, #88	; 0x58
   1647e:	77cb      	strb	r3, [r1, #31]
   16480:	0013      	movs	r3, r2
   16482:	3304      	adds	r3, #4
   16484:	9311      	str	r3, [sp, #68]	; 0x44
   16486:	2300      	movs	r3, #0
   16488:	4698      	mov	r8, r3
   1648a:	3301      	adds	r3, #1
   1648c:	9309      	str	r3, [sp, #36]	; 0x24
   1648e:	9310      	str	r3, [sp, #64]	; 0x40
   16490:	2300      	movs	r3, #0
   16492:	9512      	str	r5, [sp, #72]	; 0x48
   16494:	930b      	str	r3, [sp, #44]	; 0x2c
   16496:	9315      	str	r3, [sp, #84]	; 0x54
   16498:	e64f      	b.n	1613a <_vfprintf_r+0x4c2>
   1649a:	2300      	movs	r3, #0
   1649c:	4698      	mov	r8, r3
   1649e:	3378      	adds	r3, #120	; 0x78
   164a0:	4954      	ldr	r1, [pc, #336]	; (165f4 <_vfprintf_r+0x97c>)
   164a2:	9313      	str	r3, [sp, #76]	; 0x4c
   164a4:	e770      	b.n	16388 <_vfprintf_r+0x710>
   164a6:	9313      	str	r3, [sp, #76]	; 0x4c
   164a8:	910a      	str	r1, [sp, #40]	; 0x28
   164aa:	2800      	cmp	r0, #0
   164ac:	d001      	beq.n	164b2 <_vfprintf_r+0x83a>
   164ae:	f000 ffdf 	bl	17470 <_vfprintf_r+0x17f8>
   164b2:	9b13      	ldr	r3, [sp, #76]	; 0x4c
   164b4:	2b00      	cmp	r3, #0
   164b6:	d101      	bne.n	164bc <_vfprintf_r+0x844>
   164b8:	f000 fd28 	bl	16f0c <_vfprintf_r+0x1294>
   164bc:	ad28      	add	r5, sp, #160	; 0xa0
   164be:	702b      	strb	r3, [r5, #0]
   164c0:	2300      	movs	r3, #0
   164c2:	aa16      	add	r2, sp, #88	; 0x58
   164c4:	77d3      	strb	r3, [r2, #31]
   164c6:	e7df      	b.n	16488 <_vfprintf_r+0x810>
   164c8:	2378      	movs	r3, #120	; 0x78
   164ca:	9108      	str	r1, [sp, #32]
   164cc:	4949      	ldr	r1, [pc, #292]	; (165f4 <_vfprintf_r+0x97c>)
   164ce:	9313      	str	r3, [sp, #76]	; 0x4c
   164d0:	9a0e      	ldr	r2, [sp, #56]	; 0x38
   164d2:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   164d4:	0014      	movs	r4, r2
   164d6:	431c      	orrs	r4, r3
   164d8:	1e23      	subs	r3, r4, #0
   164da:	9011      	str	r0, [sp, #68]	; 0x44
   164dc:	d100      	bne.n	164e0 <_vfprintf_r+0x868>
   164de:	e48c      	b.n	15dfa <_vfprintf_r+0x182>
   164e0:	2300      	movs	r3, #0
   164e2:	4698      	mov	r8, r3
   164e4:	e750      	b.n	16388 <_vfprintf_r+0x710>
   164e6:	68bc      	ldr	r4, [r7, #8]
   164e8:	4643      	mov	r3, r8
   164ea:	2b00      	cmp	r3, #0
   164ec:	d00f      	beq.n	1650e <_vfprintf_r+0x896>
   164ee:	aa16      	add	r2, sp, #88	; 0x58
   164f0:	231f      	movs	r3, #31
   164f2:	4694      	mov	ip, r2
   164f4:	4463      	add	r3, ip
   164f6:	6033      	str	r3, [r6, #0]
   164f8:	2301      	movs	r3, #1
   164fa:	6073      	str	r3, [r6, #4]
   164fc:	687b      	ldr	r3, [r7, #4]
   164fe:	3401      	adds	r4, #1
   16500:	3301      	adds	r3, #1
   16502:	60bc      	str	r4, [r7, #8]
   16504:	607b      	str	r3, [r7, #4]
   16506:	2b07      	cmp	r3, #7
   16508:	dd00      	ble.n	1650c <_vfprintf_r+0x894>
   1650a:	e20c      	b.n	16926 <_vfprintf_r+0xcae>
   1650c:	3608      	adds	r6, #8
   1650e:	4653      	mov	r3, sl
   16510:	2b00      	cmp	r3, #0
   16512:	d00c      	beq.n	1652e <_vfprintf_r+0x8b6>
   16514:	ab1e      	add	r3, sp, #120	; 0x78
   16516:	6033      	str	r3, [r6, #0]
   16518:	2302      	movs	r3, #2
   1651a:	6073      	str	r3, [r6, #4]
   1651c:	687b      	ldr	r3, [r7, #4]
   1651e:	3402      	adds	r4, #2
   16520:	3301      	adds	r3, #1
   16522:	60bc      	str	r4, [r7, #8]
   16524:	607b      	str	r3, [r7, #4]
   16526:	2b07      	cmp	r3, #7
   16528:	dd00      	ble.n	1652c <_vfprintf_r+0x8b4>
   1652a:	e206      	b.n	1693a <_vfprintf_r+0xcc2>
   1652c:	3608      	adds	r6, #8
   1652e:	464b      	mov	r3, r9
   16530:	2b80      	cmp	r3, #128	; 0x80
   16532:	d100      	bne.n	16536 <_vfprintf_r+0x8be>
   16534:	e152      	b.n	167dc <_vfprintf_r+0xb64>
   16536:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   16538:	9a10      	ldr	r2, [sp, #64]	; 0x40
   1653a:	1a9d      	subs	r5, r3, r2
   1653c:	2d00      	cmp	r5, #0
   1653e:	dd32      	ble.n	165a6 <_vfprintf_r+0x92e>
   16540:	4a2d      	ldr	r2, [pc, #180]	; (165f8 <_vfprintf_r+0x980>)
   16542:	687b      	ldr	r3, [r7, #4]
   16544:	4691      	mov	r9, r2
   16546:	2d10      	cmp	r5, #16
   16548:	dd22      	ble.n	16590 <_vfprintf_r+0x918>
   1654a:	2210      	movs	r2, #16
   1654c:	4692      	mov	sl, r2
   1654e:	0022      	movs	r2, r4
   16550:	465c      	mov	r4, fp
   16552:	e003      	b.n	1655c <_vfprintf_r+0x8e4>
   16554:	3d10      	subs	r5, #16
   16556:	3608      	adds	r6, #8
   16558:	2d10      	cmp	r5, #16
   1655a:	dd17      	ble.n	1658c <_vfprintf_r+0x914>
   1655c:	4649      	mov	r1, r9
   1655e:	6031      	str	r1, [r6, #0]
   16560:	4651      	mov	r1, sl
   16562:	3210      	adds	r2, #16
   16564:	3301      	adds	r3, #1
   16566:	6071      	str	r1, [r6, #4]
   16568:	60ba      	str	r2, [r7, #8]
   1656a:	607b      	str	r3, [r7, #4]
   1656c:	2b07      	cmp	r3, #7
   1656e:	ddf1      	ble.n	16554 <_vfprintf_r+0x8dc>
   16570:	003a      	movs	r2, r7
   16572:	0021      	movs	r1, r4
   16574:	9807      	ldr	r0, [sp, #28]
   16576:	f005 fa9b 	bl	1bab0 <__sprint_r>
   1657a:	2800      	cmp	r0, #0
   1657c:	d000      	beq.n	16580 <_vfprintf_r+0x908>
   1657e:	e166      	b.n	1684e <_vfprintf_r+0xbd6>
   16580:	3d10      	subs	r5, #16
   16582:	68ba      	ldr	r2, [r7, #8]
   16584:	687b      	ldr	r3, [r7, #4]
   16586:	ae32      	add	r6, sp, #200	; 0xc8
   16588:	2d10      	cmp	r5, #16
   1658a:	dce7      	bgt.n	1655c <_vfprintf_r+0x8e4>
   1658c:	46a3      	mov	fp, r4
   1658e:	0014      	movs	r4, r2
   16590:	464a      	mov	r2, r9
   16592:	1964      	adds	r4, r4, r5
   16594:	3301      	adds	r3, #1
   16596:	6032      	str	r2, [r6, #0]
   16598:	6075      	str	r5, [r6, #4]
   1659a:	60bc      	str	r4, [r7, #8]
   1659c:	607b      	str	r3, [r7, #4]
   1659e:	2b07      	cmp	r3, #7
   165a0:	dd00      	ble.n	165a4 <_vfprintf_r+0x92c>
   165a2:	e1b6      	b.n	16912 <_vfprintf_r+0xc9a>
   165a4:	3608      	adds	r6, #8
   165a6:	9b08      	ldr	r3, [sp, #32]
   165a8:	05db      	lsls	r3, r3, #23
   165aa:	d500      	bpl.n	165ae <_vfprintf_r+0x936>
   165ac:	e0ba      	b.n	16724 <_vfprintf_r+0xaac>
   165ae:	9b12      	ldr	r3, [sp, #72]	; 0x48
   165b0:	6033      	str	r3, [r6, #0]
   165b2:	9b10      	ldr	r3, [sp, #64]	; 0x40
   165b4:	469c      	mov	ip, r3
   165b6:	6073      	str	r3, [r6, #4]
   165b8:	687b      	ldr	r3, [r7, #4]
   165ba:	4464      	add	r4, ip
   165bc:	3301      	adds	r3, #1
   165be:	60bc      	str	r4, [r7, #8]
   165c0:	607b      	str	r3, [r7, #4]
   165c2:	2b07      	cmp	r3, #7
   165c4:	dd00      	ble.n	165c8 <_vfprintf_r+0x950>
   165c6:	e0a2      	b.n	1670e <_vfprintf_r+0xa96>
   165c8:	3608      	adds	r6, #8
   165ca:	9b08      	ldr	r3, [sp, #32]
   165cc:	075b      	lsls	r3, r3, #29
   165ce:	d546      	bpl.n	1665e <_vfprintf_r+0x9e6>
   165d0:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   165d2:	9a09      	ldr	r2, [sp, #36]	; 0x24
   165d4:	1a9d      	subs	r5, r3, r2
   165d6:	2d00      	cmp	r5, #0
   165d8:	dd41      	ble.n	1665e <_vfprintf_r+0x9e6>
   165da:	4a08      	ldr	r2, [pc, #32]	; (165fc <_vfprintf_r+0x984>)
   165dc:	687b      	ldr	r3, [r7, #4]
   165de:	4690      	mov	r8, r2
   165e0:	2d10      	cmp	r5, #16
   165e2:	dd2b      	ble.n	1663c <_vfprintf_r+0x9c4>
   165e4:	2210      	movs	r2, #16
   165e6:	4691      	mov	r9, r2
   165e8:	0022      	movs	r2, r4
   165ea:	465c      	mov	r4, fp
   165ec:	e00c      	b.n	16608 <_vfprintf_r+0x990>
   165ee:	46c0      	nop			; (mov r8, r8)
   165f0:	00022d48 	.word	0x00022d48
   165f4:	00022d5c 	.word	0x00022d5c
   165f8:	00022d28 	.word	0x00022d28
   165fc:	00022d7c 	.word	0x00022d7c
   16600:	3d10      	subs	r5, #16
   16602:	3608      	adds	r6, #8
   16604:	2d10      	cmp	r5, #16
   16606:	dd17      	ble.n	16638 <_vfprintf_r+0x9c0>
   16608:	4641      	mov	r1, r8
   1660a:	6031      	str	r1, [r6, #0]
   1660c:	4649      	mov	r1, r9
   1660e:	3210      	adds	r2, #16
   16610:	3301      	adds	r3, #1
   16612:	6071      	str	r1, [r6, #4]
   16614:	60ba      	str	r2, [r7, #8]
   16616:	607b      	str	r3, [r7, #4]
   16618:	2b07      	cmp	r3, #7
   1661a:	ddf1      	ble.n	16600 <_vfprintf_r+0x988>
   1661c:	003a      	movs	r2, r7
   1661e:	0021      	movs	r1, r4
   16620:	9807      	ldr	r0, [sp, #28]
   16622:	f005 fa45 	bl	1bab0 <__sprint_r>
   16626:	2800      	cmp	r0, #0
   16628:	d000      	beq.n	1662c <_vfprintf_r+0x9b4>
   1662a:	e110      	b.n	1684e <_vfprintf_r+0xbd6>
   1662c:	3d10      	subs	r5, #16
   1662e:	68ba      	ldr	r2, [r7, #8]
   16630:	687b      	ldr	r3, [r7, #4]
   16632:	ae32      	add	r6, sp, #200	; 0xc8
   16634:	2d10      	cmp	r5, #16
   16636:	dce7      	bgt.n	16608 <_vfprintf_r+0x990>
   16638:	46a3      	mov	fp, r4
   1663a:	0014      	movs	r4, r2
   1663c:	4642      	mov	r2, r8
   1663e:	1964      	adds	r4, r4, r5
   16640:	3301      	adds	r3, #1
   16642:	c624      	stmia	r6!, {r2, r5}
   16644:	60bc      	str	r4, [r7, #8]
   16646:	607b      	str	r3, [r7, #4]
   16648:	2b07      	cmp	r3, #7
   1664a:	dd08      	ble.n	1665e <_vfprintf_r+0x9e6>
   1664c:	003a      	movs	r2, r7
   1664e:	4659      	mov	r1, fp
   16650:	9807      	ldr	r0, [sp, #28]
   16652:	f005 fa2d 	bl	1bab0 <__sprint_r>
   16656:	2800      	cmp	r0, #0
   16658:	d000      	beq.n	1665c <_vfprintf_r+0x9e4>
   1665a:	e126      	b.n	168aa <_vfprintf_r+0xc32>
   1665c:	68bc      	ldr	r4, [r7, #8]
   1665e:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   16660:	9a09      	ldr	r2, [sp, #36]	; 0x24
   16662:	4293      	cmp	r3, r2
   16664:	da00      	bge.n	16668 <_vfprintf_r+0x9f0>
   16666:	0013      	movs	r3, r2
   16668:	9a0c      	ldr	r2, [sp, #48]	; 0x30
   1666a:	4694      	mov	ip, r2
   1666c:	449c      	add	ip, r3
   1666e:	4663      	mov	r3, ip
   16670:	930c      	str	r3, [sp, #48]	; 0x30
   16672:	2c00      	cmp	r4, #0
   16674:	d000      	beq.n	16678 <_vfprintf_r+0xa00>
   16676:	e110      	b.n	1689a <_vfprintf_r+0xc22>
   16678:	2300      	movs	r3, #0
   1667a:	ae32      	add	r6, sp, #200	; 0xc8
   1667c:	607b      	str	r3, [r7, #4]
   1667e:	f7ff fb43 	bl	15d08 <_vfprintf_r+0x90>
   16682:	9b14      	ldr	r3, [sp, #80]	; 0x50
   16684:	2b01      	cmp	r3, #1
   16686:	dc00      	bgt.n	1668a <_vfprintf_r+0xa12>
   16688:	e0ea      	b.n	16860 <_vfprintf_r+0xbe8>
   1668a:	9b12      	ldr	r3, [sp, #72]	; 0x48
   1668c:	3401      	adds	r4, #1
   1668e:	6033      	str	r3, [r6, #0]
   16690:	2301      	movs	r3, #1
   16692:	6073      	str	r3, [r6, #4]
   16694:	687b      	ldr	r3, [r7, #4]
   16696:	60bc      	str	r4, [r7, #8]
   16698:	3301      	adds	r3, #1
   1669a:	607b      	str	r3, [r7, #4]
   1669c:	2b07      	cmp	r3, #7
   1669e:	dd00      	ble.n	166a2 <_vfprintf_r+0xa2a>
   166a0:	e2b2      	b.n	16c08 <_vfprintf_r+0xf90>
   166a2:	3608      	adds	r6, #8
   166a4:	9a19      	ldr	r2, [sp, #100]	; 0x64
   166a6:	3301      	adds	r3, #1
   166a8:	6032      	str	r2, [r6, #0]
   166aa:	9a18      	ldr	r2, [sp, #96]	; 0x60
   166ac:	4698      	mov	r8, r3
   166ae:	4694      	mov	ip, r2
   166b0:	4464      	add	r4, ip
   166b2:	6072      	str	r2, [r6, #4]
   166b4:	60bc      	str	r4, [r7, #8]
   166b6:	607b      	str	r3, [r7, #4]
   166b8:	2b07      	cmp	r3, #7
   166ba:	dd00      	ble.n	166be <_vfprintf_r+0xa46>
   166bc:	e2b8      	b.n	16c30 <_vfprintf_r+0xfb8>
   166be:	3608      	adds	r6, #8
   166c0:	2200      	movs	r2, #0
   166c2:	2300      	movs	r3, #0
   166c4:	9816      	ldr	r0, [sp, #88]	; 0x58
   166c6:	9917      	ldr	r1, [sp, #92]	; 0x5c
   166c8:	f007 fb74 	bl	1ddb4 <__aeabi_dcmpeq>
   166cc:	2800      	cmp	r0, #0
   166ce:	d000      	beq.n	166d2 <_vfprintf_r+0xa5a>
   166d0:	e1d1      	b.n	16a76 <_vfprintf_r+0xdfe>
   166d2:	9d12      	ldr	r5, [sp, #72]	; 0x48
   166d4:	9b14      	ldr	r3, [sp, #80]	; 0x50
   166d6:	3501      	adds	r5, #1
   166d8:	3b01      	subs	r3, #1
   166da:	6035      	str	r5, [r6, #0]
   166dc:	6073      	str	r3, [r6, #4]
   166de:	18e4      	adds	r4, r4, r3
   166e0:	2301      	movs	r3, #1
   166e2:	469c      	mov	ip, r3
   166e4:	44e0      	add	r8, ip
   166e6:	4643      	mov	r3, r8
   166e8:	60bc      	str	r4, [r7, #8]
   166ea:	607b      	str	r3, [r7, #4]
   166ec:	2b07      	cmp	r3, #7
   166ee:	dd00      	ble.n	166f2 <_vfprintf_r+0xa7a>
   166f0:	e0c7      	b.n	16882 <_vfprintf_r+0xc0a>
   166f2:	3608      	adds	r6, #8
   166f4:	ab21      	add	r3, sp, #132	; 0x84
   166f6:	6033      	str	r3, [r6, #0]
   166f8:	9b1a      	ldr	r3, [sp, #104]	; 0x68
   166fa:	469c      	mov	ip, r3
   166fc:	6073      	str	r3, [r6, #4]
   166fe:	4643      	mov	r3, r8
   16700:	4464      	add	r4, ip
   16702:	3301      	adds	r3, #1
   16704:	60bc      	str	r4, [r7, #8]
   16706:	607b      	str	r3, [r7, #4]
   16708:	2b07      	cmp	r3, #7
   1670a:	dc00      	bgt.n	1670e <_vfprintf_r+0xa96>
   1670c:	e75c      	b.n	165c8 <_vfprintf_r+0x950>
   1670e:	003a      	movs	r2, r7
   16710:	4659      	mov	r1, fp
   16712:	9807      	ldr	r0, [sp, #28]
   16714:	f005 f9cc 	bl	1bab0 <__sprint_r>
   16718:	2800      	cmp	r0, #0
   1671a:	d000      	beq.n	1671e <_vfprintf_r+0xaa6>
   1671c:	e0c5      	b.n	168aa <_vfprintf_r+0xc32>
   1671e:	68bc      	ldr	r4, [r7, #8]
   16720:	ae32      	add	r6, sp, #200	; 0xc8
   16722:	e752      	b.n	165ca <_vfprintf_r+0x952>
   16724:	9b13      	ldr	r3, [sp, #76]	; 0x4c
   16726:	2b65      	cmp	r3, #101	; 0x65
   16728:	ddab      	ble.n	16682 <_vfprintf_r+0xa0a>
   1672a:	2200      	movs	r2, #0
   1672c:	2300      	movs	r3, #0
   1672e:	9816      	ldr	r0, [sp, #88]	; 0x58
   16730:	9917      	ldr	r1, [sp, #92]	; 0x5c
   16732:	f007 fb3f 	bl	1ddb4 <__aeabi_dcmpeq>
   16736:	2800      	cmp	r0, #0
   16738:	d100      	bne.n	1673c <_vfprintf_r+0xac4>
   1673a:	e108      	b.n	1694e <_vfprintf_r+0xcd6>
   1673c:	4bd6      	ldr	r3, [pc, #856]	; (16a98 <_vfprintf_r+0xe20>)
   1673e:	3401      	adds	r4, #1
   16740:	6033      	str	r3, [r6, #0]
   16742:	2301      	movs	r3, #1
   16744:	6073      	str	r3, [r6, #4]
   16746:	687b      	ldr	r3, [r7, #4]
   16748:	60bc      	str	r4, [r7, #8]
   1674a:	3301      	adds	r3, #1
   1674c:	607b      	str	r3, [r7, #4]
   1674e:	2b07      	cmp	r3, #7
   16750:	dd00      	ble.n	16754 <_vfprintf_r+0xadc>
   16752:	e37a      	b.n	16e4a <_vfprintf_r+0x11d2>
   16754:	3608      	adds	r6, #8
   16756:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   16758:	9a14      	ldr	r2, [sp, #80]	; 0x50
   1675a:	4293      	cmp	r3, r2
   1675c:	db03      	blt.n	16766 <_vfprintf_r+0xaee>
   1675e:	9b08      	ldr	r3, [sp, #32]
   16760:	07db      	lsls	r3, r3, #31
   16762:	d400      	bmi.n	16766 <_vfprintf_r+0xaee>
   16764:	e731      	b.n	165ca <_vfprintf_r+0x952>
   16766:	9b19      	ldr	r3, [sp, #100]	; 0x64
   16768:	6033      	str	r3, [r6, #0]
   1676a:	9b18      	ldr	r3, [sp, #96]	; 0x60
   1676c:	469c      	mov	ip, r3
   1676e:	6073      	str	r3, [r6, #4]
   16770:	687b      	ldr	r3, [r7, #4]
   16772:	4464      	add	r4, ip
   16774:	3301      	adds	r3, #1
   16776:	60bc      	str	r4, [r7, #8]
   16778:	607b      	str	r3, [r7, #4]
   1677a:	2b07      	cmp	r3, #7
   1677c:	dd01      	ble.n	16782 <_vfprintf_r+0xb0a>
   1677e:	f000 fc52 	bl	17026 <_vfprintf_r+0x13ae>
   16782:	3608      	adds	r6, #8
   16784:	9b14      	ldr	r3, [sp, #80]	; 0x50
   16786:	1e5d      	subs	r5, r3, #1
   16788:	2d00      	cmp	r5, #0
   1678a:	dc00      	bgt.n	1678e <_vfprintf_r+0xb16>
   1678c:	e71d      	b.n	165ca <_vfprintf_r+0x952>
   1678e:	4ac3      	ldr	r2, [pc, #780]	; (16a9c <_vfprintf_r+0xe24>)
   16790:	687b      	ldr	r3, [r7, #4]
   16792:	4691      	mov	r9, r2
   16794:	2d10      	cmp	r5, #16
   16796:	dc00      	bgt.n	1679a <_vfprintf_r+0xb22>
   16798:	e19f      	b.n	16ada <_vfprintf_r+0xe62>
   1679a:	2210      	movs	r2, #16
   1679c:	4690      	mov	r8, r2
   1679e:	0022      	movs	r2, r4
   167a0:	464c      	mov	r4, r9
   167a2:	46d9      	mov	r9, fp
   167a4:	e004      	b.n	167b0 <_vfprintf_r+0xb38>
   167a6:	3608      	adds	r6, #8
   167a8:	3d10      	subs	r5, #16
   167aa:	2d10      	cmp	r5, #16
   167ac:	dc00      	bgt.n	167b0 <_vfprintf_r+0xb38>
   167ae:	e348      	b.n	16e42 <_vfprintf_r+0x11ca>
   167b0:	4641      	mov	r1, r8
   167b2:	3210      	adds	r2, #16
   167b4:	3301      	adds	r3, #1
   167b6:	6034      	str	r4, [r6, #0]
   167b8:	6071      	str	r1, [r6, #4]
   167ba:	60ba      	str	r2, [r7, #8]
   167bc:	607b      	str	r3, [r7, #4]
   167be:	2b07      	cmp	r3, #7
   167c0:	ddf1      	ble.n	167a6 <_vfprintf_r+0xb2e>
   167c2:	003a      	movs	r2, r7
   167c4:	4649      	mov	r1, r9
   167c6:	9807      	ldr	r0, [sp, #28]
   167c8:	f005 f972 	bl	1bab0 <__sprint_r>
   167cc:	2800      	cmp	r0, #0
   167ce:	d001      	beq.n	167d4 <_vfprintf_r+0xb5c>
   167d0:	f000 fd0f 	bl	171f2 <_vfprintf_r+0x157a>
   167d4:	68ba      	ldr	r2, [r7, #8]
   167d6:	687b      	ldr	r3, [r7, #4]
   167d8:	ae32      	add	r6, sp, #200	; 0xc8
   167da:	e7e5      	b.n	167a8 <_vfprintf_r+0xb30>
   167dc:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   167de:	9a09      	ldr	r2, [sp, #36]	; 0x24
   167e0:	1a9d      	subs	r5, r3, r2
   167e2:	2d00      	cmp	r5, #0
   167e4:	dc00      	bgt.n	167e8 <_vfprintf_r+0xb70>
   167e6:	e6a6      	b.n	16536 <_vfprintf_r+0x8be>
   167e8:	4aac      	ldr	r2, [pc, #688]	; (16a9c <_vfprintf_r+0xe24>)
   167ea:	687b      	ldr	r3, [r7, #4]
   167ec:	4691      	mov	r9, r2
   167ee:	2d10      	cmp	r5, #16
   167f0:	dd21      	ble.n	16836 <_vfprintf_r+0xbbe>
   167f2:	2210      	movs	r2, #16
   167f4:	4692      	mov	sl, r2
   167f6:	0022      	movs	r2, r4
   167f8:	465c      	mov	r4, fp
   167fa:	e003      	b.n	16804 <_vfprintf_r+0xb8c>
   167fc:	3d10      	subs	r5, #16
   167fe:	3608      	adds	r6, #8
   16800:	2d10      	cmp	r5, #16
   16802:	dd16      	ble.n	16832 <_vfprintf_r+0xbba>
   16804:	4649      	mov	r1, r9
   16806:	6031      	str	r1, [r6, #0]
   16808:	4651      	mov	r1, sl
   1680a:	3210      	adds	r2, #16
   1680c:	3301      	adds	r3, #1
   1680e:	6071      	str	r1, [r6, #4]
   16810:	60ba      	str	r2, [r7, #8]
   16812:	607b      	str	r3, [r7, #4]
   16814:	2b07      	cmp	r3, #7
   16816:	ddf1      	ble.n	167fc <_vfprintf_r+0xb84>
   16818:	003a      	movs	r2, r7
   1681a:	0021      	movs	r1, r4
   1681c:	9807      	ldr	r0, [sp, #28]
   1681e:	f005 f947 	bl	1bab0 <__sprint_r>
   16822:	2800      	cmp	r0, #0
   16824:	d113      	bne.n	1684e <_vfprintf_r+0xbd6>
   16826:	3d10      	subs	r5, #16
   16828:	68ba      	ldr	r2, [r7, #8]
   1682a:	687b      	ldr	r3, [r7, #4]
   1682c:	ae32      	add	r6, sp, #200	; 0xc8
   1682e:	2d10      	cmp	r5, #16
   16830:	dce8      	bgt.n	16804 <_vfprintf_r+0xb8c>
   16832:	46a3      	mov	fp, r4
   16834:	0014      	movs	r4, r2
   16836:	464a      	mov	r2, r9
   16838:	1964      	adds	r4, r4, r5
   1683a:	3301      	adds	r3, #1
   1683c:	6032      	str	r2, [r6, #0]
   1683e:	6075      	str	r5, [r6, #4]
   16840:	60bc      	str	r4, [r7, #8]
   16842:	607b      	str	r3, [r7, #4]
   16844:	2b07      	cmp	r3, #7
   16846:	dd00      	ble.n	1684a <_vfprintf_r+0xbd2>
   16848:	e1ff      	b.n	16c4a <_vfprintf_r+0xfd2>
   1684a:	3608      	adds	r6, #8
   1684c:	e673      	b.n	16536 <_vfprintf_r+0x8be>
   1684e:	46a0      	mov	r8, r4
   16850:	4643      	mov	r3, r8
   16852:	899b      	ldrh	r3, [r3, #12]
   16854:	065b      	lsls	r3, r3, #25
   16856:	d500      	bpl.n	1685a <_vfprintf_r+0xbe2>
   16858:	e350      	b.n	16efc <_vfprintf_r+0x1284>
   1685a:	980c      	ldr	r0, [sp, #48]	; 0x30
   1685c:	f7ff faee 	bl	15e3c <_vfprintf_r+0x1c4>
   16860:	2301      	movs	r3, #1
   16862:	9a08      	ldr	r2, [sp, #32]
   16864:	4213      	tst	r3, r2
   16866:	d000      	beq.n	1686a <_vfprintf_r+0xbf2>
   16868:	e70f      	b.n	1668a <_vfprintf_r+0xa12>
   1686a:	6073      	str	r3, [r6, #4]
   1686c:	687b      	ldr	r3, [r7, #4]
   1686e:	9a12      	ldr	r2, [sp, #72]	; 0x48
   16870:	3301      	adds	r3, #1
   16872:	3401      	adds	r4, #1
   16874:	6032      	str	r2, [r6, #0]
   16876:	60bc      	str	r4, [r7, #8]
   16878:	4698      	mov	r8, r3
   1687a:	607b      	str	r3, [r7, #4]
   1687c:	2b07      	cmp	r3, #7
   1687e:	dc00      	bgt.n	16882 <_vfprintf_r+0xc0a>
   16880:	e737      	b.n	166f2 <_vfprintf_r+0xa7a>
   16882:	003a      	movs	r2, r7
   16884:	4659      	mov	r1, fp
   16886:	9807      	ldr	r0, [sp, #28]
   16888:	f005 f912 	bl	1bab0 <__sprint_r>
   1688c:	2800      	cmp	r0, #0
   1688e:	d10c      	bne.n	168aa <_vfprintf_r+0xc32>
   16890:	687b      	ldr	r3, [r7, #4]
   16892:	68bc      	ldr	r4, [r7, #8]
   16894:	4698      	mov	r8, r3
   16896:	ae32      	add	r6, sp, #200	; 0xc8
   16898:	e72c      	b.n	166f4 <_vfprintf_r+0xa7c>
   1689a:	003a      	movs	r2, r7
   1689c:	4659      	mov	r1, fp
   1689e:	9807      	ldr	r0, [sp, #28]
   168a0:	f005 f906 	bl	1bab0 <__sprint_r>
   168a4:	2800      	cmp	r0, #0
   168a6:	d100      	bne.n	168aa <_vfprintf_r+0xc32>
   168a8:	e6e6      	b.n	16678 <_vfprintf_r+0xa00>
   168aa:	46d8      	mov	r8, fp
   168ac:	e7d0      	b.n	16850 <_vfprintf_r+0xbd8>
   168ae:	2210      	movs	r2, #16
   168b0:	9908      	ldr	r1, [sp, #32]
   168b2:	400a      	ands	r2, r1
   168b4:	d100      	bne.n	168b8 <_vfprintf_r+0xc40>
   168b6:	e11b      	b.n	16af0 <_vfprintf_r+0xe78>
   168b8:	9811      	ldr	r0, [sp, #68]	; 0x44
   168ba:	0002      	movs	r2, r0
   168bc:	6800      	ldr	r0, [r0, #0]
   168be:	3204      	adds	r2, #4
   168c0:	900e      	str	r0, [sp, #56]	; 0x38
   168c2:	2000      	movs	r0, #0
   168c4:	900f      	str	r0, [sp, #60]	; 0x3c
   168c6:	a816      	add	r0, sp, #88	; 0x58
   168c8:	77c3      	strb	r3, [r0, #31]
   168ca:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   168cc:	2b00      	cmp	r3, #0
   168ce:	da00      	bge.n	168d2 <_vfprintf_r+0xc5a>
   168d0:	e120      	b.n	16b14 <_vfprintf_r+0xe9c>
   168d2:	2380      	movs	r3, #128	; 0x80
   168d4:	4399      	bics	r1, r3
   168d6:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   168d8:	9108      	str	r1, [sp, #32]
   168da:	9211      	str	r2, [sp, #68]	; 0x44
   168dc:	2b00      	cmp	r3, #0
   168de:	d000      	beq.n	168e2 <_vfprintf_r+0xc6a>
   168e0:	e4a5      	b.n	1622e <_vfprintf_r+0x5b6>
   168e2:	4698      	mov	r8, r3
   168e4:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   168e6:	2b00      	cmp	r3, #0
   168e8:	d100      	bne.n	168ec <_vfprintf_r+0xc74>
   168ea:	e5a4      	b.n	16436 <_vfprintf_r+0x7be>
   168ec:	2300      	movs	r3, #0
   168ee:	2400      	movs	r4, #0
   168f0:	930e      	str	r3, [sp, #56]	; 0x38
   168f2:	940f      	str	r4, [sp, #60]	; 0x3c
   168f4:	2227      	movs	r2, #39	; 0x27
   168f6:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   168f8:	a928      	add	r1, sp, #160	; 0xa0
   168fa:	3330      	adds	r3, #48	; 0x30
   168fc:	548b      	strb	r3, [r1, r2]
   168fe:	ab16      	add	r3, sp, #88	; 0x58
   16900:	469c      	mov	ip, r3
   16902:	256f      	movs	r5, #111	; 0x6f
   16904:	ab32      	add	r3, sp, #200	; 0xc8
   16906:	4465      	add	r5, ip
   16908:	1b5b      	subs	r3, r3, r5
   1690a:	9310      	str	r3, [sp, #64]	; 0x40
   1690c:	9512      	str	r5, [sp, #72]	; 0x48
   1690e:	f7ff fc05 	bl	1611c <_vfprintf_r+0x4a4>
   16912:	003a      	movs	r2, r7
   16914:	4659      	mov	r1, fp
   16916:	9807      	ldr	r0, [sp, #28]
   16918:	f005 f8ca 	bl	1bab0 <__sprint_r>
   1691c:	2800      	cmp	r0, #0
   1691e:	d1c4      	bne.n	168aa <_vfprintf_r+0xc32>
   16920:	68bc      	ldr	r4, [r7, #8]
   16922:	ae32      	add	r6, sp, #200	; 0xc8
   16924:	e63f      	b.n	165a6 <_vfprintf_r+0x92e>
   16926:	003a      	movs	r2, r7
   16928:	4659      	mov	r1, fp
   1692a:	9807      	ldr	r0, [sp, #28]
   1692c:	f005 f8c0 	bl	1bab0 <__sprint_r>
   16930:	2800      	cmp	r0, #0
   16932:	d1ba      	bne.n	168aa <_vfprintf_r+0xc32>
   16934:	68bc      	ldr	r4, [r7, #8]
   16936:	ae32      	add	r6, sp, #200	; 0xc8
   16938:	e5e9      	b.n	1650e <_vfprintf_r+0x896>
   1693a:	003a      	movs	r2, r7
   1693c:	4659      	mov	r1, fp
   1693e:	9807      	ldr	r0, [sp, #28]
   16940:	f005 f8b6 	bl	1bab0 <__sprint_r>
   16944:	2800      	cmp	r0, #0
   16946:	d1b0      	bne.n	168aa <_vfprintf_r+0xc32>
   16948:	68bc      	ldr	r4, [r7, #8]
   1694a:	ae32      	add	r6, sp, #200	; 0xc8
   1694c:	e5ef      	b.n	1652e <_vfprintf_r+0x8b6>
   1694e:	981f      	ldr	r0, [sp, #124]	; 0x7c
   16950:	2800      	cmp	r0, #0
   16952:	dc00      	bgt.n	16956 <_vfprintf_r+0xcde>
   16954:	e284      	b.n	16e60 <_vfprintf_r+0x11e8>
   16956:	9a15      	ldr	r2, [sp, #84]	; 0x54
   16958:	9914      	ldr	r1, [sp, #80]	; 0x50
   1695a:	0013      	movs	r3, r2
   1695c:	4691      	mov	r9, r2
   1695e:	428b      	cmp	r3, r1
   16960:	dd00      	ble.n	16964 <_vfprintf_r+0xcec>
   16962:	4689      	mov	r9, r1
   16964:	464b      	mov	r3, r9
   16966:	2b00      	cmp	r3, #0
   16968:	dd0c      	ble.n	16984 <_vfprintf_r+0xd0c>
   1696a:	9b12      	ldr	r3, [sp, #72]	; 0x48
   1696c:	444c      	add	r4, r9
   1696e:	6033      	str	r3, [r6, #0]
   16970:	464b      	mov	r3, r9
   16972:	6073      	str	r3, [r6, #4]
   16974:	687b      	ldr	r3, [r7, #4]
   16976:	60bc      	str	r4, [r7, #8]
   16978:	3301      	adds	r3, #1
   1697a:	607b      	str	r3, [r7, #4]
   1697c:	2b07      	cmp	r3, #7
   1697e:	dd00      	ble.n	16982 <_vfprintf_r+0xd0a>
   16980:	e3a4      	b.n	170cc <_vfprintf_r+0x1454>
   16982:	3608      	adds	r6, #8
   16984:	464b      	mov	r3, r9
   16986:	43db      	mvns	r3, r3
   16988:	464a      	mov	r2, r9
   1698a:	17db      	asrs	r3, r3, #31
   1698c:	4013      	ands	r3, r2
   1698e:	9a15      	ldr	r2, [sp, #84]	; 0x54
   16990:	1ad3      	subs	r3, r2, r3
   16992:	4698      	mov	r8, r3
   16994:	2b00      	cmp	r3, #0
   16996:	dc00      	bgt.n	1699a <_vfprintf_r+0xd22>
   16998:	e0d7      	b.n	16b4a <_vfprintf_r+0xed2>
   1699a:	2b10      	cmp	r3, #16
   1699c:	dc01      	bgt.n	169a2 <_vfprintf_r+0xd2a>
   1699e:	f000 fd19 	bl	173d4 <_vfprintf_r+0x175c>
   169a2:	4a3e      	ldr	r2, [pc, #248]	; (16a9c <_vfprintf_r+0xe24>)
   169a4:	687b      	ldr	r3, [r7, #4]
   169a6:	4691      	mov	r9, r2
   169a8:	2210      	movs	r2, #16
   169aa:	464d      	mov	r5, r9
   169ac:	4692      	mov	sl, r2
   169ae:	0022      	movs	r2, r4
   169b0:	4644      	mov	r4, r8
   169b2:	46d8      	mov	r8, fp
   169b4:	e004      	b.n	169c0 <_vfprintf_r+0xd48>
   169b6:	3608      	adds	r6, #8
   169b8:	3c10      	subs	r4, #16
   169ba:	2c10      	cmp	r4, #16
   169bc:	dc00      	bgt.n	169c0 <_vfprintf_r+0xd48>
   169be:	e0b4      	b.n	16b2a <_vfprintf_r+0xeb2>
   169c0:	4651      	mov	r1, sl
   169c2:	3210      	adds	r2, #16
   169c4:	3301      	adds	r3, #1
   169c6:	6035      	str	r5, [r6, #0]
   169c8:	6071      	str	r1, [r6, #4]
   169ca:	60ba      	str	r2, [r7, #8]
   169cc:	607b      	str	r3, [r7, #4]
   169ce:	2b07      	cmp	r3, #7
   169d0:	ddf1      	ble.n	169b6 <_vfprintf_r+0xd3e>
   169d2:	003a      	movs	r2, r7
   169d4:	4641      	mov	r1, r8
   169d6:	9807      	ldr	r0, [sp, #28]
   169d8:	f005 f86a 	bl	1bab0 <__sprint_r>
   169dc:	2800      	cmp	r0, #0
   169de:	d000      	beq.n	169e2 <_vfprintf_r+0xd6a>
   169e0:	e736      	b.n	16850 <_vfprintf_r+0xbd8>
   169e2:	68ba      	ldr	r2, [r7, #8]
   169e4:	687b      	ldr	r3, [r7, #4]
   169e6:	ae32      	add	r6, sp, #200	; 0xc8
   169e8:	e7e6      	b.n	169b8 <_vfprintf_r+0xd40>
   169ea:	003a      	movs	r2, r7
   169ec:	4659      	mov	r1, fp
   169ee:	9807      	ldr	r0, [sp, #28]
   169f0:	f005 f85e 	bl	1bab0 <__sprint_r>
   169f4:	2800      	cmp	r0, #0
   169f6:	d000      	beq.n	169fa <_vfprintf_r+0xd82>
   169f8:	e757      	b.n	168aa <_vfprintf_r+0xc32>
   169fa:	ab16      	add	r3, sp, #88	; 0x58
   169fc:	7fdb      	ldrb	r3, [r3, #31]
   169fe:	68bc      	ldr	r4, [r7, #8]
   16a00:	4698      	mov	r8, r3
   16a02:	ae32      	add	r6, sp, #200	; 0xc8
   16a04:	e570      	b.n	164e8 <_vfprintf_r+0x870>
   16a06:	46b0      	mov	r8, r6
   16a08:	e722      	b.n	16850 <_vfprintf_r+0xbd8>
   16a0a:	2210      	movs	r2, #16
   16a0c:	9908      	ldr	r1, [sp, #32]
   16a0e:	400a      	ands	r2, r1
   16a10:	d100      	bne.n	16a14 <_vfprintf_r+0xd9c>
   16a12:	e13b      	b.n	16c8c <_vfprintf_r+0x1014>
   16a14:	9811      	ldr	r0, [sp, #68]	; 0x44
   16a16:	0002      	movs	r2, r0
   16a18:	6800      	ldr	r0, [r0, #0]
   16a1a:	3204      	adds	r2, #4
   16a1c:	900e      	str	r0, [sp, #56]	; 0x38
   16a1e:	2000      	movs	r0, #0
   16a20:	900f      	str	r0, [sp, #60]	; 0x3c
   16a22:	a816      	add	r0, sp, #88	; 0x58
   16a24:	77c3      	strb	r3, [r0, #31]
   16a26:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   16a28:	2b00      	cmp	r3, #0
   16a2a:	da00      	bge.n	16a2e <_vfprintf_r+0xdb6>
   16a2c:	e13f      	b.n	16cae <_vfprintf_r+0x1036>
   16a2e:	2380      	movs	r3, #128	; 0x80
   16a30:	4399      	bics	r1, r3
   16a32:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   16a34:	9108      	str	r1, [sp, #32]
   16a36:	9211      	str	r2, [sp, #68]	; 0x44
   16a38:	2b00      	cmp	r3, #0
   16a3a:	d001      	beq.n	16a40 <_vfprintf_r+0xdc8>
   16a3c:	f7ff fb43 	bl	160c6 <_vfprintf_r+0x44e>
   16a40:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   16a42:	2b00      	cmp	r3, #0
   16a44:	d101      	bne.n	16a4a <_vfprintf_r+0xdd2>
   16a46:	f000 fc6b 	bl	17320 <_vfprintf_r+0x16a8>
   16a4a:	2300      	movs	r3, #0
   16a4c:	4698      	mov	r8, r3
   16a4e:	2300      	movs	r3, #0
   16a50:	2400      	movs	r4, #0
   16a52:	930e      	str	r3, [sp, #56]	; 0x38
   16a54:	940f      	str	r4, [sp, #60]	; 0x3c
   16a56:	f7ff fb38 	bl	160ca <_vfprintf_r+0x452>
   16a5a:	9b08      	ldr	r3, [sp, #32]
   16a5c:	06db      	lsls	r3, r3, #27
   16a5e:	d400      	bmi.n	16a62 <_vfprintf_r+0xdea>
   16a60:	e130      	b.n	16cc4 <_vfprintf_r+0x104c>
   16a62:	9a11      	ldr	r2, [sp, #68]	; 0x44
   16a64:	6813      	ldr	r3, [r2, #0]
   16a66:	9309      	str	r3, [sp, #36]	; 0x24
   16a68:	930e      	str	r3, [sp, #56]	; 0x38
   16a6a:	3204      	adds	r2, #4
   16a6c:	17db      	asrs	r3, r3, #31
   16a6e:	930f      	str	r3, [sp, #60]	; 0x3c
   16a70:	9211      	str	r2, [sp, #68]	; 0x44
   16a72:	f7ff fa63 	bl	15f3c <_vfprintf_r+0x2c4>
   16a76:	9b14      	ldr	r3, [sp, #80]	; 0x50
   16a78:	1e5d      	subs	r5, r3, #1
   16a7a:	2d00      	cmp	r5, #0
   16a7c:	dc00      	bgt.n	16a80 <_vfprintf_r+0xe08>
   16a7e:	e639      	b.n	166f4 <_vfprintf_r+0xa7c>
   16a80:	4b06      	ldr	r3, [pc, #24]	; (16a9c <_vfprintf_r+0xe24>)
   16a82:	4699      	mov	r9, r3
   16a84:	2d10      	cmp	r5, #16
   16a86:	dc00      	bgt.n	16a8a <_vfprintf_r+0xe12>
   16a88:	e0cd      	b.n	16c26 <_vfprintf_r+0xfae>
   16a8a:	2310      	movs	r3, #16
   16a8c:	0022      	movs	r2, r4
   16a8e:	469a      	mov	sl, r3
   16a90:	465c      	mov	r4, fp
   16a92:	4643      	mov	r3, r8
   16a94:	e009      	b.n	16aaa <_vfprintf_r+0xe32>
   16a96:	46c0      	nop			; (mov r8, r8)
   16a98:	00022d78 	.word	0x00022d78
   16a9c:	00022d28 	.word	0x00022d28
   16aa0:	3608      	adds	r6, #8
   16aa2:	3d10      	subs	r5, #16
   16aa4:	2d10      	cmp	r5, #16
   16aa6:	dc00      	bgt.n	16aaa <_vfprintf_r+0xe32>
   16aa8:	e0ba      	b.n	16c20 <_vfprintf_r+0xfa8>
   16aaa:	4649      	mov	r1, r9
   16aac:	6031      	str	r1, [r6, #0]
   16aae:	4651      	mov	r1, sl
   16ab0:	3210      	adds	r2, #16
   16ab2:	3301      	adds	r3, #1
   16ab4:	6071      	str	r1, [r6, #4]
   16ab6:	60ba      	str	r2, [r7, #8]
   16ab8:	607b      	str	r3, [r7, #4]
   16aba:	2b07      	cmp	r3, #7
   16abc:	ddf0      	ble.n	16aa0 <_vfprintf_r+0xe28>
   16abe:	003a      	movs	r2, r7
   16ac0:	0021      	movs	r1, r4
   16ac2:	9807      	ldr	r0, [sp, #28]
   16ac4:	f004 fff4 	bl	1bab0 <__sprint_r>
   16ac8:	2800      	cmp	r0, #0
   16aca:	d000      	beq.n	16ace <_vfprintf_r+0xe56>
   16acc:	e6bf      	b.n	1684e <_vfprintf_r+0xbd6>
   16ace:	68ba      	ldr	r2, [r7, #8]
   16ad0:	687b      	ldr	r3, [r7, #4]
   16ad2:	ae32      	add	r6, sp, #200	; 0xc8
   16ad4:	e7e5      	b.n	16aa2 <_vfprintf_r+0xe2a>
   16ad6:	46a3      	mov	fp, r4
   16ad8:	0014      	movs	r4, r2
   16ada:	464a      	mov	r2, r9
   16adc:	1964      	adds	r4, r4, r5
   16ade:	3301      	adds	r3, #1
   16ae0:	6032      	str	r2, [r6, #0]
   16ae2:	6075      	str	r5, [r6, #4]
   16ae4:	60bc      	str	r4, [r7, #8]
   16ae6:	607b      	str	r3, [r7, #4]
   16ae8:	2b07      	cmp	r3, #7
   16aea:	dc00      	bgt.n	16aee <_vfprintf_r+0xe76>
   16aec:	e56c      	b.n	165c8 <_vfprintf_r+0x950>
   16aee:	e60e      	b.n	1670e <_vfprintf_r+0xa96>
   16af0:	2340      	movs	r3, #64	; 0x40
   16af2:	9908      	ldr	r1, [sp, #32]
   16af4:	400b      	ands	r3, r1
   16af6:	d000      	beq.n	16afa <_vfprintf_r+0xe82>
   16af8:	e230      	b.n	16f5c <_vfprintf_r+0x12e4>
   16afa:	9911      	ldr	r1, [sp, #68]	; 0x44
   16afc:	000a      	movs	r2, r1
   16afe:	6809      	ldr	r1, [r1, #0]
   16b00:	3204      	adds	r2, #4
   16b02:	910e      	str	r1, [sp, #56]	; 0x38
   16b04:	2100      	movs	r1, #0
   16b06:	910f      	str	r1, [sp, #60]	; 0x3c
   16b08:	a916      	add	r1, sp, #88	; 0x58
   16b0a:	77cb      	strb	r3, [r1, #31]
   16b0c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   16b0e:	2b00      	cmp	r3, #0
   16b10:	db00      	blt.n	16b14 <_vfprintf_r+0xe9c>
   16b12:	e0df      	b.n	16cd4 <_vfprintf_r+0x105c>
   16b14:	9211      	str	r2, [sp, #68]	; 0x44
   16b16:	2300      	movs	r3, #0
   16b18:	4698      	mov	r8, r3
   16b1a:	9a0e      	ldr	r2, [sp, #56]	; 0x38
   16b1c:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   16b1e:	0011      	movs	r1, r2
   16b20:	4319      	orrs	r1, r3
   16b22:	d001      	beq.n	16b28 <_vfprintf_r+0xeb0>
   16b24:	f7ff fa21 	bl	15f6a <_vfprintf_r+0x2f2>
   16b28:	e6e0      	b.n	168ec <_vfprintf_r+0xc74>
   16b2a:	46c3      	mov	fp, r8
   16b2c:	46a9      	mov	r9, r5
   16b2e:	46a0      	mov	r8, r4
   16b30:	0014      	movs	r4, r2
   16b32:	464a      	mov	r2, r9
   16b34:	6032      	str	r2, [r6, #0]
   16b36:	4642      	mov	r2, r8
   16b38:	4444      	add	r4, r8
   16b3a:	3301      	adds	r3, #1
   16b3c:	6072      	str	r2, [r6, #4]
   16b3e:	60bc      	str	r4, [r7, #8]
   16b40:	607b      	str	r3, [r7, #4]
   16b42:	2b07      	cmp	r3, #7
   16b44:	dd00      	ble.n	16b48 <_vfprintf_r+0xed0>
   16b46:	e36a      	b.n	1721e <_vfprintf_r+0x15a6>
   16b48:	3608      	adds	r6, #8
   16b4a:	9a12      	ldr	r2, [sp, #72]	; 0x48
   16b4c:	9b15      	ldr	r3, [sp, #84]	; 0x54
   16b4e:	4694      	mov	ip, r2
   16b50:	4463      	add	r3, ip
   16b52:	4698      	mov	r8, r3
   16b54:	9a14      	ldr	r2, [sp, #80]	; 0x50
   16b56:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   16b58:	4293      	cmp	r3, r2
   16b5a:	db46      	blt.n	16bea <_vfprintf_r+0xf72>
   16b5c:	9a08      	ldr	r2, [sp, #32]
   16b5e:	07d2      	lsls	r2, r2, #31
   16b60:	d443      	bmi.n	16bea <_vfprintf_r+0xf72>
   16b62:	9a12      	ldr	r2, [sp, #72]	; 0x48
   16b64:	9914      	ldr	r1, [sp, #80]	; 0x50
   16b66:	0015      	movs	r5, r2
   16b68:	468c      	mov	ip, r1
   16b6a:	4642      	mov	r2, r8
   16b6c:	4465      	add	r5, ip
   16b6e:	1acb      	subs	r3, r1, r3
   16b70:	1aad      	subs	r5, r5, r2
   16b72:	429d      	cmp	r5, r3
   16b74:	dd00      	ble.n	16b78 <_vfprintf_r+0xf00>
   16b76:	001d      	movs	r5, r3
   16b78:	2d00      	cmp	r5, #0
   16b7a:	dd0b      	ble.n	16b94 <_vfprintf_r+0xf1c>
   16b7c:	4642      	mov	r2, r8
   16b7e:	6032      	str	r2, [r6, #0]
   16b80:	687a      	ldr	r2, [r7, #4]
   16b82:	1964      	adds	r4, r4, r5
   16b84:	3201      	adds	r2, #1
   16b86:	6075      	str	r5, [r6, #4]
   16b88:	60bc      	str	r4, [r7, #8]
   16b8a:	607a      	str	r2, [r7, #4]
   16b8c:	2a07      	cmp	r2, #7
   16b8e:	dd00      	ble.n	16b92 <_vfprintf_r+0xf1a>
   16b90:	e31c      	b.n	171cc <_vfprintf_r+0x1554>
   16b92:	3608      	adds	r6, #8
   16b94:	43ea      	mvns	r2, r5
   16b96:	17d2      	asrs	r2, r2, #31
   16b98:	4015      	ands	r5, r2
   16b9a:	1b5d      	subs	r5, r3, r5
   16b9c:	2d00      	cmp	r5, #0
   16b9e:	dc00      	bgt.n	16ba2 <_vfprintf_r+0xf2a>
   16ba0:	e513      	b.n	165ca <_vfprintf_r+0x952>
   16ba2:	4ad8      	ldr	r2, [pc, #864]	; (16f04 <_vfprintf_r+0x128c>)
   16ba4:	687b      	ldr	r3, [r7, #4]
   16ba6:	4691      	mov	r9, r2
   16ba8:	2d10      	cmp	r5, #16
   16baa:	dd96      	ble.n	16ada <_vfprintf_r+0xe62>
   16bac:	2210      	movs	r2, #16
   16bae:	4690      	mov	r8, r2
   16bb0:	0022      	movs	r2, r4
   16bb2:	465c      	mov	r4, fp
   16bb4:	e003      	b.n	16bbe <_vfprintf_r+0xf46>
   16bb6:	3608      	adds	r6, #8
   16bb8:	3d10      	subs	r5, #16
   16bba:	2d10      	cmp	r5, #16
   16bbc:	dd8b      	ble.n	16ad6 <_vfprintf_r+0xe5e>
   16bbe:	4649      	mov	r1, r9
   16bc0:	6031      	str	r1, [r6, #0]
   16bc2:	4641      	mov	r1, r8
   16bc4:	3210      	adds	r2, #16
   16bc6:	3301      	adds	r3, #1
   16bc8:	6071      	str	r1, [r6, #4]
   16bca:	60ba      	str	r2, [r7, #8]
   16bcc:	607b      	str	r3, [r7, #4]
   16bce:	2b07      	cmp	r3, #7
   16bd0:	ddf1      	ble.n	16bb6 <_vfprintf_r+0xf3e>
   16bd2:	003a      	movs	r2, r7
   16bd4:	0021      	movs	r1, r4
   16bd6:	9807      	ldr	r0, [sp, #28]
   16bd8:	f004 ff6a 	bl	1bab0 <__sprint_r>
   16bdc:	2800      	cmp	r0, #0
   16bde:	d000      	beq.n	16be2 <_vfprintf_r+0xf6a>
   16be0:	e635      	b.n	1684e <_vfprintf_r+0xbd6>
   16be2:	68ba      	ldr	r2, [r7, #8]
   16be4:	687b      	ldr	r3, [r7, #4]
   16be6:	ae32      	add	r6, sp, #200	; 0xc8
   16be8:	e7e6      	b.n	16bb8 <_vfprintf_r+0xf40>
   16bea:	9a19      	ldr	r2, [sp, #100]	; 0x64
   16bec:	6032      	str	r2, [r6, #0]
   16bee:	9a18      	ldr	r2, [sp, #96]	; 0x60
   16bf0:	4694      	mov	ip, r2
   16bf2:	6072      	str	r2, [r6, #4]
   16bf4:	687a      	ldr	r2, [r7, #4]
   16bf6:	4464      	add	r4, ip
   16bf8:	3201      	adds	r2, #1
   16bfa:	60bc      	str	r4, [r7, #8]
   16bfc:	607a      	str	r2, [r7, #4]
   16bfe:	2a07      	cmp	r2, #7
   16c00:	dd00      	ble.n	16c04 <_vfprintf_r+0xf8c>
   16c02:	e26f      	b.n	170e4 <_vfprintf_r+0x146c>
   16c04:	3608      	adds	r6, #8
   16c06:	e7ac      	b.n	16b62 <_vfprintf_r+0xeea>
   16c08:	003a      	movs	r2, r7
   16c0a:	4659      	mov	r1, fp
   16c0c:	9807      	ldr	r0, [sp, #28]
   16c0e:	f004 ff4f 	bl	1bab0 <__sprint_r>
   16c12:	2800      	cmp	r0, #0
   16c14:	d000      	beq.n	16c18 <_vfprintf_r+0xfa0>
   16c16:	e648      	b.n	168aa <_vfprintf_r+0xc32>
   16c18:	68bc      	ldr	r4, [r7, #8]
   16c1a:	687b      	ldr	r3, [r7, #4]
   16c1c:	ae32      	add	r6, sp, #200	; 0xc8
   16c1e:	e541      	b.n	166a4 <_vfprintf_r+0xa2c>
   16c20:	46a3      	mov	fp, r4
   16c22:	4698      	mov	r8, r3
   16c24:	0014      	movs	r4, r2
   16c26:	464b      	mov	r3, r9
   16c28:	6075      	str	r5, [r6, #4]
   16c2a:	6033      	str	r3, [r6, #0]
   16c2c:	1964      	adds	r4, r4, r5
   16c2e:	e557      	b.n	166e0 <_vfprintf_r+0xa68>
   16c30:	003a      	movs	r2, r7
   16c32:	4659      	mov	r1, fp
   16c34:	9807      	ldr	r0, [sp, #28]
   16c36:	f004 ff3b 	bl	1bab0 <__sprint_r>
   16c3a:	2800      	cmp	r0, #0
   16c3c:	d000      	beq.n	16c40 <_vfprintf_r+0xfc8>
   16c3e:	e634      	b.n	168aa <_vfprintf_r+0xc32>
   16c40:	687b      	ldr	r3, [r7, #4]
   16c42:	68bc      	ldr	r4, [r7, #8]
   16c44:	4698      	mov	r8, r3
   16c46:	ae32      	add	r6, sp, #200	; 0xc8
   16c48:	e53a      	b.n	166c0 <_vfprintf_r+0xa48>
   16c4a:	003a      	movs	r2, r7
   16c4c:	4659      	mov	r1, fp
   16c4e:	9807      	ldr	r0, [sp, #28]
   16c50:	f004 ff2e 	bl	1bab0 <__sprint_r>
   16c54:	2800      	cmp	r0, #0
   16c56:	d000      	beq.n	16c5a <_vfprintf_r+0xfe2>
   16c58:	e627      	b.n	168aa <_vfprintf_r+0xc32>
   16c5a:	68bc      	ldr	r4, [r7, #8]
   16c5c:	ae32      	add	r6, sp, #200	; 0xc8
   16c5e:	e46a      	b.n	16536 <_vfprintf_r+0x8be>
   16c60:	990e      	ldr	r1, [sp, #56]	; 0x38
   16c62:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
   16c64:	2400      	movs	r4, #0
   16c66:	424b      	negs	r3, r1
   16c68:	4194      	sbcs	r4, r2
   16c6a:	930e      	str	r3, [sp, #56]	; 0x38
   16c6c:	940f      	str	r4, [sp, #60]	; 0x3c
   16c6e:	232d      	movs	r3, #45	; 0x2d
   16c70:	aa16      	add	r2, sp, #88	; 0x58
   16c72:	77d3      	strb	r3, [r2, #31]
   16c74:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   16c76:	2b00      	cmp	r3, #0
   16c78:	da00      	bge.n	16c7c <_vfprintf_r+0x1004>
   16c7a:	e2b6      	b.n	171ea <_vfprintf_r+0x1572>
   16c7c:	2380      	movs	r3, #128	; 0x80
   16c7e:	9a08      	ldr	r2, [sp, #32]
   16c80:	439a      	bics	r2, r3
   16c82:	3b53      	subs	r3, #83	; 0x53
   16c84:	9208      	str	r2, [sp, #32]
   16c86:	4698      	mov	r8, r3
   16c88:	f7ff f96f 	bl	15f6a <_vfprintf_r+0x2f2>
   16c8c:	2340      	movs	r3, #64	; 0x40
   16c8e:	9908      	ldr	r1, [sp, #32]
   16c90:	400b      	ands	r3, r1
   16c92:	d000      	beq.n	16c96 <_vfprintf_r+0x101e>
   16c94:	e14b      	b.n	16f2e <_vfprintf_r+0x12b6>
   16c96:	9911      	ldr	r1, [sp, #68]	; 0x44
   16c98:	000a      	movs	r2, r1
   16c9a:	6809      	ldr	r1, [r1, #0]
   16c9c:	3204      	adds	r2, #4
   16c9e:	910e      	str	r1, [sp, #56]	; 0x38
   16ca0:	2100      	movs	r1, #0
   16ca2:	910f      	str	r1, [sp, #60]	; 0x3c
   16ca4:	a916      	add	r1, sp, #88	; 0x58
   16ca6:	77cb      	strb	r3, [r1, #31]
   16ca8:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   16caa:	2b00      	cmp	r3, #0
   16cac:	da15      	bge.n	16cda <_vfprintf_r+0x1062>
   16cae:	9211      	str	r2, [sp, #68]	; 0x44
   16cb0:	2300      	movs	r3, #0
   16cb2:	4698      	mov	r8, r3
   16cb4:	9a0e      	ldr	r2, [sp, #56]	; 0x38
   16cb6:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   16cb8:	0011      	movs	r1, r2
   16cba:	4319      	orrs	r1, r3
   16cbc:	d001      	beq.n	16cc2 <_vfprintf_r+0x104a>
   16cbe:	f7ff fa04 	bl	160ca <_vfprintf_r+0x452>
   16cc2:	e6c4      	b.n	16a4e <_vfprintf_r+0xdd6>
   16cc4:	9b08      	ldr	r3, [sp, #32]
   16cc6:	9a11      	ldr	r2, [sp, #68]	; 0x44
   16cc8:	065b      	lsls	r3, r3, #25
   16cca:	d400      	bmi.n	16cce <_vfprintf_r+0x1056>
   16ccc:	e6ca      	b.n	16a64 <_vfprintf_r+0xdec>
   16cce:	2100      	movs	r1, #0
   16cd0:	5e53      	ldrsh	r3, [r2, r1]
   16cd2:	e6c9      	b.n	16a68 <_vfprintf_r+0xdf0>
   16cd4:	2380      	movs	r3, #128	; 0x80
   16cd6:	9908      	ldr	r1, [sp, #32]
   16cd8:	e5fc      	b.n	168d4 <_vfprintf_r+0xc5c>
   16cda:	2380      	movs	r3, #128	; 0x80
   16cdc:	9908      	ldr	r1, [sp, #32]
   16cde:	e6a7      	b.n	16a30 <_vfprintf_r+0xdb8>
   16ce0:	9d16      	ldr	r5, [sp, #88]	; 0x58
   16ce2:	9c17      	ldr	r4, [sp, #92]	; 0x5c
   16ce4:	002a      	movs	r2, r5
   16ce6:	0023      	movs	r3, r4
   16ce8:	0028      	movs	r0, r5
   16cea:	0021      	movs	r1, r4
   16cec:	f008 fef8 	bl	1fae0 <__aeabi_dcmpun>
   16cf0:	2800      	cmp	r0, #0
   16cf2:	d000      	beq.n	16cf6 <_vfprintf_r+0x107e>
   16cf4:	e35f      	b.n	173b6 <_vfprintf_r+0x173e>
   16cf6:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   16cf8:	3301      	adds	r3, #1
   16cfa:	d100      	bne.n	16cfe <_vfprintf_r+0x1086>
   16cfc:	e29b      	b.n	17236 <_vfprintf_r+0x15be>
   16cfe:	2320      	movs	r3, #32
   16d00:	9d13      	ldr	r5, [sp, #76]	; 0x4c
   16d02:	439d      	bics	r5, r3
   16d04:	2d47      	cmp	r5, #71	; 0x47
   16d06:	d100      	bne.n	16d0a <_vfprintf_r+0x1092>
   16d08:	e170      	b.n	16fec <_vfprintf_r+0x1374>
   16d0a:	2380      	movs	r3, #128	; 0x80
   16d0c:	9a08      	ldr	r2, [sp, #32]
   16d0e:	005b      	lsls	r3, r3, #1
   16d10:	431a      	orrs	r2, r3
   16d12:	9b17      	ldr	r3, [sp, #92]	; 0x5c
   16d14:	921b      	str	r2, [sp, #108]	; 0x6c
   16d16:	2b00      	cmp	r3, #0
   16d18:	da00      	bge.n	16d1c <_vfprintf_r+0x10a4>
   16d1a:	e2c9      	b.n	172b0 <_vfprintf_r+0x1638>
   16d1c:	9a16      	ldr	r2, [sp, #88]	; 0x58
   16d1e:	4698      	mov	r8, r3
   16d20:	2300      	movs	r3, #0
   16d22:	4691      	mov	r9, r2
   16d24:	9309      	str	r3, [sp, #36]	; 0x24
   16d26:	9c13      	ldr	r4, [sp, #76]	; 0x4c
   16d28:	2c66      	cmp	r4, #102	; 0x66
   16d2a:	d100      	bne.n	16d2e <_vfprintf_r+0x10b6>
   16d2c:	e289      	b.n	17242 <_vfprintf_r+0x15ca>
   16d2e:	2c46      	cmp	r4, #70	; 0x46
   16d30:	d100      	bne.n	16d34 <_vfprintf_r+0x10bc>
   16d32:	e130      	b.n	16f96 <_vfprintf_r+0x131e>
   16d34:	002b      	movs	r3, r5
   16d36:	3b45      	subs	r3, #69	; 0x45
   16d38:	4259      	negs	r1, r3
   16d3a:	4159      	adcs	r1, r3
   16d3c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   16d3e:	464a      	mov	r2, r9
   16d40:	469a      	mov	sl, r3
   16d42:	ab23      	add	r3, sp, #140	; 0x8c
   16d44:	9304      	str	r3, [sp, #16]
   16d46:	ab20      	add	r3, sp, #128	; 0x80
   16d48:	448a      	add	sl, r1
   16d4a:	9303      	str	r3, [sp, #12]
   16d4c:	ab1f      	add	r3, sp, #124	; 0x7c
   16d4e:	9302      	str	r3, [sp, #8]
   16d50:	4653      	mov	r3, sl
   16d52:	9301      	str	r3, [sp, #4]
   16d54:	2302      	movs	r3, #2
   16d56:	9807      	ldr	r0, [sp, #28]
   16d58:	9300      	str	r3, [sp, #0]
   16d5a:	4643      	mov	r3, r8
   16d5c:	f000 fd42 	bl	177e4 <_dtoa_r>
   16d60:	9012      	str	r0, [sp, #72]	; 0x48
   16d62:	2c67      	cmp	r4, #103	; 0x67
   16d64:	d000      	beq.n	16d68 <_vfprintf_r+0x10f0>
   16d66:	e2bb      	b.n	172e0 <_vfprintf_r+0x1668>
   16d68:	9b12      	ldr	r3, [sp, #72]	; 0x48
   16d6a:	4453      	add	r3, sl
   16d6c:	001c      	movs	r4, r3
   16d6e:	9b08      	ldr	r3, [sp, #32]
   16d70:	07db      	lsls	r3, r3, #31
   16d72:	d400      	bmi.n	16d76 <_vfprintf_r+0x10fe>
   16d74:	e306      	b.n	17384 <_vfprintf_r+0x170c>
   16d76:	2300      	movs	r3, #0
   16d78:	2200      	movs	r2, #0
   16d7a:	4648      	mov	r0, r9
   16d7c:	4641      	mov	r1, r8
   16d7e:	f007 f819 	bl	1ddb4 <__aeabi_dcmpeq>
   16d82:	0023      	movs	r3, r4
   16d84:	2800      	cmp	r0, #0
   16d86:	d109      	bne.n	16d9c <_vfprintf_r+0x1124>
   16d88:	9b23      	ldr	r3, [sp, #140]	; 0x8c
   16d8a:	429c      	cmp	r4, r3
   16d8c:	d906      	bls.n	16d9c <_vfprintf_r+0x1124>
   16d8e:	2130      	movs	r1, #48	; 0x30
   16d90:	1c5a      	adds	r2, r3, #1
   16d92:	9223      	str	r2, [sp, #140]	; 0x8c
   16d94:	7019      	strb	r1, [r3, #0]
   16d96:	9b23      	ldr	r3, [sp, #140]	; 0x8c
   16d98:	429c      	cmp	r4, r3
   16d9a:	d8f9      	bhi.n	16d90 <_vfprintf_r+0x1118>
   16d9c:	9a12      	ldr	r2, [sp, #72]	; 0x48
   16d9e:	1a9b      	subs	r3, r3, r2
   16da0:	9314      	str	r3, [sp, #80]	; 0x50
   16da2:	2d47      	cmp	r5, #71	; 0x47
   16da4:	d100      	bne.n	16da8 <_vfprintf_r+0x1130>
   16da6:	e17f      	b.n	170a8 <_vfprintf_r+0x1430>
   16da8:	9b13      	ldr	r3, [sp, #76]	; 0x4c
   16daa:	2b65      	cmp	r3, #101	; 0x65
   16dac:	dc00      	bgt.n	16db0 <_vfprintf_r+0x1138>
   16dae:	e2a9      	b.n	17304 <_vfprintf_r+0x168c>
   16db0:	9b13      	ldr	r3, [sp, #76]	; 0x4c
   16db2:	2b66      	cmp	r3, #102	; 0x66
   16db4:	d100      	bne.n	16db8 <_vfprintf_r+0x1140>
   16db6:	e286      	b.n	172c6 <_vfprintf_r+0x164e>
   16db8:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   16dba:	9315      	str	r3, [sp, #84]	; 0x54
   16dbc:	9a15      	ldr	r2, [sp, #84]	; 0x54
   16dbe:	9914      	ldr	r1, [sp, #80]	; 0x50
   16dc0:	428a      	cmp	r2, r1
   16dc2:	da00      	bge.n	16dc6 <_vfprintf_r+0x114e>
   16dc4:	e25f      	b.n	17286 <_vfprintf_r+0x160e>
   16dc6:	9b08      	ldr	r3, [sp, #32]
   16dc8:	07db      	lsls	r3, r3, #31
   16dca:	d500      	bpl.n	16dce <_vfprintf_r+0x1156>
   16dcc:	e2cb      	b.n	17366 <_vfprintf_r+0x16ee>
   16dce:	43d3      	mvns	r3, r2
   16dd0:	17db      	asrs	r3, r3, #31
   16dd2:	4013      	ands	r3, r2
   16dd4:	9210      	str	r2, [sp, #64]	; 0x40
   16dd6:	2267      	movs	r2, #103	; 0x67
   16dd8:	9213      	str	r2, [sp, #76]	; 0x4c
   16dda:	9a09      	ldr	r2, [sp, #36]	; 0x24
   16ddc:	2a00      	cmp	r2, #0
   16dde:	d000      	beq.n	16de2 <_vfprintf_r+0x116a>
   16de0:	e156      	b.n	17090 <_vfprintf_r+0x1418>
   16de2:	9309      	str	r3, [sp, #36]	; 0x24
   16de4:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
   16de6:	aa16      	add	r2, sp, #88	; 0x58
   16de8:	9308      	str	r3, [sp, #32]
   16dea:	2300      	movs	r3, #0
   16dec:	7fd2      	ldrb	r2, [r2, #31]
   16dee:	930b      	str	r3, [sp, #44]	; 0x2c
   16df0:	4690      	mov	r8, r2
   16df2:	f7ff f99c 	bl	1612e <_vfprintf_r+0x4b6>
   16df6:	9b08      	ldr	r3, [sp, #32]
   16df8:	06db      	lsls	r3, r3, #27
   16dfa:	d40c      	bmi.n	16e16 <_vfprintf_r+0x119e>
   16dfc:	9b08      	ldr	r3, [sp, #32]
   16dfe:	065b      	lsls	r3, r3, #25
   16e00:	d509      	bpl.n	16e16 <_vfprintf_r+0x119e>
   16e02:	4669      	mov	r1, sp
   16e04:	9b11      	ldr	r3, [sp, #68]	; 0x44
   16e06:	8e09      	ldrh	r1, [r1, #48]	; 0x30
   16e08:	681a      	ldr	r2, [r3, #0]
   16e0a:	3304      	adds	r3, #4
   16e0c:	9208      	str	r2, [sp, #32]
   16e0e:	8011      	strh	r1, [r2, #0]
   16e10:	9311      	str	r3, [sp, #68]	; 0x44
   16e12:	f7fe ff79 	bl	15d08 <_vfprintf_r+0x90>
   16e16:	9a11      	ldr	r2, [sp, #68]	; 0x44
   16e18:	990c      	ldr	r1, [sp, #48]	; 0x30
   16e1a:	6813      	ldr	r3, [r2, #0]
   16e1c:	6019      	str	r1, [r3, #0]
   16e1e:	0013      	movs	r3, r2
   16e20:	3304      	adds	r3, #4
   16e22:	9311      	str	r3, [sp, #68]	; 0x44
   16e24:	f7fe ff70 	bl	15d08 <_vfprintf_r+0x90>
   16e28:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   16e2a:	aa16      	add	r2, sp, #88	; 0x58
   16e2c:	77d0      	strb	r0, [r2, #31]
   16e2e:	2b00      	cmp	r3, #0
   16e30:	da01      	bge.n	16e36 <_vfprintf_r+0x11be>
   16e32:	f7fe ffe1 	bl	15df8 <_vfprintf_r+0x180>
   16e36:	2380      	movs	r3, #128	; 0x80
   16e38:	9a08      	ldr	r2, [sp, #32]
   16e3a:	439a      	bics	r2, r3
   16e3c:	9208      	str	r2, [sp, #32]
   16e3e:	f7fe ffd6 	bl	15dee <_vfprintf_r+0x176>
   16e42:	46cb      	mov	fp, r9
   16e44:	46a1      	mov	r9, r4
   16e46:	0014      	movs	r4, r2
   16e48:	e647      	b.n	16ada <_vfprintf_r+0xe62>
   16e4a:	003a      	movs	r2, r7
   16e4c:	4659      	mov	r1, fp
   16e4e:	9807      	ldr	r0, [sp, #28]
   16e50:	f004 fe2e 	bl	1bab0 <__sprint_r>
   16e54:	2800      	cmp	r0, #0
   16e56:	d000      	beq.n	16e5a <_vfprintf_r+0x11e2>
   16e58:	e527      	b.n	168aa <_vfprintf_r+0xc32>
   16e5a:	68bc      	ldr	r4, [r7, #8]
   16e5c:	ae32      	add	r6, sp, #200	; 0xc8
   16e5e:	e47a      	b.n	16756 <_vfprintf_r+0xade>
   16e60:	4b29      	ldr	r3, [pc, #164]	; (16f08 <_vfprintf_r+0x1290>)
   16e62:	3401      	adds	r4, #1
   16e64:	6033      	str	r3, [r6, #0]
   16e66:	2301      	movs	r3, #1
   16e68:	6073      	str	r3, [r6, #4]
   16e6a:	687b      	ldr	r3, [r7, #4]
   16e6c:	60bc      	str	r4, [r7, #8]
   16e6e:	3301      	adds	r3, #1
   16e70:	607b      	str	r3, [r7, #4]
   16e72:	2b07      	cmp	r3, #7
   16e74:	dd00      	ble.n	16e78 <_vfprintf_r+0x1200>
   16e76:	e0ad      	b.n	16fd4 <_vfprintf_r+0x135c>
   16e78:	3608      	adds	r6, #8
   16e7a:	2800      	cmp	r0, #0
   16e7c:	d107      	bne.n	16e8e <_vfprintf_r+0x1216>
   16e7e:	9b14      	ldr	r3, [sp, #80]	; 0x50
   16e80:	2b00      	cmp	r3, #0
   16e82:	d104      	bne.n	16e8e <_vfprintf_r+0x1216>
   16e84:	9b08      	ldr	r3, [sp, #32]
   16e86:	07db      	lsls	r3, r3, #31
   16e88:	d401      	bmi.n	16e8e <_vfprintf_r+0x1216>
   16e8a:	f7ff fb9e 	bl	165ca <_vfprintf_r+0x952>
   16e8e:	9b19      	ldr	r3, [sp, #100]	; 0x64
   16e90:	6033      	str	r3, [r6, #0]
   16e92:	9b18      	ldr	r3, [sp, #96]	; 0x60
   16e94:	1919      	adds	r1, r3, r4
   16e96:	6073      	str	r3, [r6, #4]
   16e98:	687b      	ldr	r3, [r7, #4]
   16e9a:	60b9      	str	r1, [r7, #8]
   16e9c:	3301      	adds	r3, #1
   16e9e:	607b      	str	r3, [r7, #4]
   16ea0:	2b07      	cmp	r3, #7
   16ea2:	dd00      	ble.n	16ea6 <_vfprintf_r+0x122e>
   16ea4:	e24c      	b.n	17340 <_vfprintf_r+0x16c8>
   16ea6:	0032      	movs	r2, r6
   16ea8:	3208      	adds	r2, #8
   16eaa:	4244      	negs	r4, r0
   16eac:	2c00      	cmp	r4, #0
   16eae:	dc00      	bgt.n	16eb2 <_vfprintf_r+0x123a>
   16eb0:	e0de      	b.n	17070 <_vfprintf_r+0x13f8>
   16eb2:	4814      	ldr	r0, [pc, #80]	; (16f04 <_vfprintf_r+0x128c>)
   16eb4:	4681      	mov	r9, r0
   16eb6:	2c10      	cmp	r4, #16
   16eb8:	dc00      	bgt.n	16ebc <_vfprintf_r+0x1244>
   16eba:	e121      	b.n	17100 <_vfprintf_r+0x1488>
   16ebc:	2610      	movs	r6, #16
   16ebe:	465d      	mov	r5, fp
   16ec0:	e004      	b.n	16ecc <_vfprintf_r+0x1254>
   16ec2:	3208      	adds	r2, #8
   16ec4:	3c10      	subs	r4, #16
   16ec6:	2c10      	cmp	r4, #16
   16ec8:	dc00      	bgt.n	16ecc <_vfprintf_r+0x1254>
   16eca:	e118      	b.n	170fe <_vfprintf_r+0x1486>
   16ecc:	4648      	mov	r0, r9
   16ece:	3110      	adds	r1, #16
   16ed0:	3301      	adds	r3, #1
   16ed2:	6010      	str	r0, [r2, #0]
   16ed4:	6056      	str	r6, [r2, #4]
   16ed6:	60b9      	str	r1, [r7, #8]
   16ed8:	607b      	str	r3, [r7, #4]
   16eda:	2b07      	cmp	r3, #7
   16edc:	ddf1      	ble.n	16ec2 <_vfprintf_r+0x124a>
   16ede:	003a      	movs	r2, r7
   16ee0:	0029      	movs	r1, r5
   16ee2:	9807      	ldr	r0, [sp, #28]
   16ee4:	f004 fde4 	bl	1bab0 <__sprint_r>
   16ee8:	2800      	cmp	r0, #0
   16eea:	d000      	beq.n	16eee <_vfprintf_r+0x1276>
   16eec:	e260      	b.n	173b0 <_vfprintf_r+0x1738>
   16eee:	68b9      	ldr	r1, [r7, #8]
   16ef0:	687b      	ldr	r3, [r7, #4]
   16ef2:	aa32      	add	r2, sp, #200	; 0xc8
   16ef4:	e7e6      	b.n	16ec4 <_vfprintf_r+0x124c>
   16ef6:	9811      	ldr	r0, [sp, #68]	; 0x44
   16ef8:	f7ff faea 	bl	164d0 <_vfprintf_r+0x858>
   16efc:	2001      	movs	r0, #1
   16efe:	4240      	negs	r0, r0
   16f00:	f7fe ff9c 	bl	15e3c <_vfprintf_r+0x1c4>
   16f04:	00022d28 	.word	0x00022d28
   16f08:	00022d78 	.word	0x00022d78
   16f0c:	9b07      	ldr	r3, [sp, #28]
   16f0e:	46d8      	mov	r8, fp
   16f10:	469b      	mov	fp, r3
   16f12:	68bb      	ldr	r3, [r7, #8]
   16f14:	2b00      	cmp	r3, #0
   16f16:	d100      	bne.n	16f1a <_vfprintf_r+0x12a2>
   16f18:	e49a      	b.n	16850 <_vfprintf_r+0xbd8>
   16f1a:	003a      	movs	r2, r7
   16f1c:	4641      	mov	r1, r8
   16f1e:	4658      	mov	r0, fp
   16f20:	f004 fdc6 	bl	1bab0 <__sprint_r>
   16f24:	e494      	b.n	16850 <_vfprintf_r+0xbd8>
   16f26:	4be0      	ldr	r3, [pc, #896]	; (172a8 <_vfprintf_r+0x1630>)
   16f28:	9312      	str	r3, [sp, #72]	; 0x48
   16f2a:	f7ff f88c 	bl	16046 <_vfprintf_r+0x3ce>
   16f2e:	9811      	ldr	r0, [sp, #68]	; 0x44
   16f30:	0003      	movs	r3, r0
   16f32:	8800      	ldrh	r0, [r0, #0]
   16f34:	3304      	adds	r3, #4
   16f36:	900e      	str	r0, [sp, #56]	; 0x38
   16f38:	2000      	movs	r0, #0
   16f3a:	900f      	str	r0, [sp, #60]	; 0x3c
   16f3c:	a816      	add	r0, sp, #88	; 0x58
   16f3e:	77c2      	strb	r2, [r0, #31]
   16f40:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
   16f42:	2a00      	cmp	r2, #0
   16f44:	da00      	bge.n	16f48 <_vfprintf_r+0x12d0>
   16f46:	e215      	b.n	17374 <_vfprintf_r+0x16fc>
   16f48:	2280      	movs	r2, #128	; 0x80
   16f4a:	4391      	bics	r1, r2
   16f4c:	9a0e      	ldr	r2, [sp, #56]	; 0x38
   16f4e:	9108      	str	r1, [sp, #32]
   16f50:	9311      	str	r3, [sp, #68]	; 0x44
   16f52:	2a00      	cmp	r2, #0
   16f54:	d001      	beq.n	16f5a <_vfprintf_r+0x12e2>
   16f56:	f7ff f8b6 	bl	160c6 <_vfprintf_r+0x44e>
   16f5a:	e571      	b.n	16a40 <_vfprintf_r+0xdc8>
   16f5c:	9811      	ldr	r0, [sp, #68]	; 0x44
   16f5e:	0003      	movs	r3, r0
   16f60:	8800      	ldrh	r0, [r0, #0]
   16f62:	3304      	adds	r3, #4
   16f64:	900e      	str	r0, [sp, #56]	; 0x38
   16f66:	2000      	movs	r0, #0
   16f68:	900f      	str	r0, [sp, #60]	; 0x3c
   16f6a:	a816      	add	r0, sp, #88	; 0x58
   16f6c:	77c2      	strb	r2, [r0, #31]
   16f6e:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
   16f70:	2a00      	cmp	r2, #0
   16f72:	da00      	bge.n	16f76 <_vfprintf_r+0x12fe>
   16f74:	e208      	b.n	17388 <_vfprintf_r+0x1710>
   16f76:	2280      	movs	r2, #128	; 0x80
   16f78:	9311      	str	r3, [sp, #68]	; 0x44
   16f7a:	2300      	movs	r3, #0
   16f7c:	4391      	bics	r1, r2
   16f7e:	9a0e      	ldr	r2, [sp, #56]	; 0x38
   16f80:	9108      	str	r1, [sp, #32]
   16f82:	4698      	mov	r8, r3
   16f84:	2a00      	cmp	r2, #0
   16f86:	d001      	beq.n	16f8c <_vfprintf_r+0x1314>
   16f88:	f7fe ffef 	bl	15f6a <_vfprintf_r+0x2f2>
   16f8c:	e4aa      	b.n	168e4 <_vfprintf_r+0xc6c>
   16f8e:	9b11      	ldr	r3, [sp, #68]	; 0x44
   16f90:	881a      	ldrh	r2, [r3, #0]
   16f92:	f7ff fa33 	bl	163fc <_vfprintf_r+0x784>
   16f96:	ab23      	add	r3, sp, #140	; 0x8c
   16f98:	9304      	str	r3, [sp, #16]
   16f9a:	ab20      	add	r3, sp, #128	; 0x80
   16f9c:	9303      	str	r3, [sp, #12]
   16f9e:	ab1f      	add	r3, sp, #124	; 0x7c
   16fa0:	9302      	str	r3, [sp, #8]
   16fa2:	2303      	movs	r3, #3
   16fa4:	9c0b      	ldr	r4, [sp, #44]	; 0x2c
   16fa6:	9300      	str	r3, [sp, #0]
   16fa8:	9401      	str	r4, [sp, #4]
   16faa:	464a      	mov	r2, r9
   16fac:	4643      	mov	r3, r8
   16fae:	9807      	ldr	r0, [sp, #28]
   16fb0:	f000 fc18 	bl	177e4 <_dtoa_r>
   16fb4:	46a2      	mov	sl, r4
   16fb6:	9012      	str	r0, [sp, #72]	; 0x48
   16fb8:	9b12      	ldr	r3, [sp, #72]	; 0x48
   16fba:	4453      	add	r3, sl
   16fbc:	001c      	movs	r4, r3
   16fbe:	9b13      	ldr	r3, [sp, #76]	; 0x4c
   16fc0:	2b46      	cmp	r3, #70	; 0x46
   16fc2:	d000      	beq.n	16fc6 <_vfprintf_r+0x134e>
   16fc4:	e6d7      	b.n	16d76 <_vfprintf_r+0x10fe>
   16fc6:	9b12      	ldr	r3, [sp, #72]	; 0x48
   16fc8:	781b      	ldrb	r3, [r3, #0]
   16fca:	2b30      	cmp	r3, #48	; 0x30
   16fcc:	d015      	beq.n	16ffa <_vfprintf_r+0x1382>
   16fce:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   16fd0:	18e4      	adds	r4, r4, r3
   16fd2:	e6d0      	b.n	16d76 <_vfprintf_r+0x10fe>
   16fd4:	003a      	movs	r2, r7
   16fd6:	4659      	mov	r1, fp
   16fd8:	9807      	ldr	r0, [sp, #28]
   16fda:	f004 fd69 	bl	1bab0 <__sprint_r>
   16fde:	2800      	cmp	r0, #0
   16fe0:	d000      	beq.n	16fe4 <_vfprintf_r+0x136c>
   16fe2:	e462      	b.n	168aa <_vfprintf_r+0xc32>
   16fe4:	981f      	ldr	r0, [sp, #124]	; 0x7c
   16fe6:	68bc      	ldr	r4, [r7, #8]
   16fe8:	ae32      	add	r6, sp, #200	; 0xc8
   16fea:	e746      	b.n	16e7a <_vfprintf_r+0x1202>
   16fec:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   16fee:	2b00      	cmp	r3, #0
   16ff0:	d000      	beq.n	16ff4 <_vfprintf_r+0x137c>
   16ff2:	e68a      	b.n	16d0a <_vfprintf_r+0x1092>
   16ff4:	3301      	adds	r3, #1
   16ff6:	930b      	str	r3, [sp, #44]	; 0x2c
   16ff8:	e687      	b.n	16d0a <_vfprintf_r+0x1092>
   16ffa:	2200      	movs	r2, #0
   16ffc:	2300      	movs	r3, #0
   16ffe:	4648      	mov	r0, r9
   17000:	4641      	mov	r1, r8
   17002:	f006 fed7 	bl	1ddb4 <__aeabi_dcmpeq>
   17006:	2800      	cmp	r0, #0
   17008:	d1e1      	bne.n	16fce <_vfprintf_r+0x1356>
   1700a:	2301      	movs	r3, #1
   1700c:	4652      	mov	r2, sl
   1700e:	1a9b      	subs	r3, r3, r2
   17010:	931f      	str	r3, [sp, #124]	; 0x7c
   17012:	18e4      	adds	r4, r4, r3
   17014:	e6af      	b.n	16d76 <_vfprintf_r+0x10fe>
   17016:	2220      	movs	r2, #32
   17018:	9b08      	ldr	r3, [sp, #32]
   1701a:	3101      	adds	r1, #1
   1701c:	4313      	orrs	r3, r2
   1701e:	9308      	str	r3, [sp, #32]
   17020:	780b      	ldrb	r3, [r1, #0]
   17022:	f7fe feac 	bl	15d7e <_vfprintf_r+0x106>
   17026:	003a      	movs	r2, r7
   17028:	4659      	mov	r1, fp
   1702a:	9807      	ldr	r0, [sp, #28]
   1702c:	f004 fd40 	bl	1bab0 <__sprint_r>
   17030:	2800      	cmp	r0, #0
   17032:	d000      	beq.n	17036 <_vfprintf_r+0x13be>
   17034:	e439      	b.n	168aa <_vfprintf_r+0xc32>
   17036:	68bc      	ldr	r4, [r7, #8]
   17038:	ae32      	add	r6, sp, #200	; 0xc8
   1703a:	f7ff fba3 	bl	16784 <_vfprintf_r+0xb0c>
   1703e:	9a12      	ldr	r2, [sp, #72]	; 0x48
   17040:	ab32      	add	r3, sp, #200	; 0xc8
   17042:	1a9b      	subs	r3, r3, r2
   17044:	9310      	str	r3, [sp, #64]	; 0x40
   17046:	f7ff f869 	bl	1611c <_vfprintf_r+0x4a4>
   1704a:	9812      	ldr	r0, [sp, #72]	; 0x48
   1704c:	f7fe fde0 	bl	15c10 <strlen>
   17050:	0002      	movs	r2, r0
   17052:	9010      	str	r0, [sp, #64]	; 0x40
   17054:	0003      	movs	r3, r0
   17056:	f7ff f91b 	bl	16290 <_vfprintf_r+0x618>
   1705a:	003a      	movs	r2, r7
   1705c:	4659      	mov	r1, fp
   1705e:	9807      	ldr	r0, [sp, #28]
   17060:	f004 fd26 	bl	1bab0 <__sprint_r>
   17064:	2800      	cmp	r0, #0
   17066:	d000      	beq.n	1706a <_vfprintf_r+0x13f2>
   17068:	e41f      	b.n	168aa <_vfprintf_r+0xc32>
   1706a:	68b9      	ldr	r1, [r7, #8]
   1706c:	687b      	ldr	r3, [r7, #4]
   1706e:	aa32      	add	r2, sp, #200	; 0xc8
   17070:	9812      	ldr	r0, [sp, #72]	; 0x48
   17072:	3301      	adds	r3, #1
   17074:	6010      	str	r0, [r2, #0]
   17076:	9814      	ldr	r0, [sp, #80]	; 0x50
   17078:	607b      	str	r3, [r7, #4]
   1707a:	1844      	adds	r4, r0, r1
   1707c:	6050      	str	r0, [r2, #4]
   1707e:	60bc      	str	r4, [r7, #8]
   17080:	2b07      	cmp	r3, #7
   17082:	dd01      	ble.n	17088 <_vfprintf_r+0x1410>
   17084:	f7ff fb43 	bl	1670e <_vfprintf_r+0xa96>
   17088:	3208      	adds	r2, #8
   1708a:	0016      	movs	r6, r2
   1708c:	f7ff fa9d 	bl	165ca <_vfprintf_r+0x952>
   17090:	9309      	str	r3, [sp, #36]	; 0x24
   17092:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
   17094:	222d      	movs	r2, #45	; 0x2d
   17096:	9308      	str	r3, [sp, #32]
   17098:	232d      	movs	r3, #45	; 0x2d
   1709a:	4698      	mov	r8, r3
   1709c:	2300      	movs	r3, #0
   1709e:	a916      	add	r1, sp, #88	; 0x58
   170a0:	77ca      	strb	r2, [r1, #31]
   170a2:	930b      	str	r3, [sp, #44]	; 0x2c
   170a4:	f7ff f846 	bl	16134 <_vfprintf_r+0x4bc>
   170a8:	9c1f      	ldr	r4, [sp, #124]	; 0x7c
   170aa:	1ce3      	adds	r3, r4, #3
   170ac:	db33      	blt.n	17116 <_vfprintf_r+0x149e>
   170ae:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   170b0:	42a3      	cmp	r3, r4
   170b2:	db30      	blt.n	17116 <_vfprintf_r+0x149e>
   170b4:	9415      	str	r4, [sp, #84]	; 0x54
   170b6:	e681      	b.n	16dbc <_vfprintf_r+0x1144>
   170b8:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   170ba:	2b09      	cmp	r3, #9
   170bc:	d901      	bls.n	170c2 <_vfprintf_r+0x144a>
   170be:	f7fe ff59 	bl	15f74 <_vfprintf_r+0x2fc>
   170c2:	e417      	b.n	168f4 <_vfprintf_r+0xc7c>
   170c4:	2101      	movs	r1, #1
   170c6:	4249      	negs	r1, r1
   170c8:	f7fe feff 	bl	15eca <_vfprintf_r+0x252>
   170cc:	003a      	movs	r2, r7
   170ce:	4659      	mov	r1, fp
   170d0:	9807      	ldr	r0, [sp, #28]
   170d2:	f004 fced 	bl	1bab0 <__sprint_r>
   170d6:	2800      	cmp	r0, #0
   170d8:	d001      	beq.n	170de <_vfprintf_r+0x1466>
   170da:	f7ff fbe6 	bl	168aa <_vfprintf_r+0xc32>
   170de:	68bc      	ldr	r4, [r7, #8]
   170e0:	ae32      	add	r6, sp, #200	; 0xc8
   170e2:	e44f      	b.n	16984 <_vfprintf_r+0xd0c>
   170e4:	003a      	movs	r2, r7
   170e6:	4659      	mov	r1, fp
   170e8:	9807      	ldr	r0, [sp, #28]
   170ea:	f004 fce1 	bl	1bab0 <__sprint_r>
   170ee:	2800      	cmp	r0, #0
   170f0:	d001      	beq.n	170f6 <_vfprintf_r+0x147e>
   170f2:	f7ff fbda 	bl	168aa <_vfprintf_r+0xc32>
   170f6:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   170f8:	68bc      	ldr	r4, [r7, #8]
   170fa:	ae32      	add	r6, sp, #200	; 0xc8
   170fc:	e531      	b.n	16b62 <_vfprintf_r+0xeea>
   170fe:	46ab      	mov	fp, r5
   17100:	4648      	mov	r0, r9
   17102:	1909      	adds	r1, r1, r4
   17104:	3301      	adds	r3, #1
   17106:	6010      	str	r0, [r2, #0]
   17108:	6054      	str	r4, [r2, #4]
   1710a:	60b9      	str	r1, [r7, #8]
   1710c:	607b      	str	r3, [r7, #4]
   1710e:	2b07      	cmp	r3, #7
   17110:	dca3      	bgt.n	1705a <_vfprintf_r+0x13e2>
   17112:	3208      	adds	r2, #8
   17114:	e7ac      	b.n	17070 <_vfprintf_r+0x13f8>
   17116:	9b13      	ldr	r3, [sp, #76]	; 0x4c
   17118:	3b02      	subs	r3, #2
   1711a:	9313      	str	r3, [sp, #76]	; 0x4c
   1711c:	466b      	mov	r3, sp
   1711e:	224c      	movs	r2, #76	; 0x4c
   17120:	189b      	adds	r3, r3, r2
   17122:	781b      	ldrb	r3, [r3, #0]
   17124:	3c01      	subs	r4, #1
   17126:	ad21      	add	r5, sp, #132	; 0x84
   17128:	941f      	str	r4, [sp, #124]	; 0x7c
   1712a:	702b      	strb	r3, [r5, #0]
   1712c:	2c00      	cmp	r4, #0
   1712e:	da00      	bge.n	17132 <_vfprintf_r+0x14ba>
   17130:	e155      	b.n	173de <_vfprintf_r+0x1766>
   17132:	232b      	movs	r3, #43	; 0x2b
   17134:	706b      	strb	r3, [r5, #1]
   17136:	2c09      	cmp	r4, #9
   17138:	dc00      	bgt.n	1713c <_vfprintf_r+0x14c4>
   1713a:	e11d      	b.n	17378 <_vfprintf_r+0x1700>
   1713c:	aa16      	add	r2, sp, #88	; 0x58
   1713e:	233b      	movs	r3, #59	; 0x3b
   17140:	4694      	mov	ip, r2
   17142:	4463      	add	r3, ip
   17144:	46b0      	mov	r8, r6
   17146:	469a      	mov	sl, r3
   17148:	001e      	movs	r6, r3
   1714a:	0020      	movs	r0, r4
   1714c:	210a      	movs	r1, #10
   1714e:	f7ed f8b5 	bl	42bc <__aeabi_idivmod>
   17152:	3e01      	subs	r6, #1
   17154:	3130      	adds	r1, #48	; 0x30
   17156:	7031      	strb	r1, [r6, #0]
   17158:	0020      	movs	r0, r4
   1715a:	210a      	movs	r1, #10
   1715c:	f7ed f89f 	bl	429e <__aeabi_idiv>
   17160:	0004      	movs	r4, r0
   17162:	2809      	cmp	r0, #9
   17164:	dcf1      	bgt.n	1714a <_vfprintf_r+0x14d2>
   17166:	0033      	movs	r3, r6
   17168:	3430      	adds	r4, #48	; 0x30
   1716a:	1e5a      	subs	r2, r3, #1
   1716c:	b2e4      	uxtb	r4, r4
   1716e:	4646      	mov	r6, r8
   17170:	7014      	strb	r4, [r2, #0]
   17172:	4698      	mov	r8, r3
   17174:	4552      	cmp	r2, sl
   17176:	d300      	bcc.n	1717a <_vfprintf_r+0x1502>
   17178:	e164      	b.n	17444 <_vfprintf_r+0x17cc>
   1717a:	4641      	mov	r1, r8
   1717c:	1a79      	subs	r1, r7, r1
   1717e:	002b      	movs	r3, r5
   17180:	1869      	adds	r1, r5, r1
   17182:	e000      	b.n	17186 <_vfprintf_r+0x150e>
   17184:	7814      	ldrb	r4, [r2, #0]
   17186:	709c      	strb	r4, [r3, #2]
   17188:	3301      	adds	r3, #1
   1718a:	3201      	adds	r2, #1
   1718c:	428b      	cmp	r3, r1
   1718e:	d1f9      	bne.n	17184 <_vfprintf_r+0x150c>
   17190:	a916      	add	r1, sp, #88	; 0x58
   17192:	468c      	mov	ip, r1
   17194:	222e      	movs	r2, #46	; 0x2e
   17196:	4643      	mov	r3, r8
   17198:	4462      	add	r2, ip
   1719a:	4694      	mov	ip, r2
   1719c:	1afb      	subs	r3, r7, r3
   1719e:	4463      	add	r3, ip
   171a0:	9914      	ldr	r1, [sp, #80]	; 0x50
   171a2:	1b5b      	subs	r3, r3, r5
   171a4:	000a      	movs	r2, r1
   171a6:	469c      	mov	ip, r3
   171a8:	4462      	add	r2, ip
   171aa:	931a      	str	r3, [sp, #104]	; 0x68
   171ac:	9210      	str	r2, [sp, #64]	; 0x40
   171ae:	2901      	cmp	r1, #1
   171b0:	dc00      	bgt.n	171b4 <_vfprintf_r+0x153c>
   171b2:	e11d      	b.n	173f0 <_vfprintf_r+0x1778>
   171b4:	9a18      	ldr	r2, [sp, #96]	; 0x60
   171b6:	9b10      	ldr	r3, [sp, #64]	; 0x40
   171b8:	4694      	mov	ip, r2
   171ba:	4463      	add	r3, ip
   171bc:	001a      	movs	r2, r3
   171be:	9310      	str	r3, [sp, #64]	; 0x40
   171c0:	43db      	mvns	r3, r3
   171c2:	17db      	asrs	r3, r3, #31
   171c4:	4013      	ands	r3, r2
   171c6:	2200      	movs	r2, #0
   171c8:	9215      	str	r2, [sp, #84]	; 0x54
   171ca:	e606      	b.n	16dda <_vfprintf_r+0x1162>
   171cc:	003a      	movs	r2, r7
   171ce:	4659      	mov	r1, fp
   171d0:	9807      	ldr	r0, [sp, #28]
   171d2:	f004 fc6d 	bl	1bab0 <__sprint_r>
   171d6:	2800      	cmp	r0, #0
   171d8:	d001      	beq.n	171de <_vfprintf_r+0x1566>
   171da:	f7ff fb66 	bl	168aa <_vfprintf_r+0xc32>
   171de:	9b14      	ldr	r3, [sp, #80]	; 0x50
   171e0:	9a1f      	ldr	r2, [sp, #124]	; 0x7c
   171e2:	68bc      	ldr	r4, [r7, #8]
   171e4:	1a9b      	subs	r3, r3, r2
   171e6:	ae32      	add	r6, sp, #200	; 0xc8
   171e8:	e4d4      	b.n	16b94 <_vfprintf_r+0xf1c>
   171ea:	232d      	movs	r3, #45	; 0x2d
   171ec:	4698      	mov	r8, r3
   171ee:	f7fe febc 	bl	15f6a <_vfprintf_r+0x2f2>
   171f2:	46c8      	mov	r8, r9
   171f4:	f7ff fb2c 	bl	16850 <_vfprintf_r+0xbd8>
   171f8:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   171fa:	2b06      	cmp	r3, #6
   171fc:	d900      	bls.n	17200 <_vfprintf_r+0x1588>
   171fe:	2306      	movs	r3, #6
   17200:	001a      	movs	r2, r3
   17202:	9310      	str	r3, [sp, #64]	; 0x40
   17204:	43db      	mvns	r3, r3
   17206:	17db      	asrs	r3, r3, #31
   17208:	401a      	ands	r2, r3
   1720a:	2300      	movs	r3, #0
   1720c:	4698      	mov	r8, r3
   1720e:	930b      	str	r3, [sp, #44]	; 0x2c
   17210:	9315      	str	r3, [sp, #84]	; 0x54
   17212:	4b26      	ldr	r3, [pc, #152]	; (172ac <_vfprintf_r+0x1634>)
   17214:	9209      	str	r2, [sp, #36]	; 0x24
   17216:	9411      	str	r4, [sp, #68]	; 0x44
   17218:	9312      	str	r3, [sp, #72]	; 0x48
   1721a:	f7fe ff8e 	bl	1613a <_vfprintf_r+0x4c2>
   1721e:	003a      	movs	r2, r7
   17220:	4659      	mov	r1, fp
   17222:	9807      	ldr	r0, [sp, #28]
   17224:	f004 fc44 	bl	1bab0 <__sprint_r>
   17228:	2800      	cmp	r0, #0
   1722a:	d001      	beq.n	17230 <_vfprintf_r+0x15b8>
   1722c:	f7ff fb3d 	bl	168aa <_vfprintf_r+0xc32>
   17230:	68bc      	ldr	r4, [r7, #8]
   17232:	ae32      	add	r6, sp, #200	; 0xc8
   17234:	e489      	b.n	16b4a <_vfprintf_r+0xed2>
   17236:	2320      	movs	r3, #32
   17238:	9d13      	ldr	r5, [sp, #76]	; 0x4c
   1723a:	439d      	bics	r5, r3
   1723c:	3b1a      	subs	r3, #26
   1723e:	930b      	str	r3, [sp, #44]	; 0x2c
   17240:	e563      	b.n	16d0a <_vfprintf_r+0x1092>
   17242:	ab23      	add	r3, sp, #140	; 0x8c
   17244:	9304      	str	r3, [sp, #16]
   17246:	ab20      	add	r3, sp, #128	; 0x80
   17248:	9303      	str	r3, [sp, #12]
   1724a:	ab1f      	add	r3, sp, #124	; 0x7c
   1724c:	9302      	str	r3, [sp, #8]
   1724e:	2303      	movs	r3, #3
   17250:	9c0b      	ldr	r4, [sp, #44]	; 0x2c
   17252:	9300      	str	r3, [sp, #0]
   17254:	9401      	str	r4, [sp, #4]
   17256:	464a      	mov	r2, r9
   17258:	4643      	mov	r3, r8
   1725a:	9807      	ldr	r0, [sp, #28]
   1725c:	f000 fac2 	bl	177e4 <_dtoa_r>
   17260:	46a4      	mov	ip, r4
   17262:	0001      	movs	r1, r0
   17264:	0022      	movs	r2, r4
   17266:	4461      	add	r1, ip
   17268:	9012      	str	r0, [sp, #72]	; 0x48
   1726a:	000c      	movs	r4, r1
   1726c:	4692      	mov	sl, r2
   1726e:	e6aa      	b.n	16fc6 <_vfprintf_r+0x134e>
   17270:	232d      	movs	r3, #45	; 0x2d
   17272:	aa16      	add	r2, sp, #88	; 0x58
   17274:	77d3      	strb	r3, [r2, #31]
   17276:	4698      	mov	r8, r3
   17278:	f7fe fede 	bl	16038 <_vfprintf_r+0x3c0>
   1727c:	2300      	movs	r3, #0
   1727e:	9008      	str	r0, [sp, #32]
   17280:	4698      	mov	r8, r3
   17282:	f7ff f881 	bl	16388 <_vfprintf_r+0x710>
   17286:	9a18      	ldr	r2, [sp, #96]	; 0x60
   17288:	9b14      	ldr	r3, [sp, #80]	; 0x50
   1728a:	4694      	mov	ip, r2
   1728c:	9a15      	ldr	r2, [sp, #84]	; 0x54
   1728e:	4463      	add	r3, ip
   17290:	9310      	str	r3, [sp, #64]	; 0x40
   17292:	2a00      	cmp	r2, #0
   17294:	dc00      	bgt.n	17298 <_vfprintf_r+0x1620>
   17296:	e0a6      	b.n	173e6 <_vfprintf_r+0x176e>
   17298:	001a      	movs	r2, r3
   1729a:	43db      	mvns	r3, r3
   1729c:	17db      	asrs	r3, r3, #31
   1729e:	4013      	ands	r3, r2
   172a0:	2267      	movs	r2, #103	; 0x67
   172a2:	9213      	str	r2, [sp, #76]	; 0x4c
   172a4:	e599      	b.n	16dda <_vfprintf_r+0x1162>
   172a6:	46c0      	nop			; (mov r8, r8)
   172a8:	00022d38 	.word	0x00022d38
   172ac:	00022d70 	.word	0x00022d70
   172b0:	2280      	movs	r2, #128	; 0x80
   172b2:	0612      	lsls	r2, r2, #24
   172b4:	4694      	mov	ip, r2
   172b6:	9b16      	ldr	r3, [sp, #88]	; 0x58
   172b8:	4699      	mov	r9, r3
   172ba:	9b17      	ldr	r3, [sp, #92]	; 0x5c
   172bc:	4463      	add	r3, ip
   172be:	4698      	mov	r8, r3
   172c0:	232d      	movs	r3, #45	; 0x2d
   172c2:	9309      	str	r3, [sp, #36]	; 0x24
   172c4:	e52f      	b.n	16d26 <_vfprintf_r+0x10ae>
   172c6:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   172c8:	9315      	str	r3, [sp, #84]	; 0x54
   172ca:	2b00      	cmp	r3, #0
   172cc:	dc00      	bgt.n	172d0 <_vfprintf_r+0x1658>
   172ce:	e0a4      	b.n	1741a <_vfprintf_r+0x17a2>
   172d0:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
   172d2:	2a00      	cmp	r2, #0
   172d4:	d15d      	bne.n	17392 <_vfprintf_r+0x171a>
   172d6:	9a08      	ldr	r2, [sp, #32]
   172d8:	07d2      	lsls	r2, r2, #31
   172da:	d45a      	bmi.n	17392 <_vfprintf_r+0x171a>
   172dc:	9310      	str	r3, [sp, #64]	; 0x40
   172de:	e57c      	b.n	16dda <_vfprintf_r+0x1162>
   172e0:	9b12      	ldr	r3, [sp, #72]	; 0x48
   172e2:	4453      	add	r3, sl
   172e4:	001c      	movs	r4, r3
   172e6:	9b13      	ldr	r3, [sp, #76]	; 0x4c
   172e8:	2b47      	cmp	r3, #71	; 0x47
   172ea:	d000      	beq.n	172ee <_vfprintf_r+0x1676>
   172ec:	e543      	b.n	16d76 <_vfprintf_r+0x10fe>
   172ee:	9b08      	ldr	r3, [sp, #32]
   172f0:	07db      	lsls	r3, r3, #31
   172f2:	d500      	bpl.n	172f6 <_vfprintf_r+0x167e>
   172f4:	e660      	b.n	16fb8 <_vfprintf_r+0x1340>
   172f6:	9b23      	ldr	r3, [sp, #140]	; 0x8c
   172f8:	9a12      	ldr	r2, [sp, #72]	; 0x48
   172fa:	1a9b      	subs	r3, r3, r2
   172fc:	9314      	str	r3, [sp, #80]	; 0x50
   172fe:	2d47      	cmp	r5, #71	; 0x47
   17300:	d100      	bne.n	17304 <_vfprintf_r+0x168c>
   17302:	e6d1      	b.n	170a8 <_vfprintf_r+0x1430>
   17304:	9c1f      	ldr	r4, [sp, #124]	; 0x7c
   17306:	e709      	b.n	1711c <_vfprintf_r+0x14a4>
   17308:	ab16      	add	r3, sp, #88	; 0x58
   1730a:	7fdb      	ldrb	r3, [r3, #31]
   1730c:	9411      	str	r4, [sp, #68]	; 0x44
   1730e:	4698      	mov	r8, r3
   17310:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   17312:	9309      	str	r3, [sp, #36]	; 0x24
   17314:	9310      	str	r3, [sp, #64]	; 0x40
   17316:	2300      	movs	r3, #0
   17318:	930b      	str	r3, [sp, #44]	; 0x2c
   1731a:	9315      	str	r3, [sp, #84]	; 0x54
   1731c:	f7fe ff07 	bl	1612e <_vfprintf_r+0x4b6>
   17320:	4698      	mov	r8, r3
   17322:	9b08      	ldr	r3, [sp, #32]
   17324:	07db      	lsls	r3, r3, #31
   17326:	d505      	bpl.n	17334 <_vfprintf_r+0x16bc>
   17328:	2130      	movs	r1, #48	; 0x30
   1732a:	2327      	movs	r3, #39	; 0x27
   1732c:	aa28      	add	r2, sp, #160	; 0xa0
   1732e:	54d1      	strb	r1, [r2, r3]
   17330:	f7ff fae5 	bl	168fe <_vfprintf_r+0xc86>
   17334:	2300      	movs	r3, #0
   17336:	9310      	str	r3, [sp, #64]	; 0x40
   17338:	ab32      	add	r3, sp, #200	; 0xc8
   1733a:	9312      	str	r3, [sp, #72]	; 0x48
   1733c:	f7fe feee 	bl	1611c <_vfprintf_r+0x4a4>
   17340:	003a      	movs	r2, r7
   17342:	4659      	mov	r1, fp
   17344:	9807      	ldr	r0, [sp, #28]
   17346:	f004 fbb3 	bl	1bab0 <__sprint_r>
   1734a:	2800      	cmp	r0, #0
   1734c:	d001      	beq.n	17352 <_vfprintf_r+0x16da>
   1734e:	f7ff faac 	bl	168aa <_vfprintf_r+0xc32>
   17352:	981f      	ldr	r0, [sp, #124]	; 0x7c
   17354:	68b9      	ldr	r1, [r7, #8]
   17356:	687b      	ldr	r3, [r7, #4]
   17358:	aa32      	add	r2, sp, #200	; 0xc8
   1735a:	e5a6      	b.n	16eaa <_vfprintf_r+0x1232>
   1735c:	2200      	movs	r2, #0
   1735e:	4641      	mov	r1, r8
   17360:	920b      	str	r2, [sp, #44]	; 0x2c
   17362:	f7fe fd0d 	bl	15d80 <_vfprintf_r+0x108>
   17366:	9a18      	ldr	r2, [sp, #96]	; 0x60
   17368:	9b15      	ldr	r3, [sp, #84]	; 0x54
   1736a:	4694      	mov	ip, r2
   1736c:	4463      	add	r3, ip
   1736e:	001a      	movs	r2, r3
   17370:	9310      	str	r3, [sp, #64]	; 0x40
   17372:	e792      	b.n	1729a <_vfprintf_r+0x1622>
   17374:	9311      	str	r3, [sp, #68]	; 0x44
   17376:	e49b      	b.n	16cb0 <_vfprintf_r+0x1038>
   17378:	2330      	movs	r3, #48	; 0x30
   1737a:	3430      	adds	r4, #48	; 0x30
   1737c:	70ab      	strb	r3, [r5, #2]
   1737e:	70ec      	strb	r4, [r5, #3]
   17380:	ab22      	add	r3, sp, #136	; 0x88
   17382:	e70d      	b.n	171a0 <_vfprintf_r+0x1528>
   17384:	9b23      	ldr	r3, [sp, #140]	; 0x8c
   17386:	e509      	b.n	16d9c <_vfprintf_r+0x1124>
   17388:	9311      	str	r3, [sp, #68]	; 0x44
   1738a:	2300      	movs	r3, #0
   1738c:	4698      	mov	r8, r3
   1738e:	f7ff fbc4 	bl	16b1a <_vfprintf_r+0xea2>
   17392:	9a18      	ldr	r2, [sp, #96]	; 0x60
   17394:	9b15      	ldr	r3, [sp, #84]	; 0x54
   17396:	4694      	mov	ip, r2
   17398:	4463      	add	r3, ip
   1739a:	0018      	movs	r0, r3
   1739c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   1739e:	469c      	mov	ip, r3
   173a0:	4484      	add	ip, r0
   173a2:	4663      	mov	r3, ip
   173a4:	9310      	str	r3, [sp, #64]	; 0x40
   173a6:	43db      	mvns	r3, r3
   173a8:	4662      	mov	r2, ip
   173aa:	17db      	asrs	r3, r3, #31
   173ac:	4013      	ands	r3, r2
   173ae:	e514      	b.n	16dda <_vfprintf_r+0x1162>
   173b0:	46a8      	mov	r8, r5
   173b2:	f7ff fa4d 	bl	16850 <_vfprintf_r+0xbd8>
   173b6:	9b13      	ldr	r3, [sp, #76]	; 0x4c
   173b8:	2b47      	cmp	r3, #71	; 0x47
   173ba:	dc20      	bgt.n	173fe <_vfprintf_r+0x1786>
   173bc:	4b34      	ldr	r3, [pc, #208]	; (17490 <_vfprintf_r+0x1818>)
   173be:	9312      	str	r3, [sp, #72]	; 0x48
   173c0:	2380      	movs	r3, #128	; 0x80
   173c2:	9a08      	ldr	r2, [sp, #32]
   173c4:	439a      	bics	r2, r3
   173c6:	ab16      	add	r3, sp, #88	; 0x58
   173c8:	7fdb      	ldrb	r3, [r3, #31]
   173ca:	9208      	str	r2, [sp, #32]
   173cc:	4698      	mov	r8, r3
   173ce:	2303      	movs	r3, #3
   173d0:	f7fe fe3e 	bl	16050 <_vfprintf_r+0x3d8>
   173d4:	4a2f      	ldr	r2, [pc, #188]	; (17494 <_vfprintf_r+0x181c>)
   173d6:	687b      	ldr	r3, [r7, #4]
   173d8:	4691      	mov	r9, r2
   173da:	f7ff fbaa 	bl	16b32 <_vfprintf_r+0xeba>
   173de:	232d      	movs	r3, #45	; 0x2d
   173e0:	4264      	negs	r4, r4
   173e2:	706b      	strb	r3, [r5, #1]
   173e4:	e6a7      	b.n	17136 <_vfprintf_r+0x14be>
   173e6:	9b10      	ldr	r3, [sp, #64]	; 0x40
   173e8:	9a15      	ldr	r2, [sp, #84]	; 0x54
   173ea:	1a98      	subs	r0, r3, r2
   173ec:	1c43      	adds	r3, r0, #1
   173ee:	e7be      	b.n	1736e <_vfprintf_r+0x16f6>
   173f0:	9b08      	ldr	r3, [sp, #32]
   173f2:	07db      	lsls	r3, r3, #31
   173f4:	d500      	bpl.n	173f8 <_vfprintf_r+0x1780>
   173f6:	e6dd      	b.n	171b4 <_vfprintf_r+0x153c>
   173f8:	9a10      	ldr	r2, [sp, #64]	; 0x40
   173fa:	0013      	movs	r3, r2
   173fc:	e6e0      	b.n	171c0 <_vfprintf_r+0x1548>
   173fe:	4b26      	ldr	r3, [pc, #152]	; (17498 <_vfprintf_r+0x1820>)
   17400:	9312      	str	r3, [sp, #72]	; 0x48
   17402:	e7dd      	b.n	173c0 <_vfprintf_r+0x1748>
   17404:	9b11      	ldr	r3, [sp, #68]	; 0x44
   17406:	1d1a      	adds	r2, r3, #4
   17408:	681b      	ldr	r3, [r3, #0]
   1740a:	930b      	str	r3, [sp, #44]	; 0x2c
   1740c:	2b00      	cmp	r3, #0
   1740e:	db37      	blt.n	17480 <_vfprintf_r+0x1808>
   17410:	784b      	ldrb	r3, [r1, #1]
   17412:	9211      	str	r2, [sp, #68]	; 0x44
   17414:	4641      	mov	r1, r8
   17416:	f7fe fcb2 	bl	15d7e <_vfprintf_r+0x106>
   1741a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   1741c:	2b00      	cmp	r3, #0
   1741e:	d102      	bne.n	17426 <_vfprintf_r+0x17ae>
   17420:	9b08      	ldr	r3, [sp, #32]
   17422:	07db      	lsls	r3, r3, #31
   17424:	d502      	bpl.n	1742c <_vfprintf_r+0x17b4>
   17426:	9b18      	ldr	r3, [sp, #96]	; 0x60
   17428:	1c58      	adds	r0, r3, #1
   1742a:	e7b7      	b.n	1739c <_vfprintf_r+0x1724>
   1742c:	2201      	movs	r2, #1
   1742e:	2301      	movs	r3, #1
   17430:	9210      	str	r2, [sp, #64]	; 0x40
   17432:	e4d2      	b.n	16dda <_vfprintf_r+0x1162>
   17434:	ab16      	add	r3, sp, #88	; 0x58
   17436:	77dc      	strb	r4, [r3, #31]
   17438:	f7fe fdca 	bl	15fd0 <_vfprintf_r+0x358>
   1743c:	ab16      	add	r3, sp, #88	; 0x58
   1743e:	77dc      	strb	r4, [r3, #31]
   17440:	f7fe fe18 	bl	16074 <_vfprintf_r+0x3fc>
   17444:	aa16      	add	r2, sp, #88	; 0x58
   17446:	232e      	movs	r3, #46	; 0x2e
   17448:	4694      	mov	ip, r2
   1744a:	4463      	add	r3, ip
   1744c:	e6a8      	b.n	171a0 <_vfprintf_r+0x1528>
   1744e:	ab16      	add	r3, sp, #88	; 0x58
   17450:	77dc      	strb	r4, [r3, #31]
   17452:	f7fe fec4 	bl	161de <_vfprintf_r+0x566>
   17456:	ab16      	add	r3, sp, #88	; 0x58
   17458:	77dc      	strb	r4, [r3, #31]
   1745a:	f7fe ff5d 	bl	16318 <_vfprintf_r+0x6a0>
   1745e:	ab16      	add	r3, sp, #88	; 0x58
   17460:	77dc      	strb	r4, [r3, #31]
   17462:	f7fe fd55 	bl	15f10 <_vfprintf_r+0x298>
   17466:	ab16      	add	r3, sp, #88	; 0x58
   17468:	77dc      	strb	r4, [r3, #31]
   1746a:	490c      	ldr	r1, [pc, #48]	; (1749c <_vfprintf_r+0x1824>)
   1746c:	f7fe ffb9 	bl	163e2 <_vfprintf_r+0x76a>
   17470:	ab16      	add	r3, sp, #88	; 0x58
   17472:	77dc      	strb	r4, [r3, #31]
   17474:	f7ff f81d 	bl	164b2 <_vfprintf_r+0x83a>
   17478:	ab16      	add	r3, sp, #88	; 0x58
   1747a:	77dc      	strb	r4, [r3, #31]
   1747c:	f7fe ff31 	bl	162e2 <_vfprintf_r+0x66a>
   17480:	9211      	str	r2, [sp, #68]	; 0x44
   17482:	2201      	movs	r2, #1
   17484:	4252      	negs	r2, r2
   17486:	784b      	ldrb	r3, [r1, #1]
   17488:	920b      	str	r2, [sp, #44]	; 0x2c
   1748a:	4641      	mov	r1, r8
   1748c:	f7fe fc77 	bl	15d7e <_vfprintf_r+0x106>
   17490:	00022d40 	.word	0x00022d40
   17494:	00022d28 	.word	0x00022d28
   17498:	00022d44 	.word	0x00022d44
   1749c:	00022d5c 	.word	0x00022d5c

000174a0 <vfprintf>:
   174a0:	b510      	push	{r4, lr}
   174a2:	0004      	movs	r4, r0
   174a4:	0013      	movs	r3, r2
   174a6:	4a03      	ldr	r2, [pc, #12]	; (174b4 <vfprintf+0x14>)
   174a8:	6810      	ldr	r0, [r2, #0]
   174aa:	000a      	movs	r2, r1
   174ac:	0021      	movs	r1, r4
   174ae:	f7fe fbe3 	bl	15c78 <_vfprintf_r>
   174b2:	bd10      	pop	{r4, pc}
   174b4:	10010df0 	.word	0x10010df0

000174b8 <__sbprintf>:
   174b8:	b570      	push	{r4, r5, r6, lr}
   174ba:	0006      	movs	r6, r0
   174bc:	2002      	movs	r0, #2
   174be:	4c1a      	ldr	r4, [pc, #104]	; (17528 <__sbprintf+0x70>)
   174c0:	44a5      	add	sp, r4
   174c2:	000c      	movs	r4, r1
   174c4:	8989      	ldrh	r1, [r1, #12]
   174c6:	4381      	bics	r1, r0
   174c8:	4668      	mov	r0, sp
   174ca:	8181      	strh	r1, [r0, #12]
   174cc:	6e61      	ldr	r1, [r4, #100]	; 0x64
   174ce:	9119      	str	r1, [sp, #100]	; 0x64
   174d0:	89e1      	ldrh	r1, [r4, #14]
   174d2:	81c1      	strh	r1, [r0, #14]
   174d4:	69e1      	ldr	r1, [r4, #28]
   174d6:	0030      	movs	r0, r6
   174d8:	9107      	str	r1, [sp, #28]
   174da:	6a61      	ldr	r1, [r4, #36]	; 0x24
   174dc:	9109      	str	r1, [sp, #36]	; 0x24
   174de:	a91a      	add	r1, sp, #104	; 0x68
   174e0:	9100      	str	r1, [sp, #0]
   174e2:	9104      	str	r1, [sp, #16]
   174e4:	2180      	movs	r1, #128	; 0x80
   174e6:	00c9      	lsls	r1, r1, #3
   174e8:	9102      	str	r1, [sp, #8]
   174ea:	9105      	str	r1, [sp, #20]
   174ec:	2100      	movs	r1, #0
   174ee:	9106      	str	r1, [sp, #24]
   174f0:	4669      	mov	r1, sp
   174f2:	f7fe fbc1 	bl	15c78 <_vfprintf_r>
   174f6:	1e05      	subs	r5, r0, #0
   174f8:	db05      	blt.n	17506 <__sbprintf+0x4e>
   174fa:	4669      	mov	r1, sp
   174fc:	0030      	movs	r0, r6
   174fe:	f001 f9c3 	bl	18888 <_fflush_r>
   17502:	2800      	cmp	r0, #0
   17504:	d10c      	bne.n	17520 <__sbprintf+0x68>
   17506:	466b      	mov	r3, sp
   17508:	899b      	ldrh	r3, [r3, #12]
   1750a:	065b      	lsls	r3, r3, #25
   1750c:	d503      	bpl.n	17516 <__sbprintf+0x5e>
   1750e:	2340      	movs	r3, #64	; 0x40
   17510:	89a2      	ldrh	r2, [r4, #12]
   17512:	4313      	orrs	r3, r2
   17514:	81a3      	strh	r3, [r4, #12]
   17516:	0028      	movs	r0, r5
   17518:	238d      	movs	r3, #141	; 0x8d
   1751a:	00db      	lsls	r3, r3, #3
   1751c:	449d      	add	sp, r3
   1751e:	bd70      	pop	{r4, r5, r6, pc}
   17520:	2501      	movs	r5, #1
   17522:	426d      	negs	r5, r5
   17524:	e7ef      	b.n	17506 <__sbprintf+0x4e>
   17526:	46c0      	nop			; (mov r8, r8)
   17528:	fffffb98 	.word	0xfffffb98

0001752c <_vsnprintf_r>:
   1752c:	b530      	push	{r4, r5, lr}
   1752e:	0004      	movs	r4, r0
   17530:	b09b      	sub	sp, #108	; 0x6c
   17532:	0018      	movs	r0, r3
   17534:	2a00      	cmp	r2, #0
   17536:	db2e      	blt.n	17596 <_vsnprintf_r+0x6a>
   17538:	2382      	movs	r3, #130	; 0x82
   1753a:	466d      	mov	r5, sp
   1753c:	009b      	lsls	r3, r3, #2
   1753e:	81ab      	strh	r3, [r5, #12]
   17540:	9100      	str	r1, [sp, #0]
   17542:	9104      	str	r1, [sp, #16]
   17544:	2a00      	cmp	r2, #0
   17546:	d011      	beq.n	1756c <_vsnprintf_r+0x40>
   17548:	1e53      	subs	r3, r2, #1
   1754a:	9302      	str	r3, [sp, #8]
   1754c:	9305      	str	r3, [sp, #20]
   1754e:	2301      	movs	r3, #1
   17550:	425b      	negs	r3, r3
   17552:	81eb      	strh	r3, [r5, #14]
   17554:	0002      	movs	r2, r0
   17556:	9b1e      	ldr	r3, [sp, #120]	; 0x78
   17558:	4669      	mov	r1, sp
   1755a:	0020      	movs	r0, r4
   1755c:	f002 fe5c 	bl	1a218 <_svfprintf_r>
   17560:	1c43      	adds	r3, r0, #1
   17562:	db12      	blt.n	1758a <_vsnprintf_r+0x5e>
   17564:	2300      	movs	r3, #0
   17566:	9a00      	ldr	r2, [sp, #0]
   17568:	7013      	strb	r3, [r2, #0]
   1756a:	e00c      	b.n	17586 <_vsnprintf_r+0x5a>
   1756c:	2301      	movs	r3, #1
   1756e:	425b      	negs	r3, r3
   17570:	9202      	str	r2, [sp, #8]
   17572:	9205      	str	r2, [sp, #20]
   17574:	81eb      	strh	r3, [r5, #14]
   17576:	0002      	movs	r2, r0
   17578:	9b1e      	ldr	r3, [sp, #120]	; 0x78
   1757a:	4669      	mov	r1, sp
   1757c:	0020      	movs	r0, r4
   1757e:	f002 fe4b 	bl	1a218 <_svfprintf_r>
   17582:	1c43      	adds	r3, r0, #1
   17584:	db04      	blt.n	17590 <_vsnprintf_r+0x64>
   17586:	b01b      	add	sp, #108	; 0x6c
   17588:	bd30      	pop	{r4, r5, pc}
   1758a:	238b      	movs	r3, #139	; 0x8b
   1758c:	6023      	str	r3, [r4, #0]
   1758e:	e7e9      	b.n	17564 <_vsnprintf_r+0x38>
   17590:	238b      	movs	r3, #139	; 0x8b
   17592:	6023      	str	r3, [r4, #0]
   17594:	e7f7      	b.n	17586 <_vsnprintf_r+0x5a>
   17596:	238b      	movs	r3, #139	; 0x8b
   17598:	2001      	movs	r0, #1
   1759a:	6023      	str	r3, [r4, #0]
   1759c:	4240      	negs	r0, r0
   1759e:	e7f2      	b.n	17586 <_vsnprintf_r+0x5a>

000175a0 <vsnprintf>:
   175a0:	b510      	push	{r4, lr}
   175a2:	0004      	movs	r4, r0
   175a4:	4805      	ldr	r0, [pc, #20]	; (175bc <vsnprintf+0x1c>)
   175a6:	b082      	sub	sp, #8
   175a8:	6800      	ldr	r0, [r0, #0]
   175aa:	9300      	str	r3, [sp, #0]
   175ac:	0013      	movs	r3, r2
   175ae:	000a      	movs	r2, r1
   175b0:	0021      	movs	r1, r4
   175b2:	f7ff ffbb 	bl	1752c <_vsnprintf_r>
   175b6:	b002      	add	sp, #8
   175b8:	bd10      	pop	{r4, pc}
   175ba:	46c0      	nop			; (mov r8, r8)
   175bc:	10010df0 	.word	0x10010df0

000175c0 <__swsetup_r>:
   175c0:	4b33      	ldr	r3, [pc, #204]	; (17690 <__swsetup_r+0xd0>)
   175c2:	b570      	push	{r4, r5, r6, lr}
   175c4:	0005      	movs	r5, r0
   175c6:	6818      	ldr	r0, [r3, #0]
   175c8:	000c      	movs	r4, r1
   175ca:	2800      	cmp	r0, #0
   175cc:	d002      	beq.n	175d4 <__swsetup_r+0x14>
   175ce:	6b83      	ldr	r3, [r0, #56]	; 0x38
   175d0:	2b00      	cmp	r3, #0
   175d2:	d03d      	beq.n	17650 <__swsetup_r+0x90>
   175d4:	230c      	movs	r3, #12
   175d6:	5ee0      	ldrsh	r0, [r4, r3]
   175d8:	b283      	uxth	r3, r0
   175da:	071a      	lsls	r2, r3, #28
   175dc:	d50d      	bpl.n	175fa <__swsetup_r+0x3a>
   175de:	6921      	ldr	r1, [r4, #16]
   175e0:	2900      	cmp	r1, #0
   175e2:	d016      	beq.n	17612 <__swsetup_r+0x52>
   175e4:	07da      	lsls	r2, r3, #31
   175e6:	d522      	bpl.n	1762e <__swsetup_r+0x6e>
   175e8:	2300      	movs	r3, #0
   175ea:	60a3      	str	r3, [r4, #8]
   175ec:	6963      	ldr	r3, [r4, #20]
   175ee:	2000      	movs	r0, #0
   175f0:	425b      	negs	r3, r3
   175f2:	61a3      	str	r3, [r4, #24]
   175f4:	2900      	cmp	r1, #0
   175f6:	d022      	beq.n	1763e <__swsetup_r+0x7e>
   175f8:	bd70      	pop	{r4, r5, r6, pc}
   175fa:	06da      	lsls	r2, r3, #27
   175fc:	d540      	bpl.n	17680 <__swsetup_r+0xc0>
   175fe:	075b      	lsls	r3, r3, #29
   17600:	d429      	bmi.n	17656 <__swsetup_r+0x96>
   17602:	6921      	ldr	r1, [r4, #16]
   17604:	2208      	movs	r2, #8
   17606:	0003      	movs	r3, r0
   17608:	4313      	orrs	r3, r2
   1760a:	81a3      	strh	r3, [r4, #12]
   1760c:	b29b      	uxth	r3, r3
   1760e:	2900      	cmp	r1, #0
   17610:	d1e8      	bne.n	175e4 <__swsetup_r+0x24>
   17612:	22a0      	movs	r2, #160	; 0xa0
   17614:	2080      	movs	r0, #128	; 0x80
   17616:	0092      	lsls	r2, r2, #2
   17618:	0080      	lsls	r0, r0, #2
   1761a:	401a      	ands	r2, r3
   1761c:	4282      	cmp	r2, r0
   1761e:	d0e1      	beq.n	175e4 <__swsetup_r+0x24>
   17620:	0021      	movs	r1, r4
   17622:	0028      	movs	r0, r5
   17624:	f001 fdc8 	bl	191b8 <__smakebuf_r>
   17628:	89a3      	ldrh	r3, [r4, #12]
   1762a:	6921      	ldr	r1, [r4, #16]
   1762c:	e7da      	b.n	175e4 <__swsetup_r+0x24>
   1762e:	2200      	movs	r2, #0
   17630:	079b      	lsls	r3, r3, #30
   17632:	d400      	bmi.n	17636 <__swsetup_r+0x76>
   17634:	6962      	ldr	r2, [r4, #20]
   17636:	60a2      	str	r2, [r4, #8]
   17638:	2000      	movs	r0, #0
   1763a:	2900      	cmp	r1, #0
   1763c:	d1dc      	bne.n	175f8 <__swsetup_r+0x38>
   1763e:	220c      	movs	r2, #12
   17640:	5ea3      	ldrsh	r3, [r4, r2]
   17642:	061a      	lsls	r2, r3, #24
   17644:	d5d8      	bpl.n	175f8 <__swsetup_r+0x38>
   17646:	2240      	movs	r2, #64	; 0x40
   17648:	4313      	orrs	r3, r2
   1764a:	81a3      	strh	r3, [r4, #12]
   1764c:	3801      	subs	r0, #1
   1764e:	e7d3      	b.n	175f8 <__swsetup_r+0x38>
   17650:	f001 fa34 	bl	18abc <__sinit>
   17654:	e7be      	b.n	175d4 <__swsetup_r+0x14>
   17656:	6b21      	ldr	r1, [r4, #48]	; 0x30
   17658:	2900      	cmp	r1, #0
   1765a:	d00a      	beq.n	17672 <__swsetup_r+0xb2>
   1765c:	0023      	movs	r3, r4
   1765e:	3340      	adds	r3, #64	; 0x40
   17660:	4299      	cmp	r1, r3
   17662:	d004      	beq.n	1766e <__swsetup_r+0xae>
   17664:	0028      	movs	r0, r5
   17666:	f001 faa1 	bl	18bac <_free_r>
   1766a:	230c      	movs	r3, #12
   1766c:	5ee0      	ldrsh	r0, [r4, r3]
   1766e:	2300      	movs	r3, #0
   17670:	6323      	str	r3, [r4, #48]	; 0x30
   17672:	2324      	movs	r3, #36	; 0x24
   17674:	4398      	bics	r0, r3
   17676:	2300      	movs	r3, #0
   17678:	6921      	ldr	r1, [r4, #16]
   1767a:	6063      	str	r3, [r4, #4]
   1767c:	6021      	str	r1, [r4, #0]
   1767e:	e7c1      	b.n	17604 <__swsetup_r+0x44>
   17680:	2309      	movs	r3, #9
   17682:	602b      	str	r3, [r5, #0]
   17684:	2340      	movs	r3, #64	; 0x40
   17686:	4303      	orrs	r3, r0
   17688:	2001      	movs	r0, #1
   1768a:	81a3      	strh	r3, [r4, #12]
   1768c:	4240      	negs	r0, r0
   1768e:	e7b3      	b.n	175f8 <__swsetup_r+0x38>
   17690:	10010df0 	.word	0x10010df0

00017694 <quorem>:
   17694:	b5f0      	push	{r4, r5, r6, r7, lr}
   17696:	4644      	mov	r4, r8
   17698:	4680      	mov	r8, r0
   1769a:	465f      	mov	r7, fp
   1769c:	4656      	mov	r6, sl
   1769e:	464d      	mov	r5, r9
   176a0:	4642      	mov	r2, r8
   176a2:	b4f0      	push	{r4, r5, r6, r7}
   176a4:	6912      	ldr	r2, [r2, #16]
   176a6:	690c      	ldr	r4, [r1, #16]
   176a8:	b085      	sub	sp, #20
   176aa:	000b      	movs	r3, r1
   176ac:	9103      	str	r1, [sp, #12]
   176ae:	2000      	movs	r0, #0
   176b0:	4294      	cmp	r4, r2
   176b2:	dd00      	ble.n	176b6 <quorem+0x22>
   176b4:	e08e      	b.n	177d4 <quorem+0x140>
   176b6:	2214      	movs	r2, #20
   176b8:	4694      	mov	ip, r2
   176ba:	4463      	add	r3, ip
   176bc:	4699      	mov	r9, r3
   176be:	464a      	mov	r2, r9
   176c0:	3c01      	subs	r4, #1
   176c2:	00a3      	lsls	r3, r4, #2
   176c4:	18d6      	adds	r6, r2, r3
   176c6:	2214      	movs	r2, #20
   176c8:	4442      	add	r2, r8
   176ca:	4693      	mov	fp, r2
   176cc:	449b      	add	fp, r3
   176ce:	6833      	ldr	r3, [r6, #0]
   176d0:	0015      	movs	r5, r2
   176d2:	1c59      	adds	r1, r3, #1
   176d4:	465b      	mov	r3, fp
   176d6:	6818      	ldr	r0, [r3, #0]
   176d8:	9202      	str	r2, [sp, #8]
   176da:	f7ec fe08 	bl	42ee <__aeabi_uidiv>
   176de:	1e03      	subs	r3, r0, #0
   176e0:	9001      	str	r0, [sp, #4]
   176e2:	d040      	beq.n	17766 <quorem+0xd2>
   176e4:	2700      	movs	r7, #0
   176e6:	0029      	movs	r1, r5
   176e8:	46b4      	mov	ip, r6
   176ea:	001e      	movs	r6, r3
   176ec:	0023      	movs	r3, r4
   176ee:	46ca      	mov	sl, r9
   176f0:	003c      	movs	r4, r7
   176f2:	2000      	movs	r0, #0
   176f4:	464f      	mov	r7, r9
   176f6:	000d      	movs	r5, r1
   176f8:	4699      	mov	r9, r3
   176fa:	cf02      	ldmia	r7!, {r1}
   176fc:	040a      	lsls	r2, r1, #16
   176fe:	0c12      	lsrs	r2, r2, #16
   17700:	4372      	muls	r2, r6
   17702:	0c09      	lsrs	r1, r1, #16
   17704:	4371      	muls	r1, r6
   17706:	1912      	adds	r2, r2, r4
   17708:	0c13      	lsrs	r3, r2, #16
   1770a:	18c9      	adds	r1, r1, r3
   1770c:	682b      	ldr	r3, [r5, #0]
   1770e:	0412      	lsls	r2, r2, #16
   17710:	041b      	lsls	r3, r3, #16
   17712:	0c1b      	lsrs	r3, r3, #16
   17714:	181b      	adds	r3, r3, r0
   17716:	0c12      	lsrs	r2, r2, #16
   17718:	1a9b      	subs	r3, r3, r2
   1771a:	682a      	ldr	r2, [r5, #0]
   1771c:	0c0c      	lsrs	r4, r1, #16
   1771e:	0409      	lsls	r1, r1, #16
   17720:	0c12      	lsrs	r2, r2, #16
   17722:	0c09      	lsrs	r1, r1, #16
   17724:	1418      	asrs	r0, r3, #16
   17726:	1a51      	subs	r1, r2, r1
   17728:	1809      	adds	r1, r1, r0
   1772a:	041b      	lsls	r3, r3, #16
   1772c:	1408      	asrs	r0, r1, #16
   1772e:	0c1b      	lsrs	r3, r3, #16
   17730:	0409      	lsls	r1, r1, #16
   17732:	430b      	orrs	r3, r1
   17734:	c508      	stmia	r5!, {r3}
   17736:	45bc      	cmp	ip, r7
   17738:	d2df      	bcs.n	176fa <quorem+0x66>
   1773a:	465b      	mov	r3, fp
   1773c:	681b      	ldr	r3, [r3, #0]
   1773e:	464c      	mov	r4, r9
   17740:	4666      	mov	r6, ip
   17742:	46d1      	mov	r9, sl
   17744:	2b00      	cmp	r3, #0
   17746:	d10e      	bne.n	17766 <quorem+0xd2>
   17748:	465b      	mov	r3, fp
   1774a:	9a02      	ldr	r2, [sp, #8]
   1774c:	3b04      	subs	r3, #4
   1774e:	429a      	cmp	r2, r3
   17750:	d304      	bcc.n	1775c <quorem+0xc8>
   17752:	e006      	b.n	17762 <quorem+0xce>
   17754:	3b04      	subs	r3, #4
   17756:	3c01      	subs	r4, #1
   17758:	429a      	cmp	r2, r3
   1775a:	d202      	bcs.n	17762 <quorem+0xce>
   1775c:	6819      	ldr	r1, [r3, #0]
   1775e:	2900      	cmp	r1, #0
   17760:	d0f8      	beq.n	17754 <quorem+0xc0>
   17762:	4643      	mov	r3, r8
   17764:	611c      	str	r4, [r3, #16]
   17766:	9903      	ldr	r1, [sp, #12]
   17768:	4640      	mov	r0, r8
   1776a:	f002 f87f 	bl	1986c <__mcmp>
   1776e:	2800      	cmp	r0, #0
   17770:	db2f      	blt.n	177d2 <quorem+0x13e>
   17772:	464f      	mov	r7, r9
   17774:	2000      	movs	r0, #0
   17776:	9b01      	ldr	r3, [sp, #4]
   17778:	9d02      	ldr	r5, [sp, #8]
   1777a:	3301      	adds	r3, #1
   1777c:	9301      	str	r3, [sp, #4]
   1777e:	6829      	ldr	r1, [r5, #0]
   17780:	cf04      	ldmia	r7!, {r2}
   17782:	040b      	lsls	r3, r1, #16
   17784:	0c1b      	lsrs	r3, r3, #16
   17786:	1818      	adds	r0, r3, r0
   17788:	0413      	lsls	r3, r2, #16
   1778a:	0c1b      	lsrs	r3, r3, #16
   1778c:	1ac3      	subs	r3, r0, r3
   1778e:	0c09      	lsrs	r1, r1, #16
   17790:	0c12      	lsrs	r2, r2, #16
   17792:	1a8a      	subs	r2, r1, r2
   17794:	1419      	asrs	r1, r3, #16
   17796:	1852      	adds	r2, r2, r1
   17798:	041b      	lsls	r3, r3, #16
   1779a:	1410      	asrs	r0, r2, #16
   1779c:	0c1b      	lsrs	r3, r3, #16
   1779e:	0412      	lsls	r2, r2, #16
   177a0:	431a      	orrs	r2, r3
   177a2:	c504      	stmia	r5!, {r2}
   177a4:	42be      	cmp	r6, r7
   177a6:	d2ea      	bcs.n	1777e <quorem+0xea>
   177a8:	9902      	ldr	r1, [sp, #8]
   177aa:	00a3      	lsls	r3, r4, #2
   177ac:	468c      	mov	ip, r1
   177ae:	4463      	add	r3, ip
   177b0:	681a      	ldr	r2, [r3, #0]
   177b2:	2a00      	cmp	r2, #0
   177b4:	d10d      	bne.n	177d2 <quorem+0x13e>
   177b6:	3b04      	subs	r3, #4
   177b8:	000a      	movs	r2, r1
   177ba:	4299      	cmp	r1, r3
   177bc:	d304      	bcc.n	177c8 <quorem+0x134>
   177be:	e006      	b.n	177ce <quorem+0x13a>
   177c0:	3b04      	subs	r3, #4
   177c2:	3c01      	subs	r4, #1
   177c4:	429a      	cmp	r2, r3
   177c6:	d202      	bcs.n	177ce <quorem+0x13a>
   177c8:	6819      	ldr	r1, [r3, #0]
   177ca:	2900      	cmp	r1, #0
   177cc:	d0f8      	beq.n	177c0 <quorem+0x12c>
   177ce:	4643      	mov	r3, r8
   177d0:	611c      	str	r4, [r3, #16]
   177d2:	9801      	ldr	r0, [sp, #4]
   177d4:	b005      	add	sp, #20
   177d6:	bc3c      	pop	{r2, r3, r4, r5}
   177d8:	4690      	mov	r8, r2
   177da:	4699      	mov	r9, r3
   177dc:	46a2      	mov	sl, r4
   177de:	46ab      	mov	fp, r5
   177e0:	bdf0      	pop	{r4, r5, r6, r7, pc}
   177e2:	46c0      	nop			; (mov r8, r8)

000177e4 <_dtoa_r>:
   177e4:	b5f0      	push	{r4, r5, r6, r7, lr}
   177e6:	465f      	mov	r7, fp
   177e8:	4656      	mov	r6, sl
   177ea:	464d      	mov	r5, r9
   177ec:	4644      	mov	r4, r8
   177ee:	b4f0      	push	{r4, r5, r6, r7}
   177f0:	0014      	movs	r4, r2
   177f2:	001d      	movs	r5, r3
   177f4:	6c01      	ldr	r1, [r0, #64]	; 0x40
   177f6:	b099      	sub	sp, #100	; 0x64
   177f8:	4683      	mov	fp, r0
   177fa:	9e25      	ldr	r6, [sp, #148]	; 0x94
   177fc:	9402      	str	r4, [sp, #8]
   177fe:	9503      	str	r5, [sp, #12]
   17800:	2900      	cmp	r1, #0
   17802:	d009      	beq.n	17818 <_dtoa_r+0x34>
   17804:	2301      	movs	r3, #1
   17806:	6c42      	ldr	r2, [r0, #68]	; 0x44
   17808:	4093      	lsls	r3, r2
   1780a:	604a      	str	r2, [r1, #4]
   1780c:	608b      	str	r3, [r1, #8]
   1780e:	f001 fdd3 	bl	193b8 <_Bfree>
   17812:	2300      	movs	r3, #0
   17814:	465a      	mov	r2, fp
   17816:	6413      	str	r3, [r2, #64]	; 0x40
   17818:	9f03      	ldr	r7, [sp, #12]
   1781a:	2f00      	cmp	r7, #0
   1781c:	db34      	blt.n	17888 <_dtoa_r+0xa4>
   1781e:	2300      	movs	r3, #0
   17820:	6033      	str	r3, [r6, #0]
   17822:	003a      	movs	r2, r7
   17824:	4bd3      	ldr	r3, [pc, #844]	; (17b74 <_dtoa_r+0x390>)
   17826:	401a      	ands	r2, r3
   17828:	429a      	cmp	r2, r3
   1782a:	d01a      	beq.n	17862 <_dtoa_r+0x7e>
   1782c:	9c02      	ldr	r4, [sp, #8]
   1782e:	9d03      	ldr	r5, [sp, #12]
   17830:	2200      	movs	r2, #0
   17832:	2300      	movs	r3, #0
   17834:	0020      	movs	r0, r4
   17836:	0029      	movs	r1, r5
   17838:	f006 fabc 	bl	1ddb4 <__aeabi_dcmpeq>
   1783c:	2800      	cmp	r0, #0
   1783e:	d029      	beq.n	17894 <_dtoa_r+0xb0>
   17840:	2301      	movs	r3, #1
   17842:	9a24      	ldr	r2, [sp, #144]	; 0x90
   17844:	6013      	str	r3, [r2, #0]
   17846:	9b26      	ldr	r3, [sp, #152]	; 0x98
   17848:	2b00      	cmp	r3, #0
   1784a:	d100      	bne.n	1784e <_dtoa_r+0x6a>
   1784c:	e22e      	b.n	17cac <_dtoa_r+0x4c8>
   1784e:	48ca      	ldr	r0, [pc, #808]	; (17b78 <_dtoa_r+0x394>)
   17850:	6018      	str	r0, [r3, #0]
   17852:	3801      	subs	r0, #1
   17854:	b019      	add	sp, #100	; 0x64
   17856:	bc3c      	pop	{r2, r3, r4, r5}
   17858:	4690      	mov	r8, r2
   1785a:	4699      	mov	r9, r3
   1785c:	46a2      	mov	sl, r4
   1785e:	46ab      	mov	fp, r5
   17860:	bdf0      	pop	{r4, r5, r6, r7, pc}
   17862:	4bc6      	ldr	r3, [pc, #792]	; (17b7c <_dtoa_r+0x398>)
   17864:	9a24      	ldr	r2, [sp, #144]	; 0x90
   17866:	6013      	str	r3, [r2, #0]
   17868:	9b02      	ldr	r3, [sp, #8]
   1786a:	2b00      	cmp	r3, #0
   1786c:	d100      	bne.n	17870 <_dtoa_r+0x8c>
   1786e:	e1fd      	b.n	17c6c <_dtoa_r+0x488>
   17870:	48c3      	ldr	r0, [pc, #780]	; (17b80 <_dtoa_r+0x39c>)
   17872:	9b26      	ldr	r3, [sp, #152]	; 0x98
   17874:	2b00      	cmp	r3, #0
   17876:	d0ed      	beq.n	17854 <_dtoa_r+0x70>
   17878:	78c2      	ldrb	r2, [r0, #3]
   1787a:	1cc3      	adds	r3, r0, #3
   1787c:	2a00      	cmp	r2, #0
   1787e:	d000      	beq.n	17882 <_dtoa_r+0x9e>
   17880:	3305      	adds	r3, #5
   17882:	9a26      	ldr	r2, [sp, #152]	; 0x98
   17884:	6013      	str	r3, [r2, #0]
   17886:	e7e5      	b.n	17854 <_dtoa_r+0x70>
   17888:	2301      	movs	r3, #1
   1788a:	0068      	lsls	r0, r5, #1
   1788c:	0847      	lsrs	r7, r0, #1
   1788e:	6033      	str	r3, [r6, #0]
   17890:	9703      	str	r7, [sp, #12]
   17892:	e7c6      	b.n	17822 <_dtoa_r+0x3e>
   17894:	ab16      	add	r3, sp, #88	; 0x58
   17896:	9301      	str	r3, [sp, #4]
   17898:	ab17      	add	r3, sp, #92	; 0x5c
   1789a:	9300      	str	r3, [sp, #0]
   1789c:	0022      	movs	r2, r4
   1789e:	002b      	movs	r3, r5
   178a0:	4658      	mov	r0, fp
   178a2:	f002 f921 	bl	19ae8 <__d2b>
   178a6:	0d3e      	lsrs	r6, r7, #20
   178a8:	900a      	str	r0, [sp, #40]	; 0x28
   178aa:	d100      	bne.n	178ae <_dtoa_r+0xca>
   178ac:	e1e3      	b.n	17c76 <_dtoa_r+0x492>
   178ae:	032b      	lsls	r3, r5, #12
   178b0:	4ab4      	ldr	r2, [pc, #720]	; (17b84 <_dtoa_r+0x3a0>)
   178b2:	0b1b      	lsrs	r3, r3, #12
   178b4:	431a      	orrs	r2, r3
   178b6:	4bb4      	ldr	r3, [pc, #720]	; (17b88 <_dtoa_r+0x3a4>)
   178b8:	0020      	movs	r0, r4
   178ba:	469c      	mov	ip, r3
   178bc:	9b16      	ldr	r3, [sp, #88]	; 0x58
   178be:	0011      	movs	r1, r2
   178c0:	4698      	mov	r8, r3
   178c2:	2300      	movs	r3, #0
   178c4:	4466      	add	r6, ip
   178c6:	9312      	str	r3, [sp, #72]	; 0x48
   178c8:	2200      	movs	r2, #0
   178ca:	4bb0      	ldr	r3, [pc, #704]	; (17b8c <_dtoa_r+0x3a8>)
   178cc:	f007 fdb4 	bl	1f438 <__aeabi_dsub>
   178d0:	4aaf      	ldr	r2, [pc, #700]	; (17b90 <_dtoa_r+0x3ac>)
   178d2:	4bb0      	ldr	r3, [pc, #704]	; (17b94 <_dtoa_r+0x3b0>)
   178d4:	f007 fb36 	bl	1ef44 <__aeabi_dmul>
   178d8:	4aaf      	ldr	r2, [pc, #700]	; (17b98 <_dtoa_r+0x3b4>)
   178da:	4bb0      	ldr	r3, [pc, #704]	; (17b9c <_dtoa_r+0x3b8>)
   178dc:	f006 fbe2 	bl	1e0a4 <__aeabi_dadd>
   178e0:	0004      	movs	r4, r0
   178e2:	0030      	movs	r0, r6
   178e4:	000d      	movs	r5, r1
   178e6:	f008 f951 	bl	1fb8c <__aeabi_i2d>
   178ea:	4aad      	ldr	r2, [pc, #692]	; (17ba0 <_dtoa_r+0x3bc>)
   178ec:	4bad      	ldr	r3, [pc, #692]	; (17ba4 <_dtoa_r+0x3c0>)
   178ee:	f007 fb29 	bl	1ef44 <__aeabi_dmul>
   178f2:	0002      	movs	r2, r0
   178f4:	000b      	movs	r3, r1
   178f6:	0020      	movs	r0, r4
   178f8:	0029      	movs	r1, r5
   178fa:	f006 fbd3 	bl	1e0a4 <__aeabi_dadd>
   178fe:	0004      	movs	r4, r0
   17900:	000d      	movs	r5, r1
   17902:	f008 f90d 	bl	1fb20 <__aeabi_d2iz>
   17906:	2200      	movs	r2, #0
   17908:	9005      	str	r0, [sp, #20]
   1790a:	2300      	movs	r3, #0
   1790c:	0020      	movs	r0, r4
   1790e:	0029      	movs	r1, r5
   17910:	f006 fa56 	bl	1ddc0 <__aeabi_dcmplt>
   17914:	2800      	cmp	r0, #0
   17916:	d000      	beq.n	1791a <_dtoa_r+0x136>
   17918:	e2b6      	b.n	17e88 <_dtoa_r+0x6a4>
   1791a:	2301      	movs	r3, #1
   1791c:	9c05      	ldr	r4, [sp, #20]
   1791e:	930d      	str	r3, [sp, #52]	; 0x34
   17920:	2c16      	cmp	r4, #22
   17922:	d810      	bhi.n	17946 <_dtoa_r+0x162>
   17924:	49a0      	ldr	r1, [pc, #640]	; (17ba8 <_dtoa_r+0x3c4>)
   17926:	00e3      	lsls	r3, r4, #3
   17928:	18c9      	adds	r1, r1, r3
   1792a:	6808      	ldr	r0, [r1, #0]
   1792c:	6849      	ldr	r1, [r1, #4]
   1792e:	9a02      	ldr	r2, [sp, #8]
   17930:	9b03      	ldr	r3, [sp, #12]
   17932:	f006 fa59 	bl	1dde8 <__aeabi_dcmpgt>
   17936:	2800      	cmp	r0, #0
   17938:	d100      	bne.n	1793c <_dtoa_r+0x158>
   1793a:	e3aa      	b.n	18092 <_dtoa_r+0x8ae>
   1793c:	0023      	movs	r3, r4
   1793e:	3b01      	subs	r3, #1
   17940:	9305      	str	r3, [sp, #20]
   17942:	2300      	movs	r3, #0
   17944:	930d      	str	r3, [sp, #52]	; 0x34
   17946:	4643      	mov	r3, r8
   17948:	1b9e      	subs	r6, r3, r6
   1794a:	2300      	movs	r3, #0
   1794c:	9306      	str	r3, [sp, #24]
   1794e:	3e01      	subs	r6, #1
   17950:	46b2      	mov	sl, r6
   17952:	d500      	bpl.n	17956 <_dtoa_r+0x172>
   17954:	e2a7      	b.n	17ea6 <_dtoa_r+0x6c2>
   17956:	9b05      	ldr	r3, [sp, #20]
   17958:	2b00      	cmp	r3, #0
   1795a:	da00      	bge.n	1795e <_dtoa_r+0x17a>
   1795c:	e28b      	b.n	17e76 <_dtoa_r+0x692>
   1795e:	469c      	mov	ip, r3
   17960:	930e      	str	r3, [sp, #56]	; 0x38
   17962:	2300      	movs	r3, #0
   17964:	44e2      	add	sl, ip
   17966:	930b      	str	r3, [sp, #44]	; 0x2c
   17968:	9b22      	ldr	r3, [sp, #136]	; 0x88
   1796a:	2b09      	cmp	r3, #9
   1796c:	d900      	bls.n	17970 <_dtoa_r+0x18c>
   1796e:	e19f      	b.n	17cb0 <_dtoa_r+0x4cc>
   17970:	2401      	movs	r4, #1
   17972:	2b05      	cmp	r3, #5
   17974:	dd02      	ble.n	1797c <_dtoa_r+0x198>
   17976:	2400      	movs	r4, #0
   17978:	3b04      	subs	r3, #4
   1797a:	9322      	str	r3, [sp, #136]	; 0x88
   1797c:	9b22      	ldr	r3, [sp, #136]	; 0x88
   1797e:	2b03      	cmp	r3, #3
   17980:	d101      	bne.n	17986 <_dtoa_r+0x1a2>
   17982:	f000 fcd8 	bl	18336 <_dtoa_r+0xb52>
   17986:	dc01      	bgt.n	1798c <_dtoa_r+0x1a8>
   17988:	f000 fc9d 	bl	182c6 <_dtoa_r+0xae2>
   1798c:	9b22      	ldr	r3, [sp, #136]	; 0x88
   1798e:	2b04      	cmp	r3, #4
   17990:	d100      	bne.n	17994 <_dtoa_r+0x1b0>
   17992:	e3a4      	b.n	180de <_dtoa_r+0x8fa>
   17994:	2301      	movs	r3, #1
   17996:	930c      	str	r3, [sp, #48]	; 0x30
   17998:	9b22      	ldr	r3, [sp, #136]	; 0x88
   1799a:	2b05      	cmp	r3, #5
   1799c:	d001      	beq.n	179a2 <_dtoa_r+0x1be>
   1799e:	f000 fc98 	bl	182d2 <_dtoa_r+0xaee>
   179a2:	9a23      	ldr	r2, [sp, #140]	; 0x8c
   179a4:	9b05      	ldr	r3, [sp, #20]
   179a6:	4694      	mov	ip, r2
   179a8:	4463      	add	r3, ip
   179aa:	930f      	str	r3, [sp, #60]	; 0x3c
   179ac:	3301      	adds	r3, #1
   179ae:	9308      	str	r3, [sp, #32]
   179b0:	1e1d      	subs	r5, r3, #0
   179b2:	dc01      	bgt.n	179b8 <_dtoa_r+0x1d4>
   179b4:	f000 fc66 	bl	18284 <_dtoa_r+0xaa0>
   179b8:	9d08      	ldr	r5, [sp, #32]
   179ba:	002e      	movs	r6, r5
   179bc:	2300      	movs	r3, #0
   179be:	465a      	mov	r2, fp
   179c0:	2100      	movs	r1, #0
   179c2:	6453      	str	r3, [r2, #68]	; 0x44
   179c4:	2e17      	cmp	r6, #23
   179c6:	d90a      	bls.n	179de <_dtoa_r+0x1fa>
   179c8:	2201      	movs	r2, #1
   179ca:	3304      	adds	r3, #4
   179cc:	005b      	lsls	r3, r3, #1
   179ce:	0018      	movs	r0, r3
   179d0:	3014      	adds	r0, #20
   179d2:	0011      	movs	r1, r2
   179d4:	3201      	adds	r2, #1
   179d6:	4286      	cmp	r6, r0
   179d8:	d2f8      	bcs.n	179cc <_dtoa_r+0x1e8>
   179da:	465b      	mov	r3, fp
   179dc:	6459      	str	r1, [r3, #68]	; 0x44
   179de:	4658      	mov	r0, fp
   179e0:	f001 fcc2 	bl	19368 <_Balloc>
   179e4:	465b      	mov	r3, fp
   179e6:	9009      	str	r0, [sp, #36]	; 0x24
   179e8:	6418      	str	r0, [r3, #64]	; 0x40
   179ea:	2d0e      	cmp	r5, #14
   179ec:	d900      	bls.n	179f0 <_dtoa_r+0x20c>
   179ee:	e172      	b.n	17cd6 <_dtoa_r+0x4f2>
   179f0:	2c00      	cmp	r4, #0
   179f2:	d100      	bne.n	179f6 <_dtoa_r+0x212>
   179f4:	e16f      	b.n	17cd6 <_dtoa_r+0x4f2>
   179f6:	9b02      	ldr	r3, [sp, #8]
   179f8:	9c03      	ldr	r4, [sp, #12]
   179fa:	9e05      	ldr	r6, [sp, #20]
   179fc:	9310      	str	r3, [sp, #64]	; 0x40
   179fe:	9411      	str	r4, [sp, #68]	; 0x44
   17a00:	2e00      	cmp	r6, #0
   17a02:	dc01      	bgt.n	17a08 <_dtoa_r+0x224>
   17a04:	f000 fd31 	bl	1846a <_dtoa_r+0xc86>
   17a08:	0031      	movs	r1, r6
   17a0a:	220f      	movs	r2, #15
   17a0c:	4011      	ands	r1, r2
   17a0e:	00cb      	lsls	r3, r1, #3
   17a10:	4965      	ldr	r1, [pc, #404]	; (17ba8 <_dtoa_r+0x3c4>)
   17a12:	1136      	asrs	r6, r6, #4
   17a14:	18cb      	adds	r3, r1, r3
   17a16:	681c      	ldr	r4, [r3, #0]
   17a18:	685d      	ldr	r5, [r3, #4]
   17a1a:	06f1      	lsls	r1, r6, #27
   17a1c:	d401      	bmi.n	17a22 <_dtoa_r+0x23e>
   17a1e:	f000 fcda 	bl	183d6 <_dtoa_r+0xbf2>
   17a22:	9810      	ldr	r0, [sp, #64]	; 0x40
   17a24:	9911      	ldr	r1, [sp, #68]	; 0x44
   17a26:	4b61      	ldr	r3, [pc, #388]	; (17bac <_dtoa_r+0x3c8>)
   17a28:	4016      	ands	r6, r2
   17a2a:	6a1a      	ldr	r2, [r3, #32]
   17a2c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   17a2e:	f006 fe65 	bl	1e6fc <__aeabi_ddiv>
   17a32:	2303      	movs	r3, #3
   17a34:	4698      	mov	r8, r3
   17a36:	9002      	str	r0, [sp, #8]
   17a38:	9103      	str	r1, [sp, #12]
   17a3a:	2e00      	cmp	r6, #0
   17a3c:	d014      	beq.n	17a68 <_dtoa_r+0x284>
   17a3e:	2301      	movs	r3, #1
   17a40:	4699      	mov	r9, r3
   17a42:	4f5a      	ldr	r7, [pc, #360]	; (17bac <_dtoa_r+0x3c8>)
   17a44:	464b      	mov	r3, r9
   17a46:	4233      	tst	r3, r6
   17a48:	d00a      	beq.n	17a60 <_dtoa_r+0x27c>
   17a4a:	2301      	movs	r3, #1
   17a4c:	469c      	mov	ip, r3
   17a4e:	683a      	ldr	r2, [r7, #0]
   17a50:	687b      	ldr	r3, [r7, #4]
   17a52:	0020      	movs	r0, r4
   17a54:	0029      	movs	r1, r5
   17a56:	44e0      	add	r8, ip
   17a58:	f007 fa74 	bl	1ef44 <__aeabi_dmul>
   17a5c:	0004      	movs	r4, r0
   17a5e:	000d      	movs	r5, r1
   17a60:	1076      	asrs	r6, r6, #1
   17a62:	3708      	adds	r7, #8
   17a64:	2e00      	cmp	r6, #0
   17a66:	d1ed      	bne.n	17a44 <_dtoa_r+0x260>
   17a68:	0022      	movs	r2, r4
   17a6a:	9802      	ldr	r0, [sp, #8]
   17a6c:	9903      	ldr	r1, [sp, #12]
   17a6e:	002b      	movs	r3, r5
   17a70:	f006 fe44 	bl	1e6fc <__aeabi_ddiv>
   17a74:	0006      	movs	r6, r0
   17a76:	000f      	movs	r7, r1
   17a78:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   17a7a:	2b00      	cmp	r3, #0
   17a7c:	d009      	beq.n	17a92 <_dtoa_r+0x2ae>
   17a7e:	2200      	movs	r2, #0
   17a80:	4b40      	ldr	r3, [pc, #256]	; (17b84 <_dtoa_r+0x3a0>)
   17a82:	0030      	movs	r0, r6
   17a84:	0039      	movs	r1, r7
   17a86:	f006 f99b 	bl	1ddc0 <__aeabi_dcmplt>
   17a8a:	2800      	cmp	r0, #0
   17a8c:	d001      	beq.n	17a92 <_dtoa_r+0x2ae>
   17a8e:	f000 fdc7 	bl	18620 <_dtoa_r+0xe3c>
   17a92:	4640      	mov	r0, r8
   17a94:	f008 f87a 	bl	1fb8c <__aeabi_i2d>
   17a98:	0032      	movs	r2, r6
   17a9a:	003b      	movs	r3, r7
   17a9c:	f007 fa52 	bl	1ef44 <__aeabi_dmul>
   17aa0:	2200      	movs	r2, #0
   17aa2:	4b43      	ldr	r3, [pc, #268]	; (17bb0 <_dtoa_r+0x3cc>)
   17aa4:	f006 fafe 	bl	1e0a4 <__aeabi_dadd>
   17aa8:	4a42      	ldr	r2, [pc, #264]	; (17bb4 <_dtoa_r+0x3d0>)
   17aaa:	000b      	movs	r3, r1
   17aac:	4694      	mov	ip, r2
   17aae:	4463      	add	r3, ip
   17ab0:	9002      	str	r0, [sp, #8]
   17ab2:	9103      	str	r1, [sp, #12]
   17ab4:	9303      	str	r3, [sp, #12]
   17ab6:	9b08      	ldr	r3, [sp, #32]
   17ab8:	2b00      	cmp	r3, #0
   17aba:	d101      	bne.n	17ac0 <_dtoa_r+0x2dc>
   17abc:	f000 fc5c 	bl	18378 <_dtoa_r+0xb94>
   17ac0:	9b05      	ldr	r3, [sp, #20]
   17ac2:	9314      	str	r3, [sp, #80]	; 0x50
   17ac4:	9b08      	ldr	r3, [sp, #32]
   17ac6:	9313      	str	r3, [sp, #76]	; 0x4c
   17ac8:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   17aca:	2b00      	cmp	r3, #0
   17acc:	d101      	bne.n	17ad2 <_dtoa_r+0x2ee>
   17ace:	f000 fd1a 	bl	18506 <_dtoa_r+0xd22>
   17ad2:	9b13      	ldr	r3, [sp, #76]	; 0x4c
   17ad4:	4a34      	ldr	r2, [pc, #208]	; (17ba8 <_dtoa_r+0x3c4>)
   17ad6:	3b01      	subs	r3, #1
   17ad8:	00db      	lsls	r3, r3, #3
   17ada:	18d3      	adds	r3, r2, r3
   17adc:	681a      	ldr	r2, [r3, #0]
   17ade:	685b      	ldr	r3, [r3, #4]
   17ae0:	2000      	movs	r0, #0
   17ae2:	4935      	ldr	r1, [pc, #212]	; (17bb8 <_dtoa_r+0x3d4>)
   17ae4:	f006 fe0a 	bl	1e6fc <__aeabi_ddiv>
   17ae8:	9a02      	ldr	r2, [sp, #8]
   17aea:	9b03      	ldr	r3, [sp, #12]
   17aec:	f007 fca4 	bl	1f438 <__aeabi_dsub>
   17af0:	9002      	str	r0, [sp, #8]
   17af2:	9103      	str	r1, [sp, #12]
   17af4:	0039      	movs	r1, r7
   17af6:	0030      	movs	r0, r6
   17af8:	f008 f812 	bl	1fb20 <__aeabi_d2iz>
   17afc:	0005      	movs	r5, r0
   17afe:	f008 f845 	bl	1fb8c <__aeabi_i2d>
   17b02:	0002      	movs	r2, r0
   17b04:	000b      	movs	r3, r1
   17b06:	0030      	movs	r0, r6
   17b08:	0039      	movs	r1, r7
   17b0a:	f007 fc95 	bl	1f438 <__aeabi_dsub>
   17b0e:	0006      	movs	r6, r0
   17b10:	000f      	movs	r7, r1
   17b12:	9a09      	ldr	r2, [sp, #36]	; 0x24
   17b14:	3530      	adds	r5, #48	; 0x30
   17b16:	b2e9      	uxtb	r1, r5
   17b18:	7011      	strb	r1, [r2, #0]
   17b1a:	1c54      	adds	r4, r2, #1
   17b1c:	4688      	mov	r8, r1
   17b1e:	9802      	ldr	r0, [sp, #8]
   17b20:	9903      	ldr	r1, [sp, #12]
   17b22:	0032      	movs	r2, r6
   17b24:	003b      	movs	r3, r7
   17b26:	f006 f95f 	bl	1dde8 <__aeabi_dcmpgt>
   17b2a:	2800      	cmp	r0, #0
   17b2c:	d000      	beq.n	17b30 <_dtoa_r+0x34c>
   17b2e:	e08a      	b.n	17c46 <_dtoa_r+0x462>
   17b30:	0032      	movs	r2, r6
   17b32:	003b      	movs	r3, r7
   17b34:	2000      	movs	r0, #0
   17b36:	4913      	ldr	r1, [pc, #76]	; (17b84 <_dtoa_r+0x3a0>)
   17b38:	f007 fc7e 	bl	1f438 <__aeabi_dsub>
   17b3c:	0002      	movs	r2, r0
   17b3e:	000b      	movs	r3, r1
   17b40:	9802      	ldr	r0, [sp, #8]
   17b42:	9903      	ldr	r1, [sp, #12]
   17b44:	f006 f950 	bl	1dde8 <__aeabi_dcmpgt>
   17b48:	2800      	cmp	r0, #0
   17b4a:	d001      	beq.n	17b50 <_dtoa_r+0x36c>
   17b4c:	f000 fdd8 	bl	18700 <_dtoa_r+0xf1c>
   17b50:	9b13      	ldr	r3, [sp, #76]	; 0x4c
   17b52:	2b01      	cmp	r3, #1
   17b54:	dc01      	bgt.n	17b5a <_dtoa_r+0x376>
   17b56:	f000 fc83 	bl	18460 <_dtoa_r+0xc7c>
   17b5a:	9a09      	ldr	r2, [sp, #36]	; 0x24
   17b5c:	9b13      	ldr	r3, [sp, #76]	; 0x4c
   17b5e:	4694      	mov	ip, r2
   17b60:	4463      	add	r3, ip
   17b62:	4699      	mov	r9, r3
   17b64:	4653      	mov	r3, sl
   17b66:	9313      	str	r3, [sp, #76]	; 0x4c
   17b68:	465b      	mov	r3, fp
   17b6a:	46a2      	mov	sl, r4
   17b6c:	9c02      	ldr	r4, [sp, #8]
   17b6e:	9d03      	ldr	r5, [sp, #12]
   17b70:	9302      	str	r3, [sp, #8]
   17b72:	e035      	b.n	17be0 <_dtoa_r+0x3fc>
   17b74:	7ff00000 	.word	0x7ff00000
   17b78:	00022d79 	.word	0x00022d79
   17b7c:	0000270f 	.word	0x0000270f
   17b80:	00022d98 	.word	0x00022d98
   17b84:	3ff00000 	.word	0x3ff00000
   17b88:	fffffc01 	.word	0xfffffc01
   17b8c:	3ff80000 	.word	0x3ff80000
   17b90:	636f4361 	.word	0x636f4361
   17b94:	3fd287a7 	.word	0x3fd287a7
   17b98:	8b60c8b3 	.word	0x8b60c8b3
   17b9c:	3fc68a28 	.word	0x3fc68a28
   17ba0:	509f79fb 	.word	0x509f79fb
   17ba4:	3fd34413 	.word	0x3fd34413
   17ba8:	00022da0 	.word	0x00022da0
   17bac:	00022e78 	.word	0x00022e78
   17bb0:	401c0000 	.word	0x401c0000
   17bb4:	fcc00000 	.word	0xfcc00000
   17bb8:	3fe00000 	.word	0x3fe00000
   17bbc:	0032      	movs	r2, r6
   17bbe:	003b      	movs	r3, r7
   17bc0:	2000      	movs	r0, #0
   17bc2:	49bc      	ldr	r1, [pc, #752]	; (17eb4 <_dtoa_r+0x6d0>)
   17bc4:	f007 fc38 	bl	1f438 <__aeabi_dsub>
   17bc8:	0022      	movs	r2, r4
   17bca:	002b      	movs	r3, r5
   17bcc:	f006 f8f8 	bl	1ddc0 <__aeabi_dcmplt>
   17bd0:	2800      	cmp	r0, #0
   17bd2:	d001      	beq.n	17bd8 <_dtoa_r+0x3f4>
   17bd4:	f000 fd6c 	bl	186b0 <_dtoa_r+0xecc>
   17bd8:	45ca      	cmp	sl, r9
   17bda:	d101      	bne.n	17be0 <_dtoa_r+0x3fc>
   17bdc:	f000 fc3c 	bl	18458 <_dtoa_r+0xc74>
   17be0:	2200      	movs	r2, #0
   17be2:	4bb5      	ldr	r3, [pc, #724]	; (17eb8 <_dtoa_r+0x6d4>)
   17be4:	0020      	movs	r0, r4
   17be6:	0029      	movs	r1, r5
   17be8:	f007 f9ac 	bl	1ef44 <__aeabi_dmul>
   17bec:	2200      	movs	r2, #0
   17bee:	4bb2      	ldr	r3, [pc, #712]	; (17eb8 <_dtoa_r+0x6d4>)
   17bf0:	0004      	movs	r4, r0
   17bf2:	000d      	movs	r5, r1
   17bf4:	0030      	movs	r0, r6
   17bf6:	0039      	movs	r1, r7
   17bf8:	f007 f9a4 	bl	1ef44 <__aeabi_dmul>
   17bfc:	000f      	movs	r7, r1
   17bfe:	0006      	movs	r6, r0
   17c00:	f007 ff8e 	bl	1fb20 <__aeabi_d2iz>
   17c04:	4680      	mov	r8, r0
   17c06:	f007 ffc1 	bl	1fb8c <__aeabi_i2d>
   17c0a:	0002      	movs	r2, r0
   17c0c:	000b      	movs	r3, r1
   17c0e:	0030      	movs	r0, r6
   17c10:	0039      	movs	r1, r7
   17c12:	f007 fc11 	bl	1f438 <__aeabi_dsub>
   17c16:	2301      	movs	r3, #1
   17c18:	469c      	mov	ip, r3
   17c1a:	4643      	mov	r3, r8
   17c1c:	3330      	adds	r3, #48	; 0x30
   17c1e:	b2db      	uxtb	r3, r3
   17c20:	4698      	mov	r8, r3
   17c22:	2301      	movs	r3, #1
   17c24:	4642      	mov	r2, r8
   17c26:	44e2      	add	sl, ip
   17c28:	425b      	negs	r3, r3
   17c2a:	4453      	add	r3, sl
   17c2c:	701a      	strb	r2, [r3, #0]
   17c2e:	469b      	mov	fp, r3
   17c30:	0022      	movs	r2, r4
   17c32:	002b      	movs	r3, r5
   17c34:	0006      	movs	r6, r0
   17c36:	000f      	movs	r7, r1
   17c38:	f006 f8c2 	bl	1ddc0 <__aeabi_dcmplt>
   17c3c:	2800      	cmp	r0, #0
   17c3e:	d0bd      	beq.n	17bbc <_dtoa_r+0x3d8>
   17c40:	9b02      	ldr	r3, [sp, #8]
   17c42:	4654      	mov	r4, sl
   17c44:	469b      	mov	fp, r3
   17c46:	9b14      	ldr	r3, [sp, #80]	; 0x50
   17c48:	9305      	str	r3, [sp, #20]
   17c4a:	990a      	ldr	r1, [sp, #40]	; 0x28
   17c4c:	4658      	mov	r0, fp
   17c4e:	f001 fbb3 	bl	193b8 <_Bfree>
   17c52:	2300      	movs	r3, #0
   17c54:	7023      	strb	r3, [r4, #0]
   17c56:	9b05      	ldr	r3, [sp, #20]
   17c58:	9a24      	ldr	r2, [sp, #144]	; 0x90
   17c5a:	3301      	adds	r3, #1
   17c5c:	6013      	str	r3, [r2, #0]
   17c5e:	9b26      	ldr	r3, [sp, #152]	; 0x98
   17c60:	2b00      	cmp	r3, #0
   17c62:	d100      	bne.n	17c66 <_dtoa_r+0x482>
   17c64:	e3aa      	b.n	183bc <_dtoa_r+0xbd8>
   17c66:	601c      	str	r4, [r3, #0]
   17c68:	9809      	ldr	r0, [sp, #36]	; 0x24
   17c6a:	e5f3      	b.n	17854 <_dtoa_r+0x70>
   17c6c:	0338      	lsls	r0, r7, #12
   17c6e:	d000      	beq.n	17c72 <_dtoa_r+0x48e>
   17c70:	e5fe      	b.n	17870 <_dtoa_r+0x8c>
   17c72:	4892      	ldr	r0, [pc, #584]	; (17ebc <_dtoa_r+0x6d8>)
   17c74:	e5fd      	b.n	17872 <_dtoa_r+0x8e>
   17c76:	9b16      	ldr	r3, [sp, #88]	; 0x58
   17c78:	4698      	mov	r8, r3
   17c7a:	9b17      	ldr	r3, [sp, #92]	; 0x5c
   17c7c:	4443      	add	r3, r8
   17c7e:	001e      	movs	r6, r3
   17c80:	4b8f      	ldr	r3, [pc, #572]	; (17ec0 <_dtoa_r+0x6dc>)
   17c82:	18f3      	adds	r3, r6, r3
   17c84:	2b20      	cmp	r3, #32
   17c86:	dc00      	bgt.n	17c8a <_dtoa_r+0x4a6>
   17c88:	e1fe      	b.n	18088 <_dtoa_r+0x8a4>
   17c8a:	4a8e      	ldr	r2, [pc, #568]	; (17ec4 <_dtoa_r+0x6e0>)
   17c8c:	9902      	ldr	r1, [sp, #8]
   17c8e:	18b2      	adds	r2, r6, r2
   17c90:	40d1      	lsrs	r1, r2
   17c92:	2240      	movs	r2, #64	; 0x40
   17c94:	0038      	movs	r0, r7
   17c96:	1ad3      	subs	r3, r2, r3
   17c98:	4098      	lsls	r0, r3
   17c9a:	4308      	orrs	r0, r1
   17c9c:	f007 ffb8 	bl	1fc10 <__aeabi_ui2d>
   17ca0:	2301      	movs	r3, #1
   17ca2:	4c89      	ldr	r4, [pc, #548]	; (17ec8 <_dtoa_r+0x6e4>)
   17ca4:	3e01      	subs	r6, #1
   17ca6:	1909      	adds	r1, r1, r4
   17ca8:	9312      	str	r3, [sp, #72]	; 0x48
   17caa:	e60d      	b.n	178c8 <_dtoa_r+0xe4>
   17cac:	4887      	ldr	r0, [pc, #540]	; (17ecc <_dtoa_r+0x6e8>)
   17cae:	e5d1      	b.n	17854 <_dtoa_r+0x70>
   17cb0:	2300      	movs	r3, #0
   17cb2:	465a      	mov	r2, fp
   17cb4:	2100      	movs	r1, #0
   17cb6:	6453      	str	r3, [r2, #68]	; 0x44
   17cb8:	4658      	mov	r0, fp
   17cba:	f001 fb55 	bl	19368 <_Balloc>
   17cbe:	465b      	mov	r3, fp
   17cc0:	6418      	str	r0, [r3, #64]	; 0x40
   17cc2:	2301      	movs	r3, #1
   17cc4:	425b      	negs	r3, r3
   17cc6:	9308      	str	r3, [sp, #32]
   17cc8:	930f      	str	r3, [sp, #60]	; 0x3c
   17cca:	2300      	movs	r3, #0
   17ccc:	9323      	str	r3, [sp, #140]	; 0x8c
   17cce:	9322      	str	r3, [sp, #136]	; 0x88
   17cd0:	3301      	adds	r3, #1
   17cd2:	9009      	str	r0, [sp, #36]	; 0x24
   17cd4:	930c      	str	r3, [sp, #48]	; 0x30
   17cd6:	9b17      	ldr	r3, [sp, #92]	; 0x5c
   17cd8:	2b00      	cmp	r3, #0
   17cda:	da00      	bge.n	17cde <_dtoa_r+0x4fa>
   17cdc:	e0ab      	b.n	17e36 <_dtoa_r+0x652>
   17cde:	9a05      	ldr	r2, [sp, #20]
   17ce0:	2a0e      	cmp	r2, #14
   17ce2:	dd00      	ble.n	17ce6 <_dtoa_r+0x502>
   17ce4:	e0a7      	b.n	17e36 <_dtoa_r+0x652>
   17ce6:	00d3      	lsls	r3, r2, #3
   17ce8:	4a79      	ldr	r2, [pc, #484]	; (17ed0 <_dtoa_r+0x6ec>)
   17cea:	18d3      	adds	r3, r2, r3
   17cec:	685c      	ldr	r4, [r3, #4]
   17cee:	681b      	ldr	r3, [r3, #0]
   17cf0:	9306      	str	r3, [sp, #24]
   17cf2:	9407      	str	r4, [sp, #28]
   17cf4:	9b23      	ldr	r3, [sp, #140]	; 0x8c
   17cf6:	2b00      	cmp	r3, #0
   17cf8:	da00      	bge.n	17cfc <_dtoa_r+0x518>
   17cfa:	e1fb      	b.n	180f4 <_dtoa_r+0x910>
   17cfc:	9e06      	ldr	r6, [sp, #24]
   17cfe:	9f07      	ldr	r7, [sp, #28]
   17d00:	9c02      	ldr	r4, [sp, #8]
   17d02:	9d03      	ldr	r5, [sp, #12]
   17d04:	0032      	movs	r2, r6
   17d06:	003b      	movs	r3, r7
   17d08:	0020      	movs	r0, r4
   17d0a:	0029      	movs	r1, r5
   17d0c:	f006 fcf6 	bl	1e6fc <__aeabi_ddiv>
   17d10:	f007 ff06 	bl	1fb20 <__aeabi_d2iz>
   17d14:	4680      	mov	r8, r0
   17d16:	f007 ff39 	bl	1fb8c <__aeabi_i2d>
   17d1a:	0032      	movs	r2, r6
   17d1c:	003b      	movs	r3, r7
   17d1e:	f007 f911 	bl	1ef44 <__aeabi_dmul>
   17d22:	0002      	movs	r2, r0
   17d24:	000b      	movs	r3, r1
   17d26:	0020      	movs	r0, r4
   17d28:	0029      	movs	r1, r5
   17d2a:	f007 fb85 	bl	1f438 <__aeabi_dsub>
   17d2e:	4643      	mov	r3, r8
   17d30:	9a09      	ldr	r2, [sp, #36]	; 0x24
   17d32:	3330      	adds	r3, #48	; 0x30
   17d34:	7013      	strb	r3, [r2, #0]
   17d36:	9b08      	ldr	r3, [sp, #32]
   17d38:	0006      	movs	r6, r0
   17d3a:	000f      	movs	r7, r1
   17d3c:	1c54      	adds	r4, r2, #1
   17d3e:	2b01      	cmp	r3, #1
   17d40:	d04a      	beq.n	17dd8 <_dtoa_r+0x5f4>
   17d42:	2200      	movs	r2, #0
   17d44:	4b5c      	ldr	r3, [pc, #368]	; (17eb8 <_dtoa_r+0x6d4>)
   17d46:	f007 f8fd 	bl	1ef44 <__aeabi_dmul>
   17d4a:	2200      	movs	r2, #0
   17d4c:	2300      	movs	r3, #0
   17d4e:	0006      	movs	r6, r0
   17d50:	000f      	movs	r7, r1
   17d52:	f006 f82f 	bl	1ddb4 <__aeabi_dcmpeq>
   17d56:	2800      	cmp	r0, #0
   17d58:	d000      	beq.n	17d5c <_dtoa_r+0x578>
   17d5a:	e776      	b.n	17c4a <_dtoa_r+0x466>
   17d5c:	9b09      	ldr	r3, [sp, #36]	; 0x24
   17d5e:	9a08      	ldr	r2, [sp, #32]
   17d60:	469c      	mov	ip, r3
   17d62:	1c9d      	adds	r5, r3, #2
   17d64:	465b      	mov	r3, fp
   17d66:	4462      	add	r2, ip
   17d68:	46aa      	mov	sl, r5
   17d6a:	9c06      	ldr	r4, [sp, #24]
   17d6c:	9d07      	ldr	r5, [sp, #28]
   17d6e:	4691      	mov	r9, r2
   17d70:	9302      	str	r3, [sp, #8]
   17d72:	e00f      	b.n	17d94 <_dtoa_r+0x5b0>
   17d74:	2200      	movs	r2, #0
   17d76:	4b50      	ldr	r3, [pc, #320]	; (17eb8 <_dtoa_r+0x6d4>)
   17d78:	f007 f8e4 	bl	1ef44 <__aeabi_dmul>
   17d7c:	2301      	movs	r3, #1
   17d7e:	469c      	mov	ip, r3
   17d80:	2200      	movs	r2, #0
   17d82:	2300      	movs	r3, #0
   17d84:	0006      	movs	r6, r0
   17d86:	000f      	movs	r7, r1
   17d88:	44e2      	add	sl, ip
   17d8a:	f006 f813 	bl	1ddb4 <__aeabi_dcmpeq>
   17d8e:	2800      	cmp	r0, #0
   17d90:	d000      	beq.n	17d94 <_dtoa_r+0x5b0>
   17d92:	e2db      	b.n	1834c <_dtoa_r+0xb68>
   17d94:	0022      	movs	r2, r4
   17d96:	002b      	movs	r3, r5
   17d98:	0030      	movs	r0, r6
   17d9a:	0039      	movs	r1, r7
   17d9c:	f006 fcae 	bl	1e6fc <__aeabi_ddiv>
   17da0:	f007 febe 	bl	1fb20 <__aeabi_d2iz>
   17da4:	4680      	mov	r8, r0
   17da6:	f007 fef1 	bl	1fb8c <__aeabi_i2d>
   17daa:	0022      	movs	r2, r4
   17dac:	002b      	movs	r3, r5
   17dae:	f007 f8c9 	bl	1ef44 <__aeabi_dmul>
   17db2:	0002      	movs	r2, r0
   17db4:	000b      	movs	r3, r1
   17db6:	0030      	movs	r0, r6
   17db8:	0039      	movs	r1, r7
   17dba:	f007 fb3d 	bl	1f438 <__aeabi_dsub>
   17dbe:	4653      	mov	r3, sl
   17dc0:	4642      	mov	r2, r8
   17dc2:	3b01      	subs	r3, #1
   17dc4:	3230      	adds	r2, #48	; 0x30
   17dc6:	0006      	movs	r6, r0
   17dc8:	000f      	movs	r7, r1
   17dca:	46d3      	mov	fp, sl
   17dcc:	701a      	strb	r2, [r3, #0]
   17dce:	45d1      	cmp	r9, sl
   17dd0:	d1d0      	bne.n	17d74 <_dtoa_r+0x590>
   17dd2:	9b02      	ldr	r3, [sp, #8]
   17dd4:	4654      	mov	r4, sl
   17dd6:	469b      	mov	fp, r3
   17dd8:	0032      	movs	r2, r6
   17dda:	003b      	movs	r3, r7
   17ddc:	0030      	movs	r0, r6
   17dde:	0039      	movs	r1, r7
   17de0:	f006 f960 	bl	1e0a4 <__aeabi_dadd>
   17de4:	0006      	movs	r6, r0
   17de6:	000f      	movs	r7, r1
   17de8:	0002      	movs	r2, r0
   17dea:	000b      	movs	r3, r1
   17dec:	9806      	ldr	r0, [sp, #24]
   17dee:	9907      	ldr	r1, [sp, #28]
   17df0:	f005 ffe6 	bl	1ddc0 <__aeabi_dcmplt>
   17df4:	2800      	cmp	r0, #0
   17df6:	d10c      	bne.n	17e12 <_dtoa_r+0x62e>
   17df8:	9806      	ldr	r0, [sp, #24]
   17dfa:	9907      	ldr	r1, [sp, #28]
   17dfc:	0032      	movs	r2, r6
   17dfe:	003b      	movs	r3, r7
   17e00:	f005 ffd8 	bl	1ddb4 <__aeabi_dcmpeq>
   17e04:	2800      	cmp	r0, #0
   17e06:	d100      	bne.n	17e0a <_dtoa_r+0x626>
   17e08:	e71f      	b.n	17c4a <_dtoa_r+0x466>
   17e0a:	4643      	mov	r3, r8
   17e0c:	07db      	lsls	r3, r3, #31
   17e0e:	d400      	bmi.n	17e12 <_dtoa_r+0x62e>
   17e10:	e71b      	b.n	17c4a <_dtoa_r+0x466>
   17e12:	1e65      	subs	r5, r4, #1
   17e14:	782b      	ldrb	r3, [r5, #0]
   17e16:	9a09      	ldr	r2, [sp, #36]	; 0x24
   17e18:	e006      	b.n	17e28 <_dtoa_r+0x644>
   17e1a:	4295      	cmp	r5, r2
   17e1c:	d100      	bne.n	17e20 <_dtoa_r+0x63c>
   17e1e:	e353      	b.n	184c8 <_dtoa_r+0xce4>
   17e20:	3c02      	subs	r4, #2
   17e22:	7823      	ldrb	r3, [r4, #0]
   17e24:	002c      	movs	r4, r5
   17e26:	3d01      	subs	r5, #1
   17e28:	2b39      	cmp	r3, #57	; 0x39
   17e2a:	d0f6      	beq.n	17e1a <_dtoa_r+0x636>
   17e2c:	4698      	mov	r8, r3
   17e2e:	4643      	mov	r3, r8
   17e30:	3301      	adds	r3, #1
   17e32:	702b      	strb	r3, [r5, #0]
   17e34:	e709      	b.n	17c4a <_dtoa_r+0x466>
   17e36:	9a0c      	ldr	r2, [sp, #48]	; 0x30
   17e38:	2a00      	cmp	r2, #0
   17e3a:	d04b      	beq.n	17ed4 <_dtoa_r+0x6f0>
   17e3c:	9a22      	ldr	r2, [sp, #136]	; 0x88
   17e3e:	2a01      	cmp	r2, #1
   17e40:	dc00      	bgt.n	17e44 <_dtoa_r+0x660>
   17e42:	e179      	b.n	18138 <_dtoa_r+0x954>
   17e44:	9b08      	ldr	r3, [sp, #32]
   17e46:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
   17e48:	1e5d      	subs	r5, r3, #1
   17e4a:	42aa      	cmp	r2, r5
   17e4c:	da00      	bge.n	17e50 <_dtoa_r+0x66c>
   17e4e:	e2b8      	b.n	183c2 <_dtoa_r+0xbde>
   17e50:	1b55      	subs	r5, r2, r5
   17e52:	9b08      	ldr	r3, [sp, #32]
   17e54:	2b00      	cmp	r3, #0
   17e56:	da00      	bge.n	17e5a <_dtoa_r+0x676>
   17e58:	e3c5      	b.n	185e6 <_dtoa_r+0xe02>
   17e5a:	9c06      	ldr	r4, [sp, #24]
   17e5c:	9b08      	ldr	r3, [sp, #32]
   17e5e:	9a06      	ldr	r2, [sp, #24]
   17e60:	2101      	movs	r1, #1
   17e62:	4694      	mov	ip, r2
   17e64:	449c      	add	ip, r3
   17e66:	4662      	mov	r2, ip
   17e68:	4658      	mov	r0, fp
   17e6a:	9206      	str	r2, [sp, #24]
   17e6c:	449a      	add	sl, r3
   17e6e:	f001 fb87 	bl	19580 <__i2b>
   17e72:	0007      	movs	r7, r0
   17e74:	e031      	b.n	17eda <_dtoa_r+0x6f6>
   17e76:	9a06      	ldr	r2, [sp, #24]
   17e78:	9b05      	ldr	r3, [sp, #20]
   17e7a:	1ad2      	subs	r2, r2, r3
   17e7c:	425b      	negs	r3, r3
   17e7e:	930b      	str	r3, [sp, #44]	; 0x2c
   17e80:	2300      	movs	r3, #0
   17e82:	9206      	str	r2, [sp, #24]
   17e84:	930e      	str	r3, [sp, #56]	; 0x38
   17e86:	e56f      	b.n	17968 <_dtoa_r+0x184>
   17e88:	9f05      	ldr	r7, [sp, #20]
   17e8a:	0038      	movs	r0, r7
   17e8c:	f007 fe7e 	bl	1fb8c <__aeabi_i2d>
   17e90:	000b      	movs	r3, r1
   17e92:	0002      	movs	r2, r0
   17e94:	0029      	movs	r1, r5
   17e96:	0020      	movs	r0, r4
   17e98:	f005 ff8c 	bl	1ddb4 <__aeabi_dcmpeq>
   17e9c:	4243      	negs	r3, r0
   17e9e:	4143      	adcs	r3, r0
   17ea0:	1afb      	subs	r3, r7, r3
   17ea2:	9305      	str	r3, [sp, #20]
   17ea4:	e539      	b.n	1791a <_dtoa_r+0x136>
   17ea6:	4653      	mov	r3, sl
   17ea8:	425b      	negs	r3, r3
   17eaa:	9306      	str	r3, [sp, #24]
   17eac:	2300      	movs	r3, #0
   17eae:	469a      	mov	sl, r3
   17eb0:	e551      	b.n	17956 <_dtoa_r+0x172>
   17eb2:	46c0      	nop			; (mov r8, r8)
   17eb4:	3ff00000 	.word	0x3ff00000
   17eb8:	40240000 	.word	0x40240000
   17ebc:	00022d8c 	.word	0x00022d8c
   17ec0:	00000432 	.word	0x00000432
   17ec4:	00000412 	.word	0x00000412
   17ec8:	fe100000 	.word	0xfe100000
   17ecc:	00022d78 	.word	0x00022d78
   17ed0:	00022da0 	.word	0x00022da0
   17ed4:	2700      	movs	r7, #0
   17ed6:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
   17ed8:	9c06      	ldr	r4, [sp, #24]
   17eda:	2c00      	cmp	r4, #0
   17edc:	d00d      	beq.n	17efa <_dtoa_r+0x716>
   17ede:	4653      	mov	r3, sl
   17ee0:	2b00      	cmp	r3, #0
   17ee2:	dd0a      	ble.n	17efa <_dtoa_r+0x716>
   17ee4:	0023      	movs	r3, r4
   17ee6:	4554      	cmp	r4, sl
   17ee8:	dd00      	ble.n	17eec <_dtoa_r+0x708>
   17eea:	e0d5      	b.n	18098 <_dtoa_r+0x8b4>
   17eec:	9a06      	ldr	r2, [sp, #24]
   17eee:	1ae4      	subs	r4, r4, r3
   17ef0:	1ad2      	subs	r2, r2, r3
   17ef2:	9206      	str	r2, [sp, #24]
   17ef4:	4652      	mov	r2, sl
   17ef6:	1ad3      	subs	r3, r2, r3
   17ef8:	469a      	mov	sl, r3
   17efa:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   17efc:	2b00      	cmp	r3, #0
   17efe:	dc00      	bgt.n	17f02 <_dtoa_r+0x71e>
   17f00:	e1f9      	b.n	182f6 <_dtoa_r+0xb12>
   17f02:	9a0c      	ldr	r2, [sp, #48]	; 0x30
   17f04:	2a00      	cmp	r2, #0
   17f06:	d100      	bne.n	17f0a <_dtoa_r+0x726>
   17f08:	e0c9      	b.n	1809e <_dtoa_r+0x8ba>
   17f0a:	2d00      	cmp	r5, #0
   17f0c:	d100      	bne.n	17f10 <_dtoa_r+0x72c>
   17f0e:	e0c6      	b.n	1809e <_dtoa_r+0x8ba>
   17f10:	0039      	movs	r1, r7
   17f12:	002a      	movs	r2, r5
   17f14:	4658      	mov	r0, fp
   17f16:	f001 fbeb 	bl	196f0 <__pow5mult>
   17f1a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   17f1c:	0001      	movs	r1, r0
   17f1e:	001a      	movs	r2, r3
   17f20:	0007      	movs	r7, r0
   17f22:	4658      	mov	r0, fp
   17f24:	4698      	mov	r8, r3
   17f26:	f001 fb35 	bl	19594 <__multiply>
   17f2a:	4641      	mov	r1, r8
   17f2c:	0006      	movs	r6, r0
   17f2e:	4658      	mov	r0, fp
   17f30:	f001 fa42 	bl	193b8 <_Bfree>
   17f34:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   17f36:	1b5b      	subs	r3, r3, r5
   17f38:	930b      	str	r3, [sp, #44]	; 0x2c
   17f3a:	d000      	beq.n	17f3e <_dtoa_r+0x75a>
   17f3c:	e0ae      	b.n	1809c <_dtoa_r+0x8b8>
   17f3e:	2101      	movs	r1, #1
   17f40:	4658      	mov	r0, fp
   17f42:	f001 fb1d 	bl	19580 <__i2b>
   17f46:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   17f48:	4681      	mov	r9, r0
   17f4a:	2b00      	cmp	r3, #0
   17f4c:	d100      	bne.n	17f50 <_dtoa_r+0x76c>
   17f4e:	e0ff      	b.n	18150 <_dtoa_r+0x96c>
   17f50:	001a      	movs	r2, r3
   17f52:	0001      	movs	r1, r0
   17f54:	4658      	mov	r0, fp
   17f56:	f001 fbcb 	bl	196f0 <__pow5mult>
   17f5a:	9b22      	ldr	r3, [sp, #136]	; 0x88
   17f5c:	4681      	mov	r9, r0
   17f5e:	2b01      	cmp	r3, #1
   17f60:	dc00      	bgt.n	17f64 <_dtoa_r+0x780>
   17f62:	e0a3      	b.n	180ac <_dtoa_r+0x8c8>
   17f64:	2500      	movs	r5, #0
   17f66:	464b      	mov	r3, r9
   17f68:	691b      	ldr	r3, [r3, #16]
   17f6a:	3303      	adds	r3, #3
   17f6c:	009b      	lsls	r3, r3, #2
   17f6e:	444b      	add	r3, r9
   17f70:	6858      	ldr	r0, [r3, #4]
   17f72:	f001 fab9 	bl	194e8 <__hi0bits>
   17f76:	2320      	movs	r3, #32
   17f78:	1a18      	subs	r0, r3, r0
   17f7a:	231f      	movs	r3, #31
   17f7c:	4450      	add	r0, sl
   17f7e:	4018      	ands	r0, r3
   17f80:	d100      	bne.n	17f84 <_dtoa_r+0x7a0>
   17f82:	e0e3      	b.n	1814c <_dtoa_r+0x968>
   17f84:	3301      	adds	r3, #1
   17f86:	1a1b      	subs	r3, r3, r0
   17f88:	2b04      	cmp	r3, #4
   17f8a:	dc00      	bgt.n	17f8e <_dtoa_r+0x7aa>
   17f8c:	e3bf      	b.n	1870e <_dtoa_r+0xf2a>
   17f8e:	231c      	movs	r3, #28
   17f90:	1a18      	subs	r0, r3, r0
   17f92:	9b06      	ldr	r3, [sp, #24]
   17f94:	1824      	adds	r4, r4, r0
   17f96:	469c      	mov	ip, r3
   17f98:	4484      	add	ip, r0
   17f9a:	4663      	mov	r3, ip
   17f9c:	4482      	add	sl, r0
   17f9e:	9306      	str	r3, [sp, #24]
   17fa0:	9b06      	ldr	r3, [sp, #24]
   17fa2:	2b00      	cmp	r3, #0
   17fa4:	dd05      	ble.n	17fb2 <_dtoa_r+0x7ce>
   17fa6:	0031      	movs	r1, r6
   17fa8:	001a      	movs	r2, r3
   17faa:	4658      	mov	r0, fp
   17fac:	f001 fbfe 	bl	197ac <__lshift>
   17fb0:	0006      	movs	r6, r0
   17fb2:	4653      	mov	r3, sl
   17fb4:	2b00      	cmp	r3, #0
   17fb6:	dd05      	ble.n	17fc4 <_dtoa_r+0x7e0>
   17fb8:	4649      	mov	r1, r9
   17fba:	4652      	mov	r2, sl
   17fbc:	4658      	mov	r0, fp
   17fbe:	f001 fbf5 	bl	197ac <__lshift>
   17fc2:	4681      	mov	r9, r0
   17fc4:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   17fc6:	2b00      	cmp	r3, #0
   17fc8:	d000      	beq.n	17fcc <_dtoa_r+0x7e8>
   17fca:	e161      	b.n	18290 <_dtoa_r+0xaac>
   17fcc:	9b08      	ldr	r3, [sp, #32]
   17fce:	2b00      	cmp	r3, #0
   17fd0:	dc00      	bgt.n	17fd4 <_dtoa_r+0x7f0>
   17fd2:	e192      	b.n	182fa <_dtoa_r+0xb16>
   17fd4:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   17fd6:	2b00      	cmp	r3, #0
   17fd8:	d000      	beq.n	17fdc <_dtoa_r+0x7f8>
   17fda:	e0d0      	b.n	1817e <_dtoa_r+0x99a>
   17fdc:	464b      	mov	r3, r9
   17fde:	9a09      	ldr	r2, [sp, #36]	; 0x24
   17fe0:	46b9      	mov	r9, r7
   17fe2:	2400      	movs	r4, #0
   17fe4:	9d08      	ldr	r5, [sp, #32]
   17fe6:	4690      	mov	r8, r2
   17fe8:	001f      	movs	r7, r3
   17fea:	e006      	b.n	17ffa <_dtoa_r+0x816>
   17fec:	0031      	movs	r1, r6
   17fee:	2300      	movs	r3, #0
   17ff0:	220a      	movs	r2, #10
   17ff2:	4658      	mov	r0, fp
   17ff4:	f001 f9ea 	bl	193cc <__multadd>
   17ff8:	0006      	movs	r6, r0
   17ffa:	0039      	movs	r1, r7
   17ffc:	0030      	movs	r0, r6
   17ffe:	f7ff fb49 	bl	17694 <quorem>
   18002:	4643      	mov	r3, r8
   18004:	3030      	adds	r0, #48	; 0x30
   18006:	5518      	strb	r0, [r3, r4]
   18008:	3401      	adds	r4, #1
   1800a:	42ac      	cmp	r4, r5
   1800c:	dbee      	blt.n	17fec <_dtoa_r+0x808>
   1800e:	003b      	movs	r3, r7
   18010:	464f      	mov	r7, r9
   18012:	4699      	mov	r9, r3
   18014:	9002      	str	r0, [sp, #8]
   18016:	9c08      	ldr	r4, [sp, #32]
   18018:	2c00      	cmp	r4, #0
   1801a:	dc00      	bgt.n	1801e <_dtoa_r+0x83a>
   1801c:	e2e8      	b.n	185f0 <_dtoa_r+0xe0c>
   1801e:	9b09      	ldr	r3, [sp, #36]	; 0x24
   18020:	469c      	mov	ip, r3
   18022:	2300      	movs	r3, #0
   18024:	4698      	mov	r8, r3
   18026:	4464      	add	r4, ip
   18028:	0031      	movs	r1, r6
   1802a:	2201      	movs	r2, #1
   1802c:	4658      	mov	r0, fp
   1802e:	f001 fbbd 	bl	197ac <__lshift>
   18032:	4649      	mov	r1, r9
   18034:	900a      	str	r0, [sp, #40]	; 0x28
   18036:	f001 fc19 	bl	1986c <__mcmp>
   1803a:	2800      	cmp	r0, #0
   1803c:	dc00      	bgt.n	18040 <_dtoa_r+0x85c>
   1803e:	e1ff      	b.n	18440 <_dtoa_r+0xc5c>
   18040:	1e65      	subs	r5, r4, #1
   18042:	782b      	ldrb	r3, [r5, #0]
   18044:	9a09      	ldr	r2, [sp, #36]	; 0x24
   18046:	e006      	b.n	18056 <_dtoa_r+0x872>
   18048:	4295      	cmp	r5, r2
   1804a:	d100      	bne.n	1804e <_dtoa_r+0x86a>
   1804c:	e177      	b.n	1833e <_dtoa_r+0xb5a>
   1804e:	3c02      	subs	r4, #2
   18050:	7823      	ldrb	r3, [r4, #0]
   18052:	002c      	movs	r4, r5
   18054:	3d01      	subs	r5, #1
   18056:	2b39      	cmp	r3, #57	; 0x39
   18058:	d0f6      	beq.n	18048 <_dtoa_r+0x864>
   1805a:	3301      	adds	r3, #1
   1805c:	702b      	strb	r3, [r5, #0]
   1805e:	4649      	mov	r1, r9
   18060:	4658      	mov	r0, fp
   18062:	f001 f9a9 	bl	193b8 <_Bfree>
   18066:	2f00      	cmp	r7, #0
   18068:	d100      	bne.n	1806c <_dtoa_r+0x888>
   1806a:	e5ee      	b.n	17c4a <_dtoa_r+0x466>
   1806c:	4643      	mov	r3, r8
   1806e:	2b00      	cmp	r3, #0
   18070:	d005      	beq.n	1807e <_dtoa_r+0x89a>
   18072:	45b8      	cmp	r8, r7
   18074:	d003      	beq.n	1807e <_dtoa_r+0x89a>
   18076:	4641      	mov	r1, r8
   18078:	4658      	mov	r0, fp
   1807a:	f001 f99d 	bl	193b8 <_Bfree>
   1807e:	0039      	movs	r1, r7
   18080:	4658      	mov	r0, fp
   18082:	f001 f999 	bl	193b8 <_Bfree>
   18086:	e5e0      	b.n	17c4a <_dtoa_r+0x466>
   18088:	2220      	movs	r2, #32
   1808a:	9802      	ldr	r0, [sp, #8]
   1808c:	1ad3      	subs	r3, r2, r3
   1808e:	4098      	lsls	r0, r3
   18090:	e604      	b.n	17c9c <_dtoa_r+0x4b8>
   18092:	2300      	movs	r3, #0
   18094:	930d      	str	r3, [sp, #52]	; 0x34
   18096:	e456      	b.n	17946 <_dtoa_r+0x162>
   18098:	4653      	mov	r3, sl
   1809a:	e727      	b.n	17eec <_dtoa_r+0x708>
   1809c:	960a      	str	r6, [sp, #40]	; 0x28
   1809e:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
   180a0:	990a      	ldr	r1, [sp, #40]	; 0x28
   180a2:	4658      	mov	r0, fp
   180a4:	f001 fb24 	bl	196f0 <__pow5mult>
   180a8:	0006      	movs	r6, r0
   180aa:	e748      	b.n	17f3e <_dtoa_r+0x75a>
   180ac:	9b02      	ldr	r3, [sp, #8]
   180ae:	2b00      	cmp	r3, #0
   180b0:	d000      	beq.n	180b4 <_dtoa_r+0x8d0>
   180b2:	e757      	b.n	17f64 <_dtoa_r+0x780>
   180b4:	9902      	ldr	r1, [sp, #8]
   180b6:	9a03      	ldr	r2, [sp, #12]
   180b8:	2500      	movs	r5, #0
   180ba:	0313      	lsls	r3, r2, #12
   180bc:	d109      	bne.n	180d2 <_dtoa_r+0x8ee>
   180be:	4bdb      	ldr	r3, [pc, #876]	; (1842c <_dtoa_r+0xc48>)
   180c0:	4213      	tst	r3, r2
   180c2:	d006      	beq.n	180d2 <_dtoa_r+0x8ee>
   180c4:	9b06      	ldr	r3, [sp, #24]
   180c6:	3501      	adds	r5, #1
   180c8:	3301      	adds	r3, #1
   180ca:	9306      	str	r3, [sp, #24]
   180cc:	2301      	movs	r3, #1
   180ce:	469c      	mov	ip, r3
   180d0:	44e2      	add	sl, ip
   180d2:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   180d4:	2001      	movs	r0, #1
   180d6:	2b00      	cmp	r3, #0
   180d8:	d100      	bne.n	180dc <_dtoa_r+0x8f8>
   180da:	e74e      	b.n	17f7a <_dtoa_r+0x796>
   180dc:	e743      	b.n	17f66 <_dtoa_r+0x782>
   180de:	2301      	movs	r3, #1
   180e0:	930c      	str	r3, [sp, #48]	; 0x30
   180e2:	9b23      	ldr	r3, [sp, #140]	; 0x8c
   180e4:	2b00      	cmp	r3, #0
   180e6:	dc00      	bgt.n	180ea <_dtoa_r+0x906>
   180e8:	e0c7      	b.n	1827a <_dtoa_r+0xa96>
   180ea:	001e      	movs	r6, r3
   180ec:	001d      	movs	r5, r3
   180ee:	930f      	str	r3, [sp, #60]	; 0x3c
   180f0:	9308      	str	r3, [sp, #32]
   180f2:	e463      	b.n	179bc <_dtoa_r+0x1d8>
   180f4:	9b08      	ldr	r3, [sp, #32]
   180f6:	2b00      	cmp	r3, #0
   180f8:	dd00      	ble.n	180fc <_dtoa_r+0x918>
   180fa:	e5ff      	b.n	17cfc <_dtoa_r+0x518>
   180fc:	d000      	beq.n	18100 <_dtoa_r+0x91c>
   180fe:	e159      	b.n	183b4 <_dtoa_r+0xbd0>
   18100:	9806      	ldr	r0, [sp, #24]
   18102:	9907      	ldr	r1, [sp, #28]
   18104:	2200      	movs	r2, #0
   18106:	4bca      	ldr	r3, [pc, #808]	; (18430 <_dtoa_r+0xc4c>)
   18108:	f006 ff1c 	bl	1ef44 <__aeabi_dmul>
   1810c:	9a02      	ldr	r2, [sp, #8]
   1810e:	9b03      	ldr	r3, [sp, #12]
   18110:	f005 fe74 	bl	1ddfc <__aeabi_dcmpge>
   18114:	2300      	movs	r3, #0
   18116:	2700      	movs	r7, #0
   18118:	4699      	mov	r9, r3
   1811a:	2800      	cmp	r0, #0
   1811c:	d100      	bne.n	18120 <_dtoa_r+0x93c>
   1811e:	e102      	b.n	18326 <_dtoa_r+0xb42>
   18120:	9b23      	ldr	r3, [sp, #140]	; 0x8c
   18122:	9c09      	ldr	r4, [sp, #36]	; 0x24
   18124:	43db      	mvns	r3, r3
   18126:	9305      	str	r3, [sp, #20]
   18128:	4649      	mov	r1, r9
   1812a:	4658      	mov	r0, fp
   1812c:	f001 f944 	bl	193b8 <_Bfree>
   18130:	2f00      	cmp	r7, #0
   18132:	d100      	bne.n	18136 <_dtoa_r+0x952>
   18134:	e589      	b.n	17c4a <_dtoa_r+0x466>
   18136:	e7a2      	b.n	1807e <_dtoa_r+0x89a>
   18138:	9a12      	ldr	r2, [sp, #72]	; 0x48
   1813a:	2a00      	cmp	r2, #0
   1813c:	d100      	bne.n	18140 <_dtoa_r+0x95c>
   1813e:	e259      	b.n	185f4 <_dtoa_r+0xe10>
   18140:	4abc      	ldr	r2, [pc, #752]	; (18434 <_dtoa_r+0xc50>)
   18142:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
   18144:	4694      	mov	ip, r2
   18146:	9c06      	ldr	r4, [sp, #24]
   18148:	4463      	add	r3, ip
   1814a:	e688      	b.n	17e5e <_dtoa_r+0x67a>
   1814c:	201c      	movs	r0, #28
   1814e:	e720      	b.n	17f92 <_dtoa_r+0x7ae>
   18150:	9b22      	ldr	r3, [sp, #136]	; 0x88
   18152:	2b01      	cmp	r3, #1
   18154:	dc00      	bgt.n	18158 <_dtoa_r+0x974>
   18156:	e2b5      	b.n	186c4 <_dtoa_r+0xee0>
   18158:	2500      	movs	r5, #0
   1815a:	2001      	movs	r0, #1
   1815c:	e70d      	b.n	17f7a <_dtoa_r+0x796>
   1815e:	2300      	movs	r3, #0
   18160:	0039      	movs	r1, r7
   18162:	220a      	movs	r2, #10
   18164:	4658      	mov	r0, fp
   18166:	f001 f931 	bl	193cc <__multadd>
   1816a:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   1816c:	0007      	movs	r7, r0
   1816e:	2b00      	cmp	r3, #0
   18170:	dc04      	bgt.n	1817c <_dtoa_r+0x998>
   18172:	9b22      	ldr	r3, [sp, #136]	; 0x88
   18174:	2b02      	cmp	r3, #2
   18176:	dd00      	ble.n	1817a <_dtoa_r+0x996>
   18178:	e2cf      	b.n	1871a <_dtoa_r+0xf36>
   1817a:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   1817c:	9308      	str	r3, [sp, #32]
   1817e:	2c00      	cmp	r4, #0
   18180:	dd05      	ble.n	1818e <_dtoa_r+0x9aa>
   18182:	0039      	movs	r1, r7
   18184:	0022      	movs	r2, r4
   18186:	4658      	mov	r0, fp
   18188:	f001 fb10 	bl	197ac <__lshift>
   1818c:	0007      	movs	r7, r0
   1818e:	46ba      	mov	sl, r7
   18190:	2d00      	cmp	r5, #0
   18192:	d000      	beq.n	18196 <_dtoa_r+0x9b2>
   18194:	e19f      	b.n	184d6 <_dtoa_r+0xcf2>
   18196:	9c08      	ldr	r4, [sp, #32]
   18198:	9a09      	ldr	r2, [sp, #36]	; 0x24
   1819a:	3c01      	subs	r4, #1
   1819c:	4694      	mov	ip, r2
   1819e:	0023      	movs	r3, r4
   181a0:	4463      	add	r3, ip
   181a2:	930a      	str	r3, [sp, #40]	; 0x28
   181a4:	2301      	movs	r3, #1
   181a6:	0015      	movs	r5, r2
   181a8:	9a02      	ldr	r2, [sp, #8]
   181aa:	46d8      	mov	r8, fp
   181ac:	401a      	ands	r2, r3
   181ae:	464b      	mov	r3, r9
   181b0:	46a9      	mov	r9, r5
   181b2:	9208      	str	r2, [sp, #32]
   181b4:	9306      	str	r3, [sp, #24]
   181b6:	9d06      	ldr	r5, [sp, #24]
   181b8:	0030      	movs	r0, r6
   181ba:	0029      	movs	r1, r5
   181bc:	f7ff fa6a 	bl	17694 <quorem>
   181c0:	0003      	movs	r3, r0
   181c2:	900b      	str	r0, [sp, #44]	; 0x2c
   181c4:	3330      	adds	r3, #48	; 0x30
   181c6:	0039      	movs	r1, r7
   181c8:	0030      	movs	r0, r6
   181ca:	9302      	str	r3, [sp, #8]
   181cc:	f001 fb4e 	bl	1986c <__mcmp>
   181d0:	0029      	movs	r1, r5
   181d2:	0004      	movs	r4, r0
   181d4:	4652      	mov	r2, sl
   181d6:	4640      	mov	r0, r8
   181d8:	f001 fb66 	bl	198a8 <__mdiff>
   181dc:	68c3      	ldr	r3, [r0, #12]
   181de:	0005      	movs	r5, r0
   181e0:	2b00      	cmp	r3, #0
   181e2:	d147      	bne.n	18274 <_dtoa_r+0xa90>
   181e4:	0001      	movs	r1, r0
   181e6:	0030      	movs	r0, r6
   181e8:	f001 fb40 	bl	1986c <__mcmp>
   181ec:	4683      	mov	fp, r0
   181ee:	0029      	movs	r1, r5
   181f0:	4640      	mov	r0, r8
   181f2:	f001 f8e1 	bl	193b8 <_Bfree>
   181f6:	465b      	mov	r3, fp
   181f8:	9a22      	ldr	r2, [sp, #136]	; 0x88
   181fa:	4313      	orrs	r3, r2
   181fc:	d103      	bne.n	18206 <_dtoa_r+0xa22>
   181fe:	9b08      	ldr	r3, [sp, #32]
   18200:	2b00      	cmp	r3, #0
   18202:	d100      	bne.n	18206 <_dtoa_r+0xa22>
   18204:	e249      	b.n	1869a <_dtoa_r+0xeb6>
   18206:	2c00      	cmp	r4, #0
   18208:	da00      	bge.n	1820c <_dtoa_r+0xa28>
   1820a:	e0ec      	b.n	183e6 <_dtoa_r+0xc02>
   1820c:	9b22      	ldr	r3, [sp, #136]	; 0x88
   1820e:	431c      	orrs	r4, r3
   18210:	d103      	bne.n	1821a <_dtoa_r+0xa36>
   18212:	9b08      	ldr	r3, [sp, #32]
   18214:	2b00      	cmp	r3, #0
   18216:	d100      	bne.n	1821a <_dtoa_r+0xa36>
   18218:	e0e5      	b.n	183e6 <_dtoa_r+0xc02>
   1821a:	465b      	mov	r3, fp
   1821c:	2b00      	cmp	r3, #0
   1821e:	dd00      	ble.n	18222 <_dtoa_r+0xa3e>
   18220:	e1cc      	b.n	185bc <_dtoa_r+0xdd8>
   18222:	466a      	mov	r2, sp
   18224:	464b      	mov	r3, r9
   18226:	7a12      	ldrb	r2, [r2, #8]
   18228:	1c5d      	adds	r5, r3, #1
   1822a:	701a      	strb	r2, [r3, #0]
   1822c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1822e:	002c      	movs	r4, r5
   18230:	4599      	cmp	r9, r3
   18232:	d100      	bne.n	18236 <_dtoa_r+0xa52>
   18234:	e1d1      	b.n	185da <_dtoa_r+0xdf6>
   18236:	0031      	movs	r1, r6
   18238:	2300      	movs	r3, #0
   1823a:	220a      	movs	r2, #10
   1823c:	4640      	mov	r0, r8
   1823e:	f001 f8c5 	bl	193cc <__multadd>
   18242:	2300      	movs	r3, #0
   18244:	0006      	movs	r6, r0
   18246:	220a      	movs	r2, #10
   18248:	0039      	movs	r1, r7
   1824a:	4640      	mov	r0, r8
   1824c:	4557      	cmp	r7, sl
   1824e:	d00b      	beq.n	18268 <_dtoa_r+0xa84>
   18250:	f001 f8bc 	bl	193cc <__multadd>
   18254:	4651      	mov	r1, sl
   18256:	0007      	movs	r7, r0
   18258:	2300      	movs	r3, #0
   1825a:	220a      	movs	r2, #10
   1825c:	4640      	mov	r0, r8
   1825e:	f001 f8b5 	bl	193cc <__multadd>
   18262:	46a9      	mov	r9, r5
   18264:	4682      	mov	sl, r0
   18266:	e7a6      	b.n	181b6 <_dtoa_r+0x9d2>
   18268:	f001 f8b0 	bl	193cc <__multadd>
   1826c:	46a9      	mov	r9, r5
   1826e:	0007      	movs	r7, r0
   18270:	4682      	mov	sl, r0
   18272:	e7a0      	b.n	181b6 <_dtoa_r+0x9d2>
   18274:	2301      	movs	r3, #1
   18276:	469b      	mov	fp, r3
   18278:	e7b9      	b.n	181ee <_dtoa_r+0xa0a>
   1827a:	2301      	movs	r3, #1
   1827c:	2501      	movs	r5, #1
   1827e:	930f      	str	r3, [sp, #60]	; 0x3c
   18280:	9308      	str	r3, [sp, #32]
   18282:	9323      	str	r3, [sp, #140]	; 0x8c
   18284:	2300      	movs	r3, #0
   18286:	465a      	mov	r2, fp
   18288:	2100      	movs	r1, #0
   1828a:	6453      	str	r3, [r2, #68]	; 0x44
   1828c:	f7ff fba7 	bl	179de <_dtoa_r+0x1fa>
   18290:	4649      	mov	r1, r9
   18292:	0030      	movs	r0, r6
   18294:	f001 faea 	bl	1986c <__mcmp>
   18298:	2800      	cmp	r0, #0
   1829a:	db00      	blt.n	1829e <_dtoa_r+0xaba>
   1829c:	e696      	b.n	17fcc <_dtoa_r+0x7e8>
   1829e:	9b05      	ldr	r3, [sp, #20]
   182a0:	0031      	movs	r1, r6
   182a2:	3b01      	subs	r3, #1
   182a4:	9305      	str	r3, [sp, #20]
   182a6:	220a      	movs	r2, #10
   182a8:	2300      	movs	r3, #0
   182aa:	4658      	mov	r0, fp
   182ac:	f001 f88e 	bl	193cc <__multadd>
   182b0:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   182b2:	0006      	movs	r6, r0
   182b4:	2b00      	cmp	r3, #0
   182b6:	d000      	beq.n	182ba <_dtoa_r+0xad6>
   182b8:	e751      	b.n	1815e <_dtoa_r+0x97a>
   182ba:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   182bc:	2b00      	cmp	r3, #0
   182be:	dc00      	bgt.n	182c2 <_dtoa_r+0xade>
   182c0:	e20d      	b.n	186de <_dtoa_r+0xefa>
   182c2:	9308      	str	r3, [sp, #32]
   182c4:	e68a      	b.n	17fdc <_dtoa_r+0x7f8>
   182c6:	2300      	movs	r3, #0
   182c8:	930c      	str	r3, [sp, #48]	; 0x30
   182ca:	9b22      	ldr	r3, [sp, #136]	; 0x88
   182cc:	2b02      	cmp	r3, #2
   182ce:	d100      	bne.n	182d2 <_dtoa_r+0xaee>
   182d0:	e707      	b.n	180e2 <_dtoa_r+0x8fe>
   182d2:	2400      	movs	r4, #0
   182d4:	465b      	mov	r3, fp
   182d6:	0021      	movs	r1, r4
   182d8:	645c      	str	r4, [r3, #68]	; 0x44
   182da:	4658      	mov	r0, fp
   182dc:	f001 f844 	bl	19368 <_Balloc>
   182e0:	465b      	mov	r3, fp
   182e2:	6418      	str	r0, [r3, #64]	; 0x40
   182e4:	2301      	movs	r3, #1
   182e6:	425b      	negs	r3, r3
   182e8:	9308      	str	r3, [sp, #32]
   182ea:	930f      	str	r3, [sp, #60]	; 0x3c
   182ec:	3302      	adds	r3, #2
   182ee:	9009      	str	r0, [sp, #36]	; 0x24
   182f0:	9423      	str	r4, [sp, #140]	; 0x8c
   182f2:	930c      	str	r3, [sp, #48]	; 0x30
   182f4:	e4ef      	b.n	17cd6 <_dtoa_r+0x4f2>
   182f6:	9e0a      	ldr	r6, [sp, #40]	; 0x28
   182f8:	e621      	b.n	17f3e <_dtoa_r+0x75a>
   182fa:	9b22      	ldr	r3, [sp, #136]	; 0x88
   182fc:	2b02      	cmp	r3, #2
   182fe:	dc00      	bgt.n	18302 <_dtoa_r+0xb1e>
   18300:	e668      	b.n	17fd4 <_dtoa_r+0x7f0>
   18302:	9b08      	ldr	r3, [sp, #32]
   18304:	2b00      	cmp	r3, #0
   18306:	d000      	beq.n	1830a <_dtoa_r+0xb26>
   18308:	e188      	b.n	1861c <_dtoa_r+0xe38>
   1830a:	4649      	mov	r1, r9
   1830c:	2205      	movs	r2, #5
   1830e:	4658      	mov	r0, fp
   18310:	f001 f85c 	bl	193cc <__multadd>
   18314:	0001      	movs	r1, r0
   18316:	4681      	mov	r9, r0
   18318:	0030      	movs	r0, r6
   1831a:	f001 faa7 	bl	1986c <__mcmp>
   1831e:	960a      	str	r6, [sp, #40]	; 0x28
   18320:	2800      	cmp	r0, #0
   18322:	dc00      	bgt.n	18326 <_dtoa_r+0xb42>
   18324:	e6fc      	b.n	18120 <_dtoa_r+0x93c>
   18326:	2331      	movs	r3, #49	; 0x31
   18328:	9a09      	ldr	r2, [sp, #36]	; 0x24
   1832a:	7013      	strb	r3, [r2, #0]
   1832c:	9b05      	ldr	r3, [sp, #20]
   1832e:	1c54      	adds	r4, r2, #1
   18330:	3301      	adds	r3, #1
   18332:	9305      	str	r3, [sp, #20]
   18334:	e6f8      	b.n	18128 <_dtoa_r+0x944>
   18336:	2300      	movs	r3, #0
   18338:	930c      	str	r3, [sp, #48]	; 0x30
   1833a:	f7ff fb32 	bl	179a2 <_dtoa_r+0x1be>
   1833e:	9b05      	ldr	r3, [sp, #20]
   18340:	9a09      	ldr	r2, [sp, #36]	; 0x24
   18342:	3301      	adds	r3, #1
   18344:	9305      	str	r3, [sp, #20]
   18346:	2331      	movs	r3, #49	; 0x31
   18348:	7013      	strb	r3, [r2, #0]
   1834a:	e688      	b.n	1805e <_dtoa_r+0x87a>
   1834c:	9b02      	ldr	r3, [sp, #8]
   1834e:	465c      	mov	r4, fp
   18350:	469b      	mov	fp, r3
   18352:	e47a      	b.n	17c4a <_dtoa_r+0x466>
   18354:	4640      	mov	r0, r8
   18356:	f007 fc19 	bl	1fb8c <__aeabi_i2d>
   1835a:	0032      	movs	r2, r6
   1835c:	003b      	movs	r3, r7
   1835e:	f006 fdf1 	bl	1ef44 <__aeabi_dmul>
   18362:	2200      	movs	r2, #0
   18364:	4b34      	ldr	r3, [pc, #208]	; (18438 <_dtoa_r+0xc54>)
   18366:	f005 fe9d 	bl	1e0a4 <__aeabi_dadd>
   1836a:	4a34      	ldr	r2, [pc, #208]	; (1843c <_dtoa_r+0xc58>)
   1836c:	000b      	movs	r3, r1
   1836e:	4694      	mov	ip, r2
   18370:	4463      	add	r3, ip
   18372:	9002      	str	r0, [sp, #8]
   18374:	9103      	str	r1, [sp, #12]
   18376:	9303      	str	r3, [sp, #12]
   18378:	2200      	movs	r2, #0
   1837a:	4b2d      	ldr	r3, [pc, #180]	; (18430 <_dtoa_r+0xc4c>)
   1837c:	0030      	movs	r0, r6
   1837e:	0039      	movs	r1, r7
   18380:	f007 f85a 	bl	1f438 <__aeabi_dsub>
   18384:	9e02      	ldr	r6, [sp, #8]
   18386:	9f03      	ldr	r7, [sp, #12]
   18388:	0032      	movs	r2, r6
   1838a:	003b      	movs	r3, r7
   1838c:	0004      	movs	r4, r0
   1838e:	000d      	movs	r5, r1
   18390:	f005 fd2a 	bl	1dde8 <__aeabi_dcmpgt>
   18394:	2800      	cmp	r0, #0
   18396:	d000      	beq.n	1839a <_dtoa_r+0xbb6>
   18398:	e0b1      	b.n	184fe <_dtoa_r+0xd1a>
   1839a:	2080      	movs	r0, #128	; 0x80
   1839c:	0600      	lsls	r0, r0, #24
   1839e:	4684      	mov	ip, r0
   183a0:	0039      	movs	r1, r7
   183a2:	4461      	add	r1, ip
   183a4:	000b      	movs	r3, r1
   183a6:	0032      	movs	r2, r6
   183a8:	0020      	movs	r0, r4
   183aa:	0029      	movs	r1, r5
   183ac:	f005 fd08 	bl	1ddc0 <__aeabi_dcmplt>
   183b0:	2800      	cmp	r0, #0
   183b2:	d055      	beq.n	18460 <_dtoa_r+0xc7c>
   183b4:	2300      	movs	r3, #0
   183b6:	2700      	movs	r7, #0
   183b8:	4699      	mov	r9, r3
   183ba:	e6b1      	b.n	18120 <_dtoa_r+0x93c>
   183bc:	9809      	ldr	r0, [sp, #36]	; 0x24
   183be:	f7ff fa49 	bl	17854 <_dtoa_r+0x70>
   183c2:	9a0e      	ldr	r2, [sp, #56]	; 0x38
   183c4:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   183c6:	4694      	mov	ip, r2
   183c8:	1aeb      	subs	r3, r5, r3
   183ca:	449c      	add	ip, r3
   183cc:	4663      	mov	r3, ip
   183ce:	950b      	str	r5, [sp, #44]	; 0x2c
   183d0:	930e      	str	r3, [sp, #56]	; 0x38
   183d2:	2500      	movs	r5, #0
   183d4:	e53d      	b.n	17e52 <_dtoa_r+0x66e>
   183d6:	9a10      	ldr	r2, [sp, #64]	; 0x40
   183d8:	9b11      	ldr	r3, [sp, #68]	; 0x44
   183da:	9202      	str	r2, [sp, #8]
   183dc:	9303      	str	r3, [sp, #12]
   183de:	2302      	movs	r3, #2
   183e0:	4698      	mov	r8, r3
   183e2:	f7ff fb2a 	bl	17a3a <_dtoa_r+0x256>
   183e6:	465b      	mov	r3, fp
   183e8:	9a06      	ldr	r2, [sp, #24]
   183ea:	464d      	mov	r5, r9
   183ec:	46c3      	mov	fp, r8
   183ee:	4691      	mov	r9, r2
   183f0:	2b00      	cmp	r3, #0
   183f2:	dd12      	ble.n	1841a <_dtoa_r+0xc36>
   183f4:	0031      	movs	r1, r6
   183f6:	2201      	movs	r2, #1
   183f8:	4640      	mov	r0, r8
   183fa:	f001 f9d7 	bl	197ac <__lshift>
   183fe:	4649      	mov	r1, r9
   18400:	0006      	movs	r6, r0
   18402:	f001 fa33 	bl	1986c <__mcmp>
   18406:	2800      	cmp	r0, #0
   18408:	dc00      	bgt.n	1840c <_dtoa_r+0xc28>
   1840a:	e160      	b.n	186ce <_dtoa_r+0xeea>
   1840c:	9b02      	ldr	r3, [sp, #8]
   1840e:	2b39      	cmp	r3, #57	; 0x39
   18410:	d100      	bne.n	18414 <_dtoa_r+0xc30>
   18412:	e0fb      	b.n	1860c <_dtoa_r+0xe28>
   18414:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   18416:	3331      	adds	r3, #49	; 0x31
   18418:	9302      	str	r3, [sp, #8]
   1841a:	466b      	mov	r3, sp
   1841c:	7a1b      	ldrb	r3, [r3, #8]
   1841e:	46b8      	mov	r8, r7
   18420:	1c6c      	adds	r4, r5, #1
   18422:	702b      	strb	r3, [r5, #0]
   18424:	4657      	mov	r7, sl
   18426:	960a      	str	r6, [sp, #40]	; 0x28
   18428:	e619      	b.n	1805e <_dtoa_r+0x87a>
   1842a:	46c0      	nop			; (mov r8, r8)
   1842c:	7ff00000 	.word	0x7ff00000
   18430:	40140000 	.word	0x40140000
   18434:	00000433 	.word	0x00000433
   18438:	401c0000 	.word	0x401c0000
   1843c:	fcc00000 	.word	0xfcc00000
   18440:	2800      	cmp	r0, #0
   18442:	d104      	bne.n	1844e <_dtoa_r+0xc6a>
   18444:	9b02      	ldr	r3, [sp, #8]
   18446:	07db      	lsls	r3, r3, #31
   18448:	d501      	bpl.n	1844e <_dtoa_r+0xc6a>
   1844a:	e5f9      	b.n	18040 <_dtoa_r+0x85c>
   1844c:	001c      	movs	r4, r3
   1844e:	1e63      	subs	r3, r4, #1
   18450:	781a      	ldrb	r2, [r3, #0]
   18452:	2a30      	cmp	r2, #48	; 0x30
   18454:	d0fa      	beq.n	1844c <_dtoa_r+0xc68>
   18456:	e602      	b.n	1805e <_dtoa_r+0x87a>
   18458:	9b13      	ldr	r3, [sp, #76]	; 0x4c
   1845a:	469a      	mov	sl, r3
   1845c:	9b02      	ldr	r3, [sp, #8]
   1845e:	469b      	mov	fp, r3
   18460:	9b10      	ldr	r3, [sp, #64]	; 0x40
   18462:	9c11      	ldr	r4, [sp, #68]	; 0x44
   18464:	9302      	str	r3, [sp, #8]
   18466:	9403      	str	r4, [sp, #12]
   18468:	e435      	b.n	17cd6 <_dtoa_r+0x4f2>
   1846a:	9b05      	ldr	r3, [sp, #20]
   1846c:	425c      	negs	r4, r3
   1846e:	2c00      	cmp	r4, #0
   18470:	d100      	bne.n	18474 <_dtoa_r+0xc90>
   18472:	e0c5      	b.n	18600 <_dtoa_r+0xe1c>
   18474:	9810      	ldr	r0, [sp, #64]	; 0x40
   18476:	9911      	ldr	r1, [sp, #68]	; 0x44
   18478:	230f      	movs	r3, #15
   1847a:	4aa9      	ldr	r2, [pc, #676]	; (18720 <_dtoa_r+0xf3c>)
   1847c:	4023      	ands	r3, r4
   1847e:	00db      	lsls	r3, r3, #3
   18480:	18d3      	adds	r3, r2, r3
   18482:	681a      	ldr	r2, [r3, #0]
   18484:	685b      	ldr	r3, [r3, #4]
   18486:	f006 fd5d 	bl	1ef44 <__aeabi_dmul>
   1848a:	1124      	asrs	r4, r4, #4
   1848c:	0006      	movs	r6, r0
   1848e:	000f      	movs	r7, r1
   18490:	2c00      	cmp	r4, #0
   18492:	d100      	bne.n	18496 <_dtoa_r+0xcb2>
   18494:	e130      	b.n	186f8 <_dtoa_r+0xf14>
   18496:	2302      	movs	r3, #2
   18498:	4698      	mov	r8, r3
   1849a:	3b01      	subs	r3, #1
   1849c:	4699      	mov	r9, r3
   1849e:	4da1      	ldr	r5, [pc, #644]	; (18724 <_dtoa_r+0xf40>)
   184a0:	464b      	mov	r3, r9
   184a2:	4223      	tst	r3, r4
   184a4:	d00a      	beq.n	184bc <_dtoa_r+0xcd8>
   184a6:	2301      	movs	r3, #1
   184a8:	469c      	mov	ip, r3
   184aa:	682a      	ldr	r2, [r5, #0]
   184ac:	686b      	ldr	r3, [r5, #4]
   184ae:	0030      	movs	r0, r6
   184b0:	0039      	movs	r1, r7
   184b2:	44e0      	add	r8, ip
   184b4:	f006 fd46 	bl	1ef44 <__aeabi_dmul>
   184b8:	0006      	movs	r6, r0
   184ba:	000f      	movs	r7, r1
   184bc:	1064      	asrs	r4, r4, #1
   184be:	3508      	adds	r5, #8
   184c0:	2c00      	cmp	r4, #0
   184c2:	d1ed      	bne.n	184a0 <_dtoa_r+0xcbc>
   184c4:	f7ff fad8 	bl	17a78 <_dtoa_r+0x294>
   184c8:	9b05      	ldr	r3, [sp, #20]
   184ca:	3301      	adds	r3, #1
   184cc:	9305      	str	r3, [sp, #20]
   184ce:	2330      	movs	r3, #48	; 0x30
   184d0:	702b      	strb	r3, [r5, #0]
   184d2:	4698      	mov	r8, r3
   184d4:	e4ab      	b.n	17e2e <_dtoa_r+0x64a>
   184d6:	6879      	ldr	r1, [r7, #4]
   184d8:	4658      	mov	r0, fp
   184da:	f000 ff45 	bl	19368 <_Balloc>
   184de:	0039      	movs	r1, r7
   184e0:	0004      	movs	r4, r0
   184e2:	693b      	ldr	r3, [r7, #16]
   184e4:	310c      	adds	r1, #12
   184e6:	1c9a      	adds	r2, r3, #2
   184e8:	0092      	lsls	r2, r2, #2
   184ea:	300c      	adds	r0, #12
   184ec:	f7fd fa70 	bl	159d0 <memcpy>
   184f0:	2201      	movs	r2, #1
   184f2:	0021      	movs	r1, r4
   184f4:	4658      	mov	r0, fp
   184f6:	f001 f959 	bl	197ac <__lshift>
   184fa:	4682      	mov	sl, r0
   184fc:	e64b      	b.n	18196 <_dtoa_r+0x9b2>
   184fe:	2300      	movs	r3, #0
   18500:	2700      	movs	r7, #0
   18502:	4699      	mov	r9, r3
   18504:	e70f      	b.n	18326 <_dtoa_r+0xb42>
   18506:	9b13      	ldr	r3, [sp, #76]	; 0x4c
   18508:	1e59      	subs	r1, r3, #1
   1850a:	00cb      	lsls	r3, r1, #3
   1850c:	9115      	str	r1, [sp, #84]	; 0x54
   1850e:	4984      	ldr	r1, [pc, #528]	; (18720 <_dtoa_r+0xf3c>)
   18510:	18c9      	adds	r1, r1, r3
   18512:	6808      	ldr	r0, [r1, #0]
   18514:	6849      	ldr	r1, [r1, #4]
   18516:	9a02      	ldr	r2, [sp, #8]
   18518:	9b03      	ldr	r3, [sp, #12]
   1851a:	f006 fd13 	bl	1ef44 <__aeabi_dmul>
   1851e:	9002      	str	r0, [sp, #8]
   18520:	9103      	str	r1, [sp, #12]
   18522:	0039      	movs	r1, r7
   18524:	0030      	movs	r0, r6
   18526:	f007 fafb 	bl	1fb20 <__aeabi_d2iz>
   1852a:	0005      	movs	r5, r0
   1852c:	f007 fb2e 	bl	1fb8c <__aeabi_i2d>
   18530:	0002      	movs	r2, r0
   18532:	000b      	movs	r3, r1
   18534:	0030      	movs	r0, r6
   18536:	0039      	movs	r1, r7
   18538:	f006 ff7e 	bl	1f438 <__aeabi_dsub>
   1853c:	9b13      	ldr	r3, [sp, #76]	; 0x4c
   1853e:	000f      	movs	r7, r1
   18540:	9909      	ldr	r1, [sp, #36]	; 0x24
   18542:	001a      	movs	r2, r3
   18544:	468c      	mov	ip, r1
   18546:	3530      	adds	r5, #48	; 0x30
   18548:	4462      	add	r2, ip
   1854a:	0006      	movs	r6, r0
   1854c:	1c4c      	adds	r4, r1, #1
   1854e:	700d      	strb	r5, [r1, #0]
   18550:	4691      	mov	r9, r2
   18552:	2b01      	cmp	r3, #1
   18554:	d01e      	beq.n	18594 <_dtoa_r+0xdb0>
   18556:	46a0      	mov	r8, r4
   18558:	2200      	movs	r2, #0
   1855a:	4b73      	ldr	r3, [pc, #460]	; (18728 <_dtoa_r+0xf44>)
   1855c:	0030      	movs	r0, r6
   1855e:	0039      	movs	r1, r7
   18560:	f006 fcf0 	bl	1ef44 <__aeabi_dmul>
   18564:	000f      	movs	r7, r1
   18566:	0006      	movs	r6, r0
   18568:	f007 fada 	bl	1fb20 <__aeabi_d2iz>
   1856c:	0005      	movs	r5, r0
   1856e:	f007 fb0d 	bl	1fb8c <__aeabi_i2d>
   18572:	0002      	movs	r2, r0
   18574:	000b      	movs	r3, r1
   18576:	0030      	movs	r0, r6
   18578:	0039      	movs	r1, r7
   1857a:	f006 ff5d 	bl	1f438 <__aeabi_dsub>
   1857e:	3530      	adds	r5, #48	; 0x30
   18580:	7025      	strb	r5, [r4, #0]
   18582:	3401      	adds	r4, #1
   18584:	0006      	movs	r6, r0
   18586:	000f      	movs	r7, r1
   18588:	454c      	cmp	r4, r9
   1858a:	d1e5      	bne.n	18558 <_dtoa_r+0xd74>
   1858c:	9b15      	ldr	r3, [sp, #84]	; 0x54
   1858e:	4644      	mov	r4, r8
   18590:	469c      	mov	ip, r3
   18592:	4464      	add	r4, ip
   18594:	2200      	movs	r2, #0
   18596:	9802      	ldr	r0, [sp, #8]
   18598:	9903      	ldr	r1, [sp, #12]
   1859a:	4b64      	ldr	r3, [pc, #400]	; (1872c <_dtoa_r+0xf48>)
   1859c:	f005 fd82 	bl	1e0a4 <__aeabi_dadd>
   185a0:	0032      	movs	r2, r6
   185a2:	003b      	movs	r3, r7
   185a4:	f005 fc0c 	bl	1ddc0 <__aeabi_dcmplt>
   185a8:	2800      	cmp	r0, #0
   185aa:	d062      	beq.n	18672 <_dtoa_r+0xe8e>
   185ac:	1e65      	subs	r5, r4, #1
   185ae:	782b      	ldrb	r3, [r5, #0]
   185b0:	9a09      	ldr	r2, [sp, #36]	; 0x24
   185b2:	4698      	mov	r8, r3
   185b4:	9b14      	ldr	r3, [sp, #80]	; 0x50
   185b6:	9305      	str	r3, [sp, #20]
   185b8:	4643      	mov	r3, r8
   185ba:	e435      	b.n	17e28 <_dtoa_r+0x644>
   185bc:	9b06      	ldr	r3, [sp, #24]
   185be:	464d      	mov	r5, r9
   185c0:	4699      	mov	r9, r3
   185c2:	9b02      	ldr	r3, [sp, #8]
   185c4:	46c3      	mov	fp, r8
   185c6:	2b39      	cmp	r3, #57	; 0x39
   185c8:	d020      	beq.n	1860c <_dtoa_r+0xe28>
   185ca:	9b02      	ldr	r3, [sp, #8]
   185cc:	46b8      	mov	r8, r7
   185ce:	3301      	adds	r3, #1
   185d0:	1c6c      	adds	r4, r5, #1
   185d2:	702b      	strb	r3, [r5, #0]
   185d4:	4657      	mov	r7, sl
   185d6:	960a      	str	r6, [sp, #40]	; 0x28
   185d8:	e541      	b.n	1805e <_dtoa_r+0x87a>
   185da:	9b06      	ldr	r3, [sp, #24]
   185dc:	46c3      	mov	fp, r8
   185de:	4699      	mov	r9, r3
   185e0:	46b8      	mov	r8, r7
   185e2:	4657      	mov	r7, sl
   185e4:	e520      	b.n	18028 <_dtoa_r+0x844>
   185e6:	9b06      	ldr	r3, [sp, #24]
   185e8:	9a08      	ldr	r2, [sp, #32]
   185ea:	1a9c      	subs	r4, r3, r2
   185ec:	2300      	movs	r3, #0
   185ee:	e436      	b.n	17e5e <_dtoa_r+0x67a>
   185f0:	2401      	movs	r4, #1
   185f2:	e514      	b.n	1801e <_dtoa_r+0x83a>
   185f4:	2336      	movs	r3, #54	; 0x36
   185f6:	9a16      	ldr	r2, [sp, #88]	; 0x58
   185f8:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
   185fa:	1a9b      	subs	r3, r3, r2
   185fc:	9c06      	ldr	r4, [sp, #24]
   185fe:	e42e      	b.n	17e5e <_dtoa_r+0x67a>
   18600:	2302      	movs	r3, #2
   18602:	9e10      	ldr	r6, [sp, #64]	; 0x40
   18604:	9f11      	ldr	r7, [sp, #68]	; 0x44
   18606:	4698      	mov	r8, r3
   18608:	f7ff fa36 	bl	17a78 <_dtoa_r+0x294>
   1860c:	2339      	movs	r3, #57	; 0x39
   1860e:	46b8      	mov	r8, r7
   18610:	1c6c      	adds	r4, r5, #1
   18612:	702b      	strb	r3, [r5, #0]
   18614:	4657      	mov	r7, sl
   18616:	960a      	str	r6, [sp, #40]	; 0x28
   18618:	9a09      	ldr	r2, [sp, #36]	; 0x24
   1861a:	e51c      	b.n	18056 <_dtoa_r+0x872>
   1861c:	960a      	str	r6, [sp, #40]	; 0x28
   1861e:	e57f      	b.n	18120 <_dtoa_r+0x93c>
   18620:	9b08      	ldr	r3, [sp, #32]
   18622:	2b00      	cmp	r3, #0
   18624:	d100      	bne.n	18628 <_dtoa_r+0xe44>
   18626:	e695      	b.n	18354 <_dtoa_r+0xb70>
   18628:	9c0f      	ldr	r4, [sp, #60]	; 0x3c
   1862a:	2c00      	cmp	r4, #0
   1862c:	dc00      	bgt.n	18630 <_dtoa_r+0xe4c>
   1862e:	e717      	b.n	18460 <_dtoa_r+0xc7c>
   18630:	9b05      	ldr	r3, [sp, #20]
   18632:	2200      	movs	r2, #0
   18634:	3b01      	subs	r3, #1
   18636:	9314      	str	r3, [sp, #80]	; 0x50
   18638:	0030      	movs	r0, r6
   1863a:	4b3b      	ldr	r3, [pc, #236]	; (18728 <_dtoa_r+0xf44>)
   1863c:	0039      	movs	r1, r7
   1863e:	f006 fc81 	bl	1ef44 <__aeabi_dmul>
   18642:	0006      	movs	r6, r0
   18644:	4640      	mov	r0, r8
   18646:	000f      	movs	r7, r1
   18648:	3001      	adds	r0, #1
   1864a:	f007 fa9f 	bl	1fb8c <__aeabi_i2d>
   1864e:	0032      	movs	r2, r6
   18650:	003b      	movs	r3, r7
   18652:	f006 fc77 	bl	1ef44 <__aeabi_dmul>
   18656:	2200      	movs	r2, #0
   18658:	4b35      	ldr	r3, [pc, #212]	; (18730 <_dtoa_r+0xf4c>)
   1865a:	f005 fd23 	bl	1e0a4 <__aeabi_dadd>
   1865e:	4a35      	ldr	r2, [pc, #212]	; (18734 <_dtoa_r+0xf50>)
   18660:	000b      	movs	r3, r1
   18662:	4694      	mov	ip, r2
   18664:	4463      	add	r3, ip
   18666:	9002      	str	r0, [sp, #8]
   18668:	9103      	str	r1, [sp, #12]
   1866a:	9413      	str	r4, [sp, #76]	; 0x4c
   1866c:	9303      	str	r3, [sp, #12]
   1866e:	f7ff fa2b 	bl	17ac8 <_dtoa_r+0x2e4>
   18672:	9a02      	ldr	r2, [sp, #8]
   18674:	9b03      	ldr	r3, [sp, #12]
   18676:	2000      	movs	r0, #0
   18678:	492c      	ldr	r1, [pc, #176]	; (1872c <_dtoa_r+0xf48>)
   1867a:	f006 fedd 	bl	1f438 <__aeabi_dsub>
   1867e:	0032      	movs	r2, r6
   18680:	003b      	movs	r3, r7
   18682:	f005 fbb1 	bl	1dde8 <__aeabi_dcmpgt>
   18686:	2800      	cmp	r0, #0
   18688:	d101      	bne.n	1868e <_dtoa_r+0xeaa>
   1868a:	e6e9      	b.n	18460 <_dtoa_r+0xc7c>
   1868c:	001c      	movs	r4, r3
   1868e:	1e63      	subs	r3, r4, #1
   18690:	781a      	ldrb	r2, [r3, #0]
   18692:	2a30      	cmp	r2, #48	; 0x30
   18694:	d0fa      	beq.n	1868c <_dtoa_r+0xea8>
   18696:	f7ff fad6 	bl	17c46 <_dtoa_r+0x462>
   1869a:	9b06      	ldr	r3, [sp, #24]
   1869c:	464d      	mov	r5, r9
   1869e:	4699      	mov	r9, r3
   186a0:	9b02      	ldr	r3, [sp, #8]
   186a2:	46c3      	mov	fp, r8
   186a4:	2b39      	cmp	r3, #57	; 0x39
   186a6:	d0b1      	beq.n	1860c <_dtoa_r+0xe28>
   186a8:	2c00      	cmp	r4, #0
   186aa:	dd00      	ble.n	186ae <_dtoa_r+0xeca>
   186ac:	e6b2      	b.n	18414 <_dtoa_r+0xc30>
   186ae:	e6b4      	b.n	1841a <_dtoa_r+0xc36>
   186b0:	9b02      	ldr	r3, [sp, #8]
   186b2:	465d      	mov	r5, fp
   186b4:	469b      	mov	fp, r3
   186b6:	9b14      	ldr	r3, [sp, #80]	; 0x50
   186b8:	4654      	mov	r4, sl
   186ba:	9305      	str	r3, [sp, #20]
   186bc:	9a09      	ldr	r2, [sp, #36]	; 0x24
   186be:	4643      	mov	r3, r8
   186c0:	f7ff fbb2 	bl	17e28 <_dtoa_r+0x644>
   186c4:	9b02      	ldr	r3, [sp, #8]
   186c6:	2b00      	cmp	r3, #0
   186c8:	d000      	beq.n	186cc <_dtoa_r+0xee8>
   186ca:	e545      	b.n	18158 <_dtoa_r+0x974>
   186cc:	e4f2      	b.n	180b4 <_dtoa_r+0x8d0>
   186ce:	2800      	cmp	r0, #0
   186d0:	d000      	beq.n	186d4 <_dtoa_r+0xef0>
   186d2:	e6a2      	b.n	1841a <_dtoa_r+0xc36>
   186d4:	9b02      	ldr	r3, [sp, #8]
   186d6:	07db      	lsls	r3, r3, #31
   186d8:	d400      	bmi.n	186dc <_dtoa_r+0xef8>
   186da:	e69e      	b.n	1841a <_dtoa_r+0xc36>
   186dc:	e696      	b.n	1840c <_dtoa_r+0xc28>
   186de:	9b22      	ldr	r3, [sp, #136]	; 0x88
   186e0:	2b02      	cmp	r3, #2
   186e2:	dc1a      	bgt.n	1871a <_dtoa_r+0xf36>
   186e4:	4649      	mov	r1, r9
   186e6:	f7fe ffd5 	bl	17694 <quorem>
   186ea:	9b09      	ldr	r3, [sp, #36]	; 0x24
   186ec:	3030      	adds	r0, #48	; 0x30
   186ee:	7018      	strb	r0, [r3, #0]
   186f0:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   186f2:	9002      	str	r0, [sp, #8]
   186f4:	9308      	str	r3, [sp, #32]
   186f6:	e48e      	b.n	18016 <_dtoa_r+0x832>
   186f8:	2302      	movs	r3, #2
   186fa:	4698      	mov	r8, r3
   186fc:	f7ff f9bc 	bl	17a78 <_dtoa_r+0x294>
   18700:	9b14      	ldr	r3, [sp, #80]	; 0x50
   18702:	9a09      	ldr	r2, [sp, #36]	; 0x24
   18704:	9305      	str	r3, [sp, #20]
   18706:	0015      	movs	r5, r2
   18708:	4643      	mov	r3, r8
   1870a:	f7ff fb8d 	bl	17e28 <_dtoa_r+0x644>
   1870e:	2b04      	cmp	r3, #4
   18710:	d100      	bne.n	18714 <_dtoa_r+0xf30>
   18712:	e445      	b.n	17fa0 <_dtoa_r+0x7bc>
   18714:	233c      	movs	r3, #60	; 0x3c
   18716:	1a18      	subs	r0, r3, r0
   18718:	e43b      	b.n	17f92 <_dtoa_r+0x7ae>
   1871a:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   1871c:	9308      	str	r3, [sp, #32]
   1871e:	e5f0      	b.n	18302 <_dtoa_r+0xb1e>
   18720:	00022da0 	.word	0x00022da0
   18724:	00022e78 	.word	0x00022e78
   18728:	40240000 	.word	0x40240000
   1872c:	3fe00000 	.word	0x3fe00000
   18730:	401c0000 	.word	0x401c0000
   18734:	fcc00000 	.word	0xfcc00000

00018738 <__sflush_r>:
   18738:	b5f0      	push	{r4, r5, r6, r7, lr}
   1873a:	4647      	mov	r7, r8
   1873c:	b480      	push	{r7}
   1873e:	220c      	movs	r2, #12
   18740:	5e8b      	ldrsh	r3, [r1, r2]
   18742:	4680      	mov	r8, r0
   18744:	b29a      	uxth	r2, r3
   18746:	000c      	movs	r4, r1
   18748:	0711      	lsls	r1, r2, #28
   1874a:	d440      	bmi.n	187ce <__sflush_r+0x96>
   1874c:	2280      	movs	r2, #128	; 0x80
   1874e:	0112      	lsls	r2, r2, #4
   18750:	4313      	orrs	r3, r2
   18752:	6862      	ldr	r2, [r4, #4]
   18754:	81a3      	strh	r3, [r4, #12]
   18756:	2a00      	cmp	r2, #0
   18758:	dc00      	bgt.n	1875c <__sflush_r+0x24>
   1875a:	e070      	b.n	1883e <__sflush_r+0x106>
   1875c:	6aa6      	ldr	r6, [r4, #40]	; 0x28
   1875e:	2e00      	cmp	r6, #0
   18760:	d031      	beq.n	187c6 <__sflush_r+0x8e>
   18762:	4642      	mov	r2, r8
   18764:	4641      	mov	r1, r8
   18766:	6815      	ldr	r5, [r2, #0]
   18768:	2200      	movs	r2, #0
   1876a:	b29b      	uxth	r3, r3
   1876c:	600a      	str	r2, [r1, #0]
   1876e:	04da      	lsls	r2, r3, #19
   18770:	d400      	bmi.n	18774 <__sflush_r+0x3c>
   18772:	e069      	b.n	18848 <__sflush_r+0x110>
   18774:	6d22      	ldr	r2, [r4, #80]	; 0x50
   18776:	075b      	lsls	r3, r3, #29
   18778:	d506      	bpl.n	18788 <__sflush_r+0x50>
   1877a:	6863      	ldr	r3, [r4, #4]
   1877c:	1ad2      	subs	r2, r2, r3
   1877e:	6b23      	ldr	r3, [r4, #48]	; 0x30
   18780:	2b00      	cmp	r3, #0
   18782:	d001      	beq.n	18788 <__sflush_r+0x50>
   18784:	6be3      	ldr	r3, [r4, #60]	; 0x3c
   18786:	1ad2      	subs	r2, r2, r3
   18788:	2300      	movs	r3, #0
   1878a:	69e1      	ldr	r1, [r4, #28]
   1878c:	4640      	mov	r0, r8
   1878e:	47b0      	blx	r6
   18790:	1c43      	adds	r3, r0, #1
   18792:	d03d      	beq.n	18810 <__sflush_r+0xd8>
   18794:	89a2      	ldrh	r2, [r4, #12]
   18796:	4b3a      	ldr	r3, [pc, #232]	; (18880 <__sflush_r+0x148>)
   18798:	4013      	ands	r3, r2
   1879a:	2200      	movs	r2, #0
   1879c:	6062      	str	r2, [r4, #4]
   1879e:	6922      	ldr	r2, [r4, #16]
   187a0:	b21b      	sxth	r3, r3
   187a2:	81a3      	strh	r3, [r4, #12]
   187a4:	6022      	str	r2, [r4, #0]
   187a6:	04db      	lsls	r3, r3, #19
   187a8:	d447      	bmi.n	1883a <__sflush_r+0x102>
   187aa:	4643      	mov	r3, r8
   187ac:	6b21      	ldr	r1, [r4, #48]	; 0x30
   187ae:	601d      	str	r5, [r3, #0]
   187b0:	2900      	cmp	r1, #0
   187b2:	d008      	beq.n	187c6 <__sflush_r+0x8e>
   187b4:	0023      	movs	r3, r4
   187b6:	3340      	adds	r3, #64	; 0x40
   187b8:	4299      	cmp	r1, r3
   187ba:	d002      	beq.n	187c2 <__sflush_r+0x8a>
   187bc:	4640      	mov	r0, r8
   187be:	f000 f9f5 	bl	18bac <_free_r>
   187c2:	2300      	movs	r3, #0
   187c4:	6323      	str	r3, [r4, #48]	; 0x30
   187c6:	2000      	movs	r0, #0
   187c8:	bc04      	pop	{r2}
   187ca:	4690      	mov	r8, r2
   187cc:	bdf0      	pop	{r4, r5, r6, r7, pc}
   187ce:	6926      	ldr	r6, [r4, #16]
   187d0:	2e00      	cmp	r6, #0
   187d2:	d0f8      	beq.n	187c6 <__sflush_r+0x8e>
   187d4:	6823      	ldr	r3, [r4, #0]
   187d6:	6026      	str	r6, [r4, #0]
   187d8:	1b9d      	subs	r5, r3, r6
   187da:	2300      	movs	r3, #0
   187dc:	0792      	lsls	r2, r2, #30
   187de:	d100      	bne.n	187e2 <__sflush_r+0xaa>
   187e0:	6963      	ldr	r3, [r4, #20]
   187e2:	60a3      	str	r3, [r4, #8]
   187e4:	2d00      	cmp	r5, #0
   187e6:	dc04      	bgt.n	187f2 <__sflush_r+0xba>
   187e8:	e7ed      	b.n	187c6 <__sflush_r+0x8e>
   187ea:	1836      	adds	r6, r6, r0
   187ec:	1a2d      	subs	r5, r5, r0
   187ee:	2d00      	cmp	r5, #0
   187f0:	dde9      	ble.n	187c6 <__sflush_r+0x8e>
   187f2:	002b      	movs	r3, r5
   187f4:	0032      	movs	r2, r6
   187f6:	69e1      	ldr	r1, [r4, #28]
   187f8:	4640      	mov	r0, r8
   187fa:	6a67      	ldr	r7, [r4, #36]	; 0x24
   187fc:	47b8      	blx	r7
   187fe:	2800      	cmp	r0, #0
   18800:	dcf3      	bgt.n	187ea <__sflush_r+0xb2>
   18802:	2340      	movs	r3, #64	; 0x40
   18804:	2001      	movs	r0, #1
   18806:	89a2      	ldrh	r2, [r4, #12]
   18808:	4240      	negs	r0, r0
   1880a:	4313      	orrs	r3, r2
   1880c:	81a3      	strh	r3, [r4, #12]
   1880e:	e7db      	b.n	187c8 <__sflush_r+0x90>
   18810:	4643      	mov	r3, r8
   18812:	6819      	ldr	r1, [r3, #0]
   18814:	291d      	cmp	r1, #29
   18816:	d8f4      	bhi.n	18802 <__sflush_r+0xca>
   18818:	4b1a      	ldr	r3, [pc, #104]	; (18884 <__sflush_r+0x14c>)
   1881a:	2201      	movs	r2, #1
   1881c:	40cb      	lsrs	r3, r1
   1881e:	439a      	bics	r2, r3
   18820:	d1ef      	bne.n	18802 <__sflush_r+0xca>
   18822:	89a6      	ldrh	r6, [r4, #12]
   18824:	4b16      	ldr	r3, [pc, #88]	; (18880 <__sflush_r+0x148>)
   18826:	6062      	str	r2, [r4, #4]
   18828:	4033      	ands	r3, r6
   1882a:	6922      	ldr	r2, [r4, #16]
   1882c:	b21b      	sxth	r3, r3
   1882e:	81a3      	strh	r3, [r4, #12]
   18830:	6022      	str	r2, [r4, #0]
   18832:	04db      	lsls	r3, r3, #19
   18834:	d5b9      	bpl.n	187aa <__sflush_r+0x72>
   18836:	2900      	cmp	r1, #0
   18838:	d1b7      	bne.n	187aa <__sflush_r+0x72>
   1883a:	6520      	str	r0, [r4, #80]	; 0x50
   1883c:	e7b5      	b.n	187aa <__sflush_r+0x72>
   1883e:	6be2      	ldr	r2, [r4, #60]	; 0x3c
   18840:	2a00      	cmp	r2, #0
   18842:	dd00      	ble.n	18846 <__sflush_r+0x10e>
   18844:	e78a      	b.n	1875c <__sflush_r+0x24>
   18846:	e7be      	b.n	187c6 <__sflush_r+0x8e>
   18848:	2200      	movs	r2, #0
   1884a:	2301      	movs	r3, #1
   1884c:	69e1      	ldr	r1, [r4, #28]
   1884e:	4640      	mov	r0, r8
   18850:	47b0      	blx	r6
   18852:	0002      	movs	r2, r0
   18854:	1c43      	adds	r3, r0, #1
   18856:	d002      	beq.n	1885e <__sflush_r+0x126>
   18858:	89a3      	ldrh	r3, [r4, #12]
   1885a:	6aa6      	ldr	r6, [r4, #40]	; 0x28
   1885c:	e78b      	b.n	18776 <__sflush_r+0x3e>
   1885e:	4643      	mov	r3, r8
   18860:	681b      	ldr	r3, [r3, #0]
   18862:	2b00      	cmp	r3, #0
   18864:	d0f8      	beq.n	18858 <__sflush_r+0x120>
   18866:	2b1d      	cmp	r3, #29
   18868:	d001      	beq.n	1886e <__sflush_r+0x136>
   1886a:	2b16      	cmp	r3, #22
   1886c:	d103      	bne.n	18876 <__sflush_r+0x13e>
   1886e:	4643      	mov	r3, r8
   18870:	2000      	movs	r0, #0
   18872:	601d      	str	r5, [r3, #0]
   18874:	e7a8      	b.n	187c8 <__sflush_r+0x90>
   18876:	2340      	movs	r3, #64	; 0x40
   18878:	89a1      	ldrh	r1, [r4, #12]
   1887a:	430b      	orrs	r3, r1
   1887c:	81a3      	strh	r3, [r4, #12]
   1887e:	e7a3      	b.n	187c8 <__sflush_r+0x90>
   18880:	fffff7ff 	.word	0xfffff7ff
   18884:	20400001 	.word	0x20400001

00018888 <_fflush_r>:
   18888:	b570      	push	{r4, r5, r6, lr}
   1888a:	0004      	movs	r4, r0
   1888c:	000d      	movs	r5, r1
   1888e:	2800      	cmp	r0, #0
   18890:	d002      	beq.n	18898 <_fflush_r+0x10>
   18892:	6b83      	ldr	r3, [r0, #56]	; 0x38
   18894:	2b00      	cmp	r3, #0
   18896:	d009      	beq.n	188ac <_fflush_r+0x24>
   18898:	220c      	movs	r2, #12
   1889a:	5eab      	ldrsh	r3, [r5, r2]
   1889c:	2000      	movs	r0, #0
   1889e:	2b00      	cmp	r3, #0
   188a0:	d003      	beq.n	188aa <_fflush_r+0x22>
   188a2:	0029      	movs	r1, r5
   188a4:	0020      	movs	r0, r4
   188a6:	f7ff ff47 	bl	18738 <__sflush_r>
   188aa:	bd70      	pop	{r4, r5, r6, pc}
   188ac:	f000 f906 	bl	18abc <__sinit>
   188b0:	e7f2      	b.n	18898 <_fflush_r+0x10>
   188b2:	46c0      	nop			; (mov r8, r8)

000188b4 <fflush>:
   188b4:	b510      	push	{r4, lr}
   188b6:	1e01      	subs	r1, r0, #0
   188b8:	d004      	beq.n	188c4 <fflush+0x10>
   188ba:	4b05      	ldr	r3, [pc, #20]	; (188d0 <fflush+0x1c>)
   188bc:	6818      	ldr	r0, [r3, #0]
   188be:	f7ff ffe3 	bl	18888 <_fflush_r>
   188c2:	bd10      	pop	{r4, pc}
   188c4:	4b03      	ldr	r3, [pc, #12]	; (188d4 <fflush+0x20>)
   188c6:	4904      	ldr	r1, [pc, #16]	; (188d8 <fflush+0x24>)
   188c8:	6818      	ldr	r0, [r3, #0]
   188ca:	f000 fc01 	bl	190d0 <_fwalk_reent>
   188ce:	e7f8      	b.n	188c2 <fflush+0xe>
   188d0:	10010df0 	.word	0x10010df0
   188d4:	00022d9c 	.word	0x00022d9c
   188d8:	00018889 	.word	0x00018889

000188dc <__fp_unlock>:
   188dc:	2000      	movs	r0, #0
   188de:	4770      	bx	lr

000188e0 <_cleanup_r>:
   188e0:	b510      	push	{r4, lr}
   188e2:	4902      	ldr	r1, [pc, #8]	; (188ec <_cleanup_r+0xc>)
   188e4:	f000 fbf4 	bl	190d0 <_fwalk_reent>
   188e8:	bd10      	pop	{r4, pc}
   188ea:	46c0      	nop			; (mov r8, r8)
   188ec:	0001ca21 	.word	0x0001ca21

000188f0 <__sinit.part.1>:
   188f0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   188f2:	465f      	mov	r7, fp
   188f4:	4656      	mov	r6, sl
   188f6:	464d      	mov	r5, r9
   188f8:	4644      	mov	r4, r8
   188fa:	4b34      	ldr	r3, [pc, #208]	; (189cc <__sinit.part.1+0xdc>)
   188fc:	b4f0      	push	{r4, r5, r6, r7}
   188fe:	63c3      	str	r3, [r0, #60]	; 0x3c
   18900:	23b8      	movs	r3, #184	; 0xb8
   18902:	2400      	movs	r4, #0
   18904:	2203      	movs	r2, #3
   18906:	009b      	lsls	r3, r3, #2
   18908:	50c4      	str	r4, [r0, r3]
   1890a:	3304      	adds	r3, #4
   1890c:	6845      	ldr	r5, [r0, #4]
   1890e:	50c2      	str	r2, [r0, r3]
   18910:	3308      	adds	r3, #8
   18912:	18c2      	adds	r2, r0, r3
   18914:	3b04      	subs	r3, #4
   18916:	50c2      	str	r2, [r0, r3]
   18918:	0006      	movs	r6, r0
   1891a:	2304      	movs	r3, #4
   1891c:	0028      	movs	r0, r5
   1891e:	602c      	str	r4, [r5, #0]
   18920:	606c      	str	r4, [r5, #4]
   18922:	60ac      	str	r4, [r5, #8]
   18924:	81ab      	strh	r3, [r5, #12]
   18926:	666c      	str	r4, [r5, #100]	; 0x64
   18928:	81ec      	strh	r4, [r5, #14]
   1892a:	612c      	str	r4, [r5, #16]
   1892c:	616c      	str	r4, [r5, #20]
   1892e:	61ac      	str	r4, [r5, #24]
   18930:	2208      	movs	r2, #8
   18932:	2100      	movs	r1, #0
   18934:	305c      	adds	r0, #92	; 0x5c
   18936:	f7fd f889 	bl	15a4c <memset>
   1893a:	4b25      	ldr	r3, [pc, #148]	; (189d0 <__sinit.part.1+0xe0>)
   1893c:	4f25      	ldr	r7, [pc, #148]	; (189d4 <__sinit.part.1+0xe4>)
   1893e:	469a      	mov	sl, r3
   18940:	622b      	str	r3, [r5, #32]
   18942:	4b25      	ldr	r3, [pc, #148]	; (189d8 <__sinit.part.1+0xe8>)
   18944:	62ef      	str	r7, [r5, #44]	; 0x2c
   18946:	4699      	mov	r9, r3
   18948:	626b      	str	r3, [r5, #36]	; 0x24
   1894a:	4b24      	ldr	r3, [pc, #144]	; (189dc <__sinit.part.1+0xec>)
   1894c:	61ed      	str	r5, [r5, #28]
   1894e:	62ab      	str	r3, [r5, #40]	; 0x28
   18950:	68b5      	ldr	r5, [r6, #8]
   18952:	4698      	mov	r8, r3
   18954:	2309      	movs	r3, #9
   18956:	0028      	movs	r0, r5
   18958:	81ab      	strh	r3, [r5, #12]
   1895a:	3b08      	subs	r3, #8
   1895c:	602c      	str	r4, [r5, #0]
   1895e:	606c      	str	r4, [r5, #4]
   18960:	60ac      	str	r4, [r5, #8]
   18962:	666c      	str	r4, [r5, #100]	; 0x64
   18964:	81eb      	strh	r3, [r5, #14]
   18966:	612c      	str	r4, [r5, #16]
   18968:	616c      	str	r4, [r5, #20]
   1896a:	61ac      	str	r4, [r5, #24]
   1896c:	2208      	movs	r2, #8
   1896e:	2100      	movs	r1, #0
   18970:	305c      	adds	r0, #92	; 0x5c
   18972:	469b      	mov	fp, r3
   18974:	f7fd f86a 	bl	15a4c <memset>
   18978:	4653      	mov	r3, sl
   1897a:	622b      	str	r3, [r5, #32]
   1897c:	464b      	mov	r3, r9
   1897e:	626b      	str	r3, [r5, #36]	; 0x24
   18980:	4643      	mov	r3, r8
   18982:	62ef      	str	r7, [r5, #44]	; 0x2c
   18984:	62ab      	str	r3, [r5, #40]	; 0x28
   18986:	61ed      	str	r5, [r5, #28]
   18988:	68f5      	ldr	r5, [r6, #12]
   1898a:	2312      	movs	r3, #18
   1898c:	0028      	movs	r0, r5
   1898e:	81ab      	strh	r3, [r5, #12]
   18990:	3b10      	subs	r3, #16
   18992:	81eb      	strh	r3, [r5, #14]
   18994:	602c      	str	r4, [r5, #0]
   18996:	606c      	str	r4, [r5, #4]
   18998:	60ac      	str	r4, [r5, #8]
   1899a:	666c      	str	r4, [r5, #100]	; 0x64
   1899c:	612c      	str	r4, [r5, #16]
   1899e:	616c      	str	r4, [r5, #20]
   189a0:	61ac      	str	r4, [r5, #24]
   189a2:	2208      	movs	r2, #8
   189a4:	2100      	movs	r1, #0
   189a6:	305c      	adds	r0, #92	; 0x5c
   189a8:	f7fd f850 	bl	15a4c <memset>
   189ac:	4653      	mov	r3, sl
   189ae:	622b      	str	r3, [r5, #32]
   189b0:	464b      	mov	r3, r9
   189b2:	626b      	str	r3, [r5, #36]	; 0x24
   189b4:	4643      	mov	r3, r8
   189b6:	62ab      	str	r3, [r5, #40]	; 0x28
   189b8:	465b      	mov	r3, fp
   189ba:	62ef      	str	r7, [r5, #44]	; 0x2c
   189bc:	61ed      	str	r5, [r5, #28]
   189be:	63b3      	str	r3, [r6, #56]	; 0x38
   189c0:	bc3c      	pop	{r2, r3, r4, r5}
   189c2:	4690      	mov	r8, r2
   189c4:	4699      	mov	r9, r3
   189c6:	46a2      	mov	sl, r4
   189c8:	46ab      	mov	fp, r5
   189ca:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   189cc:	000188e1 	.word	0x000188e1
   189d0:	0001a179 	.word	0x0001a179
   189d4:	0001a20d 	.word	0x0001a20d
   189d8:	0001a1a5 	.word	0x0001a1a5
   189dc:	0001a1e1 	.word	0x0001a1e1

000189e0 <__fp_lock>:
   189e0:	2000      	movs	r0, #0
   189e2:	4770      	bx	lr

000189e4 <__sfmoreglue>:
   189e4:	2368      	movs	r3, #104	; 0x68
   189e6:	b570      	push	{r4, r5, r6, lr}
   189e8:	1e4c      	subs	r4, r1, #1
   189ea:	435c      	muls	r4, r3
   189ec:	000e      	movs	r6, r1
   189ee:	0021      	movs	r1, r4
   189f0:	3174      	adds	r1, #116	; 0x74
   189f2:	f7fc fd1b 	bl	1542c <_malloc_r>
   189f6:	1e05      	subs	r5, r0, #0
   189f8:	d009      	beq.n	18a0e <__sfmoreglue+0x2a>
   189fa:	2300      	movs	r3, #0
   189fc:	0022      	movs	r2, r4
   189fe:	6003      	str	r3, [r0, #0]
   18a00:	6046      	str	r6, [r0, #4]
   18a02:	300c      	adds	r0, #12
   18a04:	60a8      	str	r0, [r5, #8]
   18a06:	3268      	adds	r2, #104	; 0x68
   18a08:	2100      	movs	r1, #0
   18a0a:	f7fd f81f 	bl	15a4c <memset>
   18a0e:	0028      	movs	r0, r5
   18a10:	bd70      	pop	{r4, r5, r6, pc}
   18a12:	46c0      	nop			; (mov r8, r8)

00018a14 <__sfp>:
   18a14:	4b22      	ldr	r3, [pc, #136]	; (18aa0 <__sfp+0x8c>)
   18a16:	b570      	push	{r4, r5, r6, lr}
   18a18:	681d      	ldr	r5, [r3, #0]
   18a1a:	0006      	movs	r6, r0
   18a1c:	6bab      	ldr	r3, [r5, #56]	; 0x38
   18a1e:	2b00      	cmp	r3, #0
   18a20:	d102      	bne.n	18a28 <__sfp+0x14>
   18a22:	0028      	movs	r0, r5
   18a24:	f7ff ff64 	bl	188f0 <__sinit.part.1>
   18a28:	23b8      	movs	r3, #184	; 0xb8
   18a2a:	009b      	lsls	r3, r3, #2
   18a2c:	469c      	mov	ip, r3
   18a2e:	4465      	add	r5, ip
   18a30:	686b      	ldr	r3, [r5, #4]
   18a32:	68ac      	ldr	r4, [r5, #8]
   18a34:	3b01      	subs	r3, #1
   18a36:	d503      	bpl.n	18a40 <__sfp+0x2c>
   18a38:	e01f      	b.n	18a7a <__sfp+0x66>
   18a3a:	3468      	adds	r4, #104	; 0x68
   18a3c:	3b01      	subs	r3, #1
   18a3e:	d31c      	bcc.n	18a7a <__sfp+0x66>
   18a40:	210c      	movs	r1, #12
   18a42:	5e62      	ldrsh	r2, [r4, r1]
   18a44:	2a00      	cmp	r2, #0
   18a46:	d1f8      	bne.n	18a3a <__sfp+0x26>
   18a48:	2301      	movs	r3, #1
   18a4a:	2500      	movs	r5, #0
   18a4c:	0020      	movs	r0, r4
   18a4e:	425b      	negs	r3, r3
   18a50:	81e3      	strh	r3, [r4, #14]
   18a52:	3302      	adds	r3, #2
   18a54:	81a3      	strh	r3, [r4, #12]
   18a56:	6665      	str	r5, [r4, #100]	; 0x64
   18a58:	6025      	str	r5, [r4, #0]
   18a5a:	60a5      	str	r5, [r4, #8]
   18a5c:	6065      	str	r5, [r4, #4]
   18a5e:	6125      	str	r5, [r4, #16]
   18a60:	6165      	str	r5, [r4, #20]
   18a62:	61a5      	str	r5, [r4, #24]
   18a64:	305c      	adds	r0, #92	; 0x5c
   18a66:	2208      	movs	r2, #8
   18a68:	2100      	movs	r1, #0
   18a6a:	f7fc ffef 	bl	15a4c <memset>
   18a6e:	0020      	movs	r0, r4
   18a70:	6325      	str	r5, [r4, #48]	; 0x30
   18a72:	6365      	str	r5, [r4, #52]	; 0x34
   18a74:	6465      	str	r5, [r4, #68]	; 0x44
   18a76:	64a5      	str	r5, [r4, #72]	; 0x48
   18a78:	bd70      	pop	{r4, r5, r6, pc}
   18a7a:	682b      	ldr	r3, [r5, #0]
   18a7c:	2b00      	cmp	r3, #0
   18a7e:	d001      	beq.n	18a84 <__sfp+0x70>
   18a80:	001d      	movs	r5, r3
   18a82:	e7d5      	b.n	18a30 <__sfp+0x1c>
   18a84:	2104      	movs	r1, #4
   18a86:	0030      	movs	r0, r6
   18a88:	f7ff ffac 	bl	189e4 <__sfmoreglue>
   18a8c:	6028      	str	r0, [r5, #0]
   18a8e:	2800      	cmp	r0, #0
   18a90:	d001      	beq.n	18a96 <__sfp+0x82>
   18a92:	0005      	movs	r5, r0
   18a94:	e7cc      	b.n	18a30 <__sfp+0x1c>
   18a96:	230c      	movs	r3, #12
   18a98:	2000      	movs	r0, #0
   18a9a:	6033      	str	r3, [r6, #0]
   18a9c:	e7ec      	b.n	18a78 <__sfp+0x64>
   18a9e:	46c0      	nop			; (mov r8, r8)
   18aa0:	00022d9c 	.word	0x00022d9c

00018aa4 <_cleanup>:
   18aa4:	b510      	push	{r4, lr}
   18aa6:	4b03      	ldr	r3, [pc, #12]	; (18ab4 <_cleanup+0x10>)
   18aa8:	4903      	ldr	r1, [pc, #12]	; (18ab8 <_cleanup+0x14>)
   18aaa:	6818      	ldr	r0, [r3, #0]
   18aac:	f000 fb10 	bl	190d0 <_fwalk_reent>
   18ab0:	bd10      	pop	{r4, pc}
   18ab2:	46c0      	nop			; (mov r8, r8)
   18ab4:	00022d9c 	.word	0x00022d9c
   18ab8:	0001ca21 	.word	0x0001ca21

00018abc <__sinit>:
   18abc:	6b83      	ldr	r3, [r0, #56]	; 0x38
   18abe:	b510      	push	{r4, lr}
   18ac0:	2b00      	cmp	r3, #0
   18ac2:	d101      	bne.n	18ac8 <__sinit+0xc>
   18ac4:	f7ff ff14 	bl	188f0 <__sinit.part.1>
   18ac8:	bd10      	pop	{r4, pc}
   18aca:	46c0      	nop			; (mov r8, r8)

00018acc <__sfp_lock_acquire>:
   18acc:	4770      	bx	lr
   18ace:	46c0      	nop			; (mov r8, r8)

00018ad0 <__sfp_lock_release>:
   18ad0:	4770      	bx	lr
   18ad2:	46c0      	nop			; (mov r8, r8)

00018ad4 <__sinit_lock_acquire>:
   18ad4:	4770      	bx	lr
   18ad6:	46c0      	nop			; (mov r8, r8)

00018ad8 <__sinit_lock_release>:
   18ad8:	4770      	bx	lr
   18ada:	46c0      	nop			; (mov r8, r8)

00018adc <__fp_lock_all>:
   18adc:	b510      	push	{r4, lr}
   18ade:	4b03      	ldr	r3, [pc, #12]	; (18aec <__fp_lock_all+0x10>)
   18ae0:	4903      	ldr	r1, [pc, #12]	; (18af0 <__fp_lock_all+0x14>)
   18ae2:	6818      	ldr	r0, [r3, #0]
   18ae4:	f000 fad2 	bl	1908c <_fwalk>
   18ae8:	bd10      	pop	{r4, pc}
   18aea:	46c0      	nop			; (mov r8, r8)
   18aec:	10010df0 	.word	0x10010df0
   18af0:	000189e1 	.word	0x000189e1

00018af4 <__fp_unlock_all>:
   18af4:	b510      	push	{r4, lr}
   18af6:	4b03      	ldr	r3, [pc, #12]	; (18b04 <__fp_unlock_all+0x10>)
   18af8:	4903      	ldr	r1, [pc, #12]	; (18b08 <__fp_unlock_all+0x14>)
   18afa:	6818      	ldr	r0, [r3, #0]
   18afc:	f000 fac6 	bl	1908c <_fwalk>
   18b00:	bd10      	pop	{r4, pc}
   18b02:	46c0      	nop			; (mov r8, r8)
   18b04:	10010df0 	.word	0x10010df0
   18b08:	000188dd 	.word	0x000188dd

00018b0c <_malloc_trim_r>:
   18b0c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   18b0e:	000c      	movs	r4, r1
   18b10:	0006      	movs	r6, r0
   18b12:	f7fc ffe1 	bl	15ad8 <__malloc_lock>
   18b16:	4f20      	ldr	r7, [pc, #128]	; (18b98 <_malloc_trim_r+0x8c>)
   18b18:	68bb      	ldr	r3, [r7, #8]
   18b1a:	685d      	ldr	r5, [r3, #4]
   18b1c:	2303      	movs	r3, #3
   18b1e:	439d      	bics	r5, r3
   18b20:	4b1e      	ldr	r3, [pc, #120]	; (18b9c <_malloc_trim_r+0x90>)
   18b22:	1b2c      	subs	r4, r5, r4
   18b24:	469c      	mov	ip, r3
   18b26:	4464      	add	r4, ip
   18b28:	0b24      	lsrs	r4, r4, #12
   18b2a:	4b1d      	ldr	r3, [pc, #116]	; (18ba0 <_malloc_trim_r+0x94>)
   18b2c:	3c01      	subs	r4, #1
   18b2e:	0324      	lsls	r4, r4, #12
   18b30:	429c      	cmp	r4, r3
   18b32:	dd07      	ble.n	18b44 <_malloc_trim_r+0x38>
   18b34:	2100      	movs	r1, #0
   18b36:	0030      	movs	r0, r6
   18b38:	f7fd f858 	bl	15bec <_sbrk_r>
   18b3c:	68bb      	ldr	r3, [r7, #8]
   18b3e:	195b      	adds	r3, r3, r5
   18b40:	4298      	cmp	r0, r3
   18b42:	d004      	beq.n	18b4e <_malloc_trim_r+0x42>
   18b44:	0030      	movs	r0, r6
   18b46:	f7fc ffc9 	bl	15adc <__malloc_unlock>
   18b4a:	2000      	movs	r0, #0
   18b4c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   18b4e:	4261      	negs	r1, r4
   18b50:	0030      	movs	r0, r6
   18b52:	f7fd f84b 	bl	15bec <_sbrk_r>
   18b56:	1c43      	adds	r3, r0, #1
   18b58:	d00d      	beq.n	18b76 <_malloc_trim_r+0x6a>
   18b5a:	2301      	movs	r3, #1
   18b5c:	1b2d      	subs	r5, r5, r4
   18b5e:	68ba      	ldr	r2, [r7, #8]
   18b60:	431d      	orrs	r5, r3
   18b62:	4b10      	ldr	r3, [pc, #64]	; (18ba4 <_malloc_trim_r+0x98>)
   18b64:	6055      	str	r5, [r2, #4]
   18b66:	681a      	ldr	r2, [r3, #0]
   18b68:	0030      	movs	r0, r6
   18b6a:	1b14      	subs	r4, r2, r4
   18b6c:	601c      	str	r4, [r3, #0]
   18b6e:	f7fc ffb5 	bl	15adc <__malloc_unlock>
   18b72:	2001      	movs	r0, #1
   18b74:	e7ea      	b.n	18b4c <_malloc_trim_r+0x40>
   18b76:	2100      	movs	r1, #0
   18b78:	0030      	movs	r0, r6
   18b7a:	f7fd f837 	bl	15bec <_sbrk_r>
   18b7e:	68bb      	ldr	r3, [r7, #8]
   18b80:	1ac2      	subs	r2, r0, r3
   18b82:	2a0f      	cmp	r2, #15
   18b84:	ddde      	ble.n	18b44 <_malloc_trim_r+0x38>
   18b86:	4908      	ldr	r1, [pc, #32]	; (18ba8 <_malloc_trim_r+0x9c>)
   18b88:	6809      	ldr	r1, [r1, #0]
   18b8a:	1a40      	subs	r0, r0, r1
   18b8c:	4905      	ldr	r1, [pc, #20]	; (18ba4 <_malloc_trim_r+0x98>)
   18b8e:	6008      	str	r0, [r1, #0]
   18b90:	2101      	movs	r1, #1
   18b92:	430a      	orrs	r2, r1
   18b94:	605a      	str	r2, [r3, #4]
   18b96:	e7d5      	b.n	18b44 <_malloc_trim_r+0x38>
   18b98:	100105b8 	.word	0x100105b8
   18b9c:	00000fef 	.word	0x00000fef
   18ba0:	00000fff 	.word	0x00000fff
   18ba4:	100126e4 	.word	0x100126e4
   18ba8:	100109c4 	.word	0x100109c4

00018bac <_free_r>:
   18bac:	b5f0      	push	{r4, r5, r6, r7, lr}
   18bae:	4647      	mov	r7, r8
   18bb0:	0005      	movs	r5, r0
   18bb2:	b480      	push	{r7}
   18bb4:	1e0c      	subs	r4, r1, #0
   18bb6:	d03e      	beq.n	18c36 <_free_r+0x8a>
   18bb8:	f7fc ff8e 	bl	15ad8 <__malloc_lock>
   18bbc:	2301      	movs	r3, #1
   18bbe:	0021      	movs	r1, r4
   18bc0:	4698      	mov	r8, r3
   18bc2:	3908      	subs	r1, #8
   18bc4:	684e      	ldr	r6, [r1, #4]
   18bc6:	4642      	mov	r2, r8
   18bc8:	0033      	movs	r3, r6
   18bca:	2003      	movs	r0, #3
   18bcc:	4393      	bics	r3, r2
   18bce:	18cc      	adds	r4, r1, r3
   18bd0:	6862      	ldr	r2, [r4, #4]
   18bd2:	4382      	bics	r2, r0
   18bd4:	4860      	ldr	r0, [pc, #384]	; (18d58 <_free_r+0x1ac>)
   18bd6:	6887      	ldr	r7, [r0, #8]
   18bd8:	42bc      	cmp	r4, r7
   18bda:	d05a      	beq.n	18c92 <_free_r+0xe6>
   18bdc:	4647      	mov	r7, r8
   18bde:	6062      	str	r2, [r4, #4]
   18be0:	4237      	tst	r7, r6
   18be2:	d10b      	bne.n	18bfc <_free_r+0x50>
   18be4:	2708      	movs	r7, #8
   18be6:	46bc      	mov	ip, r7
   18be8:	680e      	ldr	r6, [r1, #0]
   18bea:	4484      	add	ip, r0
   18bec:	1b89      	subs	r1, r1, r6
   18bee:	199b      	adds	r3, r3, r6
   18bf0:	688e      	ldr	r6, [r1, #8]
   18bf2:	4566      	cmp	r6, ip
   18bf4:	d066      	beq.n	18cc4 <_free_r+0x118>
   18bf6:	68cf      	ldr	r7, [r1, #12]
   18bf8:	60f7      	str	r7, [r6, #12]
   18bfa:	60be      	str	r6, [r7, #8]
   18bfc:	2601      	movs	r6, #1
   18bfe:	18a7      	adds	r7, r4, r2
   18c00:	687f      	ldr	r7, [r7, #4]
   18c02:	4237      	tst	r7, r6
   18c04:	d036      	beq.n	18c74 <_free_r+0xc8>
   18c06:	4a55      	ldr	r2, [pc, #340]	; (18d5c <_free_r+0x1b0>)
   18c08:	431e      	orrs	r6, r3
   18c0a:	604e      	str	r6, [r1, #4]
   18c0c:	50cb      	str	r3, [r1, r3]
   18c0e:	4293      	cmp	r3, r2
   18c10:	d814      	bhi.n	18c3c <_free_r+0x90>
   18c12:	08db      	lsrs	r3, r3, #3
   18c14:	3aff      	subs	r2, #255	; 0xff
   18c16:	109c      	asrs	r4, r3, #2
   18c18:	3aff      	subs	r2, #255	; 0xff
   18c1a:	40a2      	lsls	r2, r4
   18c1c:	6844      	ldr	r4, [r0, #4]
   18c1e:	00db      	lsls	r3, r3, #3
   18c20:	4322      	orrs	r2, r4
   18c22:	6042      	str	r2, [r0, #4]
   18c24:	1818      	adds	r0, r3, r0
   18c26:	6883      	ldr	r3, [r0, #8]
   18c28:	60c8      	str	r0, [r1, #12]
   18c2a:	608b      	str	r3, [r1, #8]
   18c2c:	6081      	str	r1, [r0, #8]
   18c2e:	60d9      	str	r1, [r3, #12]
   18c30:	0028      	movs	r0, r5
   18c32:	f7fc ff53 	bl	15adc <__malloc_unlock>
   18c36:	bc04      	pop	{r2}
   18c38:	4690      	mov	r8, r2
   18c3a:	bdf0      	pop	{r4, r5, r6, r7, pc}
   18c3c:	0a5a      	lsrs	r2, r3, #9
   18c3e:	2a04      	cmp	r2, #4
   18c40:	d84f      	bhi.n	18ce2 <_free_r+0x136>
   18c42:	099c      	lsrs	r4, r3, #6
   18c44:	0026      	movs	r6, r4
   18c46:	3439      	adds	r4, #57	; 0x39
   18c48:	3638      	adds	r6, #56	; 0x38
   18c4a:	0064      	lsls	r4, r4, #1
   18c4c:	00a4      	lsls	r4, r4, #2
   18c4e:	1904      	adds	r4, r0, r4
   18c50:	3c08      	subs	r4, #8
   18c52:	68a2      	ldr	r2, [r4, #8]
   18c54:	2703      	movs	r7, #3
   18c56:	4294      	cmp	r4, r2
   18c58:	d04a      	beq.n	18cf0 <_free_r+0x144>
   18c5a:	6850      	ldr	r0, [r2, #4]
   18c5c:	43b8      	bics	r0, r7
   18c5e:	4283      	cmp	r3, r0
   18c60:	d202      	bcs.n	18c68 <_free_r+0xbc>
   18c62:	6892      	ldr	r2, [r2, #8]
   18c64:	4294      	cmp	r4, r2
   18c66:	d1f8      	bne.n	18c5a <_free_r+0xae>
   18c68:	68d4      	ldr	r4, [r2, #12]
   18c6a:	60cc      	str	r4, [r1, #12]
   18c6c:	608a      	str	r2, [r1, #8]
   18c6e:	60a1      	str	r1, [r4, #8]
   18c70:	60d1      	str	r1, [r2, #12]
   18c72:	e7dd      	b.n	18c30 <_free_r+0x84>
   18c74:	189b      	adds	r3, r3, r2
   18c76:	4f3a      	ldr	r7, [pc, #232]	; (18d60 <_free_r+0x1b4>)
   18c78:	68a2      	ldr	r2, [r4, #8]
   18c7a:	42ba      	cmp	r2, r7
   18c7c:	d040      	beq.n	18d00 <_free_r+0x154>
   18c7e:	68e4      	ldr	r4, [r4, #12]
   18c80:	431e      	orrs	r6, r3
   18c82:	60d4      	str	r4, [r2, #12]
   18c84:	60a2      	str	r2, [r4, #8]
   18c86:	4a35      	ldr	r2, [pc, #212]	; (18d5c <_free_r+0x1b0>)
   18c88:	604e      	str	r6, [r1, #4]
   18c8a:	50cb      	str	r3, [r1, r3]
   18c8c:	4293      	cmp	r3, r2
   18c8e:	d8d5      	bhi.n	18c3c <_free_r+0x90>
   18c90:	e7bf      	b.n	18c12 <_free_r+0x66>
   18c92:	189b      	adds	r3, r3, r2
   18c94:	4642      	mov	r2, r8
   18c96:	4232      	tst	r2, r6
   18c98:	d106      	bne.n	18ca8 <_free_r+0xfc>
   18c9a:	680a      	ldr	r2, [r1, #0]
   18c9c:	1a89      	subs	r1, r1, r2
   18c9e:	688c      	ldr	r4, [r1, #8]
   18ca0:	189b      	adds	r3, r3, r2
   18ca2:	68ca      	ldr	r2, [r1, #12]
   18ca4:	60e2      	str	r2, [r4, #12]
   18ca6:	6094      	str	r4, [r2, #8]
   18ca8:	2401      	movs	r4, #1
   18caa:	4a2e      	ldr	r2, [pc, #184]	; (18d64 <_free_r+0x1b8>)
   18cac:	431c      	orrs	r4, r3
   18cae:	6812      	ldr	r2, [r2, #0]
   18cb0:	604c      	str	r4, [r1, #4]
   18cb2:	6081      	str	r1, [r0, #8]
   18cb4:	4293      	cmp	r3, r2
   18cb6:	d3bb      	bcc.n	18c30 <_free_r+0x84>
   18cb8:	4b2b      	ldr	r3, [pc, #172]	; (18d68 <_free_r+0x1bc>)
   18cba:	0028      	movs	r0, r5
   18cbc:	6819      	ldr	r1, [r3, #0]
   18cbe:	f7ff ff25 	bl	18b0c <_malloc_trim_r>
   18cc2:	e7b5      	b.n	18c30 <_free_r+0x84>
   18cc4:	4646      	mov	r6, r8
   18cc6:	18a0      	adds	r0, r4, r2
   18cc8:	6840      	ldr	r0, [r0, #4]
   18cca:	4230      	tst	r0, r6
   18ccc:	d13e      	bne.n	18d4c <_free_r+0x1a0>
   18cce:	68a0      	ldr	r0, [r4, #8]
   18cd0:	18d3      	adds	r3, r2, r3
   18cd2:	68e2      	ldr	r2, [r4, #12]
   18cd4:	60c2      	str	r2, [r0, #12]
   18cd6:	6090      	str	r0, [r2, #8]
   18cd8:	4642      	mov	r2, r8
   18cda:	431a      	orrs	r2, r3
   18cdc:	604a      	str	r2, [r1, #4]
   18cde:	50cb      	str	r3, [r1, r3]
   18ce0:	e7a6      	b.n	18c30 <_free_r+0x84>
   18ce2:	2a14      	cmp	r2, #20
   18ce4:	d814      	bhi.n	18d10 <_free_r+0x164>
   18ce6:	0016      	movs	r6, r2
   18ce8:	325c      	adds	r2, #92	; 0x5c
   18cea:	365b      	adds	r6, #91	; 0x5b
   18cec:	0054      	lsls	r4, r2, #1
   18cee:	e7ad      	b.n	18c4c <_free_r+0xa0>
   18cf0:	2301      	movs	r3, #1
   18cf2:	10b6      	asrs	r6, r6, #2
   18cf4:	40b3      	lsls	r3, r6
   18cf6:	6842      	ldr	r2, [r0, #4]
   18cf8:	4313      	orrs	r3, r2
   18cfa:	6043      	str	r3, [r0, #4]
   18cfc:	0022      	movs	r2, r4
   18cfe:	e7b4      	b.n	18c6a <_free_r+0xbe>
   18d00:	431e      	orrs	r6, r3
   18d02:	60d1      	str	r1, [r2, #12]
   18d04:	6091      	str	r1, [r2, #8]
   18d06:	60ca      	str	r2, [r1, #12]
   18d08:	608a      	str	r2, [r1, #8]
   18d0a:	604e      	str	r6, [r1, #4]
   18d0c:	50cb      	str	r3, [r1, r3]
   18d0e:	e78f      	b.n	18c30 <_free_r+0x84>
   18d10:	2a54      	cmp	r2, #84	; 0x54
   18d12:	d805      	bhi.n	18d20 <_free_r+0x174>
   18d14:	0b1c      	lsrs	r4, r3, #12
   18d16:	0026      	movs	r6, r4
   18d18:	346f      	adds	r4, #111	; 0x6f
   18d1a:	366e      	adds	r6, #110	; 0x6e
   18d1c:	0064      	lsls	r4, r4, #1
   18d1e:	e795      	b.n	18c4c <_free_r+0xa0>
   18d20:	24aa      	movs	r4, #170	; 0xaa
   18d22:	0064      	lsls	r4, r4, #1
   18d24:	42a2      	cmp	r2, r4
   18d26:	d805      	bhi.n	18d34 <_free_r+0x188>
   18d28:	0bdc      	lsrs	r4, r3, #15
   18d2a:	0026      	movs	r6, r4
   18d2c:	3478      	adds	r4, #120	; 0x78
   18d2e:	3677      	adds	r6, #119	; 0x77
   18d30:	0064      	lsls	r4, r4, #1
   18d32:	e78b      	b.n	18c4c <_free_r+0xa0>
   18d34:	4c0d      	ldr	r4, [pc, #52]	; (18d6c <_free_r+0x1c0>)
   18d36:	42a2      	cmp	r2, r4
   18d38:	d805      	bhi.n	18d46 <_free_r+0x19a>
   18d3a:	0c9c      	lsrs	r4, r3, #18
   18d3c:	0026      	movs	r6, r4
   18d3e:	347d      	adds	r4, #125	; 0x7d
   18d40:	367c      	adds	r6, #124	; 0x7c
   18d42:	0064      	lsls	r4, r4, #1
   18d44:	e782      	b.n	18c4c <_free_r+0xa0>
   18d46:	24fe      	movs	r4, #254	; 0xfe
   18d48:	267e      	movs	r6, #126	; 0x7e
   18d4a:	e77f      	b.n	18c4c <_free_r+0xa0>
   18d4c:	4642      	mov	r2, r8
   18d4e:	431a      	orrs	r2, r3
   18d50:	604a      	str	r2, [r1, #4]
   18d52:	50cb      	str	r3, [r1, r3]
   18d54:	e76c      	b.n	18c30 <_free_r+0x84>
   18d56:	46c0      	nop			; (mov r8, r8)
   18d58:	100105b8 	.word	0x100105b8
   18d5c:	000001ff 	.word	0x000001ff
   18d60:	100105c0 	.word	0x100105c0
   18d64:	100109c0 	.word	0x100109c0
   18d68:	100126e0 	.word	0x100126e0
   18d6c:	00000554 	.word	0x00000554

00018d70 <__sfvwrite_r>:
   18d70:	b5f0      	push	{r4, r5, r6, r7, lr}
   18d72:	4656      	mov	r6, sl
   18d74:	4644      	mov	r4, r8
   18d76:	465f      	mov	r7, fp
   18d78:	464d      	mov	r5, r9
   18d7a:	b4f0      	push	{r4, r5, r6, r7}
   18d7c:	6893      	ldr	r3, [r2, #8]
   18d7e:	b085      	sub	sp, #20
   18d80:	9001      	str	r0, [sp, #4]
   18d82:	000c      	movs	r4, r1
   18d84:	4692      	mov	sl, r2
   18d86:	2b00      	cmp	r3, #0
   18d88:	d025      	beq.n	18dd6 <__sfvwrite_r+0x66>
   18d8a:	898b      	ldrh	r3, [r1, #12]
   18d8c:	071a      	lsls	r2, r3, #28
   18d8e:	d52a      	bpl.n	18de6 <__sfvwrite_r+0x76>
   18d90:	690a      	ldr	r2, [r1, #16]
   18d92:	2a00      	cmp	r2, #0
   18d94:	d027      	beq.n	18de6 <__sfvwrite_r+0x76>
   18d96:	4652      	mov	r2, sl
   18d98:	6812      	ldr	r2, [r2, #0]
   18d9a:	4693      	mov	fp, r2
   18d9c:	079a      	lsls	r2, r3, #30
   18d9e:	d52f      	bpl.n	18e00 <__sfvwrite_r+0x90>
   18da0:	4bb7      	ldr	r3, [pc, #732]	; (19080 <__sfvwrite_r+0x310>)
   18da2:	2600      	movs	r6, #0
   18da4:	2500      	movs	r5, #0
   18da6:	4698      	mov	r8, r3
   18da8:	2d00      	cmp	r5, #0
   18daa:	d100      	bne.n	18dae <__sfvwrite_r+0x3e>
   18dac:	e06d      	b.n	18e8a <__sfvwrite_r+0x11a>
   18dae:	002b      	movs	r3, r5
   18db0:	4545      	cmp	r5, r8
   18db2:	d900      	bls.n	18db6 <__sfvwrite_r+0x46>
   18db4:	4bb2      	ldr	r3, [pc, #712]	; (19080 <__sfvwrite_r+0x310>)
   18db6:	0032      	movs	r2, r6
   18db8:	69e1      	ldr	r1, [r4, #28]
   18dba:	9801      	ldr	r0, [sp, #4]
   18dbc:	6a67      	ldr	r7, [r4, #36]	; 0x24
   18dbe:	47b8      	blx	r7
   18dc0:	2800      	cmp	r0, #0
   18dc2:	dc00      	bgt.n	18dc6 <__sfvwrite_r+0x56>
   18dc4:	e079      	b.n	18eba <__sfvwrite_r+0x14a>
   18dc6:	4653      	mov	r3, sl
   18dc8:	689b      	ldr	r3, [r3, #8]
   18dca:	1836      	adds	r6, r6, r0
   18dcc:	1a2d      	subs	r5, r5, r0
   18dce:	1a18      	subs	r0, r3, r0
   18dd0:	4653      	mov	r3, sl
   18dd2:	6098      	str	r0, [r3, #8]
   18dd4:	d1e8      	bne.n	18da8 <__sfvwrite_r+0x38>
   18dd6:	2000      	movs	r0, #0
   18dd8:	b005      	add	sp, #20
   18dda:	bc3c      	pop	{r2, r3, r4, r5}
   18ddc:	4690      	mov	r8, r2
   18dde:	4699      	mov	r9, r3
   18de0:	46a2      	mov	sl, r4
   18de2:	46ab      	mov	fp, r5
   18de4:	bdf0      	pop	{r4, r5, r6, r7, pc}
   18de6:	0021      	movs	r1, r4
   18de8:	9801      	ldr	r0, [sp, #4]
   18dea:	f7fe fbe9 	bl	175c0 <__swsetup_r>
   18dee:	2800      	cmp	r0, #0
   18df0:	d000      	beq.n	18df4 <__sfvwrite_r+0x84>
   18df2:	e13b      	b.n	1906c <__sfvwrite_r+0x2fc>
   18df4:	4652      	mov	r2, sl
   18df6:	89a3      	ldrh	r3, [r4, #12]
   18df8:	6812      	ldr	r2, [r2, #0]
   18dfa:	4693      	mov	fp, r2
   18dfc:	079a      	lsls	r2, r3, #30
   18dfe:	d4cf      	bmi.n	18da0 <__sfvwrite_r+0x30>
   18e00:	07da      	lsls	r2, r3, #31
   18e02:	d562      	bpl.n	18eca <__sfvwrite_r+0x15a>
   18e04:	2300      	movs	r3, #0
   18e06:	2700      	movs	r7, #0
   18e08:	4699      	mov	r9, r3
   18e0a:	001d      	movs	r5, r3
   18e0c:	9302      	str	r3, [sp, #8]
   18e0e:	2f00      	cmp	r7, #0
   18e10:	d030      	beq.n	18e74 <__sfvwrite_r+0x104>
   18e12:	9b02      	ldr	r3, [sp, #8]
   18e14:	2b00      	cmp	r3, #0
   18e16:	d100      	bne.n	18e1a <__sfvwrite_r+0xaa>
   18e18:	e0c3      	b.n	18fa2 <__sfvwrite_r+0x232>
   18e1a:	002e      	movs	r6, r5
   18e1c:	42bd      	cmp	r5, r7
   18e1e:	d900      	bls.n	18e22 <__sfvwrite_r+0xb2>
   18e20:	003e      	movs	r6, r7
   18e22:	6820      	ldr	r0, [r4, #0]
   18e24:	6922      	ldr	r2, [r4, #16]
   18e26:	46b0      	mov	r8, r6
   18e28:	6963      	ldr	r3, [r4, #20]
   18e2a:	4290      	cmp	r0, r2
   18e2c:	d907      	bls.n	18e3e <__sfvwrite_r+0xce>
   18e2e:	68a2      	ldr	r2, [r4, #8]
   18e30:	4694      	mov	ip, r2
   18e32:	449c      	add	ip, r3
   18e34:	4662      	mov	r2, ip
   18e36:	9203      	str	r2, [sp, #12]
   18e38:	4566      	cmp	r6, ip
   18e3a:	dd00      	ble.n	18e3e <__sfvwrite_r+0xce>
   18e3c:	e0ef      	b.n	1901e <__sfvwrite_r+0x2ae>
   18e3e:	429e      	cmp	r6, r3
   18e40:	da00      	bge.n	18e44 <__sfvwrite_r+0xd4>
   18e42:	e092      	b.n	18f6a <__sfvwrite_r+0x1fa>
   18e44:	464a      	mov	r2, r9
   18e46:	69e1      	ldr	r1, [r4, #28]
   18e48:	9801      	ldr	r0, [sp, #4]
   18e4a:	6a66      	ldr	r6, [r4, #36]	; 0x24
   18e4c:	47b0      	blx	r6
   18e4e:	4680      	mov	r8, r0
   18e50:	2800      	cmp	r0, #0
   18e52:	dd32      	ble.n	18eba <__sfvwrite_r+0x14a>
   18e54:	4643      	mov	r3, r8
   18e56:	1aed      	subs	r5, r5, r3
   18e58:	d100      	bne.n	18e5c <__sfvwrite_r+0xec>
   18e5a:	e095      	b.n	18f88 <__sfvwrite_r+0x218>
   18e5c:	4643      	mov	r3, r8
   18e5e:	1aff      	subs	r7, r7, r3
   18e60:	4653      	mov	r3, sl
   18e62:	4642      	mov	r2, r8
   18e64:	689b      	ldr	r3, [r3, #8]
   18e66:	44c1      	add	r9, r8
   18e68:	1a9b      	subs	r3, r3, r2
   18e6a:	4652      	mov	r2, sl
   18e6c:	6093      	str	r3, [r2, #8]
   18e6e:	d0b2      	beq.n	18dd6 <__sfvwrite_r+0x66>
   18e70:	2f00      	cmp	r7, #0
   18e72:	d1ce      	bne.n	18e12 <__sfvwrite_r+0xa2>
   18e74:	465b      	mov	r3, fp
   18e76:	681b      	ldr	r3, [r3, #0]
   18e78:	4699      	mov	r9, r3
   18e7a:	465b      	mov	r3, fp
   18e7c:	685f      	ldr	r7, [r3, #4]
   18e7e:	2308      	movs	r3, #8
   18e80:	469c      	mov	ip, r3
   18e82:	2300      	movs	r3, #0
   18e84:	44e3      	add	fp, ip
   18e86:	9302      	str	r3, [sp, #8]
   18e88:	e7c1      	b.n	18e0e <__sfvwrite_r+0x9e>
   18e8a:	465b      	mov	r3, fp
   18e8c:	681e      	ldr	r6, [r3, #0]
   18e8e:	685d      	ldr	r5, [r3, #4]
   18e90:	2308      	movs	r3, #8
   18e92:	469c      	mov	ip, r3
   18e94:	44e3      	add	fp, ip
   18e96:	e787      	b.n	18da8 <__sfvwrite_r+0x38>
   18e98:	4b7a      	ldr	r3, [pc, #488]	; (19084 <__sfvwrite_r+0x314>)
   18e9a:	0030      	movs	r0, r6
   18e9c:	429e      	cmp	r6, r3
   18e9e:	d900      	bls.n	18ea2 <__sfvwrite_r+0x132>
   18ea0:	0018      	movs	r0, r3
   18ea2:	4641      	mov	r1, r8
   18ea4:	f7eb f9fb 	bl	429e <__aeabi_idiv>
   18ea8:	4643      	mov	r3, r8
   18eaa:	003a      	movs	r2, r7
   18eac:	4343      	muls	r3, r0
   18eae:	69e1      	ldr	r1, [r4, #28]
   18eb0:	9801      	ldr	r0, [sp, #4]
   18eb2:	6a65      	ldr	r5, [r4, #36]	; 0x24
   18eb4:	47a8      	blx	r5
   18eb6:	2800      	cmp	r0, #0
   18eb8:	dc23      	bgt.n	18f02 <__sfvwrite_r+0x192>
   18eba:	230c      	movs	r3, #12
   18ebc:	5ee2      	ldrsh	r2, [r4, r3]
   18ebe:	2340      	movs	r3, #64	; 0x40
   18ec0:	2001      	movs	r0, #1
   18ec2:	4313      	orrs	r3, r2
   18ec4:	81a3      	strh	r3, [r4, #12]
   18ec6:	4240      	negs	r0, r0
   18ec8:	e786      	b.n	18dd8 <__sfvwrite_r+0x68>
   18eca:	2700      	movs	r7, #0
   18ecc:	2600      	movs	r6, #0
   18ece:	2e00      	cmp	r6, #0
   18ed0:	d023      	beq.n	18f1a <__sfvwrite_r+0x1aa>
   18ed2:	2280      	movs	r2, #128	; 0x80
   18ed4:	0092      	lsls	r2, r2, #2
   18ed6:	68a5      	ldr	r5, [r4, #8]
   18ed8:	4213      	tst	r3, r2
   18eda:	d025      	beq.n	18f28 <__sfvwrite_r+0x1b8>
   18edc:	46a8      	mov	r8, r5
   18ede:	42ae      	cmp	r6, r5
   18ee0:	d35b      	bcc.n	18f9a <__sfvwrite_r+0x22a>
   18ee2:	2290      	movs	r2, #144	; 0x90
   18ee4:	00d2      	lsls	r2, r2, #3
   18ee6:	4213      	tst	r3, r2
   18ee8:	d168      	bne.n	18fbc <__sfvwrite_r+0x24c>
   18eea:	6820      	ldr	r0, [r4, #0]
   18eec:	4642      	mov	r2, r8
   18eee:	0039      	movs	r1, r7
   18ef0:	f000 f9ee 	bl	192d0 <memmove>
   18ef4:	0030      	movs	r0, r6
   18ef6:	68a3      	ldr	r3, [r4, #8]
   18ef8:	1b5d      	subs	r5, r3, r5
   18efa:	6823      	ldr	r3, [r4, #0]
   18efc:	60a5      	str	r5, [r4, #8]
   18efe:	4443      	add	r3, r8
   18f00:	6023      	str	r3, [r4, #0]
   18f02:	4653      	mov	r3, sl
   18f04:	689b      	ldr	r3, [r3, #8]
   18f06:	183f      	adds	r7, r7, r0
   18f08:	1a36      	subs	r6, r6, r0
   18f0a:	1a18      	subs	r0, r3, r0
   18f0c:	4653      	mov	r3, sl
   18f0e:	6098      	str	r0, [r3, #8]
   18f10:	d100      	bne.n	18f14 <__sfvwrite_r+0x1a4>
   18f12:	e760      	b.n	18dd6 <__sfvwrite_r+0x66>
   18f14:	89a3      	ldrh	r3, [r4, #12]
   18f16:	2e00      	cmp	r6, #0
   18f18:	d1db      	bne.n	18ed2 <__sfvwrite_r+0x162>
   18f1a:	465a      	mov	r2, fp
   18f1c:	6817      	ldr	r7, [r2, #0]
   18f1e:	6856      	ldr	r6, [r2, #4]
   18f20:	2208      	movs	r2, #8
   18f22:	4694      	mov	ip, r2
   18f24:	44e3      	add	fp, ip
   18f26:	e7d2      	b.n	18ece <__sfvwrite_r+0x15e>
   18f28:	6820      	ldr	r0, [r4, #0]
   18f2a:	6923      	ldr	r3, [r4, #16]
   18f2c:	4298      	cmp	r0, r3
   18f2e:	d803      	bhi.n	18f38 <__sfvwrite_r+0x1c8>
   18f30:	6963      	ldr	r3, [r4, #20]
   18f32:	4698      	mov	r8, r3
   18f34:	429e      	cmp	r6, r3
   18f36:	d2af      	bcs.n	18e98 <__sfvwrite_r+0x128>
   18f38:	42b5      	cmp	r5, r6
   18f3a:	d900      	bls.n	18f3e <__sfvwrite_r+0x1ce>
   18f3c:	0035      	movs	r5, r6
   18f3e:	002a      	movs	r2, r5
   18f40:	0039      	movs	r1, r7
   18f42:	f000 f9c5 	bl	192d0 <memmove>
   18f46:	68a3      	ldr	r3, [r4, #8]
   18f48:	6822      	ldr	r2, [r4, #0]
   18f4a:	1b5b      	subs	r3, r3, r5
   18f4c:	1952      	adds	r2, r2, r5
   18f4e:	60a3      	str	r3, [r4, #8]
   18f50:	6022      	str	r2, [r4, #0]
   18f52:	2b00      	cmp	r3, #0
   18f54:	d001      	beq.n	18f5a <__sfvwrite_r+0x1ea>
   18f56:	0028      	movs	r0, r5
   18f58:	e7d3      	b.n	18f02 <__sfvwrite_r+0x192>
   18f5a:	0021      	movs	r1, r4
   18f5c:	9801      	ldr	r0, [sp, #4]
   18f5e:	f7ff fc93 	bl	18888 <_fflush_r>
   18f62:	2800      	cmp	r0, #0
   18f64:	d1a9      	bne.n	18eba <__sfvwrite_r+0x14a>
   18f66:	0028      	movs	r0, r5
   18f68:	e7cb      	b.n	18f02 <__sfvwrite_r+0x192>
   18f6a:	0032      	movs	r2, r6
   18f6c:	4649      	mov	r1, r9
   18f6e:	f000 f9af 	bl	192d0 <memmove>
   18f72:	68a3      	ldr	r3, [r4, #8]
   18f74:	1b9b      	subs	r3, r3, r6
   18f76:	60a3      	str	r3, [r4, #8]
   18f78:	6823      	ldr	r3, [r4, #0]
   18f7a:	469c      	mov	ip, r3
   18f7c:	4643      	mov	r3, r8
   18f7e:	4466      	add	r6, ip
   18f80:	6026      	str	r6, [r4, #0]
   18f82:	1aed      	subs	r5, r5, r3
   18f84:	d000      	beq.n	18f88 <__sfvwrite_r+0x218>
   18f86:	e769      	b.n	18e5c <__sfvwrite_r+0xec>
   18f88:	0021      	movs	r1, r4
   18f8a:	9801      	ldr	r0, [sp, #4]
   18f8c:	f7ff fc7c 	bl	18888 <_fflush_r>
   18f90:	2800      	cmp	r0, #0
   18f92:	d192      	bne.n	18eba <__sfvwrite_r+0x14a>
   18f94:	2300      	movs	r3, #0
   18f96:	9302      	str	r3, [sp, #8]
   18f98:	e760      	b.n	18e5c <__sfvwrite_r+0xec>
   18f9a:	0035      	movs	r5, r6
   18f9c:	6820      	ldr	r0, [r4, #0]
   18f9e:	46b0      	mov	r8, r6
   18fa0:	e7a4      	b.n	18eec <__sfvwrite_r+0x17c>
   18fa2:	003a      	movs	r2, r7
   18fa4:	210a      	movs	r1, #10
   18fa6:	4648      	mov	r0, r9
   18fa8:	f000 f94a 	bl	19240 <memchr>
   18fac:	2800      	cmp	r0, #0
   18fae:	d059      	beq.n	19064 <__sfvwrite_r+0x2f4>
   18fb0:	464b      	mov	r3, r9
   18fb2:	3001      	adds	r0, #1
   18fb4:	1ac5      	subs	r5, r0, r3
   18fb6:	2301      	movs	r3, #1
   18fb8:	9302      	str	r3, [sp, #8]
   18fba:	e72e      	b.n	18e1a <__sfvwrite_r+0xaa>
   18fbc:	6921      	ldr	r1, [r4, #16]
   18fbe:	6822      	ldr	r2, [r4, #0]
   18fc0:	1a52      	subs	r2, r2, r1
   18fc2:	4691      	mov	r9, r2
   18fc4:	6962      	ldr	r2, [r4, #20]
   18fc6:	0050      	lsls	r0, r2, #1
   18fc8:	1882      	adds	r2, r0, r2
   18fca:	0fd0      	lsrs	r0, r2, #31
   18fcc:	1882      	adds	r2, r0, r2
   18fce:	1052      	asrs	r2, r2, #1
   18fd0:	4690      	mov	r8, r2
   18fd2:	464a      	mov	r2, r9
   18fd4:	1c50      	adds	r0, r2, #1
   18fd6:	1980      	adds	r0, r0, r6
   18fd8:	4642      	mov	r2, r8
   18fda:	4540      	cmp	r0, r8
   18fdc:	d901      	bls.n	18fe2 <__sfvwrite_r+0x272>
   18fde:	4680      	mov	r8, r0
   18fe0:	0002      	movs	r2, r0
   18fe2:	055b      	lsls	r3, r3, #21
   18fe4:	d52d      	bpl.n	19042 <__sfvwrite_r+0x2d2>
   18fe6:	0011      	movs	r1, r2
   18fe8:	9801      	ldr	r0, [sp, #4]
   18fea:	f7fc fa1f 	bl	1542c <_malloc_r>
   18fee:	1e05      	subs	r5, r0, #0
   18ff0:	d03f      	beq.n	19072 <__sfvwrite_r+0x302>
   18ff2:	464a      	mov	r2, r9
   18ff4:	6921      	ldr	r1, [r4, #16]
   18ff6:	f7fc fceb 	bl	159d0 <memcpy>
   18ffa:	89a2      	ldrh	r2, [r4, #12]
   18ffc:	4b22      	ldr	r3, [pc, #136]	; (19088 <__sfvwrite_r+0x318>)
   18ffe:	4013      	ands	r3, r2
   19000:	2280      	movs	r2, #128	; 0x80
   19002:	4313      	orrs	r3, r2
   19004:	81a3      	strh	r3, [r4, #12]
   19006:	4643      	mov	r3, r8
   19008:	0028      	movs	r0, r5
   1900a:	464a      	mov	r2, r9
   1900c:	4448      	add	r0, r9
   1900e:	6163      	str	r3, [r4, #20]
   19010:	1a9b      	subs	r3, r3, r2
   19012:	6125      	str	r5, [r4, #16]
   19014:	6020      	str	r0, [r4, #0]
   19016:	0035      	movs	r5, r6
   19018:	60a3      	str	r3, [r4, #8]
   1901a:	46b0      	mov	r8, r6
   1901c:	e766      	b.n	18eec <__sfvwrite_r+0x17c>
   1901e:	4666      	mov	r6, ip
   19020:	4649      	mov	r1, r9
   19022:	f000 f955 	bl	192d0 <memmove>
   19026:	46b4      	mov	ip, r6
   19028:	6823      	ldr	r3, [r4, #0]
   1902a:	0021      	movs	r1, r4
   1902c:	4463      	add	r3, ip
   1902e:	6023      	str	r3, [r4, #0]
   19030:	9801      	ldr	r0, [sp, #4]
   19032:	f7ff fc29 	bl	18888 <_fflush_r>
   19036:	2800      	cmp	r0, #0
   19038:	d000      	beq.n	1903c <__sfvwrite_r+0x2cc>
   1903a:	e73e      	b.n	18eba <__sfvwrite_r+0x14a>
   1903c:	9b03      	ldr	r3, [sp, #12]
   1903e:	4698      	mov	r8, r3
   19040:	e708      	b.n	18e54 <__sfvwrite_r+0xe4>
   19042:	9801      	ldr	r0, [sp, #4]
   19044:	f000 fe52 	bl	19cec <_realloc_r>
   19048:	1e05      	subs	r5, r0, #0
   1904a:	d1dc      	bne.n	19006 <__sfvwrite_r+0x296>
   1904c:	9d01      	ldr	r5, [sp, #4]
   1904e:	6921      	ldr	r1, [r4, #16]
   19050:	0028      	movs	r0, r5
   19052:	f7ff fdab 	bl	18bac <_free_r>
   19056:	2280      	movs	r2, #128	; 0x80
   19058:	89a3      	ldrh	r3, [r4, #12]
   1905a:	4393      	bics	r3, r2
   1905c:	b21a      	sxth	r2, r3
   1905e:	230c      	movs	r3, #12
   19060:	602b      	str	r3, [r5, #0]
   19062:	e72c      	b.n	18ebe <__sfvwrite_r+0x14e>
   19064:	2301      	movs	r3, #1
   19066:	1c7d      	adds	r5, r7, #1
   19068:	9302      	str	r3, [sp, #8]
   1906a:	e6d6      	b.n	18e1a <__sfvwrite_r+0xaa>
   1906c:	2001      	movs	r0, #1
   1906e:	4240      	negs	r0, r0
   19070:	e6b2      	b.n	18dd8 <__sfvwrite_r+0x68>
   19072:	230c      	movs	r3, #12
   19074:	9a01      	ldr	r2, [sp, #4]
   19076:	6013      	str	r3, [r2, #0]
   19078:	230c      	movs	r3, #12
   1907a:	5ee2      	ldrsh	r2, [r4, r3]
   1907c:	e71f      	b.n	18ebe <__sfvwrite_r+0x14e>
   1907e:	46c0      	nop			; (mov r8, r8)
   19080:	7ffffc00 	.word	0x7ffffc00
   19084:	7fffffff 	.word	0x7fffffff
   19088:	fffffb7f 	.word	0xfffffb7f

0001908c <_fwalk>:
   1908c:	23b8      	movs	r3, #184	; 0xb8
   1908e:	b5f0      	push	{r4, r5, r6, r7, lr}
   19090:	4647      	mov	r7, r8
   19092:	009b      	lsls	r3, r3, #2
   19094:	b480      	push	{r7}
   19096:	18c7      	adds	r7, r0, r3
   19098:	4688      	mov	r8, r1
   1909a:	2600      	movs	r6, #0
   1909c:	2f00      	cmp	r7, #0
   1909e:	d013      	beq.n	190c8 <_fwalk+0x3c>
   190a0:	687b      	ldr	r3, [r7, #4]
   190a2:	68bc      	ldr	r4, [r7, #8]
   190a4:	1e5d      	subs	r5, r3, #1
   190a6:	d40c      	bmi.n	190c2 <_fwalk+0x36>
   190a8:	89a3      	ldrh	r3, [r4, #12]
   190aa:	2b01      	cmp	r3, #1
   190ac:	d906      	bls.n	190bc <_fwalk+0x30>
   190ae:	220e      	movs	r2, #14
   190b0:	5ea3      	ldrsh	r3, [r4, r2]
   190b2:	3301      	adds	r3, #1
   190b4:	d002      	beq.n	190bc <_fwalk+0x30>
   190b6:	0020      	movs	r0, r4
   190b8:	47c0      	blx	r8
   190ba:	4306      	orrs	r6, r0
   190bc:	3468      	adds	r4, #104	; 0x68
   190be:	3d01      	subs	r5, #1
   190c0:	d2f2      	bcs.n	190a8 <_fwalk+0x1c>
   190c2:	683f      	ldr	r7, [r7, #0]
   190c4:	2f00      	cmp	r7, #0
   190c6:	d1eb      	bne.n	190a0 <_fwalk+0x14>
   190c8:	0030      	movs	r0, r6
   190ca:	bc04      	pop	{r2}
   190cc:	4690      	mov	r8, r2
   190ce:	bdf0      	pop	{r4, r5, r6, r7, pc}

000190d0 <_fwalk_reent>:
   190d0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   190d2:	464f      	mov	r7, r9
   190d4:	4646      	mov	r6, r8
   190d6:	b4c0      	push	{r6, r7}
   190d8:	27b8      	movs	r7, #184	; 0xb8
   190da:	4680      	mov	r8, r0
   190dc:	00bf      	lsls	r7, r7, #2
   190de:	4447      	add	r7, r8
   190e0:	4689      	mov	r9, r1
   190e2:	2600      	movs	r6, #0
   190e4:	2f00      	cmp	r7, #0
   190e6:	d014      	beq.n	19112 <_fwalk_reent+0x42>
   190e8:	687b      	ldr	r3, [r7, #4]
   190ea:	68bc      	ldr	r4, [r7, #8]
   190ec:	1e5d      	subs	r5, r3, #1
   190ee:	d40d      	bmi.n	1910c <_fwalk_reent+0x3c>
   190f0:	89a3      	ldrh	r3, [r4, #12]
   190f2:	2b01      	cmp	r3, #1
   190f4:	d907      	bls.n	19106 <_fwalk_reent+0x36>
   190f6:	220e      	movs	r2, #14
   190f8:	5ea3      	ldrsh	r3, [r4, r2]
   190fa:	3301      	adds	r3, #1
   190fc:	d003      	beq.n	19106 <_fwalk_reent+0x36>
   190fe:	0021      	movs	r1, r4
   19100:	4640      	mov	r0, r8
   19102:	47c8      	blx	r9
   19104:	4306      	orrs	r6, r0
   19106:	3468      	adds	r4, #104	; 0x68
   19108:	3d01      	subs	r5, #1
   1910a:	d2f1      	bcs.n	190f0 <_fwalk_reent+0x20>
   1910c:	683f      	ldr	r7, [r7, #0]
   1910e:	2f00      	cmp	r7, #0
   19110:	d1ea      	bne.n	190e8 <_fwalk_reent+0x18>
   19112:	0030      	movs	r0, r6
   19114:	bc0c      	pop	{r2, r3}
   19116:	4690      	mov	r8, r2
   19118:	4699      	mov	r9, r3
   1911a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0001911c <__localeconv_l>:
   1911c:	30f0      	adds	r0, #240	; 0xf0
   1911e:	4770      	bx	lr

00019120 <_localeconv_r>:
   19120:	4b04      	ldr	r3, [pc, #16]	; (19134 <_localeconv_r+0x14>)
   19122:	681b      	ldr	r3, [r3, #0]
   19124:	6b58      	ldr	r0, [r3, #52]	; 0x34
   19126:	2800      	cmp	r0, #0
   19128:	d001      	beq.n	1912e <_localeconv_r+0xe>
   1912a:	30f0      	adds	r0, #240	; 0xf0
   1912c:	4770      	bx	lr
   1912e:	4802      	ldr	r0, [pc, #8]	; (19138 <_localeconv_r+0x18>)
   19130:	e7fb      	b.n	1912a <_localeconv_r+0xa>
   19132:	46c0      	nop			; (mov r8, r8)
   19134:	10010df0 	.word	0x10010df0
   19138:	10010df4 	.word	0x10010df4

0001913c <localeconv>:
   1913c:	4b04      	ldr	r3, [pc, #16]	; (19150 <localeconv+0x14>)
   1913e:	681b      	ldr	r3, [r3, #0]
   19140:	6b58      	ldr	r0, [r3, #52]	; 0x34
   19142:	2800      	cmp	r0, #0
   19144:	d001      	beq.n	1914a <localeconv+0xe>
   19146:	30f0      	adds	r0, #240	; 0xf0
   19148:	4770      	bx	lr
   1914a:	4802      	ldr	r0, [pc, #8]	; (19154 <localeconv+0x18>)
   1914c:	e7fb      	b.n	19146 <localeconv+0xa>
   1914e:	46c0      	nop			; (mov r8, r8)
   19150:	10010df0 	.word	0x10010df0
   19154:	10010df4 	.word	0x10010df4

00019158 <__swhatbuf_r>:
   19158:	b570      	push	{r4, r5, r6, lr}
   1915a:	000c      	movs	r4, r1
   1915c:	001e      	movs	r6, r3
   1915e:	230e      	movs	r3, #14
   19160:	5ec9      	ldrsh	r1, [r1, r3]
   19162:	b090      	sub	sp, #64	; 0x40
   19164:	0015      	movs	r5, r2
   19166:	2900      	cmp	r1, #0
   19168:	db15      	blt.n	19196 <__swhatbuf_r+0x3e>
   1916a:	aa01      	add	r2, sp, #4
   1916c:	f003 fd26 	bl	1cbbc <_fstat_r>
   19170:	2800      	cmp	r0, #0
   19172:	db10      	blt.n	19196 <__swhatbuf_r+0x3e>
   19174:	23f0      	movs	r3, #240	; 0xf0
   19176:	9a02      	ldr	r2, [sp, #8]
   19178:	021b      	lsls	r3, r3, #8
   1917a:	4013      	ands	r3, r2
   1917c:	4a0d      	ldr	r2, [pc, #52]	; (191b4 <__swhatbuf_r+0x5c>)
   1917e:	2080      	movs	r0, #128	; 0x80
   19180:	4694      	mov	ip, r2
   19182:	4463      	add	r3, ip
   19184:	425a      	negs	r2, r3
   19186:	4153      	adcs	r3, r2
   19188:	6033      	str	r3, [r6, #0]
   1918a:	2380      	movs	r3, #128	; 0x80
   1918c:	00db      	lsls	r3, r3, #3
   1918e:	602b      	str	r3, [r5, #0]
   19190:	0100      	lsls	r0, r0, #4
   19192:	b010      	add	sp, #64	; 0x40
   19194:	bd70      	pop	{r4, r5, r6, pc}
   19196:	2300      	movs	r3, #0
   19198:	6033      	str	r3, [r6, #0]
   1919a:	89a3      	ldrh	r3, [r4, #12]
   1919c:	061b      	lsls	r3, r3, #24
   1919e:	d503      	bpl.n	191a8 <__swhatbuf_r+0x50>
   191a0:	2340      	movs	r3, #64	; 0x40
   191a2:	2000      	movs	r0, #0
   191a4:	602b      	str	r3, [r5, #0]
   191a6:	e7f4      	b.n	19192 <__swhatbuf_r+0x3a>
   191a8:	2380      	movs	r3, #128	; 0x80
   191aa:	00db      	lsls	r3, r3, #3
   191ac:	602b      	str	r3, [r5, #0]
   191ae:	2000      	movs	r0, #0
   191b0:	e7ef      	b.n	19192 <__swhatbuf_r+0x3a>
   191b2:	46c0      	nop			; (mov r8, r8)
   191b4:	ffffe000 	.word	0xffffe000

000191b8 <__smakebuf_r>:
   191b8:	b570      	push	{r4, r5, r6, lr}
   191ba:	898b      	ldrh	r3, [r1, #12]
   191bc:	b082      	sub	sp, #8
   191be:	0005      	movs	r5, r0
   191c0:	000c      	movs	r4, r1
   191c2:	079b      	lsls	r3, r3, #30
   191c4:	d507      	bpl.n	191d6 <__smakebuf_r+0x1e>
   191c6:	0023      	movs	r3, r4
   191c8:	3343      	adds	r3, #67	; 0x43
   191ca:	6023      	str	r3, [r4, #0]
   191cc:	6123      	str	r3, [r4, #16]
   191ce:	2301      	movs	r3, #1
   191d0:	6163      	str	r3, [r4, #20]
   191d2:	b002      	add	sp, #8
   191d4:	bd70      	pop	{r4, r5, r6, pc}
   191d6:	ab01      	add	r3, sp, #4
   191d8:	466a      	mov	r2, sp
   191da:	f7ff ffbd 	bl	19158 <__swhatbuf_r>
   191de:	9900      	ldr	r1, [sp, #0]
   191e0:	0006      	movs	r6, r0
   191e2:	0028      	movs	r0, r5
   191e4:	f7fc f922 	bl	1542c <_malloc_r>
   191e8:	2800      	cmp	r0, #0
   191ea:	d01c      	beq.n	19226 <__smakebuf_r+0x6e>
   191ec:	2280      	movs	r2, #128	; 0x80
   191ee:	4b13      	ldr	r3, [pc, #76]	; (1923c <__smakebuf_r+0x84>)
   191f0:	63eb      	str	r3, [r5, #60]	; 0x3c
   191f2:	89a3      	ldrh	r3, [r4, #12]
   191f4:	6020      	str	r0, [r4, #0]
   191f6:	4313      	orrs	r3, r2
   191f8:	9a00      	ldr	r2, [sp, #0]
   191fa:	b21b      	sxth	r3, r3
   191fc:	6162      	str	r2, [r4, #20]
   191fe:	9a01      	ldr	r2, [sp, #4]
   19200:	81a3      	strh	r3, [r4, #12]
   19202:	6120      	str	r0, [r4, #16]
   19204:	2a00      	cmp	r2, #0
   19206:	d102      	bne.n	1920e <__smakebuf_r+0x56>
   19208:	4333      	orrs	r3, r6
   1920a:	81a3      	strh	r3, [r4, #12]
   1920c:	e7e1      	b.n	191d2 <__smakebuf_r+0x1a>
   1920e:	230e      	movs	r3, #14
   19210:	5ee1      	ldrsh	r1, [r4, r3]
   19212:	0028      	movs	r0, r5
   19214:	f003 fce6 	bl	1cbe4 <_isatty_r>
   19218:	2800      	cmp	r0, #0
   1921a:	d00c      	beq.n	19236 <__smakebuf_r+0x7e>
   1921c:	2201      	movs	r2, #1
   1921e:	89a3      	ldrh	r3, [r4, #12]
   19220:	431a      	orrs	r2, r3
   19222:	b213      	sxth	r3, r2
   19224:	e7f0      	b.n	19208 <__smakebuf_r+0x50>
   19226:	220c      	movs	r2, #12
   19228:	5ea3      	ldrsh	r3, [r4, r2]
   1922a:	059a      	lsls	r2, r3, #22
   1922c:	d4d1      	bmi.n	191d2 <__smakebuf_r+0x1a>
   1922e:	2202      	movs	r2, #2
   19230:	4313      	orrs	r3, r2
   19232:	81a3      	strh	r3, [r4, #12]
   19234:	e7c7      	b.n	191c6 <__smakebuf_r+0xe>
   19236:	220c      	movs	r2, #12
   19238:	5ea3      	ldrsh	r3, [r4, r2]
   1923a:	e7e5      	b.n	19208 <__smakebuf_r+0x50>
   1923c:	000188e1 	.word	0x000188e1

00019240 <memchr>:
   19240:	b570      	push	{r4, r5, r6, lr}
   19242:	b2cd      	uxtb	r5, r1
   19244:	0783      	lsls	r3, r0, #30
   19246:	d03c      	beq.n	192c2 <memchr+0x82>
   19248:	1e53      	subs	r3, r2, #1
   1924a:	2a00      	cmp	r2, #0
   1924c:	d01f      	beq.n	1928e <memchr+0x4e>
   1924e:	7802      	ldrb	r2, [r0, #0]
   19250:	42aa      	cmp	r2, r5
   19252:	d01d      	beq.n	19290 <memchr+0x50>
   19254:	2403      	movs	r4, #3
   19256:	e005      	b.n	19264 <memchr+0x24>
   19258:	2b00      	cmp	r3, #0
   1925a:	d018      	beq.n	1928e <memchr+0x4e>
   1925c:	7802      	ldrb	r2, [r0, #0]
   1925e:	3b01      	subs	r3, #1
   19260:	42aa      	cmp	r2, r5
   19262:	d015      	beq.n	19290 <memchr+0x50>
   19264:	3001      	adds	r0, #1
   19266:	4220      	tst	r0, r4
   19268:	d1f6      	bne.n	19258 <memchr+0x18>
   1926a:	2b03      	cmp	r3, #3
   1926c:	d811      	bhi.n	19292 <memchr+0x52>
   1926e:	2b00      	cmp	r3, #0
   19270:	d00d      	beq.n	1928e <memchr+0x4e>
   19272:	7802      	ldrb	r2, [r0, #0]
   19274:	42aa      	cmp	r2, r5
   19276:	d00b      	beq.n	19290 <memchr+0x50>
   19278:	1c42      	adds	r2, r0, #1
   1927a:	18c0      	adds	r0, r0, r3
   1927c:	e004      	b.n	19288 <memchr+0x48>
   1927e:	3201      	adds	r2, #1
   19280:	1e51      	subs	r1, r2, #1
   19282:	7809      	ldrb	r1, [r1, #0]
   19284:	42a9      	cmp	r1, r5
   19286:	d01a      	beq.n	192be <memchr+0x7e>
   19288:	0013      	movs	r3, r2
   1928a:	4290      	cmp	r0, r2
   1928c:	d1f7      	bne.n	1927e <memchr+0x3e>
   1928e:	2000      	movs	r0, #0
   19290:	bd70      	pop	{r4, r5, r6, pc}
   19292:	22ff      	movs	r2, #255	; 0xff
   19294:	020c      	lsls	r4, r1, #8
   19296:	0212      	lsls	r2, r2, #8
   19298:	4022      	ands	r2, r4
   1929a:	24ff      	movs	r4, #255	; 0xff
   1929c:	4021      	ands	r1, r4
   1929e:	4311      	orrs	r1, r2
   192a0:	040c      	lsls	r4, r1, #16
   192a2:	4e09      	ldr	r6, [pc, #36]	; (192c8 <memchr+0x88>)
   192a4:	430c      	orrs	r4, r1
   192a6:	6802      	ldr	r2, [r0, #0]
   192a8:	4908      	ldr	r1, [pc, #32]	; (192cc <memchr+0x8c>)
   192aa:	4062      	eors	r2, r4
   192ac:	1851      	adds	r1, r2, r1
   192ae:	4391      	bics	r1, r2
   192b0:	4231      	tst	r1, r6
   192b2:	d1de      	bne.n	19272 <memchr+0x32>
   192b4:	3b04      	subs	r3, #4
   192b6:	3004      	adds	r0, #4
   192b8:	2b03      	cmp	r3, #3
   192ba:	d8f4      	bhi.n	192a6 <memchr+0x66>
   192bc:	e7d7      	b.n	1926e <memchr+0x2e>
   192be:	0018      	movs	r0, r3
   192c0:	e7e6      	b.n	19290 <memchr+0x50>
   192c2:	0013      	movs	r3, r2
   192c4:	e7d1      	b.n	1926a <memchr+0x2a>
   192c6:	46c0      	nop			; (mov r8, r8)
   192c8:	80808080 	.word	0x80808080
   192cc:	fefefeff 	.word	0xfefefeff

000192d0 <memmove>:
   192d0:	b570      	push	{r4, r5, r6, lr}
   192d2:	4288      	cmp	r0, r1
   192d4:	d90b      	bls.n	192ee <memmove+0x1e>
   192d6:	188b      	adds	r3, r1, r2
   192d8:	4298      	cmp	r0, r3
   192da:	d208      	bcs.n	192ee <memmove+0x1e>
   192dc:	1a99      	subs	r1, r3, r2
   192de:	1e53      	subs	r3, r2, #1
   192e0:	2a00      	cmp	r2, #0
   192e2:	d003      	beq.n	192ec <memmove+0x1c>
   192e4:	5cca      	ldrb	r2, [r1, r3]
   192e6:	54c2      	strb	r2, [r0, r3]
   192e8:	3b01      	subs	r3, #1
   192ea:	d2fb      	bcs.n	192e4 <memmove+0x14>
   192ec:	bd70      	pop	{r4, r5, r6, pc}
   192ee:	2a0f      	cmp	r2, #15
   192f0:	d809      	bhi.n	19306 <memmove+0x36>
   192f2:	0005      	movs	r5, r0
   192f4:	2a00      	cmp	r2, #0
   192f6:	d0f9      	beq.n	192ec <memmove+0x1c>
   192f8:	2300      	movs	r3, #0
   192fa:	5ccc      	ldrb	r4, [r1, r3]
   192fc:	54ec      	strb	r4, [r5, r3]
   192fe:	3301      	adds	r3, #1
   19300:	429a      	cmp	r2, r3
   19302:	d1fa      	bne.n	192fa <memmove+0x2a>
   19304:	e7f2      	b.n	192ec <memmove+0x1c>
   19306:	000c      	movs	r4, r1
   19308:	4304      	orrs	r4, r0
   1930a:	000b      	movs	r3, r1
   1930c:	07a4      	lsls	r4, r4, #30
   1930e:	d126      	bne.n	1935e <memmove+0x8e>
   19310:	0015      	movs	r5, r2
   19312:	0004      	movs	r4, r0
   19314:	3d10      	subs	r5, #16
   19316:	092d      	lsrs	r5, r5, #4
   19318:	3501      	adds	r5, #1
   1931a:	012d      	lsls	r5, r5, #4
   1931c:	1949      	adds	r1, r1, r5
   1931e:	681e      	ldr	r6, [r3, #0]
   19320:	6026      	str	r6, [r4, #0]
   19322:	685e      	ldr	r6, [r3, #4]
   19324:	6066      	str	r6, [r4, #4]
   19326:	689e      	ldr	r6, [r3, #8]
   19328:	60a6      	str	r6, [r4, #8]
   1932a:	68de      	ldr	r6, [r3, #12]
   1932c:	3310      	adds	r3, #16
   1932e:	60e6      	str	r6, [r4, #12]
   19330:	3410      	adds	r4, #16
   19332:	4299      	cmp	r1, r3
   19334:	d1f3      	bne.n	1931e <memmove+0x4e>
   19336:	240f      	movs	r4, #15
   19338:	1945      	adds	r5, r0, r5
   1933a:	4014      	ands	r4, r2
   1933c:	2c03      	cmp	r4, #3
   1933e:	d910      	bls.n	19362 <memmove+0x92>
   19340:	2300      	movs	r3, #0
   19342:	3c04      	subs	r4, #4
   19344:	08a4      	lsrs	r4, r4, #2
   19346:	3401      	adds	r4, #1
   19348:	00a4      	lsls	r4, r4, #2
   1934a:	58ce      	ldr	r6, [r1, r3]
   1934c:	50ee      	str	r6, [r5, r3]
   1934e:	3304      	adds	r3, #4
   19350:	429c      	cmp	r4, r3
   19352:	d1fa      	bne.n	1934a <memmove+0x7a>
   19354:	2303      	movs	r3, #3
   19356:	192d      	adds	r5, r5, r4
   19358:	1909      	adds	r1, r1, r4
   1935a:	401a      	ands	r2, r3
   1935c:	e7ca      	b.n	192f4 <memmove+0x24>
   1935e:	0005      	movs	r5, r0
   19360:	e7ca      	b.n	192f8 <memmove+0x28>
   19362:	0022      	movs	r2, r4
   19364:	e7c6      	b.n	192f4 <memmove+0x24>
   19366:	46c0      	nop			; (mov r8, r8)

00019368 <_Balloc>:
   19368:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
   1936a:	b570      	push	{r4, r5, r6, lr}
   1936c:	0004      	movs	r4, r0
   1936e:	000d      	movs	r5, r1
   19370:	2b00      	cmp	r3, #0
   19372:	d00a      	beq.n	1938a <_Balloc+0x22>
   19374:	00aa      	lsls	r2, r5, #2
   19376:	189b      	adds	r3, r3, r2
   19378:	6818      	ldr	r0, [r3, #0]
   1937a:	2800      	cmp	r0, #0
   1937c:	d00e      	beq.n	1939c <_Balloc+0x34>
   1937e:	6802      	ldr	r2, [r0, #0]
   19380:	601a      	str	r2, [r3, #0]
   19382:	2300      	movs	r3, #0
   19384:	6103      	str	r3, [r0, #16]
   19386:	60c3      	str	r3, [r0, #12]
   19388:	bd70      	pop	{r4, r5, r6, pc}
   1938a:	2221      	movs	r2, #33	; 0x21
   1938c:	2104      	movs	r1, #4
   1938e:	f003 fb05 	bl	1c99c <_calloc_r>
   19392:	64e0      	str	r0, [r4, #76]	; 0x4c
   19394:	1e03      	subs	r3, r0, #0
   19396:	d1ed      	bne.n	19374 <_Balloc+0xc>
   19398:	2000      	movs	r0, #0
   1939a:	e7f5      	b.n	19388 <_Balloc+0x20>
   1939c:	2601      	movs	r6, #1
   1939e:	40ae      	lsls	r6, r5
   193a0:	1d72      	adds	r2, r6, #5
   193a2:	0092      	lsls	r2, r2, #2
   193a4:	2101      	movs	r1, #1
   193a6:	0020      	movs	r0, r4
   193a8:	f003 faf8 	bl	1c99c <_calloc_r>
   193ac:	2800      	cmp	r0, #0
   193ae:	d0f3      	beq.n	19398 <_Balloc+0x30>
   193b0:	6045      	str	r5, [r0, #4]
   193b2:	6086      	str	r6, [r0, #8]
   193b4:	e7e5      	b.n	19382 <_Balloc+0x1a>
   193b6:	46c0      	nop			; (mov r8, r8)

000193b8 <_Bfree>:
   193b8:	2900      	cmp	r1, #0
   193ba:	d006      	beq.n	193ca <_Bfree+0x12>
   193bc:	684b      	ldr	r3, [r1, #4]
   193be:	6cc2      	ldr	r2, [r0, #76]	; 0x4c
   193c0:	009b      	lsls	r3, r3, #2
   193c2:	18d3      	adds	r3, r2, r3
   193c4:	681a      	ldr	r2, [r3, #0]
   193c6:	600a      	str	r2, [r1, #0]
   193c8:	6019      	str	r1, [r3, #0]
   193ca:	4770      	bx	lr

000193cc <__multadd>:
   193cc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   193ce:	464f      	mov	r7, r9
   193d0:	4646      	mov	r6, r8
   193d2:	b4c0      	push	{r6, r7}
   193d4:	000f      	movs	r7, r1
   193d6:	4681      	mov	r9, r0
   193d8:	000e      	movs	r6, r1
   193da:	001c      	movs	r4, r3
   193dc:	2000      	movs	r0, #0
   193de:	690d      	ldr	r5, [r1, #16]
   193e0:	3714      	adds	r7, #20
   193e2:	6839      	ldr	r1, [r7, #0]
   193e4:	3001      	adds	r0, #1
   193e6:	040b      	lsls	r3, r1, #16
   193e8:	0c1b      	lsrs	r3, r3, #16
   193ea:	4353      	muls	r3, r2
   193ec:	0c09      	lsrs	r1, r1, #16
   193ee:	4351      	muls	r1, r2
   193f0:	191b      	adds	r3, r3, r4
   193f2:	0c1c      	lsrs	r4, r3, #16
   193f4:	1909      	adds	r1, r1, r4
   193f6:	041b      	lsls	r3, r3, #16
   193f8:	0c0c      	lsrs	r4, r1, #16
   193fa:	0c1b      	lsrs	r3, r3, #16
   193fc:	0409      	lsls	r1, r1, #16
   193fe:	18cb      	adds	r3, r1, r3
   19400:	c708      	stmia	r7!, {r3}
   19402:	4285      	cmp	r5, r0
   19404:	dced      	bgt.n	193e2 <__multadd+0x16>
   19406:	2c00      	cmp	r4, #0
   19408:	d008      	beq.n	1941c <__multadd+0x50>
   1940a:	68b3      	ldr	r3, [r6, #8]
   1940c:	429d      	cmp	r5, r3
   1940e:	da0a      	bge.n	19426 <__multadd+0x5a>
   19410:	1d2b      	adds	r3, r5, #4
   19412:	009b      	lsls	r3, r3, #2
   19414:	18f3      	adds	r3, r6, r3
   19416:	3501      	adds	r5, #1
   19418:	605c      	str	r4, [r3, #4]
   1941a:	6135      	str	r5, [r6, #16]
   1941c:	0030      	movs	r0, r6
   1941e:	bc0c      	pop	{r2, r3}
   19420:	4690      	mov	r8, r2
   19422:	4699      	mov	r9, r3
   19424:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   19426:	6873      	ldr	r3, [r6, #4]
   19428:	4648      	mov	r0, r9
   1942a:	1c59      	adds	r1, r3, #1
   1942c:	f7ff ff9c 	bl	19368 <_Balloc>
   19430:	0031      	movs	r1, r6
   19432:	6933      	ldr	r3, [r6, #16]
   19434:	4680      	mov	r8, r0
   19436:	1c9a      	adds	r2, r3, #2
   19438:	0092      	lsls	r2, r2, #2
   1943a:	310c      	adds	r1, #12
   1943c:	300c      	adds	r0, #12
   1943e:	f7fc fac7 	bl	159d0 <memcpy>
   19442:	464a      	mov	r2, r9
   19444:	6873      	ldr	r3, [r6, #4]
   19446:	6cd2      	ldr	r2, [r2, #76]	; 0x4c
   19448:	009b      	lsls	r3, r3, #2
   1944a:	18d3      	adds	r3, r2, r3
   1944c:	681a      	ldr	r2, [r3, #0]
   1944e:	6032      	str	r2, [r6, #0]
   19450:	601e      	str	r6, [r3, #0]
   19452:	4646      	mov	r6, r8
   19454:	e7dc      	b.n	19410 <__multadd+0x44>
   19456:	46c0      	nop			; (mov r8, r8)

00019458 <__s2b>:
   19458:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1945a:	464f      	mov	r7, r9
   1945c:	4646      	mov	r6, r8
   1945e:	0005      	movs	r5, r0
   19460:	0018      	movs	r0, r3
   19462:	b4c0      	push	{r6, r7}
   19464:	000c      	movs	r4, r1
   19466:	3008      	adds	r0, #8
   19468:	2109      	movs	r1, #9
   1946a:	0017      	movs	r7, r2
   1946c:	4698      	mov	r8, r3
   1946e:	f7ea ff16 	bl	429e <__aeabi_idiv>
   19472:	2801      	cmp	r0, #1
   19474:	dd36      	ble.n	194e4 <__s2b+0x8c>
   19476:	2201      	movs	r2, #1
   19478:	2100      	movs	r1, #0
   1947a:	0052      	lsls	r2, r2, #1
   1947c:	3101      	adds	r1, #1
   1947e:	4290      	cmp	r0, r2
   19480:	dcfb      	bgt.n	1947a <__s2b+0x22>
   19482:	0028      	movs	r0, r5
   19484:	f7ff ff70 	bl	19368 <_Balloc>
   19488:	9b08      	ldr	r3, [sp, #32]
   1948a:	6143      	str	r3, [r0, #20]
   1948c:	2301      	movs	r3, #1
   1948e:	6103      	str	r3, [r0, #16]
   19490:	2f09      	cmp	r7, #9
   19492:	dd24      	ble.n	194de <__s2b+0x86>
   19494:	3308      	adds	r3, #8
   19496:	4699      	mov	r9, r3
   19498:	44a1      	add	r9, r4
   1949a:	464e      	mov	r6, r9
   1949c:	19e4      	adds	r4, r4, r7
   1949e:	7833      	ldrb	r3, [r6, #0]
   194a0:	0001      	movs	r1, r0
   194a2:	3b30      	subs	r3, #48	; 0x30
   194a4:	220a      	movs	r2, #10
   194a6:	0028      	movs	r0, r5
   194a8:	3601      	adds	r6, #1
   194aa:	f7ff ff8f 	bl	193cc <__multadd>
   194ae:	42a6      	cmp	r6, r4
   194b0:	d1f5      	bne.n	1949e <__s2b+0x46>
   194b2:	464b      	mov	r3, r9
   194b4:	19dc      	adds	r4, r3, r7
   194b6:	3c08      	subs	r4, #8
   194b8:	45b8      	cmp	r8, r7
   194ba:	dd0c      	ble.n	194d6 <__s2b+0x7e>
   194bc:	4643      	mov	r3, r8
   194be:	1bde      	subs	r6, r3, r7
   194c0:	19a6      	adds	r6, r4, r6
   194c2:	7823      	ldrb	r3, [r4, #0]
   194c4:	0001      	movs	r1, r0
   194c6:	3b30      	subs	r3, #48	; 0x30
   194c8:	220a      	movs	r2, #10
   194ca:	0028      	movs	r0, r5
   194cc:	3401      	adds	r4, #1
   194ce:	f7ff ff7d 	bl	193cc <__multadd>
   194d2:	42b4      	cmp	r4, r6
   194d4:	d1f5      	bne.n	194c2 <__s2b+0x6a>
   194d6:	bc0c      	pop	{r2, r3}
   194d8:	4690      	mov	r8, r2
   194da:	4699      	mov	r9, r3
   194dc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   194de:	340a      	adds	r4, #10
   194e0:	2709      	movs	r7, #9
   194e2:	e7e9      	b.n	194b8 <__s2b+0x60>
   194e4:	2100      	movs	r1, #0
   194e6:	e7cc      	b.n	19482 <__s2b+0x2a>

000194e8 <__hi0bits>:
   194e8:	0003      	movs	r3, r0
   194ea:	0c01      	lsrs	r1, r0, #16
   194ec:	2200      	movs	r2, #0
   194ee:	2900      	cmp	r1, #0
   194f0:	d101      	bne.n	194f6 <__hi0bits+0xe>
   194f2:	0403      	lsls	r3, r0, #16
   194f4:	3210      	adds	r2, #16
   194f6:	0e19      	lsrs	r1, r3, #24
   194f8:	d101      	bne.n	194fe <__hi0bits+0x16>
   194fa:	3208      	adds	r2, #8
   194fc:	021b      	lsls	r3, r3, #8
   194fe:	0f19      	lsrs	r1, r3, #28
   19500:	d101      	bne.n	19506 <__hi0bits+0x1e>
   19502:	3204      	adds	r2, #4
   19504:	011b      	lsls	r3, r3, #4
   19506:	0f99      	lsrs	r1, r3, #30
   19508:	d101      	bne.n	1950e <__hi0bits+0x26>
   1950a:	3202      	adds	r2, #2
   1950c:	009b      	lsls	r3, r3, #2
   1950e:	2b00      	cmp	r3, #0
   19510:	db05      	blt.n	1951e <__hi0bits+0x36>
   19512:	2020      	movs	r0, #32
   19514:	005b      	lsls	r3, r3, #1
   19516:	d400      	bmi.n	1951a <__hi0bits+0x32>
   19518:	4770      	bx	lr
   1951a:	1c50      	adds	r0, r2, #1
   1951c:	e7fc      	b.n	19518 <__hi0bits+0x30>
   1951e:	0010      	movs	r0, r2
   19520:	e7fa      	b.n	19518 <__hi0bits+0x30>
   19522:	46c0      	nop			; (mov r8, r8)

00019524 <__lo0bits>:
   19524:	6803      	ldr	r3, [r0, #0]
   19526:	0001      	movs	r1, r0
   19528:	075a      	lsls	r2, r3, #29
   1952a:	d008      	beq.n	1953e <__lo0bits+0x1a>
   1952c:	2000      	movs	r0, #0
   1952e:	07da      	lsls	r2, r3, #31
   19530:	d404      	bmi.n	1953c <__lo0bits+0x18>
   19532:	079a      	lsls	r2, r3, #30
   19534:	d420      	bmi.n	19578 <__lo0bits+0x54>
   19536:	2002      	movs	r0, #2
   19538:	089b      	lsrs	r3, r3, #2
   1953a:	600b      	str	r3, [r1, #0]
   1953c:	4770      	bx	lr
   1953e:	0418      	lsls	r0, r3, #16
   19540:	2200      	movs	r2, #0
   19542:	2800      	cmp	r0, #0
   19544:	d101      	bne.n	1954a <__lo0bits+0x26>
   19546:	0c1b      	lsrs	r3, r3, #16
   19548:	3210      	adds	r2, #16
   1954a:	20ff      	movs	r0, #255	; 0xff
   1954c:	4218      	tst	r0, r3
   1954e:	d101      	bne.n	19554 <__lo0bits+0x30>
   19550:	3208      	adds	r2, #8
   19552:	0a1b      	lsrs	r3, r3, #8
   19554:	0718      	lsls	r0, r3, #28
   19556:	d101      	bne.n	1955c <__lo0bits+0x38>
   19558:	3204      	adds	r2, #4
   1955a:	091b      	lsrs	r3, r3, #4
   1955c:	0798      	lsls	r0, r3, #30
   1955e:	d101      	bne.n	19564 <__lo0bits+0x40>
   19560:	3202      	adds	r2, #2
   19562:	089b      	lsrs	r3, r3, #2
   19564:	07d8      	lsls	r0, r3, #31
   19566:	d404      	bmi.n	19572 <__lo0bits+0x4e>
   19568:	085b      	lsrs	r3, r3, #1
   1956a:	2020      	movs	r0, #32
   1956c:	2b00      	cmp	r3, #0
   1956e:	d0e5      	beq.n	1953c <__lo0bits+0x18>
   19570:	3201      	adds	r2, #1
   19572:	600b      	str	r3, [r1, #0]
   19574:	0010      	movs	r0, r2
   19576:	e7e1      	b.n	1953c <__lo0bits+0x18>
   19578:	085b      	lsrs	r3, r3, #1
   1957a:	600b      	str	r3, [r1, #0]
   1957c:	3001      	adds	r0, #1
   1957e:	e7dd      	b.n	1953c <__lo0bits+0x18>

00019580 <__i2b>:
   19580:	b510      	push	{r4, lr}
   19582:	000c      	movs	r4, r1
   19584:	2101      	movs	r1, #1
   19586:	f7ff feef 	bl	19368 <_Balloc>
   1958a:	2301      	movs	r3, #1
   1958c:	6144      	str	r4, [r0, #20]
   1958e:	6103      	str	r3, [r0, #16]
   19590:	bd10      	pop	{r4, pc}
   19592:	46c0      	nop			; (mov r8, r8)

00019594 <__multiply>:
   19594:	b5f0      	push	{r4, r5, r6, r7, lr}
   19596:	465f      	mov	r7, fp
   19598:	4656      	mov	r6, sl
   1959a:	464d      	mov	r5, r9
   1959c:	4644      	mov	r4, r8
   1959e:	b4f0      	push	{r4, r5, r6, r7}
   195a0:	690e      	ldr	r6, [r1, #16]
   195a2:	6914      	ldr	r4, [r2, #16]
   195a4:	b085      	sub	sp, #20
   195a6:	000f      	movs	r7, r1
   195a8:	0015      	movs	r5, r2
   195aa:	42a6      	cmp	r6, r4
   195ac:	da04      	bge.n	195b8 <__multiply+0x24>
   195ae:	0033      	movs	r3, r6
   195b0:	0017      	movs	r7, r2
   195b2:	0026      	movs	r6, r4
   195b4:	000d      	movs	r5, r1
   195b6:	001c      	movs	r4, r3
   195b8:	1933      	adds	r3, r6, r4
   195ba:	4698      	mov	r8, r3
   195bc:	68bb      	ldr	r3, [r7, #8]
   195be:	6879      	ldr	r1, [r7, #4]
   195c0:	4598      	cmp	r8, r3
   195c2:	dd00      	ble.n	195c6 <__multiply+0x32>
   195c4:	3101      	adds	r1, #1
   195c6:	f7ff fecf 	bl	19368 <_Balloc>
   195ca:	2214      	movs	r2, #20
   195cc:	0003      	movs	r3, r0
   195ce:	4694      	mov	ip, r2
   195d0:	4463      	add	r3, ip
   195d2:	469b      	mov	fp, r3
   195d4:	4643      	mov	r3, r8
   195d6:	009b      	lsls	r3, r3, #2
   195d8:	445b      	add	r3, fp
   195da:	0019      	movs	r1, r3
   195dc:	9302      	str	r3, [sp, #8]
   195de:	9003      	str	r0, [sp, #12]
   195e0:	465b      	mov	r3, fp
   195e2:	2200      	movs	r2, #0
   195e4:	458b      	cmp	fp, r1
   195e6:	d203      	bcs.n	195f0 <__multiply+0x5c>
   195e8:	9902      	ldr	r1, [sp, #8]
   195ea:	c304      	stmia	r3!, {r2}
   195ec:	4299      	cmp	r1, r3
   195ee:	d8fc      	bhi.n	195ea <__multiply+0x56>
   195f0:	2314      	movs	r3, #20
   195f2:	00a4      	lsls	r4, r4, #2
   195f4:	469a      	mov	sl, r3
   195f6:	3714      	adds	r7, #20
   195f8:	0023      	movs	r3, r4
   195fa:	46bc      	mov	ip, r7
   195fc:	44aa      	add	sl, r5
   195fe:	00b6      	lsls	r6, r6, #2
   19600:	4453      	add	r3, sl
   19602:	9700      	str	r7, [sp, #0]
   19604:	44b4      	add	ip, r6
   19606:	9301      	str	r3, [sp, #4]
   19608:	459a      	cmp	sl, r3
   1960a:	d253      	bcs.n	196b4 <__multiply+0x120>
   1960c:	4653      	mov	r3, sl
   1960e:	681b      	ldr	r3, [r3, #0]
   19610:	041e      	lsls	r6, r3, #16
   19612:	0c36      	lsrs	r6, r6, #16
   19614:	d021      	beq.n	1965a <__multiply+0xc6>
   19616:	465c      	mov	r4, fp
   19618:	2700      	movs	r7, #0
   1961a:	4661      	mov	r1, ip
   1961c:	9d00      	ldr	r5, [sp, #0]
   1961e:	cd04      	ldmia	r5!, {r2}
   19620:	0020      	movs	r0, r4
   19622:	0413      	lsls	r3, r2, #16
   19624:	0c1b      	lsrs	r3, r3, #16
   19626:	4373      	muls	r3, r6
   19628:	4699      	mov	r9, r3
   1962a:	6823      	ldr	r3, [r4, #0]
   1962c:	041b      	lsls	r3, r3, #16
   1962e:	0c1b      	lsrs	r3, r3, #16
   19630:	444b      	add	r3, r9
   19632:	19db      	adds	r3, r3, r7
   19634:	0c17      	lsrs	r7, r2, #16
   19636:	4377      	muls	r7, r6
   19638:	6822      	ldr	r2, [r4, #0]
   1963a:	0c12      	lsrs	r2, r2, #16
   1963c:	18ba      	adds	r2, r7, r2
   1963e:	0c1f      	lsrs	r7, r3, #16
   19640:	19d2      	adds	r2, r2, r7
   19642:	041b      	lsls	r3, r3, #16
   19644:	0c17      	lsrs	r7, r2, #16
   19646:	0c1b      	lsrs	r3, r3, #16
   19648:	0412      	lsls	r2, r2, #16
   1964a:	4313      	orrs	r3, r2
   1964c:	c408      	stmia	r4!, {r3}
   1964e:	42a9      	cmp	r1, r5
   19650:	d8e5      	bhi.n	1961e <__multiply+0x8a>
   19652:	4653      	mov	r3, sl
   19654:	468c      	mov	ip, r1
   19656:	6047      	str	r7, [r0, #4]
   19658:	681b      	ldr	r3, [r3, #0]
   1965a:	0c1e      	lsrs	r6, r3, #16
   1965c:	d023      	beq.n	196a6 <__multiply+0x112>
   1965e:	465b      	mov	r3, fp
   19660:	2200      	movs	r2, #0
   19662:	681b      	ldr	r3, [r3, #0]
   19664:	4658      	mov	r0, fp
   19666:	001d      	movs	r5, r3
   19668:	0011      	movs	r1, r2
   1966a:	4667      	mov	r7, ip
   1966c:	9c00      	ldr	r4, [sp, #0]
   1966e:	8822      	ldrh	r2, [r4, #0]
   19670:	0c2d      	lsrs	r5, r5, #16
   19672:	4372      	muls	r2, r6
   19674:	1955      	adds	r5, r2, r5
   19676:	186a      	adds	r2, r5, r1
   19678:	041b      	lsls	r3, r3, #16
   1967a:	0411      	lsls	r1, r2, #16
   1967c:	0c1b      	lsrs	r3, r3, #16
   1967e:	430b      	orrs	r3, r1
   19680:	6003      	str	r3, [r0, #0]
   19682:	cc08      	ldmia	r4!, {r3}
   19684:	6845      	ldr	r5, [r0, #4]
   19686:	0c1b      	lsrs	r3, r3, #16
   19688:	4373      	muls	r3, r6
   1968a:	0429      	lsls	r1, r5, #16
   1968c:	0c09      	lsrs	r1, r1, #16
   1968e:	1859      	adds	r1, r3, r1
   19690:	0c13      	lsrs	r3, r2, #16
   19692:	18cb      	adds	r3, r1, r3
   19694:	4684      	mov	ip, r0
   19696:	0c19      	lsrs	r1, r3, #16
   19698:	3004      	adds	r0, #4
   1969a:	42a7      	cmp	r7, r4
   1969c:	d8e7      	bhi.n	1966e <__multiply+0xda>
   1969e:	003a      	movs	r2, r7
   196a0:	4667      	mov	r7, ip
   196a2:	4694      	mov	ip, r2
   196a4:	607b      	str	r3, [r7, #4]
   196a6:	2304      	movs	r3, #4
   196a8:	4699      	mov	r9, r3
   196aa:	9b01      	ldr	r3, [sp, #4]
   196ac:	44ca      	add	sl, r9
   196ae:	44cb      	add	fp, r9
   196b0:	4553      	cmp	r3, sl
   196b2:	d8ab      	bhi.n	1960c <__multiply+0x78>
   196b4:	4643      	mov	r3, r8
   196b6:	2b00      	cmp	r3, #0
   196b8:	dd0e      	ble.n	196d8 <__multiply+0x144>
   196ba:	9b02      	ldr	r3, [sp, #8]
   196bc:	3b04      	subs	r3, #4
   196be:	681a      	ldr	r2, [r3, #0]
   196c0:	2a00      	cmp	r2, #0
   196c2:	d109      	bne.n	196d8 <__multiply+0x144>
   196c4:	4642      	mov	r2, r8
   196c6:	e003      	b.n	196d0 <__multiply+0x13c>
   196c8:	3b04      	subs	r3, #4
   196ca:	6819      	ldr	r1, [r3, #0]
   196cc:	2900      	cmp	r1, #0
   196ce:	d102      	bne.n	196d6 <__multiply+0x142>
   196d0:	3a01      	subs	r2, #1
   196d2:	2a00      	cmp	r2, #0
   196d4:	d1f8      	bne.n	196c8 <__multiply+0x134>
   196d6:	4690      	mov	r8, r2
   196d8:	9b03      	ldr	r3, [sp, #12]
   196da:	4642      	mov	r2, r8
   196dc:	0018      	movs	r0, r3
   196de:	611a      	str	r2, [r3, #16]
   196e0:	b005      	add	sp, #20
   196e2:	bc3c      	pop	{r2, r3, r4, r5}
   196e4:	4690      	mov	r8, r2
   196e6:	4699      	mov	r9, r3
   196e8:	46a2      	mov	sl, r4
   196ea:	46ab      	mov	fp, r5
   196ec:	bdf0      	pop	{r4, r5, r6, r7, pc}
   196ee:	46c0      	nop			; (mov r8, r8)

000196f0 <__pow5mult>:
   196f0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   196f2:	4646      	mov	r6, r8
   196f4:	464f      	mov	r7, r9
   196f6:	2303      	movs	r3, #3
   196f8:	b4c0      	push	{r6, r7}
   196fa:	4680      	mov	r8, r0
   196fc:	000e      	movs	r6, r1
   196fe:	0014      	movs	r4, r2
   19700:	4013      	ands	r3, r2
   19702:	d137      	bne.n	19774 <__pow5mult+0x84>
   19704:	10a4      	asrs	r4, r4, #2
   19706:	d024      	beq.n	19752 <__pow5mult+0x62>
   19708:	4643      	mov	r3, r8
   1970a:	6c9d      	ldr	r5, [r3, #72]	; 0x48
   1970c:	2d00      	cmp	r5, #0
   1970e:	d03a      	beq.n	19786 <__pow5mult+0x96>
   19710:	2300      	movs	r3, #0
   19712:	2701      	movs	r7, #1
   19714:	4699      	mov	r9, r3
   19716:	4227      	tst	r7, r4
   19718:	d107      	bne.n	1972a <__pow5mult+0x3a>
   1971a:	1064      	asrs	r4, r4, #1
   1971c:	d019      	beq.n	19752 <__pow5mult+0x62>
   1971e:	6828      	ldr	r0, [r5, #0]
   19720:	2800      	cmp	r0, #0
   19722:	d01b      	beq.n	1975c <__pow5mult+0x6c>
   19724:	0005      	movs	r5, r0
   19726:	4227      	tst	r7, r4
   19728:	d0f7      	beq.n	1971a <__pow5mult+0x2a>
   1972a:	002a      	movs	r2, r5
   1972c:	0031      	movs	r1, r6
   1972e:	4640      	mov	r0, r8
   19730:	f7ff ff30 	bl	19594 <__multiply>
   19734:	2e00      	cmp	r6, #0
   19736:	d01b      	beq.n	19770 <__pow5mult+0x80>
   19738:	4642      	mov	r2, r8
   1973a:	6cd2      	ldr	r2, [r2, #76]	; 0x4c
   1973c:	6873      	ldr	r3, [r6, #4]
   1973e:	4694      	mov	ip, r2
   19740:	009b      	lsls	r3, r3, #2
   19742:	4463      	add	r3, ip
   19744:	681a      	ldr	r2, [r3, #0]
   19746:	1064      	asrs	r4, r4, #1
   19748:	6032      	str	r2, [r6, #0]
   1974a:	601e      	str	r6, [r3, #0]
   1974c:	0006      	movs	r6, r0
   1974e:	2c00      	cmp	r4, #0
   19750:	d1e5      	bne.n	1971e <__pow5mult+0x2e>
   19752:	0030      	movs	r0, r6
   19754:	bc0c      	pop	{r2, r3}
   19756:	4690      	mov	r8, r2
   19758:	4699      	mov	r9, r3
   1975a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1975c:	002a      	movs	r2, r5
   1975e:	0029      	movs	r1, r5
   19760:	4640      	mov	r0, r8
   19762:	f7ff ff17 	bl	19594 <__multiply>
   19766:	464b      	mov	r3, r9
   19768:	6028      	str	r0, [r5, #0]
   1976a:	6003      	str	r3, [r0, #0]
   1976c:	0005      	movs	r5, r0
   1976e:	e7da      	b.n	19726 <__pow5mult+0x36>
   19770:	0006      	movs	r6, r0
   19772:	e7d2      	b.n	1971a <__pow5mult+0x2a>
   19774:	4a0b      	ldr	r2, [pc, #44]	; (197a4 <__pow5mult+0xb4>)
   19776:	3b01      	subs	r3, #1
   19778:	009b      	lsls	r3, r3, #2
   1977a:	589a      	ldr	r2, [r3, r2]
   1977c:	2300      	movs	r3, #0
   1977e:	f7ff fe25 	bl	193cc <__multadd>
   19782:	0006      	movs	r6, r0
   19784:	e7be      	b.n	19704 <__pow5mult+0x14>
   19786:	2101      	movs	r1, #1
   19788:	4640      	mov	r0, r8
   1978a:	f7ff fded 	bl	19368 <_Balloc>
   1978e:	4b06      	ldr	r3, [pc, #24]	; (197a8 <__pow5mult+0xb8>)
   19790:	0005      	movs	r5, r0
   19792:	6143      	str	r3, [r0, #20]
   19794:	2301      	movs	r3, #1
   19796:	6103      	str	r3, [r0, #16]
   19798:	4643      	mov	r3, r8
   1979a:	6498      	str	r0, [r3, #72]	; 0x48
   1979c:	2300      	movs	r3, #0
   1979e:	6003      	str	r3, [r0, #0]
   197a0:	e7b6      	b.n	19710 <__pow5mult+0x20>
   197a2:	46c0      	nop			; (mov r8, r8)
   197a4:	00022e68 	.word	0x00022e68
   197a8:	00000271 	.word	0x00000271

000197ac <__lshift>:
   197ac:	b5f0      	push	{r4, r5, r6, r7, lr}
   197ae:	464d      	mov	r5, r9
   197b0:	4644      	mov	r4, r8
   197b2:	465f      	mov	r7, fp
   197b4:	4656      	mov	r6, sl
   197b6:	b4f0      	push	{r4, r5, r6, r7}
   197b8:	000e      	movs	r6, r1
   197ba:	6933      	ldr	r3, [r6, #16]
   197bc:	1157      	asrs	r7, r2, #5
   197be:	4699      	mov	r9, r3
   197c0:	44b9      	add	r9, r7
   197c2:	464b      	mov	r3, r9
   197c4:	1c5d      	adds	r5, r3, #1
   197c6:	68b3      	ldr	r3, [r6, #8]
   197c8:	b083      	sub	sp, #12
   197ca:	4680      	mov	r8, r0
   197cc:	0014      	movs	r4, r2
   197ce:	6849      	ldr	r1, [r1, #4]
   197d0:	429d      	cmp	r5, r3
   197d2:	dd03      	ble.n	197dc <__lshift+0x30>
   197d4:	3101      	adds	r1, #1
   197d6:	005b      	lsls	r3, r3, #1
   197d8:	429d      	cmp	r5, r3
   197da:	dcfb      	bgt.n	197d4 <__lshift+0x28>
   197dc:	4640      	mov	r0, r8
   197de:	f7ff fdc3 	bl	19368 <_Balloc>
   197e2:	0003      	movs	r3, r0
   197e4:	4682      	mov	sl, r0
   197e6:	3314      	adds	r3, #20
   197e8:	2f00      	cmp	r7, #0
   197ea:	dd06      	ble.n	197fa <__lshift+0x4e>
   197ec:	00b9      	lsls	r1, r7, #2
   197ee:	001a      	movs	r2, r3
   197f0:	185b      	adds	r3, r3, r1
   197f2:	2100      	movs	r1, #0
   197f4:	c202      	stmia	r2!, {r1}
   197f6:	4293      	cmp	r3, r2
   197f8:	d1fc      	bne.n	197f4 <__lshift+0x48>
   197fa:	0031      	movs	r1, r6
   197fc:	201f      	movs	r0, #31
   197fe:	6932      	ldr	r2, [r6, #16]
   19800:	3114      	adds	r1, #20
   19802:	0092      	lsls	r2, r2, #2
   19804:	188a      	adds	r2, r1, r2
   19806:	4020      	ands	r0, r4
   19808:	d026      	beq.n	19858 <__lshift+0xac>
   1980a:	2420      	movs	r4, #32
   1980c:	1a24      	subs	r4, r4, r0
   1980e:	46a4      	mov	ip, r4
   19810:	2400      	movs	r4, #0
   19812:	680f      	ldr	r7, [r1, #0]
   19814:	9301      	str	r3, [sp, #4]
   19816:	4087      	lsls	r7, r0
   19818:	433c      	orrs	r4, r7
   1981a:	4667      	mov	r7, ip
   1981c:	c310      	stmia	r3!, {r4}
   1981e:	c910      	ldmia	r1!, {r4}
   19820:	40fc      	lsrs	r4, r7
   19822:	428a      	cmp	r2, r1
   19824:	d8f5      	bhi.n	19812 <__lshift+0x66>
   19826:	9b01      	ldr	r3, [sp, #4]
   19828:	605c      	str	r4, [r3, #4]
   1982a:	2c00      	cmp	r4, #0
   1982c:	d001      	beq.n	19832 <__lshift+0x86>
   1982e:	464d      	mov	r5, r9
   19830:	3502      	adds	r5, #2
   19832:	4653      	mov	r3, sl
   19834:	4642      	mov	r2, r8
   19836:	4650      	mov	r0, sl
   19838:	3d01      	subs	r5, #1
   1983a:	611d      	str	r5, [r3, #16]
   1983c:	6873      	ldr	r3, [r6, #4]
   1983e:	6cd2      	ldr	r2, [r2, #76]	; 0x4c
   19840:	009b      	lsls	r3, r3, #2
   19842:	18d3      	adds	r3, r2, r3
   19844:	681a      	ldr	r2, [r3, #0]
   19846:	6032      	str	r2, [r6, #0]
   19848:	601e      	str	r6, [r3, #0]
   1984a:	b003      	add	sp, #12
   1984c:	bc3c      	pop	{r2, r3, r4, r5}
   1984e:	4690      	mov	r8, r2
   19850:	4699      	mov	r9, r3
   19852:	46a2      	mov	sl, r4
   19854:	46ab      	mov	fp, r5
   19856:	bdf0      	pop	{r4, r5, r6, r7, pc}
   19858:	c901      	ldmia	r1!, {r0}
   1985a:	c301      	stmia	r3!, {r0}
   1985c:	428a      	cmp	r2, r1
   1985e:	d9e8      	bls.n	19832 <__lshift+0x86>
   19860:	c901      	ldmia	r1!, {r0}
   19862:	c301      	stmia	r3!, {r0}
   19864:	428a      	cmp	r2, r1
   19866:	d8f7      	bhi.n	19858 <__lshift+0xac>
   19868:	e7e3      	b.n	19832 <__lshift+0x86>
   1986a:	46c0      	nop			; (mov r8, r8)

0001986c <__mcmp>:
   1986c:	6902      	ldr	r2, [r0, #16]
   1986e:	690b      	ldr	r3, [r1, #16]
   19870:	b510      	push	{r4, lr}
   19872:	1ad2      	subs	r2, r2, r3
   19874:	0004      	movs	r4, r0
   19876:	1e10      	subs	r0, r2, #0
   19878:	d112      	bne.n	198a0 <__mcmp+0x34>
   1987a:	0020      	movs	r0, r4
   1987c:	009a      	lsls	r2, r3, #2
   1987e:	3014      	adds	r0, #20
   19880:	3114      	adds	r1, #20
   19882:	1883      	adds	r3, r0, r2
   19884:	1889      	adds	r1, r1, r2
   19886:	e001      	b.n	1988c <__mcmp+0x20>
   19888:	4298      	cmp	r0, r3
   1988a:	d20a      	bcs.n	198a2 <__mcmp+0x36>
   1988c:	3b04      	subs	r3, #4
   1988e:	3904      	subs	r1, #4
   19890:	681a      	ldr	r2, [r3, #0]
   19892:	680c      	ldr	r4, [r1, #0]
   19894:	42a2      	cmp	r2, r4
   19896:	d0f7      	beq.n	19888 <__mcmp+0x1c>
   19898:	42a2      	cmp	r2, r4
   1989a:	4192      	sbcs	r2, r2
   1989c:	2001      	movs	r0, #1
   1989e:	4310      	orrs	r0, r2
   198a0:	bd10      	pop	{r4, pc}
   198a2:	2000      	movs	r0, #0
   198a4:	e7fc      	b.n	198a0 <__mcmp+0x34>
   198a6:	46c0      	nop			; (mov r8, r8)

000198a8 <__mdiff>:
   198a8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   198aa:	464f      	mov	r7, r9
   198ac:	4646      	mov	r6, r8
   198ae:	0014      	movs	r4, r2
   198b0:	690b      	ldr	r3, [r1, #16]
   198b2:	6912      	ldr	r2, [r2, #16]
   198b4:	b4c0      	push	{r6, r7}
   198b6:	1a9b      	subs	r3, r3, r2
   198b8:	000f      	movs	r7, r1
   198ba:	2b00      	cmp	r3, #0
   198bc:	d119      	bne.n	198f2 <__mdiff+0x4a>
   198be:	000d      	movs	r5, r1
   198c0:	2114      	movs	r1, #20
   198c2:	468c      	mov	ip, r1
   198c4:	0092      	lsls	r2, r2, #2
   198c6:	3514      	adds	r5, #20
   198c8:	44a4      	add	ip, r4
   198ca:	18ab      	adds	r3, r5, r2
   198cc:	4462      	add	r2, ip
   198ce:	e001      	b.n	198d4 <__mdiff+0x2c>
   198d0:	429d      	cmp	r5, r3
   198d2:	d266      	bcs.n	199a2 <__mdiff+0xfa>
   198d4:	3b04      	subs	r3, #4
   198d6:	3a04      	subs	r2, #4
   198d8:	681e      	ldr	r6, [r3, #0]
   198da:	6811      	ldr	r1, [r2, #0]
   198dc:	428e      	cmp	r6, r1
   198de:	d0f7      	beq.n	198d0 <__mdiff+0x28>
   198e0:	d267      	bcs.n	199b2 <__mdiff+0x10a>
   198e2:	002e      	movs	r6, r5
   198e4:	4665      	mov	r5, ip
   198e6:	003b      	movs	r3, r7
   198e8:	0027      	movs	r7, r4
   198ea:	001c      	movs	r4, r3
   198ec:	2301      	movs	r3, #1
   198ee:	4699      	mov	r9, r3
   198f0:	e007      	b.n	19902 <__mdiff+0x5a>
   198f2:	2b00      	cmp	r3, #0
   198f4:	db61      	blt.n	199ba <__mdiff+0x112>
   198f6:	2300      	movs	r3, #0
   198f8:	0026      	movs	r6, r4
   198fa:	000d      	movs	r5, r1
   198fc:	4699      	mov	r9, r3
   198fe:	3614      	adds	r6, #20
   19900:	3514      	adds	r5, #20
   19902:	6879      	ldr	r1, [r7, #4]
   19904:	f7ff fd30 	bl	19368 <_Balloc>
   19908:	464a      	mov	r2, r9
   1990a:	4680      	mov	r8, r0
   1990c:	6921      	ldr	r1, [r4, #16]
   1990e:	60c2      	str	r2, [r0, #12]
   19910:	6938      	ldr	r0, [r7, #16]
   19912:	0089      	lsls	r1, r1, #2
   19914:	0083      	lsls	r3, r0, #2
   19916:	469c      	mov	ip, r3
   19918:	4689      	mov	r9, r1
   1991a:	4647      	mov	r7, r8
   1991c:	2400      	movs	r4, #0
   1991e:	44ac      	add	ip, r5
   19920:	44b1      	add	r9, r6
   19922:	3714      	adds	r7, #20
   19924:	cd08      	ldmia	r5!, {r3}
   19926:	ce02      	ldmia	r6!, {r1}
   19928:	041a      	lsls	r2, r3, #16
   1992a:	0c12      	lsrs	r2, r2, #16
   1992c:	1914      	adds	r4, r2, r4
   1992e:	040a      	lsls	r2, r1, #16
   19930:	0c12      	lsrs	r2, r2, #16
   19932:	1aa2      	subs	r2, r4, r2
   19934:	0c1c      	lsrs	r4, r3, #16
   19936:	0c0b      	lsrs	r3, r1, #16
   19938:	1ae3      	subs	r3, r4, r3
   1993a:	1414      	asrs	r4, r2, #16
   1993c:	191b      	adds	r3, r3, r4
   1993e:	0412      	lsls	r2, r2, #16
   19940:	0c12      	lsrs	r2, r2, #16
   19942:	141c      	asrs	r4, r3, #16
   19944:	3704      	adds	r7, #4
   19946:	041b      	lsls	r3, r3, #16
   19948:	4313      	orrs	r3, r2
   1994a:	1f3a      	subs	r2, r7, #4
   1994c:	6013      	str	r3, [r2, #0]
   1994e:	45b1      	cmp	r9, r6
   19950:	d8e8      	bhi.n	19924 <__mdiff+0x7c>
   19952:	45ac      	cmp	ip, r5
   19954:	d91c      	bls.n	19990 <__mdiff+0xe8>
   19956:	003e      	movs	r6, r7
   19958:	002a      	movs	r2, r5
   1995a:	ca08      	ldmia	r2!, {r3}
   1995c:	0419      	lsls	r1, r3, #16
   1995e:	0c09      	lsrs	r1, r1, #16
   19960:	1909      	adds	r1, r1, r4
   19962:	140c      	asrs	r4, r1, #16
   19964:	0c1b      	lsrs	r3, r3, #16
   19966:	191b      	adds	r3, r3, r4
   19968:	0409      	lsls	r1, r1, #16
   1996a:	141c      	asrs	r4, r3, #16
   1996c:	0c09      	lsrs	r1, r1, #16
   1996e:	041b      	lsls	r3, r3, #16
   19970:	430b      	orrs	r3, r1
   19972:	c608      	stmia	r6!, {r3}
   19974:	4594      	cmp	ip, r2
   19976:	d8f0      	bhi.n	1995a <__mdiff+0xb2>
   19978:	43ed      	mvns	r5, r5
   1997a:	4465      	add	r5, ip
   1997c:	08ad      	lsrs	r5, r5, #2
   1997e:	3501      	adds	r5, #1
   19980:	00ad      	lsls	r5, r5, #2
   19982:	197f      	adds	r7, r7, r5
   19984:	1f3a      	subs	r2, r7, #4
   19986:	2b00      	cmp	r3, #0
   19988:	d104      	bne.n	19994 <__mdiff+0xec>
   1998a:	3a04      	subs	r2, #4
   1998c:	6813      	ldr	r3, [r2, #0]
   1998e:	3801      	subs	r0, #1
   19990:	2b00      	cmp	r3, #0
   19992:	d0fa      	beq.n	1998a <__mdiff+0xe2>
   19994:	4643      	mov	r3, r8
   19996:	6118      	str	r0, [r3, #16]
   19998:	4640      	mov	r0, r8
   1999a:	bc0c      	pop	{r2, r3}
   1999c:	4690      	mov	r8, r2
   1999e:	4699      	mov	r9, r3
   199a0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   199a2:	2100      	movs	r1, #0
   199a4:	f7ff fce0 	bl	19368 <_Balloc>
   199a8:	2301      	movs	r3, #1
   199aa:	6103      	str	r3, [r0, #16]
   199ac:	2300      	movs	r3, #0
   199ae:	6143      	str	r3, [r0, #20]
   199b0:	e7f3      	b.n	1999a <__mdiff+0xf2>
   199b2:	2300      	movs	r3, #0
   199b4:	4666      	mov	r6, ip
   199b6:	4699      	mov	r9, r3
   199b8:	e7a3      	b.n	19902 <__mdiff+0x5a>
   199ba:	003e      	movs	r6, r7
   199bc:	0025      	movs	r5, r4
   199be:	3614      	adds	r6, #20
   199c0:	3514      	adds	r5, #20
   199c2:	e790      	b.n	198e6 <__mdiff+0x3e>

000199c4 <__ulp>:
   199c4:	4b10      	ldr	r3, [pc, #64]	; (19a08 <__ulp+0x44>)
   199c6:	b510      	push	{r4, lr}
   199c8:	4019      	ands	r1, r3
   199ca:	4b10      	ldr	r3, [pc, #64]	; (19a0c <__ulp+0x48>)
   199cc:	469c      	mov	ip, r3
   199ce:	4461      	add	r1, ip
   199d0:	2900      	cmp	r1, #0
   199d2:	dd04      	ble.n	199de <__ulp+0x1a>
   199d4:	2200      	movs	r2, #0
   199d6:	000b      	movs	r3, r1
   199d8:	0010      	movs	r0, r2
   199da:	0019      	movs	r1, r3
   199dc:	bd10      	pop	{r4, pc}
   199de:	4249      	negs	r1, r1
   199e0:	1509      	asrs	r1, r1, #20
   199e2:	2200      	movs	r2, #0
   199e4:	2300      	movs	r3, #0
   199e6:	2913      	cmp	r1, #19
   199e8:	dd08      	ble.n	199fc <__ulp+0x38>
   199ea:	3914      	subs	r1, #20
   199ec:	2001      	movs	r0, #1
   199ee:	291e      	cmp	r1, #30
   199f0:	dc02      	bgt.n	199f8 <__ulp+0x34>
   199f2:	241f      	movs	r4, #31
   199f4:	1a61      	subs	r1, r4, r1
   199f6:	4088      	lsls	r0, r1
   199f8:	0002      	movs	r2, r0
   199fa:	e7ed      	b.n	199d8 <__ulp+0x14>
   199fc:	2080      	movs	r0, #128	; 0x80
   199fe:	0300      	lsls	r0, r0, #12
   19a00:	4108      	asrs	r0, r1
   19a02:	0003      	movs	r3, r0
   19a04:	e7e8      	b.n	199d8 <__ulp+0x14>
   19a06:	46c0      	nop			; (mov r8, r8)
   19a08:	7ff00000 	.word	0x7ff00000
   19a0c:	fcc00000 	.word	0xfcc00000

00019a10 <__b2d>:
   19a10:	b5f0      	push	{r4, r5, r6, r7, lr}
   19a12:	464e      	mov	r6, r9
   19a14:	4645      	mov	r5, r8
   19a16:	4657      	mov	r7, sl
   19a18:	6904      	ldr	r4, [r0, #16]
   19a1a:	b4e0      	push	{r5, r6, r7}
   19a1c:	00a4      	lsls	r4, r4, #2
   19a1e:	0006      	movs	r6, r0
   19a20:	46a1      	mov	r9, r4
   19a22:	3614      	adds	r6, #20
   19a24:	44b1      	add	r9, r6
   19a26:	464b      	mov	r3, r9
   19a28:	4688      	mov	r8, r1
   19a2a:	1f1f      	subs	r7, r3, #4
   19a2c:	683d      	ldr	r5, [r7, #0]
   19a2e:	0028      	movs	r0, r5
   19a30:	f7ff fd5a 	bl	194e8 <__hi0bits>
   19a34:	2320      	movs	r3, #32
   19a36:	4641      	mov	r1, r8
   19a38:	1a1a      	subs	r2, r3, r0
   19a3a:	600a      	str	r2, [r1, #0]
   19a3c:	280a      	cmp	r0, #10
   19a3e:	dc20      	bgt.n	19a82 <__b2d+0x72>
   19a40:	210b      	movs	r1, #11
   19a42:	1a0b      	subs	r3, r1, r0
   19a44:	469a      	mov	sl, r3
   19a46:	002b      	movs	r3, r5
   19a48:	4652      	mov	r2, sl
   19a4a:	4926      	ldr	r1, [pc, #152]	; (19ae4 <__b2d+0xd4>)
   19a4c:	40d3      	lsrs	r3, r2
   19a4e:	4688      	mov	r8, r1
   19a50:	0019      	movs	r1, r3
   19a52:	4644      	mov	r4, r8
   19a54:	4321      	orrs	r1, r4
   19a56:	000b      	movs	r3, r1
   19a58:	2100      	movs	r1, #0
   19a5a:	468c      	mov	ip, r1
   19a5c:	42be      	cmp	r6, r7
   19a5e:	d204      	bcs.n	19a6a <__b2d+0x5a>
   19a60:	464c      	mov	r4, r9
   19a62:	3c08      	subs	r4, #8
   19a64:	6824      	ldr	r4, [r4, #0]
   19a66:	40d4      	lsrs	r4, r2
   19a68:	46a4      	mov	ip, r4
   19a6a:	3015      	adds	r0, #21
   19a6c:	4085      	lsls	r5, r0
   19a6e:	4661      	mov	r1, ip
   19a70:	4329      	orrs	r1, r5
   19a72:	000a      	movs	r2, r1
   19a74:	0010      	movs	r0, r2
   19a76:	0019      	movs	r1, r3
   19a78:	bc1c      	pop	{r2, r3, r4}
   19a7a:	4690      	mov	r8, r2
   19a7c:	4699      	mov	r9, r3
   19a7e:	46a2      	mov	sl, r4
   19a80:	bdf0      	pop	{r4, r5, r6, r7, pc}
   19a82:	42be      	cmp	r6, r7
   19a84:	d21b      	bcs.n	19abe <__b2d+0xae>
   19a86:	2208      	movs	r2, #8
   19a88:	4252      	negs	r2, r2
   19a8a:	4694      	mov	ip, r2
   19a8c:	44cc      	add	ip, r9
   19a8e:	4662      	mov	r2, ip
   19a90:	380b      	subs	r0, #11
   19a92:	6817      	ldr	r7, [r2, #0]
   19a94:	2800      	cmp	r0, #0
   19a96:	d016      	beq.n	19ac6 <__b2d+0xb6>
   19a98:	4085      	lsls	r5, r0
   19a9a:	1a19      	subs	r1, r3, r0
   19a9c:	4b11      	ldr	r3, [pc, #68]	; (19ae4 <__b2d+0xd4>)
   19a9e:	431d      	orrs	r5, r3
   19aa0:	003b      	movs	r3, r7
   19aa2:	40cb      	lsrs	r3, r1
   19aa4:	001c      	movs	r4, r3
   19aa6:	432c      	orrs	r4, r5
   19aa8:	0023      	movs	r3, r4
   19aaa:	4566      	cmp	r6, ip
   19aac:	d217      	bcs.n	19ade <__b2d+0xce>
   19aae:	464c      	mov	r4, r9
   19ab0:	3c0c      	subs	r4, #12
   19ab2:	6824      	ldr	r4, [r4, #0]
   19ab4:	4087      	lsls	r7, r0
   19ab6:	40cc      	lsrs	r4, r1
   19ab8:	4327      	orrs	r7, r4
   19aba:	003a      	movs	r2, r7
   19abc:	e7da      	b.n	19a74 <__b2d+0x64>
   19abe:	380b      	subs	r0, #11
   19ac0:	2700      	movs	r7, #0
   19ac2:	2800      	cmp	r0, #0
   19ac4:	d104      	bne.n	19ad0 <__b2d+0xc0>
   19ac6:	4907      	ldr	r1, [pc, #28]	; (19ae4 <__b2d+0xd4>)
   19ac8:	003a      	movs	r2, r7
   19aca:	4329      	orrs	r1, r5
   19acc:	000b      	movs	r3, r1
   19ace:	e7d1      	b.n	19a74 <__b2d+0x64>
   19ad0:	4085      	lsls	r5, r0
   19ad2:	2700      	movs	r7, #0
   19ad4:	4903      	ldr	r1, [pc, #12]	; (19ae4 <__b2d+0xd4>)
   19ad6:	003a      	movs	r2, r7
   19ad8:	4329      	orrs	r1, r5
   19ada:	000b      	movs	r3, r1
   19adc:	e7ca      	b.n	19a74 <__b2d+0x64>
   19ade:	4087      	lsls	r7, r0
   19ae0:	003a      	movs	r2, r7
   19ae2:	e7c7      	b.n	19a74 <__b2d+0x64>
   19ae4:	3ff00000 	.word	0x3ff00000

00019ae8 <__d2b>:
   19ae8:	b5f0      	push	{r4, r5, r6, r7, lr}
   19aea:	2101      	movs	r1, #1
   19aec:	001c      	movs	r4, r3
   19aee:	b083      	sub	sp, #12
   19af0:	9f08      	ldr	r7, [sp, #32]
   19af2:	0015      	movs	r5, r2
   19af4:	f7ff fc38 	bl	19368 <_Balloc>
   19af8:	0321      	lsls	r1, r4, #12
   19afa:	0064      	lsls	r4, r4, #1
   19afc:	0006      	movs	r6, r0
   19afe:	0b09      	lsrs	r1, r1, #12
   19b00:	0d64      	lsrs	r4, r4, #21
   19b02:	d002      	beq.n	19b0a <__d2b+0x22>
   19b04:	2380      	movs	r3, #128	; 0x80
   19b06:	035b      	lsls	r3, r3, #13
   19b08:	4319      	orrs	r1, r3
   19b0a:	9101      	str	r1, [sp, #4]
   19b0c:	2d00      	cmp	r5, #0
   19b0e:	d01a      	beq.n	19b46 <__d2b+0x5e>
   19b10:	4668      	mov	r0, sp
   19b12:	9500      	str	r5, [sp, #0]
   19b14:	f7ff fd06 	bl	19524 <__lo0bits>
   19b18:	2800      	cmp	r0, #0
   19b1a:	d131      	bne.n	19b80 <__d2b+0x98>
   19b1c:	9b00      	ldr	r3, [sp, #0]
   19b1e:	9d01      	ldr	r5, [sp, #4]
   19b20:	6173      	str	r3, [r6, #20]
   19b22:	61b5      	str	r5, [r6, #24]
   19b24:	426b      	negs	r3, r5
   19b26:	416b      	adcs	r3, r5
   19b28:	2502      	movs	r5, #2
   19b2a:	1aed      	subs	r5, r5, r3
   19b2c:	6135      	str	r5, [r6, #16]
   19b2e:	2c00      	cmp	r4, #0
   19b30:	d014      	beq.n	19b5c <__d2b+0x74>
   19b32:	4b19      	ldr	r3, [pc, #100]	; (19b98 <__d2b+0xb0>)
   19b34:	469c      	mov	ip, r3
   19b36:	2335      	movs	r3, #53	; 0x35
   19b38:	4464      	add	r4, ip
   19b3a:	1824      	adds	r4, r4, r0
   19b3c:	1a18      	subs	r0, r3, r0
   19b3e:	9b09      	ldr	r3, [sp, #36]	; 0x24
   19b40:	603c      	str	r4, [r7, #0]
   19b42:	6018      	str	r0, [r3, #0]
   19b44:	e019      	b.n	19b7a <__d2b+0x92>
   19b46:	a801      	add	r0, sp, #4
   19b48:	f7ff fcec 	bl	19524 <__lo0bits>
   19b4c:	9b01      	ldr	r3, [sp, #4]
   19b4e:	3020      	adds	r0, #32
   19b50:	6173      	str	r3, [r6, #20]
   19b52:	2301      	movs	r3, #1
   19b54:	2501      	movs	r5, #1
   19b56:	6133      	str	r3, [r6, #16]
   19b58:	2c00      	cmp	r4, #0
   19b5a:	d1ea      	bne.n	19b32 <__d2b+0x4a>
   19b5c:	4b0f      	ldr	r3, [pc, #60]	; (19b9c <__d2b+0xb4>)
   19b5e:	469c      	mov	ip, r3
   19b60:	4b0f      	ldr	r3, [pc, #60]	; (19ba0 <__d2b+0xb8>)
   19b62:	4460      	add	r0, ip
   19b64:	18eb      	adds	r3, r5, r3
   19b66:	009b      	lsls	r3, r3, #2
   19b68:	18f3      	adds	r3, r6, r3
   19b6a:	6038      	str	r0, [r7, #0]
   19b6c:	6958      	ldr	r0, [r3, #20]
   19b6e:	f7ff fcbb 	bl	194e8 <__hi0bits>
   19b72:	016d      	lsls	r5, r5, #5
   19b74:	9b09      	ldr	r3, [sp, #36]	; 0x24
   19b76:	1a28      	subs	r0, r5, r0
   19b78:	6018      	str	r0, [r3, #0]
   19b7a:	0030      	movs	r0, r6
   19b7c:	b003      	add	sp, #12
   19b7e:	bdf0      	pop	{r4, r5, r6, r7, pc}
   19b80:	9d01      	ldr	r5, [sp, #4]
   19b82:	2320      	movs	r3, #32
   19b84:	002a      	movs	r2, r5
   19b86:	1a1b      	subs	r3, r3, r0
   19b88:	409a      	lsls	r2, r3
   19b8a:	0013      	movs	r3, r2
   19b8c:	40c5      	lsrs	r5, r0
   19b8e:	9a00      	ldr	r2, [sp, #0]
   19b90:	9501      	str	r5, [sp, #4]
   19b92:	4313      	orrs	r3, r2
   19b94:	6173      	str	r3, [r6, #20]
   19b96:	e7c4      	b.n	19b22 <__d2b+0x3a>
   19b98:	fffffbcd 	.word	0xfffffbcd
   19b9c:	fffffbce 	.word	0xfffffbce
   19ba0:	3fffffff 	.word	0x3fffffff

00019ba4 <__ratio>:
   19ba4:	b5f0      	push	{r4, r5, r6, r7, lr}
   19ba6:	464f      	mov	r7, r9
   19ba8:	4646      	mov	r6, r8
   19baa:	b4c0      	push	{r6, r7}
   19bac:	b085      	sub	sp, #20
   19bae:	4688      	mov	r8, r1
   19bb0:	a902      	add	r1, sp, #8
   19bb2:	4681      	mov	r9, r0
   19bb4:	f7ff ff2c 	bl	19a10 <__b2d>
   19bb8:	0006      	movs	r6, r0
   19bba:	000f      	movs	r7, r1
   19bbc:	4640      	mov	r0, r8
   19bbe:	a903      	add	r1, sp, #12
   19bc0:	f7ff ff26 	bl	19a10 <__b2d>
   19bc4:	464b      	mov	r3, r9
   19bc6:	691b      	ldr	r3, [r3, #16]
   19bc8:	9000      	str	r0, [sp, #0]
   19bca:	9101      	str	r1, [sp, #4]
   19bcc:	469c      	mov	ip, r3
   19bce:	4643      	mov	r3, r8
   19bd0:	691b      	ldr	r3, [r3, #16]
   19bd2:	4698      	mov	r8, r3
   19bd4:	4663      	mov	r3, ip
   19bd6:	4642      	mov	r2, r8
   19bd8:	1a9b      	subs	r3, r3, r2
   19bda:	015b      	lsls	r3, r3, #5
   19bdc:	469c      	mov	ip, r3
   19bde:	9a03      	ldr	r2, [sp, #12]
   19be0:	9b02      	ldr	r3, [sp, #8]
   19be2:	1a9b      	subs	r3, r3, r2
   19be4:	4698      	mov	r8, r3
   19be6:	44c4      	add	ip, r8
   19be8:	4663      	mov	r3, ip
   19bea:	2b00      	cmp	r3, #0
   19bec:	dd0d      	ble.n	19c0a <__ratio+0x66>
   19bee:	051b      	lsls	r3, r3, #20
   19bf0:	19dd      	adds	r5, r3, r7
   19bf2:	002f      	movs	r7, r5
   19bf4:	0002      	movs	r2, r0
   19bf6:	000b      	movs	r3, r1
   19bf8:	0030      	movs	r0, r6
   19bfa:	0039      	movs	r1, r7
   19bfc:	f004 fd7e 	bl	1e6fc <__aeabi_ddiv>
   19c00:	b005      	add	sp, #20
   19c02:	bc0c      	pop	{r2, r3}
   19c04:	4690      	mov	r8, r2
   19c06:	4699      	mov	r9, r3
   19c08:	bdf0      	pop	{r4, r5, r6, r7, pc}
   19c0a:	4663      	mov	r3, ip
   19c0c:	0518      	lsls	r0, r3, #20
   19c0e:	1a0b      	subs	r3, r1, r0
   19c10:	9301      	str	r3, [sp, #4]
   19c12:	9800      	ldr	r0, [sp, #0]
   19c14:	9901      	ldr	r1, [sp, #4]
   19c16:	e7ed      	b.n	19bf4 <__ratio+0x50>

00019c18 <_mprec_log10>:
   19c18:	b510      	push	{r4, lr}
   19c1a:	0004      	movs	r4, r0
   19c1c:	2817      	cmp	r0, #23
   19c1e:	dd09      	ble.n	19c34 <_mprec_log10+0x1c>
   19c20:	2000      	movs	r0, #0
   19c22:	4907      	ldr	r1, [pc, #28]	; (19c40 <_mprec_log10+0x28>)
   19c24:	2200      	movs	r2, #0
   19c26:	4b07      	ldr	r3, [pc, #28]	; (19c44 <_mprec_log10+0x2c>)
   19c28:	3c01      	subs	r4, #1
   19c2a:	f005 f98b 	bl	1ef44 <__aeabi_dmul>
   19c2e:	2c00      	cmp	r4, #0
   19c30:	d1f8      	bne.n	19c24 <_mprec_log10+0xc>
   19c32:	bd10      	pop	{r4, pc}
   19c34:	4b04      	ldr	r3, [pc, #16]	; (19c48 <_mprec_log10+0x30>)
   19c36:	00c4      	lsls	r4, r0, #3
   19c38:	191c      	adds	r4, r3, r4
   19c3a:	6820      	ldr	r0, [r4, #0]
   19c3c:	6861      	ldr	r1, [r4, #4]
   19c3e:	e7f8      	b.n	19c32 <_mprec_log10+0x1a>
   19c40:	3ff00000 	.word	0x3ff00000
   19c44:	40240000 	.word	0x40240000
   19c48:	00022da0 	.word	0x00022da0

00019c4c <__copybits>:
   19c4c:	0013      	movs	r3, r2
   19c4e:	b570      	push	{r4, r5, r6, lr}
   19c50:	1e4c      	subs	r4, r1, #1
   19c52:	6911      	ldr	r1, [r2, #16]
   19c54:	1164      	asrs	r4, r4, #5
   19c56:	3401      	adds	r4, #1
   19c58:	3314      	adds	r3, #20
   19c5a:	0089      	lsls	r1, r1, #2
   19c5c:	00a4      	lsls	r4, r4, #2
   19c5e:	1859      	adds	r1, r3, r1
   19c60:	1904      	adds	r4, r0, r4
   19c62:	428b      	cmp	r3, r1
   19c64:	d20a      	bcs.n	19c7c <__copybits+0x30>
   19c66:	0005      	movs	r5, r0
   19c68:	cb40      	ldmia	r3!, {r6}
   19c6a:	c540      	stmia	r5!, {r6}
   19c6c:	4299      	cmp	r1, r3
   19c6e:	d8fb      	bhi.n	19c68 <__copybits+0x1c>
   19c70:	1a89      	subs	r1, r1, r2
   19c72:	3915      	subs	r1, #21
   19c74:	0889      	lsrs	r1, r1, #2
   19c76:	3101      	adds	r1, #1
   19c78:	0089      	lsls	r1, r1, #2
   19c7a:	1840      	adds	r0, r0, r1
   19c7c:	2300      	movs	r3, #0
   19c7e:	4284      	cmp	r4, r0
   19c80:	d902      	bls.n	19c88 <__copybits+0x3c>
   19c82:	c008      	stmia	r0!, {r3}
   19c84:	4284      	cmp	r4, r0
   19c86:	d8fc      	bhi.n	19c82 <__copybits+0x36>
   19c88:	bd70      	pop	{r4, r5, r6, pc}
   19c8a:	46c0      	nop			; (mov r8, r8)

00019c8c <__any_on>:
   19c8c:	0002      	movs	r2, r0
   19c8e:	6903      	ldr	r3, [r0, #16]
   19c90:	b510      	push	{r4, lr}
   19c92:	3214      	adds	r2, #20
   19c94:	1148      	asrs	r0, r1, #5
   19c96:	4283      	cmp	r3, r0
   19c98:	da0f      	bge.n	19cba <__any_on+0x2e>
   19c9a:	009b      	lsls	r3, r3, #2
   19c9c:	18d3      	adds	r3, r2, r3
   19c9e:	429a      	cmp	r2, r3
   19ca0:	d221      	bcs.n	19ce6 <__any_on+0x5a>
   19ca2:	3b04      	subs	r3, #4
   19ca4:	6818      	ldr	r0, [r3, #0]
   19ca6:	2800      	cmp	r0, #0
   19ca8:	d004      	beq.n	19cb4 <__any_on+0x28>
   19caa:	e01a      	b.n	19ce2 <__any_on+0x56>
   19cac:	3b04      	subs	r3, #4
   19cae:	6819      	ldr	r1, [r3, #0]
   19cb0:	2900      	cmp	r1, #0
   19cb2:	d116      	bne.n	19ce2 <__any_on+0x56>
   19cb4:	429a      	cmp	r2, r3
   19cb6:	d3f9      	bcc.n	19cac <__any_on+0x20>
   19cb8:	bd10      	pop	{r4, pc}
   19cba:	4283      	cmp	r3, r0
   19cbc:	dd0e      	ble.n	19cdc <__any_on+0x50>
   19cbe:	231f      	movs	r3, #31
   19cc0:	4019      	ands	r1, r3
   19cc2:	0083      	lsls	r3, r0, #2
   19cc4:	18d3      	adds	r3, r2, r3
   19cc6:	2900      	cmp	r1, #0
   19cc8:	d0e9      	beq.n	19c9e <__any_on+0x12>
   19cca:	681c      	ldr	r4, [r3, #0]
   19ccc:	0020      	movs	r0, r4
   19cce:	40c8      	lsrs	r0, r1
   19cd0:	4088      	lsls	r0, r1
   19cd2:	0001      	movs	r1, r0
   19cd4:	2001      	movs	r0, #1
   19cd6:	428c      	cmp	r4, r1
   19cd8:	d1ee      	bne.n	19cb8 <__any_on+0x2c>
   19cda:	e7e0      	b.n	19c9e <__any_on+0x12>
   19cdc:	0083      	lsls	r3, r0, #2
   19cde:	18d3      	adds	r3, r2, r3
   19ce0:	e7dd      	b.n	19c9e <__any_on+0x12>
   19ce2:	2001      	movs	r0, #1
   19ce4:	e7e8      	b.n	19cb8 <__any_on+0x2c>
   19ce6:	2000      	movs	r0, #0
   19ce8:	e7e6      	b.n	19cb8 <__any_on+0x2c>
   19cea:	46c0      	nop			; (mov r8, r8)

00019cec <_realloc_r>:
   19cec:	b5f0      	push	{r4, r5, r6, r7, lr}
   19cee:	4656      	mov	r6, sl
   19cf0:	464d      	mov	r5, r9
   19cf2:	4644      	mov	r4, r8
   19cf4:	465f      	mov	r7, fp
   19cf6:	b4f0      	push	{r4, r5, r6, r7}
   19cf8:	4680      	mov	r8, r0
   19cfa:	b085      	sub	sp, #20
   19cfc:	1e0e      	subs	r6, r1, #0
   19cfe:	4691      	mov	r9, r2
   19d00:	d100      	bne.n	19d04 <_realloc_r+0x18>
   19d02:	e0cb      	b.n	19e9c <_realloc_r+0x1b0>
   19d04:	0037      	movs	r7, r6
   19d06:	3f08      	subs	r7, #8
   19d08:	f7fb fee6 	bl	15ad8 <__malloc_lock>
   19d0c:	687a      	ldr	r2, [r7, #4]
   19d0e:	464d      	mov	r5, r9
   19d10:	2303      	movs	r3, #3
   19d12:	0014      	movs	r4, r2
   19d14:	350b      	adds	r5, #11
   19d16:	46ba      	mov	sl, r7
   19d18:	439c      	bics	r4, r3
   19d1a:	2d16      	cmp	r5, #22
   19d1c:	d84a      	bhi.n	19db4 <_realloc_r+0xc8>
   19d1e:	2310      	movs	r3, #16
   19d20:	2510      	movs	r5, #16
   19d22:	45a9      	cmp	r9, r5
   19d24:	d84a      	bhi.n	19dbc <_realloc_r+0xd0>
   19d26:	429c      	cmp	r4, r3
   19d28:	da7b      	bge.n	19e22 <_realloc_r+0x136>
   19d2a:	49d3      	ldr	r1, [pc, #844]	; (1a078 <_realloc_r+0x38c>)
   19d2c:	1938      	adds	r0, r7, r4
   19d2e:	6889      	ldr	r1, [r1, #8]
   19d30:	9001      	str	r0, [sp, #4]
   19d32:	4288      	cmp	r0, r1
   19d34:	d100      	bne.n	19d38 <_realloc_r+0x4c>
   19d36:	e0ec      	b.n	19f12 <_realloc_r+0x226>
   19d38:	6840      	ldr	r0, [r0, #4]
   19d3a:	0001      	movs	r1, r0
   19d3c:	9002      	str	r0, [sp, #8]
   19d3e:	2001      	movs	r0, #1
   19d40:	9003      	str	r0, [sp, #12]
   19d42:	0008      	movs	r0, r1
   19d44:	2101      	movs	r1, #1
   19d46:	4388      	bics	r0, r1
   19d48:	9901      	ldr	r1, [sp, #4]
   19d4a:	4684      	mov	ip, r0
   19d4c:	468b      	mov	fp, r1
   19d4e:	44dc      	add	ip, fp
   19d50:	4661      	mov	r1, ip
   19d52:	2001      	movs	r0, #1
   19d54:	6849      	ldr	r1, [r1, #4]
   19d56:	4201      	tst	r1, r0
   19d58:	d100      	bne.n	19d5c <_realloc_r+0x70>
   19d5a:	e07c      	b.n	19e56 <_realloc_r+0x16a>
   19d5c:	2101      	movs	r1, #1
   19d5e:	4211      	tst	r1, r2
   19d60:	d031      	beq.n	19dc6 <_realloc_r+0xda>
   19d62:	4649      	mov	r1, r9
   19d64:	4640      	mov	r0, r8
   19d66:	f7fb fb61 	bl	1542c <_malloc_r>
   19d6a:	4681      	mov	r9, r0
   19d6c:	2800      	cmp	r0, #0
   19d6e:	d100      	bne.n	19d72 <_realloc_r+0x86>
   19d70:	e19c      	b.n	1a0ac <_realloc_r+0x3c0>
   19d72:	2301      	movs	r3, #1
   19d74:	0002      	movs	r2, r0
   19d76:	6879      	ldr	r1, [r7, #4]
   19d78:	3a08      	subs	r2, #8
   19d7a:	4399      	bics	r1, r3
   19d7c:	187f      	adds	r7, r7, r1
   19d7e:	42ba      	cmp	r2, r7
   19d80:	d100      	bne.n	19d84 <_realloc_r+0x98>
   19d82:	e13c      	b.n	19ffe <_realloc_r+0x312>
   19d84:	1f22      	subs	r2, r4, #4
   19d86:	2a24      	cmp	r2, #36	; 0x24
   19d88:	d900      	bls.n	19d8c <_realloc_r+0xa0>
   19d8a:	e129      	b.n	19fe0 <_realloc_r+0x2f4>
   19d8c:	0003      	movs	r3, r0
   19d8e:	2a13      	cmp	r2, #19
   19d90:	d900      	bls.n	19d94 <_realloc_r+0xa8>
   19d92:	e10b      	b.n	19fac <_realloc_r+0x2c0>
   19d94:	0032      	movs	r2, r6
   19d96:	6811      	ldr	r1, [r2, #0]
   19d98:	6019      	str	r1, [r3, #0]
   19d9a:	6851      	ldr	r1, [r2, #4]
   19d9c:	6059      	str	r1, [r3, #4]
   19d9e:	6892      	ldr	r2, [r2, #8]
   19da0:	609a      	str	r2, [r3, #8]
   19da2:	0031      	movs	r1, r6
   19da4:	4640      	mov	r0, r8
   19da6:	f7fe ff01 	bl	18bac <_free_r>
   19daa:	4640      	mov	r0, r8
   19dac:	f7fb fe96 	bl	15adc <__malloc_unlock>
   19db0:	4648      	mov	r0, r9
   19db2:	e049      	b.n	19e48 <_realloc_r+0x15c>
   19db4:	3304      	adds	r3, #4
   19db6:	439d      	bics	r5, r3
   19db8:	1e2b      	subs	r3, r5, #0
   19dba:	dab2      	bge.n	19d22 <_realloc_r+0x36>
   19dbc:	230c      	movs	r3, #12
   19dbe:	4642      	mov	r2, r8
   19dc0:	2000      	movs	r0, #0
   19dc2:	6013      	str	r3, [r2, #0]
   19dc4:	e040      	b.n	19e48 <_realloc_r+0x15c>
   19dc6:	683a      	ldr	r2, [r7, #0]
   19dc8:	1aba      	subs	r2, r7, r2
   19dca:	4693      	mov	fp, r2
   19dcc:	4659      	mov	r1, fp
   19dce:	2203      	movs	r2, #3
   19dd0:	6849      	ldr	r1, [r1, #4]
   19dd2:	4391      	bics	r1, r2
   19dd4:	000a      	movs	r2, r1
   19dd6:	18a2      	adds	r2, r4, r2
   19dd8:	9201      	str	r2, [sp, #4]
   19dda:	429a      	cmp	r2, r3
   19ddc:	dbc1      	blt.n	19d62 <_realloc_r+0x76>
   19dde:	465b      	mov	r3, fp
   19de0:	465a      	mov	r2, fp
   19de2:	465f      	mov	r7, fp
   19de4:	6892      	ldr	r2, [r2, #8]
   19de6:	68db      	ldr	r3, [r3, #12]
   19de8:	3708      	adds	r7, #8
   19dea:	60d3      	str	r3, [r2, #12]
   19dec:	609a      	str	r2, [r3, #8]
   19dee:	1f22      	subs	r2, r4, #4
   19df0:	2a24      	cmp	r2, #36	; 0x24
   19df2:	d900      	bls.n	19df6 <_realloc_r+0x10a>
   19df4:	e110      	b.n	1a018 <_realloc_r+0x32c>
   19df6:	003b      	movs	r3, r7
   19df8:	2a13      	cmp	r2, #19
   19dfa:	d909      	bls.n	19e10 <_realloc_r+0x124>
   19dfc:	465b      	mov	r3, fp
   19dfe:	6831      	ldr	r1, [r6, #0]
   19e00:	6099      	str	r1, [r3, #8]
   19e02:	6871      	ldr	r1, [r6, #4]
   19e04:	60d9      	str	r1, [r3, #12]
   19e06:	2a1b      	cmp	r2, #27
   19e08:	d900      	bls.n	19e0c <_realloc_r+0x120>
   19e0a:	e121      	b.n	1a050 <_realloc_r+0x364>
   19e0c:	3310      	adds	r3, #16
   19e0e:	3608      	adds	r6, #8
   19e10:	6832      	ldr	r2, [r6, #0]
   19e12:	46da      	mov	sl, fp
   19e14:	601a      	str	r2, [r3, #0]
   19e16:	6872      	ldr	r2, [r6, #4]
   19e18:	9c01      	ldr	r4, [sp, #4]
   19e1a:	605a      	str	r2, [r3, #4]
   19e1c:	68b2      	ldr	r2, [r6, #8]
   19e1e:	003e      	movs	r6, r7
   19e20:	609a      	str	r2, [r3, #8]
   19e22:	1b63      	subs	r3, r4, r5
   19e24:	2b0f      	cmp	r3, #15
   19e26:	d824      	bhi.n	19e72 <_realloc_r+0x186>
   19e28:	4653      	mov	r3, sl
   19e2a:	2101      	movs	r1, #1
   19e2c:	4652      	mov	r2, sl
   19e2e:	685b      	ldr	r3, [r3, #4]
   19e30:	400b      	ands	r3, r1
   19e32:	4323      	orrs	r3, r4
   19e34:	6053      	str	r3, [r2, #4]
   19e36:	0022      	movs	r2, r4
   19e38:	4452      	add	r2, sl
   19e3a:	6853      	ldr	r3, [r2, #4]
   19e3c:	4319      	orrs	r1, r3
   19e3e:	6051      	str	r1, [r2, #4]
   19e40:	4640      	mov	r0, r8
   19e42:	f7fb fe4b 	bl	15adc <__malloc_unlock>
   19e46:	0030      	movs	r0, r6
   19e48:	b005      	add	sp, #20
   19e4a:	bc3c      	pop	{r2, r3, r4, r5}
   19e4c:	4690      	mov	r8, r2
   19e4e:	4699      	mov	r9, r3
   19e50:	46a2      	mov	sl, r4
   19e52:	46ab      	mov	fp, r5
   19e54:	bdf0      	pop	{r4, r5, r6, r7, pc}
   19e56:	2103      	movs	r1, #3
   19e58:	9802      	ldr	r0, [sp, #8]
   19e5a:	468c      	mov	ip, r1
   19e5c:	4388      	bics	r0, r1
   19e5e:	1901      	adds	r1, r0, r4
   19e60:	4299      	cmp	r1, r3
   19e62:	db1f      	blt.n	19ea4 <_realloc_r+0x1b8>
   19e64:	9a01      	ldr	r2, [sp, #4]
   19e66:	000c      	movs	r4, r1
   19e68:	68d3      	ldr	r3, [r2, #12]
   19e6a:	6892      	ldr	r2, [r2, #8]
   19e6c:	60d3      	str	r3, [r2, #12]
   19e6e:	609a      	str	r2, [r3, #8]
   19e70:	e7d7      	b.n	19e22 <_realloc_r+0x136>
   19e72:	4652      	mov	r2, sl
   19e74:	4650      	mov	r0, sl
   19e76:	1951      	adds	r1, r2, r5
   19e78:	2201      	movs	r2, #1
   19e7a:	6840      	ldr	r0, [r0, #4]
   19e7c:	4010      	ands	r0, r2
   19e7e:	4305      	orrs	r5, r0
   19e80:	4650      	mov	r0, sl
   19e82:	6045      	str	r5, [r0, #4]
   19e84:	0018      	movs	r0, r3
   19e86:	4310      	orrs	r0, r2
   19e88:	18cb      	adds	r3, r1, r3
   19e8a:	6048      	str	r0, [r1, #4]
   19e8c:	6858      	ldr	r0, [r3, #4]
   19e8e:	3108      	adds	r1, #8
   19e90:	4302      	orrs	r2, r0
   19e92:	605a      	str	r2, [r3, #4]
   19e94:	4640      	mov	r0, r8
   19e96:	f7fe fe89 	bl	18bac <_free_r>
   19e9a:	e7d1      	b.n	19e40 <_realloc_r+0x154>
   19e9c:	0011      	movs	r1, r2
   19e9e:	f7fb fac5 	bl	1542c <_malloc_r>
   19ea2:	e7d1      	b.n	19e48 <_realloc_r+0x15c>
   19ea4:	2001      	movs	r0, #1
   19ea6:	4210      	tst	r0, r2
   19ea8:	d000      	beq.n	19eac <_realloc_r+0x1c0>
   19eaa:	e75a      	b.n	19d62 <_realloc_r+0x76>
   19eac:	4660      	mov	r0, ip
   19eae:	683a      	ldr	r2, [r7, #0]
   19eb0:	1aba      	subs	r2, r7, r2
   19eb2:	4693      	mov	fp, r2
   19eb4:	6852      	ldr	r2, [r2, #4]
   19eb6:	4382      	bics	r2, r0
   19eb8:	1889      	adds	r1, r1, r2
   19eba:	9102      	str	r1, [sp, #8]
   19ebc:	4299      	cmp	r1, r3
   19ebe:	da00      	bge.n	19ec2 <_realloc_r+0x1d6>
   19ec0:	e789      	b.n	19dd6 <_realloc_r+0xea>
   19ec2:	9a01      	ldr	r2, [sp, #4]
   19ec4:	465f      	mov	r7, fp
   19ec6:	68d3      	ldr	r3, [r2, #12]
   19ec8:	6892      	ldr	r2, [r2, #8]
   19eca:	3708      	adds	r7, #8
   19ecc:	60d3      	str	r3, [r2, #12]
   19ece:	609a      	str	r2, [r3, #8]
   19ed0:	465b      	mov	r3, fp
   19ed2:	465a      	mov	r2, fp
   19ed4:	68db      	ldr	r3, [r3, #12]
   19ed6:	6892      	ldr	r2, [r2, #8]
   19ed8:	60d3      	str	r3, [r2, #12]
   19eda:	609a      	str	r2, [r3, #8]
   19edc:	1f22      	subs	r2, r4, #4
   19ede:	2a24      	cmp	r2, #36	; 0x24
   19ee0:	d900      	bls.n	19ee4 <_realloc_r+0x1f8>
   19ee2:	e091      	b.n	1a008 <_realloc_r+0x31c>
   19ee4:	003b      	movs	r3, r7
   19ee6:	2a13      	cmp	r2, #19
   19ee8:	d909      	bls.n	19efe <_realloc_r+0x212>
   19eea:	465b      	mov	r3, fp
   19eec:	6831      	ldr	r1, [r6, #0]
   19eee:	6099      	str	r1, [r3, #8]
   19ef0:	6871      	ldr	r1, [r6, #4]
   19ef2:	60d9      	str	r1, [r3, #12]
   19ef4:	2a1b      	cmp	r2, #27
   19ef6:	d900      	bls.n	19efa <_realloc_r+0x20e>
   19ef8:	e096      	b.n	1a028 <_realloc_r+0x33c>
   19efa:	3310      	adds	r3, #16
   19efc:	3608      	adds	r6, #8
   19efe:	6832      	ldr	r2, [r6, #0]
   19f00:	9c02      	ldr	r4, [sp, #8]
   19f02:	601a      	str	r2, [r3, #0]
   19f04:	6872      	ldr	r2, [r6, #4]
   19f06:	46da      	mov	sl, fp
   19f08:	605a      	str	r2, [r3, #4]
   19f0a:	68b2      	ldr	r2, [r6, #8]
   19f0c:	003e      	movs	r6, r7
   19f0e:	609a      	str	r2, [r3, #8]
   19f10:	e787      	b.n	19e22 <_realloc_r+0x136>
   19f12:	2003      	movs	r0, #3
   19f14:	9901      	ldr	r1, [sp, #4]
   19f16:	4684      	mov	ip, r0
   19f18:	6849      	ldr	r1, [r1, #4]
   19f1a:	4381      	bics	r1, r0
   19f1c:	0028      	movs	r0, r5
   19f1e:	1909      	adds	r1, r1, r4
   19f20:	3010      	adds	r0, #16
   19f22:	9001      	str	r0, [sp, #4]
   19f24:	4281      	cmp	r1, r0
   19f26:	da4b      	bge.n	19fc0 <_realloc_r+0x2d4>
   19f28:	07d2      	lsls	r2, r2, #31
   19f2a:	d500      	bpl.n	19f2e <_realloc_r+0x242>
   19f2c:	e719      	b.n	19d62 <_realloc_r+0x76>
   19f2e:	4660      	mov	r0, ip
   19f30:	683a      	ldr	r2, [r7, #0]
   19f32:	1aba      	subs	r2, r7, r2
   19f34:	4693      	mov	fp, r2
   19f36:	6852      	ldr	r2, [r2, #4]
   19f38:	4382      	bics	r2, r0
   19f3a:	9801      	ldr	r0, [sp, #4]
   19f3c:	1851      	adds	r1, r2, r1
   19f3e:	9102      	str	r1, [sp, #8]
   19f40:	4288      	cmp	r0, r1
   19f42:	dd00      	ble.n	19f46 <_realloc_r+0x25a>
   19f44:	e747      	b.n	19dd6 <_realloc_r+0xea>
   19f46:	465b      	mov	r3, fp
   19f48:	465a      	mov	r2, fp
   19f4a:	465f      	mov	r7, fp
   19f4c:	6892      	ldr	r2, [r2, #8]
   19f4e:	68db      	ldr	r3, [r3, #12]
   19f50:	3708      	adds	r7, #8
   19f52:	60d3      	str	r3, [r2, #12]
   19f54:	609a      	str	r2, [r3, #8]
   19f56:	1f22      	subs	r2, r4, #4
   19f58:	2a24      	cmp	r2, #36	; 0x24
   19f5a:	d900      	bls.n	19f5e <_realloc_r+0x272>
   19f5c:	e097      	b.n	1a08e <_realloc_r+0x3a2>
   19f5e:	003b      	movs	r3, r7
   19f60:	2a13      	cmp	r2, #19
   19f62:	d909      	bls.n	19f78 <_realloc_r+0x28c>
   19f64:	465b      	mov	r3, fp
   19f66:	6831      	ldr	r1, [r6, #0]
   19f68:	6099      	str	r1, [r3, #8]
   19f6a:	6871      	ldr	r1, [r6, #4]
   19f6c:	60d9      	str	r1, [r3, #12]
   19f6e:	2a1b      	cmp	r2, #27
   19f70:	d900      	bls.n	19f74 <_realloc_r+0x288>
   19f72:	e091      	b.n	1a098 <_realloc_r+0x3ac>
   19f74:	3310      	adds	r3, #16
   19f76:	3608      	adds	r6, #8
   19f78:	6832      	ldr	r2, [r6, #0]
   19f7a:	601a      	str	r2, [r3, #0]
   19f7c:	6872      	ldr	r2, [r6, #4]
   19f7e:	605a      	str	r2, [r3, #4]
   19f80:	68b2      	ldr	r2, [r6, #8]
   19f82:	609a      	str	r2, [r3, #8]
   19f84:	465b      	mov	r3, fp
   19f86:	1959      	adds	r1, r3, r5
   19f88:	4b3b      	ldr	r3, [pc, #236]	; (1a078 <_realloc_r+0x38c>)
   19f8a:	4640      	mov	r0, r8
   19f8c:	6099      	str	r1, [r3, #8]
   19f8e:	9b02      	ldr	r3, [sp, #8]
   19f90:	1b5a      	subs	r2, r3, r5
   19f92:	2301      	movs	r3, #1
   19f94:	431a      	orrs	r2, r3
   19f96:	604a      	str	r2, [r1, #4]
   19f98:	465a      	mov	r2, fp
   19f9a:	6852      	ldr	r2, [r2, #4]
   19f9c:	4013      	ands	r3, r2
   19f9e:	431d      	orrs	r5, r3
   19fa0:	465b      	mov	r3, fp
   19fa2:	605d      	str	r5, [r3, #4]
   19fa4:	f7fb fd9a 	bl	15adc <__malloc_unlock>
   19fa8:	0038      	movs	r0, r7
   19faa:	e74d      	b.n	19e48 <_realloc_r+0x15c>
   19fac:	6831      	ldr	r1, [r6, #0]
   19fae:	6001      	str	r1, [r0, #0]
   19fb0:	6871      	ldr	r1, [r6, #4]
   19fb2:	6041      	str	r1, [r0, #4]
   19fb4:	2a1b      	cmp	r2, #27
   19fb6:	d817      	bhi.n	19fe8 <_realloc_r+0x2fc>
   19fb8:	0032      	movs	r2, r6
   19fba:	3308      	adds	r3, #8
   19fbc:	3208      	adds	r2, #8
   19fbe:	e6ea      	b.n	19d96 <_realloc_r+0xaa>
   19fc0:	4b2d      	ldr	r3, [pc, #180]	; (1a078 <_realloc_r+0x38c>)
   19fc2:	197a      	adds	r2, r7, r5
   19fc4:	609a      	str	r2, [r3, #8]
   19fc6:	2301      	movs	r3, #1
   19fc8:	1b49      	subs	r1, r1, r5
   19fca:	4319      	orrs	r1, r3
   19fcc:	6051      	str	r1, [r2, #4]
   19fce:	687a      	ldr	r2, [r7, #4]
   19fd0:	4640      	mov	r0, r8
   19fd2:	4013      	ands	r3, r2
   19fd4:	431d      	orrs	r5, r3
   19fd6:	607d      	str	r5, [r7, #4]
   19fd8:	f7fb fd80 	bl	15adc <__malloc_unlock>
   19fdc:	0030      	movs	r0, r6
   19fde:	e733      	b.n	19e48 <_realloc_r+0x15c>
   19fe0:	0031      	movs	r1, r6
   19fe2:	f7ff f975 	bl	192d0 <memmove>
   19fe6:	e6dc      	b.n	19da2 <_realloc_r+0xb6>
   19fe8:	68b1      	ldr	r1, [r6, #8]
   19fea:	0003      	movs	r3, r0
   19fec:	6081      	str	r1, [r0, #8]
   19fee:	68f1      	ldr	r1, [r6, #12]
   19ff0:	60c1      	str	r1, [r0, #12]
   19ff2:	2a24      	cmp	r2, #36	; 0x24
   19ff4:	d022      	beq.n	1a03c <_realloc_r+0x350>
   19ff6:	0032      	movs	r2, r6
   19ff8:	3310      	adds	r3, #16
   19ffa:	3210      	adds	r2, #16
   19ffc:	e6cb      	b.n	19d96 <_realloc_r+0xaa>
   19ffe:	6853      	ldr	r3, [r2, #4]
   1a000:	2203      	movs	r2, #3
   1a002:	4393      	bics	r3, r2
   1a004:	18e4      	adds	r4, r4, r3
   1a006:	e70c      	b.n	19e22 <_realloc_r+0x136>
   1a008:	0031      	movs	r1, r6
   1a00a:	0038      	movs	r0, r7
   1a00c:	f7ff f960 	bl	192d0 <memmove>
   1a010:	003e      	movs	r6, r7
   1a012:	9c02      	ldr	r4, [sp, #8]
   1a014:	46da      	mov	sl, fp
   1a016:	e704      	b.n	19e22 <_realloc_r+0x136>
   1a018:	0031      	movs	r1, r6
   1a01a:	0038      	movs	r0, r7
   1a01c:	f7ff f958 	bl	192d0 <memmove>
   1a020:	003e      	movs	r6, r7
   1a022:	9c01      	ldr	r4, [sp, #4]
   1a024:	46da      	mov	sl, fp
   1a026:	e6fc      	b.n	19e22 <_realloc_r+0x136>
   1a028:	465b      	mov	r3, fp
   1a02a:	68b1      	ldr	r1, [r6, #8]
   1a02c:	6119      	str	r1, [r3, #16]
   1a02e:	68f1      	ldr	r1, [r6, #12]
   1a030:	6159      	str	r1, [r3, #20]
   1a032:	2a24      	cmp	r2, #36	; 0x24
   1a034:	d016      	beq.n	1a064 <_realloc_r+0x378>
   1a036:	3318      	adds	r3, #24
   1a038:	3610      	adds	r6, #16
   1a03a:	e760      	b.n	19efe <_realloc_r+0x212>
   1a03c:	6932      	ldr	r2, [r6, #16]
   1a03e:	0003      	movs	r3, r0
   1a040:	6102      	str	r2, [r0, #16]
   1a042:	0001      	movs	r1, r0
   1a044:	0032      	movs	r2, r6
   1a046:	6970      	ldr	r0, [r6, #20]
   1a048:	3318      	adds	r3, #24
   1a04a:	3218      	adds	r2, #24
   1a04c:	6148      	str	r0, [r1, #20]
   1a04e:	e6a2      	b.n	19d96 <_realloc_r+0xaa>
   1a050:	465b      	mov	r3, fp
   1a052:	68b1      	ldr	r1, [r6, #8]
   1a054:	6119      	str	r1, [r3, #16]
   1a056:	68f1      	ldr	r1, [r6, #12]
   1a058:	6159      	str	r1, [r3, #20]
   1a05a:	2a24      	cmp	r2, #36	; 0x24
   1a05c:	d00e      	beq.n	1a07c <_realloc_r+0x390>
   1a05e:	3318      	adds	r3, #24
   1a060:	3610      	adds	r6, #16
   1a062:	e6d5      	b.n	19e10 <_realloc_r+0x124>
   1a064:	465b      	mov	r3, fp
   1a066:	6932      	ldr	r2, [r6, #16]
   1a068:	619a      	str	r2, [r3, #24]
   1a06a:	465a      	mov	r2, fp
   1a06c:	6971      	ldr	r1, [r6, #20]
   1a06e:	3320      	adds	r3, #32
   1a070:	61d1      	str	r1, [r2, #28]
   1a072:	3618      	adds	r6, #24
   1a074:	e743      	b.n	19efe <_realloc_r+0x212>
   1a076:	46c0      	nop			; (mov r8, r8)
   1a078:	100105b8 	.word	0x100105b8
   1a07c:	465b      	mov	r3, fp
   1a07e:	6932      	ldr	r2, [r6, #16]
   1a080:	619a      	str	r2, [r3, #24]
   1a082:	465a      	mov	r2, fp
   1a084:	6971      	ldr	r1, [r6, #20]
   1a086:	3320      	adds	r3, #32
   1a088:	61d1      	str	r1, [r2, #28]
   1a08a:	3618      	adds	r6, #24
   1a08c:	e6c0      	b.n	19e10 <_realloc_r+0x124>
   1a08e:	0031      	movs	r1, r6
   1a090:	0038      	movs	r0, r7
   1a092:	f7ff f91d 	bl	192d0 <memmove>
   1a096:	e775      	b.n	19f84 <_realloc_r+0x298>
   1a098:	465b      	mov	r3, fp
   1a09a:	68b1      	ldr	r1, [r6, #8]
   1a09c:	6119      	str	r1, [r3, #16]
   1a09e:	68f1      	ldr	r1, [r6, #12]
   1a0a0:	6159      	str	r1, [r3, #20]
   1a0a2:	2a24      	cmp	r2, #36	; 0x24
   1a0a4:	d007      	beq.n	1a0b6 <_realloc_r+0x3ca>
   1a0a6:	3318      	adds	r3, #24
   1a0a8:	3610      	adds	r6, #16
   1a0aa:	e765      	b.n	19f78 <_realloc_r+0x28c>
   1a0ac:	4640      	mov	r0, r8
   1a0ae:	f7fb fd15 	bl	15adc <__malloc_unlock>
   1a0b2:	2000      	movs	r0, #0
   1a0b4:	e6c8      	b.n	19e48 <_realloc_r+0x15c>
   1a0b6:	465b      	mov	r3, fp
   1a0b8:	6932      	ldr	r2, [r6, #16]
   1a0ba:	619a      	str	r2, [r3, #24]
   1a0bc:	465a      	mov	r2, fp
   1a0be:	6971      	ldr	r1, [r6, #20]
   1a0c0:	3320      	adds	r3, #32
   1a0c2:	61d1      	str	r1, [r2, #28]
   1a0c4:	3618      	adds	r6, #24
   1a0c6:	e757      	b.n	19f78 <_realloc_r+0x28c>

0001a0c8 <cleanup_glue>:
   1a0c8:	b570      	push	{r4, r5, r6, lr}
   1a0ca:	000c      	movs	r4, r1
   1a0cc:	6809      	ldr	r1, [r1, #0]
   1a0ce:	0005      	movs	r5, r0
   1a0d0:	2900      	cmp	r1, #0
   1a0d2:	d001      	beq.n	1a0d8 <cleanup_glue+0x10>
   1a0d4:	f7ff fff8 	bl	1a0c8 <cleanup_glue>
   1a0d8:	0028      	movs	r0, r5
   1a0da:	0021      	movs	r1, r4
   1a0dc:	f7fe fd66 	bl	18bac <_free_r>
   1a0e0:	bd70      	pop	{r4, r5, r6, pc}
   1a0e2:	46c0      	nop			; (mov r8, r8)

0001a0e4 <_reclaim_reent>:
   1a0e4:	4b23      	ldr	r3, [pc, #140]	; (1a174 <_reclaim_reent+0x90>)
   1a0e6:	b570      	push	{r4, r5, r6, lr}
   1a0e8:	681b      	ldr	r3, [r3, #0]
   1a0ea:	0005      	movs	r5, r0
   1a0ec:	4283      	cmp	r3, r0
   1a0ee:	d034      	beq.n	1a15a <_reclaim_reent+0x76>
   1a0f0:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
   1a0f2:	2b00      	cmp	r3, #0
   1a0f4:	d011      	beq.n	1a11a <_reclaim_reent+0x36>
   1a0f6:	2600      	movs	r6, #0
   1a0f8:	5999      	ldr	r1, [r3, r6]
   1a0fa:	2900      	cmp	r1, #0
   1a0fc:	d006      	beq.n	1a10c <_reclaim_reent+0x28>
   1a0fe:	680c      	ldr	r4, [r1, #0]
   1a100:	0028      	movs	r0, r5
   1a102:	f7fe fd53 	bl	18bac <_free_r>
   1a106:	1e21      	subs	r1, r4, #0
   1a108:	d1f9      	bne.n	1a0fe <_reclaim_reent+0x1a>
   1a10a:	6ceb      	ldr	r3, [r5, #76]	; 0x4c
   1a10c:	3604      	adds	r6, #4
   1a10e:	2e80      	cmp	r6, #128	; 0x80
   1a110:	d1f2      	bne.n	1a0f8 <_reclaim_reent+0x14>
   1a112:	0019      	movs	r1, r3
   1a114:	0028      	movs	r0, r5
   1a116:	f7fe fd49 	bl	18bac <_free_r>
   1a11a:	6c29      	ldr	r1, [r5, #64]	; 0x40
   1a11c:	2900      	cmp	r1, #0
   1a11e:	d002      	beq.n	1a126 <_reclaim_reent+0x42>
   1a120:	0028      	movs	r0, r5
   1a122:	f7fe fd43 	bl	18bac <_free_r>
   1a126:	23a4      	movs	r3, #164	; 0xa4
   1a128:	005b      	lsls	r3, r3, #1
   1a12a:	58e9      	ldr	r1, [r5, r3]
   1a12c:	2900      	cmp	r1, #0
   1a12e:	d00b      	beq.n	1a148 <_reclaim_reent+0x64>
   1a130:	002e      	movs	r6, r5
   1a132:	364d      	adds	r6, #77	; 0x4d
   1a134:	36ff      	adds	r6, #255	; 0xff
   1a136:	42b1      	cmp	r1, r6
   1a138:	d006      	beq.n	1a148 <_reclaim_reent+0x64>
   1a13a:	680c      	ldr	r4, [r1, #0]
   1a13c:	0028      	movs	r0, r5
   1a13e:	f7fe fd35 	bl	18bac <_free_r>
   1a142:	0021      	movs	r1, r4
   1a144:	42a6      	cmp	r6, r4
   1a146:	d1f8      	bne.n	1a13a <_reclaim_reent+0x56>
   1a148:	6d69      	ldr	r1, [r5, #84]	; 0x54
   1a14a:	2900      	cmp	r1, #0
   1a14c:	d002      	beq.n	1a154 <_reclaim_reent+0x70>
   1a14e:	0028      	movs	r0, r5
   1a150:	f7fe fd2c 	bl	18bac <_free_r>
   1a154:	6bab      	ldr	r3, [r5, #56]	; 0x38
   1a156:	2b00      	cmp	r3, #0
   1a158:	d100      	bne.n	1a15c <_reclaim_reent+0x78>
   1a15a:	bd70      	pop	{r4, r5, r6, pc}
   1a15c:	6beb      	ldr	r3, [r5, #60]	; 0x3c
   1a15e:	0028      	movs	r0, r5
   1a160:	4798      	blx	r3
   1a162:	23b8      	movs	r3, #184	; 0xb8
   1a164:	009b      	lsls	r3, r3, #2
   1a166:	58e9      	ldr	r1, [r5, r3]
   1a168:	2900      	cmp	r1, #0
   1a16a:	d0f6      	beq.n	1a15a <_reclaim_reent+0x76>
   1a16c:	0028      	movs	r0, r5
   1a16e:	f7ff ffab 	bl	1a0c8 <cleanup_glue>
   1a172:	e7f2      	b.n	1a15a <_reclaim_reent+0x76>
   1a174:	10010df0 	.word	0x10010df0

0001a178 <__sread>:
   1a178:	b570      	push	{r4, r5, r6, lr}
   1a17a:	000c      	movs	r4, r1
   1a17c:	250e      	movs	r5, #14
   1a17e:	5f49      	ldrsh	r1, [r1, r5]
   1a180:	f002 fdd8 	bl	1cd34 <_read_r>
   1a184:	2800      	cmp	r0, #0
   1a186:	db03      	blt.n	1a190 <__sread+0x18>
   1a188:	6d23      	ldr	r3, [r4, #80]	; 0x50
   1a18a:	181b      	adds	r3, r3, r0
   1a18c:	6523      	str	r3, [r4, #80]	; 0x50
   1a18e:	bd70      	pop	{r4, r5, r6, pc}
   1a190:	89a2      	ldrh	r2, [r4, #12]
   1a192:	4b02      	ldr	r3, [pc, #8]	; (1a19c <__sread+0x24>)
   1a194:	4013      	ands	r3, r2
   1a196:	81a3      	strh	r3, [r4, #12]
   1a198:	e7f9      	b.n	1a18e <__sread+0x16>
   1a19a:	46c0      	nop			; (mov r8, r8)
   1a19c:	ffffefff 	.word	0xffffefff

0001a1a0 <__seofread>:
   1a1a0:	2000      	movs	r0, #0
   1a1a2:	4770      	bx	lr

0001a1a4 <__swrite>:
   1a1a4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1a1a6:	0016      	movs	r6, r2
   1a1a8:	001f      	movs	r7, r3
   1a1aa:	230c      	movs	r3, #12
   1a1ac:	5eca      	ldrsh	r2, [r1, r3]
   1a1ae:	0005      	movs	r5, r0
   1a1b0:	000c      	movs	r4, r1
   1a1b2:	05d3      	lsls	r3, r2, #23
   1a1b4:	d507      	bpl.n	1a1c6 <__swrite+0x22>
   1a1b6:	230e      	movs	r3, #14
   1a1b8:	5ec9      	ldrsh	r1, [r1, r3]
   1a1ba:	2200      	movs	r2, #0
   1a1bc:	2302      	movs	r3, #2
   1a1be:	f002 fd7b 	bl	1ccb8 <_lseek_r>
   1a1c2:	230c      	movs	r3, #12
   1a1c4:	5ee2      	ldrsh	r2, [r4, r3]
   1a1c6:	4b05      	ldr	r3, [pc, #20]	; (1a1dc <__swrite+0x38>)
   1a1c8:	0028      	movs	r0, r5
   1a1ca:	4013      	ands	r3, r2
   1a1cc:	81a3      	strh	r3, [r4, #12]
   1a1ce:	0032      	movs	r2, r6
   1a1d0:	230e      	movs	r3, #14
   1a1d2:	5ee1      	ldrsh	r1, [r4, r3]
   1a1d4:	003b      	movs	r3, r7
   1a1d6:	f002 fbcd 	bl	1c974 <_write_r>
   1a1da:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1a1dc:	ffffefff 	.word	0xffffefff

0001a1e0 <__sseek>:
   1a1e0:	b570      	push	{r4, r5, r6, lr}
   1a1e2:	000c      	movs	r4, r1
   1a1e4:	250e      	movs	r5, #14
   1a1e6:	5f49      	ldrsh	r1, [r1, r5]
   1a1e8:	f002 fd66 	bl	1ccb8 <_lseek_r>
   1a1ec:	1c43      	adds	r3, r0, #1
   1a1ee:	d006      	beq.n	1a1fe <__sseek+0x1e>
   1a1f0:	2280      	movs	r2, #128	; 0x80
   1a1f2:	89a3      	ldrh	r3, [r4, #12]
   1a1f4:	0152      	lsls	r2, r2, #5
   1a1f6:	4313      	orrs	r3, r2
   1a1f8:	81a3      	strh	r3, [r4, #12]
   1a1fa:	6520      	str	r0, [r4, #80]	; 0x50
   1a1fc:	bd70      	pop	{r4, r5, r6, pc}
   1a1fe:	89a2      	ldrh	r2, [r4, #12]
   1a200:	4b01      	ldr	r3, [pc, #4]	; (1a208 <__sseek+0x28>)
   1a202:	4013      	ands	r3, r2
   1a204:	81a3      	strh	r3, [r4, #12]
   1a206:	e7f9      	b.n	1a1fc <__sseek+0x1c>
   1a208:	ffffefff 	.word	0xffffefff

0001a20c <__sclose>:
   1a20c:	b510      	push	{r4, lr}
   1a20e:	230e      	movs	r3, #14
   1a210:	5ec9      	ldrsh	r1, [r1, r3]
   1a212:	f002 fbf3 	bl	1c9fc <_close_r>
   1a216:	bd10      	pop	{r4, pc}

0001a218 <_svfprintf_r>:
   1a218:	b5f0      	push	{r4, r5, r6, r7, lr}
   1a21a:	465f      	mov	r7, fp
   1a21c:	4644      	mov	r4, r8
   1a21e:	4656      	mov	r6, sl
   1a220:	464d      	mov	r5, r9
   1a222:	b4f0      	push	{r4, r5, r6, r7}
   1a224:	b0c3      	sub	sp, #268	; 0x10c
   1a226:	000c      	movs	r4, r1
   1a228:	9311      	str	r3, [sp, #68]	; 0x44
   1a22a:	9107      	str	r1, [sp, #28]
   1a22c:	4693      	mov	fp, r2
   1a22e:	9009      	str	r0, [sp, #36]	; 0x24
   1a230:	f7fe ff76 	bl	19120 <_localeconv_r>
   1a234:	6800      	ldr	r0, [r0, #0]
   1a236:	9019      	str	r0, [sp, #100]	; 0x64
   1a238:	f7fb fcea 	bl	15c10 <strlen>
   1a23c:	9018      	str	r0, [sp, #96]	; 0x60
   1a23e:	89a3      	ldrh	r3, [r4, #12]
   1a240:	061b      	lsls	r3, r3, #24
   1a242:	d505      	bpl.n	1a250 <_svfprintf_r+0x38>
   1a244:	6923      	ldr	r3, [r4, #16]
   1a246:	9308      	str	r3, [sp, #32]
   1a248:	2b00      	cmp	r3, #0
   1a24a:	d101      	bne.n	1a250 <_svfprintf_r+0x38>
   1a24c:	f001 f96c 	bl	1b528 <_svfprintf_r+0x1310>
   1a250:	ab32      	add	r3, sp, #200	; 0xc8
   1a252:	9325      	str	r3, [sp, #148]	; 0x94
   1a254:	2300      	movs	r3, #0
   1a256:	af25      	add	r7, sp, #148	; 0x94
   1a258:	60bb      	str	r3, [r7, #8]
   1a25a:	607b      	str	r3, [r7, #4]
   1a25c:	9314      	str	r3, [sp, #80]	; 0x50
   1a25e:	9316      	str	r3, [sp, #88]	; 0x58
   1a260:	9317      	str	r3, [sp, #92]	; 0x5c
   1a262:	ae32      	add	r6, sp, #200	; 0xc8
   1a264:	931a      	str	r3, [sp, #104]	; 0x68
   1a266:	930c      	str	r3, [sp, #48]	; 0x30
   1a268:	465b      	mov	r3, fp
   1a26a:	781b      	ldrb	r3, [r3, #0]
   1a26c:	465c      	mov	r4, fp
   1a26e:	2b00      	cmp	r3, #0
   1a270:	d01c      	beq.n	1a2ac <_svfprintf_r+0x94>
   1a272:	2b25      	cmp	r3, #37	; 0x25
   1a274:	d102      	bne.n	1a27c <_svfprintf_r+0x64>
   1a276:	e019      	b.n	1a2ac <_svfprintf_r+0x94>
   1a278:	2b25      	cmp	r3, #37	; 0x25
   1a27a:	d003      	beq.n	1a284 <_svfprintf_r+0x6c>
   1a27c:	3401      	adds	r4, #1
   1a27e:	7823      	ldrb	r3, [r4, #0]
   1a280:	2b00      	cmp	r3, #0
   1a282:	d1f9      	bne.n	1a278 <_svfprintf_r+0x60>
   1a284:	465b      	mov	r3, fp
   1a286:	1ae5      	subs	r5, r4, r3
   1a288:	d010      	beq.n	1a2ac <_svfprintf_r+0x94>
   1a28a:	465b      	mov	r3, fp
   1a28c:	6033      	str	r3, [r6, #0]
   1a28e:	68bb      	ldr	r3, [r7, #8]
   1a290:	6075      	str	r5, [r6, #4]
   1a292:	195b      	adds	r3, r3, r5
   1a294:	60bb      	str	r3, [r7, #8]
   1a296:	687b      	ldr	r3, [r7, #4]
   1a298:	3301      	adds	r3, #1
   1a29a:	607b      	str	r3, [r7, #4]
   1a29c:	2b07      	cmp	r3, #7
   1a29e:	dc61      	bgt.n	1a364 <_svfprintf_r+0x14c>
   1a2a0:	3608      	adds	r6, #8
   1a2a2:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   1a2a4:	469c      	mov	ip, r3
   1a2a6:	44ac      	add	ip, r5
   1a2a8:	4663      	mov	r3, ip
   1a2aa:	930c      	str	r3, [sp, #48]	; 0x30
   1a2ac:	7823      	ldrb	r3, [r4, #0]
   1a2ae:	2b00      	cmp	r3, #0
   1a2b0:	d061      	beq.n	1a376 <_svfprintf_r+0x15e>
   1a2b2:	2001      	movs	r0, #1
   1a2b4:	4240      	negs	r0, r0
   1a2b6:	900b      	str	r0, [sp, #44]	; 0x2c
   1a2b8:	2000      	movs	r0, #0
   1a2ba:	1c63      	adds	r3, r4, #1
   1a2bc:	469b      	mov	fp, r3
   1a2be:	2300      	movs	r3, #0
   1a2c0:	900d      	str	r0, [sp, #52]	; 0x34
   1a2c2:	9008      	str	r0, [sp, #32]
   1a2c4:	3010      	adds	r0, #16
   1a2c6:	4681      	mov	r9, r0
   1a2c8:	3030      	adds	r0, #48	; 0x30
   1a2ca:	aa16      	add	r2, sp, #88	; 0x58
   1a2cc:	4684      	mov	ip, r0
   1a2ce:	3040      	adds	r0, #64	; 0x40
   1a2d0:	77d3      	strb	r3, [r2, #31]
   1a2d2:	2100      	movs	r1, #0
   1a2d4:	2200      	movs	r2, #0
   1a2d6:	4682      	mov	sl, r0
   1a2d8:	465d      	mov	r5, fp
   1a2da:	7863      	ldrb	r3, [r4, #1]
   1a2dc:	3501      	adds	r5, #1
   1a2de:	001c      	movs	r4, r3
   1a2e0:	3c20      	subs	r4, #32
   1a2e2:	2c58      	cmp	r4, #88	; 0x58
   1a2e4:	d900      	bls.n	1a2e8 <_svfprintf_r+0xd0>
   1a2e6:	e3ab      	b.n	1aa40 <_svfprintf_r+0x828>
   1a2e8:	48d4      	ldr	r0, [pc, #848]	; (1a63c <_svfprintf_r+0x424>)
   1a2ea:	00a4      	lsls	r4, r4, #2
   1a2ec:	5904      	ldr	r4, [r0, r4]
   1a2ee:	46a7      	mov	pc, r4
   1a2f0:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   1a2f2:	9411      	str	r4, [sp, #68]	; 0x44
   1a2f4:	425b      	negs	r3, r3
   1a2f6:	930d      	str	r3, [sp, #52]	; 0x34
   1a2f8:	2304      	movs	r3, #4
   1a2fa:	9808      	ldr	r0, [sp, #32]
   1a2fc:	4318      	orrs	r0, r3
   1a2fe:	9008      	str	r0, [sp, #32]
   1a300:	782b      	ldrb	r3, [r5, #0]
   1a302:	e7eb      	b.n	1a2dc <_svfprintf_r+0xc4>
   1a304:	2430      	movs	r4, #48	; 0x30
   1a306:	9b11      	ldr	r3, [sp, #68]	; 0x44
   1a308:	aa1e      	add	r2, sp, #120	; 0x78
   1a30a:	7014      	strb	r4, [r2, #0]
   1a30c:	1d18      	adds	r0, r3, #4
   1a30e:	3448      	adds	r4, #72	; 0x48
   1a310:	681b      	ldr	r3, [r3, #0]
   1a312:	7054      	strb	r4, [r2, #1]
   1a314:	46ab      	mov	fp, r5
   1a316:	2200      	movs	r2, #0
   1a318:	9d08      	ldr	r5, [sp, #32]
   1a31a:	930e      	str	r3, [sp, #56]	; 0x38
   1a31c:	2300      	movs	r3, #0
   1a31e:	0029      	movs	r1, r5
   1a320:	ac16      	add	r4, sp, #88	; 0x58
   1a322:	77e2      	strb	r2, [r4, #31]
   1a324:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
   1a326:	930f      	str	r3, [sp, #60]	; 0x3c
   1a328:	3302      	adds	r3, #2
   1a32a:	4319      	orrs	r1, r3
   1a32c:	2a00      	cmp	r2, #0
   1a32e:	da00      	bge.n	1a332 <_svfprintf_r+0x11a>
   1a330:	e396      	b.n	1aa60 <_svfprintf_r+0x848>
   1a332:	2280      	movs	r2, #128	; 0x80
   1a334:	4395      	bics	r5, r2
   1a336:	002a      	movs	r2, r5
   1a338:	431a      	orrs	r2, r3
   1a33a:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   1a33c:	9208      	str	r2, [sp, #32]
   1a33e:	9011      	str	r0, [sp, #68]	; 0x44
   1a340:	2b00      	cmp	r3, #0
   1a342:	d000      	beq.n	1a346 <_svfprintf_r+0x12e>
   1a344:	e376      	b.n	1aa34 <_svfprintf_r+0x81c>
   1a346:	3378      	adds	r3, #120	; 0x78
   1a348:	49bd      	ldr	r1, [pc, #756]	; (1a640 <_svfprintf_r+0x428>)
   1a34a:	9313      	str	r3, [sp, #76]	; 0x4c
   1a34c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   1a34e:	4698      	mov	r8, r3
   1a350:	2b00      	cmp	r3, #0
   1a352:	d100      	bne.n	1a356 <_svfprintf_r+0x13e>
   1a354:	e30c      	b.n	1a970 <_svfprintf_r+0x758>
   1a356:	2300      	movs	r3, #0
   1a358:	4698      	mov	r8, r3
   1a35a:	2400      	movs	r4, #0
   1a35c:	2300      	movs	r3, #0
   1a35e:	930e      	str	r3, [sp, #56]	; 0x38
   1a360:	940f      	str	r4, [sp, #60]	; 0x3c
   1a362:	e26b      	b.n	1a83c <_svfprintf_r+0x624>
   1a364:	003a      	movs	r2, r7
   1a366:	9907      	ldr	r1, [sp, #28]
   1a368:	9809      	ldr	r0, [sp, #36]	; 0x24
   1a36a:	f002 fd3b 	bl	1cde4 <__ssprint_r>
   1a36e:	2800      	cmp	r0, #0
   1a370:	d109      	bne.n	1a386 <_svfprintf_r+0x16e>
   1a372:	ae32      	add	r6, sp, #200	; 0xc8
   1a374:	e795      	b.n	1a2a2 <_svfprintf_r+0x8a>
   1a376:	68bb      	ldr	r3, [r7, #8]
   1a378:	2b00      	cmp	r3, #0
   1a37a:	d004      	beq.n	1a386 <_svfprintf_r+0x16e>
   1a37c:	003a      	movs	r2, r7
   1a37e:	9907      	ldr	r1, [sp, #28]
   1a380:	9809      	ldr	r0, [sp, #36]	; 0x24
   1a382:	f002 fd2f 	bl	1cde4 <__ssprint_r>
   1a386:	9b07      	ldr	r3, [sp, #28]
   1a388:	980c      	ldr	r0, [sp, #48]	; 0x30
   1a38a:	899b      	ldrh	r3, [r3, #12]
   1a38c:	065b      	lsls	r3, r3, #25
   1a38e:	d501      	bpl.n	1a394 <_svfprintf_r+0x17c>
   1a390:	f001 f95e 	bl	1b650 <_svfprintf_r+0x1438>
   1a394:	b043      	add	sp, #268	; 0x10c
   1a396:	bc3c      	pop	{r2, r3, r4, r5}
   1a398:	4690      	mov	r8, r2
   1a39a:	4699      	mov	r9, r3
   1a39c:	46a2      	mov	sl, r4
   1a39e:	46ab      	mov	fp, r5
   1a3a0:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1a3a2:	9313      	str	r3, [sp, #76]	; 0x4c
   1a3a4:	46ab      	mov	fp, r5
   1a3a6:	2a00      	cmp	r2, #0
   1a3a8:	d001      	beq.n	1a3ae <_svfprintf_r+0x196>
   1a3aa:	f001 fb10 	bl	1b9ce <_svfprintf_r+0x17b6>
   1a3ae:	2320      	movs	r3, #32
   1a3b0:	9908      	ldr	r1, [sp, #32]
   1a3b2:	400b      	ands	r3, r1
   1a3b4:	d100      	bne.n	1a3b8 <_svfprintf_r+0x1a0>
   1a3b6:	e1a8      	b.n	1a70a <_svfprintf_r+0x4f2>
   1a3b8:	2207      	movs	r2, #7
   1a3ba:	9b11      	ldr	r3, [sp, #68]	; 0x44
   1a3bc:	3307      	adds	r3, #7
   1a3be:	4393      	bics	r3, r2
   1a3c0:	3201      	adds	r2, #1
   1a3c2:	4694      	mov	ip, r2
   1a3c4:	449c      	add	ip, r3
   1a3c6:	4662      	mov	r2, ip
   1a3c8:	685c      	ldr	r4, [r3, #4]
   1a3ca:	681b      	ldr	r3, [r3, #0]
   1a3cc:	0025      	movs	r5, r4
   1a3ce:	001c      	movs	r4, r3
   1a3d0:	2300      	movs	r3, #0
   1a3d2:	9211      	str	r2, [sp, #68]	; 0x44
   1a3d4:	aa16      	add	r2, sp, #88	; 0x58
   1a3d6:	77d3      	strb	r3, [r2, #31]
   1a3d8:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   1a3da:	940e      	str	r4, [sp, #56]	; 0x38
   1a3dc:	950f      	str	r5, [sp, #60]	; 0x3c
   1a3de:	2b00      	cmp	r3, #0
   1a3e0:	da01      	bge.n	1a3e6 <_svfprintf_r+0x1ce>
   1a3e2:	f000 ffb9 	bl	1b358 <_svfprintf_r+0x1140>
   1a3e6:	2380      	movs	r3, #128	; 0x80
   1a3e8:	4399      	bics	r1, r3
   1a3ea:	9108      	str	r1, [sp, #32]
   1a3ec:	0021      	movs	r1, r4
   1a3ee:	4329      	orrs	r1, r5
   1a3f0:	d100      	bne.n	1a3f4 <_svfprintf_r+0x1dc>
   1a3f2:	e1a6      	b.n	1a742 <_svfprintf_r+0x52a>
   1a3f4:	2300      	movs	r3, #0
   1a3f6:	4698      	mov	r8, r3
   1a3f8:	2207      	movs	r2, #7
   1a3fa:	46b4      	mov	ip, r6
   1a3fc:	ab32      	add	r3, sp, #200	; 0xc8
   1a3fe:	4692      	mov	sl, r2
   1a400:	001c      	movs	r4, r3
   1a402:	9a0e      	ldr	r2, [sp, #56]	; 0x38
   1a404:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   1a406:	0758      	lsls	r0, r3, #29
   1a408:	08d6      	lsrs	r6, r2, #3
   1a40a:	4651      	mov	r1, sl
   1a40c:	08dd      	lsrs	r5, r3, #3
   1a40e:	4330      	orrs	r0, r6
   1a410:	002b      	movs	r3, r5
   1a412:	0005      	movs	r5, r0
   1a414:	4011      	ands	r1, r2
   1a416:	3c01      	subs	r4, #1
   1a418:	3130      	adds	r1, #48	; 0x30
   1a41a:	7021      	strb	r1, [r4, #0]
   1a41c:	0002      	movs	r2, r0
   1a41e:	431d      	orrs	r5, r3
   1a420:	d1f1      	bne.n	1a406 <_svfprintf_r+0x1ee>
   1a422:	920e      	str	r2, [sp, #56]	; 0x38
   1a424:	930f      	str	r3, [sp, #60]	; 0x3c
   1a426:	9a08      	ldr	r2, [sp, #32]
   1a428:	9412      	str	r4, [sp, #72]	; 0x48
   1a42a:	4666      	mov	r6, ip
   1a42c:	07d2      	lsls	r2, r2, #31
   1a42e:	d400      	bmi.n	1a432 <_svfprintf_r+0x21a>
   1a430:	e21e      	b.n	1a870 <_svfprintf_r+0x658>
   1a432:	2930      	cmp	r1, #48	; 0x30
   1a434:	d101      	bne.n	1a43a <_svfprintf_r+0x222>
   1a436:	f001 f8cd 	bl	1b5d4 <_svfprintf_r+0x13bc>
   1a43a:	2330      	movs	r3, #48	; 0x30
   1a43c:	9d12      	ldr	r5, [sp, #72]	; 0x48
   1a43e:	3d01      	subs	r5, #1
   1a440:	702b      	strb	r3, [r5, #0]
   1a442:	ab32      	add	r3, sp, #200	; 0xc8
   1a444:	1b5b      	subs	r3, r3, r5
   1a446:	9310      	str	r3, [sp, #64]	; 0x40
   1a448:	9512      	str	r5, [sp, #72]	; 0x48
   1a44a:	9a10      	ldr	r2, [sp, #64]	; 0x40
   1a44c:	0013      	movs	r3, r2
   1a44e:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
   1a450:	4293      	cmp	r3, r2
   1a452:	da00      	bge.n	1a456 <_svfprintf_r+0x23e>
   1a454:	0013      	movs	r3, r2
   1a456:	930a      	str	r3, [sp, #40]	; 0x28
   1a458:	2300      	movs	r3, #0
   1a45a:	9315      	str	r3, [sp, #84]	; 0x54
   1a45c:	4643      	mov	r3, r8
   1a45e:	2b00      	cmp	r3, #0
   1a460:	d002      	beq.n	1a468 <_svfprintf_r+0x250>
   1a462:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1a464:	3301      	adds	r3, #1
   1a466:	930a      	str	r3, [sp, #40]	; 0x28
   1a468:	2302      	movs	r3, #2
   1a46a:	9a08      	ldr	r2, [sp, #32]
   1a46c:	401a      	ands	r2, r3
   1a46e:	4692      	mov	sl, r2
   1a470:	d002      	beq.n	1a478 <_svfprintf_r+0x260>
   1a472:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1a474:	3302      	adds	r3, #2
   1a476:	930a      	str	r3, [sp, #40]	; 0x28
   1a478:	2384      	movs	r3, #132	; 0x84
   1a47a:	9a08      	ldr	r2, [sp, #32]
   1a47c:	401a      	ands	r2, r3
   1a47e:	4691      	mov	r9, r2
   1a480:	d000      	beq.n	1a484 <_svfprintf_r+0x26c>
   1a482:	e2fc      	b.n	1aa7e <_svfprintf_r+0x866>
   1a484:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   1a486:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   1a488:	1a9c      	subs	r4, r3, r2
   1a48a:	2c00      	cmp	r4, #0
   1a48c:	dc00      	bgt.n	1a490 <_svfprintf_r+0x278>
   1a48e:	e2f6      	b.n	1aa7e <_svfprintf_r+0x866>
   1a490:	496c      	ldr	r1, [pc, #432]	; (1a644 <_svfprintf_r+0x42c>)
   1a492:	68ba      	ldr	r2, [r7, #8]
   1a494:	687b      	ldr	r3, [r7, #4]
   1a496:	4688      	mov	r8, r1
   1a498:	2c10      	cmp	r4, #16
   1a49a:	dd1f      	ble.n	1a4dc <_svfprintf_r+0x2c4>
   1a49c:	0031      	movs	r1, r6
   1a49e:	2510      	movs	r5, #16
   1a4a0:	4646      	mov	r6, r8
   1a4a2:	e003      	b.n	1a4ac <_svfprintf_r+0x294>
   1a4a4:	3c10      	subs	r4, #16
   1a4a6:	3108      	adds	r1, #8
   1a4a8:	2c10      	cmp	r4, #16
   1a4aa:	dd15      	ble.n	1a4d8 <_svfprintf_r+0x2c0>
   1a4ac:	3210      	adds	r2, #16
   1a4ae:	3301      	adds	r3, #1
   1a4b0:	600e      	str	r6, [r1, #0]
   1a4b2:	604d      	str	r5, [r1, #4]
   1a4b4:	60ba      	str	r2, [r7, #8]
   1a4b6:	607b      	str	r3, [r7, #4]
   1a4b8:	2b07      	cmp	r3, #7
   1a4ba:	ddf3      	ble.n	1a4a4 <_svfprintf_r+0x28c>
   1a4bc:	003a      	movs	r2, r7
   1a4be:	9907      	ldr	r1, [sp, #28]
   1a4c0:	9809      	ldr	r0, [sp, #36]	; 0x24
   1a4c2:	f002 fc8f 	bl	1cde4 <__ssprint_r>
   1a4c6:	2800      	cmp	r0, #0
   1a4c8:	d000      	beq.n	1a4cc <_svfprintf_r+0x2b4>
   1a4ca:	e75c      	b.n	1a386 <_svfprintf_r+0x16e>
   1a4cc:	3c10      	subs	r4, #16
   1a4ce:	68ba      	ldr	r2, [r7, #8]
   1a4d0:	687b      	ldr	r3, [r7, #4]
   1a4d2:	a932      	add	r1, sp, #200	; 0xc8
   1a4d4:	2c10      	cmp	r4, #16
   1a4d6:	dce9      	bgt.n	1a4ac <_svfprintf_r+0x294>
   1a4d8:	46b0      	mov	r8, r6
   1a4da:	000e      	movs	r6, r1
   1a4dc:	4641      	mov	r1, r8
   1a4de:	6074      	str	r4, [r6, #4]
   1a4e0:	3301      	adds	r3, #1
   1a4e2:	18a4      	adds	r4, r4, r2
   1a4e4:	6031      	str	r1, [r6, #0]
   1a4e6:	60bc      	str	r4, [r7, #8]
   1a4e8:	607b      	str	r3, [r7, #4]
   1a4ea:	2b07      	cmp	r3, #7
   1a4ec:	dd01      	ble.n	1a4f2 <_svfprintf_r+0x2da>
   1a4ee:	f000 fd5b 	bl	1afa8 <_svfprintf_r+0xd90>
   1a4f2:	ab16      	add	r3, sp, #88	; 0x58
   1a4f4:	7fdb      	ldrb	r3, [r3, #31]
   1a4f6:	3608      	adds	r6, #8
   1a4f8:	4698      	mov	r8, r3
   1a4fa:	e2c1      	b.n	1aa80 <_svfprintf_r+0x868>
   1a4fc:	1c6b      	adds	r3, r5, #1
   1a4fe:	4698      	mov	r8, r3
   1a500:	782b      	ldrb	r3, [r5, #0]
   1a502:	2b2a      	cmp	r3, #42	; 0x2a
   1a504:	d101      	bne.n	1a50a <_svfprintf_r+0x2f2>
   1a506:	f001 fa4b 	bl	1b9a0 <_svfprintf_r+0x1788>
   1a50a:	2030      	movs	r0, #48	; 0x30
   1a50c:	4240      	negs	r0, r0
   1a50e:	4683      	mov	fp, r0
   1a510:	449b      	add	fp, r3
   1a512:	4658      	mov	r0, fp
   1a514:	2400      	movs	r4, #0
   1a516:	4645      	mov	r5, r8
   1a518:	2809      	cmp	r0, #9
   1a51a:	d901      	bls.n	1a520 <_svfprintf_r+0x308>
   1a51c:	f001 f9dc 	bl	1b8d8 <_svfprintf_r+0x16c0>
   1a520:	4690      	mov	r8, r2
   1a522:	465a      	mov	r2, fp
   1a524:	00a3      	lsls	r3, r4, #2
   1a526:	3501      	adds	r5, #1
   1a528:	191c      	adds	r4, r3, r4
   1a52a:	1e6b      	subs	r3, r5, #1
   1a52c:	781b      	ldrb	r3, [r3, #0]
   1a52e:	0064      	lsls	r4, r4, #1
   1a530:	18a4      	adds	r4, r4, r2
   1a532:	001a      	movs	r2, r3
   1a534:	3a30      	subs	r2, #48	; 0x30
   1a536:	2a09      	cmp	r2, #9
   1a538:	d9f4      	bls.n	1a524 <_svfprintf_r+0x30c>
   1a53a:	4642      	mov	r2, r8
   1a53c:	46a8      	mov	r8, r5
   1a53e:	2c00      	cmp	r4, #0
   1a540:	da01      	bge.n	1a546 <_svfprintf_r+0x32e>
   1a542:	f001 f88f 	bl	1b664 <_svfprintf_r+0x144c>
   1a546:	940b      	str	r4, [sp, #44]	; 0x2c
   1a548:	4645      	mov	r5, r8
   1a54a:	e6c8      	b.n	1a2de <_svfprintf_r+0xc6>
   1a54c:	4650      	mov	r0, sl
   1a54e:	9b08      	ldr	r3, [sp, #32]
   1a550:	4303      	orrs	r3, r0
   1a552:	9308      	str	r3, [sp, #32]
   1a554:	782b      	ldrb	r3, [r5, #0]
   1a556:	e6c1      	b.n	1a2dc <_svfprintf_r+0xc4>
   1a558:	2430      	movs	r4, #48	; 0x30
   1a55a:	4264      	negs	r4, r4
   1a55c:	46a3      	mov	fp, r4
   1a55e:	2000      	movs	r0, #0
   1a560:	449b      	add	fp, r3
   1a562:	4690      	mov	r8, r2
   1a564:	0003      	movs	r3, r0
   1a566:	465a      	mov	r2, fp
   1a568:	009c      	lsls	r4, r3, #2
   1a56a:	18e3      	adds	r3, r4, r3
   1a56c:	005b      	lsls	r3, r3, #1
   1a56e:	3501      	adds	r5, #1
   1a570:	18d3      	adds	r3, r2, r3
   1a572:	1e6a      	subs	r2, r5, #1
   1a574:	7814      	ldrb	r4, [r2, #0]
   1a576:	0022      	movs	r2, r4
   1a578:	3a30      	subs	r2, #48	; 0x30
   1a57a:	2a09      	cmp	r2, #9
   1a57c:	d9f4      	bls.n	1a568 <_svfprintf_r+0x350>
   1a57e:	930d      	str	r3, [sp, #52]	; 0x34
   1a580:	4642      	mov	r2, r8
   1a582:	0023      	movs	r3, r4
   1a584:	e6ab      	b.n	1a2de <_svfprintf_r+0xc6>
   1a586:	9313      	str	r3, [sp, #76]	; 0x4c
   1a588:	46ab      	mov	fp, r5
   1a58a:	2a00      	cmp	r2, #0
   1a58c:	d001      	beq.n	1a592 <_svfprintf_r+0x37a>
   1a58e:	f001 fa12 	bl	1b9b6 <_svfprintf_r+0x179e>
   1a592:	2310      	movs	r3, #16
   1a594:	9a08      	ldr	r2, [sp, #32]
   1a596:	431a      	orrs	r2, r3
   1a598:	9208      	str	r2, [sp, #32]
   1a59a:	9b08      	ldr	r3, [sp, #32]
   1a59c:	069b      	lsls	r3, r3, #26
   1a59e:	d401      	bmi.n	1a5a4 <_svfprintf_r+0x38c>
   1a5a0:	f000 fd49 	bl	1b036 <_svfprintf_r+0xe1e>
   1a5a4:	2307      	movs	r3, #7
   1a5a6:	9a11      	ldr	r2, [sp, #68]	; 0x44
   1a5a8:	3207      	adds	r2, #7
   1a5aa:	439a      	bics	r2, r3
   1a5ac:	3301      	adds	r3, #1
   1a5ae:	469c      	mov	ip, r3
   1a5b0:	4494      	add	ip, r2
   1a5b2:	4663      	mov	r3, ip
   1a5b4:	9311      	str	r3, [sp, #68]	; 0x44
   1a5b6:	6853      	ldr	r3, [r2, #4]
   1a5b8:	6812      	ldr	r2, [r2, #0]
   1a5ba:	930f      	str	r3, [sp, #60]	; 0x3c
   1a5bc:	920e      	str	r2, [sp, #56]	; 0x38
   1a5be:	2b00      	cmp	r3, #0
   1a5c0:	da01      	bge.n	1a5c6 <_svfprintf_r+0x3ae>
   1a5c2:	f000 fd47 	bl	1b054 <_svfprintf_r+0xe3c>
   1a5c6:	ab16      	add	r3, sp, #88	; 0x58
   1a5c8:	7fdb      	ldrb	r3, [r3, #31]
   1a5ca:	4698      	mov	r8, r3
   1a5cc:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   1a5ce:	2b00      	cmp	r3, #0
   1a5d0:	da01      	bge.n	1a5d6 <_svfprintf_r+0x3be>
   1a5d2:	f000 fd65 	bl	1b0a0 <_svfprintf_r+0xe88>
   1a5d6:	2380      	movs	r3, #128	; 0x80
   1a5d8:	9a08      	ldr	r2, [sp, #32]
   1a5da:	439a      	bics	r2, r3
   1a5dc:	9208      	str	r2, [sp, #32]
   1a5de:	9a0e      	ldr	r2, [sp, #56]	; 0x38
   1a5e0:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   1a5e2:	0011      	movs	r1, r2
   1a5e4:	4319      	orrs	r1, r3
   1a5e6:	d101      	bne.n	1a5ec <_svfprintf_r+0x3d4>
   1a5e8:	f000 fc53 	bl	1ae92 <_svfprintf_r+0xc7a>
   1a5ec:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   1a5ee:	2b00      	cmp	r3, #0
   1a5f0:	d101      	bne.n	1a5f6 <_svfprintf_r+0x3de>
   1a5f2:	f001 f831 	bl	1b658 <_svfprintf_r+0x1440>
   1a5f6:	9c0e      	ldr	r4, [sp, #56]	; 0x38
   1a5f8:	9d0f      	ldr	r5, [sp, #60]	; 0x3c
   1a5fa:	ab32      	add	r3, sp, #200	; 0xc8
   1a5fc:	46b1      	mov	r9, r6
   1a5fe:	001e      	movs	r6, r3
   1a600:	0020      	movs	r0, r4
   1a602:	0029      	movs	r1, r5
   1a604:	220a      	movs	r2, #10
   1a606:	2300      	movs	r3, #0
   1a608:	f003 fc40 	bl	1de8c <__aeabi_uldivmod>
   1a60c:	3e01      	subs	r6, #1
   1a60e:	3230      	adds	r2, #48	; 0x30
   1a610:	7032      	strb	r2, [r6, #0]
   1a612:	2300      	movs	r3, #0
   1a614:	0020      	movs	r0, r4
   1a616:	0029      	movs	r1, r5
   1a618:	220a      	movs	r2, #10
   1a61a:	f003 fc37 	bl	1de8c <__aeabi_uldivmod>
   1a61e:	0003      	movs	r3, r0
   1a620:	0004      	movs	r4, r0
   1a622:	000d      	movs	r5, r1
   1a624:	430b      	orrs	r3, r1
   1a626:	d1eb      	bne.n	1a600 <_svfprintf_r+0x3e8>
   1a628:	0032      	movs	r2, r6
   1a62a:	ab32      	add	r3, sp, #200	; 0xc8
   1a62c:	1a9b      	subs	r3, r3, r2
   1a62e:	9612      	str	r6, [sp, #72]	; 0x48
   1a630:	940e      	str	r4, [sp, #56]	; 0x38
   1a632:	950f      	str	r5, [sp, #60]	; 0x3c
   1a634:	464e      	mov	r6, r9
   1a636:	9310      	str	r3, [sp, #64]	; 0x40
   1a638:	e707      	b.n	1a44a <_svfprintf_r+0x232>
   1a63a:	46c0      	nop			; (mov r8, r8)
   1a63c:	00022ec8 	.word	0x00022ec8
   1a640:	00022d5c 	.word	0x00022d5c
   1a644:	0002303c 	.word	0x0002303c
   1a648:	9313      	str	r3, [sp, #76]	; 0x4c
   1a64a:	46ab      	mov	fp, r5
   1a64c:	2a00      	cmp	r2, #0
   1a64e:	d001      	beq.n	1a654 <_svfprintf_r+0x43c>
   1a650:	f001 f9dd 	bl	1ba0e <_svfprintf_r+0x17f6>
   1a654:	2207      	movs	r2, #7
   1a656:	9b11      	ldr	r3, [sp, #68]	; 0x44
   1a658:	3307      	adds	r3, #7
   1a65a:	4393      	bics	r3, r2
   1a65c:	3201      	adds	r2, #1
   1a65e:	4694      	mov	ip, r2
   1a660:	449c      	add	ip, r3
   1a662:	4662      	mov	r2, ip
   1a664:	9211      	str	r2, [sp, #68]	; 0x44
   1a666:	681a      	ldr	r2, [r3, #0]
   1a668:	9216      	str	r2, [sp, #88]	; 0x58
   1a66a:	2201      	movs	r2, #1
   1a66c:	685b      	ldr	r3, [r3, #4]
   1a66e:	9d16      	ldr	r5, [sp, #88]	; 0x58
   1a670:	9317      	str	r3, [sp, #92]	; 0x5c
   1a672:	9b17      	ldr	r3, [sp, #92]	; 0x5c
   1a674:	4252      	negs	r2, r2
   1a676:	005c      	lsls	r4, r3, #1
   1a678:	0864      	lsrs	r4, r4, #1
   1a67a:	4be4      	ldr	r3, [pc, #912]	; (1aa0c <_svfprintf_r+0x7f4>)
   1a67c:	0028      	movs	r0, r5
   1a67e:	0021      	movs	r1, r4
   1a680:	f005 fa2e 	bl	1fae0 <__aeabi_dcmpun>
   1a684:	2800      	cmp	r0, #0
   1a686:	d001      	beq.n	1a68c <_svfprintf_r+0x474>
   1a688:	f000 fdcd 	bl	1b226 <_svfprintf_r+0x100e>
   1a68c:	2201      	movs	r2, #1
   1a68e:	4bdf      	ldr	r3, [pc, #892]	; (1aa0c <_svfprintf_r+0x7f4>)
   1a690:	4252      	negs	r2, r2
   1a692:	0028      	movs	r0, r5
   1a694:	0021      	movs	r1, r4
   1a696:	f003 fb9d 	bl	1ddd4 <__aeabi_dcmple>
   1a69a:	2800      	cmp	r0, #0
   1a69c:	d001      	beq.n	1a6a2 <_svfprintf_r+0x48a>
   1a69e:	f000 fdc2 	bl	1b226 <_svfprintf_r+0x100e>
   1a6a2:	2200      	movs	r2, #0
   1a6a4:	2300      	movs	r3, #0
   1a6a6:	9816      	ldr	r0, [sp, #88]	; 0x58
   1a6a8:	9917      	ldr	r1, [sp, #92]	; 0x5c
   1a6aa:	f003 fb89 	bl	1ddc0 <__aeabi_dcmplt>
   1a6ae:	2800      	cmp	r0, #0
   1a6b0:	d001      	beq.n	1a6b6 <_svfprintf_r+0x49e>
   1a6b2:	f001 f8aa 	bl	1b80a <_svfprintf_r+0x15f2>
   1a6b6:	ab16      	add	r3, sp, #88	; 0x58
   1a6b8:	7fdb      	ldrb	r3, [r3, #31]
   1a6ba:	4698      	mov	r8, r3
   1a6bc:	9b13      	ldr	r3, [sp, #76]	; 0x4c
   1a6be:	2b47      	cmp	r3, #71	; 0x47
   1a6c0:	dd01      	ble.n	1a6c6 <_svfprintf_r+0x4ae>
   1a6c2:	f000 ff2d 	bl	1b520 <_svfprintf_r+0x1308>
   1a6c6:	4bd2      	ldr	r3, [pc, #840]	; (1aa10 <_svfprintf_r+0x7f8>)
   1a6c8:	9312      	str	r3, [sp, #72]	; 0x48
   1a6ca:	2380      	movs	r3, #128	; 0x80
   1a6cc:	9a08      	ldr	r2, [sp, #32]
   1a6ce:	439a      	bics	r2, r3
   1a6d0:	9208      	str	r2, [sp, #32]
   1a6d2:	3b7d      	subs	r3, #125	; 0x7d
   1a6d4:	930a      	str	r3, [sp, #40]	; 0x28
   1a6d6:	9310      	str	r3, [sp, #64]	; 0x40
   1a6d8:	2300      	movs	r3, #0
   1a6da:	930b      	str	r3, [sp, #44]	; 0x2c
   1a6dc:	9315      	str	r3, [sp, #84]	; 0x54
   1a6de:	e6bd      	b.n	1a45c <_svfprintf_r+0x244>
   1a6e0:	2008      	movs	r0, #8
   1a6e2:	9b08      	ldr	r3, [sp, #32]
   1a6e4:	4303      	orrs	r3, r0
   1a6e6:	9308      	str	r3, [sp, #32]
   1a6e8:	782b      	ldrb	r3, [r5, #0]
   1a6ea:	e5f7      	b.n	1a2dc <_svfprintf_r+0xc4>
   1a6ec:	9313      	str	r3, [sp, #76]	; 0x4c
   1a6ee:	46ab      	mov	fp, r5
   1a6f0:	2a00      	cmp	r2, #0
   1a6f2:	d001      	beq.n	1a6f8 <_svfprintf_r+0x4e0>
   1a6f4:	f001 f993 	bl	1ba1e <_svfprintf_r+0x1806>
   1a6f8:	2310      	movs	r3, #16
   1a6fa:	9a08      	ldr	r2, [sp, #32]
   1a6fc:	431a      	orrs	r2, r3
   1a6fe:	2320      	movs	r3, #32
   1a700:	9208      	str	r2, [sp, #32]
   1a702:	9908      	ldr	r1, [sp, #32]
   1a704:	400b      	ands	r3, r1
   1a706:	d000      	beq.n	1a70a <_svfprintf_r+0x4f2>
   1a708:	e656      	b.n	1a3b8 <_svfprintf_r+0x1a0>
   1a70a:	2210      	movs	r2, #16
   1a70c:	9908      	ldr	r1, [sp, #32]
   1a70e:	400a      	ands	r2, r1
   1a710:	d101      	bne.n	1a716 <_svfprintf_r+0x4fe>
   1a712:	f000 fe2c 	bl	1b36e <_svfprintf_r+0x1156>
   1a716:	9811      	ldr	r0, [sp, #68]	; 0x44
   1a718:	0002      	movs	r2, r0
   1a71a:	6800      	ldr	r0, [r0, #0]
   1a71c:	3204      	adds	r2, #4
   1a71e:	900e      	str	r0, [sp, #56]	; 0x38
   1a720:	2000      	movs	r0, #0
   1a722:	900f      	str	r0, [sp, #60]	; 0x3c
   1a724:	a816      	add	r0, sp, #88	; 0x58
   1a726:	77c3      	strb	r3, [r0, #31]
   1a728:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   1a72a:	2b00      	cmp	r3, #0
   1a72c:	da01      	bge.n	1a732 <_svfprintf_r+0x51a>
   1a72e:	f000 fe12 	bl	1b356 <_svfprintf_r+0x113e>
   1a732:	2380      	movs	r3, #128	; 0x80
   1a734:	4399      	bics	r1, r3
   1a736:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   1a738:	9108      	str	r1, [sp, #32]
   1a73a:	9211      	str	r2, [sp, #68]	; 0x44
   1a73c:	2b00      	cmp	r3, #0
   1a73e:	d000      	beq.n	1a742 <_svfprintf_r+0x52a>
   1a740:	e658      	b.n	1a3f4 <_svfprintf_r+0x1dc>
   1a742:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   1a744:	2b00      	cmp	r3, #0
   1a746:	d101      	bne.n	1a74c <_svfprintf_r+0x534>
   1a748:	f001 f892 	bl	1b870 <_svfprintf_r+0x1658>
   1a74c:	2300      	movs	r3, #0
   1a74e:	4698      	mov	r8, r3
   1a750:	2300      	movs	r3, #0
   1a752:	2400      	movs	r4, #0
   1a754:	930e      	str	r3, [sp, #56]	; 0x38
   1a756:	940f      	str	r4, [sp, #60]	; 0x3c
   1a758:	e64e      	b.n	1a3f8 <_svfprintf_r+0x1e0>
   1a75a:	9313      	str	r3, [sp, #76]	; 0x4c
   1a75c:	46ab      	mov	fp, r5
   1a75e:	2a00      	cmp	r2, #0
   1a760:	d001      	beq.n	1a766 <_svfprintf_r+0x54e>
   1a762:	f001 f958 	bl	1ba16 <_svfprintf_r+0x17fe>
   1a766:	2310      	movs	r3, #16
   1a768:	9a08      	ldr	r2, [sp, #32]
   1a76a:	431a      	orrs	r2, r3
   1a76c:	9208      	str	r2, [sp, #32]
   1a76e:	2320      	movs	r3, #32
   1a770:	9908      	ldr	r1, [sp, #32]
   1a772:	400b      	ands	r3, r1
   1a774:	d100      	bne.n	1a778 <_svfprintf_r+0x560>
   1a776:	e371      	b.n	1ae5c <_svfprintf_r+0xc44>
   1a778:	2207      	movs	r2, #7
   1a77a:	9b11      	ldr	r3, [sp, #68]	; 0x44
   1a77c:	3307      	adds	r3, #7
   1a77e:	4393      	bics	r3, r2
   1a780:	3201      	adds	r2, #1
   1a782:	4694      	mov	ip, r2
   1a784:	449c      	add	ip, r3
   1a786:	4662      	mov	r2, ip
   1a788:	685c      	ldr	r4, [r3, #4]
   1a78a:	681b      	ldr	r3, [r3, #0]
   1a78c:	0025      	movs	r5, r4
   1a78e:	001c      	movs	r4, r3
   1a790:	2300      	movs	r3, #0
   1a792:	9211      	str	r2, [sp, #68]	; 0x44
   1a794:	aa16      	add	r2, sp, #88	; 0x58
   1a796:	77d3      	strb	r3, [r2, #31]
   1a798:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   1a79a:	940e      	str	r4, [sp, #56]	; 0x38
   1a79c:	950f      	str	r5, [sp, #60]	; 0x3c
   1a79e:	2b00      	cmp	r3, #0
   1a7a0:	da01      	bge.n	1a7a6 <_svfprintf_r+0x58e>
   1a7a2:	f000 fc7b 	bl	1b09c <_svfprintf_r+0xe84>
   1a7a6:	2380      	movs	r3, #128	; 0x80
   1a7a8:	4399      	bics	r1, r3
   1a7aa:	9108      	str	r1, [sp, #32]
   1a7ac:	0021      	movs	r1, r4
   1a7ae:	4329      	orrs	r1, r5
   1a7b0:	1e0b      	subs	r3, r1, #0
   1a7b2:	d100      	bne.n	1a7b6 <_svfprintf_r+0x59e>
   1a7b4:	e36c      	b.n	1ae90 <_svfprintf_r+0xc78>
   1a7b6:	2300      	movs	r3, #0
   1a7b8:	4698      	mov	r8, r3
   1a7ba:	e717      	b.n	1a5ec <_svfprintf_r+0x3d4>
   1a7bc:	9313      	str	r3, [sp, #76]	; 0x4c
   1a7be:	46ab      	mov	fp, r5
   1a7c0:	2a00      	cmp	r2, #0
   1a7c2:	d001      	beq.n	1a7c8 <_svfprintf_r+0x5b0>
   1a7c4:	f001 f91f 	bl	1ba06 <_svfprintf_r+0x17ee>
   1a7c8:	9b08      	ldr	r3, [sp, #32]
   1a7ca:	4992      	ldr	r1, [pc, #584]	; (1aa14 <_svfprintf_r+0x7fc>)
   1a7cc:	069b      	lsls	r3, r3, #26
   1a7ce:	d400      	bmi.n	1a7d2 <_svfprintf_r+0x5ba>
   1a7d0:	e0a5      	b.n	1a91e <_svfprintf_r+0x706>
   1a7d2:	2207      	movs	r2, #7
   1a7d4:	9b11      	ldr	r3, [sp, #68]	; 0x44
   1a7d6:	3307      	adds	r3, #7
   1a7d8:	4393      	bics	r3, r2
   1a7da:	3201      	adds	r2, #1
   1a7dc:	4694      	mov	ip, r2
   1a7de:	449c      	add	ip, r3
   1a7e0:	4662      	mov	r2, ip
   1a7e2:	685c      	ldr	r4, [r3, #4]
   1a7e4:	681b      	ldr	r3, [r3, #0]
   1a7e6:	930e      	str	r3, [sp, #56]	; 0x38
   1a7e8:	940f      	str	r4, [sp, #60]	; 0x3c
   1a7ea:	2301      	movs	r3, #1
   1a7ec:	9211      	str	r2, [sp, #68]	; 0x44
   1a7ee:	9a08      	ldr	r2, [sp, #32]
   1a7f0:	4013      	ands	r3, r2
   1a7f2:	d100      	bne.n	1a7f6 <_svfprintf_r+0x5de>
   1a7f4:	e0a7      	b.n	1a946 <_svfprintf_r+0x72e>
   1a7f6:	9a0e      	ldr	r2, [sp, #56]	; 0x38
   1a7f8:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   1a7fa:	0010      	movs	r0, r2
   1a7fc:	4318      	orrs	r0, r3
   1a7fe:	d101      	bne.n	1a804 <_svfprintf_r+0x5ec>
   1a800:	f000 fe08 	bl	1b414 <_svfprintf_r+0x11fc>
   1a804:	2230      	movs	r2, #48	; 0x30
   1a806:	ab1e      	add	r3, sp, #120	; 0x78
   1a808:	701a      	strb	r2, [r3, #0]
   1a80a:	204c      	movs	r0, #76	; 0x4c
   1a80c:	466a      	mov	r2, sp
   1a80e:	1812      	adds	r2, r2, r0
   1a810:	7812      	ldrb	r2, [r2, #0]
   1a812:	9c08      	ldr	r4, [sp, #32]
   1a814:	705a      	strb	r2, [r3, #1]
   1a816:	2200      	movs	r2, #0
   1a818:	2302      	movs	r3, #2
   1a81a:	0020      	movs	r0, r4
   1a81c:	ad16      	add	r5, sp, #88	; 0x58
   1a81e:	77ea      	strb	r2, [r5, #31]
   1a820:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
   1a822:	4318      	orrs	r0, r3
   1a824:	2a00      	cmp	r2, #0
   1a826:	da01      	bge.n	1a82c <_svfprintf_r+0x614>
   1a828:	f000 ffea 	bl	1b800 <_svfprintf_r+0x15e8>
   1a82c:	2280      	movs	r2, #128	; 0x80
   1a82e:	0020      	movs	r0, r4
   1a830:	4390      	bics	r0, r2
   1a832:	0002      	movs	r2, r0
   1a834:	431a      	orrs	r2, r3
   1a836:	2300      	movs	r3, #0
   1a838:	4698      	mov	r8, r3
   1a83a:	9208      	str	r2, [sp, #32]
   1a83c:	200f      	movs	r0, #15
   1a83e:	468c      	mov	ip, r1
   1a840:	46b1      	mov	r9, r6
   1a842:	ab32      	add	r3, sp, #200	; 0xc8
   1a844:	001c      	movs	r4, r3
   1a846:	9a0e      	ldr	r2, [sp, #56]	; 0x38
   1a848:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   1a84a:	0001      	movs	r1, r0
   1a84c:	4665      	mov	r5, ip
   1a84e:	4011      	ands	r1, r2
   1a850:	5c69      	ldrb	r1, [r5, r1]
   1a852:	3c01      	subs	r4, #1
   1a854:	071e      	lsls	r6, r3, #28
   1a856:	7021      	strb	r1, [r4, #0]
   1a858:	0911      	lsrs	r1, r2, #4
   1a85a:	091d      	lsrs	r5, r3, #4
   1a85c:	430e      	orrs	r6, r1
   1a85e:	002b      	movs	r3, r5
   1a860:	0035      	movs	r5, r6
   1a862:	0032      	movs	r2, r6
   1a864:	431d      	orrs	r5, r3
   1a866:	d1f0      	bne.n	1a84a <_svfprintf_r+0x632>
   1a868:	464e      	mov	r6, r9
   1a86a:	920e      	str	r2, [sp, #56]	; 0x38
   1a86c:	930f      	str	r3, [sp, #60]	; 0x3c
   1a86e:	9412      	str	r4, [sp, #72]	; 0x48
   1a870:	ab32      	add	r3, sp, #200	; 0xc8
   1a872:	1b1b      	subs	r3, r3, r4
   1a874:	9310      	str	r3, [sp, #64]	; 0x40
   1a876:	e5e8      	b.n	1a44a <_svfprintf_r+0x232>
   1a878:	9b11      	ldr	r3, [sp, #68]	; 0x44
   1a87a:	1d1c      	adds	r4, r3, #4
   1a87c:	681b      	ldr	r3, [r3, #0]
   1a87e:	930d      	str	r3, [sp, #52]	; 0x34
   1a880:	2b00      	cmp	r3, #0
   1a882:	da00      	bge.n	1a886 <_svfprintf_r+0x66e>
   1a884:	e534      	b.n	1a2f0 <_svfprintf_r+0xd8>
   1a886:	782b      	ldrb	r3, [r5, #0]
   1a888:	9411      	str	r4, [sp, #68]	; 0x44
   1a88a:	e527      	b.n	1a2dc <_svfprintf_r+0xc4>
   1a88c:	782b      	ldrb	r3, [r5, #0]
   1a88e:	2201      	movs	r2, #1
   1a890:	212b      	movs	r1, #43	; 0x2b
   1a892:	e523      	b.n	1a2dc <_svfprintf_r+0xc4>
   1a894:	2020      	movs	r0, #32
   1a896:	9b08      	ldr	r3, [sp, #32]
   1a898:	4303      	orrs	r3, r0
   1a89a:	9308      	str	r3, [sp, #32]
   1a89c:	782b      	ldrb	r3, [r5, #0]
   1a89e:	e51d      	b.n	1a2dc <_svfprintf_r+0xc4>
   1a8a0:	9313      	str	r3, [sp, #76]	; 0x4c
   1a8a2:	9b11      	ldr	r3, [sp, #68]	; 0x44
   1a8a4:	a916      	add	r1, sp, #88	; 0x58
   1a8a6:	1d1c      	adds	r4, r3, #4
   1a8a8:	681b      	ldr	r3, [r3, #0]
   1a8aa:	46ab      	mov	fp, r5
   1a8ac:	001a      	movs	r2, r3
   1a8ae:	9312      	str	r3, [sp, #72]	; 0x48
   1a8b0:	2300      	movs	r3, #0
   1a8b2:	77cb      	strb	r3, [r1, #31]
   1a8b4:	2a00      	cmp	r2, #0
   1a8b6:	d101      	bne.n	1a8bc <_svfprintf_r+0x6a4>
   1a8b8:	f000 ff65 	bl	1b786 <_svfprintf_r+0x156e>
   1a8bc:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   1a8be:	2b00      	cmp	r3, #0
   1a8c0:	da01      	bge.n	1a8c6 <_svfprintf_r+0x6ae>
   1a8c2:	f000 fe8d 	bl	1b5e0 <_svfprintf_r+0x13c8>
   1a8c6:	001a      	movs	r2, r3
   1a8c8:	2100      	movs	r1, #0
   1a8ca:	9812      	ldr	r0, [sp, #72]	; 0x48
   1a8cc:	f7fe fcb8 	bl	19240 <memchr>
   1a8d0:	2800      	cmp	r0, #0
   1a8d2:	d101      	bne.n	1a8d8 <_svfprintf_r+0x6c0>
   1a8d4:	f000 ffc0 	bl	1b858 <_svfprintf_r+0x1640>
   1a8d8:	9b12      	ldr	r3, [sp, #72]	; 0x48
   1a8da:	1ac3      	subs	r3, r0, r3
   1a8dc:	001a      	movs	r2, r3
   1a8de:	9310      	str	r3, [sp, #64]	; 0x40
   1a8e0:	43db      	mvns	r3, r3
   1a8e2:	17db      	asrs	r3, r3, #31
   1a8e4:	401a      	ands	r2, r3
   1a8e6:	2300      	movs	r3, #0
   1a8e8:	a916      	add	r1, sp, #88	; 0x58
   1a8ea:	7fc9      	ldrb	r1, [r1, #31]
   1a8ec:	920a      	str	r2, [sp, #40]	; 0x28
   1a8ee:	4688      	mov	r8, r1
   1a8f0:	9411      	str	r4, [sp, #68]	; 0x44
   1a8f2:	930b      	str	r3, [sp, #44]	; 0x2c
   1a8f4:	9315      	str	r3, [sp, #84]	; 0x54
   1a8f6:	e5b1      	b.n	1a45c <_svfprintf_r+0x244>
   1a8f8:	9313      	str	r3, [sp, #76]	; 0x4c
   1a8fa:	46ab      	mov	fp, r5
   1a8fc:	2a00      	cmp	r2, #0
   1a8fe:	d100      	bne.n	1a902 <_svfprintf_r+0x6ea>
   1a900:	e735      	b.n	1a76e <_svfprintf_r+0x556>
   1a902:	ab16      	add	r3, sp, #88	; 0x58
   1a904:	77d9      	strb	r1, [r3, #31]
   1a906:	e732      	b.n	1a76e <_svfprintf_r+0x556>
   1a908:	9313      	str	r3, [sp, #76]	; 0x4c
   1a90a:	46ab      	mov	fp, r5
   1a90c:	2a00      	cmp	r2, #0
   1a90e:	d001      	beq.n	1a914 <_svfprintf_r+0x6fc>
   1a910:	f001 f86a 	bl	1b9e8 <_svfprintf_r+0x17d0>
   1a914:	4940      	ldr	r1, [pc, #256]	; (1aa18 <_svfprintf_r+0x800>)
   1a916:	9b08      	ldr	r3, [sp, #32]
   1a918:	069b      	lsls	r3, r3, #26
   1a91a:	d500      	bpl.n	1a91e <_svfprintf_r+0x706>
   1a91c:	e759      	b.n	1a7d2 <_svfprintf_r+0x5ba>
   1a91e:	9b08      	ldr	r3, [sp, #32]
   1a920:	06db      	lsls	r3, r3, #27
   1a922:	d500      	bpl.n	1a926 <_svfprintf_r+0x70e>
   1a924:	e3d3      	b.n	1b0ce <_svfprintf_r+0xeb6>
   1a926:	9b08      	ldr	r3, [sp, #32]
   1a928:	065b      	lsls	r3, r3, #25
   1a92a:	d400      	bmi.n	1a92e <_svfprintf_r+0x716>
   1a92c:	e3cf      	b.n	1b0ce <_svfprintf_r+0xeb6>
   1a92e:	9b11      	ldr	r3, [sp, #68]	; 0x44
   1a930:	881a      	ldrh	r2, [r3, #0]
   1a932:	3304      	adds	r3, #4
   1a934:	920e      	str	r2, [sp, #56]	; 0x38
   1a936:	2200      	movs	r2, #0
   1a938:	9311      	str	r3, [sp, #68]	; 0x44
   1a93a:	920f      	str	r2, [sp, #60]	; 0x3c
   1a93c:	2301      	movs	r3, #1
   1a93e:	9a08      	ldr	r2, [sp, #32]
   1a940:	4013      	ands	r3, r2
   1a942:	d000      	beq.n	1a946 <_svfprintf_r+0x72e>
   1a944:	e757      	b.n	1a7f6 <_svfprintf_r+0x5de>
   1a946:	a816      	add	r0, sp, #88	; 0x58
   1a948:	77c3      	strb	r3, [r0, #31]
   1a94a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   1a94c:	2b00      	cmp	r3, #0
   1a94e:	da01      	bge.n	1a954 <_svfprintf_r+0x73c>
   1a950:	f000 fd79 	bl	1b446 <_svfprintf_r+0x122e>
   1a954:	2380      	movs	r3, #128	; 0x80
   1a956:	439a      	bics	r2, r3
   1a958:	9208      	str	r2, [sp, #32]
   1a95a:	9a0e      	ldr	r2, [sp, #56]	; 0x38
   1a95c:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   1a95e:	0010      	movs	r0, r2
   1a960:	4318      	orrs	r0, r3
   1a962:	d000      	beq.n	1a966 <_svfprintf_r+0x74e>
   1a964:	e088      	b.n	1aa78 <_svfprintf_r+0x860>
   1a966:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   1a968:	4698      	mov	r8, r3
   1a96a:	2b00      	cmp	r3, #0
   1a96c:	d000      	beq.n	1a970 <_svfprintf_r+0x758>
   1a96e:	e4f2      	b.n	1a356 <_svfprintf_r+0x13e>
   1a970:	2300      	movs	r3, #0
   1a972:	930b      	str	r3, [sp, #44]	; 0x2c
   1a974:	9310      	str	r3, [sp, #64]	; 0x40
   1a976:	ab32      	add	r3, sp, #200	; 0xc8
   1a978:	9312      	str	r3, [sp, #72]	; 0x48
   1a97a:	e566      	b.n	1a44a <_svfprintf_r+0x232>
   1a97c:	782b      	ldrb	r3, [r5, #0]
   1a97e:	2b6c      	cmp	r3, #108	; 0x6c
   1a980:	d101      	bne.n	1a986 <_svfprintf_r+0x76e>
   1a982:	f000 fdb8 	bl	1b4f6 <_svfprintf_r+0x12de>
   1a986:	464c      	mov	r4, r9
   1a988:	9808      	ldr	r0, [sp, #32]
   1a98a:	4320      	orrs	r0, r4
   1a98c:	9008      	str	r0, [sp, #32]
   1a98e:	e4a5      	b.n	1a2dc <_svfprintf_r+0xc4>
   1a990:	46ab      	mov	fp, r5
   1a992:	2a00      	cmp	r2, #0
   1a994:	d001      	beq.n	1a99a <_svfprintf_r+0x782>
   1a996:	f001 f823 	bl	1b9e0 <_svfprintf_r+0x17c8>
   1a99a:	9b08      	ldr	r3, [sp, #32]
   1a99c:	069b      	lsls	r3, r3, #26
   1a99e:	d401      	bmi.n	1a9a4 <_svfprintf_r+0x78c>
   1a9a0:	f000 fd1f 	bl	1b3e2 <_svfprintf_r+0x11ca>
   1a9a4:	9911      	ldr	r1, [sp, #68]	; 0x44
   1a9a6:	9a0c      	ldr	r2, [sp, #48]	; 0x30
   1a9a8:	680b      	ldr	r3, [r1, #0]
   1a9aa:	601a      	str	r2, [r3, #0]
   1a9ac:	17d2      	asrs	r2, r2, #31
   1a9ae:	605a      	str	r2, [r3, #4]
   1a9b0:	000b      	movs	r3, r1
   1a9b2:	3304      	adds	r3, #4
   1a9b4:	9311      	str	r3, [sp, #68]	; 0x44
   1a9b6:	e457      	b.n	1a268 <_svfprintf_r+0x50>
   1a9b8:	9313      	str	r3, [sp, #76]	; 0x4c
   1a9ba:	46ab      	mov	fp, r5
   1a9bc:	2a00      	cmp	r2, #0
   1a9be:	d100      	bne.n	1a9c2 <_svfprintf_r+0x7aa>
   1a9c0:	e5eb      	b.n	1a59a <_svfprintf_r+0x382>
   1a9c2:	ab16      	add	r3, sp, #88	; 0x58
   1a9c4:	77d9      	strb	r1, [r3, #31]
   1a9c6:	e5e8      	b.n	1a59a <_svfprintf_r+0x382>
   1a9c8:	9a11      	ldr	r2, [sp, #68]	; 0x44
   1a9ca:	9313      	str	r3, [sp, #76]	; 0x4c
   1a9cc:	6813      	ldr	r3, [r2, #0]
   1a9ce:	2128      	movs	r1, #40	; 0x28
   1a9d0:	930a      	str	r3, [sp, #40]	; 0x28
   1a9d2:	466b      	mov	r3, sp
   1a9d4:	185b      	adds	r3, r3, r1
   1a9d6:	781b      	ldrb	r3, [r3, #0]
   1a9d8:	46ab      	mov	fp, r5
   1a9da:	ad28      	add	r5, sp, #160	; 0xa0
   1a9dc:	702b      	strb	r3, [r5, #0]
   1a9de:	2300      	movs	r3, #0
   1a9e0:	a916      	add	r1, sp, #88	; 0x58
   1a9e2:	77cb      	strb	r3, [r1, #31]
   1a9e4:	0013      	movs	r3, r2
   1a9e6:	3304      	adds	r3, #4
   1a9e8:	9311      	str	r3, [sp, #68]	; 0x44
   1a9ea:	2300      	movs	r3, #0
   1a9ec:	4698      	mov	r8, r3
   1a9ee:	3301      	adds	r3, #1
   1a9f0:	930a      	str	r3, [sp, #40]	; 0x28
   1a9f2:	9310      	str	r3, [sp, #64]	; 0x40
   1a9f4:	2300      	movs	r3, #0
   1a9f6:	9512      	str	r5, [sp, #72]	; 0x48
   1a9f8:	930b      	str	r3, [sp, #44]	; 0x2c
   1a9fa:	9315      	str	r3, [sp, #84]	; 0x54
   1a9fc:	e534      	b.n	1a468 <_svfprintf_r+0x250>
   1a9fe:	782b      	ldrb	r3, [r5, #0]
   1aa00:	2900      	cmp	r1, #0
   1aa02:	d000      	beq.n	1aa06 <_svfprintf_r+0x7ee>
   1aa04:	e46a      	b.n	1a2dc <_svfprintf_r+0xc4>
   1aa06:	2201      	movs	r2, #1
   1aa08:	3120      	adds	r1, #32
   1aa0a:	e467      	b.n	1a2dc <_svfprintf_r+0xc4>
   1aa0c:	7fefffff 	.word	0x7fefffff
   1aa10:	00022d38 	.word	0x00022d38
   1aa14:	00022d48 	.word	0x00022d48
   1aa18:	00022d5c 	.word	0x00022d5c
   1aa1c:	2301      	movs	r3, #1
   1aa1e:	9808      	ldr	r0, [sp, #32]
   1aa20:	4318      	orrs	r0, r3
   1aa22:	9008      	str	r0, [sp, #32]
   1aa24:	782b      	ldrb	r3, [r5, #0]
   1aa26:	e459      	b.n	1a2dc <_svfprintf_r+0xc4>
   1aa28:	4660      	mov	r0, ip
   1aa2a:	9b08      	ldr	r3, [sp, #32]
   1aa2c:	4303      	orrs	r3, r0
   1aa2e:	9308      	str	r3, [sp, #32]
   1aa30:	782b      	ldrb	r3, [r5, #0]
   1aa32:	e453      	b.n	1a2dc <_svfprintf_r+0xc4>
   1aa34:	2300      	movs	r3, #0
   1aa36:	4698      	mov	r8, r3
   1aa38:	3378      	adds	r3, #120	; 0x78
   1aa3a:	49d0      	ldr	r1, [pc, #832]	; (1ad7c <_svfprintf_r+0xb64>)
   1aa3c:	9313      	str	r3, [sp, #76]	; 0x4c
   1aa3e:	e6fd      	b.n	1a83c <_svfprintf_r+0x624>
   1aa40:	9313      	str	r3, [sp, #76]	; 0x4c
   1aa42:	46ab      	mov	fp, r5
   1aa44:	2a00      	cmp	r2, #0
   1aa46:	d001      	beq.n	1aa4c <_svfprintf_r+0x834>
   1aa48:	f000 ffd3 	bl	1b9f2 <_svfprintf_r+0x17da>
   1aa4c:	9b13      	ldr	r3, [sp, #76]	; 0x4c
   1aa4e:	2b00      	cmp	r3, #0
   1aa50:	d100      	bne.n	1aa54 <_svfprintf_r+0x83c>
   1aa52:	e490      	b.n	1a376 <_svfprintf_r+0x15e>
   1aa54:	ad28      	add	r5, sp, #160	; 0xa0
   1aa56:	702b      	strb	r3, [r5, #0]
   1aa58:	2300      	movs	r3, #0
   1aa5a:	aa16      	add	r2, sp, #88	; 0x58
   1aa5c:	77d3      	strb	r3, [r2, #31]
   1aa5e:	e7c5      	b.n	1a9ec <_svfprintf_r+0x7d4>
   1aa60:	2378      	movs	r3, #120	; 0x78
   1aa62:	9108      	str	r1, [sp, #32]
   1aa64:	49c5      	ldr	r1, [pc, #788]	; (1ad7c <_svfprintf_r+0xb64>)
   1aa66:	9313      	str	r3, [sp, #76]	; 0x4c
   1aa68:	9a0e      	ldr	r2, [sp, #56]	; 0x38
   1aa6a:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   1aa6c:	0014      	movs	r4, r2
   1aa6e:	431c      	orrs	r4, r3
   1aa70:	1e23      	subs	r3, r4, #0
   1aa72:	9011      	str	r0, [sp, #68]	; 0x44
   1aa74:	d100      	bne.n	1aa78 <_svfprintf_r+0x860>
   1aa76:	e46f      	b.n	1a358 <_svfprintf_r+0x140>
   1aa78:	2300      	movs	r3, #0
   1aa7a:	4698      	mov	r8, r3
   1aa7c:	e6de      	b.n	1a83c <_svfprintf_r+0x624>
   1aa7e:	68bc      	ldr	r4, [r7, #8]
   1aa80:	4643      	mov	r3, r8
   1aa82:	2b00      	cmp	r3, #0
   1aa84:	d00f      	beq.n	1aaa6 <_svfprintf_r+0x88e>
   1aa86:	aa16      	add	r2, sp, #88	; 0x58
   1aa88:	231f      	movs	r3, #31
   1aa8a:	4694      	mov	ip, r2
   1aa8c:	4463      	add	r3, ip
   1aa8e:	6033      	str	r3, [r6, #0]
   1aa90:	2301      	movs	r3, #1
   1aa92:	6073      	str	r3, [r6, #4]
   1aa94:	687b      	ldr	r3, [r7, #4]
   1aa96:	3401      	adds	r4, #1
   1aa98:	3301      	adds	r3, #1
   1aa9a:	60bc      	str	r4, [r7, #8]
   1aa9c:	607b      	str	r3, [r7, #4]
   1aa9e:	2b07      	cmp	r3, #7
   1aaa0:	dd00      	ble.n	1aaa4 <_svfprintf_r+0x88c>
   1aaa2:	e219      	b.n	1aed8 <_svfprintf_r+0xcc0>
   1aaa4:	3608      	adds	r6, #8
   1aaa6:	4653      	mov	r3, sl
   1aaa8:	2b00      	cmp	r3, #0
   1aaaa:	d00c      	beq.n	1aac6 <_svfprintf_r+0x8ae>
   1aaac:	ab1e      	add	r3, sp, #120	; 0x78
   1aaae:	6033      	str	r3, [r6, #0]
   1aab0:	2302      	movs	r3, #2
   1aab2:	6073      	str	r3, [r6, #4]
   1aab4:	687b      	ldr	r3, [r7, #4]
   1aab6:	3402      	adds	r4, #2
   1aab8:	3301      	adds	r3, #1
   1aaba:	60bc      	str	r4, [r7, #8]
   1aabc:	607b      	str	r3, [r7, #4]
   1aabe:	2b07      	cmp	r3, #7
   1aac0:	dd00      	ble.n	1aac4 <_svfprintf_r+0x8ac>
   1aac2:	e215      	b.n	1aef0 <_svfprintf_r+0xcd8>
   1aac4:	3608      	adds	r6, #8
   1aac6:	464b      	mov	r3, r9
   1aac8:	2b80      	cmp	r3, #128	; 0x80
   1aaca:	d100      	bne.n	1aace <_svfprintf_r+0x8b6>
   1aacc:	e15e      	b.n	1ad8c <_svfprintf_r+0xb74>
   1aace:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   1aad0:	9a10      	ldr	r2, [sp, #64]	; 0x40
   1aad2:	1a9d      	subs	r5, r3, r2
   1aad4:	2d00      	cmp	r5, #0
   1aad6:	dd36      	ble.n	1ab46 <_svfprintf_r+0x92e>
   1aad8:	4aa9      	ldr	r2, [pc, #676]	; (1ad80 <_svfprintf_r+0xb68>)
   1aada:	687b      	ldr	r3, [r7, #4]
   1aadc:	4691      	mov	r9, r2
   1aade:	2d10      	cmp	r5, #16
   1aae0:	dd26      	ble.n	1ab30 <_svfprintf_r+0x918>
   1aae2:	2210      	movs	r2, #16
   1aae4:	0021      	movs	r1, r4
   1aae6:	4692      	mov	sl, r2
   1aae8:	9c09      	ldr	r4, [sp, #36]	; 0x24
   1aaea:	0032      	movs	r2, r6
   1aaec:	002e      	movs	r6, r5
   1aaee:	464d      	mov	r5, r9
   1aaf0:	e003      	b.n	1aafa <_svfprintf_r+0x8e2>
   1aaf2:	3e10      	subs	r6, #16
   1aaf4:	3208      	adds	r2, #8
   1aaf6:	2e10      	cmp	r6, #16
   1aaf8:	dd16      	ble.n	1ab28 <_svfprintf_r+0x910>
   1aafa:	4650      	mov	r0, sl
   1aafc:	3110      	adds	r1, #16
   1aafe:	3301      	adds	r3, #1
   1ab00:	6015      	str	r5, [r2, #0]
   1ab02:	6050      	str	r0, [r2, #4]
   1ab04:	60b9      	str	r1, [r7, #8]
   1ab06:	607b      	str	r3, [r7, #4]
   1ab08:	2b07      	cmp	r3, #7
   1ab0a:	ddf2      	ble.n	1aaf2 <_svfprintf_r+0x8da>
   1ab0c:	003a      	movs	r2, r7
   1ab0e:	9907      	ldr	r1, [sp, #28]
   1ab10:	0020      	movs	r0, r4
   1ab12:	f002 f967 	bl	1cde4 <__ssprint_r>
   1ab16:	2800      	cmp	r0, #0
   1ab18:	d000      	beq.n	1ab1c <_svfprintf_r+0x904>
   1ab1a:	e434      	b.n	1a386 <_svfprintf_r+0x16e>
   1ab1c:	3e10      	subs	r6, #16
   1ab1e:	68b9      	ldr	r1, [r7, #8]
   1ab20:	687b      	ldr	r3, [r7, #4]
   1ab22:	aa32      	add	r2, sp, #200	; 0xc8
   1ab24:	2e10      	cmp	r6, #16
   1ab26:	dce8      	bgt.n	1aafa <_svfprintf_r+0x8e2>
   1ab28:	46a9      	mov	r9, r5
   1ab2a:	000c      	movs	r4, r1
   1ab2c:	0035      	movs	r5, r6
   1ab2e:	0016      	movs	r6, r2
   1ab30:	464a      	mov	r2, r9
   1ab32:	1964      	adds	r4, r4, r5
   1ab34:	3301      	adds	r3, #1
   1ab36:	6032      	str	r2, [r6, #0]
   1ab38:	6075      	str	r5, [r6, #4]
   1ab3a:	60bc      	str	r4, [r7, #8]
   1ab3c:	607b      	str	r3, [r7, #4]
   1ab3e:	2b07      	cmp	r3, #7
   1ab40:	dd00      	ble.n	1ab44 <_svfprintf_r+0x92c>
   1ab42:	e1bd      	b.n	1aec0 <_svfprintf_r+0xca8>
   1ab44:	3608      	adds	r6, #8
   1ab46:	9b08      	ldr	r3, [sp, #32]
   1ab48:	05db      	lsls	r3, r3, #23
   1ab4a:	d500      	bpl.n	1ab4e <_svfprintf_r+0x936>
   1ab4c:	e0b8      	b.n	1acc0 <_svfprintf_r+0xaa8>
   1ab4e:	9b12      	ldr	r3, [sp, #72]	; 0x48
   1ab50:	6033      	str	r3, [r6, #0]
   1ab52:	9b10      	ldr	r3, [sp, #64]	; 0x40
   1ab54:	469c      	mov	ip, r3
   1ab56:	6073      	str	r3, [r6, #4]
   1ab58:	687b      	ldr	r3, [r7, #4]
   1ab5a:	4464      	add	r4, ip
   1ab5c:	3301      	adds	r3, #1
   1ab5e:	60bc      	str	r4, [r7, #8]
   1ab60:	607b      	str	r3, [r7, #4]
   1ab62:	2b07      	cmp	r3, #7
   1ab64:	dd00      	ble.n	1ab68 <_svfprintf_r+0x950>
   1ab66:	e09f      	b.n	1aca8 <_svfprintf_r+0xa90>
   1ab68:	3608      	adds	r6, #8
   1ab6a:	9b08      	ldr	r3, [sp, #32]
   1ab6c:	075b      	lsls	r3, r3, #29
   1ab6e:	d543      	bpl.n	1abf8 <_svfprintf_r+0x9e0>
   1ab70:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   1ab72:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   1ab74:	1a9d      	subs	r5, r3, r2
   1ab76:	2d00      	cmp	r5, #0
   1ab78:	dd3e      	ble.n	1abf8 <_svfprintf_r+0x9e0>
   1ab7a:	4a82      	ldr	r2, [pc, #520]	; (1ad84 <_svfprintf_r+0xb6c>)
   1ab7c:	687b      	ldr	r3, [r7, #4]
   1ab7e:	4690      	mov	r8, r2
   1ab80:	2d10      	cmp	r5, #16
   1ab82:	dd27      	ble.n	1abd4 <_svfprintf_r+0x9bc>
   1ab84:	2210      	movs	r2, #16
   1ab86:	0021      	movs	r1, r4
   1ab88:	4691      	mov	r9, r2
   1ab8a:	9c09      	ldr	r4, [sp, #36]	; 0x24
   1ab8c:	0032      	movs	r2, r6
   1ab8e:	002e      	movs	r6, r5
   1ab90:	4645      	mov	r5, r8
   1ab92:	e003      	b.n	1ab9c <_svfprintf_r+0x984>
   1ab94:	3e10      	subs	r6, #16
   1ab96:	3208      	adds	r2, #8
   1ab98:	2e10      	cmp	r6, #16
   1ab9a:	dd17      	ble.n	1abcc <_svfprintf_r+0x9b4>
   1ab9c:	4648      	mov	r0, r9
   1ab9e:	3110      	adds	r1, #16
   1aba0:	3301      	adds	r3, #1
   1aba2:	6015      	str	r5, [r2, #0]
   1aba4:	6050      	str	r0, [r2, #4]
   1aba6:	60b9      	str	r1, [r7, #8]
   1aba8:	607b      	str	r3, [r7, #4]
   1abaa:	2b07      	cmp	r3, #7
   1abac:	ddf2      	ble.n	1ab94 <_svfprintf_r+0x97c>
   1abae:	003a      	movs	r2, r7
   1abb0:	9907      	ldr	r1, [sp, #28]
   1abb2:	0020      	movs	r0, r4
   1abb4:	f002 f916 	bl	1cde4 <__ssprint_r>
   1abb8:	2800      	cmp	r0, #0
   1abba:	d001      	beq.n	1abc0 <_svfprintf_r+0x9a8>
   1abbc:	f7ff fbe3 	bl	1a386 <_svfprintf_r+0x16e>
   1abc0:	3e10      	subs	r6, #16
   1abc2:	68b9      	ldr	r1, [r7, #8]
   1abc4:	687b      	ldr	r3, [r7, #4]
   1abc6:	aa32      	add	r2, sp, #200	; 0xc8
   1abc8:	2e10      	cmp	r6, #16
   1abca:	dce7      	bgt.n	1ab9c <_svfprintf_r+0x984>
   1abcc:	46a8      	mov	r8, r5
   1abce:	000c      	movs	r4, r1
   1abd0:	0035      	movs	r5, r6
   1abd2:	0016      	movs	r6, r2
   1abd4:	4642      	mov	r2, r8
   1abd6:	1964      	adds	r4, r4, r5
   1abd8:	3301      	adds	r3, #1
   1abda:	c624      	stmia	r6!, {r2, r5}
   1abdc:	60bc      	str	r4, [r7, #8]
   1abde:	607b      	str	r3, [r7, #4]
   1abe0:	2b07      	cmp	r3, #7
   1abe2:	dd09      	ble.n	1abf8 <_svfprintf_r+0x9e0>
   1abe4:	003a      	movs	r2, r7
   1abe6:	9907      	ldr	r1, [sp, #28]
   1abe8:	9809      	ldr	r0, [sp, #36]	; 0x24
   1abea:	f002 f8fb 	bl	1cde4 <__ssprint_r>
   1abee:	2800      	cmp	r0, #0
   1abf0:	d001      	beq.n	1abf6 <_svfprintf_r+0x9de>
   1abf2:	f7ff fbc8 	bl	1a386 <_svfprintf_r+0x16e>
   1abf6:	68bc      	ldr	r4, [r7, #8]
   1abf8:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   1abfa:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   1abfc:	4293      	cmp	r3, r2
   1abfe:	da00      	bge.n	1ac02 <_svfprintf_r+0x9ea>
   1ac00:	0013      	movs	r3, r2
   1ac02:	9a0c      	ldr	r2, [sp, #48]	; 0x30
   1ac04:	4694      	mov	ip, r2
   1ac06:	449c      	add	ip, r3
   1ac08:	4663      	mov	r3, ip
   1ac0a:	930c      	str	r3, [sp, #48]	; 0x30
   1ac0c:	2c00      	cmp	r4, #0
   1ac0e:	d000      	beq.n	1ac12 <_svfprintf_r+0x9fa>
   1ac10:	e11a      	b.n	1ae48 <_svfprintf_r+0xc30>
   1ac12:	2300      	movs	r3, #0
   1ac14:	ae32      	add	r6, sp, #200	; 0xc8
   1ac16:	607b      	str	r3, [r7, #4]
   1ac18:	f7ff fb26 	bl	1a268 <_svfprintf_r+0x50>
   1ac1c:	9b14      	ldr	r3, [sp, #80]	; 0x50
   1ac1e:	2b01      	cmp	r3, #1
   1ac20:	dc00      	bgt.n	1ac24 <_svfprintf_r+0xa0c>
   1ac22:	e0f2      	b.n	1ae0a <_svfprintf_r+0xbf2>
   1ac24:	9b12      	ldr	r3, [sp, #72]	; 0x48
   1ac26:	3401      	adds	r4, #1
   1ac28:	6033      	str	r3, [r6, #0]
   1ac2a:	2301      	movs	r3, #1
   1ac2c:	6073      	str	r3, [r6, #4]
   1ac2e:	687b      	ldr	r3, [r7, #4]
   1ac30:	60bc      	str	r4, [r7, #8]
   1ac32:	3301      	adds	r3, #1
   1ac34:	607b      	str	r3, [r7, #4]
   1ac36:	2b07      	cmp	r3, #7
   1ac38:	dd00      	ble.n	1ac3c <_svfprintf_r+0xa24>
   1ac3a:	e2c5      	b.n	1b1c8 <_svfprintf_r+0xfb0>
   1ac3c:	3608      	adds	r6, #8
   1ac3e:	9a19      	ldr	r2, [sp, #100]	; 0x64
   1ac40:	3301      	adds	r3, #1
   1ac42:	6032      	str	r2, [r6, #0]
   1ac44:	9a18      	ldr	r2, [sp, #96]	; 0x60
   1ac46:	4698      	mov	r8, r3
   1ac48:	4694      	mov	ip, r2
   1ac4a:	4464      	add	r4, ip
   1ac4c:	6072      	str	r2, [r6, #4]
   1ac4e:	60bc      	str	r4, [r7, #8]
   1ac50:	607b      	str	r3, [r7, #4]
   1ac52:	2b07      	cmp	r3, #7
   1ac54:	dd00      	ble.n	1ac58 <_svfprintf_r+0xa40>
   1ac56:	e2c4      	b.n	1b1e2 <_svfprintf_r+0xfca>
   1ac58:	3608      	adds	r6, #8
   1ac5a:	2200      	movs	r2, #0
   1ac5c:	2300      	movs	r3, #0
   1ac5e:	9816      	ldr	r0, [sp, #88]	; 0x58
   1ac60:	9917      	ldr	r1, [sp, #92]	; 0x5c
   1ac62:	f003 f8a7 	bl	1ddb4 <__aeabi_dcmpeq>
   1ac66:	2800      	cmp	r0, #0
   1ac68:	d000      	beq.n	1ac6c <_svfprintf_r+0xa54>
   1ac6a:	e1ac      	b.n	1afc6 <_svfprintf_r+0xdae>
   1ac6c:	9d12      	ldr	r5, [sp, #72]	; 0x48
   1ac6e:	9b14      	ldr	r3, [sp, #80]	; 0x50
   1ac70:	3501      	adds	r5, #1
   1ac72:	3b01      	subs	r3, #1
   1ac74:	6035      	str	r5, [r6, #0]
   1ac76:	6073      	str	r3, [r6, #4]
   1ac78:	18e4      	adds	r4, r4, r3
   1ac7a:	2301      	movs	r3, #1
   1ac7c:	469c      	mov	ip, r3
   1ac7e:	44e0      	add	r8, ip
   1ac80:	4643      	mov	r3, r8
   1ac82:	60bc      	str	r4, [r7, #8]
   1ac84:	607b      	str	r3, [r7, #4]
   1ac86:	2b07      	cmp	r3, #7
   1ac88:	dd00      	ble.n	1ac8c <_svfprintf_r+0xa74>
   1ac8a:	e0cf      	b.n	1ae2c <_svfprintf_r+0xc14>
   1ac8c:	3608      	adds	r6, #8
   1ac8e:	ab21      	add	r3, sp, #132	; 0x84
   1ac90:	6033      	str	r3, [r6, #0]
   1ac92:	9b1a      	ldr	r3, [sp, #104]	; 0x68
   1ac94:	469c      	mov	ip, r3
   1ac96:	6073      	str	r3, [r6, #4]
   1ac98:	4643      	mov	r3, r8
   1ac9a:	4464      	add	r4, ip
   1ac9c:	3301      	adds	r3, #1
   1ac9e:	60bc      	str	r4, [r7, #8]
   1aca0:	607b      	str	r3, [r7, #4]
   1aca2:	2b07      	cmp	r3, #7
   1aca4:	dc00      	bgt.n	1aca8 <_svfprintf_r+0xa90>
   1aca6:	e75f      	b.n	1ab68 <_svfprintf_r+0x950>
   1aca8:	003a      	movs	r2, r7
   1acaa:	9907      	ldr	r1, [sp, #28]
   1acac:	9809      	ldr	r0, [sp, #36]	; 0x24
   1acae:	f002 f899 	bl	1cde4 <__ssprint_r>
   1acb2:	2800      	cmp	r0, #0
   1acb4:	d001      	beq.n	1acba <_svfprintf_r+0xaa2>
   1acb6:	f7ff fb66 	bl	1a386 <_svfprintf_r+0x16e>
   1acba:	68bc      	ldr	r4, [r7, #8]
   1acbc:	ae32      	add	r6, sp, #200	; 0xc8
   1acbe:	e754      	b.n	1ab6a <_svfprintf_r+0x952>
   1acc0:	9b13      	ldr	r3, [sp, #76]	; 0x4c
   1acc2:	2b65      	cmp	r3, #101	; 0x65
   1acc4:	ddaa      	ble.n	1ac1c <_svfprintf_r+0xa04>
   1acc6:	2200      	movs	r2, #0
   1acc8:	2300      	movs	r3, #0
   1acca:	9816      	ldr	r0, [sp, #88]	; 0x58
   1accc:	9917      	ldr	r1, [sp, #92]	; 0x5c
   1acce:	f003 f871 	bl	1ddb4 <__aeabi_dcmpeq>
   1acd2:	2800      	cmp	r0, #0
   1acd4:	d100      	bne.n	1acd8 <_svfprintf_r+0xac0>
   1acd6:	e117      	b.n	1af08 <_svfprintf_r+0xcf0>
   1acd8:	4b2b      	ldr	r3, [pc, #172]	; (1ad88 <_svfprintf_r+0xb70>)
   1acda:	3401      	adds	r4, #1
   1acdc:	6033      	str	r3, [r6, #0]
   1acde:	2301      	movs	r3, #1
   1ace0:	6073      	str	r3, [r6, #4]
   1ace2:	687b      	ldr	r3, [r7, #4]
   1ace4:	60bc      	str	r4, [r7, #8]
   1ace6:	3301      	adds	r3, #1
   1ace8:	607b      	str	r3, [r7, #4]
   1acea:	2b07      	cmp	r3, #7
   1acec:	dd00      	ble.n	1acf0 <_svfprintf_r+0xad8>
   1acee:	e39e      	b.n	1b42e <_svfprintf_r+0x1216>
   1acf0:	3608      	adds	r6, #8
   1acf2:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   1acf4:	9a14      	ldr	r2, [sp, #80]	; 0x50
   1acf6:	4293      	cmp	r3, r2
   1acf8:	db03      	blt.n	1ad02 <_svfprintf_r+0xaea>
   1acfa:	9b08      	ldr	r3, [sp, #32]
   1acfc:	07db      	lsls	r3, r3, #31
   1acfe:	d400      	bmi.n	1ad02 <_svfprintf_r+0xaea>
   1ad00:	e733      	b.n	1ab6a <_svfprintf_r+0x952>
   1ad02:	9b19      	ldr	r3, [sp, #100]	; 0x64
   1ad04:	6033      	str	r3, [r6, #0]
   1ad06:	9b18      	ldr	r3, [sp, #96]	; 0x60
   1ad08:	469c      	mov	ip, r3
   1ad0a:	6073      	str	r3, [r6, #4]
   1ad0c:	687b      	ldr	r3, [r7, #4]
   1ad0e:	4464      	add	r4, ip
   1ad10:	3301      	adds	r3, #1
   1ad12:	60bc      	str	r4, [r7, #8]
   1ad14:	607b      	str	r3, [r7, #4]
   1ad16:	2b07      	cmp	r3, #7
   1ad18:	dd01      	ble.n	1ad1e <_svfprintf_r+0xb06>
   1ad1a:	f000 fbf4 	bl	1b506 <_svfprintf_r+0x12ee>
   1ad1e:	3608      	adds	r6, #8
   1ad20:	9b14      	ldr	r3, [sp, #80]	; 0x50
   1ad22:	1e5d      	subs	r5, r3, #1
   1ad24:	2d00      	cmp	r5, #0
   1ad26:	dc00      	bgt.n	1ad2a <_svfprintf_r+0xb12>
   1ad28:	e71f      	b.n	1ab6a <_svfprintf_r+0x952>
   1ad2a:	4a15      	ldr	r2, [pc, #84]	; (1ad80 <_svfprintf_r+0xb68>)
   1ad2c:	687b      	ldr	r3, [r7, #4]
   1ad2e:	4691      	mov	r9, r2
   1ad30:	2d10      	cmp	r5, #16
   1ad32:	dc00      	bgt.n	1ad36 <_svfprintf_r+0xb1e>
   1ad34:	e1c0      	b.n	1b0b8 <_svfprintf_r+0xea0>
   1ad36:	2210      	movs	r2, #16
   1ad38:	0021      	movs	r1, r4
   1ad3a:	4690      	mov	r8, r2
   1ad3c:	9c09      	ldr	r4, [sp, #36]	; 0x24
   1ad3e:	0032      	movs	r2, r6
   1ad40:	002e      	movs	r6, r5
   1ad42:	464d      	mov	r5, r9
   1ad44:	e004      	b.n	1ad50 <_svfprintf_r+0xb38>
   1ad46:	3208      	adds	r2, #8
   1ad48:	3e10      	subs	r6, #16
   1ad4a:	2e10      	cmp	r6, #16
   1ad4c:	dc00      	bgt.n	1ad50 <_svfprintf_r+0xb38>
   1ad4e:	e1af      	b.n	1b0b0 <_svfprintf_r+0xe98>
   1ad50:	4640      	mov	r0, r8
   1ad52:	3110      	adds	r1, #16
   1ad54:	3301      	adds	r3, #1
   1ad56:	6015      	str	r5, [r2, #0]
   1ad58:	6050      	str	r0, [r2, #4]
   1ad5a:	60b9      	str	r1, [r7, #8]
   1ad5c:	607b      	str	r3, [r7, #4]
   1ad5e:	2b07      	cmp	r3, #7
   1ad60:	ddf1      	ble.n	1ad46 <_svfprintf_r+0xb2e>
   1ad62:	003a      	movs	r2, r7
   1ad64:	9907      	ldr	r1, [sp, #28]
   1ad66:	0020      	movs	r0, r4
   1ad68:	f002 f83c 	bl	1cde4 <__ssprint_r>
   1ad6c:	2800      	cmp	r0, #0
   1ad6e:	d001      	beq.n	1ad74 <_svfprintf_r+0xb5c>
   1ad70:	f7ff fb09 	bl	1a386 <_svfprintf_r+0x16e>
   1ad74:	68b9      	ldr	r1, [r7, #8]
   1ad76:	687b      	ldr	r3, [r7, #4]
   1ad78:	aa32      	add	r2, sp, #200	; 0xc8
   1ad7a:	e7e5      	b.n	1ad48 <_svfprintf_r+0xb30>
   1ad7c:	00022d5c 	.word	0x00022d5c
   1ad80:	0002302c 	.word	0x0002302c
   1ad84:	0002303c 	.word	0x0002303c
   1ad88:	00022d78 	.word	0x00022d78
   1ad8c:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   1ad8e:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   1ad90:	1a9d      	subs	r5, r3, r2
   1ad92:	2d00      	cmp	r5, #0
   1ad94:	dc00      	bgt.n	1ad98 <_svfprintf_r+0xb80>
   1ad96:	e69a      	b.n	1aace <_svfprintf_r+0x8b6>
   1ad98:	4ad1      	ldr	r2, [pc, #836]	; (1b0e0 <_svfprintf_r+0xec8>)
   1ad9a:	687b      	ldr	r3, [r7, #4]
   1ad9c:	4691      	mov	r9, r2
   1ad9e:	2d10      	cmp	r5, #16
   1ada0:	dd27      	ble.n	1adf2 <_svfprintf_r+0xbda>
   1ada2:	2210      	movs	r2, #16
   1ada4:	0021      	movs	r1, r4
   1ada6:	4692      	mov	sl, r2
   1ada8:	9c09      	ldr	r4, [sp, #36]	; 0x24
   1adaa:	0032      	movs	r2, r6
   1adac:	002e      	movs	r6, r5
   1adae:	464d      	mov	r5, r9
   1adb0:	e003      	b.n	1adba <_svfprintf_r+0xba2>
   1adb2:	3e10      	subs	r6, #16
   1adb4:	3208      	adds	r2, #8
   1adb6:	2e10      	cmp	r6, #16
   1adb8:	dd17      	ble.n	1adea <_svfprintf_r+0xbd2>
   1adba:	4650      	mov	r0, sl
   1adbc:	3110      	adds	r1, #16
   1adbe:	3301      	adds	r3, #1
   1adc0:	6015      	str	r5, [r2, #0]
   1adc2:	6050      	str	r0, [r2, #4]
   1adc4:	60b9      	str	r1, [r7, #8]
   1adc6:	607b      	str	r3, [r7, #4]
   1adc8:	2b07      	cmp	r3, #7
   1adca:	ddf2      	ble.n	1adb2 <_svfprintf_r+0xb9a>
   1adcc:	003a      	movs	r2, r7
   1adce:	9907      	ldr	r1, [sp, #28]
   1add0:	0020      	movs	r0, r4
   1add2:	f002 f807 	bl	1cde4 <__ssprint_r>
   1add6:	2800      	cmp	r0, #0
   1add8:	d001      	beq.n	1adde <_svfprintf_r+0xbc6>
   1adda:	f7ff fad4 	bl	1a386 <_svfprintf_r+0x16e>
   1adde:	3e10      	subs	r6, #16
   1ade0:	68b9      	ldr	r1, [r7, #8]
   1ade2:	687b      	ldr	r3, [r7, #4]
   1ade4:	aa32      	add	r2, sp, #200	; 0xc8
   1ade6:	2e10      	cmp	r6, #16
   1ade8:	dce7      	bgt.n	1adba <_svfprintf_r+0xba2>
   1adea:	46a9      	mov	r9, r5
   1adec:	000c      	movs	r4, r1
   1adee:	0035      	movs	r5, r6
   1adf0:	0016      	movs	r6, r2
   1adf2:	464a      	mov	r2, r9
   1adf4:	1964      	adds	r4, r4, r5
   1adf6:	3301      	adds	r3, #1
   1adf8:	6032      	str	r2, [r6, #0]
   1adfa:	6075      	str	r5, [r6, #4]
   1adfc:	60bc      	str	r4, [r7, #8]
   1adfe:	607b      	str	r3, [r7, #4]
   1ae00:	2b07      	cmp	r3, #7
   1ae02:	dd00      	ble.n	1ae06 <_svfprintf_r+0xbee>
   1ae04:	e1fb      	b.n	1b1fe <_svfprintf_r+0xfe6>
   1ae06:	3608      	adds	r6, #8
   1ae08:	e661      	b.n	1aace <_svfprintf_r+0x8b6>
   1ae0a:	2301      	movs	r3, #1
   1ae0c:	9a08      	ldr	r2, [sp, #32]
   1ae0e:	4213      	tst	r3, r2
   1ae10:	d000      	beq.n	1ae14 <_svfprintf_r+0xbfc>
   1ae12:	e707      	b.n	1ac24 <_svfprintf_r+0xa0c>
   1ae14:	6073      	str	r3, [r6, #4]
   1ae16:	687b      	ldr	r3, [r7, #4]
   1ae18:	9a12      	ldr	r2, [sp, #72]	; 0x48
   1ae1a:	3301      	adds	r3, #1
   1ae1c:	3401      	adds	r4, #1
   1ae1e:	6032      	str	r2, [r6, #0]
   1ae20:	60bc      	str	r4, [r7, #8]
   1ae22:	4698      	mov	r8, r3
   1ae24:	607b      	str	r3, [r7, #4]
   1ae26:	2b07      	cmp	r3, #7
   1ae28:	dc00      	bgt.n	1ae2c <_svfprintf_r+0xc14>
   1ae2a:	e72f      	b.n	1ac8c <_svfprintf_r+0xa74>
   1ae2c:	003a      	movs	r2, r7
   1ae2e:	9907      	ldr	r1, [sp, #28]
   1ae30:	9809      	ldr	r0, [sp, #36]	; 0x24
   1ae32:	f001 ffd7 	bl	1cde4 <__ssprint_r>
   1ae36:	2800      	cmp	r0, #0
   1ae38:	d001      	beq.n	1ae3e <_svfprintf_r+0xc26>
   1ae3a:	f7ff faa4 	bl	1a386 <_svfprintf_r+0x16e>
   1ae3e:	687b      	ldr	r3, [r7, #4]
   1ae40:	68bc      	ldr	r4, [r7, #8]
   1ae42:	4698      	mov	r8, r3
   1ae44:	ae32      	add	r6, sp, #200	; 0xc8
   1ae46:	e722      	b.n	1ac8e <_svfprintf_r+0xa76>
   1ae48:	003a      	movs	r2, r7
   1ae4a:	9907      	ldr	r1, [sp, #28]
   1ae4c:	9809      	ldr	r0, [sp, #36]	; 0x24
   1ae4e:	f001 ffc9 	bl	1cde4 <__ssprint_r>
   1ae52:	2800      	cmp	r0, #0
   1ae54:	d100      	bne.n	1ae58 <_svfprintf_r+0xc40>
   1ae56:	e6dc      	b.n	1ac12 <_svfprintf_r+0x9fa>
   1ae58:	f7ff fa95 	bl	1a386 <_svfprintf_r+0x16e>
   1ae5c:	2210      	movs	r2, #16
   1ae5e:	9908      	ldr	r1, [sp, #32]
   1ae60:	400a      	ands	r2, r1
   1ae62:	d100      	bne.n	1ae66 <_svfprintf_r+0xc4e>
   1ae64:	e29f      	b.n	1b3a6 <_svfprintf_r+0x118e>
   1ae66:	9811      	ldr	r0, [sp, #68]	; 0x44
   1ae68:	0002      	movs	r2, r0
   1ae6a:	6800      	ldr	r0, [r0, #0]
   1ae6c:	3204      	adds	r2, #4
   1ae6e:	900e      	str	r0, [sp, #56]	; 0x38
   1ae70:	2000      	movs	r0, #0
   1ae72:	900f      	str	r0, [sp, #60]	; 0x3c
   1ae74:	a816      	add	r0, sp, #88	; 0x58
   1ae76:	77c3      	strb	r3, [r0, #31]
   1ae78:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   1ae7a:	2b00      	cmp	r3, #0
   1ae7c:	da00      	bge.n	1ae80 <_svfprintf_r+0xc68>
   1ae7e:	e10c      	b.n	1b09a <_svfprintf_r+0xe82>
   1ae80:	2380      	movs	r3, #128	; 0x80
   1ae82:	4399      	bics	r1, r3
   1ae84:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   1ae86:	9108      	str	r1, [sp, #32]
   1ae88:	9211      	str	r2, [sp, #68]	; 0x44
   1ae8a:	2b00      	cmp	r3, #0
   1ae8c:	d000      	beq.n	1ae90 <_svfprintf_r+0xc78>
   1ae8e:	e492      	b.n	1a7b6 <_svfprintf_r+0x59e>
   1ae90:	4698      	mov	r8, r3
   1ae92:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   1ae94:	2b00      	cmp	r3, #0
   1ae96:	d100      	bne.n	1ae9a <_svfprintf_r+0xc82>
   1ae98:	e56a      	b.n	1a970 <_svfprintf_r+0x758>
   1ae9a:	2300      	movs	r3, #0
   1ae9c:	2400      	movs	r4, #0
   1ae9e:	930e      	str	r3, [sp, #56]	; 0x38
   1aea0:	940f      	str	r4, [sp, #60]	; 0x3c
   1aea2:	2227      	movs	r2, #39	; 0x27
   1aea4:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   1aea6:	a928      	add	r1, sp, #160	; 0xa0
   1aea8:	3330      	adds	r3, #48	; 0x30
   1aeaa:	548b      	strb	r3, [r1, r2]
   1aeac:	ab16      	add	r3, sp, #88	; 0x58
   1aeae:	469c      	mov	ip, r3
   1aeb0:	256f      	movs	r5, #111	; 0x6f
   1aeb2:	ab32      	add	r3, sp, #200	; 0xc8
   1aeb4:	4465      	add	r5, ip
   1aeb6:	1b5b      	subs	r3, r3, r5
   1aeb8:	9310      	str	r3, [sp, #64]	; 0x40
   1aeba:	9512      	str	r5, [sp, #72]	; 0x48
   1aebc:	f7ff fac5 	bl	1a44a <_svfprintf_r+0x232>
   1aec0:	003a      	movs	r2, r7
   1aec2:	9907      	ldr	r1, [sp, #28]
   1aec4:	9809      	ldr	r0, [sp, #36]	; 0x24
   1aec6:	f001 ff8d 	bl	1cde4 <__ssprint_r>
   1aeca:	2800      	cmp	r0, #0
   1aecc:	d001      	beq.n	1aed2 <_svfprintf_r+0xcba>
   1aece:	f7ff fa5a 	bl	1a386 <_svfprintf_r+0x16e>
   1aed2:	68bc      	ldr	r4, [r7, #8]
   1aed4:	ae32      	add	r6, sp, #200	; 0xc8
   1aed6:	e636      	b.n	1ab46 <_svfprintf_r+0x92e>
   1aed8:	003a      	movs	r2, r7
   1aeda:	9907      	ldr	r1, [sp, #28]
   1aedc:	9809      	ldr	r0, [sp, #36]	; 0x24
   1aede:	f001 ff81 	bl	1cde4 <__ssprint_r>
   1aee2:	2800      	cmp	r0, #0
   1aee4:	d001      	beq.n	1aeea <_svfprintf_r+0xcd2>
   1aee6:	f7ff fa4e 	bl	1a386 <_svfprintf_r+0x16e>
   1aeea:	68bc      	ldr	r4, [r7, #8]
   1aeec:	ae32      	add	r6, sp, #200	; 0xc8
   1aeee:	e5da      	b.n	1aaa6 <_svfprintf_r+0x88e>
   1aef0:	003a      	movs	r2, r7
   1aef2:	9907      	ldr	r1, [sp, #28]
   1aef4:	9809      	ldr	r0, [sp, #36]	; 0x24
   1aef6:	f001 ff75 	bl	1cde4 <__ssprint_r>
   1aefa:	2800      	cmp	r0, #0
   1aefc:	d001      	beq.n	1af02 <_svfprintf_r+0xcea>
   1aefe:	f7ff fa42 	bl	1a386 <_svfprintf_r+0x16e>
   1af02:	68bc      	ldr	r4, [r7, #8]
   1af04:	ae32      	add	r6, sp, #200	; 0xc8
   1af06:	e5de      	b.n	1aac6 <_svfprintf_r+0x8ae>
   1af08:	981f      	ldr	r0, [sp, #124]	; 0x7c
   1af0a:	2800      	cmp	r0, #0
   1af0c:	dc00      	bgt.n	1af10 <_svfprintf_r+0xcf8>
   1af0e:	e29d      	b.n	1b44c <_svfprintf_r+0x1234>
   1af10:	9a15      	ldr	r2, [sp, #84]	; 0x54
   1af12:	9914      	ldr	r1, [sp, #80]	; 0x50
   1af14:	0013      	movs	r3, r2
   1af16:	4691      	mov	r9, r2
   1af18:	428b      	cmp	r3, r1
   1af1a:	dd00      	ble.n	1af1e <_svfprintf_r+0xd06>
   1af1c:	4689      	mov	r9, r1
   1af1e:	464b      	mov	r3, r9
   1af20:	2b00      	cmp	r3, #0
   1af22:	dd0c      	ble.n	1af3e <_svfprintf_r+0xd26>
   1af24:	9b12      	ldr	r3, [sp, #72]	; 0x48
   1af26:	444c      	add	r4, r9
   1af28:	6033      	str	r3, [r6, #0]
   1af2a:	464b      	mov	r3, r9
   1af2c:	6073      	str	r3, [r6, #4]
   1af2e:	687b      	ldr	r3, [r7, #4]
   1af30:	60bc      	str	r4, [r7, #8]
   1af32:	3301      	adds	r3, #1
   1af34:	607b      	str	r3, [r7, #4]
   1af36:	2b07      	cmp	r3, #7
   1af38:	dd00      	ble.n	1af3c <_svfprintf_r+0xd24>
   1af3a:	e397      	b.n	1b66c <_svfprintf_r+0x1454>
   1af3c:	3608      	adds	r6, #8
   1af3e:	464b      	mov	r3, r9
   1af40:	43db      	mvns	r3, r3
   1af42:	464a      	mov	r2, r9
   1af44:	17db      	asrs	r3, r3, #31
   1af46:	4013      	ands	r3, r2
   1af48:	9a15      	ldr	r2, [sp, #84]	; 0x54
   1af4a:	1ad3      	subs	r3, r2, r3
   1af4c:	4698      	mov	r8, r3
   1af4e:	2b00      	cmp	r3, #0
   1af50:	dc00      	bgt.n	1af54 <_svfprintf_r+0xd3c>
   1af52:	e0d7      	b.n	1b104 <_svfprintf_r+0xeec>
   1af54:	2b10      	cmp	r3, #16
   1af56:	dc01      	bgt.n	1af5c <_svfprintf_r+0xd44>
   1af58:	f000 fd06 	bl	1b968 <_svfprintf_r+0x1750>
   1af5c:	4a60      	ldr	r2, [pc, #384]	; (1b0e0 <_svfprintf_r+0xec8>)
   1af5e:	0021      	movs	r1, r4
   1af60:	4691      	mov	r9, r2
   1af62:	2210      	movs	r2, #16
   1af64:	687b      	ldr	r3, [r7, #4]
   1af66:	4692      	mov	sl, r2
   1af68:	9d09      	ldr	r5, [sp, #36]	; 0x24
   1af6a:	0032      	movs	r2, r6
   1af6c:	464c      	mov	r4, r9
   1af6e:	4646      	mov	r6, r8
   1af70:	e004      	b.n	1af7c <_svfprintf_r+0xd64>
   1af72:	3208      	adds	r2, #8
   1af74:	3e10      	subs	r6, #16
   1af76:	2e10      	cmp	r6, #16
   1af78:	dc00      	bgt.n	1af7c <_svfprintf_r+0xd64>
   1af7a:	e0b3      	b.n	1b0e4 <_svfprintf_r+0xecc>
   1af7c:	4650      	mov	r0, sl
   1af7e:	3110      	adds	r1, #16
   1af80:	3301      	adds	r3, #1
   1af82:	6014      	str	r4, [r2, #0]
   1af84:	6050      	str	r0, [r2, #4]
   1af86:	60b9      	str	r1, [r7, #8]
   1af88:	607b      	str	r3, [r7, #4]
   1af8a:	2b07      	cmp	r3, #7
   1af8c:	ddf1      	ble.n	1af72 <_svfprintf_r+0xd5a>
   1af8e:	003a      	movs	r2, r7
   1af90:	9907      	ldr	r1, [sp, #28]
   1af92:	0028      	movs	r0, r5
   1af94:	f001 ff26 	bl	1cde4 <__ssprint_r>
   1af98:	2800      	cmp	r0, #0
   1af9a:	d001      	beq.n	1afa0 <_svfprintf_r+0xd88>
   1af9c:	f7ff f9f3 	bl	1a386 <_svfprintf_r+0x16e>
   1afa0:	68b9      	ldr	r1, [r7, #8]
   1afa2:	687b      	ldr	r3, [r7, #4]
   1afa4:	aa32      	add	r2, sp, #200	; 0xc8
   1afa6:	e7e5      	b.n	1af74 <_svfprintf_r+0xd5c>
   1afa8:	003a      	movs	r2, r7
   1afaa:	9907      	ldr	r1, [sp, #28]
   1afac:	9809      	ldr	r0, [sp, #36]	; 0x24
   1afae:	f001 ff19 	bl	1cde4 <__ssprint_r>
   1afb2:	2800      	cmp	r0, #0
   1afb4:	d001      	beq.n	1afba <_svfprintf_r+0xda2>
   1afb6:	f7ff f9e6 	bl	1a386 <_svfprintf_r+0x16e>
   1afba:	ab16      	add	r3, sp, #88	; 0x58
   1afbc:	7fdb      	ldrb	r3, [r3, #31]
   1afbe:	68bc      	ldr	r4, [r7, #8]
   1afc0:	4698      	mov	r8, r3
   1afc2:	ae32      	add	r6, sp, #200	; 0xc8
   1afc4:	e55c      	b.n	1aa80 <_svfprintf_r+0x868>
   1afc6:	9b14      	ldr	r3, [sp, #80]	; 0x50
   1afc8:	1e5d      	subs	r5, r3, #1
   1afca:	2d00      	cmp	r5, #0
   1afcc:	dc00      	bgt.n	1afd0 <_svfprintf_r+0xdb8>
   1afce:	e65e      	b.n	1ac8e <_svfprintf_r+0xa76>
   1afd0:	4b43      	ldr	r3, [pc, #268]	; (1b0e0 <_svfprintf_r+0xec8>)
   1afd2:	4699      	mov	r9, r3
   1afd4:	2d10      	cmp	r5, #16
   1afd6:	dd29      	ble.n	1b02c <_svfprintf_r+0xe14>
   1afd8:	2310      	movs	r3, #16
   1afda:	0032      	movs	r2, r6
   1afdc:	469a      	mov	sl, r3
   1afde:	002e      	movs	r6, r5
   1afe0:	0021      	movs	r1, r4
   1afe2:	4643      	mov	r3, r8
   1afe4:	9c09      	ldr	r4, [sp, #36]	; 0x24
   1afe6:	464d      	mov	r5, r9
   1afe8:	e003      	b.n	1aff2 <_svfprintf_r+0xdda>
   1afea:	3e10      	subs	r6, #16
   1afec:	3208      	adds	r2, #8
   1afee:	2e10      	cmp	r6, #16
   1aff0:	dd17      	ble.n	1b022 <_svfprintf_r+0xe0a>
   1aff2:	4650      	mov	r0, sl
   1aff4:	3110      	adds	r1, #16
   1aff6:	3301      	adds	r3, #1
   1aff8:	6015      	str	r5, [r2, #0]
   1affa:	6050      	str	r0, [r2, #4]
   1affc:	60b9      	str	r1, [r7, #8]
   1affe:	607b      	str	r3, [r7, #4]
   1b000:	2b07      	cmp	r3, #7
   1b002:	ddf2      	ble.n	1afea <_svfprintf_r+0xdd2>
   1b004:	003a      	movs	r2, r7
   1b006:	9907      	ldr	r1, [sp, #28]
   1b008:	0020      	movs	r0, r4
   1b00a:	f001 feeb 	bl	1cde4 <__ssprint_r>
   1b00e:	2800      	cmp	r0, #0
   1b010:	d001      	beq.n	1b016 <_svfprintf_r+0xdfe>
   1b012:	f7ff f9b8 	bl	1a386 <_svfprintf_r+0x16e>
   1b016:	3e10      	subs	r6, #16
   1b018:	68b9      	ldr	r1, [r7, #8]
   1b01a:	687b      	ldr	r3, [r7, #4]
   1b01c:	aa32      	add	r2, sp, #200	; 0xc8
   1b01e:	2e10      	cmp	r6, #16
   1b020:	dce7      	bgt.n	1aff2 <_svfprintf_r+0xdda>
   1b022:	46a9      	mov	r9, r5
   1b024:	000c      	movs	r4, r1
   1b026:	0035      	movs	r5, r6
   1b028:	4698      	mov	r8, r3
   1b02a:	0016      	movs	r6, r2
   1b02c:	464b      	mov	r3, r9
   1b02e:	6075      	str	r5, [r6, #4]
   1b030:	6033      	str	r3, [r6, #0]
   1b032:	1964      	adds	r4, r4, r5
   1b034:	e621      	b.n	1ac7a <_svfprintf_r+0xa62>
   1b036:	9b08      	ldr	r3, [sp, #32]
   1b038:	06db      	lsls	r3, r3, #27
   1b03a:	d400      	bmi.n	1b03e <_svfprintf_r+0xe26>
   1b03c:	e0eb      	b.n	1b216 <_svfprintf_r+0xffe>
   1b03e:	9a11      	ldr	r2, [sp, #68]	; 0x44
   1b040:	6813      	ldr	r3, [r2, #0]
   1b042:	930a      	str	r3, [sp, #40]	; 0x28
   1b044:	930e      	str	r3, [sp, #56]	; 0x38
   1b046:	3204      	adds	r2, #4
   1b048:	17db      	asrs	r3, r3, #31
   1b04a:	930f      	str	r3, [sp, #60]	; 0x3c
   1b04c:	9211      	str	r2, [sp, #68]	; 0x44
   1b04e:	d401      	bmi.n	1b054 <_svfprintf_r+0xe3c>
   1b050:	f7ff fab9 	bl	1a5c6 <_svfprintf_r+0x3ae>
   1b054:	990e      	ldr	r1, [sp, #56]	; 0x38
   1b056:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
   1b058:	2400      	movs	r4, #0
   1b05a:	424b      	negs	r3, r1
   1b05c:	4194      	sbcs	r4, r2
   1b05e:	930e      	str	r3, [sp, #56]	; 0x38
   1b060:	940f      	str	r4, [sp, #60]	; 0x3c
   1b062:	232d      	movs	r3, #45	; 0x2d
   1b064:	aa16      	add	r2, sp, #88	; 0x58
   1b066:	77d3      	strb	r3, [r2, #31]
   1b068:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   1b06a:	2b00      	cmp	r3, #0
   1b06c:	da00      	bge.n	1b070 <_svfprintf_r+0xe58>
   1b06e:	e3ac      	b.n	1b7ca <_svfprintf_r+0x15b2>
   1b070:	2380      	movs	r3, #128	; 0x80
   1b072:	9a08      	ldr	r2, [sp, #32]
   1b074:	439a      	bics	r2, r3
   1b076:	3b53      	subs	r3, #83	; 0x53
   1b078:	9208      	str	r2, [sp, #32]
   1b07a:	4698      	mov	r8, r3
   1b07c:	f7ff fab6 	bl	1a5ec <_svfprintf_r+0x3d4>
   1b080:	9911      	ldr	r1, [sp, #68]	; 0x44
   1b082:	000a      	movs	r2, r1
   1b084:	6809      	ldr	r1, [r1, #0]
   1b086:	3204      	adds	r2, #4
   1b088:	910e      	str	r1, [sp, #56]	; 0x38
   1b08a:	2100      	movs	r1, #0
   1b08c:	910f      	str	r1, [sp, #60]	; 0x3c
   1b08e:	a916      	add	r1, sp, #88	; 0x58
   1b090:	77cb      	strb	r3, [r1, #31]
   1b092:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   1b094:	2b00      	cmp	r3, #0
   1b096:	db00      	blt.n	1b09a <_svfprintf_r+0xe82>
   1b098:	e22a      	b.n	1b4f0 <_svfprintf_r+0x12d8>
   1b09a:	9211      	str	r2, [sp, #68]	; 0x44
   1b09c:	2300      	movs	r3, #0
   1b09e:	4698      	mov	r8, r3
   1b0a0:	9a0e      	ldr	r2, [sp, #56]	; 0x38
   1b0a2:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   1b0a4:	0011      	movs	r1, r2
   1b0a6:	4319      	orrs	r1, r3
   1b0a8:	d001      	beq.n	1b0ae <_svfprintf_r+0xe96>
   1b0aa:	f7ff fa9f 	bl	1a5ec <_svfprintf_r+0x3d4>
   1b0ae:	e6f4      	b.n	1ae9a <_svfprintf_r+0xc82>
   1b0b0:	46a9      	mov	r9, r5
   1b0b2:	000c      	movs	r4, r1
   1b0b4:	0035      	movs	r5, r6
   1b0b6:	0016      	movs	r6, r2
   1b0b8:	464a      	mov	r2, r9
   1b0ba:	1964      	adds	r4, r4, r5
   1b0bc:	3301      	adds	r3, #1
   1b0be:	6032      	str	r2, [r6, #0]
   1b0c0:	6075      	str	r5, [r6, #4]
   1b0c2:	60bc      	str	r4, [r7, #8]
   1b0c4:	607b      	str	r3, [r7, #4]
   1b0c6:	2b07      	cmp	r3, #7
   1b0c8:	dc00      	bgt.n	1b0cc <_svfprintf_r+0xeb4>
   1b0ca:	e54d      	b.n	1ab68 <_svfprintf_r+0x950>
   1b0cc:	e5ec      	b.n	1aca8 <_svfprintf_r+0xa90>
   1b0ce:	9b11      	ldr	r3, [sp, #68]	; 0x44
   1b0d0:	681a      	ldr	r2, [r3, #0]
   1b0d2:	3304      	adds	r3, #4
   1b0d4:	920e      	str	r2, [sp, #56]	; 0x38
   1b0d6:	2200      	movs	r2, #0
   1b0d8:	9311      	str	r3, [sp, #68]	; 0x44
   1b0da:	920f      	str	r2, [sp, #60]	; 0x3c
   1b0dc:	e42e      	b.n	1a93c <_svfprintf_r+0x724>
   1b0de:	46c0      	nop			; (mov r8, r8)
   1b0e0:	0002302c 	.word	0x0002302c
   1b0e4:	46b0      	mov	r8, r6
   1b0e6:	46a1      	mov	r9, r4
   1b0e8:	0016      	movs	r6, r2
   1b0ea:	000c      	movs	r4, r1
   1b0ec:	464a      	mov	r2, r9
   1b0ee:	6032      	str	r2, [r6, #0]
   1b0f0:	4642      	mov	r2, r8
   1b0f2:	4444      	add	r4, r8
   1b0f4:	3301      	adds	r3, #1
   1b0f6:	6072      	str	r2, [r6, #4]
   1b0f8:	60bc      	str	r4, [r7, #8]
   1b0fa:	607b      	str	r3, [r7, #4]
   1b0fc:	2b07      	cmp	r3, #7
   1b0fe:	dd00      	ble.n	1b102 <_svfprintf_r+0xeea>
   1b100:	e335      	b.n	1b76e <_svfprintf_r+0x1556>
   1b102:	3608      	adds	r6, #8
   1b104:	9a12      	ldr	r2, [sp, #72]	; 0x48
   1b106:	9b15      	ldr	r3, [sp, #84]	; 0x54
   1b108:	4694      	mov	ip, r2
   1b10a:	4463      	add	r3, ip
   1b10c:	4698      	mov	r8, r3
   1b10e:	9a14      	ldr	r2, [sp, #80]	; 0x50
   1b110:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   1b112:	4293      	cmp	r3, r2
   1b114:	db49      	blt.n	1b1aa <_svfprintf_r+0xf92>
   1b116:	9a08      	ldr	r2, [sp, #32]
   1b118:	07d2      	lsls	r2, r2, #31
   1b11a:	d446      	bmi.n	1b1aa <_svfprintf_r+0xf92>
   1b11c:	9a12      	ldr	r2, [sp, #72]	; 0x48
   1b11e:	9914      	ldr	r1, [sp, #80]	; 0x50
   1b120:	0015      	movs	r5, r2
   1b122:	468c      	mov	ip, r1
   1b124:	4642      	mov	r2, r8
   1b126:	4465      	add	r5, ip
   1b128:	1acb      	subs	r3, r1, r3
   1b12a:	1aad      	subs	r5, r5, r2
   1b12c:	429d      	cmp	r5, r3
   1b12e:	dd00      	ble.n	1b132 <_svfprintf_r+0xf1a>
   1b130:	001d      	movs	r5, r3
   1b132:	2d00      	cmp	r5, #0
   1b134:	dd0b      	ble.n	1b14e <_svfprintf_r+0xf36>
   1b136:	4642      	mov	r2, r8
   1b138:	6032      	str	r2, [r6, #0]
   1b13a:	687a      	ldr	r2, [r7, #4]
   1b13c:	1964      	adds	r4, r4, r5
   1b13e:	3201      	adds	r2, #1
   1b140:	6075      	str	r5, [r6, #4]
   1b142:	60bc      	str	r4, [r7, #8]
   1b144:	607a      	str	r2, [r7, #4]
   1b146:	2a07      	cmp	r2, #7
   1b148:	dd00      	ble.n	1b14c <_svfprintf_r+0xf34>
   1b14a:	e32f      	b.n	1b7ac <_svfprintf_r+0x1594>
   1b14c:	3608      	adds	r6, #8
   1b14e:	43ea      	mvns	r2, r5
   1b150:	17d2      	asrs	r2, r2, #31
   1b152:	4015      	ands	r5, r2
   1b154:	1b5d      	subs	r5, r3, r5
   1b156:	2d00      	cmp	r5, #0
   1b158:	dc00      	bgt.n	1b15c <_svfprintf_r+0xf44>
   1b15a:	e506      	b.n	1ab6a <_svfprintf_r+0x952>
   1b15c:	4ad3      	ldr	r2, [pc, #844]	; (1b4ac <_svfprintf_r+0x1294>)
   1b15e:	687b      	ldr	r3, [r7, #4]
   1b160:	4691      	mov	r9, r2
   1b162:	2d10      	cmp	r5, #16
   1b164:	dda8      	ble.n	1b0b8 <_svfprintf_r+0xea0>
   1b166:	2210      	movs	r2, #16
   1b168:	0021      	movs	r1, r4
   1b16a:	4690      	mov	r8, r2
   1b16c:	9c09      	ldr	r4, [sp, #36]	; 0x24
   1b16e:	0032      	movs	r2, r6
   1b170:	002e      	movs	r6, r5
   1b172:	464d      	mov	r5, r9
   1b174:	e003      	b.n	1b17e <_svfprintf_r+0xf66>
   1b176:	3208      	adds	r2, #8
   1b178:	3e10      	subs	r6, #16
   1b17a:	2e10      	cmp	r6, #16
   1b17c:	dd98      	ble.n	1b0b0 <_svfprintf_r+0xe98>
   1b17e:	4640      	mov	r0, r8
   1b180:	3110      	adds	r1, #16
   1b182:	3301      	adds	r3, #1
   1b184:	6015      	str	r5, [r2, #0]
   1b186:	6050      	str	r0, [r2, #4]
   1b188:	60b9      	str	r1, [r7, #8]
   1b18a:	607b      	str	r3, [r7, #4]
   1b18c:	2b07      	cmp	r3, #7
   1b18e:	ddf2      	ble.n	1b176 <_svfprintf_r+0xf5e>
   1b190:	003a      	movs	r2, r7
   1b192:	9907      	ldr	r1, [sp, #28]
   1b194:	0020      	movs	r0, r4
   1b196:	f001 fe25 	bl	1cde4 <__ssprint_r>
   1b19a:	2800      	cmp	r0, #0
   1b19c:	d001      	beq.n	1b1a2 <_svfprintf_r+0xf8a>
   1b19e:	f7ff f8f2 	bl	1a386 <_svfprintf_r+0x16e>
   1b1a2:	68b9      	ldr	r1, [r7, #8]
   1b1a4:	687b      	ldr	r3, [r7, #4]
   1b1a6:	aa32      	add	r2, sp, #200	; 0xc8
   1b1a8:	e7e6      	b.n	1b178 <_svfprintf_r+0xf60>
   1b1aa:	9a19      	ldr	r2, [sp, #100]	; 0x64
   1b1ac:	6032      	str	r2, [r6, #0]
   1b1ae:	9a18      	ldr	r2, [sp, #96]	; 0x60
   1b1b0:	4694      	mov	ip, r2
   1b1b2:	6072      	str	r2, [r6, #4]
   1b1b4:	687a      	ldr	r2, [r7, #4]
   1b1b6:	4464      	add	r4, ip
   1b1b8:	3201      	adds	r2, #1
   1b1ba:	60bc      	str	r4, [r7, #8]
   1b1bc:	607a      	str	r2, [r7, #4]
   1b1be:	2a07      	cmp	r2, #7
   1b1c0:	dd00      	ble.n	1b1c4 <_svfprintf_r+0xfac>
   1b1c2:	e2c7      	b.n	1b754 <_svfprintf_r+0x153c>
   1b1c4:	3608      	adds	r6, #8
   1b1c6:	e7a9      	b.n	1b11c <_svfprintf_r+0xf04>
   1b1c8:	003a      	movs	r2, r7
   1b1ca:	9907      	ldr	r1, [sp, #28]
   1b1cc:	9809      	ldr	r0, [sp, #36]	; 0x24
   1b1ce:	f001 fe09 	bl	1cde4 <__ssprint_r>
   1b1d2:	2800      	cmp	r0, #0
   1b1d4:	d001      	beq.n	1b1da <_svfprintf_r+0xfc2>
   1b1d6:	f7ff f8d6 	bl	1a386 <_svfprintf_r+0x16e>
   1b1da:	68bc      	ldr	r4, [r7, #8]
   1b1dc:	687b      	ldr	r3, [r7, #4]
   1b1de:	ae32      	add	r6, sp, #200	; 0xc8
   1b1e0:	e52d      	b.n	1ac3e <_svfprintf_r+0xa26>
   1b1e2:	003a      	movs	r2, r7
   1b1e4:	9907      	ldr	r1, [sp, #28]
   1b1e6:	9809      	ldr	r0, [sp, #36]	; 0x24
   1b1e8:	f001 fdfc 	bl	1cde4 <__ssprint_r>
   1b1ec:	2800      	cmp	r0, #0
   1b1ee:	d001      	beq.n	1b1f4 <_svfprintf_r+0xfdc>
   1b1f0:	f7ff f8c9 	bl	1a386 <_svfprintf_r+0x16e>
   1b1f4:	687b      	ldr	r3, [r7, #4]
   1b1f6:	68bc      	ldr	r4, [r7, #8]
   1b1f8:	4698      	mov	r8, r3
   1b1fa:	ae32      	add	r6, sp, #200	; 0xc8
   1b1fc:	e52d      	b.n	1ac5a <_svfprintf_r+0xa42>
   1b1fe:	003a      	movs	r2, r7
   1b200:	9907      	ldr	r1, [sp, #28]
   1b202:	9809      	ldr	r0, [sp, #36]	; 0x24
   1b204:	f001 fdee 	bl	1cde4 <__ssprint_r>
   1b208:	2800      	cmp	r0, #0
   1b20a:	d001      	beq.n	1b210 <_svfprintf_r+0xff8>
   1b20c:	f7ff f8bb 	bl	1a386 <_svfprintf_r+0x16e>
   1b210:	68bc      	ldr	r4, [r7, #8]
   1b212:	ae32      	add	r6, sp, #200	; 0xc8
   1b214:	e45b      	b.n	1aace <_svfprintf_r+0x8b6>
   1b216:	9b08      	ldr	r3, [sp, #32]
   1b218:	9a11      	ldr	r2, [sp, #68]	; 0x44
   1b21a:	065b      	lsls	r3, r3, #25
   1b21c:	d400      	bmi.n	1b220 <_svfprintf_r+0x1008>
   1b21e:	e70f      	b.n	1b040 <_svfprintf_r+0xe28>
   1b220:	2100      	movs	r1, #0
   1b222:	5e53      	ldrsh	r3, [r2, r1]
   1b224:	e70e      	b.n	1b044 <_svfprintf_r+0xe2c>
   1b226:	9d16      	ldr	r5, [sp, #88]	; 0x58
   1b228:	9c17      	ldr	r4, [sp, #92]	; 0x5c
   1b22a:	002a      	movs	r2, r5
   1b22c:	0023      	movs	r3, r4
   1b22e:	0028      	movs	r0, r5
   1b230:	0021      	movs	r1, r4
   1b232:	f004 fc55 	bl	1fae0 <__aeabi_dcmpun>
   1b236:	2800      	cmp	r0, #0
   1b238:	d000      	beq.n	1b23c <_svfprintf_r+0x1024>
   1b23a:	e36e      	b.n	1b91a <_svfprintf_r+0x1702>
   1b23c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   1b23e:	3301      	adds	r3, #1
   1b240:	d100      	bne.n	1b244 <_svfprintf_r+0x102c>
   1b242:	e2e8      	b.n	1b816 <_svfprintf_r+0x15fe>
   1b244:	2320      	movs	r3, #32
   1b246:	9d13      	ldr	r5, [sp, #76]	; 0x4c
   1b248:	439d      	bics	r5, r3
   1b24a:	2d47      	cmp	r5, #71	; 0x47
   1b24c:	d100      	bne.n	1b250 <_svfprintf_r+0x1038>
   1b24e:	e1a6      	b.n	1b59e <_svfprintf_r+0x1386>
   1b250:	2380      	movs	r3, #128	; 0x80
   1b252:	9a08      	ldr	r2, [sp, #32]
   1b254:	005b      	lsls	r3, r3, #1
   1b256:	431a      	orrs	r2, r3
   1b258:	9b17      	ldr	r3, [sp, #92]	; 0x5c
   1b25a:	921b      	str	r2, [sp, #108]	; 0x6c
   1b25c:	2b00      	cmp	r3, #0
   1b25e:	da00      	bge.n	1b262 <_svfprintf_r+0x104a>
   1b260:	e2ef      	b.n	1b842 <_svfprintf_r+0x162a>
   1b262:	9a16      	ldr	r2, [sp, #88]	; 0x58
   1b264:	4698      	mov	r8, r3
   1b266:	2300      	movs	r3, #0
   1b268:	4691      	mov	r9, r2
   1b26a:	930a      	str	r3, [sp, #40]	; 0x28
   1b26c:	9c13      	ldr	r4, [sp, #76]	; 0x4c
   1b26e:	2c66      	cmp	r4, #102	; 0x66
   1b270:	d100      	bne.n	1b274 <_svfprintf_r+0x105c>
   1b272:	e2ae      	b.n	1b7d2 <_svfprintf_r+0x15ba>
   1b274:	2c46      	cmp	r4, #70	; 0x46
   1b276:	d100      	bne.n	1b27a <_svfprintf_r+0x1062>
   1b278:	e172      	b.n	1b560 <_svfprintf_r+0x1348>
   1b27a:	002b      	movs	r3, r5
   1b27c:	3b45      	subs	r3, #69	; 0x45
   1b27e:	4259      	negs	r1, r3
   1b280:	4159      	adcs	r1, r3
   1b282:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   1b284:	464a      	mov	r2, r9
   1b286:	469a      	mov	sl, r3
   1b288:	ab23      	add	r3, sp, #140	; 0x8c
   1b28a:	9304      	str	r3, [sp, #16]
   1b28c:	ab20      	add	r3, sp, #128	; 0x80
   1b28e:	448a      	add	sl, r1
   1b290:	9303      	str	r3, [sp, #12]
   1b292:	ab1f      	add	r3, sp, #124	; 0x7c
   1b294:	9302      	str	r3, [sp, #8]
   1b296:	4653      	mov	r3, sl
   1b298:	9301      	str	r3, [sp, #4]
   1b29a:	2302      	movs	r3, #2
   1b29c:	9809      	ldr	r0, [sp, #36]	; 0x24
   1b29e:	9300      	str	r3, [sp, #0]
   1b2a0:	4643      	mov	r3, r8
   1b2a2:	f7fc fa9f 	bl	177e4 <_dtoa_r>
   1b2a6:	9012      	str	r0, [sp, #72]	; 0x48
   1b2a8:	2c67      	cmp	r4, #103	; 0x67
   1b2aa:	d000      	beq.n	1b2ae <_svfprintf_r+0x1096>
   1b2ac:	e2f0      	b.n	1b890 <_svfprintf_r+0x1678>
   1b2ae:	9b12      	ldr	r3, [sp, #72]	; 0x48
   1b2b0:	4453      	add	r3, sl
   1b2b2:	001c      	movs	r4, r3
   1b2b4:	9b08      	ldr	r3, [sp, #32]
   1b2b6:	07db      	lsls	r3, r3, #31
   1b2b8:	d400      	bmi.n	1b2bc <_svfprintf_r+0x10a4>
   1b2ba:	e326      	b.n	1b90a <_svfprintf_r+0x16f2>
   1b2bc:	2300      	movs	r3, #0
   1b2be:	2200      	movs	r2, #0
   1b2c0:	4648      	mov	r0, r9
   1b2c2:	4641      	mov	r1, r8
   1b2c4:	f002 fd76 	bl	1ddb4 <__aeabi_dcmpeq>
   1b2c8:	0023      	movs	r3, r4
   1b2ca:	2800      	cmp	r0, #0
   1b2cc:	d109      	bne.n	1b2e2 <_svfprintf_r+0x10ca>
   1b2ce:	9b23      	ldr	r3, [sp, #140]	; 0x8c
   1b2d0:	429c      	cmp	r4, r3
   1b2d2:	d906      	bls.n	1b2e2 <_svfprintf_r+0x10ca>
   1b2d4:	2130      	movs	r1, #48	; 0x30
   1b2d6:	1c5a      	adds	r2, r3, #1
   1b2d8:	9223      	str	r2, [sp, #140]	; 0x8c
   1b2da:	7019      	strb	r1, [r3, #0]
   1b2dc:	9b23      	ldr	r3, [sp, #140]	; 0x8c
   1b2de:	429c      	cmp	r4, r3
   1b2e0:	d8f9      	bhi.n	1b2d6 <_svfprintf_r+0x10be>
   1b2e2:	9a12      	ldr	r2, [sp, #72]	; 0x48
   1b2e4:	1a9b      	subs	r3, r3, r2
   1b2e6:	9314      	str	r3, [sp, #80]	; 0x50
   1b2e8:	2d47      	cmp	r5, #71	; 0x47
   1b2ea:	d100      	bne.n	1b2ee <_svfprintf_r+0x10d6>
   1b2ec:	e1a8      	b.n	1b640 <_svfprintf_r+0x1428>
   1b2ee:	9b13      	ldr	r3, [sp, #76]	; 0x4c
   1b2f0:	2b65      	cmp	r3, #101	; 0x65
   1b2f2:	dc00      	bgt.n	1b2f6 <_svfprintf_r+0x10de>
   1b2f4:	e2de      	b.n	1b8b4 <_svfprintf_r+0x169c>
   1b2f6:	9b13      	ldr	r3, [sp, #76]	; 0x4c
   1b2f8:	2b66      	cmp	r3, #102	; 0x66
   1b2fa:	d100      	bne.n	1b2fe <_svfprintf_r+0x10e6>
   1b2fc:	e2e0      	b.n	1b8c0 <_svfprintf_r+0x16a8>
   1b2fe:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   1b300:	9315      	str	r3, [sp, #84]	; 0x54
   1b302:	9a15      	ldr	r2, [sp, #84]	; 0x54
   1b304:	9914      	ldr	r1, [sp, #80]	; 0x50
   1b306:	428a      	cmp	r2, r1
   1b308:	da00      	bge.n	1b30c <_svfprintf_r+0x10f4>
   1b30a:	e28a      	b.n	1b822 <_svfprintf_r+0x160a>
   1b30c:	9b08      	ldr	r3, [sp, #32]
   1b30e:	07db      	lsls	r3, r3, #31
   1b310:	d500      	bpl.n	1b314 <_svfprintf_r+0x10fc>
   1b312:	e2f3      	b.n	1b8fc <_svfprintf_r+0x16e4>
   1b314:	43d3      	mvns	r3, r2
   1b316:	17db      	asrs	r3, r3, #31
   1b318:	4013      	ands	r3, r2
   1b31a:	9210      	str	r2, [sp, #64]	; 0x40
   1b31c:	2267      	movs	r2, #103	; 0x67
   1b31e:	9213      	str	r2, [sp, #76]	; 0x4c
   1b320:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   1b322:	2a00      	cmp	r2, #0
   1b324:	d000      	beq.n	1b328 <_svfprintf_r+0x1110>
   1b326:	e17f      	b.n	1b628 <_svfprintf_r+0x1410>
   1b328:	930a      	str	r3, [sp, #40]	; 0x28
   1b32a:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
   1b32c:	aa16      	add	r2, sp, #88	; 0x58
   1b32e:	9308      	str	r3, [sp, #32]
   1b330:	2300      	movs	r3, #0
   1b332:	7fd2      	ldrb	r2, [r2, #31]
   1b334:	930b      	str	r3, [sp, #44]	; 0x2c
   1b336:	4690      	mov	r8, r2
   1b338:	f7ff f890 	bl	1a45c <_svfprintf_r+0x244>
   1b33c:	9911      	ldr	r1, [sp, #68]	; 0x44
   1b33e:	000a      	movs	r2, r1
   1b340:	6809      	ldr	r1, [r1, #0]
   1b342:	3204      	adds	r2, #4
   1b344:	910e      	str	r1, [sp, #56]	; 0x38
   1b346:	2100      	movs	r1, #0
   1b348:	910f      	str	r1, [sp, #60]	; 0x3c
   1b34a:	a916      	add	r1, sp, #88	; 0x58
   1b34c:	77cb      	strb	r3, [r1, #31]
   1b34e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   1b350:	2b00      	cmp	r3, #0
   1b352:	db00      	blt.n	1b356 <_svfprintf_r+0x113e>
   1b354:	e0c8      	b.n	1b4e8 <_svfprintf_r+0x12d0>
   1b356:	9211      	str	r2, [sp, #68]	; 0x44
   1b358:	2300      	movs	r3, #0
   1b35a:	4698      	mov	r8, r3
   1b35c:	9a0e      	ldr	r2, [sp, #56]	; 0x38
   1b35e:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   1b360:	0011      	movs	r1, r2
   1b362:	4319      	orrs	r1, r3
   1b364:	d001      	beq.n	1b36a <_svfprintf_r+0x1152>
   1b366:	f7ff f847 	bl	1a3f8 <_svfprintf_r+0x1e0>
   1b36a:	f7ff f9f1 	bl	1a750 <_svfprintf_r+0x538>
   1b36e:	2340      	movs	r3, #64	; 0x40
   1b370:	9908      	ldr	r1, [sp, #32]
   1b372:	400b      	ands	r3, r1
   1b374:	d0e2      	beq.n	1b33c <_svfprintf_r+0x1124>
   1b376:	9811      	ldr	r0, [sp, #68]	; 0x44
   1b378:	0003      	movs	r3, r0
   1b37a:	8800      	ldrh	r0, [r0, #0]
   1b37c:	3304      	adds	r3, #4
   1b37e:	900e      	str	r0, [sp, #56]	; 0x38
   1b380:	2000      	movs	r0, #0
   1b382:	900f      	str	r0, [sp, #60]	; 0x3c
   1b384:	a816      	add	r0, sp, #88	; 0x58
   1b386:	77c2      	strb	r2, [r0, #31]
   1b388:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
   1b38a:	2a00      	cmp	r2, #0
   1b38c:	da00      	bge.n	1b390 <_svfprintf_r+0x1178>
   1b38e:	e111      	b.n	1b5b4 <_svfprintf_r+0x139c>
   1b390:	2280      	movs	r2, #128	; 0x80
   1b392:	4391      	bics	r1, r2
   1b394:	9a0e      	ldr	r2, [sp, #56]	; 0x38
   1b396:	9108      	str	r1, [sp, #32]
   1b398:	9311      	str	r3, [sp, #68]	; 0x44
   1b39a:	2a00      	cmp	r2, #0
   1b39c:	d001      	beq.n	1b3a2 <_svfprintf_r+0x118a>
   1b39e:	f7ff f829 	bl	1a3f4 <_svfprintf_r+0x1dc>
   1b3a2:	f7ff f9ce 	bl	1a742 <_svfprintf_r+0x52a>
   1b3a6:	2340      	movs	r3, #64	; 0x40
   1b3a8:	9908      	ldr	r1, [sp, #32]
   1b3aa:	400b      	ands	r3, r1
   1b3ac:	d100      	bne.n	1b3b0 <_svfprintf_r+0x1198>
   1b3ae:	e667      	b.n	1b080 <_svfprintf_r+0xe68>
   1b3b0:	9811      	ldr	r0, [sp, #68]	; 0x44
   1b3b2:	0003      	movs	r3, r0
   1b3b4:	8800      	ldrh	r0, [r0, #0]
   1b3b6:	3304      	adds	r3, #4
   1b3b8:	900e      	str	r0, [sp, #56]	; 0x38
   1b3ba:	2000      	movs	r0, #0
   1b3bc:	900f      	str	r0, [sp, #60]	; 0x3c
   1b3be:	a816      	add	r0, sp, #88	; 0x58
   1b3c0:	77c2      	strb	r2, [r0, #31]
   1b3c2:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
   1b3c4:	2a00      	cmp	r2, #0
   1b3c6:	da00      	bge.n	1b3ca <_svfprintf_r+0x11b2>
   1b3c8:	e0f0      	b.n	1b5ac <_svfprintf_r+0x1394>
   1b3ca:	2280      	movs	r2, #128	; 0x80
   1b3cc:	9311      	str	r3, [sp, #68]	; 0x44
   1b3ce:	2300      	movs	r3, #0
   1b3d0:	4391      	bics	r1, r2
   1b3d2:	9a0e      	ldr	r2, [sp, #56]	; 0x38
   1b3d4:	9108      	str	r1, [sp, #32]
   1b3d6:	4698      	mov	r8, r3
   1b3d8:	2a00      	cmp	r2, #0
   1b3da:	d001      	beq.n	1b3e0 <_svfprintf_r+0x11c8>
   1b3dc:	f7ff f906 	bl	1a5ec <_svfprintf_r+0x3d4>
   1b3e0:	e557      	b.n	1ae92 <_svfprintf_r+0xc7a>
   1b3e2:	9b08      	ldr	r3, [sp, #32]
   1b3e4:	06db      	lsls	r3, r3, #27
   1b3e6:	d40c      	bmi.n	1b402 <_svfprintf_r+0x11ea>
   1b3e8:	9b08      	ldr	r3, [sp, #32]
   1b3ea:	065b      	lsls	r3, r3, #25
   1b3ec:	d509      	bpl.n	1b402 <_svfprintf_r+0x11ea>
   1b3ee:	4669      	mov	r1, sp
   1b3f0:	9b11      	ldr	r3, [sp, #68]	; 0x44
   1b3f2:	8e09      	ldrh	r1, [r1, #48]	; 0x30
   1b3f4:	681a      	ldr	r2, [r3, #0]
   1b3f6:	3304      	adds	r3, #4
   1b3f8:	9208      	str	r2, [sp, #32]
   1b3fa:	8011      	strh	r1, [r2, #0]
   1b3fc:	9311      	str	r3, [sp, #68]	; 0x44
   1b3fe:	f7fe ff33 	bl	1a268 <_svfprintf_r+0x50>
   1b402:	9a11      	ldr	r2, [sp, #68]	; 0x44
   1b404:	990c      	ldr	r1, [sp, #48]	; 0x30
   1b406:	6813      	ldr	r3, [r2, #0]
   1b408:	6019      	str	r1, [r3, #0]
   1b40a:	0013      	movs	r3, r2
   1b40c:	3304      	adds	r3, #4
   1b40e:	9311      	str	r3, [sp, #68]	; 0x44
   1b410:	f7fe ff2a 	bl	1a268 <_svfprintf_r+0x50>
   1b414:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   1b416:	aa16      	add	r2, sp, #88	; 0x58
   1b418:	77d0      	strb	r0, [r2, #31]
   1b41a:	2b00      	cmp	r3, #0
   1b41c:	da01      	bge.n	1b422 <_svfprintf_r+0x120a>
   1b41e:	f7fe ff9a 	bl	1a356 <_svfprintf_r+0x13e>
   1b422:	2380      	movs	r3, #128	; 0x80
   1b424:	9a08      	ldr	r2, [sp, #32]
   1b426:	439a      	bics	r2, r3
   1b428:	9208      	str	r2, [sp, #32]
   1b42a:	f7fe ff8f 	bl	1a34c <_svfprintf_r+0x134>
   1b42e:	003a      	movs	r2, r7
   1b430:	9907      	ldr	r1, [sp, #28]
   1b432:	9809      	ldr	r0, [sp, #36]	; 0x24
   1b434:	f001 fcd6 	bl	1cde4 <__ssprint_r>
   1b438:	2800      	cmp	r0, #0
   1b43a:	d001      	beq.n	1b440 <_svfprintf_r+0x1228>
   1b43c:	f7fe ffa3 	bl	1a386 <_svfprintf_r+0x16e>
   1b440:	68bc      	ldr	r4, [r7, #8]
   1b442:	ae32      	add	r6, sp, #200	; 0xc8
   1b444:	e455      	b.n	1acf2 <_svfprintf_r+0xada>
   1b446:	9811      	ldr	r0, [sp, #68]	; 0x44
   1b448:	f7ff fb0e 	bl	1aa68 <_svfprintf_r+0x850>
   1b44c:	4b18      	ldr	r3, [pc, #96]	; (1b4b0 <_svfprintf_r+0x1298>)
   1b44e:	3401      	adds	r4, #1
   1b450:	6033      	str	r3, [r6, #0]
   1b452:	2301      	movs	r3, #1
   1b454:	6073      	str	r3, [r6, #4]
   1b456:	687b      	ldr	r3, [r7, #4]
   1b458:	60bc      	str	r4, [r7, #8]
   1b45a:	3301      	adds	r3, #1
   1b45c:	607b      	str	r3, [r7, #4]
   1b45e:	2b07      	cmp	r3, #7
   1b460:	dc71      	bgt.n	1b546 <_svfprintf_r+0x132e>
   1b462:	3608      	adds	r6, #8
   1b464:	2800      	cmp	r0, #0
   1b466:	d107      	bne.n	1b478 <_svfprintf_r+0x1260>
   1b468:	9b14      	ldr	r3, [sp, #80]	; 0x50
   1b46a:	2b00      	cmp	r3, #0
   1b46c:	d104      	bne.n	1b478 <_svfprintf_r+0x1260>
   1b46e:	9b08      	ldr	r3, [sp, #32]
   1b470:	07db      	lsls	r3, r3, #31
   1b472:	d401      	bmi.n	1b478 <_svfprintf_r+0x1260>
   1b474:	f7ff fb79 	bl	1ab6a <_svfprintf_r+0x952>
   1b478:	9b19      	ldr	r3, [sp, #100]	; 0x64
   1b47a:	6033      	str	r3, [r6, #0]
   1b47c:	9b18      	ldr	r3, [sp, #96]	; 0x60
   1b47e:	1919      	adds	r1, r3, r4
   1b480:	6073      	str	r3, [r6, #4]
   1b482:	687b      	ldr	r3, [r7, #4]
   1b484:	60b9      	str	r1, [r7, #8]
   1b486:	3301      	adds	r3, #1
   1b488:	607b      	str	r3, [r7, #4]
   1b48a:	2b07      	cmp	r3, #7
   1b48c:	dd00      	ble.n	1b490 <_svfprintf_r+0x1278>
   1b48e:	e227      	b.n	1b8e0 <_svfprintf_r+0x16c8>
   1b490:	0032      	movs	r2, r6
   1b492:	3208      	adds	r2, #8
   1b494:	4244      	negs	r4, r0
   1b496:	2c00      	cmp	r4, #0
   1b498:	dc00      	bgt.n	1b49c <_svfprintf_r+0x1284>
   1b49a:	e0b5      	b.n	1b608 <_svfprintf_r+0x13f0>
   1b49c:	4803      	ldr	r0, [pc, #12]	; (1b4ac <_svfprintf_r+0x1294>)
   1b49e:	4681      	mov	r9, r0
   1b4a0:	2c10      	cmp	r4, #16
   1b4a2:	dc00      	bgt.n	1b4a6 <_svfprintf_r+0x128e>
   1b4a4:	e14a      	b.n	1b73c <_svfprintf_r+0x1524>
   1b4a6:	2610      	movs	r6, #16
   1b4a8:	0005      	movs	r5, r0
   1b4aa:	e008      	b.n	1b4be <_svfprintf_r+0x12a6>
   1b4ac:	0002302c 	.word	0x0002302c
   1b4b0:	00022d78 	.word	0x00022d78
   1b4b4:	3208      	adds	r2, #8
   1b4b6:	3c10      	subs	r4, #16
   1b4b8:	2c10      	cmp	r4, #16
   1b4ba:	dc00      	bgt.n	1b4be <_svfprintf_r+0x12a6>
   1b4bc:	e13d      	b.n	1b73a <_svfprintf_r+0x1522>
   1b4be:	3110      	adds	r1, #16
   1b4c0:	3301      	adds	r3, #1
   1b4c2:	6015      	str	r5, [r2, #0]
   1b4c4:	6056      	str	r6, [r2, #4]
   1b4c6:	60b9      	str	r1, [r7, #8]
   1b4c8:	607b      	str	r3, [r7, #4]
   1b4ca:	2b07      	cmp	r3, #7
   1b4cc:	ddf2      	ble.n	1b4b4 <_svfprintf_r+0x129c>
   1b4ce:	003a      	movs	r2, r7
   1b4d0:	9907      	ldr	r1, [sp, #28]
   1b4d2:	9809      	ldr	r0, [sp, #36]	; 0x24
   1b4d4:	f001 fc86 	bl	1cde4 <__ssprint_r>
   1b4d8:	2800      	cmp	r0, #0
   1b4da:	d001      	beq.n	1b4e0 <_svfprintf_r+0x12c8>
   1b4dc:	f7fe ff53 	bl	1a386 <_svfprintf_r+0x16e>
   1b4e0:	68b9      	ldr	r1, [r7, #8]
   1b4e2:	687b      	ldr	r3, [r7, #4]
   1b4e4:	aa32      	add	r2, sp, #200	; 0xc8
   1b4e6:	e7e6      	b.n	1b4b6 <_svfprintf_r+0x129e>
   1b4e8:	2380      	movs	r3, #128	; 0x80
   1b4ea:	9908      	ldr	r1, [sp, #32]
   1b4ec:	f7ff f922 	bl	1a734 <_svfprintf_r+0x51c>
   1b4f0:	2380      	movs	r3, #128	; 0x80
   1b4f2:	9908      	ldr	r1, [sp, #32]
   1b4f4:	e4c5      	b.n	1ae82 <_svfprintf_r+0xc6a>
   1b4f6:	2020      	movs	r0, #32
   1b4f8:	9b08      	ldr	r3, [sp, #32]
   1b4fa:	3501      	adds	r5, #1
   1b4fc:	4303      	orrs	r3, r0
   1b4fe:	9308      	str	r3, [sp, #32]
   1b500:	782b      	ldrb	r3, [r5, #0]
   1b502:	f7fe feeb 	bl	1a2dc <_svfprintf_r+0xc4>
   1b506:	003a      	movs	r2, r7
   1b508:	9907      	ldr	r1, [sp, #28]
   1b50a:	9809      	ldr	r0, [sp, #36]	; 0x24
   1b50c:	f001 fc6a 	bl	1cde4 <__ssprint_r>
   1b510:	2800      	cmp	r0, #0
   1b512:	d001      	beq.n	1b518 <_svfprintf_r+0x1300>
   1b514:	f7fe ff37 	bl	1a386 <_svfprintf_r+0x16e>
   1b518:	68bc      	ldr	r4, [r7, #8]
   1b51a:	ae32      	add	r6, sp, #200	; 0xc8
   1b51c:	f7ff fc00 	bl	1ad20 <_svfprintf_r+0xb08>
   1b520:	4be5      	ldr	r3, [pc, #916]	; (1b8b8 <_svfprintf_r+0x16a0>)
   1b522:	9312      	str	r3, [sp, #72]	; 0x48
   1b524:	f7ff f8d1 	bl	1a6ca <_svfprintf_r+0x4b2>
   1b528:	2140      	movs	r1, #64	; 0x40
   1b52a:	9809      	ldr	r0, [sp, #36]	; 0x24
   1b52c:	f7f9 ff7e 	bl	1542c <_malloc_r>
   1b530:	9b07      	ldr	r3, [sp, #28]
   1b532:	6018      	str	r0, [r3, #0]
   1b534:	6118      	str	r0, [r3, #16]
   1b536:	2800      	cmp	r0, #0
   1b538:	d100      	bne.n	1b53c <_svfprintf_r+0x1324>
   1b53a:	e25e      	b.n	1b9fa <_svfprintf_r+0x17e2>
   1b53c:	2340      	movs	r3, #64	; 0x40
   1b53e:	9a07      	ldr	r2, [sp, #28]
   1b540:	6153      	str	r3, [r2, #20]
   1b542:	f7fe fe85 	bl	1a250 <_svfprintf_r+0x38>
   1b546:	003a      	movs	r2, r7
   1b548:	9907      	ldr	r1, [sp, #28]
   1b54a:	9809      	ldr	r0, [sp, #36]	; 0x24
   1b54c:	f001 fc4a 	bl	1cde4 <__ssprint_r>
   1b550:	2800      	cmp	r0, #0
   1b552:	d001      	beq.n	1b558 <_svfprintf_r+0x1340>
   1b554:	f7fe ff17 	bl	1a386 <_svfprintf_r+0x16e>
   1b558:	981f      	ldr	r0, [sp, #124]	; 0x7c
   1b55a:	68bc      	ldr	r4, [r7, #8]
   1b55c:	ae32      	add	r6, sp, #200	; 0xc8
   1b55e:	e781      	b.n	1b464 <_svfprintf_r+0x124c>
   1b560:	ab23      	add	r3, sp, #140	; 0x8c
   1b562:	9304      	str	r3, [sp, #16]
   1b564:	ab20      	add	r3, sp, #128	; 0x80
   1b566:	9303      	str	r3, [sp, #12]
   1b568:	ab1f      	add	r3, sp, #124	; 0x7c
   1b56a:	9302      	str	r3, [sp, #8]
   1b56c:	2303      	movs	r3, #3
   1b56e:	9c0b      	ldr	r4, [sp, #44]	; 0x2c
   1b570:	9300      	str	r3, [sp, #0]
   1b572:	9401      	str	r4, [sp, #4]
   1b574:	464a      	mov	r2, r9
   1b576:	4643      	mov	r3, r8
   1b578:	9809      	ldr	r0, [sp, #36]	; 0x24
   1b57a:	f7fc f933 	bl	177e4 <_dtoa_r>
   1b57e:	46a2      	mov	sl, r4
   1b580:	9012      	str	r0, [sp, #72]	; 0x48
   1b582:	9b12      	ldr	r3, [sp, #72]	; 0x48
   1b584:	4453      	add	r3, sl
   1b586:	001c      	movs	r4, r3
   1b588:	9b13      	ldr	r3, [sp, #76]	; 0x4c
   1b58a:	2b46      	cmp	r3, #70	; 0x46
   1b58c:	d000      	beq.n	1b590 <_svfprintf_r+0x1378>
   1b58e:	e695      	b.n	1b2bc <_svfprintf_r+0x10a4>
   1b590:	9b12      	ldr	r3, [sp, #72]	; 0x48
   1b592:	781b      	ldrb	r3, [r3, #0]
   1b594:	2b30      	cmp	r3, #48	; 0x30
   1b596:	d00f      	beq.n	1b5b8 <_svfprintf_r+0x13a0>
   1b598:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   1b59a:	18e4      	adds	r4, r4, r3
   1b59c:	e68e      	b.n	1b2bc <_svfprintf_r+0x10a4>
   1b59e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   1b5a0:	2b00      	cmp	r3, #0
   1b5a2:	d000      	beq.n	1b5a6 <_svfprintf_r+0x138e>
   1b5a4:	e654      	b.n	1b250 <_svfprintf_r+0x1038>
   1b5a6:	3301      	adds	r3, #1
   1b5a8:	930b      	str	r3, [sp, #44]	; 0x2c
   1b5aa:	e651      	b.n	1b250 <_svfprintf_r+0x1038>
   1b5ac:	9311      	str	r3, [sp, #68]	; 0x44
   1b5ae:	2300      	movs	r3, #0
   1b5b0:	4698      	mov	r8, r3
   1b5b2:	e575      	b.n	1b0a0 <_svfprintf_r+0xe88>
   1b5b4:	9311      	str	r3, [sp, #68]	; 0x44
   1b5b6:	e6cf      	b.n	1b358 <_svfprintf_r+0x1140>
   1b5b8:	2200      	movs	r2, #0
   1b5ba:	2300      	movs	r3, #0
   1b5bc:	4648      	mov	r0, r9
   1b5be:	4641      	mov	r1, r8
   1b5c0:	f002 fbf8 	bl	1ddb4 <__aeabi_dcmpeq>
   1b5c4:	2800      	cmp	r0, #0
   1b5c6:	d1e7      	bne.n	1b598 <_svfprintf_r+0x1380>
   1b5c8:	2301      	movs	r3, #1
   1b5ca:	4652      	mov	r2, sl
   1b5cc:	1a9b      	subs	r3, r3, r2
   1b5ce:	931f      	str	r3, [sp, #124]	; 0x7c
   1b5d0:	18e4      	adds	r4, r4, r3
   1b5d2:	e673      	b.n	1b2bc <_svfprintf_r+0x10a4>
   1b5d4:	9a12      	ldr	r2, [sp, #72]	; 0x48
   1b5d6:	ab32      	add	r3, sp, #200	; 0xc8
   1b5d8:	1a9b      	subs	r3, r3, r2
   1b5da:	9310      	str	r3, [sp, #64]	; 0x40
   1b5dc:	f7fe ff35 	bl	1a44a <_svfprintf_r+0x232>
   1b5e0:	9812      	ldr	r0, [sp, #72]	; 0x48
   1b5e2:	f7fa fb15 	bl	15c10 <strlen>
   1b5e6:	0002      	movs	r2, r0
   1b5e8:	9010      	str	r0, [sp, #64]	; 0x40
   1b5ea:	0003      	movs	r3, r0
   1b5ec:	f7ff f978 	bl	1a8e0 <_svfprintf_r+0x6c8>
   1b5f0:	003a      	movs	r2, r7
   1b5f2:	9907      	ldr	r1, [sp, #28]
   1b5f4:	9809      	ldr	r0, [sp, #36]	; 0x24
   1b5f6:	f001 fbf5 	bl	1cde4 <__ssprint_r>
   1b5fa:	2800      	cmp	r0, #0
   1b5fc:	d001      	beq.n	1b602 <_svfprintf_r+0x13ea>
   1b5fe:	f7fe fec2 	bl	1a386 <_svfprintf_r+0x16e>
   1b602:	68b9      	ldr	r1, [r7, #8]
   1b604:	687b      	ldr	r3, [r7, #4]
   1b606:	aa32      	add	r2, sp, #200	; 0xc8
   1b608:	9812      	ldr	r0, [sp, #72]	; 0x48
   1b60a:	3301      	adds	r3, #1
   1b60c:	6010      	str	r0, [r2, #0]
   1b60e:	9814      	ldr	r0, [sp, #80]	; 0x50
   1b610:	607b      	str	r3, [r7, #4]
   1b612:	1844      	adds	r4, r0, r1
   1b614:	6050      	str	r0, [r2, #4]
   1b616:	60bc      	str	r4, [r7, #8]
   1b618:	2b07      	cmp	r3, #7
   1b61a:	dd01      	ble.n	1b620 <_svfprintf_r+0x1408>
   1b61c:	f7ff fb44 	bl	1aca8 <_svfprintf_r+0xa90>
   1b620:	3208      	adds	r2, #8
   1b622:	0016      	movs	r6, r2
   1b624:	f7ff faa1 	bl	1ab6a <_svfprintf_r+0x952>
   1b628:	930a      	str	r3, [sp, #40]	; 0x28
   1b62a:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
   1b62c:	222d      	movs	r2, #45	; 0x2d
   1b62e:	9308      	str	r3, [sp, #32]
   1b630:	232d      	movs	r3, #45	; 0x2d
   1b632:	4698      	mov	r8, r3
   1b634:	2300      	movs	r3, #0
   1b636:	a916      	add	r1, sp, #88	; 0x58
   1b638:	77ca      	strb	r2, [r1, #31]
   1b63a:	930b      	str	r3, [sp, #44]	; 0x2c
   1b63c:	f7fe ff11 	bl	1a462 <_svfprintf_r+0x24a>
   1b640:	9c1f      	ldr	r4, [sp, #124]	; 0x7c
   1b642:	1ce3      	adds	r3, r4, #3
   1b644:	db1e      	blt.n	1b684 <_svfprintf_r+0x146c>
   1b646:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   1b648:	42a3      	cmp	r3, r4
   1b64a:	db1b      	blt.n	1b684 <_svfprintf_r+0x146c>
   1b64c:	9415      	str	r4, [sp, #84]	; 0x54
   1b64e:	e658      	b.n	1b302 <_svfprintf_r+0x10ea>
   1b650:	2001      	movs	r0, #1
   1b652:	4240      	negs	r0, r0
   1b654:	f7fe fe9e 	bl	1a394 <_svfprintf_r+0x17c>
   1b658:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   1b65a:	2b09      	cmp	r3, #9
   1b65c:	d901      	bls.n	1b662 <_svfprintf_r+0x144a>
   1b65e:	f7fe ffca 	bl	1a5f6 <_svfprintf_r+0x3de>
   1b662:	e41e      	b.n	1aea2 <_svfprintf_r+0xc8a>
   1b664:	2401      	movs	r4, #1
   1b666:	4264      	negs	r4, r4
   1b668:	f7fe ff6d 	bl	1a546 <_svfprintf_r+0x32e>
   1b66c:	003a      	movs	r2, r7
   1b66e:	9907      	ldr	r1, [sp, #28]
   1b670:	9809      	ldr	r0, [sp, #36]	; 0x24
   1b672:	f001 fbb7 	bl	1cde4 <__ssprint_r>
   1b676:	2800      	cmp	r0, #0
   1b678:	d001      	beq.n	1b67e <_svfprintf_r+0x1466>
   1b67a:	f7fe fe84 	bl	1a386 <_svfprintf_r+0x16e>
   1b67e:	68bc      	ldr	r4, [r7, #8]
   1b680:	ae32      	add	r6, sp, #200	; 0xc8
   1b682:	e45c      	b.n	1af3e <_svfprintf_r+0xd26>
   1b684:	9b13      	ldr	r3, [sp, #76]	; 0x4c
   1b686:	3b02      	subs	r3, #2
   1b688:	9313      	str	r3, [sp, #76]	; 0x4c
   1b68a:	466b      	mov	r3, sp
   1b68c:	224c      	movs	r2, #76	; 0x4c
   1b68e:	189b      	adds	r3, r3, r2
   1b690:	781b      	ldrb	r3, [r3, #0]
   1b692:	3c01      	subs	r4, #1
   1b694:	ad21      	add	r5, sp, #132	; 0x84
   1b696:	941f      	str	r4, [sp, #124]	; 0x7c
   1b698:	702b      	strb	r3, [r5, #0]
   1b69a:	2c00      	cmp	r4, #0
   1b69c:	da00      	bge.n	1b6a0 <_svfprintf_r+0x1488>
   1b69e:	e15a      	b.n	1b956 <_svfprintf_r+0x173e>
   1b6a0:	232b      	movs	r3, #43	; 0x2b
   1b6a2:	706b      	strb	r3, [r5, #1]
   1b6a4:	2c09      	cmp	r4, #9
   1b6a6:	dc00      	bgt.n	1b6aa <_svfprintf_r+0x1492>
   1b6a8:	e131      	b.n	1b90e <_svfprintf_r+0x16f6>
   1b6aa:	aa16      	add	r2, sp, #88	; 0x58
   1b6ac:	233b      	movs	r3, #59	; 0x3b
   1b6ae:	4694      	mov	ip, r2
   1b6b0:	4463      	add	r3, ip
   1b6b2:	46b0      	mov	r8, r6
   1b6b4:	469a      	mov	sl, r3
   1b6b6:	001e      	movs	r6, r3
   1b6b8:	0020      	movs	r0, r4
   1b6ba:	210a      	movs	r1, #10
   1b6bc:	f7e8 fdfe 	bl	42bc <__aeabi_idivmod>
   1b6c0:	3e01      	subs	r6, #1
   1b6c2:	3130      	adds	r1, #48	; 0x30
   1b6c4:	7031      	strb	r1, [r6, #0]
   1b6c6:	0020      	movs	r0, r4
   1b6c8:	210a      	movs	r1, #10
   1b6ca:	f7e8 fde8 	bl	429e <__aeabi_idiv>
   1b6ce:	0004      	movs	r4, r0
   1b6d0:	2809      	cmp	r0, #9
   1b6d2:	dcf1      	bgt.n	1b6b8 <_svfprintf_r+0x14a0>
   1b6d4:	0033      	movs	r3, r6
   1b6d6:	3430      	adds	r4, #48	; 0x30
   1b6d8:	1e5a      	subs	r2, r3, #1
   1b6da:	b2e4      	uxtb	r4, r4
   1b6dc:	4646      	mov	r6, r8
   1b6de:	7014      	strb	r4, [r2, #0]
   1b6e0:	4698      	mov	r8, r3
   1b6e2:	4552      	cmp	r2, sl
   1b6e4:	d300      	bcc.n	1b6e8 <_svfprintf_r+0x14d0>
   1b6e6:	e176      	b.n	1b9d6 <_svfprintf_r+0x17be>
   1b6e8:	4641      	mov	r1, r8
   1b6ea:	1a79      	subs	r1, r7, r1
   1b6ec:	002b      	movs	r3, r5
   1b6ee:	1869      	adds	r1, r5, r1
   1b6f0:	e000      	b.n	1b6f4 <_svfprintf_r+0x14dc>
   1b6f2:	7814      	ldrb	r4, [r2, #0]
   1b6f4:	709c      	strb	r4, [r3, #2]
   1b6f6:	3301      	adds	r3, #1
   1b6f8:	3201      	adds	r2, #1
   1b6fa:	4299      	cmp	r1, r3
   1b6fc:	d1f9      	bne.n	1b6f2 <_svfprintf_r+0x14da>
   1b6fe:	a916      	add	r1, sp, #88	; 0x58
   1b700:	468c      	mov	ip, r1
   1b702:	222e      	movs	r2, #46	; 0x2e
   1b704:	4643      	mov	r3, r8
   1b706:	4462      	add	r2, ip
   1b708:	4694      	mov	ip, r2
   1b70a:	1afb      	subs	r3, r7, r3
   1b70c:	4463      	add	r3, ip
   1b70e:	9914      	ldr	r1, [sp, #80]	; 0x50
   1b710:	1b5b      	subs	r3, r3, r5
   1b712:	000a      	movs	r2, r1
   1b714:	469c      	mov	ip, r3
   1b716:	4462      	add	r2, ip
   1b718:	931a      	str	r3, [sp, #104]	; 0x68
   1b71a:	9210      	str	r2, [sp, #64]	; 0x40
   1b71c:	2901      	cmp	r1, #1
   1b71e:	dc00      	bgt.n	1b722 <_svfprintf_r+0x150a>
   1b720:	e127      	b.n	1b972 <_svfprintf_r+0x175a>
   1b722:	9a18      	ldr	r2, [sp, #96]	; 0x60
   1b724:	9b10      	ldr	r3, [sp, #64]	; 0x40
   1b726:	4694      	mov	ip, r2
   1b728:	4463      	add	r3, ip
   1b72a:	001a      	movs	r2, r3
   1b72c:	9310      	str	r3, [sp, #64]	; 0x40
   1b72e:	43db      	mvns	r3, r3
   1b730:	17db      	asrs	r3, r3, #31
   1b732:	4013      	ands	r3, r2
   1b734:	2200      	movs	r2, #0
   1b736:	9215      	str	r2, [sp, #84]	; 0x54
   1b738:	e5f2      	b.n	1b320 <_svfprintf_r+0x1108>
   1b73a:	46a9      	mov	r9, r5
   1b73c:	4648      	mov	r0, r9
   1b73e:	1909      	adds	r1, r1, r4
   1b740:	3301      	adds	r3, #1
   1b742:	6010      	str	r0, [r2, #0]
   1b744:	6054      	str	r4, [r2, #4]
   1b746:	60b9      	str	r1, [r7, #8]
   1b748:	607b      	str	r3, [r7, #4]
   1b74a:	2b07      	cmp	r3, #7
   1b74c:	dd00      	ble.n	1b750 <_svfprintf_r+0x1538>
   1b74e:	e74f      	b.n	1b5f0 <_svfprintf_r+0x13d8>
   1b750:	3208      	adds	r2, #8
   1b752:	e759      	b.n	1b608 <_svfprintf_r+0x13f0>
   1b754:	003a      	movs	r2, r7
   1b756:	9907      	ldr	r1, [sp, #28]
   1b758:	9809      	ldr	r0, [sp, #36]	; 0x24
   1b75a:	f001 fb43 	bl	1cde4 <__ssprint_r>
   1b75e:	2800      	cmp	r0, #0
   1b760:	d001      	beq.n	1b766 <_svfprintf_r+0x154e>
   1b762:	f7fe fe10 	bl	1a386 <_svfprintf_r+0x16e>
   1b766:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   1b768:	68bc      	ldr	r4, [r7, #8]
   1b76a:	ae32      	add	r6, sp, #200	; 0xc8
   1b76c:	e4d6      	b.n	1b11c <_svfprintf_r+0xf04>
   1b76e:	003a      	movs	r2, r7
   1b770:	9907      	ldr	r1, [sp, #28]
   1b772:	9809      	ldr	r0, [sp, #36]	; 0x24
   1b774:	f001 fb36 	bl	1cde4 <__ssprint_r>
   1b778:	2800      	cmp	r0, #0
   1b77a:	d001      	beq.n	1b780 <_svfprintf_r+0x1568>
   1b77c:	f7fe fe03 	bl	1a386 <_svfprintf_r+0x16e>
   1b780:	68bc      	ldr	r4, [r7, #8]
   1b782:	ae32      	add	r6, sp, #200	; 0xc8
   1b784:	e4be      	b.n	1b104 <_svfprintf_r+0xeec>
   1b786:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   1b788:	2b06      	cmp	r3, #6
   1b78a:	d900      	bls.n	1b78e <_svfprintf_r+0x1576>
   1b78c:	2306      	movs	r3, #6
   1b78e:	001a      	movs	r2, r3
   1b790:	9310      	str	r3, [sp, #64]	; 0x40
   1b792:	43db      	mvns	r3, r3
   1b794:	17db      	asrs	r3, r3, #31
   1b796:	401a      	ands	r2, r3
   1b798:	2300      	movs	r3, #0
   1b79a:	4698      	mov	r8, r3
   1b79c:	930b      	str	r3, [sp, #44]	; 0x2c
   1b79e:	9315      	str	r3, [sp, #84]	; 0x54
   1b7a0:	4b46      	ldr	r3, [pc, #280]	; (1b8bc <_svfprintf_r+0x16a4>)
   1b7a2:	920a      	str	r2, [sp, #40]	; 0x28
   1b7a4:	9411      	str	r4, [sp, #68]	; 0x44
   1b7a6:	9312      	str	r3, [sp, #72]	; 0x48
   1b7a8:	f7fe fe5e 	bl	1a468 <_svfprintf_r+0x250>
   1b7ac:	003a      	movs	r2, r7
   1b7ae:	9907      	ldr	r1, [sp, #28]
   1b7b0:	9809      	ldr	r0, [sp, #36]	; 0x24
   1b7b2:	f001 fb17 	bl	1cde4 <__ssprint_r>
   1b7b6:	2800      	cmp	r0, #0
   1b7b8:	d001      	beq.n	1b7be <_svfprintf_r+0x15a6>
   1b7ba:	f7fe fde4 	bl	1a386 <_svfprintf_r+0x16e>
   1b7be:	9b14      	ldr	r3, [sp, #80]	; 0x50
   1b7c0:	9a1f      	ldr	r2, [sp, #124]	; 0x7c
   1b7c2:	68bc      	ldr	r4, [r7, #8]
   1b7c4:	1a9b      	subs	r3, r3, r2
   1b7c6:	ae32      	add	r6, sp, #200	; 0xc8
   1b7c8:	e4c1      	b.n	1b14e <_svfprintf_r+0xf36>
   1b7ca:	232d      	movs	r3, #45	; 0x2d
   1b7cc:	4698      	mov	r8, r3
   1b7ce:	f7fe ff0d 	bl	1a5ec <_svfprintf_r+0x3d4>
   1b7d2:	ab23      	add	r3, sp, #140	; 0x8c
   1b7d4:	9304      	str	r3, [sp, #16]
   1b7d6:	ab20      	add	r3, sp, #128	; 0x80
   1b7d8:	9303      	str	r3, [sp, #12]
   1b7da:	ab1f      	add	r3, sp, #124	; 0x7c
   1b7dc:	9302      	str	r3, [sp, #8]
   1b7de:	2303      	movs	r3, #3
   1b7e0:	9c0b      	ldr	r4, [sp, #44]	; 0x2c
   1b7e2:	9300      	str	r3, [sp, #0]
   1b7e4:	9401      	str	r4, [sp, #4]
   1b7e6:	464a      	mov	r2, r9
   1b7e8:	4643      	mov	r3, r8
   1b7ea:	9809      	ldr	r0, [sp, #36]	; 0x24
   1b7ec:	f7fb fffa 	bl	177e4 <_dtoa_r>
   1b7f0:	46a4      	mov	ip, r4
   1b7f2:	0001      	movs	r1, r0
   1b7f4:	0022      	movs	r2, r4
   1b7f6:	4461      	add	r1, ip
   1b7f8:	9012      	str	r0, [sp, #72]	; 0x48
   1b7fa:	000c      	movs	r4, r1
   1b7fc:	4692      	mov	sl, r2
   1b7fe:	e6c7      	b.n	1b590 <_svfprintf_r+0x1378>
   1b800:	2300      	movs	r3, #0
   1b802:	9008      	str	r0, [sp, #32]
   1b804:	4698      	mov	r8, r3
   1b806:	f7ff f819 	bl	1a83c <_svfprintf_r+0x624>
   1b80a:	232d      	movs	r3, #45	; 0x2d
   1b80c:	aa16      	add	r2, sp, #88	; 0x58
   1b80e:	77d3      	strb	r3, [r2, #31]
   1b810:	4698      	mov	r8, r3
   1b812:	f7fe ff53 	bl	1a6bc <_svfprintf_r+0x4a4>
   1b816:	2320      	movs	r3, #32
   1b818:	9d13      	ldr	r5, [sp, #76]	; 0x4c
   1b81a:	439d      	bics	r5, r3
   1b81c:	3b1a      	subs	r3, #26
   1b81e:	930b      	str	r3, [sp, #44]	; 0x2c
   1b820:	e516      	b.n	1b250 <_svfprintf_r+0x1038>
   1b822:	9a18      	ldr	r2, [sp, #96]	; 0x60
   1b824:	9b14      	ldr	r3, [sp, #80]	; 0x50
   1b826:	4694      	mov	ip, r2
   1b828:	9a15      	ldr	r2, [sp, #84]	; 0x54
   1b82a:	4463      	add	r3, ip
   1b82c:	9310      	str	r3, [sp, #64]	; 0x40
   1b82e:	2a00      	cmp	r2, #0
   1b830:	dc00      	bgt.n	1b834 <_svfprintf_r+0x161c>
   1b832:	e094      	b.n	1b95e <_svfprintf_r+0x1746>
   1b834:	001a      	movs	r2, r3
   1b836:	43db      	mvns	r3, r3
   1b838:	17db      	asrs	r3, r3, #31
   1b83a:	4013      	ands	r3, r2
   1b83c:	2267      	movs	r2, #103	; 0x67
   1b83e:	9213      	str	r2, [sp, #76]	; 0x4c
   1b840:	e56e      	b.n	1b320 <_svfprintf_r+0x1108>
   1b842:	2280      	movs	r2, #128	; 0x80
   1b844:	0612      	lsls	r2, r2, #24
   1b846:	4694      	mov	ip, r2
   1b848:	9b16      	ldr	r3, [sp, #88]	; 0x58
   1b84a:	4699      	mov	r9, r3
   1b84c:	9b17      	ldr	r3, [sp, #92]	; 0x5c
   1b84e:	4463      	add	r3, ip
   1b850:	4698      	mov	r8, r3
   1b852:	232d      	movs	r3, #45	; 0x2d
   1b854:	930a      	str	r3, [sp, #40]	; 0x28
   1b856:	e509      	b.n	1b26c <_svfprintf_r+0x1054>
   1b858:	ab16      	add	r3, sp, #88	; 0x58
   1b85a:	7fdb      	ldrb	r3, [r3, #31]
   1b85c:	9411      	str	r4, [sp, #68]	; 0x44
   1b85e:	4698      	mov	r8, r3
   1b860:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   1b862:	930a      	str	r3, [sp, #40]	; 0x28
   1b864:	9310      	str	r3, [sp, #64]	; 0x40
   1b866:	2300      	movs	r3, #0
   1b868:	930b      	str	r3, [sp, #44]	; 0x2c
   1b86a:	9315      	str	r3, [sp, #84]	; 0x54
   1b86c:	f7fe fdf6 	bl	1a45c <_svfprintf_r+0x244>
   1b870:	4698      	mov	r8, r3
   1b872:	9b08      	ldr	r3, [sp, #32]
   1b874:	07db      	lsls	r3, r3, #31
   1b876:	d505      	bpl.n	1b884 <_svfprintf_r+0x166c>
   1b878:	2130      	movs	r1, #48	; 0x30
   1b87a:	2327      	movs	r3, #39	; 0x27
   1b87c:	aa28      	add	r2, sp, #160	; 0xa0
   1b87e:	54d1      	strb	r1, [r2, r3]
   1b880:	f7ff fb14 	bl	1aeac <_svfprintf_r+0xc94>
   1b884:	2300      	movs	r3, #0
   1b886:	9310      	str	r3, [sp, #64]	; 0x40
   1b888:	ab32      	add	r3, sp, #200	; 0xc8
   1b88a:	9312      	str	r3, [sp, #72]	; 0x48
   1b88c:	f7fe fddd 	bl	1a44a <_svfprintf_r+0x232>
   1b890:	9b12      	ldr	r3, [sp, #72]	; 0x48
   1b892:	4453      	add	r3, sl
   1b894:	001c      	movs	r4, r3
   1b896:	9b13      	ldr	r3, [sp, #76]	; 0x4c
   1b898:	2b47      	cmp	r3, #71	; 0x47
   1b89a:	d000      	beq.n	1b89e <_svfprintf_r+0x1686>
   1b89c:	e50e      	b.n	1b2bc <_svfprintf_r+0x10a4>
   1b89e:	9b08      	ldr	r3, [sp, #32]
   1b8a0:	07db      	lsls	r3, r3, #31
   1b8a2:	d500      	bpl.n	1b8a6 <_svfprintf_r+0x168e>
   1b8a4:	e66d      	b.n	1b582 <_svfprintf_r+0x136a>
   1b8a6:	9b23      	ldr	r3, [sp, #140]	; 0x8c
   1b8a8:	9a12      	ldr	r2, [sp, #72]	; 0x48
   1b8aa:	1a9b      	subs	r3, r3, r2
   1b8ac:	9314      	str	r3, [sp, #80]	; 0x50
   1b8ae:	2d47      	cmp	r5, #71	; 0x47
   1b8b0:	d100      	bne.n	1b8b4 <_svfprintf_r+0x169c>
   1b8b2:	e6c5      	b.n	1b640 <_svfprintf_r+0x1428>
   1b8b4:	9c1f      	ldr	r4, [sp, #124]	; 0x7c
   1b8b6:	e6e8      	b.n	1b68a <_svfprintf_r+0x1472>
   1b8b8:	00022d3c 	.word	0x00022d3c
   1b8bc:	00022d70 	.word	0x00022d70
   1b8c0:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
   1b8c2:	9315      	str	r3, [sp, #84]	; 0x54
   1b8c4:	2b00      	cmp	r3, #0
   1b8c6:	dd5e      	ble.n	1b986 <_svfprintf_r+0x176e>
   1b8c8:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
   1b8ca:	2a00      	cmp	r2, #0
   1b8cc:	d134      	bne.n	1b938 <_svfprintf_r+0x1720>
   1b8ce:	9a08      	ldr	r2, [sp, #32]
   1b8d0:	07d2      	lsls	r2, r2, #31
   1b8d2:	d431      	bmi.n	1b938 <_svfprintf_r+0x1720>
   1b8d4:	9310      	str	r3, [sp, #64]	; 0x40
   1b8d6:	e523      	b.n	1b320 <_svfprintf_r+0x1108>
   1b8d8:	2000      	movs	r0, #0
   1b8da:	900b      	str	r0, [sp, #44]	; 0x2c
   1b8dc:	f7fe fcff 	bl	1a2de <_svfprintf_r+0xc6>
   1b8e0:	003a      	movs	r2, r7
   1b8e2:	9907      	ldr	r1, [sp, #28]
   1b8e4:	9809      	ldr	r0, [sp, #36]	; 0x24
   1b8e6:	f001 fa7d 	bl	1cde4 <__ssprint_r>
   1b8ea:	2800      	cmp	r0, #0
   1b8ec:	d001      	beq.n	1b8f2 <_svfprintf_r+0x16da>
   1b8ee:	f7fe fd4a 	bl	1a386 <_svfprintf_r+0x16e>
   1b8f2:	981f      	ldr	r0, [sp, #124]	; 0x7c
   1b8f4:	68b9      	ldr	r1, [r7, #8]
   1b8f6:	687b      	ldr	r3, [r7, #4]
   1b8f8:	aa32      	add	r2, sp, #200	; 0xc8
   1b8fa:	e5cb      	b.n	1b494 <_svfprintf_r+0x127c>
   1b8fc:	9a18      	ldr	r2, [sp, #96]	; 0x60
   1b8fe:	9b15      	ldr	r3, [sp, #84]	; 0x54
   1b900:	4694      	mov	ip, r2
   1b902:	4463      	add	r3, ip
   1b904:	001a      	movs	r2, r3
   1b906:	9310      	str	r3, [sp, #64]	; 0x40
   1b908:	e795      	b.n	1b836 <_svfprintf_r+0x161e>
   1b90a:	9b23      	ldr	r3, [sp, #140]	; 0x8c
   1b90c:	e4e9      	b.n	1b2e2 <_svfprintf_r+0x10ca>
   1b90e:	2330      	movs	r3, #48	; 0x30
   1b910:	3430      	adds	r4, #48	; 0x30
   1b912:	70ab      	strb	r3, [r5, #2]
   1b914:	70ec      	strb	r4, [r5, #3]
   1b916:	ab22      	add	r3, sp, #136	; 0x88
   1b918:	e6f9      	b.n	1b70e <_svfprintf_r+0x14f6>
   1b91a:	9b13      	ldr	r3, [sp, #76]	; 0x4c
   1b91c:	2b47      	cmp	r3, #71	; 0x47
   1b91e:	dc2f      	bgt.n	1b980 <_svfprintf_r+0x1768>
   1b920:	4b41      	ldr	r3, [pc, #260]	; (1ba28 <_svfprintf_r+0x1810>)
   1b922:	9312      	str	r3, [sp, #72]	; 0x48
   1b924:	2380      	movs	r3, #128	; 0x80
   1b926:	9a08      	ldr	r2, [sp, #32]
   1b928:	439a      	bics	r2, r3
   1b92a:	ab16      	add	r3, sp, #88	; 0x58
   1b92c:	7fdb      	ldrb	r3, [r3, #31]
   1b92e:	9208      	str	r2, [sp, #32]
   1b930:	4698      	mov	r8, r3
   1b932:	2303      	movs	r3, #3
   1b934:	f7fe fece 	bl	1a6d4 <_svfprintf_r+0x4bc>
   1b938:	9a18      	ldr	r2, [sp, #96]	; 0x60
   1b93a:	9b15      	ldr	r3, [sp, #84]	; 0x54
   1b93c:	4694      	mov	ip, r2
   1b93e:	4463      	add	r3, ip
   1b940:	0018      	movs	r0, r3
   1b942:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   1b944:	469c      	mov	ip, r3
   1b946:	4484      	add	ip, r0
   1b948:	4663      	mov	r3, ip
   1b94a:	9310      	str	r3, [sp, #64]	; 0x40
   1b94c:	43db      	mvns	r3, r3
   1b94e:	4662      	mov	r2, ip
   1b950:	17db      	asrs	r3, r3, #31
   1b952:	4013      	ands	r3, r2
   1b954:	e4e4      	b.n	1b320 <_svfprintf_r+0x1108>
   1b956:	232d      	movs	r3, #45	; 0x2d
   1b958:	4264      	negs	r4, r4
   1b95a:	706b      	strb	r3, [r5, #1]
   1b95c:	e6a2      	b.n	1b6a4 <_svfprintf_r+0x148c>
   1b95e:	9b10      	ldr	r3, [sp, #64]	; 0x40
   1b960:	9a15      	ldr	r2, [sp, #84]	; 0x54
   1b962:	1a98      	subs	r0, r3, r2
   1b964:	1c43      	adds	r3, r0, #1
   1b966:	e7cd      	b.n	1b904 <_svfprintf_r+0x16ec>
   1b968:	4a30      	ldr	r2, [pc, #192]	; (1ba2c <_svfprintf_r+0x1814>)
   1b96a:	687b      	ldr	r3, [r7, #4]
   1b96c:	4691      	mov	r9, r2
   1b96e:	f7ff fbbd 	bl	1b0ec <_svfprintf_r+0xed4>
   1b972:	9b08      	ldr	r3, [sp, #32]
   1b974:	07db      	lsls	r3, r3, #31
   1b976:	d500      	bpl.n	1b97a <_svfprintf_r+0x1762>
   1b978:	e6d3      	b.n	1b722 <_svfprintf_r+0x150a>
   1b97a:	9a10      	ldr	r2, [sp, #64]	; 0x40
   1b97c:	0013      	movs	r3, r2
   1b97e:	e6d6      	b.n	1b72e <_svfprintf_r+0x1516>
   1b980:	4b2b      	ldr	r3, [pc, #172]	; (1ba30 <_svfprintf_r+0x1818>)
   1b982:	9312      	str	r3, [sp, #72]	; 0x48
   1b984:	e7ce      	b.n	1b924 <_svfprintf_r+0x170c>
   1b986:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   1b988:	2b00      	cmp	r3, #0
   1b98a:	d102      	bne.n	1b992 <_svfprintf_r+0x177a>
   1b98c:	9b08      	ldr	r3, [sp, #32]
   1b98e:	07db      	lsls	r3, r3, #31
   1b990:	d502      	bpl.n	1b998 <_svfprintf_r+0x1780>
   1b992:	9b18      	ldr	r3, [sp, #96]	; 0x60
   1b994:	1c58      	adds	r0, r3, #1
   1b996:	e7d4      	b.n	1b942 <_svfprintf_r+0x172a>
   1b998:	2201      	movs	r2, #1
   1b99a:	2301      	movs	r3, #1
   1b99c:	9210      	str	r2, [sp, #64]	; 0x40
   1b99e:	e4bf      	b.n	1b320 <_svfprintf_r+0x1108>
   1b9a0:	9b11      	ldr	r3, [sp, #68]	; 0x44
   1b9a2:	1d1c      	adds	r4, r3, #4
   1b9a4:	681b      	ldr	r3, [r3, #0]
   1b9a6:	930b      	str	r3, [sp, #44]	; 0x2c
   1b9a8:	2b00      	cmp	r3, #0
   1b9aa:	db08      	blt.n	1b9be <_svfprintf_r+0x17a6>
   1b9ac:	786b      	ldrb	r3, [r5, #1]
   1b9ae:	9411      	str	r4, [sp, #68]	; 0x44
   1b9b0:	4645      	mov	r5, r8
   1b9b2:	f7fe fc93 	bl	1a2dc <_svfprintf_r+0xc4>
   1b9b6:	ab16      	add	r3, sp, #88	; 0x58
   1b9b8:	77d9      	strb	r1, [r3, #31]
   1b9ba:	f7fe fdea 	bl	1a592 <_svfprintf_r+0x37a>
   1b9be:	2001      	movs	r0, #1
   1b9c0:	4240      	negs	r0, r0
   1b9c2:	786b      	ldrb	r3, [r5, #1]
   1b9c4:	9411      	str	r4, [sp, #68]	; 0x44
   1b9c6:	4645      	mov	r5, r8
   1b9c8:	900b      	str	r0, [sp, #44]	; 0x2c
   1b9ca:	f7fe fc87 	bl	1a2dc <_svfprintf_r+0xc4>
   1b9ce:	ab16      	add	r3, sp, #88	; 0x58
   1b9d0:	77d9      	strb	r1, [r3, #31]
   1b9d2:	f7fe fcec 	bl	1a3ae <_svfprintf_r+0x196>
   1b9d6:	aa16      	add	r2, sp, #88	; 0x58
   1b9d8:	232e      	movs	r3, #46	; 0x2e
   1b9da:	4694      	mov	ip, r2
   1b9dc:	4463      	add	r3, ip
   1b9de:	e696      	b.n	1b70e <_svfprintf_r+0x14f6>
   1b9e0:	ab16      	add	r3, sp, #88	; 0x58
   1b9e2:	77d9      	strb	r1, [r3, #31]
   1b9e4:	f7fe ffd9 	bl	1a99a <_svfprintf_r+0x782>
   1b9e8:	ab16      	add	r3, sp, #88	; 0x58
   1b9ea:	77d9      	strb	r1, [r3, #31]
   1b9ec:	4911      	ldr	r1, [pc, #68]	; (1ba34 <_svfprintf_r+0x181c>)
   1b9ee:	f7fe ff92 	bl	1a916 <_svfprintf_r+0x6fe>
   1b9f2:	ab16      	add	r3, sp, #88	; 0x58
   1b9f4:	77d9      	strb	r1, [r3, #31]
   1b9f6:	f7ff f829 	bl	1aa4c <_svfprintf_r+0x834>
   1b9fa:	230c      	movs	r3, #12
   1b9fc:	9a09      	ldr	r2, [sp, #36]	; 0x24
   1b9fe:	3801      	subs	r0, #1
   1ba00:	6013      	str	r3, [r2, #0]
   1ba02:	f7fe fcc7 	bl	1a394 <_svfprintf_r+0x17c>
   1ba06:	ab16      	add	r3, sp, #88	; 0x58
   1ba08:	77d9      	strb	r1, [r3, #31]
   1ba0a:	f7fe fedd 	bl	1a7c8 <_svfprintf_r+0x5b0>
   1ba0e:	ab16      	add	r3, sp, #88	; 0x58
   1ba10:	77d9      	strb	r1, [r3, #31]
   1ba12:	f7fe fe1f 	bl	1a654 <_svfprintf_r+0x43c>
   1ba16:	ab16      	add	r3, sp, #88	; 0x58
   1ba18:	77d9      	strb	r1, [r3, #31]
   1ba1a:	f7fe fea4 	bl	1a766 <_svfprintf_r+0x54e>
   1ba1e:	ab16      	add	r3, sp, #88	; 0x58
   1ba20:	77d9      	strb	r1, [r3, #31]
   1ba22:	f7fe fe69 	bl	1a6f8 <_svfprintf_r+0x4e0>
   1ba26:	46c0      	nop			; (mov r8, r8)
   1ba28:	00022d40 	.word	0x00022d40
   1ba2c:	0002302c 	.word	0x0002302c
   1ba30:	00022d44 	.word	0x00022d44
   1ba34:	00022d5c 	.word	0x00022d5c

0001ba38 <__sprint_r.part.0>:
   1ba38:	b5f0      	push	{r4, r5, r6, r7, lr}
   1ba3a:	4657      	mov	r7, sl
   1ba3c:	464e      	mov	r6, r9
   1ba3e:	4645      	mov	r5, r8
   1ba40:	6e4b      	ldr	r3, [r1, #100]	; 0x64
   1ba42:	b4e0      	push	{r5, r6, r7}
   1ba44:	4680      	mov	r8, r0
   1ba46:	000f      	movs	r7, r1
   1ba48:	4691      	mov	r9, r2
   1ba4a:	049b      	lsls	r3, r3, #18
   1ba4c:	d52d      	bpl.n	1baaa <__sprint_r.part.0+0x72>
   1ba4e:	6813      	ldr	r3, [r2, #0]
   1ba50:	469a      	mov	sl, r3
   1ba52:	6893      	ldr	r3, [r2, #8]
   1ba54:	2b00      	cmp	r3, #0
   1ba56:	d026      	beq.n	1baa6 <__sprint_r.part.0+0x6e>
   1ba58:	4652      	mov	r2, sl
   1ba5a:	6852      	ldr	r2, [r2, #4]
   1ba5c:	2500      	movs	r5, #0
   1ba5e:	0896      	lsrs	r6, r2, #2
   1ba60:	4652      	mov	r2, sl
   1ba62:	6814      	ldr	r4, [r2, #0]
   1ba64:	d104      	bne.n	1ba70 <__sprint_r.part.0+0x38>
   1ba66:	e015      	b.n	1ba94 <__sprint_r.part.0+0x5c>
   1ba68:	3501      	adds	r5, #1
   1ba6a:	3404      	adds	r4, #4
   1ba6c:	42ae      	cmp	r6, r5
   1ba6e:	d00f      	beq.n	1ba90 <__sprint_r.part.0+0x58>
   1ba70:	003a      	movs	r2, r7
   1ba72:	6821      	ldr	r1, [r4, #0]
   1ba74:	4640      	mov	r0, r8
   1ba76:	f001 f86f 	bl	1cb58 <_fputwc_r>
   1ba7a:	1c43      	adds	r3, r0, #1
   1ba7c:	d1f4      	bne.n	1ba68 <__sprint_r.part.0+0x30>
   1ba7e:	464a      	mov	r2, r9
   1ba80:	2300      	movs	r3, #0
   1ba82:	6093      	str	r3, [r2, #8]
   1ba84:	6053      	str	r3, [r2, #4]
   1ba86:	bc1c      	pop	{r2, r3, r4}
   1ba88:	4690      	mov	r8, r2
   1ba8a:	4699      	mov	r9, r3
   1ba8c:	46a2      	mov	sl, r4
   1ba8e:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1ba90:	464b      	mov	r3, r9
   1ba92:	689b      	ldr	r3, [r3, #8]
   1ba94:	464a      	mov	r2, r9
   1ba96:	00b6      	lsls	r6, r6, #2
   1ba98:	1b9b      	subs	r3, r3, r6
   1ba9a:	6093      	str	r3, [r2, #8]
   1ba9c:	2208      	movs	r2, #8
   1ba9e:	4694      	mov	ip, r2
   1baa0:	44e2      	add	sl, ip
   1baa2:	2b00      	cmp	r3, #0
   1baa4:	d1d8      	bne.n	1ba58 <__sprint_r.part.0+0x20>
   1baa6:	2000      	movs	r0, #0
   1baa8:	e7e9      	b.n	1ba7e <__sprint_r.part.0+0x46>
   1baaa:	f7fd f961 	bl	18d70 <__sfvwrite_r>
   1baae:	e7e6      	b.n	1ba7e <__sprint_r.part.0+0x46>

0001bab0 <__sprint_r>:
   1bab0:	6893      	ldr	r3, [r2, #8]
   1bab2:	b510      	push	{r4, lr}
   1bab4:	2b00      	cmp	r3, #0
   1bab6:	d002      	beq.n	1babe <__sprint_r+0xe>
   1bab8:	f7ff ffbe 	bl	1ba38 <__sprint_r.part.0>
   1babc:	bd10      	pop	{r4, pc}
   1babe:	6053      	str	r3, [r2, #4]
   1bac0:	2000      	movs	r0, #0
   1bac2:	e7fb      	b.n	1babc <__sprint_r+0xc>

0001bac4 <_vfiprintf_r>:
   1bac4:	b5f0      	push	{r4, r5, r6, r7, lr}
   1bac6:	465f      	mov	r7, fp
   1bac8:	4656      	mov	r6, sl
   1baca:	4644      	mov	r4, r8
   1bacc:	464d      	mov	r5, r9
   1bace:	b4f0      	push	{r4, r5, r6, r7}
   1bad0:	b0af      	sub	sp, #188	; 0xbc
   1bad2:	9004      	str	r0, [sp, #16]
   1bad4:	468a      	mov	sl, r1
   1bad6:	4693      	mov	fp, r2
   1bad8:	001c      	movs	r4, r3
   1bada:	930a      	str	r3, [sp, #40]	; 0x28
   1badc:	2800      	cmp	r0, #0
   1bade:	d004      	beq.n	1baea <_vfiprintf_r+0x26>
   1bae0:	6b83      	ldr	r3, [r0, #56]	; 0x38
   1bae2:	9301      	str	r3, [sp, #4]
   1bae4:	2b00      	cmp	r3, #0
   1bae6:	d100      	bne.n	1baea <_vfiprintf_r+0x26>
   1bae8:	e08f      	b.n	1bc0a <_vfiprintf_r+0x146>
   1baea:	4653      	mov	r3, sl
   1baec:	2180      	movs	r1, #128	; 0x80
   1baee:	220c      	movs	r2, #12
   1baf0:	5e9a      	ldrsh	r2, [r3, r2]
   1baf2:	0189      	lsls	r1, r1, #6
   1baf4:	b293      	uxth	r3, r2
   1baf6:	420b      	tst	r3, r1
   1baf8:	d109      	bne.n	1bb0e <_vfiprintf_r+0x4a>
   1bafa:	430a      	orrs	r2, r1
   1bafc:	4653      	mov	r3, sl
   1bafe:	4651      	mov	r1, sl
   1bb00:	819a      	strh	r2, [r3, #12]
   1bb02:	6e49      	ldr	r1, [r1, #100]	; 0x64
   1bb04:	4bca      	ldr	r3, [pc, #808]	; (1be30 <_vfiprintf_r+0x36c>)
   1bb06:	400b      	ands	r3, r1
   1bb08:	4651      	mov	r1, sl
   1bb0a:	664b      	str	r3, [r1, #100]	; 0x64
   1bb0c:	b293      	uxth	r3, r2
   1bb0e:	071a      	lsls	r2, r3, #28
   1bb10:	d55b      	bpl.n	1bbca <_vfiprintf_r+0x106>
   1bb12:	4652      	mov	r2, sl
   1bb14:	6912      	ldr	r2, [r2, #16]
   1bb16:	2a00      	cmp	r2, #0
   1bb18:	d057      	beq.n	1bbca <_vfiprintf_r+0x106>
   1bb1a:	221a      	movs	r2, #26
   1bb1c:	4013      	ands	r3, r2
   1bb1e:	2b0a      	cmp	r3, #10
   1bb20:	d061      	beq.n	1bbe6 <_vfiprintf_r+0x122>
   1bb22:	ab1e      	add	r3, sp, #120	; 0x78
   1bb24:	4698      	mov	r8, r3
   1bb26:	9311      	str	r3, [sp, #68]	; 0x44
   1bb28:	2300      	movs	r3, #0
   1bb2a:	465d      	mov	r5, fp
   1bb2c:	4647      	mov	r7, r8
   1bb2e:	46d3      	mov	fp, sl
   1bb30:	9313      	str	r3, [sp, #76]	; 0x4c
   1bb32:	9312      	str	r3, [sp, #72]	; 0x48
   1bb34:	9305      	str	r3, [sp, #20]
   1bb36:	782b      	ldrb	r3, [r5, #0]
   1bb38:	002c      	movs	r4, r5
   1bb3a:	2b00      	cmp	r3, #0
   1bb3c:	d01b      	beq.n	1bb76 <_vfiprintf_r+0xb2>
   1bb3e:	2b25      	cmp	r3, #37	; 0x25
   1bb40:	d102      	bne.n	1bb48 <_vfiprintf_r+0x84>
   1bb42:	e018      	b.n	1bb76 <_vfiprintf_r+0xb2>
   1bb44:	2b25      	cmp	r3, #37	; 0x25
   1bb46:	d003      	beq.n	1bb50 <_vfiprintf_r+0x8c>
   1bb48:	3401      	adds	r4, #1
   1bb4a:	7823      	ldrb	r3, [r4, #0]
   1bb4c:	2b00      	cmp	r3, #0
   1bb4e:	d1f9      	bne.n	1bb44 <_vfiprintf_r+0x80>
   1bb50:	1b66      	subs	r6, r4, r5
   1bb52:	d010      	beq.n	1bb76 <_vfiprintf_r+0xb2>
   1bb54:	9b13      	ldr	r3, [sp, #76]	; 0x4c
   1bb56:	603d      	str	r5, [r7, #0]
   1bb58:	18f2      	adds	r2, r6, r3
   1bb5a:	9b12      	ldr	r3, [sp, #72]	; 0x48
   1bb5c:	607e      	str	r6, [r7, #4]
   1bb5e:	9301      	str	r3, [sp, #4]
   1bb60:	3301      	adds	r3, #1
   1bb62:	9213      	str	r2, [sp, #76]	; 0x4c
   1bb64:	9312      	str	r3, [sp, #72]	; 0x48
   1bb66:	3708      	adds	r7, #8
   1bb68:	2b07      	cmp	r3, #7
   1bb6a:	dc27      	bgt.n	1bbbc <_vfiprintf_r+0xf8>
   1bb6c:	9b05      	ldr	r3, [sp, #20]
   1bb6e:	469c      	mov	ip, r3
   1bb70:	44b4      	add	ip, r6
   1bb72:	4663      	mov	r3, ip
   1bb74:	9305      	str	r3, [sp, #20]
   1bb76:	7823      	ldrb	r3, [r4, #0]
   1bb78:	2b00      	cmp	r3, #0
   1bb7a:	d101      	bne.n	1bb80 <_vfiprintf_r+0xbc>
   1bb7c:	f000 fe11 	bl	1c7a2 <_vfiprintf_r+0xcde>
   1bb80:	2300      	movs	r3, #0
   1bb82:	aa0e      	add	r2, sp, #56	; 0x38
   1bb84:	71d3      	strb	r3, [r2, #7]
   1bb86:	2201      	movs	r2, #1
   1bb88:	4252      	negs	r2, r2
   1bb8a:	9203      	str	r2, [sp, #12]
   1bb8c:	2200      	movs	r2, #0
   1bb8e:	9209      	str	r2, [sp, #36]	; 0x24
   1bb90:	9201      	str	r2, [sp, #4]
   1bb92:	3240      	adds	r2, #64	; 0x40
   1bb94:	4692      	mov	sl, r2
   1bb96:	3240      	adds	r2, #64	; 0x40
   1bb98:	4691      	mov	r9, r2
   1bb9a:	3a7f      	subs	r2, #127	; 0x7f
   1bb9c:	1c65      	adds	r5, r4, #1
   1bb9e:	7863      	ldrb	r3, [r4, #1]
   1bba0:	2000      	movs	r0, #0
   1bba2:	2600      	movs	r6, #0
   1bba4:	2420      	movs	r4, #32
   1bba6:	4694      	mov	ip, r2
   1bba8:	3501      	adds	r5, #1
   1bbaa:	001a      	movs	r2, r3
   1bbac:	3a20      	subs	r2, #32
   1bbae:	2a58      	cmp	r2, #88	; 0x58
   1bbb0:	d900      	bls.n	1bbb4 <_vfiprintf_r+0xf0>
   1bbb2:	e39b      	b.n	1c2ec <_vfiprintf_r+0x828>
   1bbb4:	499f      	ldr	r1, [pc, #636]	; (1be34 <_vfiprintf_r+0x370>)
   1bbb6:	0092      	lsls	r2, r2, #2
   1bbb8:	588a      	ldr	r2, [r1, r2]
   1bbba:	4697      	mov	pc, r2
   1bbbc:	2a00      	cmp	r2, #0
   1bbbe:	d001      	beq.n	1bbc4 <_vfiprintf_r+0x100>
   1bbc0:	f000 fcf8 	bl	1c5b4 <_vfiprintf_r+0xaf0>
   1bbc4:	9212      	str	r2, [sp, #72]	; 0x48
   1bbc6:	4647      	mov	r7, r8
   1bbc8:	e7d0      	b.n	1bb6c <_vfiprintf_r+0xa8>
   1bbca:	4651      	mov	r1, sl
   1bbcc:	9804      	ldr	r0, [sp, #16]
   1bbce:	f7fb fcf7 	bl	175c0 <__swsetup_r>
   1bbd2:	2800      	cmp	r0, #0
   1bbd4:	d001      	beq.n	1bbda <_vfiprintf_r+0x116>
   1bbd6:	f000 fda5 	bl	1c724 <_vfiprintf_r+0xc60>
   1bbda:	4653      	mov	r3, sl
   1bbdc:	221a      	movs	r2, #26
   1bbde:	899b      	ldrh	r3, [r3, #12]
   1bbe0:	4013      	ands	r3, r2
   1bbe2:	2b0a      	cmp	r3, #10
   1bbe4:	d19d      	bne.n	1bb22 <_vfiprintf_r+0x5e>
   1bbe6:	4653      	mov	r3, sl
   1bbe8:	220e      	movs	r2, #14
   1bbea:	5e9b      	ldrsh	r3, [r3, r2]
   1bbec:	2b00      	cmp	r3, #0
   1bbee:	db98      	blt.n	1bb22 <_vfiprintf_r+0x5e>
   1bbf0:	0023      	movs	r3, r4
   1bbf2:	465a      	mov	r2, fp
   1bbf4:	4651      	mov	r1, sl
   1bbf6:	9804      	ldr	r0, [sp, #16]
   1bbf8:	f000 fe82 	bl	1c900 <__sbprintf>
   1bbfc:	b02f      	add	sp, #188	; 0xbc
   1bbfe:	bc3c      	pop	{r2, r3, r4, r5}
   1bc00:	4690      	mov	r8, r2
   1bc02:	4699      	mov	r9, r3
   1bc04:	46a2      	mov	sl, r4
   1bc06:	46ab      	mov	fp, r5
   1bc08:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1bc0a:	f7fc ff57 	bl	18abc <__sinit>
   1bc0e:	e76c      	b.n	1baea <_vfiprintf_r+0x26>
   1bc10:	9b09      	ldr	r3, [sp, #36]	; 0x24
   1bc12:	920a      	str	r2, [sp, #40]	; 0x28
   1bc14:	425b      	negs	r3, r3
   1bc16:	9309      	str	r3, [sp, #36]	; 0x24
   1bc18:	2304      	movs	r3, #4
   1bc1a:	9a01      	ldr	r2, [sp, #4]
   1bc1c:	431a      	orrs	r2, r3
   1bc1e:	9201      	str	r2, [sp, #4]
   1bc20:	782b      	ldrb	r3, [r5, #0]
   1bc22:	e7c1      	b.n	1bba8 <_vfiprintf_r+0xe4>
   1bc24:	2430      	movs	r4, #48	; 0x30
   1bc26:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1bc28:	aa10      	add	r2, sp, #64	; 0x40
   1bc2a:	7014      	strb	r4, [r2, #0]
   1bc2c:	1d18      	adds	r0, r3, #4
   1bc2e:	3448      	adds	r4, #72	; 0x48
   1bc30:	681b      	ldr	r3, [r3, #0]
   1bc32:	7054      	strb	r4, [r2, #1]
   1bc34:	9e01      	ldr	r6, [sp, #4]
   1bc36:	2200      	movs	r2, #0
   1bc38:	9306      	str	r3, [sp, #24]
   1bc3a:	2300      	movs	r3, #0
   1bc3c:	0031      	movs	r1, r6
   1bc3e:	ac0e      	add	r4, sp, #56	; 0x38
   1bc40:	71e2      	strb	r2, [r4, #7]
   1bc42:	9a03      	ldr	r2, [sp, #12]
   1bc44:	9307      	str	r3, [sp, #28]
   1bc46:	3302      	adds	r3, #2
   1bc48:	4319      	orrs	r1, r3
   1bc4a:	2a00      	cmp	r2, #0
   1bc4c:	da01      	bge.n	1bc52 <_vfiprintf_r+0x18e>
   1bc4e:	f000 fc61 	bl	1c514 <_vfiprintf_r+0xa50>
   1bc52:	2280      	movs	r2, #128	; 0x80
   1bc54:	0031      	movs	r1, r6
   1bc56:	4391      	bics	r1, r2
   1bc58:	000a      	movs	r2, r1
   1bc5a:	431a      	orrs	r2, r3
   1bc5c:	9b06      	ldr	r3, [sp, #24]
   1bc5e:	9201      	str	r2, [sp, #4]
   1bc60:	900a      	str	r0, [sp, #40]	; 0x28
   1bc62:	2b00      	cmp	r3, #0
   1bc64:	d001      	beq.n	1bc6a <_vfiprintf_r+0x1a6>
   1bc66:	f000 fcf8 	bl	1c65a <_vfiprintf_r+0xb96>
   1bc6a:	4b73      	ldr	r3, [pc, #460]	; (1be38 <_vfiprintf_r+0x374>)
   1bc6c:	9302      	str	r3, [sp, #8]
   1bc6e:	9b03      	ldr	r3, [sp, #12]
   1bc70:	2400      	movs	r4, #0
   1bc72:	2b00      	cmp	r3, #0
   1bc74:	d001      	beq.n	1bc7a <_vfiprintf_r+0x1b6>
   1bc76:	f000 fc57 	bl	1c528 <_vfiprintf_r+0xa64>
   1bc7a:	2300      	movs	r3, #0
   1bc7c:	4646      	mov	r6, r8
   1bc7e:	9303      	str	r3, [sp, #12]
   1bc80:	9308      	str	r3, [sp, #32]
   1bc82:	9b03      	ldr	r3, [sp, #12]
   1bc84:	9908      	ldr	r1, [sp, #32]
   1bc86:	9302      	str	r3, [sp, #8]
   1bc88:	428b      	cmp	r3, r1
   1bc8a:	da00      	bge.n	1bc8e <_vfiprintf_r+0x1ca>
   1bc8c:	9102      	str	r1, [sp, #8]
   1bc8e:	1e63      	subs	r3, r4, #1
   1bc90:	419c      	sbcs	r4, r3
   1bc92:	9b02      	ldr	r3, [sp, #8]
   1bc94:	469c      	mov	ip, r3
   1bc96:	44a4      	add	ip, r4
   1bc98:	4663      	mov	r3, ip
   1bc9a:	9302      	str	r3, [sp, #8]
   1bc9c:	2302      	movs	r3, #2
   1bc9e:	9a01      	ldr	r2, [sp, #4]
   1bca0:	401a      	ands	r2, r3
   1bca2:	920b      	str	r2, [sp, #44]	; 0x2c
   1bca4:	d002      	beq.n	1bcac <_vfiprintf_r+0x1e8>
   1bca6:	9b02      	ldr	r3, [sp, #8]
   1bca8:	3302      	adds	r3, #2
   1bcaa:	9302      	str	r3, [sp, #8]
   1bcac:	2384      	movs	r3, #132	; 0x84
   1bcae:	9a01      	ldr	r2, [sp, #4]
   1bcb0:	401a      	ands	r2, r3
   1bcb2:	920c      	str	r2, [sp, #48]	; 0x30
   1bcb4:	d000      	beq.n	1bcb8 <_vfiprintf_r+0x1f4>
   1bcb6:	e351      	b.n	1c35c <_vfiprintf_r+0x898>
   1bcb8:	9b09      	ldr	r3, [sp, #36]	; 0x24
   1bcba:	9a02      	ldr	r2, [sp, #8]
   1bcbc:	1a9c      	subs	r4, r3, r2
   1bcbe:	2c00      	cmp	r4, #0
   1bcc0:	dc00      	bgt.n	1bcc4 <_vfiprintf_r+0x200>
   1bcc2:	e34b      	b.n	1c35c <_vfiprintf_r+0x898>
   1bcc4:	9813      	ldr	r0, [sp, #76]	; 0x4c
   1bcc6:	2c10      	cmp	r4, #16
   1bcc8:	dc01      	bgt.n	1bcce <_vfiprintf_r+0x20a>
   1bcca:	f000 fd95 	bl	1c7f8 <_vfiprintf_r+0xd34>
   1bcce:	4b5b      	ldr	r3, [pc, #364]	; (1be3c <_vfiprintf_r+0x378>)
   1bcd0:	9912      	ldr	r1, [sp, #72]	; 0x48
   1bcd2:	4699      	mov	r9, r3
   1bcd4:	2310      	movs	r3, #16
   1bcd6:	469a      	mov	sl, r3
   1bcd8:	464b      	mov	r3, r9
   1bcda:	46a9      	mov	r9, r5
   1bcdc:	001d      	movs	r5, r3
   1bcde:	e005      	b.n	1bcec <_vfiprintf_r+0x228>
   1bce0:	1c8a      	adds	r2, r1, #2
   1bce2:	0019      	movs	r1, r3
   1bce4:	3708      	adds	r7, #8
   1bce6:	3c10      	subs	r4, #16
   1bce8:	2c10      	cmp	r4, #16
   1bcea:	dd11      	ble.n	1bd10 <_vfiprintf_r+0x24c>
   1bcec:	4653      	mov	r3, sl
   1bcee:	3010      	adds	r0, #16
   1bcf0:	607b      	str	r3, [r7, #4]
   1bcf2:	1c4b      	adds	r3, r1, #1
   1bcf4:	603d      	str	r5, [r7, #0]
   1bcf6:	9013      	str	r0, [sp, #76]	; 0x4c
   1bcf8:	9312      	str	r3, [sp, #72]	; 0x48
   1bcfa:	2b07      	cmp	r3, #7
   1bcfc:	ddf0      	ble.n	1bce0 <_vfiprintf_r+0x21c>
   1bcfe:	2800      	cmp	r0, #0
   1bd00:	d000      	beq.n	1bd04 <_vfiprintf_r+0x240>
   1bd02:	e31f      	b.n	1c344 <_vfiprintf_r+0x880>
   1bd04:	3c10      	subs	r4, #16
   1bd06:	2100      	movs	r1, #0
   1bd08:	2201      	movs	r2, #1
   1bd0a:	4647      	mov	r7, r8
   1bd0c:	2c10      	cmp	r4, #16
   1bd0e:	dced      	bgt.n	1bcec <_vfiprintf_r+0x228>
   1bd10:	002b      	movs	r3, r5
   1bd12:	464d      	mov	r5, r9
   1bd14:	4699      	mov	r9, r3
   1bd16:	464b      	mov	r3, r9
   1bd18:	1820      	adds	r0, r4, r0
   1bd1a:	603b      	str	r3, [r7, #0]
   1bd1c:	607c      	str	r4, [r7, #4]
   1bd1e:	9013      	str	r0, [sp, #76]	; 0x4c
   1bd20:	9212      	str	r2, [sp, #72]	; 0x48
   1bd22:	2a07      	cmp	r2, #7
   1bd24:	dd00      	ble.n	1bd28 <_vfiprintf_r+0x264>
   1bd26:	e3ca      	b.n	1c4be <_vfiprintf_r+0x9fa>
   1bd28:	ab0e      	add	r3, sp, #56	; 0x38
   1bd2a:	79db      	ldrb	r3, [r3, #7]
   1bd2c:	3708      	adds	r7, #8
   1bd2e:	1c51      	adds	r1, r2, #1
   1bd30:	2b00      	cmp	r3, #0
   1bd32:	d000      	beq.n	1bd36 <_vfiprintf_r+0x272>
   1bd34:	e31a      	b.n	1c36c <_vfiprintf_r+0x8a8>
   1bd36:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   1bd38:	2b00      	cmp	r3, #0
   1bd3a:	d100      	bne.n	1bd3e <_vfiprintf_r+0x27a>
   1bd3c:	e32b      	b.n	1c396 <_vfiprintf_r+0x8d2>
   1bd3e:	ab10      	add	r3, sp, #64	; 0x40
   1bd40:	603b      	str	r3, [r7, #0]
   1bd42:	2302      	movs	r3, #2
   1bd44:	3002      	adds	r0, #2
   1bd46:	607b      	str	r3, [r7, #4]
   1bd48:	9013      	str	r0, [sp, #76]	; 0x4c
   1bd4a:	9112      	str	r1, [sp, #72]	; 0x48
   1bd4c:	2907      	cmp	r1, #7
   1bd4e:	dc01      	bgt.n	1bd54 <_vfiprintf_r+0x290>
   1bd50:	f000 fbdc 	bl	1c50c <_vfiprintf_r+0xa48>
   1bd54:	2800      	cmp	r0, #0
   1bd56:	d001      	beq.n	1bd5c <_vfiprintf_r+0x298>
   1bd58:	f000 fc45 	bl	1c5e6 <_vfiprintf_r+0xb22>
   1bd5c:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   1bd5e:	2101      	movs	r1, #1
   1bd60:	2200      	movs	r2, #0
   1bd62:	4647      	mov	r7, r8
   1bd64:	2b80      	cmp	r3, #128	; 0x80
   1bd66:	d000      	beq.n	1bd6a <_vfiprintf_r+0x2a6>
   1bd68:	e319      	b.n	1c39e <_vfiprintf_r+0x8da>
   1bd6a:	9b09      	ldr	r3, [sp, #36]	; 0x24
   1bd6c:	9c02      	ldr	r4, [sp, #8]
   1bd6e:	1b1c      	subs	r4, r3, r4
   1bd70:	2c00      	cmp	r4, #0
   1bd72:	dc00      	bgt.n	1bd76 <_vfiprintf_r+0x2b2>
   1bd74:	e313      	b.n	1c39e <_vfiprintf_r+0x8da>
   1bd76:	2c10      	cmp	r4, #16
   1bd78:	dc01      	bgt.n	1bd7e <_vfiprintf_r+0x2ba>
   1bd7a:	f000 fd5e 	bl	1c83a <_vfiprintf_r+0xd76>
   1bd7e:	4b30      	ldr	r3, [pc, #192]	; (1be40 <_vfiprintf_r+0x37c>)
   1bd80:	4699      	mov	r9, r3
   1bd82:	2310      	movs	r3, #16
   1bd84:	469a      	mov	sl, r3
   1bd86:	464b      	mov	r3, r9
   1bd88:	46a9      	mov	r9, r5
   1bd8a:	001d      	movs	r5, r3
   1bd8c:	e005      	b.n	1bd9a <_vfiprintf_r+0x2d6>
   1bd8e:	1c91      	adds	r1, r2, #2
   1bd90:	001a      	movs	r2, r3
   1bd92:	3708      	adds	r7, #8
   1bd94:	3c10      	subs	r4, #16
   1bd96:	2c10      	cmp	r4, #16
   1bd98:	dd11      	ble.n	1bdbe <_vfiprintf_r+0x2fa>
   1bd9a:	4653      	mov	r3, sl
   1bd9c:	3010      	adds	r0, #16
   1bd9e:	607b      	str	r3, [r7, #4]
   1bda0:	1c53      	adds	r3, r2, #1
   1bda2:	603d      	str	r5, [r7, #0]
   1bda4:	9013      	str	r0, [sp, #76]	; 0x4c
   1bda6:	9312      	str	r3, [sp, #72]	; 0x48
   1bda8:	2b07      	cmp	r3, #7
   1bdaa:	ddf0      	ble.n	1bd8e <_vfiprintf_r+0x2ca>
   1bdac:	2800      	cmp	r0, #0
   1bdae:	d000      	beq.n	1bdb2 <_vfiprintf_r+0x2ee>
   1bdb0:	e379      	b.n	1c4a6 <_vfiprintf_r+0x9e2>
   1bdb2:	3c10      	subs	r4, #16
   1bdb4:	2101      	movs	r1, #1
   1bdb6:	2200      	movs	r2, #0
   1bdb8:	4647      	mov	r7, r8
   1bdba:	2c10      	cmp	r4, #16
   1bdbc:	dced      	bgt.n	1bd9a <_vfiprintf_r+0x2d6>
   1bdbe:	002b      	movs	r3, r5
   1bdc0:	468c      	mov	ip, r1
   1bdc2:	464d      	mov	r5, r9
   1bdc4:	4699      	mov	r9, r3
   1bdc6:	464b      	mov	r3, r9
   1bdc8:	603b      	str	r3, [r7, #0]
   1bdca:	4663      	mov	r3, ip
   1bdcc:	1900      	adds	r0, r0, r4
   1bdce:	607c      	str	r4, [r7, #4]
   1bdd0:	9013      	str	r0, [sp, #76]	; 0x4c
   1bdd2:	9312      	str	r3, [sp, #72]	; 0x48
   1bdd4:	2b07      	cmp	r3, #7
   1bdd6:	dd01      	ble.n	1bddc <_vfiprintf_r+0x318>
   1bdd8:	f000 fc12 	bl	1c600 <_vfiprintf_r+0xb3c>
   1bddc:	1c59      	adds	r1, r3, #1
   1bdde:	9c08      	ldr	r4, [sp, #32]
   1bde0:	9b03      	ldr	r3, [sp, #12]
   1bde2:	3708      	adds	r7, #8
   1bde4:	4662      	mov	r2, ip
   1bde6:	1b1c      	subs	r4, r3, r4
   1bde8:	2c00      	cmp	r4, #0
   1bdea:	dd00      	ble.n	1bdee <_vfiprintf_r+0x32a>
   1bdec:	e2dd      	b.n	1c3aa <_vfiprintf_r+0x8e6>
   1bdee:	9b08      	ldr	r3, [sp, #32]
   1bdf0:	603e      	str	r6, [r7, #0]
   1bdf2:	469c      	mov	ip, r3
   1bdf4:	4460      	add	r0, ip
   1bdf6:	607b      	str	r3, [r7, #4]
   1bdf8:	9013      	str	r0, [sp, #76]	; 0x4c
   1bdfa:	9112      	str	r1, [sp, #72]	; 0x48
   1bdfc:	2907      	cmp	r1, #7
   1bdfe:	dc00      	bgt.n	1be02 <_vfiprintf_r+0x33e>
   1be00:	e335      	b.n	1c46e <_vfiprintf_r+0x9aa>
   1be02:	2800      	cmp	r0, #0
   1be04:	d000      	beq.n	1be08 <_vfiprintf_r+0x344>
   1be06:	e3b4      	b.n	1c572 <_vfiprintf_r+0xaae>
   1be08:	9b01      	ldr	r3, [sp, #4]
   1be0a:	9012      	str	r0, [sp, #72]	; 0x48
   1be0c:	075b      	lsls	r3, r3, #29
   1be0e:	d53d      	bpl.n	1be8c <_vfiprintf_r+0x3c8>
   1be10:	9b09      	ldr	r3, [sp, #36]	; 0x24
   1be12:	9a02      	ldr	r2, [sp, #8]
   1be14:	1a9e      	subs	r6, r3, r2
   1be16:	4643      	mov	r3, r8
   1be18:	2e00      	cmp	r6, #0
   1be1a:	dd37      	ble.n	1be8c <_vfiprintf_r+0x3c8>
   1be1c:	2e10      	cmp	r6, #16
   1be1e:	dc01      	bgt.n	1be24 <_vfiprintf_r+0x360>
   1be20:	f000 fd04 	bl	1c82c <_vfiprintf_r+0xd68>
   1be24:	4a05      	ldr	r2, [pc, #20]	; (1be3c <_vfiprintf_r+0x378>)
   1be26:	9912      	ldr	r1, [sp, #72]	; 0x48
   1be28:	4691      	mov	r9, r2
   1be2a:	2710      	movs	r7, #16
   1be2c:	e010      	b.n	1be50 <_vfiprintf_r+0x38c>
   1be2e:	46c0      	nop			; (mov r8, r8)
   1be30:	ffffdfff 	.word	0xffffdfff
   1be34:	0002304c 	.word	0x0002304c
   1be38:	00022d5c 	.word	0x00022d5c
   1be3c:	000231c0 	.word	0x000231c0
   1be40:	000231b0 	.word	0x000231b0
   1be44:	1c8c      	adds	r4, r1, #2
   1be46:	0011      	movs	r1, r2
   1be48:	3308      	adds	r3, #8
   1be4a:	3e10      	subs	r6, #16
   1be4c:	2e10      	cmp	r6, #16
   1be4e:	dd11      	ble.n	1be74 <_vfiprintf_r+0x3b0>
   1be50:	4ad7      	ldr	r2, [pc, #860]	; (1c1b0 <_vfiprintf_r+0x6ec>)
   1be52:	3010      	adds	r0, #16
   1be54:	601a      	str	r2, [r3, #0]
   1be56:	1c4a      	adds	r2, r1, #1
   1be58:	605f      	str	r7, [r3, #4]
   1be5a:	9013      	str	r0, [sp, #76]	; 0x4c
   1be5c:	9212      	str	r2, [sp, #72]	; 0x48
   1be5e:	2a07      	cmp	r2, #7
   1be60:	ddf0      	ble.n	1be44 <_vfiprintf_r+0x380>
   1be62:	2800      	cmp	r0, #0
   1be64:	d000      	beq.n	1be68 <_vfiprintf_r+0x3a4>
   1be66:	e2eb      	b.n	1c440 <_vfiprintf_r+0x97c>
   1be68:	3e10      	subs	r6, #16
   1be6a:	2401      	movs	r4, #1
   1be6c:	2100      	movs	r1, #0
   1be6e:	4643      	mov	r3, r8
   1be70:	2e10      	cmp	r6, #16
   1be72:	dced      	bgt.n	1be50 <_vfiprintf_r+0x38c>
   1be74:	464a      	mov	r2, r9
   1be76:	1980      	adds	r0, r0, r6
   1be78:	c344      	stmia	r3!, {r2, r6}
   1be7a:	9013      	str	r0, [sp, #76]	; 0x4c
   1be7c:	9412      	str	r4, [sp, #72]	; 0x48
   1be7e:	2c07      	cmp	r4, #7
   1be80:	dc00      	bgt.n	1be84 <_vfiprintf_r+0x3c0>
   1be82:	e2ff      	b.n	1c484 <_vfiprintf_r+0x9c0>
   1be84:	2800      	cmp	r0, #0
   1be86:	d001      	beq.n	1be8c <_vfiprintf_r+0x3c8>
   1be88:	f000 fc52 	bl	1c730 <_vfiprintf_r+0xc6c>
   1be8c:	9b09      	ldr	r3, [sp, #36]	; 0x24
   1be8e:	9902      	ldr	r1, [sp, #8]
   1be90:	428b      	cmp	r3, r1
   1be92:	da00      	bge.n	1be96 <_vfiprintf_r+0x3d2>
   1be94:	000b      	movs	r3, r1
   1be96:	9a05      	ldr	r2, [sp, #20]
   1be98:	4694      	mov	ip, r2
   1be9a:	449c      	add	ip, r3
   1be9c:	4663      	mov	r3, ip
   1be9e:	9305      	str	r3, [sp, #20]
   1bea0:	e2fc      	b.n	1c49c <_vfiprintf_r+0x9d8>
   1bea2:	464a      	mov	r2, r9
   1bea4:	9b01      	ldr	r3, [sp, #4]
   1bea6:	4313      	orrs	r3, r2
   1bea8:	9301      	str	r3, [sp, #4]
   1beaa:	782b      	ldrb	r3, [r5, #0]
   1beac:	e67c      	b.n	1bba8 <_vfiprintf_r+0xe4>
   1beae:	2800      	cmp	r0, #0
   1beb0:	d001      	beq.n	1beb6 <_vfiprintf_r+0x3f2>
   1beb2:	f000 fd0c 	bl	1c8ce <_vfiprintf_r+0xe0a>
   1beb6:	2310      	movs	r3, #16
   1beb8:	9a01      	ldr	r2, [sp, #4]
   1beba:	431a      	orrs	r2, r3
   1bebc:	9201      	str	r2, [sp, #4]
   1bebe:	9b01      	ldr	r3, [sp, #4]
   1bec0:	069b      	lsls	r3, r3, #26
   1bec2:	d400      	bmi.n	1bec6 <_vfiprintf_r+0x402>
   1bec4:	e360      	b.n	1c588 <_vfiprintf_r+0xac4>
   1bec6:	2307      	movs	r3, #7
   1bec8:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   1beca:	3207      	adds	r2, #7
   1becc:	439a      	bics	r2, r3
   1bece:	3301      	adds	r3, #1
   1bed0:	469c      	mov	ip, r3
   1bed2:	4494      	add	ip, r2
   1bed4:	4663      	mov	r3, ip
   1bed6:	930a      	str	r3, [sp, #40]	; 0x28
   1bed8:	6853      	ldr	r3, [r2, #4]
   1beda:	6812      	ldr	r2, [r2, #0]
   1bedc:	9307      	str	r3, [sp, #28]
   1bede:	9206      	str	r2, [sp, #24]
   1bee0:	2b00      	cmp	r3, #0
   1bee2:	da00      	bge.n	1bee6 <_vfiprintf_r+0x422>
   1bee4:	e3bf      	b.n	1c666 <_vfiprintf_r+0xba2>
   1bee6:	ab0e      	add	r3, sp, #56	; 0x38
   1bee8:	79dc      	ldrb	r4, [r3, #7]
   1beea:	9b03      	ldr	r3, [sp, #12]
   1beec:	2b00      	cmp	r3, #0
   1beee:	da00      	bge.n	1bef2 <_vfiprintf_r+0x42e>
   1bef0:	e359      	b.n	1c5a6 <_vfiprintf_r+0xae2>
   1bef2:	2380      	movs	r3, #128	; 0x80
   1bef4:	9a01      	ldr	r2, [sp, #4]
   1bef6:	439a      	bics	r2, r3
   1bef8:	9201      	str	r2, [sp, #4]
   1befa:	9a06      	ldr	r2, [sp, #24]
   1befc:	9b07      	ldr	r3, [sp, #28]
   1befe:	0011      	movs	r1, r2
   1bf00:	4319      	orrs	r1, r3
   1bf02:	d100      	bne.n	1bf06 <_vfiprintf_r+0x442>
   1bf04:	e10e      	b.n	1c124 <_vfiprintf_r+0x660>
   1bf06:	9b07      	ldr	r3, [sp, #28]
   1bf08:	2b00      	cmp	r3, #0
   1bf0a:	d101      	bne.n	1bf10 <_vfiprintf_r+0x44c>
   1bf0c:	f000 fc6e 	bl	1c7ec <_vfiprintf_r+0xd28>
   1bf10:	4646      	mov	r6, r8
   1bf12:	46a1      	mov	r9, r4
   1bf14:	46aa      	mov	sl, r5
   1bf16:	9c06      	ldr	r4, [sp, #24]
   1bf18:	9d07      	ldr	r5, [sp, #28]
   1bf1a:	0020      	movs	r0, r4
   1bf1c:	0029      	movs	r1, r5
   1bf1e:	220a      	movs	r2, #10
   1bf20:	2300      	movs	r3, #0
   1bf22:	f001 ffb3 	bl	1de8c <__aeabi_uldivmod>
   1bf26:	3e01      	subs	r6, #1
   1bf28:	3230      	adds	r2, #48	; 0x30
   1bf2a:	7032      	strb	r2, [r6, #0]
   1bf2c:	2300      	movs	r3, #0
   1bf2e:	0020      	movs	r0, r4
   1bf30:	0029      	movs	r1, r5
   1bf32:	220a      	movs	r2, #10
   1bf34:	f001 ffaa 	bl	1de8c <__aeabi_uldivmod>
   1bf38:	0003      	movs	r3, r0
   1bf3a:	0004      	movs	r4, r0
   1bf3c:	000d      	movs	r5, r1
   1bf3e:	430b      	orrs	r3, r1
   1bf40:	d1eb      	bne.n	1bf1a <_vfiprintf_r+0x456>
   1bf42:	4643      	mov	r3, r8
   1bf44:	1b9b      	subs	r3, r3, r6
   1bf46:	9406      	str	r4, [sp, #24]
   1bf48:	9507      	str	r5, [sp, #28]
   1bf4a:	9308      	str	r3, [sp, #32]
   1bf4c:	464c      	mov	r4, r9
   1bf4e:	4655      	mov	r5, sl
   1bf50:	e697      	b.n	1bc82 <_vfiprintf_r+0x1be>
   1bf52:	2800      	cmp	r0, #0
   1bf54:	d001      	beq.n	1bf5a <_vfiprintf_r+0x496>
   1bf56:	f000 fcb6 	bl	1c8c6 <_vfiprintf_r+0xe02>
   1bf5a:	2310      	movs	r3, #16
   1bf5c:	9a01      	ldr	r2, [sp, #4]
   1bf5e:	431a      	orrs	r2, r3
   1bf60:	9201      	str	r2, [sp, #4]
   1bf62:	2320      	movs	r3, #32
   1bf64:	9a01      	ldr	r2, [sp, #4]
   1bf66:	4013      	ands	r3, r2
   1bf68:	d100      	bne.n	1bf6c <_vfiprintf_r+0x4a8>
   1bf6a:	e1ce      	b.n	1c30a <_vfiprintf_r+0x846>
   1bf6c:	2207      	movs	r2, #7
   1bf6e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1bf70:	3307      	adds	r3, #7
   1bf72:	4393      	bics	r3, r2
   1bf74:	3201      	adds	r2, #1
   1bf76:	4694      	mov	ip, r2
   1bf78:	449c      	add	ip, r3
   1bf7a:	4662      	mov	r2, ip
   1bf7c:	685c      	ldr	r4, [r3, #4]
   1bf7e:	681b      	ldr	r3, [r3, #0]
   1bf80:	9306      	str	r3, [sp, #24]
   1bf82:	9407      	str	r4, [sp, #28]
   1bf84:	2300      	movs	r3, #0
   1bf86:	920a      	str	r2, [sp, #40]	; 0x28
   1bf88:	aa0e      	add	r2, sp, #56	; 0x38
   1bf8a:	71d3      	strb	r3, [r2, #7]
   1bf8c:	9b03      	ldr	r3, [sp, #12]
   1bf8e:	2b00      	cmp	r3, #0
   1bf90:	da01      	bge.n	1bf96 <_vfiprintf_r+0x4d2>
   1bf92:	f000 fbfc 	bl	1c78e <_vfiprintf_r+0xcca>
   1bf96:	2380      	movs	r3, #128	; 0x80
   1bf98:	9a01      	ldr	r2, [sp, #4]
   1bf9a:	439a      	bics	r2, r3
   1bf9c:	9201      	str	r2, [sp, #4]
   1bf9e:	9a06      	ldr	r2, [sp, #24]
   1bfa0:	9b07      	ldr	r3, [sp, #28]
   1bfa2:	0011      	movs	r1, r2
   1bfa4:	4319      	orrs	r1, r3
   1bfa6:	d000      	beq.n	1bfaa <_vfiprintf_r+0x4e6>
   1bfa8:	e1ca      	b.n	1c340 <_vfiprintf_r+0x87c>
   1bfaa:	9b03      	ldr	r3, [sp, #12]
   1bfac:	2400      	movs	r4, #0
   1bfae:	2b00      	cmp	r3, #0
   1bfb0:	d101      	bne.n	1bfb6 <_vfiprintf_r+0x4f2>
   1bfb2:	f000 fc69 	bl	1c888 <_vfiprintf_r+0xdc4>
   1bfb6:	2200      	movs	r2, #0
   1bfb8:	2300      	movs	r3, #0
   1bfba:	9206      	str	r2, [sp, #24]
   1bfbc:	9307      	str	r3, [sp, #28]
   1bfbe:	9a06      	ldr	r2, [sp, #24]
   1bfc0:	9b07      	ldr	r3, [sp, #28]
   1bfc2:	4646      	mov	r6, r8
   1bfc4:	2007      	movs	r0, #7
   1bfc6:	46ba      	mov	sl, r7
   1bfc8:	46a4      	mov	ip, r4
   1bfca:	46a9      	mov	r9, r5
   1bfcc:	075f      	lsls	r7, r3, #29
   1bfce:	08d5      	lsrs	r5, r2, #3
   1bfd0:	0001      	movs	r1, r0
   1bfd2:	08dc      	lsrs	r4, r3, #3
   1bfd4:	432f      	orrs	r7, r5
   1bfd6:	0023      	movs	r3, r4
   1bfd8:	003c      	movs	r4, r7
   1bfda:	4011      	ands	r1, r2
   1bfdc:	3e01      	subs	r6, #1
   1bfde:	3130      	adds	r1, #48	; 0x30
   1bfe0:	7031      	strb	r1, [r6, #0]
   1bfe2:	003a      	movs	r2, r7
   1bfe4:	431c      	orrs	r4, r3
   1bfe6:	d1f1      	bne.n	1bfcc <_vfiprintf_r+0x508>
   1bfe8:	9206      	str	r2, [sp, #24]
   1bfea:	9307      	str	r3, [sp, #28]
   1bfec:	9a01      	ldr	r2, [sp, #4]
   1bfee:	4657      	mov	r7, sl
   1bff0:	4664      	mov	r4, ip
   1bff2:	464d      	mov	r5, r9
   1bff4:	07d2      	lsls	r2, r2, #31
   1bff6:	d400      	bmi.n	1bffa <_vfiprintf_r+0x536>
   1bff8:	e0a5      	b.n	1c146 <_vfiprintf_r+0x682>
   1bffa:	2930      	cmp	r1, #48	; 0x30
   1bffc:	d100      	bne.n	1c000 <_vfiprintf_r+0x53c>
   1bffe:	e0a2      	b.n	1c146 <_vfiprintf_r+0x682>
   1c000:	2330      	movs	r3, #48	; 0x30
   1c002:	3e01      	subs	r6, #1
   1c004:	7033      	strb	r3, [r6, #0]
   1c006:	4643      	mov	r3, r8
   1c008:	1b9b      	subs	r3, r3, r6
   1c00a:	9308      	str	r3, [sp, #32]
   1c00c:	e639      	b.n	1bc82 <_vfiprintf_r+0x1be>
   1c00e:	2200      	movs	r2, #0
   1c010:	0019      	movs	r1, r3
   1c012:	0013      	movs	r3, r2
   1c014:	3930      	subs	r1, #48	; 0x30
   1c016:	009a      	lsls	r2, r3, #2
   1c018:	3501      	adds	r5, #1
   1c01a:	18d3      	adds	r3, r2, r3
   1c01c:	1e6a      	subs	r2, r5, #1
   1c01e:	7812      	ldrb	r2, [r2, #0]
   1c020:	005b      	lsls	r3, r3, #1
   1c022:	18cb      	adds	r3, r1, r3
   1c024:	0011      	movs	r1, r2
   1c026:	3930      	subs	r1, #48	; 0x30
   1c028:	2909      	cmp	r1, #9
   1c02a:	d9f4      	bls.n	1c016 <_vfiprintf_r+0x552>
   1c02c:	9309      	str	r3, [sp, #36]	; 0x24
   1c02e:	0013      	movs	r3, r2
   1c030:	e5bb      	b.n	1bbaa <_vfiprintf_r+0xe6>
   1c032:	782b      	ldrb	r3, [r5, #0]
   1c034:	2001      	movs	r0, #1
   1c036:	262b      	movs	r6, #43	; 0x2b
   1c038:	e5b6      	b.n	1bba8 <_vfiprintf_r+0xe4>
   1c03a:	1c6b      	adds	r3, r5, #1
   1c03c:	9302      	str	r3, [sp, #8]
   1c03e:	782b      	ldrb	r3, [r5, #0]
   1c040:	2b2a      	cmp	r3, #42	; 0x2a
   1c042:	d101      	bne.n	1c048 <_vfiprintf_r+0x584>
   1c044:	f000 fc0d 	bl	1c862 <_vfiprintf_r+0xd9e>
   1c048:	0019      	movs	r1, r3
   1c04a:	3930      	subs	r1, #48	; 0x30
   1c04c:	2200      	movs	r2, #0
   1c04e:	9d02      	ldr	r5, [sp, #8]
   1c050:	2909      	cmp	r1, #9
   1c052:	d80d      	bhi.n	1c070 <_vfiprintf_r+0x5ac>
   1c054:	0093      	lsls	r3, r2, #2
   1c056:	3501      	adds	r5, #1
   1c058:	189a      	adds	r2, r3, r2
   1c05a:	1e6b      	subs	r3, r5, #1
   1c05c:	781b      	ldrb	r3, [r3, #0]
   1c05e:	0052      	lsls	r2, r2, #1
   1c060:	1852      	adds	r2, r2, r1
   1c062:	0019      	movs	r1, r3
   1c064:	3930      	subs	r1, #48	; 0x30
   1c066:	2909      	cmp	r1, #9
   1c068:	d9f4      	bls.n	1c054 <_vfiprintf_r+0x590>
   1c06a:	2a00      	cmp	r2, #0
   1c06c:	da00      	bge.n	1c070 <_vfiprintf_r+0x5ac>
   1c06e:	e388      	b.n	1c782 <_vfiprintf_r+0xcbe>
   1c070:	9203      	str	r2, [sp, #12]
   1c072:	e59a      	b.n	1bbaa <_vfiprintf_r+0xe6>
   1c074:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1c076:	1d1a      	adds	r2, r3, #4
   1c078:	681b      	ldr	r3, [r3, #0]
   1c07a:	9309      	str	r3, [sp, #36]	; 0x24
   1c07c:	2b00      	cmp	r3, #0
   1c07e:	da00      	bge.n	1c082 <_vfiprintf_r+0x5be>
   1c080:	e5c6      	b.n	1bc10 <_vfiprintf_r+0x14c>
   1c082:	782b      	ldrb	r3, [r5, #0]
   1c084:	920a      	str	r2, [sp, #40]	; 0x28
   1c086:	e58f      	b.n	1bba8 <_vfiprintf_r+0xe4>
   1c088:	2800      	cmp	r0, #0
   1c08a:	d100      	bne.n	1c08e <_vfiprintf_r+0x5ca>
   1c08c:	e769      	b.n	1bf62 <_vfiprintf_r+0x49e>
   1c08e:	ab0e      	add	r3, sp, #56	; 0x38
   1c090:	71de      	strb	r6, [r3, #7]
   1c092:	e766      	b.n	1bf62 <_vfiprintf_r+0x49e>
   1c094:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1c096:	1d1a      	adds	r2, r3, #4
   1c098:	681e      	ldr	r6, [r3, #0]
   1c09a:	2300      	movs	r3, #0
   1c09c:	4691      	mov	r9, r2
   1c09e:	aa0e      	add	r2, sp, #56	; 0x38
   1c0a0:	71d3      	strb	r3, [r2, #7]
   1c0a2:	2e00      	cmp	r6, #0
   1c0a4:	d100      	bne.n	1c0a8 <_vfiprintf_r+0x5e4>
   1c0a6:	e3b1      	b.n	1c80c <_vfiprintf_r+0xd48>
   1c0a8:	9b03      	ldr	r3, [sp, #12]
   1c0aa:	2b00      	cmp	r3, #0
   1c0ac:	da00      	bge.n	1c0b0 <_vfiprintf_r+0x5ec>
   1c0ae:	e38b      	b.n	1c7c8 <_vfiprintf_r+0xd04>
   1c0b0:	001a      	movs	r2, r3
   1c0b2:	2100      	movs	r1, #0
   1c0b4:	0030      	movs	r0, r6
   1c0b6:	f7fd f8c3 	bl	19240 <memchr>
   1c0ba:	2800      	cmp	r0, #0
   1c0bc:	d100      	bne.n	1c0c0 <_vfiprintf_r+0x5fc>
   1c0be:	e3c1      	b.n	1c844 <_vfiprintf_r+0xd80>
   1c0c0:	1b83      	subs	r3, r0, r6
   1c0c2:	9308      	str	r3, [sp, #32]
   1c0c4:	ab0e      	add	r3, sp, #56	; 0x38
   1c0c6:	79dc      	ldrb	r4, [r3, #7]
   1c0c8:	464b      	mov	r3, r9
   1c0ca:	930a      	str	r3, [sp, #40]	; 0x28
   1c0cc:	2300      	movs	r3, #0
   1c0ce:	9303      	str	r3, [sp, #12]
   1c0d0:	e5d7      	b.n	1bc82 <_vfiprintf_r+0x1be>
   1c0d2:	2800      	cmp	r0, #0
   1c0d4:	d001      	beq.n	1c0da <_vfiprintf_r+0x616>
   1c0d6:	f000 fbf2 	bl	1c8be <_vfiprintf_r+0xdfa>
   1c0da:	2320      	movs	r3, #32
   1c0dc:	9a01      	ldr	r2, [sp, #4]
   1c0de:	4013      	ands	r3, r2
   1c0e0:	d145      	bne.n	1c16e <_vfiprintf_r+0x6aa>
   1c0e2:	2210      	movs	r2, #16
   1c0e4:	9901      	ldr	r1, [sp, #4]
   1c0e6:	400a      	ands	r2, r1
   1c0e8:	d000      	beq.n	1c0ec <_vfiprintf_r+0x628>
   1c0ea:	e2ba      	b.n	1c662 <_vfiprintf_r+0xb9e>
   1c0ec:	2340      	movs	r3, #64	; 0x40
   1c0ee:	9901      	ldr	r1, [sp, #4]
   1c0f0:	400b      	ands	r3, r1
   1c0f2:	990a      	ldr	r1, [sp, #40]	; 0x28
   1c0f4:	d000      	beq.n	1c0f8 <_vfiprintf_r+0x634>
   1c0f6:	e325      	b.n	1c744 <_vfiprintf_r+0xc80>
   1c0f8:	000a      	movs	r2, r1
   1c0fa:	6809      	ldr	r1, [r1, #0]
   1c0fc:	3204      	adds	r2, #4
   1c0fe:	9106      	str	r1, [sp, #24]
   1c100:	2100      	movs	r1, #0
   1c102:	9107      	str	r1, [sp, #28]
   1c104:	a90e      	add	r1, sp, #56	; 0x38
   1c106:	71cb      	strb	r3, [r1, #7]
   1c108:	9b03      	ldr	r3, [sp, #12]
   1c10a:	2b00      	cmp	r3, #0
   1c10c:	da00      	bge.n	1c110 <_vfiprintf_r+0x64c>
   1c10e:	e248      	b.n	1c5a2 <_vfiprintf_r+0xade>
   1c110:	2380      	movs	r3, #128	; 0x80
   1c112:	9901      	ldr	r1, [sp, #4]
   1c114:	920a      	str	r2, [sp, #40]	; 0x28
   1c116:	4399      	bics	r1, r3
   1c118:	9b06      	ldr	r3, [sp, #24]
   1c11a:	9101      	str	r1, [sp, #4]
   1c11c:	2400      	movs	r4, #0
   1c11e:	2b00      	cmp	r3, #0
   1c120:	d000      	beq.n	1c124 <_vfiprintf_r+0x660>
   1c122:	e6f0      	b.n	1bf06 <_vfiprintf_r+0x442>
   1c124:	9b03      	ldr	r3, [sp, #12]
   1c126:	2b00      	cmp	r3, #0
   1c128:	d100      	bne.n	1c12c <_vfiprintf_r+0x668>
   1c12a:	e5a6      	b.n	1bc7a <_vfiprintf_r+0x1b6>
   1c12c:	2200      	movs	r2, #0
   1c12e:	2300      	movs	r3, #0
   1c130:	9206      	str	r2, [sp, #24]
   1c132:	9307      	str	r3, [sp, #28]
   1c134:	2227      	movs	r2, #39	; 0x27
   1c136:	9b06      	ldr	r3, [sp, #24]
   1c138:	a914      	add	r1, sp, #80	; 0x50
   1c13a:	3330      	adds	r3, #48	; 0x30
   1c13c:	548b      	strb	r3, [r1, r2]
   1c13e:	ab0e      	add	r3, sp, #56	; 0x38
   1c140:	263f      	movs	r6, #63	; 0x3f
   1c142:	469c      	mov	ip, r3
   1c144:	4466      	add	r6, ip
   1c146:	4643      	mov	r3, r8
   1c148:	1b9b      	subs	r3, r3, r6
   1c14a:	9308      	str	r3, [sp, #32]
   1c14c:	e599      	b.n	1bc82 <_vfiprintf_r+0x1be>
   1c14e:	9b01      	ldr	r3, [sp, #4]
   1c150:	4323      	orrs	r3, r4
   1c152:	9301      	str	r3, [sp, #4]
   1c154:	782b      	ldrb	r3, [r5, #0]
   1c156:	e527      	b.n	1bba8 <_vfiprintf_r+0xe4>
   1c158:	2800      	cmp	r0, #0
   1c15a:	d000      	beq.n	1c15e <_vfiprintf_r+0x69a>
   1c15c:	e3ac      	b.n	1c8b8 <_vfiprintf_r+0xdf4>
   1c15e:	2310      	movs	r3, #16
   1c160:	9a01      	ldr	r2, [sp, #4]
   1c162:	431a      	orrs	r2, r3
   1c164:	2320      	movs	r3, #32
   1c166:	9201      	str	r2, [sp, #4]
   1c168:	9a01      	ldr	r2, [sp, #4]
   1c16a:	4013      	ands	r3, r2
   1c16c:	d0b9      	beq.n	1c0e2 <_vfiprintf_r+0x61e>
   1c16e:	2207      	movs	r2, #7
   1c170:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1c172:	3307      	adds	r3, #7
   1c174:	4393      	bics	r3, r2
   1c176:	3201      	adds	r2, #1
   1c178:	4694      	mov	ip, r2
   1c17a:	449c      	add	ip, r3
   1c17c:	4662      	mov	r2, ip
   1c17e:	685c      	ldr	r4, [r3, #4]
   1c180:	681b      	ldr	r3, [r3, #0]
   1c182:	9306      	str	r3, [sp, #24]
   1c184:	9407      	str	r4, [sp, #28]
   1c186:	2300      	movs	r3, #0
   1c188:	920a      	str	r2, [sp, #40]	; 0x28
   1c18a:	aa0e      	add	r2, sp, #56	; 0x38
   1c18c:	71d3      	strb	r3, [r2, #7]
   1c18e:	9b03      	ldr	r3, [sp, #12]
   1c190:	2b00      	cmp	r3, #0
   1c192:	da00      	bge.n	1c196 <_vfiprintf_r+0x6d2>
   1c194:	e206      	b.n	1c5a4 <_vfiprintf_r+0xae0>
   1c196:	2380      	movs	r3, #128	; 0x80
   1c198:	9a01      	ldr	r2, [sp, #4]
   1c19a:	2400      	movs	r4, #0
   1c19c:	439a      	bics	r2, r3
   1c19e:	9201      	str	r2, [sp, #4]
   1c1a0:	9a06      	ldr	r2, [sp, #24]
   1c1a2:	9b07      	ldr	r3, [sp, #28]
   1c1a4:	0011      	movs	r1, r2
   1c1a6:	4319      	orrs	r1, r3
   1c1a8:	d000      	beq.n	1c1ac <_vfiprintf_r+0x6e8>
   1c1aa:	e6ac      	b.n	1bf06 <_vfiprintf_r+0x442>
   1c1ac:	e7ba      	b.n	1c124 <_vfiprintf_r+0x660>
   1c1ae:	46c0      	nop			; (mov r8, r8)
   1c1b0:	000231c0 	.word	0x000231c0
   1c1b4:	2800      	cmp	r0, #0
   1c1b6:	d000      	beq.n	1c1ba <_vfiprintf_r+0x6f6>
   1c1b8:	e393      	b.n	1c8e2 <_vfiprintf_r+0xe1e>
   1c1ba:	4acb      	ldr	r2, [pc, #812]	; (1c4e8 <_vfiprintf_r+0xa24>)
   1c1bc:	9202      	str	r2, [sp, #8]
   1c1be:	9a01      	ldr	r2, [sp, #4]
   1c1c0:	0692      	lsls	r2, r2, #26
   1c1c2:	d549      	bpl.n	1c258 <_vfiprintf_r+0x794>
   1c1c4:	2108      	movs	r1, #8
   1c1c6:	2007      	movs	r0, #7
   1c1c8:	468c      	mov	ip, r1
   1c1ca:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   1c1cc:	3207      	adds	r2, #7
   1c1ce:	4382      	bics	r2, r0
   1c1d0:	4494      	add	ip, r2
   1c1d2:	4661      	mov	r1, ip
   1c1d4:	910a      	str	r1, [sp, #40]	; 0x28
   1c1d6:	6811      	ldr	r1, [r2, #0]
   1c1d8:	6852      	ldr	r2, [r2, #4]
   1c1da:	9106      	str	r1, [sp, #24]
   1c1dc:	9207      	str	r2, [sp, #28]
   1c1de:	2201      	movs	r2, #1
   1c1e0:	9901      	ldr	r1, [sp, #4]
   1c1e2:	400a      	ands	r2, r1
   1c1e4:	d04a      	beq.n	1c27c <_vfiprintf_r+0x7b8>
   1c1e6:	9906      	ldr	r1, [sp, #24]
   1c1e8:	9a07      	ldr	r2, [sp, #28]
   1c1ea:	0008      	movs	r0, r1
   1c1ec:	4310      	orrs	r0, r2
   1c1ee:	d000      	beq.n	1c1f2 <_vfiprintf_r+0x72e>
   1c1f0:	e21c      	b.n	1c62c <_vfiprintf_r+0xb68>
   1c1f2:	ab0e      	add	r3, sp, #56	; 0x38
   1c1f4:	71d8      	strb	r0, [r3, #7]
   1c1f6:	9b03      	ldr	r3, [sp, #12]
   1c1f8:	2b00      	cmp	r3, #0
   1c1fa:	da00      	bge.n	1c1fe <_vfiprintf_r+0x73a>
   1c1fc:	e194      	b.n	1c528 <_vfiprintf_r+0xa64>
   1c1fe:	2380      	movs	r3, #128	; 0x80
   1c200:	9a01      	ldr	r2, [sp, #4]
   1c202:	439a      	bics	r2, r3
   1c204:	9201      	str	r2, [sp, #4]
   1c206:	e532      	b.n	1bc6e <_vfiprintf_r+0x1aa>
   1c208:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   1c20a:	ae14      	add	r6, sp, #80	; 0x50
   1c20c:	6813      	ldr	r3, [r2, #0]
   1c20e:	a90e      	add	r1, sp, #56	; 0x38
   1c210:	9302      	str	r3, [sp, #8]
   1c212:	466b      	mov	r3, sp
   1c214:	7a1b      	ldrb	r3, [r3, #8]
   1c216:	7033      	strb	r3, [r6, #0]
   1c218:	2300      	movs	r3, #0
   1c21a:	71cb      	strb	r3, [r1, #7]
   1c21c:	0013      	movs	r3, r2
   1c21e:	3304      	adds	r3, #4
   1c220:	930a      	str	r3, [sp, #40]	; 0x28
   1c222:	2301      	movs	r3, #1
   1c224:	9302      	str	r3, [sp, #8]
   1c226:	9308      	str	r3, [sp, #32]
   1c228:	2300      	movs	r3, #0
   1c22a:	9303      	str	r3, [sp, #12]
   1c22c:	e536      	b.n	1bc9c <_vfiprintf_r+0x1d8>
   1c22e:	782b      	ldrb	r3, [r5, #0]
   1c230:	2e00      	cmp	r6, #0
   1c232:	d000      	beq.n	1c236 <_vfiprintf_r+0x772>
   1c234:	e4b8      	b.n	1bba8 <_vfiprintf_r+0xe4>
   1c236:	2001      	movs	r0, #1
   1c238:	3620      	adds	r6, #32
   1c23a:	e4b5      	b.n	1bba8 <_vfiprintf_r+0xe4>
   1c23c:	4662      	mov	r2, ip
   1c23e:	9b01      	ldr	r3, [sp, #4]
   1c240:	4313      	orrs	r3, r2
   1c242:	9301      	str	r3, [sp, #4]
   1c244:	782b      	ldrb	r3, [r5, #0]
   1c246:	e4af      	b.n	1bba8 <_vfiprintf_r+0xe4>
   1c248:	2800      	cmp	r0, #0
   1c24a:	d000      	beq.n	1c24e <_vfiprintf_r+0x78a>
   1c24c:	e346      	b.n	1c8dc <_vfiprintf_r+0xe18>
   1c24e:	4aa7      	ldr	r2, [pc, #668]	; (1c4ec <_vfiprintf_r+0xa28>)
   1c250:	9202      	str	r2, [sp, #8]
   1c252:	9a01      	ldr	r2, [sp, #4]
   1c254:	0692      	lsls	r2, r2, #26
   1c256:	d4b5      	bmi.n	1c1c4 <_vfiprintf_r+0x700>
   1c258:	9a01      	ldr	r2, [sp, #4]
   1c25a:	06d2      	lsls	r2, r2, #27
   1c25c:	d403      	bmi.n	1c266 <_vfiprintf_r+0x7a2>
   1c25e:	9a01      	ldr	r2, [sp, #4]
   1c260:	0652      	lsls	r2, r2, #25
   1c262:	d500      	bpl.n	1c266 <_vfiprintf_r+0x7a2>
   1c264:	e28a      	b.n	1c77c <_vfiprintf_r+0xcb8>
   1c266:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   1c268:	6811      	ldr	r1, [r2, #0]
   1c26a:	9106      	str	r1, [sp, #24]
   1c26c:	2100      	movs	r1, #0
   1c26e:	3204      	adds	r2, #4
   1c270:	920a      	str	r2, [sp, #40]	; 0x28
   1c272:	2201      	movs	r2, #1
   1c274:	9107      	str	r1, [sp, #28]
   1c276:	9901      	ldr	r1, [sp, #4]
   1c278:	400a      	ands	r2, r1
   1c27a:	d1b4      	bne.n	1c1e6 <_vfiprintf_r+0x722>
   1c27c:	ab0e      	add	r3, sp, #56	; 0x38
   1c27e:	71da      	strb	r2, [r3, #7]
   1c280:	9b03      	ldr	r3, [sp, #12]
   1c282:	2b00      	cmp	r3, #0
   1c284:	da00      	bge.n	1c288 <_vfiprintf_r+0x7c4>
   1c286:	e251      	b.n	1c72c <_vfiprintf_r+0xc68>
   1c288:	2380      	movs	r3, #128	; 0x80
   1c28a:	4399      	bics	r1, r3
   1c28c:	9101      	str	r1, [sp, #4]
   1c28e:	9a06      	ldr	r2, [sp, #24]
   1c290:	9b07      	ldr	r3, [sp, #28]
   1c292:	0011      	movs	r1, r2
   1c294:	4319      	orrs	r1, r3
   1c296:	d100      	bne.n	1c29a <_vfiprintf_r+0x7d6>
   1c298:	e4e9      	b.n	1bc6e <_vfiprintf_r+0x1aa>
   1c29a:	2400      	movs	r4, #0
   1c29c:	e149      	b.n	1c532 <_vfiprintf_r+0xa6e>
   1c29e:	4652      	mov	r2, sl
   1c2a0:	9b01      	ldr	r3, [sp, #4]
   1c2a2:	4313      	orrs	r3, r2
   1c2a4:	9301      	str	r3, [sp, #4]
   1c2a6:	782b      	ldrb	r3, [r5, #0]
   1c2a8:	e47e      	b.n	1bba8 <_vfiprintf_r+0xe4>
   1c2aa:	782b      	ldrb	r3, [r5, #0]
   1c2ac:	2b6c      	cmp	r3, #108	; 0x6c
   1c2ae:	d100      	bne.n	1c2b2 <_vfiprintf_r+0x7ee>
   1c2b0:	e283      	b.n	1c7ba <_vfiprintf_r+0xcf6>
   1c2b2:	2110      	movs	r1, #16
   1c2b4:	9a01      	ldr	r2, [sp, #4]
   1c2b6:	430a      	orrs	r2, r1
   1c2b8:	9201      	str	r2, [sp, #4]
   1c2ba:	e475      	b.n	1bba8 <_vfiprintf_r+0xe4>
   1c2bc:	2800      	cmp	r0, #0
   1c2be:	d000      	beq.n	1c2c2 <_vfiprintf_r+0x7fe>
   1c2c0:	e2f7      	b.n	1c8b2 <_vfiprintf_r+0xdee>
   1c2c2:	9b01      	ldr	r3, [sp, #4]
   1c2c4:	069b      	lsls	r3, r3, #26
   1c2c6:	d400      	bmi.n	1c2ca <_vfiprintf_r+0x806>
   1c2c8:	e206      	b.n	1c6d8 <_vfiprintf_r+0xc14>
   1c2ca:	990a      	ldr	r1, [sp, #40]	; 0x28
   1c2cc:	9a05      	ldr	r2, [sp, #20]
   1c2ce:	680b      	ldr	r3, [r1, #0]
   1c2d0:	601a      	str	r2, [r3, #0]
   1c2d2:	17d2      	asrs	r2, r2, #31
   1c2d4:	605a      	str	r2, [r3, #4]
   1c2d6:	000b      	movs	r3, r1
   1c2d8:	3304      	adds	r3, #4
   1c2da:	930a      	str	r3, [sp, #40]	; 0x28
   1c2dc:	f7ff fc2b 	bl	1bb36 <_vfiprintf_r+0x72>
   1c2e0:	2800      	cmp	r0, #0
   1c2e2:	d100      	bne.n	1c2e6 <_vfiprintf_r+0x822>
   1c2e4:	e5eb      	b.n	1bebe <_vfiprintf_r+0x3fa>
   1c2e6:	ab0e      	add	r3, sp, #56	; 0x38
   1c2e8:	71de      	strb	r6, [r3, #7]
   1c2ea:	e5e8      	b.n	1bebe <_vfiprintf_r+0x3fa>
   1c2ec:	2800      	cmp	r0, #0
   1c2ee:	d000      	beq.n	1c2f2 <_vfiprintf_r+0x82e>
   1c2f0:	e2f1      	b.n	1c8d6 <_vfiprintf_r+0xe12>
   1c2f2:	2b00      	cmp	r3, #0
   1c2f4:	d100      	bne.n	1c2f8 <_vfiprintf_r+0x834>
   1c2f6:	e254      	b.n	1c7a2 <_vfiprintf_r+0xcde>
   1c2f8:	ae14      	add	r6, sp, #80	; 0x50
   1c2fa:	7033      	strb	r3, [r6, #0]
   1c2fc:	2300      	movs	r3, #0
   1c2fe:	aa0e      	add	r2, sp, #56	; 0x38
   1c300:	71d3      	strb	r3, [r2, #7]
   1c302:	3301      	adds	r3, #1
   1c304:	9302      	str	r3, [sp, #8]
   1c306:	9308      	str	r3, [sp, #32]
   1c308:	e78e      	b.n	1c228 <_vfiprintf_r+0x764>
   1c30a:	2210      	movs	r2, #16
   1c30c:	9901      	ldr	r1, [sp, #4]
   1c30e:	400a      	ands	r2, r1
   1c310:	d100      	bne.n	1c314 <_vfiprintf_r+0x850>
   1c312:	e1bc      	b.n	1c68e <_vfiprintf_r+0xbca>
   1c314:	990a      	ldr	r1, [sp, #40]	; 0x28
   1c316:	000a      	movs	r2, r1
   1c318:	6809      	ldr	r1, [r1, #0]
   1c31a:	3204      	adds	r2, #4
   1c31c:	9106      	str	r1, [sp, #24]
   1c31e:	2100      	movs	r1, #0
   1c320:	9107      	str	r1, [sp, #28]
   1c322:	a90e      	add	r1, sp, #56	; 0x38
   1c324:	71cb      	strb	r3, [r1, #7]
   1c326:	9b03      	ldr	r3, [sp, #12]
   1c328:	2b00      	cmp	r3, #0
   1c32a:	da00      	bge.n	1c32e <_vfiprintf_r+0x86a>
   1c32c:	e22e      	b.n	1c78c <_vfiprintf_r+0xcc8>
   1c32e:	2380      	movs	r3, #128	; 0x80
   1c330:	9901      	ldr	r1, [sp, #4]
   1c332:	920a      	str	r2, [sp, #40]	; 0x28
   1c334:	4399      	bics	r1, r3
   1c336:	9b06      	ldr	r3, [sp, #24]
   1c338:	9101      	str	r1, [sp, #4]
   1c33a:	2b00      	cmp	r3, #0
   1c33c:	d100      	bne.n	1c340 <_vfiprintf_r+0x87c>
   1c33e:	e634      	b.n	1bfaa <_vfiprintf_r+0x4e6>
   1c340:	2400      	movs	r4, #0
   1c342:	e63c      	b.n	1bfbe <_vfiprintf_r+0x4fa>
   1c344:	aa11      	add	r2, sp, #68	; 0x44
   1c346:	4659      	mov	r1, fp
   1c348:	9804      	ldr	r0, [sp, #16]
   1c34a:	f7ff fb75 	bl	1ba38 <__sprint_r.part.0>
   1c34e:	2800      	cmp	r0, #0
   1c350:	d16d      	bne.n	1c42e <_vfiprintf_r+0x96a>
   1c352:	9912      	ldr	r1, [sp, #72]	; 0x48
   1c354:	9813      	ldr	r0, [sp, #76]	; 0x4c
   1c356:	1c4a      	adds	r2, r1, #1
   1c358:	4647      	mov	r7, r8
   1c35a:	e4c4      	b.n	1bce6 <_vfiprintf_r+0x222>
   1c35c:	9a12      	ldr	r2, [sp, #72]	; 0x48
   1c35e:	9813      	ldr	r0, [sp, #76]	; 0x4c
   1c360:	1c51      	adds	r1, r2, #1
   1c362:	ab0e      	add	r3, sp, #56	; 0x38
   1c364:	79db      	ldrb	r3, [r3, #7]
   1c366:	2b00      	cmp	r3, #0
   1c368:	d100      	bne.n	1c36c <_vfiprintf_r+0x8a8>
   1c36a:	e4e4      	b.n	1bd36 <_vfiprintf_r+0x272>
   1c36c:	ab0e      	add	r3, sp, #56	; 0x38
   1c36e:	3307      	adds	r3, #7
   1c370:	603b      	str	r3, [r7, #0]
   1c372:	2301      	movs	r3, #1
   1c374:	3001      	adds	r0, #1
   1c376:	607b      	str	r3, [r7, #4]
   1c378:	9013      	str	r0, [sp, #76]	; 0x4c
   1c37a:	9112      	str	r1, [sp, #72]	; 0x48
   1c37c:	2907      	cmp	r1, #7
   1c37e:	dc00      	bgt.n	1c382 <_vfiprintf_r+0x8be>
   1c380:	e0ae      	b.n	1c4e0 <_vfiprintf_r+0xa1c>
   1c382:	2800      	cmp	r0, #0
   1c384:	d000      	beq.n	1c388 <_vfiprintf_r+0x8c4>
   1c386:	e120      	b.n	1c5ca <_vfiprintf_r+0xb06>
   1c388:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   1c38a:	2b00      	cmp	r3, #0
   1c38c:	d000      	beq.n	1c390 <_vfiprintf_r+0x8cc>
   1c38e:	e0b5      	b.n	1c4fc <_vfiprintf_r+0xa38>
   1c390:	2200      	movs	r2, #0
   1c392:	2101      	movs	r1, #1
   1c394:	4647      	mov	r7, r8
   1c396:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   1c398:	2b80      	cmp	r3, #128	; 0x80
   1c39a:	d100      	bne.n	1c39e <_vfiprintf_r+0x8da>
   1c39c:	e4e5      	b.n	1bd6a <_vfiprintf_r+0x2a6>
   1c39e:	9b03      	ldr	r3, [sp, #12]
   1c3a0:	9c08      	ldr	r4, [sp, #32]
   1c3a2:	1b1c      	subs	r4, r3, r4
   1c3a4:	2c00      	cmp	r4, #0
   1c3a6:	dc00      	bgt.n	1c3aa <_vfiprintf_r+0x8e6>
   1c3a8:	e521      	b.n	1bdee <_vfiprintf_r+0x32a>
   1c3aa:	4b51      	ldr	r3, [pc, #324]	; (1c4f0 <_vfiprintf_r+0xa2c>)
   1c3ac:	4699      	mov	r9, r3
   1c3ae:	2c10      	cmp	r4, #16
   1c3b0:	dd1f      	ble.n	1c3f2 <_vfiprintf_r+0x92e>
   1c3b2:	2310      	movs	r3, #16
   1c3b4:	469a      	mov	sl, r3
   1c3b6:	464b      	mov	r3, r9
   1c3b8:	46a9      	mov	r9, r5
   1c3ba:	001d      	movs	r5, r3
   1c3bc:	e005      	b.n	1c3ca <_vfiprintf_r+0x906>
   1c3be:	1c91      	adds	r1, r2, #2
   1c3c0:	001a      	movs	r2, r3
   1c3c2:	3708      	adds	r7, #8
   1c3c4:	3c10      	subs	r4, #16
   1c3c6:	2c10      	cmp	r4, #16
   1c3c8:	dd10      	ble.n	1c3ec <_vfiprintf_r+0x928>
   1c3ca:	4653      	mov	r3, sl
   1c3cc:	3010      	adds	r0, #16
   1c3ce:	607b      	str	r3, [r7, #4]
   1c3d0:	1c53      	adds	r3, r2, #1
   1c3d2:	603d      	str	r5, [r7, #0]
   1c3d4:	9013      	str	r0, [sp, #76]	; 0x4c
   1c3d6:	9312      	str	r3, [sp, #72]	; 0x48
   1c3d8:	2b07      	cmp	r3, #7
   1c3da:	ddf0      	ble.n	1c3be <_vfiprintf_r+0x8fa>
   1c3dc:	2800      	cmp	r0, #0
   1c3de:	d113      	bne.n	1c408 <_vfiprintf_r+0x944>
   1c3e0:	3c10      	subs	r4, #16
   1c3e2:	2101      	movs	r1, #1
   1c3e4:	2200      	movs	r2, #0
   1c3e6:	4647      	mov	r7, r8
   1c3e8:	2c10      	cmp	r4, #16
   1c3ea:	dcee      	bgt.n	1c3ca <_vfiprintf_r+0x906>
   1c3ec:	002b      	movs	r3, r5
   1c3ee:	464d      	mov	r5, r9
   1c3f0:	4699      	mov	r9, r3
   1c3f2:	464b      	mov	r3, r9
   1c3f4:	1900      	adds	r0, r0, r4
   1c3f6:	603b      	str	r3, [r7, #0]
   1c3f8:	607c      	str	r4, [r7, #4]
   1c3fa:	9013      	str	r0, [sp, #76]	; 0x4c
   1c3fc:	9112      	str	r1, [sp, #72]	; 0x48
   1c3fe:	2907      	cmp	r1, #7
   1c400:	dc2a      	bgt.n	1c458 <_vfiprintf_r+0x994>
   1c402:	3708      	adds	r7, #8
   1c404:	3101      	adds	r1, #1
   1c406:	e4f2      	b.n	1bdee <_vfiprintf_r+0x32a>
   1c408:	aa11      	add	r2, sp, #68	; 0x44
   1c40a:	4659      	mov	r1, fp
   1c40c:	9804      	ldr	r0, [sp, #16]
   1c40e:	f7ff fb13 	bl	1ba38 <__sprint_r.part.0>
   1c412:	2800      	cmp	r0, #0
   1c414:	d10b      	bne.n	1c42e <_vfiprintf_r+0x96a>
   1c416:	9a12      	ldr	r2, [sp, #72]	; 0x48
   1c418:	9813      	ldr	r0, [sp, #76]	; 0x4c
   1c41a:	1c51      	adds	r1, r2, #1
   1c41c:	4647      	mov	r7, r8
   1c41e:	e7d1      	b.n	1c3c4 <_vfiprintf_r+0x900>
   1c420:	aa11      	add	r2, sp, #68	; 0x44
   1c422:	4659      	mov	r1, fp
   1c424:	9804      	ldr	r0, [sp, #16]
   1c426:	f7ff fb07 	bl	1ba38 <__sprint_r.part.0>
   1c42a:	2800      	cmp	r0, #0
   1c42c:	d036      	beq.n	1c49c <_vfiprintf_r+0x9d8>
   1c42e:	46da      	mov	sl, fp
   1c430:	4653      	mov	r3, sl
   1c432:	899b      	ldrh	r3, [r3, #12]
   1c434:	065b      	lsls	r3, r3, #25
   1c436:	d500      	bpl.n	1c43a <_vfiprintf_r+0x976>
   1c438:	e174      	b.n	1c724 <_vfiprintf_r+0xc60>
   1c43a:	9805      	ldr	r0, [sp, #20]
   1c43c:	f7ff fbde 	bl	1bbfc <_vfiprintf_r+0x138>
   1c440:	aa11      	add	r2, sp, #68	; 0x44
   1c442:	4659      	mov	r1, fp
   1c444:	9804      	ldr	r0, [sp, #16]
   1c446:	f7ff faf7 	bl	1ba38 <__sprint_r.part.0>
   1c44a:	2800      	cmp	r0, #0
   1c44c:	d1ef      	bne.n	1c42e <_vfiprintf_r+0x96a>
   1c44e:	9912      	ldr	r1, [sp, #72]	; 0x48
   1c450:	9813      	ldr	r0, [sp, #76]	; 0x4c
   1c452:	1c4c      	adds	r4, r1, #1
   1c454:	4643      	mov	r3, r8
   1c456:	e4f8      	b.n	1be4a <_vfiprintf_r+0x386>
   1c458:	2800      	cmp	r0, #0
   1c45a:	d000      	beq.n	1c45e <_vfiprintf_r+0x99a>
   1c45c:	e0d7      	b.n	1c60e <_vfiprintf_r+0xb4a>
   1c45e:	4643      	mov	r3, r8
   1c460:	9808      	ldr	r0, [sp, #32]
   1c462:	601e      	str	r6, [r3, #0]
   1c464:	6058      	str	r0, [r3, #4]
   1c466:	2301      	movs	r3, #1
   1c468:	4647      	mov	r7, r8
   1c46a:	9013      	str	r0, [sp, #76]	; 0x4c
   1c46c:	9312      	str	r3, [sp, #72]	; 0x48
   1c46e:	003b      	movs	r3, r7
   1c470:	3308      	adds	r3, #8
   1c472:	9a01      	ldr	r2, [sp, #4]
   1c474:	0752      	lsls	r2, r2, #29
   1c476:	d505      	bpl.n	1c484 <_vfiprintf_r+0x9c0>
   1c478:	9a09      	ldr	r2, [sp, #36]	; 0x24
   1c47a:	9902      	ldr	r1, [sp, #8]
   1c47c:	1a56      	subs	r6, r2, r1
   1c47e:	2e00      	cmp	r6, #0
   1c480:	dd00      	ble.n	1c484 <_vfiprintf_r+0x9c0>
   1c482:	e4cb      	b.n	1be1c <_vfiprintf_r+0x358>
   1c484:	9b09      	ldr	r3, [sp, #36]	; 0x24
   1c486:	9902      	ldr	r1, [sp, #8]
   1c488:	428b      	cmp	r3, r1
   1c48a:	da00      	bge.n	1c48e <_vfiprintf_r+0x9ca>
   1c48c:	000b      	movs	r3, r1
   1c48e:	9a05      	ldr	r2, [sp, #20]
   1c490:	4694      	mov	ip, r2
   1c492:	449c      	add	ip, r3
   1c494:	4663      	mov	r3, ip
   1c496:	9305      	str	r3, [sp, #20]
   1c498:	2800      	cmp	r0, #0
   1c49a:	d1c1      	bne.n	1c420 <_vfiprintf_r+0x95c>
   1c49c:	2300      	movs	r3, #0
   1c49e:	4647      	mov	r7, r8
   1c4a0:	9312      	str	r3, [sp, #72]	; 0x48
   1c4a2:	f7ff fb48 	bl	1bb36 <_vfiprintf_r+0x72>
   1c4a6:	aa11      	add	r2, sp, #68	; 0x44
   1c4a8:	4659      	mov	r1, fp
   1c4aa:	9804      	ldr	r0, [sp, #16]
   1c4ac:	f7ff fac4 	bl	1ba38 <__sprint_r.part.0>
   1c4b0:	2800      	cmp	r0, #0
   1c4b2:	d1bc      	bne.n	1c42e <_vfiprintf_r+0x96a>
   1c4b4:	9a12      	ldr	r2, [sp, #72]	; 0x48
   1c4b6:	9813      	ldr	r0, [sp, #76]	; 0x4c
   1c4b8:	1c51      	adds	r1, r2, #1
   1c4ba:	4647      	mov	r7, r8
   1c4bc:	e46a      	b.n	1bd94 <_vfiprintf_r+0x2d0>
   1c4be:	2800      	cmp	r0, #0
   1c4c0:	d000      	beq.n	1c4c4 <_vfiprintf_r+0xa00>
   1c4c2:	e122      	b.n	1c70a <_vfiprintf_r+0xc46>
   1c4c4:	ab0e      	add	r3, sp, #56	; 0x38
   1c4c6:	79db      	ldrb	r3, [r3, #7]
   1c4c8:	2b00      	cmp	r3, #0
   1c4ca:	d013      	beq.n	1c4f4 <_vfiprintf_r+0xa30>
   1c4cc:	4643      	mov	r3, r8
   1c4ce:	aa0e      	add	r2, sp, #56	; 0x38
   1c4d0:	3207      	adds	r2, #7
   1c4d2:	601a      	str	r2, [r3, #0]
   1c4d4:	2301      	movs	r3, #1
   1c4d6:	4642      	mov	r2, r8
   1c4d8:	2001      	movs	r0, #1
   1c4da:	2101      	movs	r1, #1
   1c4dc:	4647      	mov	r7, r8
   1c4de:	6053      	str	r3, [r2, #4]
   1c4e0:	000a      	movs	r2, r1
   1c4e2:	3708      	adds	r7, #8
   1c4e4:	3101      	adds	r1, #1
   1c4e6:	e426      	b.n	1bd36 <_vfiprintf_r+0x272>
   1c4e8:	00022d48 	.word	0x00022d48
   1c4ec:	00022d5c 	.word	0x00022d5c
   1c4f0:	000231b0 	.word	0x000231b0
   1c4f4:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   1c4f6:	2b00      	cmp	r3, #0
   1c4f8:	d100      	bne.n	1c4fc <_vfiprintf_r+0xa38>
   1c4fa:	e13b      	b.n	1c774 <_vfiprintf_r+0xcb0>
   1c4fc:	4642      	mov	r2, r8
   1c4fe:	ab10      	add	r3, sp, #64	; 0x40
   1c500:	6013      	str	r3, [r2, #0]
   1c502:	2302      	movs	r3, #2
   1c504:	2101      	movs	r1, #1
   1c506:	2002      	movs	r0, #2
   1c508:	4647      	mov	r7, r8
   1c50a:	6053      	str	r3, [r2, #4]
   1c50c:	000a      	movs	r2, r1
   1c50e:	3708      	adds	r7, #8
   1c510:	3101      	adds	r1, #1
   1c512:	e740      	b.n	1c396 <_vfiprintf_r+0x8d2>
   1c514:	4bd8      	ldr	r3, [pc, #864]	; (1c878 <_vfiprintf_r+0xdb4>)
   1c516:	9101      	str	r1, [sp, #4]
   1c518:	9302      	str	r3, [sp, #8]
   1c51a:	9a06      	ldr	r2, [sp, #24]
   1c51c:	9b07      	ldr	r3, [sp, #28]
   1c51e:	0011      	movs	r1, r2
   1c520:	900a      	str	r0, [sp, #40]	; 0x28
   1c522:	4319      	orrs	r1, r3
   1c524:	d000      	beq.n	1c528 <_vfiprintf_r+0xa64>
   1c526:	e6b8      	b.n	1c29a <_vfiprintf_r+0x7d6>
   1c528:	2200      	movs	r2, #0
   1c52a:	2300      	movs	r3, #0
   1c52c:	2400      	movs	r4, #0
   1c52e:	9206      	str	r2, [sp, #24]
   1c530:	9307      	str	r3, [sp, #28]
   1c532:	9a06      	ldr	r2, [sp, #24]
   1c534:	9b07      	ldr	r3, [sp, #28]
   1c536:	4646      	mov	r6, r8
   1c538:	200f      	movs	r0, #15
   1c53a:	46ba      	mov	sl, r7
   1c53c:	46a4      	mov	ip, r4
   1c53e:	46a9      	mov	r9, r5
   1c540:	9d02      	ldr	r5, [sp, #8]
   1c542:	0001      	movs	r1, r0
   1c544:	4011      	ands	r1, r2
   1c546:	5c69      	ldrb	r1, [r5, r1]
   1c548:	071f      	lsls	r7, r3, #28
   1c54a:	0914      	lsrs	r4, r2, #4
   1c54c:	3e01      	subs	r6, #1
   1c54e:	4327      	orrs	r7, r4
   1c550:	7031      	strb	r1, [r6, #0]
   1c552:	0919      	lsrs	r1, r3, #4
   1c554:	000b      	movs	r3, r1
   1c556:	0039      	movs	r1, r7
   1c558:	003a      	movs	r2, r7
   1c55a:	4319      	orrs	r1, r3
   1c55c:	d1f1      	bne.n	1c542 <_vfiprintf_r+0xa7e>
   1c55e:	9206      	str	r2, [sp, #24]
   1c560:	9307      	str	r3, [sp, #28]
   1c562:	4643      	mov	r3, r8
   1c564:	1b9b      	subs	r3, r3, r6
   1c566:	4657      	mov	r7, sl
   1c568:	4664      	mov	r4, ip
   1c56a:	464d      	mov	r5, r9
   1c56c:	9308      	str	r3, [sp, #32]
   1c56e:	f7ff fb88 	bl	1bc82 <_vfiprintf_r+0x1be>
   1c572:	aa11      	add	r2, sp, #68	; 0x44
   1c574:	4659      	mov	r1, fp
   1c576:	9804      	ldr	r0, [sp, #16]
   1c578:	f7ff fa5e 	bl	1ba38 <__sprint_r.part.0>
   1c57c:	2800      	cmp	r0, #0
   1c57e:	d000      	beq.n	1c582 <_vfiprintf_r+0xabe>
   1c580:	e755      	b.n	1c42e <_vfiprintf_r+0x96a>
   1c582:	9813      	ldr	r0, [sp, #76]	; 0x4c
   1c584:	4643      	mov	r3, r8
   1c586:	e774      	b.n	1c472 <_vfiprintf_r+0x9ae>
   1c588:	9b01      	ldr	r3, [sp, #4]
   1c58a:	06db      	lsls	r3, r3, #27
   1c58c:	d400      	bmi.n	1c590 <_vfiprintf_r+0xacc>
   1c58e:	e09b      	b.n	1c6c8 <_vfiprintf_r+0xc04>
   1c590:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   1c592:	6813      	ldr	r3, [r2, #0]
   1c594:	9302      	str	r3, [sp, #8]
   1c596:	9306      	str	r3, [sp, #24]
   1c598:	3204      	adds	r2, #4
   1c59a:	17db      	asrs	r3, r3, #31
   1c59c:	9307      	str	r3, [sp, #28]
   1c59e:	920a      	str	r2, [sp, #40]	; 0x28
   1c5a0:	e49e      	b.n	1bee0 <_vfiprintf_r+0x41c>
   1c5a2:	920a      	str	r2, [sp, #40]	; 0x28
   1c5a4:	2400      	movs	r4, #0
   1c5a6:	9a06      	ldr	r2, [sp, #24]
   1c5a8:	9b07      	ldr	r3, [sp, #28]
   1c5aa:	0011      	movs	r1, r2
   1c5ac:	4319      	orrs	r1, r3
   1c5ae:	d000      	beq.n	1c5b2 <_vfiprintf_r+0xaee>
   1c5b0:	e4a9      	b.n	1bf06 <_vfiprintf_r+0x442>
   1c5b2:	e5bb      	b.n	1c12c <_vfiprintf_r+0x668>
   1c5b4:	aa11      	add	r2, sp, #68	; 0x44
   1c5b6:	4659      	mov	r1, fp
   1c5b8:	9804      	ldr	r0, [sp, #16]
   1c5ba:	f7ff fa3d 	bl	1ba38 <__sprint_r.part.0>
   1c5be:	2800      	cmp	r0, #0
   1c5c0:	d000      	beq.n	1c5c4 <_vfiprintf_r+0xb00>
   1c5c2:	e734      	b.n	1c42e <_vfiprintf_r+0x96a>
   1c5c4:	4647      	mov	r7, r8
   1c5c6:	f7ff fad1 	bl	1bb6c <_vfiprintf_r+0xa8>
   1c5ca:	aa11      	add	r2, sp, #68	; 0x44
   1c5cc:	4659      	mov	r1, fp
   1c5ce:	9804      	ldr	r0, [sp, #16]
   1c5d0:	f7ff fa32 	bl	1ba38 <__sprint_r.part.0>
   1c5d4:	2800      	cmp	r0, #0
   1c5d6:	d000      	beq.n	1c5da <_vfiprintf_r+0xb16>
   1c5d8:	e729      	b.n	1c42e <_vfiprintf_r+0x96a>
   1c5da:	9a12      	ldr	r2, [sp, #72]	; 0x48
   1c5dc:	9813      	ldr	r0, [sp, #76]	; 0x4c
   1c5de:	1c51      	adds	r1, r2, #1
   1c5e0:	4647      	mov	r7, r8
   1c5e2:	f7ff fba8 	bl	1bd36 <_vfiprintf_r+0x272>
   1c5e6:	aa11      	add	r2, sp, #68	; 0x44
   1c5e8:	4659      	mov	r1, fp
   1c5ea:	9804      	ldr	r0, [sp, #16]
   1c5ec:	f7ff fa24 	bl	1ba38 <__sprint_r.part.0>
   1c5f0:	2800      	cmp	r0, #0
   1c5f2:	d000      	beq.n	1c5f6 <_vfiprintf_r+0xb32>
   1c5f4:	e71b      	b.n	1c42e <_vfiprintf_r+0x96a>
   1c5f6:	9a12      	ldr	r2, [sp, #72]	; 0x48
   1c5f8:	9813      	ldr	r0, [sp, #76]	; 0x4c
   1c5fa:	1c51      	adds	r1, r2, #1
   1c5fc:	4647      	mov	r7, r8
   1c5fe:	e6ca      	b.n	1c396 <_vfiprintf_r+0x8d2>
   1c600:	2800      	cmp	r0, #0
   1c602:	d000      	beq.n	1c606 <_vfiprintf_r+0xb42>
   1c604:	e0e5      	b.n	1c7d2 <_vfiprintf_r+0xd0e>
   1c606:	2101      	movs	r1, #1
   1c608:	2200      	movs	r2, #0
   1c60a:	4647      	mov	r7, r8
   1c60c:	e6c7      	b.n	1c39e <_vfiprintf_r+0x8da>
   1c60e:	aa11      	add	r2, sp, #68	; 0x44
   1c610:	4659      	mov	r1, fp
   1c612:	9804      	ldr	r0, [sp, #16]
   1c614:	f7ff fa10 	bl	1ba38 <__sprint_r.part.0>
   1c618:	2800      	cmp	r0, #0
   1c61a:	d000      	beq.n	1c61e <_vfiprintf_r+0xb5a>
   1c61c:	e707      	b.n	1c42e <_vfiprintf_r+0x96a>
   1c61e:	9b12      	ldr	r3, [sp, #72]	; 0x48
   1c620:	9813      	ldr	r0, [sp, #76]	; 0x4c
   1c622:	9303      	str	r3, [sp, #12]
   1c624:	1c59      	adds	r1, r3, #1
   1c626:	4647      	mov	r7, r8
   1c628:	f7ff fbe1 	bl	1bdee <_vfiprintf_r+0x32a>
   1c62c:	2030      	movs	r0, #48	; 0x30
   1c62e:	aa10      	add	r2, sp, #64	; 0x40
   1c630:	7010      	strb	r0, [r2, #0]
   1c632:	7053      	strb	r3, [r2, #1]
   1c634:	9901      	ldr	r1, [sp, #4]
   1c636:	2200      	movs	r2, #0
   1c638:	2302      	movs	r3, #2
   1c63a:	0008      	movs	r0, r1
   1c63c:	ac0e      	add	r4, sp, #56	; 0x38
   1c63e:	71e2      	strb	r2, [r4, #7]
   1c640:	9a03      	ldr	r2, [sp, #12]
   1c642:	4318      	orrs	r0, r3
   1c644:	2a00      	cmp	r2, #0
   1c646:	da00      	bge.n	1c64a <_vfiprintf_r+0xb86>
   1c648:	e0dd      	b.n	1c806 <_vfiprintf_r+0xd42>
   1c64a:	2280      	movs	r2, #128	; 0x80
   1c64c:	0008      	movs	r0, r1
   1c64e:	4390      	bics	r0, r2
   1c650:	0002      	movs	r2, r0
   1c652:	431a      	orrs	r2, r3
   1c654:	9201      	str	r2, [sp, #4]
   1c656:	2400      	movs	r4, #0
   1c658:	e76b      	b.n	1c532 <_vfiprintf_r+0xa6e>
   1c65a:	4b87      	ldr	r3, [pc, #540]	; (1c878 <_vfiprintf_r+0xdb4>)
   1c65c:	2400      	movs	r4, #0
   1c65e:	9302      	str	r3, [sp, #8]
   1c660:	e767      	b.n	1c532 <_vfiprintf_r+0xa6e>
   1c662:	990a      	ldr	r1, [sp, #40]	; 0x28
   1c664:	e548      	b.n	1c0f8 <_vfiprintf_r+0x634>
   1c666:	9906      	ldr	r1, [sp, #24]
   1c668:	9a07      	ldr	r2, [sp, #28]
   1c66a:	2400      	movs	r4, #0
   1c66c:	424b      	negs	r3, r1
   1c66e:	4194      	sbcs	r4, r2
   1c670:	9306      	str	r3, [sp, #24]
   1c672:	9407      	str	r4, [sp, #28]
   1c674:	232d      	movs	r3, #45	; 0x2d
   1c676:	aa0e      	add	r2, sp, #56	; 0x38
   1c678:	71d3      	strb	r3, [r2, #7]
   1c67a:	9b03      	ldr	r3, [sp, #12]
   1c67c:	2b00      	cmp	r3, #0
   1c67e:	da00      	bge.n	1c682 <_vfiprintf_r+0xbbe>
   1c680:	e0d1      	b.n	1c826 <_vfiprintf_r+0xd62>
   1c682:	2380      	movs	r3, #128	; 0x80
   1c684:	9a01      	ldr	r2, [sp, #4]
   1c686:	242d      	movs	r4, #45	; 0x2d
   1c688:	439a      	bics	r2, r3
   1c68a:	9201      	str	r2, [sp, #4]
   1c68c:	e43b      	b.n	1bf06 <_vfiprintf_r+0x442>
   1c68e:	2340      	movs	r3, #64	; 0x40
   1c690:	9901      	ldr	r1, [sp, #4]
   1c692:	400b      	ands	r3, r1
   1c694:	990a      	ldr	r1, [sp, #40]	; 0x28
   1c696:	d100      	bne.n	1c69a <_vfiprintf_r+0xbd6>
   1c698:	e63d      	b.n	1c316 <_vfiprintf_r+0x852>
   1c69a:	000b      	movs	r3, r1
   1c69c:	8809      	ldrh	r1, [r1, #0]
   1c69e:	3304      	adds	r3, #4
   1c6a0:	9106      	str	r1, [sp, #24]
   1c6a2:	2100      	movs	r1, #0
   1c6a4:	9107      	str	r1, [sp, #28]
   1c6a6:	a90e      	add	r1, sp, #56	; 0x38
   1c6a8:	71ca      	strb	r2, [r1, #7]
   1c6aa:	9a03      	ldr	r2, [sp, #12]
   1c6ac:	2a00      	cmp	r2, #0
   1c6ae:	da00      	bge.n	1c6b2 <_vfiprintf_r+0xbee>
   1c6b0:	e0d5      	b.n	1c85e <_vfiprintf_r+0xd9a>
   1c6b2:	2280      	movs	r2, #128	; 0x80
   1c6b4:	9901      	ldr	r1, [sp, #4]
   1c6b6:	930a      	str	r3, [sp, #40]	; 0x28
   1c6b8:	4391      	bics	r1, r2
   1c6ba:	9a06      	ldr	r2, [sp, #24]
   1c6bc:	9101      	str	r1, [sp, #4]
   1c6be:	2a00      	cmp	r2, #0
   1c6c0:	d100      	bne.n	1c6c4 <_vfiprintf_r+0xc00>
   1c6c2:	e472      	b.n	1bfaa <_vfiprintf_r+0x4e6>
   1c6c4:	2400      	movs	r4, #0
   1c6c6:	e47a      	b.n	1bfbe <_vfiprintf_r+0x4fa>
   1c6c8:	9b01      	ldr	r3, [sp, #4]
   1c6ca:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   1c6cc:	065b      	lsls	r3, r3, #25
   1c6ce:	d400      	bmi.n	1c6d2 <_vfiprintf_r+0xc0e>
   1c6d0:	e75f      	b.n	1c592 <_vfiprintf_r+0xace>
   1c6d2:	2100      	movs	r1, #0
   1c6d4:	5e53      	ldrsh	r3, [r2, r1]
   1c6d6:	e75e      	b.n	1c596 <_vfiprintf_r+0xad2>
   1c6d8:	9b01      	ldr	r3, [sp, #4]
   1c6da:	06db      	lsls	r3, r3, #27
   1c6dc:	d40c      	bmi.n	1c6f8 <_vfiprintf_r+0xc34>
   1c6de:	9b01      	ldr	r3, [sp, #4]
   1c6e0:	065b      	lsls	r3, r3, #25
   1c6e2:	d509      	bpl.n	1c6f8 <_vfiprintf_r+0xc34>
   1c6e4:	4669      	mov	r1, sp
   1c6e6:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1c6e8:	8a89      	ldrh	r1, [r1, #20]
   1c6ea:	681a      	ldr	r2, [r3, #0]
   1c6ec:	3304      	adds	r3, #4
   1c6ee:	9201      	str	r2, [sp, #4]
   1c6f0:	8011      	strh	r1, [r2, #0]
   1c6f2:	930a      	str	r3, [sp, #40]	; 0x28
   1c6f4:	f7ff fa1f 	bl	1bb36 <_vfiprintf_r+0x72>
   1c6f8:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   1c6fa:	9905      	ldr	r1, [sp, #20]
   1c6fc:	6813      	ldr	r3, [r2, #0]
   1c6fe:	6019      	str	r1, [r3, #0]
   1c700:	0013      	movs	r3, r2
   1c702:	3304      	adds	r3, #4
   1c704:	930a      	str	r3, [sp, #40]	; 0x28
   1c706:	f7ff fa16 	bl	1bb36 <_vfiprintf_r+0x72>
   1c70a:	aa11      	add	r2, sp, #68	; 0x44
   1c70c:	4659      	mov	r1, fp
   1c70e:	9804      	ldr	r0, [sp, #16]
   1c710:	f7ff f992 	bl	1ba38 <__sprint_r.part.0>
   1c714:	2800      	cmp	r0, #0
   1c716:	d000      	beq.n	1c71a <_vfiprintf_r+0xc56>
   1c718:	e689      	b.n	1c42e <_vfiprintf_r+0x96a>
   1c71a:	9a12      	ldr	r2, [sp, #72]	; 0x48
   1c71c:	9813      	ldr	r0, [sp, #76]	; 0x4c
   1c71e:	1c51      	adds	r1, r2, #1
   1c720:	4647      	mov	r7, r8
   1c722:	e61e      	b.n	1c362 <_vfiprintf_r+0x89e>
   1c724:	2001      	movs	r0, #1
   1c726:	4240      	negs	r0, r0
   1c728:	f7ff fa68 	bl	1bbfc <_vfiprintf_r+0x138>
   1c72c:	980a      	ldr	r0, [sp, #40]	; 0x28
   1c72e:	e6f4      	b.n	1c51a <_vfiprintf_r+0xa56>
   1c730:	aa11      	add	r2, sp, #68	; 0x44
   1c732:	4659      	mov	r1, fp
   1c734:	9804      	ldr	r0, [sp, #16]
   1c736:	f7ff f97f 	bl	1ba38 <__sprint_r.part.0>
   1c73a:	2800      	cmp	r0, #0
   1c73c:	d000      	beq.n	1c740 <_vfiprintf_r+0xc7c>
   1c73e:	e676      	b.n	1c42e <_vfiprintf_r+0x96a>
   1c740:	9813      	ldr	r0, [sp, #76]	; 0x4c
   1c742:	e69f      	b.n	1c484 <_vfiprintf_r+0x9c0>
   1c744:	000b      	movs	r3, r1
   1c746:	8809      	ldrh	r1, [r1, #0]
   1c748:	3304      	adds	r3, #4
   1c74a:	9106      	str	r1, [sp, #24]
   1c74c:	2100      	movs	r1, #0
   1c74e:	9107      	str	r1, [sp, #28]
   1c750:	a90e      	add	r1, sp, #56	; 0x38
   1c752:	71ca      	strb	r2, [r1, #7]
   1c754:	9a03      	ldr	r2, [sp, #12]
   1c756:	2a00      	cmp	r2, #0
   1c758:	da00      	bge.n	1c75c <_vfiprintf_r+0xc98>
   1c75a:	e07d      	b.n	1c858 <_vfiprintf_r+0xd94>
   1c75c:	2280      	movs	r2, #128	; 0x80
   1c75e:	9901      	ldr	r1, [sp, #4]
   1c760:	930a      	str	r3, [sp, #40]	; 0x28
   1c762:	4391      	bics	r1, r2
   1c764:	9a06      	ldr	r2, [sp, #24]
   1c766:	9101      	str	r1, [sp, #4]
   1c768:	2400      	movs	r4, #0
   1c76a:	2a00      	cmp	r2, #0
   1c76c:	d001      	beq.n	1c772 <_vfiprintf_r+0xcae>
   1c76e:	f7ff fbca 	bl	1bf06 <_vfiprintf_r+0x442>
   1c772:	e4d7      	b.n	1c124 <_vfiprintf_r+0x660>
   1c774:	2200      	movs	r2, #0
   1c776:	2101      	movs	r1, #1
   1c778:	4647      	mov	r7, r8
   1c77a:	e610      	b.n	1c39e <_vfiprintf_r+0x8da>
   1c77c:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   1c77e:	8811      	ldrh	r1, [r2, #0]
   1c780:	e573      	b.n	1c26a <_vfiprintf_r+0x7a6>
   1c782:	2201      	movs	r2, #1
   1c784:	4252      	negs	r2, r2
   1c786:	9203      	str	r2, [sp, #12]
   1c788:	f7ff fa0f 	bl	1bbaa <_vfiprintf_r+0xe6>
   1c78c:	920a      	str	r2, [sp, #40]	; 0x28
   1c78e:	9a06      	ldr	r2, [sp, #24]
   1c790:	9b07      	ldr	r3, [sp, #28]
   1c792:	0011      	movs	r1, r2
   1c794:	2400      	movs	r4, #0
   1c796:	4319      	orrs	r1, r3
   1c798:	d001      	beq.n	1c79e <_vfiprintf_r+0xcda>
   1c79a:	f7ff fc10 	bl	1bfbe <_vfiprintf_r+0x4fa>
   1c79e:	f7ff fc0a 	bl	1bfb6 <_vfiprintf_r+0x4f2>
   1c7a2:	9b13      	ldr	r3, [sp, #76]	; 0x4c
   1c7a4:	46da      	mov	sl, fp
   1c7a6:	9301      	str	r3, [sp, #4]
   1c7a8:	2b00      	cmp	r3, #0
   1c7aa:	d100      	bne.n	1c7ae <_vfiprintf_r+0xcea>
   1c7ac:	e640      	b.n	1c430 <_vfiprintf_r+0x96c>
   1c7ae:	aa11      	add	r2, sp, #68	; 0x44
   1c7b0:	4651      	mov	r1, sl
   1c7b2:	9804      	ldr	r0, [sp, #16]
   1c7b4:	f7ff f940 	bl	1ba38 <__sprint_r.part.0>
   1c7b8:	e63a      	b.n	1c430 <_vfiprintf_r+0x96c>
   1c7ba:	9b01      	ldr	r3, [sp, #4]
   1c7bc:	3501      	adds	r5, #1
   1c7be:	4323      	orrs	r3, r4
   1c7c0:	9301      	str	r3, [sp, #4]
   1c7c2:	782b      	ldrb	r3, [r5, #0]
   1c7c4:	f7ff f9f0 	bl	1bba8 <_vfiprintf_r+0xe4>
   1c7c8:	0030      	movs	r0, r6
   1c7ca:	f7f9 fa21 	bl	15c10 <strlen>
   1c7ce:	9008      	str	r0, [sp, #32]
   1c7d0:	e478      	b.n	1c0c4 <_vfiprintf_r+0x600>
   1c7d2:	aa11      	add	r2, sp, #68	; 0x44
   1c7d4:	4659      	mov	r1, fp
   1c7d6:	9804      	ldr	r0, [sp, #16]
   1c7d8:	f7ff f92e 	bl	1ba38 <__sprint_r.part.0>
   1c7dc:	2800      	cmp	r0, #0
   1c7de:	d000      	beq.n	1c7e2 <_vfiprintf_r+0xd1e>
   1c7e0:	e625      	b.n	1c42e <_vfiprintf_r+0x96a>
   1c7e2:	9a12      	ldr	r2, [sp, #72]	; 0x48
   1c7e4:	9813      	ldr	r0, [sp, #76]	; 0x4c
   1c7e6:	1c51      	adds	r1, r2, #1
   1c7e8:	4647      	mov	r7, r8
   1c7ea:	e5d8      	b.n	1c39e <_vfiprintf_r+0x8da>
   1c7ec:	9b06      	ldr	r3, [sp, #24]
   1c7ee:	2b09      	cmp	r3, #9
   1c7f0:	d901      	bls.n	1c7f6 <_vfiprintf_r+0xd32>
   1c7f2:	f7ff fb8d 	bl	1bf10 <_vfiprintf_r+0x44c>
   1c7f6:	e49d      	b.n	1c134 <_vfiprintf_r+0x670>
   1c7f8:	9b12      	ldr	r3, [sp, #72]	; 0x48
   1c7fa:	930d      	str	r3, [sp, #52]	; 0x34
   1c7fc:	1c5a      	adds	r2, r3, #1
   1c7fe:	4b1f      	ldr	r3, [pc, #124]	; (1c87c <_vfiprintf_r+0xdb8>)
   1c800:	4699      	mov	r9, r3
   1c802:	f7ff fa88 	bl	1bd16 <_vfiprintf_r+0x252>
   1c806:	2400      	movs	r4, #0
   1c808:	9001      	str	r0, [sp, #4]
   1c80a:	e692      	b.n	1c532 <_vfiprintf_r+0xa6e>
   1c80c:	9a03      	ldr	r2, [sp, #12]
   1c80e:	2a06      	cmp	r2, #6
   1c810:	d900      	bls.n	1c814 <_vfiprintf_r+0xd50>
   1c812:	2206      	movs	r2, #6
   1c814:	43d3      	mvns	r3, r2
   1c816:	17db      	asrs	r3, r3, #31
   1c818:	9208      	str	r2, [sp, #32]
   1c81a:	401a      	ands	r2, r3
   1c81c:	464b      	mov	r3, r9
   1c81e:	9202      	str	r2, [sp, #8]
   1c820:	930a      	str	r3, [sp, #40]	; 0x28
   1c822:	4e17      	ldr	r6, [pc, #92]	; (1c880 <_vfiprintf_r+0xdbc>)
   1c824:	e500      	b.n	1c228 <_vfiprintf_r+0x764>
   1c826:	242d      	movs	r4, #45	; 0x2d
   1c828:	f7ff fb6d 	bl	1bf06 <_vfiprintf_r+0x442>
   1c82c:	9a12      	ldr	r2, [sp, #72]	; 0x48
   1c82e:	9201      	str	r2, [sp, #4]
   1c830:	1c54      	adds	r4, r2, #1
   1c832:	4a12      	ldr	r2, [pc, #72]	; (1c87c <_vfiprintf_r+0xdb8>)
   1c834:	4691      	mov	r9, r2
   1c836:	f7ff fb1d 	bl	1be74 <_vfiprintf_r+0x3b0>
   1c83a:	4b12      	ldr	r3, [pc, #72]	; (1c884 <_vfiprintf_r+0xdc0>)
   1c83c:	468c      	mov	ip, r1
   1c83e:	4699      	mov	r9, r3
   1c840:	f7ff fac1 	bl	1bdc6 <_vfiprintf_r+0x302>
   1c844:	ab0e      	add	r3, sp, #56	; 0x38
   1c846:	79dc      	ldrb	r4, [r3, #7]
   1c848:	464b      	mov	r3, r9
   1c84a:	930a      	str	r3, [sp, #40]	; 0x28
   1c84c:	9b03      	ldr	r3, [sp, #12]
   1c84e:	9308      	str	r3, [sp, #32]
   1c850:	2300      	movs	r3, #0
   1c852:	9303      	str	r3, [sp, #12]
   1c854:	f7ff fa15 	bl	1bc82 <_vfiprintf_r+0x1be>
   1c858:	930a      	str	r3, [sp, #40]	; 0x28
   1c85a:	2400      	movs	r4, #0
   1c85c:	e6a3      	b.n	1c5a6 <_vfiprintf_r+0xae2>
   1c85e:	930a      	str	r3, [sp, #40]	; 0x28
   1c860:	e795      	b.n	1c78e <_vfiprintf_r+0xcca>
   1c862:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1c864:	1d1a      	adds	r2, r3, #4
   1c866:	681b      	ldr	r3, [r3, #0]
   1c868:	9303      	str	r3, [sp, #12]
   1c86a:	2b00      	cmp	r3, #0
   1c86c:	db19      	blt.n	1c8a2 <_vfiprintf_r+0xdde>
   1c86e:	786b      	ldrb	r3, [r5, #1]
   1c870:	920a      	str	r2, [sp, #40]	; 0x28
   1c872:	9d02      	ldr	r5, [sp, #8]
   1c874:	f7ff f998 	bl	1bba8 <_vfiprintf_r+0xe4>
   1c878:	00022d5c 	.word	0x00022d5c
   1c87c:	000231c0 	.word	0x000231c0
   1c880:	00022d70 	.word	0x00022d70
   1c884:	000231b0 	.word	0x000231b0
   1c888:	9b01      	ldr	r3, [sp, #4]
   1c88a:	07db      	lsls	r3, r3, #31
   1c88c:	d504      	bpl.n	1c898 <_vfiprintf_r+0xdd4>
   1c88e:	2130      	movs	r1, #48	; 0x30
   1c890:	2327      	movs	r3, #39	; 0x27
   1c892:	aa14      	add	r2, sp, #80	; 0x50
   1c894:	54d1      	strb	r1, [r2, r3]
   1c896:	e452      	b.n	1c13e <_vfiprintf_r+0x67a>
   1c898:	2300      	movs	r3, #0
   1c89a:	4646      	mov	r6, r8
   1c89c:	9308      	str	r3, [sp, #32]
   1c89e:	f7ff f9f0 	bl	1bc82 <_vfiprintf_r+0x1be>
   1c8a2:	920a      	str	r2, [sp, #40]	; 0x28
   1c8a4:	2201      	movs	r2, #1
   1c8a6:	4252      	negs	r2, r2
   1c8a8:	786b      	ldrb	r3, [r5, #1]
   1c8aa:	9203      	str	r2, [sp, #12]
   1c8ac:	9d02      	ldr	r5, [sp, #8]
   1c8ae:	f7ff f97b 	bl	1bba8 <_vfiprintf_r+0xe4>
   1c8b2:	ab0e      	add	r3, sp, #56	; 0x38
   1c8b4:	71de      	strb	r6, [r3, #7]
   1c8b6:	e504      	b.n	1c2c2 <_vfiprintf_r+0x7fe>
   1c8b8:	ab0e      	add	r3, sp, #56	; 0x38
   1c8ba:	71de      	strb	r6, [r3, #7]
   1c8bc:	e44f      	b.n	1c15e <_vfiprintf_r+0x69a>
   1c8be:	ab0e      	add	r3, sp, #56	; 0x38
   1c8c0:	71de      	strb	r6, [r3, #7]
   1c8c2:	f7ff fc0a 	bl	1c0da <_vfiprintf_r+0x616>
   1c8c6:	ab0e      	add	r3, sp, #56	; 0x38
   1c8c8:	71de      	strb	r6, [r3, #7]
   1c8ca:	f7ff fb46 	bl	1bf5a <_vfiprintf_r+0x496>
   1c8ce:	ab0e      	add	r3, sp, #56	; 0x38
   1c8d0:	71de      	strb	r6, [r3, #7]
   1c8d2:	f7ff faf0 	bl	1beb6 <_vfiprintf_r+0x3f2>
   1c8d6:	aa0e      	add	r2, sp, #56	; 0x38
   1c8d8:	71d6      	strb	r6, [r2, #7]
   1c8da:	e50a      	b.n	1c2f2 <_vfiprintf_r+0x82e>
   1c8dc:	aa0e      	add	r2, sp, #56	; 0x38
   1c8de:	71d6      	strb	r6, [r2, #7]
   1c8e0:	e4b5      	b.n	1c24e <_vfiprintf_r+0x78a>
   1c8e2:	aa0e      	add	r2, sp, #56	; 0x38
   1c8e4:	71d6      	strb	r6, [r2, #7]
   1c8e6:	e468      	b.n	1c1ba <_vfiprintf_r+0x6f6>

0001c8e8 <vfiprintf>:
   1c8e8:	b510      	push	{r4, lr}
   1c8ea:	0004      	movs	r4, r0
   1c8ec:	0013      	movs	r3, r2
   1c8ee:	4a03      	ldr	r2, [pc, #12]	; (1c8fc <vfiprintf+0x14>)
   1c8f0:	6810      	ldr	r0, [r2, #0]
   1c8f2:	000a      	movs	r2, r1
   1c8f4:	0021      	movs	r1, r4
   1c8f6:	f7ff f8e5 	bl	1bac4 <_vfiprintf_r>
   1c8fa:	bd10      	pop	{r4, pc}
   1c8fc:	10010df0 	.word	0x10010df0

0001c900 <__sbprintf>:
   1c900:	b570      	push	{r4, r5, r6, lr}
   1c902:	0006      	movs	r6, r0
   1c904:	2002      	movs	r0, #2
   1c906:	4c1a      	ldr	r4, [pc, #104]	; (1c970 <__sbprintf+0x70>)
   1c908:	44a5      	add	sp, r4
   1c90a:	000c      	movs	r4, r1
   1c90c:	8989      	ldrh	r1, [r1, #12]
   1c90e:	4381      	bics	r1, r0
   1c910:	4668      	mov	r0, sp
   1c912:	8181      	strh	r1, [r0, #12]
   1c914:	6e61      	ldr	r1, [r4, #100]	; 0x64
   1c916:	9119      	str	r1, [sp, #100]	; 0x64
   1c918:	89e1      	ldrh	r1, [r4, #14]
   1c91a:	81c1      	strh	r1, [r0, #14]
   1c91c:	69e1      	ldr	r1, [r4, #28]
   1c91e:	0030      	movs	r0, r6
   1c920:	9107      	str	r1, [sp, #28]
   1c922:	6a61      	ldr	r1, [r4, #36]	; 0x24
   1c924:	9109      	str	r1, [sp, #36]	; 0x24
   1c926:	a91a      	add	r1, sp, #104	; 0x68
   1c928:	9100      	str	r1, [sp, #0]
   1c92a:	9104      	str	r1, [sp, #16]
   1c92c:	2180      	movs	r1, #128	; 0x80
   1c92e:	00c9      	lsls	r1, r1, #3
   1c930:	9102      	str	r1, [sp, #8]
   1c932:	9105      	str	r1, [sp, #20]
   1c934:	2100      	movs	r1, #0
   1c936:	9106      	str	r1, [sp, #24]
   1c938:	4669      	mov	r1, sp
   1c93a:	f7ff f8c3 	bl	1bac4 <_vfiprintf_r>
   1c93e:	1e05      	subs	r5, r0, #0
   1c940:	db05      	blt.n	1c94e <__sbprintf+0x4e>
   1c942:	4669      	mov	r1, sp
   1c944:	0030      	movs	r0, r6
   1c946:	f7fb ff9f 	bl	18888 <_fflush_r>
   1c94a:	2800      	cmp	r0, #0
   1c94c:	d10c      	bne.n	1c968 <__sbprintf+0x68>
   1c94e:	466b      	mov	r3, sp
   1c950:	899b      	ldrh	r3, [r3, #12]
   1c952:	065b      	lsls	r3, r3, #25
   1c954:	d503      	bpl.n	1c95e <__sbprintf+0x5e>
   1c956:	2340      	movs	r3, #64	; 0x40
   1c958:	89a2      	ldrh	r2, [r4, #12]
   1c95a:	4313      	orrs	r3, r2
   1c95c:	81a3      	strh	r3, [r4, #12]
   1c95e:	0028      	movs	r0, r5
   1c960:	238d      	movs	r3, #141	; 0x8d
   1c962:	00db      	lsls	r3, r3, #3
   1c964:	449d      	add	sp, r3
   1c966:	bd70      	pop	{r4, r5, r6, pc}
   1c968:	2501      	movs	r5, #1
   1c96a:	426d      	negs	r5, r5
   1c96c:	e7ef      	b.n	1c94e <__sbprintf+0x4e>
   1c96e:	46c0      	nop			; (mov r8, r8)
   1c970:	fffffb98 	.word	0xfffffb98

0001c974 <_write_r>:
   1c974:	b570      	push	{r4, r5, r6, lr}
   1c976:	0005      	movs	r5, r0
   1c978:	0008      	movs	r0, r1
   1c97a:	0011      	movs	r1, r2
   1c97c:	2200      	movs	r2, #0
   1c97e:	4c06      	ldr	r4, [pc, #24]	; (1c998 <_write_r+0x24>)
   1c980:	6022      	str	r2, [r4, #0]
   1c982:	001a      	movs	r2, r3
   1c984:	f7e5 fe42 	bl	260c <_write>
   1c988:	1c43      	adds	r3, r0, #1
   1c98a:	d000      	beq.n	1c98e <_write_r+0x1a>
   1c98c:	bd70      	pop	{r4, r5, r6, pc}
   1c98e:	6823      	ldr	r3, [r4, #0]
   1c990:	2b00      	cmp	r3, #0
   1c992:	d0fb      	beq.n	1c98c <_write_r+0x18>
   1c994:	602b      	str	r3, [r5, #0]
   1c996:	e7f9      	b.n	1c98c <_write_r+0x18>
   1c998:	100128a8 	.word	0x100128a8

0001c99c <_calloc_r>:
   1c99c:	b510      	push	{r4, lr}
   1c99e:	4351      	muls	r1, r2
   1c9a0:	f7f8 fd44 	bl	1542c <_malloc_r>
   1c9a4:	1e04      	subs	r4, r0, #0
   1c9a6:	d026      	beq.n	1c9f6 <_calloc_r+0x5a>
   1c9a8:	0003      	movs	r3, r0
   1c9aa:	3b08      	subs	r3, #8
   1c9ac:	685a      	ldr	r2, [r3, #4]
   1c9ae:	2303      	movs	r3, #3
   1c9b0:	439a      	bics	r2, r3
   1c9b2:	3a04      	subs	r2, #4
   1c9b4:	2a24      	cmp	r2, #36	; 0x24
   1c9b6:	d816      	bhi.n	1c9e6 <_calloc_r+0x4a>
   1c9b8:	0003      	movs	r3, r0
   1c9ba:	2a13      	cmp	r2, #19
   1c9bc:	d90d      	bls.n	1c9da <_calloc_r+0x3e>
   1c9be:	2100      	movs	r1, #0
   1c9c0:	3308      	adds	r3, #8
   1c9c2:	6001      	str	r1, [r0, #0]
   1c9c4:	6041      	str	r1, [r0, #4]
   1c9c6:	2a1b      	cmp	r2, #27
   1c9c8:	d907      	bls.n	1c9da <_calloc_r+0x3e>
   1c9ca:	6081      	str	r1, [r0, #8]
   1c9cc:	60c1      	str	r1, [r0, #12]
   1c9ce:	2a24      	cmp	r2, #36	; 0x24
   1c9d0:	d10e      	bne.n	1c9f0 <_calloc_r+0x54>
   1c9d2:	0003      	movs	r3, r0
   1c9d4:	6101      	str	r1, [r0, #16]
   1c9d6:	3318      	adds	r3, #24
   1c9d8:	6141      	str	r1, [r0, #20]
   1c9da:	2200      	movs	r2, #0
   1c9dc:	0020      	movs	r0, r4
   1c9de:	601a      	str	r2, [r3, #0]
   1c9e0:	605a      	str	r2, [r3, #4]
   1c9e2:	609a      	str	r2, [r3, #8]
   1c9e4:	bd10      	pop	{r4, pc}
   1c9e6:	2100      	movs	r1, #0
   1c9e8:	f7f9 f830 	bl	15a4c <memset>
   1c9ec:	0020      	movs	r0, r4
   1c9ee:	e7f9      	b.n	1c9e4 <_calloc_r+0x48>
   1c9f0:	0003      	movs	r3, r0
   1c9f2:	3310      	adds	r3, #16
   1c9f4:	e7f1      	b.n	1c9da <_calloc_r+0x3e>
   1c9f6:	2000      	movs	r0, #0
   1c9f8:	e7f4      	b.n	1c9e4 <_calloc_r+0x48>
   1c9fa:	46c0      	nop			; (mov r8, r8)

0001c9fc <_close_r>:
   1c9fc:	2300      	movs	r3, #0
   1c9fe:	b570      	push	{r4, r5, r6, lr}
   1ca00:	4c06      	ldr	r4, [pc, #24]	; (1ca1c <_close_r+0x20>)
   1ca02:	0005      	movs	r5, r0
   1ca04:	0008      	movs	r0, r1
   1ca06:	6023      	str	r3, [r4, #0]
   1ca08:	f7e5 fdfd 	bl	2606 <_close>
   1ca0c:	1c43      	adds	r3, r0, #1
   1ca0e:	d000      	beq.n	1ca12 <_close_r+0x16>
   1ca10:	bd70      	pop	{r4, r5, r6, pc}
   1ca12:	6823      	ldr	r3, [r4, #0]
   1ca14:	2b00      	cmp	r3, #0
   1ca16:	d0fb      	beq.n	1ca10 <_close_r+0x14>
   1ca18:	602b      	str	r3, [r5, #0]
   1ca1a:	e7f9      	b.n	1ca10 <_close_r+0x14>
   1ca1c:	100128a8 	.word	0x100128a8

0001ca20 <_fclose_r>:
   1ca20:	b570      	push	{r4, r5, r6, lr}
   1ca22:	0005      	movs	r5, r0
   1ca24:	1e0c      	subs	r4, r1, #0
   1ca26:	d008      	beq.n	1ca3a <_fclose_r+0x1a>
   1ca28:	2800      	cmp	r0, #0
   1ca2a:	d002      	beq.n	1ca32 <_fclose_r+0x12>
   1ca2c:	6b83      	ldr	r3, [r0, #56]	; 0x38
   1ca2e:	2b00      	cmp	r3, #0
   1ca30:	d031      	beq.n	1ca96 <_fclose_r+0x76>
   1ca32:	220c      	movs	r2, #12
   1ca34:	5ea3      	ldrsh	r3, [r4, r2]
   1ca36:	2b00      	cmp	r3, #0
   1ca38:	d101      	bne.n	1ca3e <_fclose_r+0x1e>
   1ca3a:	2000      	movs	r0, #0
   1ca3c:	bd70      	pop	{r4, r5, r6, pc}
   1ca3e:	0021      	movs	r1, r4
   1ca40:	0028      	movs	r0, r5
   1ca42:	f7fb fe79 	bl	18738 <__sflush_r>
   1ca46:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
   1ca48:	0006      	movs	r6, r0
   1ca4a:	2b00      	cmp	r3, #0
   1ca4c:	d004      	beq.n	1ca58 <_fclose_r+0x38>
   1ca4e:	69e1      	ldr	r1, [r4, #28]
   1ca50:	0028      	movs	r0, r5
   1ca52:	4798      	blx	r3
   1ca54:	2800      	cmp	r0, #0
   1ca56:	db21      	blt.n	1ca9c <_fclose_r+0x7c>
   1ca58:	89a3      	ldrh	r3, [r4, #12]
   1ca5a:	061b      	lsls	r3, r3, #24
   1ca5c:	d421      	bmi.n	1caa2 <_fclose_r+0x82>
   1ca5e:	6b21      	ldr	r1, [r4, #48]	; 0x30
   1ca60:	2900      	cmp	r1, #0
   1ca62:	d008      	beq.n	1ca76 <_fclose_r+0x56>
   1ca64:	0023      	movs	r3, r4
   1ca66:	3340      	adds	r3, #64	; 0x40
   1ca68:	4299      	cmp	r1, r3
   1ca6a:	d002      	beq.n	1ca72 <_fclose_r+0x52>
   1ca6c:	0028      	movs	r0, r5
   1ca6e:	f7fc f89d 	bl	18bac <_free_r>
   1ca72:	2300      	movs	r3, #0
   1ca74:	6323      	str	r3, [r4, #48]	; 0x30
   1ca76:	6c61      	ldr	r1, [r4, #68]	; 0x44
   1ca78:	2900      	cmp	r1, #0
   1ca7a:	d004      	beq.n	1ca86 <_fclose_r+0x66>
   1ca7c:	0028      	movs	r0, r5
   1ca7e:	f7fc f895 	bl	18bac <_free_r>
   1ca82:	2300      	movs	r3, #0
   1ca84:	6463      	str	r3, [r4, #68]	; 0x44
   1ca86:	f7fc f821 	bl	18acc <__sfp_lock_acquire>
   1ca8a:	2300      	movs	r3, #0
   1ca8c:	81a3      	strh	r3, [r4, #12]
   1ca8e:	f7fc f81f 	bl	18ad0 <__sfp_lock_release>
   1ca92:	0030      	movs	r0, r6
   1ca94:	e7d2      	b.n	1ca3c <_fclose_r+0x1c>
   1ca96:	f7fc f811 	bl	18abc <__sinit>
   1ca9a:	e7ca      	b.n	1ca32 <_fclose_r+0x12>
   1ca9c:	2601      	movs	r6, #1
   1ca9e:	4276      	negs	r6, r6
   1caa0:	e7da      	b.n	1ca58 <_fclose_r+0x38>
   1caa2:	6921      	ldr	r1, [r4, #16]
   1caa4:	0028      	movs	r0, r5
   1caa6:	f7fc f881 	bl	18bac <_free_r>
   1caaa:	e7d8      	b.n	1ca5e <_fclose_r+0x3e>

0001caac <fclose>:
   1caac:	b510      	push	{r4, lr}
   1caae:	4b03      	ldr	r3, [pc, #12]	; (1cabc <fclose+0x10>)
   1cab0:	0001      	movs	r1, r0
   1cab2:	6818      	ldr	r0, [r3, #0]
   1cab4:	f7ff ffb4 	bl	1ca20 <_fclose_r>
   1cab8:	bd10      	pop	{r4, pc}
   1caba:	46c0      	nop			; (mov r8, r8)
   1cabc:	10010df0 	.word	0x10010df0

0001cac0 <__fputwc>:
   1cac0:	b5f0      	push	{r4, r5, r6, r7, lr}
   1cac2:	464f      	mov	r7, r9
   1cac4:	4646      	mov	r6, r8
   1cac6:	b4c0      	push	{r6, r7}
   1cac8:	b085      	sub	sp, #20
   1caca:	4680      	mov	r8, r0
   1cacc:	4689      	mov	r9, r1
   1cace:	0014      	movs	r4, r2
   1cad0:	f000 f8c8 	bl	1cc64 <__locale_mb_cur_max>
   1cad4:	2801      	cmp	r0, #1
   1cad6:	d031      	beq.n	1cb3c <__fputwc+0x7c>
   1cad8:	0023      	movs	r3, r4
   1cada:	af03      	add	r7, sp, #12
   1cadc:	335c      	adds	r3, #92	; 0x5c
   1cade:	464a      	mov	r2, r9
   1cae0:	0039      	movs	r1, r7
   1cae2:	4640      	mov	r0, r8
   1cae4:	f001 f8c2 	bl	1dc6c <_wcrtomb_r>
   1cae8:	0006      	movs	r6, r0
   1caea:	1c43      	adds	r3, r0, #1
   1caec:	d021      	beq.n	1cb32 <__fputwc+0x72>
   1caee:	2800      	cmp	r0, #0
   1caf0:	d030      	beq.n	1cb54 <__fputwc+0x94>
   1caf2:	7839      	ldrb	r1, [r7, #0]
   1caf4:	2500      	movs	r5, #0
   1caf6:	e007      	b.n	1cb08 <__fputwc+0x48>
   1caf8:	6823      	ldr	r3, [r4, #0]
   1cafa:	1c5a      	adds	r2, r3, #1
   1cafc:	6022      	str	r2, [r4, #0]
   1cafe:	7019      	strb	r1, [r3, #0]
   1cb00:	3501      	adds	r5, #1
   1cb02:	42b5      	cmp	r5, r6
   1cb04:	d226      	bcs.n	1cb54 <__fputwc+0x94>
   1cb06:	5d79      	ldrb	r1, [r7, r5]
   1cb08:	68a3      	ldr	r3, [r4, #8]
   1cb0a:	3b01      	subs	r3, #1
   1cb0c:	60a3      	str	r3, [r4, #8]
   1cb0e:	2b00      	cmp	r3, #0
   1cb10:	daf2      	bge.n	1caf8 <__fputwc+0x38>
   1cb12:	69a2      	ldr	r2, [r4, #24]
   1cb14:	4293      	cmp	r3, r2
   1cb16:	db01      	blt.n	1cb1c <__fputwc+0x5c>
   1cb18:	290a      	cmp	r1, #10
   1cb1a:	d1ed      	bne.n	1caf8 <__fputwc+0x38>
   1cb1c:	0022      	movs	r2, r4
   1cb1e:	4640      	mov	r0, r8
   1cb20:	f001 f83c 	bl	1db9c <__swbuf_r>
   1cb24:	1c43      	adds	r3, r0, #1
   1cb26:	d1eb      	bne.n	1cb00 <__fputwc+0x40>
   1cb28:	b005      	add	sp, #20
   1cb2a:	bc0c      	pop	{r2, r3}
   1cb2c:	4690      	mov	r8, r2
   1cb2e:	4699      	mov	r9, r3
   1cb30:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1cb32:	2340      	movs	r3, #64	; 0x40
   1cb34:	89a2      	ldrh	r2, [r4, #12]
   1cb36:	4313      	orrs	r3, r2
   1cb38:	81a3      	strh	r3, [r4, #12]
   1cb3a:	e7f5      	b.n	1cb28 <__fputwc+0x68>
   1cb3c:	464b      	mov	r3, r9
   1cb3e:	3b01      	subs	r3, #1
   1cb40:	2bfe      	cmp	r3, #254	; 0xfe
   1cb42:	d8c9      	bhi.n	1cad8 <__fputwc+0x18>
   1cb44:	466a      	mov	r2, sp
   1cb46:	464b      	mov	r3, r9
   1cb48:	71d3      	strb	r3, [r2, #7]
   1cb4a:	79d1      	ldrb	r1, [r2, #7]
   1cb4c:	af03      	add	r7, sp, #12
   1cb4e:	7039      	strb	r1, [r7, #0]
   1cb50:	2601      	movs	r6, #1
   1cb52:	e7cf      	b.n	1caf4 <__fputwc+0x34>
   1cb54:	4648      	mov	r0, r9
   1cb56:	e7e7      	b.n	1cb28 <__fputwc+0x68>

0001cb58 <_fputwc_r>:
   1cb58:	b510      	push	{r4, lr}
   1cb5a:	240c      	movs	r4, #12
   1cb5c:	5f13      	ldrsh	r3, [r2, r4]
   1cb5e:	2480      	movs	r4, #128	; 0x80
   1cb60:	01a4      	lsls	r4, r4, #6
   1cb62:	4223      	tst	r3, r4
   1cb64:	d104      	bne.n	1cb70 <_fputwc_r+0x18>
   1cb66:	4323      	orrs	r3, r4
   1cb68:	8193      	strh	r3, [r2, #12]
   1cb6a:	6e53      	ldr	r3, [r2, #100]	; 0x64
   1cb6c:	431c      	orrs	r4, r3
   1cb6e:	6654      	str	r4, [r2, #100]	; 0x64
   1cb70:	f7ff ffa6 	bl	1cac0 <__fputwc>
   1cb74:	bd10      	pop	{r4, pc}
   1cb76:	46c0      	nop			; (mov r8, r8)

0001cb78 <fputwc>:
   1cb78:	4b0f      	ldr	r3, [pc, #60]	; (1cbb8 <fputwc+0x40>)
   1cb7a:	b570      	push	{r4, r5, r6, lr}
   1cb7c:	681d      	ldr	r5, [r3, #0]
   1cb7e:	0006      	movs	r6, r0
   1cb80:	000c      	movs	r4, r1
   1cb82:	2d00      	cmp	r5, #0
   1cb84:	d002      	beq.n	1cb8c <fputwc+0x14>
   1cb86:	6bab      	ldr	r3, [r5, #56]	; 0x38
   1cb88:	2b00      	cmp	r3, #0
   1cb8a:	d010      	beq.n	1cbae <fputwc+0x36>
   1cb8c:	220c      	movs	r2, #12
   1cb8e:	5ea3      	ldrsh	r3, [r4, r2]
   1cb90:	2280      	movs	r2, #128	; 0x80
   1cb92:	0192      	lsls	r2, r2, #6
   1cb94:	4213      	tst	r3, r2
   1cb96:	d104      	bne.n	1cba2 <fputwc+0x2a>
   1cb98:	4313      	orrs	r3, r2
   1cb9a:	81a3      	strh	r3, [r4, #12]
   1cb9c:	6e63      	ldr	r3, [r4, #100]	; 0x64
   1cb9e:	431a      	orrs	r2, r3
   1cba0:	6662      	str	r2, [r4, #100]	; 0x64
   1cba2:	0031      	movs	r1, r6
   1cba4:	0028      	movs	r0, r5
   1cba6:	0022      	movs	r2, r4
   1cba8:	f7ff ff8a 	bl	1cac0 <__fputwc>
   1cbac:	bd70      	pop	{r4, r5, r6, pc}
   1cbae:	0028      	movs	r0, r5
   1cbb0:	f7fb ff84 	bl	18abc <__sinit>
   1cbb4:	e7ea      	b.n	1cb8c <fputwc+0x14>
   1cbb6:	46c0      	nop			; (mov r8, r8)
   1cbb8:	10010df0 	.word	0x10010df0

0001cbbc <_fstat_r>:
   1cbbc:	2300      	movs	r3, #0
   1cbbe:	b570      	push	{r4, r5, r6, lr}
   1cbc0:	4c07      	ldr	r4, [pc, #28]	; (1cbe0 <_fstat_r+0x24>)
   1cbc2:	0005      	movs	r5, r0
   1cbc4:	0008      	movs	r0, r1
   1cbc6:	0011      	movs	r1, r2
   1cbc8:	6023      	str	r3, [r4, #0]
   1cbca:	f7e5 fd17 	bl	25fc <_fstat>
   1cbce:	1c43      	adds	r3, r0, #1
   1cbd0:	d000      	beq.n	1cbd4 <_fstat_r+0x18>
   1cbd2:	bd70      	pop	{r4, r5, r6, pc}
   1cbd4:	6823      	ldr	r3, [r4, #0]
   1cbd6:	2b00      	cmp	r3, #0
   1cbd8:	d0fb      	beq.n	1cbd2 <_fstat_r+0x16>
   1cbda:	602b      	str	r3, [r5, #0]
   1cbdc:	e7f9      	b.n	1cbd2 <_fstat_r+0x16>
   1cbde:	46c0      	nop			; (mov r8, r8)
   1cbe0:	100128a8 	.word	0x100128a8

0001cbe4 <_isatty_r>:
   1cbe4:	2300      	movs	r3, #0
   1cbe6:	b570      	push	{r4, r5, r6, lr}
   1cbe8:	4c06      	ldr	r4, [pc, #24]	; (1cc04 <_isatty_r+0x20>)
   1cbea:	0005      	movs	r5, r0
   1cbec:	0008      	movs	r0, r1
   1cbee:	6023      	str	r3, [r4, #0]
   1cbf0:	f7e5 fd21 	bl	2636 <_isatty>
   1cbf4:	1c43      	adds	r3, r0, #1
   1cbf6:	d000      	beq.n	1cbfa <_isatty_r+0x16>
   1cbf8:	bd70      	pop	{r4, r5, r6, pc}
   1cbfa:	6823      	ldr	r3, [r4, #0]
   1cbfc:	2b00      	cmp	r3, #0
   1cbfe:	d0fb      	beq.n	1cbf8 <_isatty_r+0x14>
   1cc00:	602b      	str	r3, [r5, #0]
   1cc02:	e7f9      	b.n	1cbf8 <_isatty_r+0x14>
   1cc04:	100128a8 	.word	0x100128a8

0001cc08 <__get_current_locale>:
   1cc08:	4b03      	ldr	r3, [pc, #12]	; (1cc18 <__get_current_locale+0x10>)
   1cc0a:	681b      	ldr	r3, [r3, #0]
   1cc0c:	6b58      	ldr	r0, [r3, #52]	; 0x34
   1cc0e:	2800      	cmp	r0, #0
   1cc10:	d000      	beq.n	1cc14 <__get_current_locale+0xc>
   1cc12:	4770      	bx	lr
   1cc14:	4801      	ldr	r0, [pc, #4]	; (1cc1c <__get_current_locale+0x14>)
   1cc16:	e7fc      	b.n	1cc12 <__get_current_locale+0xa>
   1cc18:	10010df0 	.word	0x10010df0
   1cc1c:	10010df4 	.word	0x10010df4

0001cc20 <_setlocale_r>:
   1cc20:	b570      	push	{r4, r5, r6, lr}
   1cc22:	1e15      	subs	r5, r2, #0
   1cc24:	d016      	beq.n	1cc54 <_setlocale_r+0x34>
   1cc26:	490c      	ldr	r1, [pc, #48]	; (1cc58 <_setlocale_r+0x38>)
   1cc28:	0010      	movs	r0, r2
   1cc2a:	f000 f897 	bl	1cd5c <strcmp>
   1cc2e:	4c0b      	ldr	r4, [pc, #44]	; (1cc5c <_setlocale_r+0x3c>)
   1cc30:	2800      	cmp	r0, #0
   1cc32:	d101      	bne.n	1cc38 <_setlocale_r+0x18>
   1cc34:	0020      	movs	r0, r4
   1cc36:	bd70      	pop	{r4, r5, r6, pc}
   1cc38:	0021      	movs	r1, r4
   1cc3a:	0028      	movs	r0, r5
   1cc3c:	f000 f88e 	bl	1cd5c <strcmp>
   1cc40:	2800      	cmp	r0, #0
   1cc42:	d0f7      	beq.n	1cc34 <_setlocale_r+0x14>
   1cc44:	4906      	ldr	r1, [pc, #24]	; (1cc60 <_setlocale_r+0x40>)
   1cc46:	0028      	movs	r0, r5
   1cc48:	f000 f888 	bl	1cd5c <strcmp>
   1cc4c:	2800      	cmp	r0, #0
   1cc4e:	d0f1      	beq.n	1cc34 <_setlocale_r+0x14>
   1cc50:	2000      	movs	r0, #0
   1cc52:	e7f0      	b.n	1cc36 <_setlocale_r+0x16>
   1cc54:	4c01      	ldr	r4, [pc, #4]	; (1cc5c <_setlocale_r+0x3c>)
   1cc56:	e7ed      	b.n	1cc34 <_setlocale_r+0x14>
   1cc58:	000231d4 	.word	0x000231d4
   1cc5c:	000231d0 	.word	0x000231d0
   1cc60:	00022d58 	.word	0x00022d58

0001cc64 <__locale_mb_cur_max>:
   1cc64:	4b05      	ldr	r3, [pc, #20]	; (1cc7c <__locale_mb_cur_max+0x18>)
   1cc66:	681b      	ldr	r3, [r3, #0]
   1cc68:	6b5b      	ldr	r3, [r3, #52]	; 0x34
   1cc6a:	2b00      	cmp	r3, #0
   1cc6c:	d003      	beq.n	1cc76 <__locale_mb_cur_max+0x12>
   1cc6e:	2294      	movs	r2, #148	; 0x94
   1cc70:	0052      	lsls	r2, r2, #1
   1cc72:	5c98      	ldrb	r0, [r3, r2]
   1cc74:	4770      	bx	lr
   1cc76:	4b02      	ldr	r3, [pc, #8]	; (1cc80 <__locale_mb_cur_max+0x1c>)
   1cc78:	e7f9      	b.n	1cc6e <__locale_mb_cur_max+0xa>
   1cc7a:	46c0      	nop			; (mov r8, r8)
   1cc7c:	10010df0 	.word	0x10010df0
   1cc80:	10010df4 	.word	0x10010df4

0001cc84 <__locale_ctype_ptr_l>:
   1cc84:	23ec      	movs	r3, #236	; 0xec
   1cc86:	58c0      	ldr	r0, [r0, r3]
   1cc88:	4770      	bx	lr
   1cc8a:	46c0      	nop			; (mov r8, r8)

0001cc8c <__locale_ctype_ptr>:
   1cc8c:	4b03      	ldr	r3, [pc, #12]	; (1cc9c <__locale_ctype_ptr+0x10>)
   1cc8e:	b510      	push	{r4, lr}
   1cc90:	6818      	ldr	r0, [r3, #0]
   1cc92:	f7ff ffb9 	bl	1cc08 <__get_current_locale>
   1cc96:	23ec      	movs	r3, #236	; 0xec
   1cc98:	58c0      	ldr	r0, [r0, r3]
   1cc9a:	bd10      	pop	{r4, pc}
   1cc9c:	10010df0 	.word	0x10010df0

0001cca0 <setlocale>:
   1cca0:	b510      	push	{r4, lr}
   1cca2:	4b04      	ldr	r3, [pc, #16]	; (1ccb4 <setlocale+0x14>)
   1cca4:	000a      	movs	r2, r1
   1cca6:	681b      	ldr	r3, [r3, #0]
   1cca8:	0001      	movs	r1, r0
   1ccaa:	0018      	movs	r0, r3
   1ccac:	f7ff ffb8 	bl	1cc20 <_setlocale_r>
   1ccb0:	bd10      	pop	{r4, pc}
   1ccb2:	46c0      	nop			; (mov r8, r8)
   1ccb4:	10010df0 	.word	0x10010df0

0001ccb8 <_lseek_r>:
   1ccb8:	b570      	push	{r4, r5, r6, lr}
   1ccba:	0005      	movs	r5, r0
   1ccbc:	0008      	movs	r0, r1
   1ccbe:	0011      	movs	r1, r2
   1ccc0:	2200      	movs	r2, #0
   1ccc2:	4c06      	ldr	r4, [pc, #24]	; (1ccdc <_lseek_r+0x24>)
   1ccc4:	6022      	str	r2, [r4, #0]
   1ccc6:	001a      	movs	r2, r3
   1ccc8:	f7e5 fcb7 	bl	263a <_lseek>
   1cccc:	1c43      	adds	r3, r0, #1
   1ccce:	d000      	beq.n	1ccd2 <_lseek_r+0x1a>
   1ccd0:	bd70      	pop	{r4, r5, r6, pc}
   1ccd2:	6823      	ldr	r3, [r4, #0]
   1ccd4:	2b00      	cmp	r3, #0
   1ccd6:	d0fb      	beq.n	1ccd0 <_lseek_r+0x18>
   1ccd8:	602b      	str	r3, [r5, #0]
   1ccda:	e7f9      	b.n	1ccd0 <_lseek_r+0x18>
   1ccdc:	100128a8 	.word	0x100128a8

0001cce0 <_mbtowc_r>:
   1cce0:	b530      	push	{r4, r5, lr}
   1cce2:	4c07      	ldr	r4, [pc, #28]	; (1cd00 <_mbtowc_r+0x20>)
   1cce4:	b083      	sub	sp, #12
   1cce6:	6824      	ldr	r4, [r4, #0]
   1cce8:	6b64      	ldr	r4, [r4, #52]	; 0x34
   1ccea:	2c00      	cmp	r4, #0
   1ccec:	d006      	beq.n	1ccfc <_mbtowc_r+0x1c>
   1ccee:	9d06      	ldr	r5, [sp, #24]
   1ccf0:	9500      	str	r5, [sp, #0]
   1ccf2:	25e4      	movs	r5, #228	; 0xe4
   1ccf4:	5964      	ldr	r4, [r4, r5]
   1ccf6:	47a0      	blx	r4
   1ccf8:	b003      	add	sp, #12
   1ccfa:	bd30      	pop	{r4, r5, pc}
   1ccfc:	4c01      	ldr	r4, [pc, #4]	; (1cd04 <_mbtowc_r+0x24>)
   1ccfe:	e7f6      	b.n	1ccee <_mbtowc_r+0xe>
   1cd00:	10010df0 	.word	0x10010df0
   1cd04:	10010df4 	.word	0x10010df4

0001cd08 <__ascii_mbtowc>:
   1cd08:	b082      	sub	sp, #8
   1cd0a:	2900      	cmp	r1, #0
   1cd0c:	d00a      	beq.n	1cd24 <__ascii_mbtowc+0x1c>
   1cd0e:	2a00      	cmp	r2, #0
   1cd10:	d00b      	beq.n	1cd2a <__ascii_mbtowc+0x22>
   1cd12:	2b00      	cmp	r3, #0
   1cd14:	d00b      	beq.n	1cd2e <__ascii_mbtowc+0x26>
   1cd16:	7813      	ldrb	r3, [r2, #0]
   1cd18:	600b      	str	r3, [r1, #0]
   1cd1a:	7810      	ldrb	r0, [r2, #0]
   1cd1c:	1e43      	subs	r3, r0, #1
   1cd1e:	4198      	sbcs	r0, r3
   1cd20:	b002      	add	sp, #8
   1cd22:	4770      	bx	lr
   1cd24:	a901      	add	r1, sp, #4
   1cd26:	2a00      	cmp	r2, #0
   1cd28:	d1f3      	bne.n	1cd12 <__ascii_mbtowc+0xa>
   1cd2a:	2000      	movs	r0, #0
   1cd2c:	e7f8      	b.n	1cd20 <__ascii_mbtowc+0x18>
   1cd2e:	2002      	movs	r0, #2
   1cd30:	4240      	negs	r0, r0
   1cd32:	e7f5      	b.n	1cd20 <__ascii_mbtowc+0x18>

0001cd34 <_read_r>:
   1cd34:	b570      	push	{r4, r5, r6, lr}
   1cd36:	0005      	movs	r5, r0
   1cd38:	0008      	movs	r0, r1
   1cd3a:	0011      	movs	r1, r2
   1cd3c:	2200      	movs	r2, #0
   1cd3e:	4c06      	ldr	r4, [pc, #24]	; (1cd58 <_read_r+0x24>)
   1cd40:	6022      	str	r2, [r4, #0]
   1cd42:	001a      	movs	r2, r3
   1cd44:	f7e5 fc7b 	bl	263e <_read>
   1cd48:	1c43      	adds	r3, r0, #1
   1cd4a:	d000      	beq.n	1cd4e <_read_r+0x1a>
   1cd4c:	bd70      	pop	{r4, r5, r6, pc}
   1cd4e:	6823      	ldr	r3, [r4, #0]
   1cd50:	2b00      	cmp	r3, #0
   1cd52:	d0fb      	beq.n	1cd4c <_read_r+0x18>
   1cd54:	602b      	str	r3, [r5, #0]
   1cd56:	e7f9      	b.n	1cd4c <_read_r+0x18>
   1cd58:	100128a8 	.word	0x100128a8

0001cd5c <strcmp>:
   1cd5c:	4602      	mov	r2, r0
   1cd5e:	b570      	push	{r4, r5, r6, lr}
   1cd60:	430a      	orrs	r2, r1
   1cd62:	0792      	lsls	r2, r2, #30
   1cd64:	d12a      	bne.n	1cdbc <strcmp+0x60>
   1cd66:	4d1e      	ldr	r5, [pc, #120]	; (1cde0 <strcmp+0x84>)
   1cd68:	01ee      	lsls	r6, r5, #7
   1cd6a:	c804      	ldmia	r0!, {r2}
   1cd6c:	c908      	ldmia	r1!, {r3}
   1cd6e:	1b54      	subs	r4, r2, r5
   1cd70:	4394      	bics	r4, r2
   1cd72:	4034      	ands	r4, r6
   1cd74:	d017      	beq.n	1cda6 <strcmp+0x4a>
   1cd76:	b2d0      	uxtb	r0, r2
   1cd78:	b2d9      	uxtb	r1, r3
   1cd7a:	1a40      	subs	r0, r0, r1
   1cd7c:	0621      	lsls	r1, r4, #24
   1cd7e:	4301      	orrs	r1, r0
   1cd80:	d110      	bne.n	1cda4 <strcmp+0x48>
   1cd82:	b290      	uxth	r0, r2
   1cd84:	b299      	uxth	r1, r3
   1cd86:	1a40      	subs	r0, r0, r1
   1cd88:	0421      	lsls	r1, r4, #16
   1cd8a:	4301      	orrs	r1, r0
   1cd8c:	d10a      	bne.n	1cda4 <strcmp+0x48>
   1cd8e:	0210      	lsls	r0, r2, #8
   1cd90:	0219      	lsls	r1, r3, #8
   1cd92:	0a00      	lsrs	r0, r0, #8
   1cd94:	0a09      	lsrs	r1, r1, #8
   1cd96:	1a40      	subs	r0, r0, r1
   1cd98:	0221      	lsls	r1, r4, #8
   1cd9a:	4301      	orrs	r1, r0
   1cd9c:	d102      	bne.n	1cda4 <strcmp+0x48>
   1cd9e:	0e10      	lsrs	r0, r2, #24
   1cda0:	0e19      	lsrs	r1, r3, #24
   1cda2:	1a40      	subs	r0, r0, r1
   1cda4:	bd70      	pop	{r4, r5, r6, pc}
   1cda6:	429a      	cmp	r2, r3
   1cda8:	d0df      	beq.n	1cd6a <strcmp+0xe>
   1cdaa:	ba10      	rev	r0, r2
   1cdac:	ba19      	rev	r1, r3
   1cdae:	4288      	cmp	r0, r1
   1cdb0:	d901      	bls.n	1cdb6 <strcmp+0x5a>
   1cdb2:	2001      	movs	r0, #1
   1cdb4:	bd70      	pop	{r4, r5, r6, pc}
   1cdb6:	2000      	movs	r0, #0
   1cdb8:	43c0      	mvns	r0, r0
   1cdba:	bd70      	pop	{r4, r5, r6, pc}
   1cdbc:	7802      	ldrb	r2, [r0, #0]
   1cdbe:	780b      	ldrb	r3, [r1, #0]
   1cdc0:	3001      	adds	r0, #1
   1cdc2:	3101      	adds	r1, #1
   1cdc4:	2a00      	cmp	r2, #0
   1cdc6:	d009      	beq.n	1cddc <strcmp+0x80>
   1cdc8:	429a      	cmp	r2, r3
   1cdca:	d107      	bne.n	1cddc <strcmp+0x80>
   1cdcc:	7802      	ldrb	r2, [r0, #0]
   1cdce:	780b      	ldrb	r3, [r1, #0]
   1cdd0:	3001      	adds	r0, #1
   1cdd2:	3101      	adds	r1, #1
   1cdd4:	2a00      	cmp	r2, #0
   1cdd6:	d001      	beq.n	1cddc <strcmp+0x80>
   1cdd8:	429a      	cmp	r2, r3
   1cdda:	d0ef      	beq.n	1cdbc <strcmp+0x60>
   1cddc:	1ad0      	subs	r0, r2, r3
   1cdde:	bd70      	pop	{r4, r5, r6, pc}
   1cde0:	01010101 	.word	0x01010101

0001cde4 <__ssprint_r>:
   1cde4:	b5f0      	push	{r4, r5, r6, r7, lr}
   1cde6:	4656      	mov	r6, sl
   1cde8:	465f      	mov	r7, fp
   1cdea:	464d      	mov	r5, r9
   1cdec:	4644      	mov	r4, r8
   1cdee:	b4f0      	push	{r4, r5, r6, r7}
   1cdf0:	6893      	ldr	r3, [r2, #8]
   1cdf2:	b083      	sub	sp, #12
   1cdf4:	9001      	str	r0, [sp, #4]
   1cdf6:	000e      	movs	r6, r1
   1cdf8:	4692      	mov	sl, r2
   1cdfa:	2b00      	cmp	r3, #0
   1cdfc:	d078      	beq.n	1cef0 <__ssprint_r+0x10c>
   1cdfe:	6813      	ldr	r3, [r2, #0]
   1ce00:	2400      	movs	r4, #0
   1ce02:	4699      	mov	r9, r3
   1ce04:	2300      	movs	r3, #0
   1ce06:	6808      	ldr	r0, [r1, #0]
   1ce08:	469b      	mov	fp, r3
   1ce0a:	464f      	mov	r7, r9
   1ce0c:	688b      	ldr	r3, [r1, #8]
   1ce0e:	2c00      	cmp	r4, #0
   1ce10:	d049      	beq.n	1cea6 <__ssprint_r+0xc2>
   1ce12:	001d      	movs	r5, r3
   1ce14:	4698      	mov	r8, r3
   1ce16:	429c      	cmp	r4, r3
   1ce18:	d34f      	bcc.n	1ceba <__ssprint_r+0xd6>
   1ce1a:	2390      	movs	r3, #144	; 0x90
   1ce1c:	89b2      	ldrh	r2, [r6, #12]
   1ce1e:	00db      	lsls	r3, r3, #3
   1ce20:	421a      	tst	r2, r3
   1ce22:	d02f      	beq.n	1ce84 <__ssprint_r+0xa0>
   1ce24:	6931      	ldr	r1, [r6, #16]
   1ce26:	1a43      	subs	r3, r0, r1
   1ce28:	4699      	mov	r9, r3
   1ce2a:	6973      	ldr	r3, [r6, #20]
   1ce2c:	0058      	lsls	r0, r3, #1
   1ce2e:	18c3      	adds	r3, r0, r3
   1ce30:	0fd8      	lsrs	r0, r3, #31
   1ce32:	18c3      	adds	r3, r0, r3
   1ce34:	105b      	asrs	r3, r3, #1
   1ce36:	4698      	mov	r8, r3
   1ce38:	1c63      	adds	r3, r4, #1
   1ce3a:	444b      	add	r3, r9
   1ce3c:	4640      	mov	r0, r8
   1ce3e:	4543      	cmp	r3, r8
   1ce40:	d901      	bls.n	1ce46 <__ssprint_r+0x62>
   1ce42:	4698      	mov	r8, r3
   1ce44:	0018      	movs	r0, r3
   1ce46:	2380      	movs	r3, #128	; 0x80
   1ce48:	00db      	lsls	r3, r3, #3
   1ce4a:	421a      	tst	r2, r3
   1ce4c:	d038      	beq.n	1cec0 <__ssprint_r+0xdc>
   1ce4e:	0001      	movs	r1, r0
   1ce50:	9801      	ldr	r0, [sp, #4]
   1ce52:	f7f8 faeb 	bl	1542c <_malloc_r>
   1ce56:	1e05      	subs	r5, r0, #0
   1ce58:	d055      	beq.n	1cf06 <__ssprint_r+0x122>
   1ce5a:	464a      	mov	r2, r9
   1ce5c:	6931      	ldr	r1, [r6, #16]
   1ce5e:	f7f8 fdb7 	bl	159d0 <memcpy>
   1ce62:	89b2      	ldrh	r2, [r6, #12]
   1ce64:	4b2a      	ldr	r3, [pc, #168]	; (1cf10 <__ssprint_r+0x12c>)
   1ce66:	4013      	ands	r3, r2
   1ce68:	2280      	movs	r2, #128	; 0x80
   1ce6a:	4313      	orrs	r3, r2
   1ce6c:	81b3      	strh	r3, [r6, #12]
   1ce6e:	4643      	mov	r3, r8
   1ce70:	0028      	movs	r0, r5
   1ce72:	464a      	mov	r2, r9
   1ce74:	6135      	str	r5, [r6, #16]
   1ce76:	46a0      	mov	r8, r4
   1ce78:	0025      	movs	r5, r4
   1ce7a:	4448      	add	r0, r9
   1ce7c:	6173      	str	r3, [r6, #20]
   1ce7e:	1a9b      	subs	r3, r3, r2
   1ce80:	6030      	str	r0, [r6, #0]
   1ce82:	60b3      	str	r3, [r6, #8]
   1ce84:	4642      	mov	r2, r8
   1ce86:	4659      	mov	r1, fp
   1ce88:	f7fc fa22 	bl	192d0 <memmove>
   1ce8c:	6832      	ldr	r2, [r6, #0]
   1ce8e:	68b3      	ldr	r3, [r6, #8]
   1ce90:	4442      	add	r2, r8
   1ce92:	6032      	str	r2, [r6, #0]
   1ce94:	0010      	movs	r0, r2
   1ce96:	4652      	mov	r2, sl
   1ce98:	6892      	ldr	r2, [r2, #8]
   1ce9a:	1b5b      	subs	r3, r3, r5
   1ce9c:	1b14      	subs	r4, r2, r4
   1ce9e:	4652      	mov	r2, sl
   1cea0:	60b3      	str	r3, [r6, #8]
   1cea2:	6094      	str	r4, [r2, #8]
   1cea4:	d024      	beq.n	1cef0 <__ssprint_r+0x10c>
   1cea6:	683a      	ldr	r2, [r7, #0]
   1cea8:	687c      	ldr	r4, [r7, #4]
   1ceaa:	4693      	mov	fp, r2
   1ceac:	3708      	adds	r7, #8
   1ceae:	2c00      	cmp	r4, #0
   1ceb0:	d0f9      	beq.n	1cea6 <__ssprint_r+0xc2>
   1ceb2:	001d      	movs	r5, r3
   1ceb4:	4698      	mov	r8, r3
   1ceb6:	429c      	cmp	r4, r3
   1ceb8:	d2af      	bcs.n	1ce1a <__ssprint_r+0x36>
   1ceba:	0025      	movs	r5, r4
   1cebc:	46a0      	mov	r8, r4
   1cebe:	e7e1      	b.n	1ce84 <__ssprint_r+0xa0>
   1cec0:	0002      	movs	r2, r0
   1cec2:	9801      	ldr	r0, [sp, #4]
   1cec4:	f7fc ff12 	bl	19cec <_realloc_r>
   1cec8:	1e05      	subs	r5, r0, #0
   1ceca:	d1d0      	bne.n	1ce6e <__ssprint_r+0x8a>
   1cecc:	9c01      	ldr	r4, [sp, #4]
   1cece:	6931      	ldr	r1, [r6, #16]
   1ced0:	0020      	movs	r0, r4
   1ced2:	f7fb fe6b 	bl	18bac <_free_r>
   1ced6:	230c      	movs	r3, #12
   1ced8:	6023      	str	r3, [r4, #0]
   1ceda:	2340      	movs	r3, #64	; 0x40
   1cedc:	89b2      	ldrh	r2, [r6, #12]
   1cede:	2001      	movs	r0, #1
   1cee0:	4313      	orrs	r3, r2
   1cee2:	81b3      	strh	r3, [r6, #12]
   1cee4:	4652      	mov	r2, sl
   1cee6:	2300      	movs	r3, #0
   1cee8:	4240      	negs	r0, r0
   1ceea:	6093      	str	r3, [r2, #8]
   1ceec:	6053      	str	r3, [r2, #4]
   1ceee:	e003      	b.n	1cef8 <__ssprint_r+0x114>
   1cef0:	2300      	movs	r3, #0
   1cef2:	4652      	mov	r2, sl
   1cef4:	2000      	movs	r0, #0
   1cef6:	6053      	str	r3, [r2, #4]
   1cef8:	b003      	add	sp, #12
   1cefa:	bc3c      	pop	{r2, r3, r4, r5}
   1cefc:	4690      	mov	r8, r2
   1cefe:	4699      	mov	r9, r3
   1cf00:	46a2      	mov	sl, r4
   1cf02:	46ab      	mov	fp, r5
   1cf04:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1cf06:	230c      	movs	r3, #12
   1cf08:	9a01      	ldr	r2, [sp, #4]
   1cf0a:	6013      	str	r3, [r2, #0]
   1cf0c:	e7e5      	b.n	1ceda <__ssprint_r+0xf6>
   1cf0e:	46c0      	nop			; (mov r8, r8)
   1cf10:	fffffb7f 	.word	0xfffffb7f

0001cf14 <_svfiprintf_r>:
   1cf14:	b5f0      	push	{r4, r5, r6, r7, lr}
   1cf16:	465f      	mov	r7, fp
   1cf18:	4644      	mov	r4, r8
   1cf1a:	4656      	mov	r6, sl
   1cf1c:	464d      	mov	r5, r9
   1cf1e:	b4f0      	push	{r4, r5, r6, r7}
   1cf20:	b0ad      	sub	sp, #180	; 0xb4
   1cf22:	9008      	str	r0, [sp, #32]
   1cf24:	9309      	str	r3, [sp, #36]	; 0x24
   1cf26:	898b      	ldrh	r3, [r1, #12]
   1cf28:	468b      	mov	fp, r1
   1cf2a:	4690      	mov	r8, r2
   1cf2c:	061b      	lsls	r3, r3, #24
   1cf2e:	d504      	bpl.n	1cf3a <_svfiprintf_r+0x26>
   1cf30:	690b      	ldr	r3, [r1, #16]
   1cf32:	2b00      	cmp	r3, #0
   1cf34:	d101      	bne.n	1cf3a <_svfiprintf_r+0x26>
   1cf36:	f000 fdae 	bl	1da96 <_svfiprintf_r+0xb82>
   1cf3a:	ab1c      	add	r3, sp, #112	; 0x70
   1cf3c:	930f      	str	r3, [sp, #60]	; 0x3c
   1cf3e:	2300      	movs	r3, #0
   1cf40:	46c2      	mov	sl, r8
   1cf42:	9311      	str	r3, [sp, #68]	; 0x44
   1cf44:	9310      	str	r3, [sp, #64]	; 0x40
   1cf46:	af1c      	add	r7, sp, #112	; 0x70
   1cf48:	9303      	str	r3, [sp, #12]
   1cf4a:	4653      	mov	r3, sl
   1cf4c:	781b      	ldrb	r3, [r3, #0]
   1cf4e:	4654      	mov	r4, sl
   1cf50:	2b00      	cmp	r3, #0
   1cf52:	d01f      	beq.n	1cf94 <_svfiprintf_r+0x80>
   1cf54:	2b25      	cmp	r3, #37	; 0x25
   1cf56:	d102      	bne.n	1cf5e <_svfiprintf_r+0x4a>
   1cf58:	e01c      	b.n	1cf94 <_svfiprintf_r+0x80>
   1cf5a:	2b25      	cmp	r3, #37	; 0x25
   1cf5c:	d003      	beq.n	1cf66 <_svfiprintf_r+0x52>
   1cf5e:	3401      	adds	r4, #1
   1cf60:	7823      	ldrb	r3, [r4, #0]
   1cf62:	2b00      	cmp	r3, #0
   1cf64:	d1f9      	bne.n	1cf5a <_svfiprintf_r+0x46>
   1cf66:	4653      	mov	r3, sl
   1cf68:	1ae5      	subs	r5, r4, r3
   1cf6a:	d013      	beq.n	1cf94 <_svfiprintf_r+0x80>
   1cf6c:	4653      	mov	r3, sl
   1cf6e:	603b      	str	r3, [r7, #0]
   1cf70:	9b11      	ldr	r3, [sp, #68]	; 0x44
   1cf72:	607d      	str	r5, [r7, #4]
   1cf74:	195b      	adds	r3, r3, r5
   1cf76:	9311      	str	r3, [sp, #68]	; 0x44
   1cf78:	9b10      	ldr	r3, [sp, #64]	; 0x40
   1cf7a:	9301      	str	r3, [sp, #4]
   1cf7c:	3301      	adds	r3, #1
   1cf7e:	9310      	str	r3, [sp, #64]	; 0x40
   1cf80:	2b07      	cmp	r3, #7
   1cf82:	dd01      	ble.n	1cf88 <_svfiprintf_r+0x74>
   1cf84:	f000 fc5c 	bl	1d840 <_svfiprintf_r+0x92c>
   1cf88:	3708      	adds	r7, #8
   1cf8a:	9b03      	ldr	r3, [sp, #12]
   1cf8c:	469c      	mov	ip, r3
   1cf8e:	44ac      	add	ip, r5
   1cf90:	4663      	mov	r3, ip
   1cf92:	9303      	str	r3, [sp, #12]
   1cf94:	7823      	ldrb	r3, [r4, #0]
   1cf96:	2b00      	cmp	r3, #0
   1cf98:	d101      	bne.n	1cf9e <_svfiprintf_r+0x8a>
   1cf9a:	f000 fd68 	bl	1da6e <_svfiprintf_r+0xb5a>
   1cf9e:	1c63      	adds	r3, r4, #1
   1cfa0:	469a      	mov	sl, r3
   1cfa2:	2300      	movs	r3, #0
   1cfa4:	aa0c      	add	r2, sp, #48	; 0x30
   1cfa6:	71d3      	strb	r3, [r2, #7]
   1cfa8:	2201      	movs	r2, #1
   1cfaa:	4252      	negs	r2, r2
   1cfac:	9202      	str	r2, [sp, #8]
   1cfae:	2200      	movs	r2, #0
   1cfb0:	2000      	movs	r0, #0
   1cfb2:	9205      	str	r2, [sp, #20]
   1cfb4:	4691      	mov	r9, r2
   1cfb6:	3240      	adds	r2, #64	; 0x40
   1cfb8:	4690      	mov	r8, r2
   1cfba:	3240      	adds	r2, #64	; 0x40
   1cfbc:	7863      	ldrb	r3, [r4, #1]
   1cfbe:	4694      	mov	ip, r2
   1cfc0:	2400      	movs	r4, #0
   1cfc2:	4652      	mov	r2, sl
   1cfc4:	2520      	movs	r5, #32
   1cfc6:	2601      	movs	r6, #1
   1cfc8:	4682      	mov	sl, r0
   1cfca:	3201      	adds	r2, #1
   1cfcc:	0019      	movs	r1, r3
   1cfce:	3920      	subs	r1, #32
   1cfd0:	2958      	cmp	r1, #88	; 0x58
   1cfd2:	d900      	bls.n	1cfd6 <_svfiprintf_r+0xc2>
   1cfd4:	e294      	b.n	1d500 <_svfiprintf_r+0x5ec>
   1cfd6:	48dc      	ldr	r0, [pc, #880]	; (1d348 <_svfiprintf_r+0x434>)
   1cfd8:	0089      	lsls	r1, r1, #2
   1cfda:	5841      	ldr	r1, [r0, r1]
   1cfdc:	468f      	mov	pc, r1
   1cfde:	9b09      	ldr	r3, [sp, #36]	; 0x24
   1cfe0:	1d19      	adds	r1, r3, #4
   1cfe2:	681b      	ldr	r3, [r3, #0]
   1cfe4:	9305      	str	r3, [sp, #20]
   1cfe6:	2b00      	cmp	r3, #0
   1cfe8:	db01      	blt.n	1cfee <_svfiprintf_r+0xda>
   1cfea:	f000 fc8c 	bl	1d906 <_svfiprintf_r+0x9f2>
   1cfee:	9b05      	ldr	r3, [sp, #20]
   1cff0:	9109      	str	r1, [sp, #36]	; 0x24
   1cff2:	425b      	negs	r3, r3
   1cff4:	9305      	str	r3, [sp, #20]
   1cff6:	2304      	movs	r3, #4
   1cff8:	4649      	mov	r1, r9
   1cffa:	4319      	orrs	r1, r3
   1cffc:	4689      	mov	r9, r1
   1cffe:	7813      	ldrb	r3, [r2, #0]
   1d000:	e7e3      	b.n	1cfca <_svfiprintf_r+0xb6>
   1d002:	2430      	movs	r4, #48	; 0x30
   1d004:	9b09      	ldr	r3, [sp, #36]	; 0x24
   1d006:	4692      	mov	sl, r2
   1d008:	aa0e      	add	r2, sp, #56	; 0x38
   1d00a:	7014      	strb	r4, [r2, #0]
   1d00c:	1d18      	adds	r0, r3, #4
   1d00e:	3448      	adds	r4, #72	; 0x48
   1d010:	681b      	ldr	r3, [r3, #0]
   1d012:	7054      	strb	r4, [r2, #1]
   1d014:	2200      	movs	r2, #0
   1d016:	9306      	str	r3, [sp, #24]
   1d018:	2300      	movs	r3, #0
   1d01a:	4649      	mov	r1, r9
   1d01c:	ac0c      	add	r4, sp, #48	; 0x30
   1d01e:	71e2      	strb	r2, [r4, #7]
   1d020:	9a02      	ldr	r2, [sp, #8]
   1d022:	9307      	str	r3, [sp, #28]
   1d024:	3302      	adds	r3, #2
   1d026:	4319      	orrs	r1, r3
   1d028:	2a00      	cmp	r2, #0
   1d02a:	da01      	bge.n	1d030 <_svfiprintf_r+0x11c>
   1d02c:	f000 fd1c 	bl	1da68 <_svfiprintf_r+0xb54>
   1d030:	2280      	movs	r2, #128	; 0x80
   1d032:	4649      	mov	r1, r9
   1d034:	4391      	bics	r1, r2
   1d036:	000a      	movs	r2, r1
   1d038:	431a      	orrs	r2, r3
   1d03a:	9b06      	ldr	r3, [sp, #24]
   1d03c:	4691      	mov	r9, r2
   1d03e:	9009      	str	r0, [sp, #36]	; 0x24
   1d040:	2b00      	cmp	r3, #0
   1d042:	d101      	bne.n	1d048 <_svfiprintf_r+0x134>
   1d044:	f000 fc6d 	bl	1d922 <_svfiprintf_r+0xa0e>
   1d048:	2400      	movs	r4, #0
   1d04a:	49c0      	ldr	r1, [pc, #768]	; (1d34c <_svfiprintf_r+0x438>)
   1d04c:	e06c      	b.n	1d128 <_svfiprintf_r+0x214>
   1d04e:	4650      	mov	r0, sl
   1d050:	4692      	mov	sl, r2
   1d052:	2800      	cmp	r0, #0
   1d054:	d001      	beq.n	1d05a <_svfiprintf_r+0x146>
   1d056:	f000 fd6f 	bl	1db38 <_svfiprintf_r+0xc24>
   1d05a:	2320      	movs	r3, #32
   1d05c:	464a      	mov	r2, r9
   1d05e:	4013      	ands	r3, r2
   1d060:	d100      	bne.n	1d064 <_svfiprintf_r+0x150>
   1d062:	e1b1      	b.n	1d3c8 <_svfiprintf_r+0x4b4>
   1d064:	2207      	movs	r2, #7
   1d066:	9b09      	ldr	r3, [sp, #36]	; 0x24
   1d068:	a80c      	add	r0, sp, #48	; 0x30
   1d06a:	3307      	adds	r3, #7
   1d06c:	4393      	bics	r3, r2
   1d06e:	3201      	adds	r2, #1
   1d070:	4694      	mov	ip, r2
   1d072:	449c      	add	ip, r3
   1d074:	4662      	mov	r2, ip
   1d076:	685c      	ldr	r4, [r3, #4]
   1d078:	681b      	ldr	r3, [r3, #0]
   1d07a:	0019      	movs	r1, r3
   1d07c:	2300      	movs	r3, #0
   1d07e:	9209      	str	r2, [sp, #36]	; 0x24
   1d080:	0022      	movs	r2, r4
   1d082:	71c3      	strb	r3, [r0, #7]
   1d084:	9b02      	ldr	r3, [sp, #8]
   1d086:	9106      	str	r1, [sp, #24]
   1d088:	9207      	str	r2, [sp, #28]
   1d08a:	2b00      	cmp	r3, #0
   1d08c:	da01      	bge.n	1d092 <_svfiprintf_r+0x17e>
   1d08e:	f000 fcb9 	bl	1da04 <_svfiprintf_r+0xaf0>
   1d092:	4648      	mov	r0, r9
   1d094:	2380      	movs	r3, #128	; 0x80
   1d096:	4398      	bics	r0, r3
   1d098:	4681      	mov	r9, r0
   1d09a:	4321      	orrs	r1, r4
   1d09c:	d100      	bne.n	1d0a0 <_svfiprintf_r+0x18c>
   1d09e:	e1ae      	b.n	1d3fe <_svfiprintf_r+0x4ea>
   1d0a0:	2400      	movs	r4, #0
   1d0a2:	e1b5      	b.n	1d410 <_svfiprintf_r+0x4fc>
   1d0a4:	464b      	mov	r3, r9
   1d0a6:	4333      	orrs	r3, r6
   1d0a8:	4699      	mov	r9, r3
   1d0aa:	7813      	ldrb	r3, [r2, #0]
   1d0ac:	e78d      	b.n	1cfca <_svfiprintf_r+0xb6>
   1d0ae:	7813      	ldrb	r3, [r2, #0]
   1d0b0:	2c00      	cmp	r4, #0
   1d0b2:	d18a      	bne.n	1cfca <_svfiprintf_r+0xb6>
   1d0b4:	2101      	movs	r1, #1
   1d0b6:	3420      	adds	r4, #32
   1d0b8:	468a      	mov	sl, r1
   1d0ba:	e786      	b.n	1cfca <_svfiprintf_r+0xb6>
   1d0bc:	4650      	mov	r0, sl
   1d0be:	4692      	mov	sl, r2
   1d0c0:	2800      	cmp	r0, #0
   1d0c2:	d001      	beq.n	1d0c8 <_svfiprintf_r+0x1b4>
   1d0c4:	f000 fd55 	bl	1db72 <_svfiprintf_r+0xc5e>
   1d0c8:	464a      	mov	r2, r9
   1d0ca:	49a0      	ldr	r1, [pc, #640]	; (1d34c <_svfiprintf_r+0x438>)
   1d0cc:	0692      	lsls	r2, r2, #26
   1d0ce:	d400      	bmi.n	1d0d2 <_svfiprintf_r+0x1be>
   1d0d0:	e1ce      	b.n	1d470 <_svfiprintf_r+0x55c>
   1d0d2:	2007      	movs	r0, #7
   1d0d4:	9a09      	ldr	r2, [sp, #36]	; 0x24
   1d0d6:	3207      	adds	r2, #7
   1d0d8:	4382      	bics	r2, r0
   1d0da:	3001      	adds	r0, #1
   1d0dc:	4684      	mov	ip, r0
   1d0de:	6814      	ldr	r4, [r2, #0]
   1d0e0:	6855      	ldr	r5, [r2, #4]
   1d0e2:	4494      	add	ip, r2
   1d0e4:	4660      	mov	r0, ip
   1d0e6:	2201      	movs	r2, #1
   1d0e8:	9009      	str	r0, [sp, #36]	; 0x24
   1d0ea:	4648      	mov	r0, r9
   1d0ec:	9406      	str	r4, [sp, #24]
   1d0ee:	9507      	str	r5, [sp, #28]
   1d0f0:	4002      	ands	r2, r0
   1d0f2:	d100      	bne.n	1d0f6 <_svfiprintf_r+0x1e2>
   1d0f4:	e1cc      	b.n	1d490 <_svfiprintf_r+0x57c>
   1d0f6:	9c06      	ldr	r4, [sp, #24]
   1d0f8:	9d07      	ldr	r5, [sp, #28]
   1d0fa:	0022      	movs	r2, r4
   1d0fc:	432a      	orrs	r2, r5
   1d0fe:	d001      	beq.n	1d104 <_svfiprintf_r+0x1f0>
   1d100:	f000 fc42 	bl	1d988 <_svfiprintf_r+0xa74>
   1d104:	ab0c      	add	r3, sp, #48	; 0x30
   1d106:	71da      	strb	r2, [r3, #7]
   1d108:	9b02      	ldr	r3, [sp, #8]
   1d10a:	2b00      	cmp	r3, #0
   1d10c:	db07      	blt.n	1d11e <_svfiprintf_r+0x20a>
   1d10e:	464a      	mov	r2, r9
   1d110:	2380      	movs	r3, #128	; 0x80
   1d112:	439a      	bics	r2, r3
   1d114:	4691      	mov	r9, r2
   1d116:	9b02      	ldr	r3, [sp, #8]
   1d118:	2400      	movs	r4, #0
   1d11a:	2b00      	cmp	r3, #0
   1d11c:	d04f      	beq.n	1d1be <_svfiprintf_r+0x2aa>
   1d11e:	2200      	movs	r2, #0
   1d120:	2300      	movs	r3, #0
   1d122:	2400      	movs	r4, #0
   1d124:	9206      	str	r2, [sp, #24]
   1d126:	9307      	str	r3, [sp, #28]
   1d128:	9a06      	ldr	r2, [sp, #24]
   1d12a:	9b07      	ldr	r3, [sp, #28]
   1d12c:	46a4      	mov	ip, r4
   1d12e:	200f      	movs	r0, #15
   1d130:	46b8      	mov	r8, r7
   1d132:	000c      	movs	r4, r1
   1d134:	ad1c      	add	r5, sp, #112	; 0x70
   1d136:	0001      	movs	r1, r0
   1d138:	4011      	ands	r1, r2
   1d13a:	5c61      	ldrb	r1, [r4, r1]
   1d13c:	3d01      	subs	r5, #1
   1d13e:	071f      	lsls	r7, r3, #28
   1d140:	7029      	strb	r1, [r5, #0]
   1d142:	0911      	lsrs	r1, r2, #4
   1d144:	091e      	lsrs	r6, r3, #4
   1d146:	430f      	orrs	r7, r1
   1d148:	0033      	movs	r3, r6
   1d14a:	003e      	movs	r6, r7
   1d14c:	003a      	movs	r2, r7
   1d14e:	431e      	orrs	r6, r3
   1d150:	d1f1      	bne.n	1d136 <_svfiprintf_r+0x222>
   1d152:	9206      	str	r2, [sp, #24]
   1d154:	9307      	str	r3, [sp, #28]
   1d156:	ab1c      	add	r3, sp, #112	; 0x70
   1d158:	1b5b      	subs	r3, r3, r5
   1d15a:	4647      	mov	r7, r8
   1d15c:	4664      	mov	r4, ip
   1d15e:	9304      	str	r3, [sp, #16]
   1d160:	e031      	b.n	1d1c6 <_svfiprintf_r+0x2b2>
   1d162:	4650      	mov	r0, sl
   1d164:	4692      	mov	sl, r2
   1d166:	2800      	cmp	r0, #0
   1d168:	d001      	beq.n	1d16e <_svfiprintf_r+0x25a>
   1d16a:	f000 fd10 	bl	1db8e <_svfiprintf_r+0xc7a>
   1d16e:	2320      	movs	r3, #32
   1d170:	464a      	mov	r2, r9
   1d172:	4013      	ands	r3, r2
   1d174:	d100      	bne.n	1d178 <_svfiprintf_r+0x264>
   1d176:	e0fc      	b.n	1d372 <_svfiprintf_r+0x45e>
   1d178:	2207      	movs	r2, #7
   1d17a:	9b09      	ldr	r3, [sp, #36]	; 0x24
   1d17c:	a80c      	add	r0, sp, #48	; 0x30
   1d17e:	3307      	adds	r3, #7
   1d180:	4393      	bics	r3, r2
   1d182:	3201      	adds	r2, #1
   1d184:	4694      	mov	ip, r2
   1d186:	449c      	add	ip, r3
   1d188:	4662      	mov	r2, ip
   1d18a:	685c      	ldr	r4, [r3, #4]
   1d18c:	681b      	ldr	r3, [r3, #0]
   1d18e:	0019      	movs	r1, r3
   1d190:	2300      	movs	r3, #0
   1d192:	9209      	str	r2, [sp, #36]	; 0x24
   1d194:	0022      	movs	r2, r4
   1d196:	71c3      	strb	r3, [r0, #7]
   1d198:	9b02      	ldr	r3, [sp, #8]
   1d19a:	9106      	str	r1, [sp, #24]
   1d19c:	9207      	str	r2, [sp, #28]
   1d19e:	2b00      	cmp	r3, #0
   1d1a0:	da00      	bge.n	1d1a4 <_svfiprintf_r+0x290>
   1d1a2:	e225      	b.n	1d5f0 <_svfiprintf_r+0x6dc>
   1d1a4:	4648      	mov	r0, r9
   1d1a6:	2380      	movs	r3, #128	; 0x80
   1d1a8:	4398      	bics	r0, r3
   1d1aa:	4321      	orrs	r1, r4
   1d1ac:	4681      	mov	r9, r0
   1d1ae:	2400      	movs	r4, #0
   1d1b0:	2900      	cmp	r1, #0
   1d1b2:	d000      	beq.n	1d1b6 <_svfiprintf_r+0x2a2>
   1d1b4:	e0a4      	b.n	1d300 <_svfiprintf_r+0x3ec>
   1d1b6:	9b02      	ldr	r3, [sp, #8]
   1d1b8:	2b00      	cmp	r3, #0
   1d1ba:	d000      	beq.n	1d1be <_svfiprintf_r+0x2aa>
   1d1bc:	e21f      	b.n	1d5fe <_svfiprintf_r+0x6ea>
   1d1be:	2300      	movs	r3, #0
   1d1c0:	ad1c      	add	r5, sp, #112	; 0x70
   1d1c2:	9302      	str	r3, [sp, #8]
   1d1c4:	9304      	str	r3, [sp, #16]
   1d1c6:	9b02      	ldr	r3, [sp, #8]
   1d1c8:	9904      	ldr	r1, [sp, #16]
   1d1ca:	9301      	str	r3, [sp, #4]
   1d1cc:	428b      	cmp	r3, r1
   1d1ce:	da00      	bge.n	1d1d2 <_svfiprintf_r+0x2be>
   1d1d0:	9101      	str	r1, [sp, #4]
   1d1d2:	1e63      	subs	r3, r4, #1
   1d1d4:	419c      	sbcs	r4, r3
   1d1d6:	9b01      	ldr	r3, [sp, #4]
   1d1d8:	469c      	mov	ip, r3
   1d1da:	44a4      	add	ip, r4
   1d1dc:	4663      	mov	r3, ip
   1d1de:	9301      	str	r3, [sp, #4]
   1d1e0:	e017      	b.n	1d212 <_svfiprintf_r+0x2fe>
   1d1e2:	2101      	movs	r1, #1
   1d1e4:	7813      	ldrb	r3, [r2, #0]
   1d1e6:	468a      	mov	sl, r1
   1d1e8:	242b      	movs	r4, #43	; 0x2b
   1d1ea:	e6ee      	b.n	1cfca <_svfiprintf_r+0xb6>
   1d1ec:	4692      	mov	sl, r2
   1d1ee:	9a09      	ldr	r2, [sp, #36]	; 0x24
   1d1f0:	ad12      	add	r5, sp, #72	; 0x48
   1d1f2:	6813      	ldr	r3, [r2, #0]
   1d1f4:	a90c      	add	r1, sp, #48	; 0x30
   1d1f6:	9301      	str	r3, [sp, #4]
   1d1f8:	466b      	mov	r3, sp
   1d1fa:	791b      	ldrb	r3, [r3, #4]
   1d1fc:	702b      	strb	r3, [r5, #0]
   1d1fe:	2300      	movs	r3, #0
   1d200:	71cb      	strb	r3, [r1, #7]
   1d202:	0013      	movs	r3, r2
   1d204:	3304      	adds	r3, #4
   1d206:	9309      	str	r3, [sp, #36]	; 0x24
   1d208:	2301      	movs	r3, #1
   1d20a:	9301      	str	r3, [sp, #4]
   1d20c:	9304      	str	r3, [sp, #16]
   1d20e:	2300      	movs	r3, #0
   1d210:	9302      	str	r3, [sp, #8]
   1d212:	2302      	movs	r3, #2
   1d214:	464a      	mov	r2, r9
   1d216:	401a      	ands	r2, r3
   1d218:	920a      	str	r2, [sp, #40]	; 0x28
   1d21a:	d002      	beq.n	1d222 <_svfiprintf_r+0x30e>
   1d21c:	9b01      	ldr	r3, [sp, #4]
   1d21e:	3302      	adds	r3, #2
   1d220:	9301      	str	r3, [sp, #4]
   1d222:	2384      	movs	r3, #132	; 0x84
   1d224:	464a      	mov	r2, r9
   1d226:	401a      	ands	r2, r3
   1d228:	920b      	str	r2, [sp, #44]	; 0x2c
   1d22a:	d000      	beq.n	1d22e <_svfiprintf_r+0x31a>
   1d22c:	e1f8      	b.n	1d620 <_svfiprintf_r+0x70c>
   1d22e:	9b05      	ldr	r3, [sp, #20]
   1d230:	9a01      	ldr	r2, [sp, #4]
   1d232:	1a9c      	subs	r4, r3, r2
   1d234:	2c00      	cmp	r4, #0
   1d236:	dc00      	bgt.n	1d23a <_svfiprintf_r+0x326>
   1d238:	e1f2      	b.n	1d620 <_svfiprintf_r+0x70c>
   1d23a:	9811      	ldr	r0, [sp, #68]	; 0x44
   1d23c:	9b10      	ldr	r3, [sp, #64]	; 0x40
   1d23e:	4e44      	ldr	r6, [pc, #272]	; (1d350 <_svfiprintf_r+0x43c>)
   1d240:	2c10      	cmp	r4, #16
   1d242:	dd24      	ble.n	1d28e <_svfiprintf_r+0x37a>
   1d244:	2210      	movs	r2, #16
   1d246:	4690      	mov	r8, r2
   1d248:	003a      	movs	r2, r7
   1d24a:	465f      	mov	r7, fp
   1d24c:	46ab      	mov	fp, r5
   1d24e:	9d08      	ldr	r5, [sp, #32]
   1d250:	e003      	b.n	1d25a <_svfiprintf_r+0x346>
   1d252:	3c10      	subs	r4, #16
   1d254:	3208      	adds	r2, #8
   1d256:	2c10      	cmp	r4, #16
   1d258:	dd16      	ble.n	1d288 <_svfiprintf_r+0x374>
   1d25a:	4641      	mov	r1, r8
   1d25c:	3010      	adds	r0, #16
   1d25e:	3301      	adds	r3, #1
   1d260:	6016      	str	r6, [r2, #0]
   1d262:	6051      	str	r1, [r2, #4]
   1d264:	9011      	str	r0, [sp, #68]	; 0x44
   1d266:	9310      	str	r3, [sp, #64]	; 0x40
   1d268:	2b07      	cmp	r3, #7
   1d26a:	ddf2      	ble.n	1d252 <_svfiprintf_r+0x33e>
   1d26c:	aa0f      	add	r2, sp, #60	; 0x3c
   1d26e:	0039      	movs	r1, r7
   1d270:	0028      	movs	r0, r5
   1d272:	f7ff fdb7 	bl	1cde4 <__ssprint_r>
   1d276:	2800      	cmp	r0, #0
   1d278:	d000      	beq.n	1d27c <_svfiprintf_r+0x368>
   1d27a:	e289      	b.n	1d790 <_svfiprintf_r+0x87c>
   1d27c:	3c10      	subs	r4, #16
   1d27e:	9811      	ldr	r0, [sp, #68]	; 0x44
   1d280:	9b10      	ldr	r3, [sp, #64]	; 0x40
   1d282:	aa1c      	add	r2, sp, #112	; 0x70
   1d284:	2c10      	cmp	r4, #16
   1d286:	dce8      	bgt.n	1d25a <_svfiprintf_r+0x346>
   1d288:	465d      	mov	r5, fp
   1d28a:	46bb      	mov	fp, r7
   1d28c:	0017      	movs	r7, r2
   1d28e:	1820      	adds	r0, r4, r0
   1d290:	3301      	adds	r3, #1
   1d292:	603e      	str	r6, [r7, #0]
   1d294:	607c      	str	r4, [r7, #4]
   1d296:	9011      	str	r0, [sp, #68]	; 0x44
   1d298:	9310      	str	r3, [sp, #64]	; 0x40
   1d29a:	2b07      	cmp	r3, #7
   1d29c:	dd00      	ble.n	1d2a0 <_svfiprintf_r+0x38c>
   1d29e:	e326      	b.n	1d8ee <_svfiprintf_r+0x9da>
   1d2a0:	3708      	adds	r7, #8
   1d2a2:	e1bf      	b.n	1d624 <_svfiprintf_r+0x710>
   1d2a4:	4650      	mov	r0, sl
   1d2a6:	4692      	mov	sl, r2
   1d2a8:	2800      	cmp	r0, #0
   1d2aa:	d001      	beq.n	1d2b0 <_svfiprintf_r+0x39c>
   1d2ac:	f000 fc5d 	bl	1db6a <_svfiprintf_r+0xc56>
   1d2b0:	464a      	mov	r2, r9
   1d2b2:	2310      	movs	r3, #16
   1d2b4:	431a      	orrs	r2, r3
   1d2b6:	4691      	mov	r9, r2
   1d2b8:	464b      	mov	r3, r9
   1d2ba:	069b      	lsls	r3, r3, #26
   1d2bc:	d400      	bmi.n	1d2c0 <_svfiprintf_r+0x3ac>
   1d2be:	e2ec      	b.n	1d89a <_svfiprintf_r+0x986>
   1d2c0:	2307      	movs	r3, #7
   1d2c2:	9a09      	ldr	r2, [sp, #36]	; 0x24
   1d2c4:	3207      	adds	r2, #7
   1d2c6:	439a      	bics	r2, r3
   1d2c8:	3301      	adds	r3, #1
   1d2ca:	469c      	mov	ip, r3
   1d2cc:	4494      	add	ip, r2
   1d2ce:	4663      	mov	r3, ip
   1d2d0:	9309      	str	r3, [sp, #36]	; 0x24
   1d2d2:	6853      	ldr	r3, [r2, #4]
   1d2d4:	6812      	ldr	r2, [r2, #0]
   1d2d6:	9307      	str	r3, [sp, #28]
   1d2d8:	9206      	str	r2, [sp, #24]
   1d2da:	2b00      	cmp	r3, #0
   1d2dc:	da00      	bge.n	1d2e0 <_svfiprintf_r+0x3cc>
   1d2de:	e2ee      	b.n	1d8be <_svfiprintf_r+0x9aa>
   1d2e0:	ab0c      	add	r3, sp, #48	; 0x30
   1d2e2:	79dc      	ldrb	r4, [r3, #7]
   1d2e4:	9b02      	ldr	r3, [sp, #8]
   1d2e6:	2b00      	cmp	r3, #0
   1d2e8:	da00      	bge.n	1d2ec <_svfiprintf_r+0x3d8>
   1d2ea:	e182      	b.n	1d5f2 <_svfiprintf_r+0x6de>
   1d2ec:	2380      	movs	r3, #128	; 0x80
   1d2ee:	464a      	mov	r2, r9
   1d2f0:	439a      	bics	r2, r3
   1d2f2:	4691      	mov	r9, r2
   1d2f4:	9a06      	ldr	r2, [sp, #24]
   1d2f6:	9b07      	ldr	r3, [sp, #28]
   1d2f8:	0011      	movs	r1, r2
   1d2fa:	4319      	orrs	r1, r3
   1d2fc:	d100      	bne.n	1d300 <_svfiprintf_r+0x3ec>
   1d2fe:	e75a      	b.n	1d1b6 <_svfiprintf_r+0x2a2>
   1d300:	9b07      	ldr	r3, [sp, #28]
   1d302:	2b00      	cmp	r3, #0
   1d304:	d100      	bne.n	1d308 <_svfiprintf_r+0x3f4>
   1d306:	e377      	b.n	1d9f8 <_svfiprintf_r+0xae4>
   1d308:	ad1c      	add	r5, sp, #112	; 0x70
   1d30a:	46b8      	mov	r8, r7
   1d30c:	9e06      	ldr	r6, [sp, #24]
   1d30e:	9f07      	ldr	r7, [sp, #28]
   1d310:	0030      	movs	r0, r6
   1d312:	0039      	movs	r1, r7
   1d314:	220a      	movs	r2, #10
   1d316:	2300      	movs	r3, #0
   1d318:	f000 fdb8 	bl	1de8c <__aeabi_uldivmod>
   1d31c:	3d01      	subs	r5, #1
   1d31e:	3230      	adds	r2, #48	; 0x30
   1d320:	702a      	strb	r2, [r5, #0]
   1d322:	2300      	movs	r3, #0
   1d324:	0030      	movs	r0, r6
   1d326:	0039      	movs	r1, r7
   1d328:	220a      	movs	r2, #10
   1d32a:	f000 fdaf 	bl	1de8c <__aeabi_uldivmod>
   1d32e:	0003      	movs	r3, r0
   1d330:	0006      	movs	r6, r0
   1d332:	000f      	movs	r7, r1
   1d334:	430b      	orrs	r3, r1
   1d336:	d1eb      	bne.n	1d310 <_svfiprintf_r+0x3fc>
   1d338:	ab1c      	add	r3, sp, #112	; 0x70
   1d33a:	1b5b      	subs	r3, r3, r5
   1d33c:	9606      	str	r6, [sp, #24]
   1d33e:	9707      	str	r7, [sp, #28]
   1d340:	9304      	str	r3, [sp, #16]
   1d342:	4647      	mov	r7, r8
   1d344:	e73f      	b.n	1d1c6 <_svfiprintf_r+0x2b2>
   1d346:	46c0      	nop			; (mov r8, r8)
   1d348:	000231e0 	.word	0x000231e0
   1d34c:	00022d5c 	.word	0x00022d5c
   1d350:	00023344 	.word	0x00023344
   1d354:	4650      	mov	r0, sl
   1d356:	4692      	mov	sl, r2
   1d358:	2800      	cmp	r0, #0
   1d35a:	d001      	beq.n	1d360 <_svfiprintf_r+0x44c>
   1d35c:	f000 fbfd 	bl	1db5a <_svfiprintf_r+0xc46>
   1d360:	2310      	movs	r3, #16
   1d362:	464a      	mov	r2, r9
   1d364:	431a      	orrs	r2, r3
   1d366:	4691      	mov	r9, r2
   1d368:	2320      	movs	r3, #32
   1d36a:	464a      	mov	r2, r9
   1d36c:	4013      	ands	r3, r2
   1d36e:	d000      	beq.n	1d372 <_svfiprintf_r+0x45e>
   1d370:	e702      	b.n	1d178 <_svfiprintf_r+0x264>
   1d372:	2210      	movs	r2, #16
   1d374:	4649      	mov	r1, r9
   1d376:	400a      	ands	r2, r1
   1d378:	d100      	bne.n	1d37c <_svfiprintf_r+0x468>
   1d37a:	e2e7      	b.n	1d94c <_svfiprintf_r+0xa38>
   1d37c:	9909      	ldr	r1, [sp, #36]	; 0x24
   1d37e:	000a      	movs	r2, r1
   1d380:	6809      	ldr	r1, [r1, #0]
   1d382:	3204      	adds	r2, #4
   1d384:	9106      	str	r1, [sp, #24]
   1d386:	2100      	movs	r1, #0
   1d388:	9107      	str	r1, [sp, #28]
   1d38a:	a90c      	add	r1, sp, #48	; 0x30
   1d38c:	71cb      	strb	r3, [r1, #7]
   1d38e:	9b02      	ldr	r3, [sp, #8]
   1d390:	2b00      	cmp	r3, #0
   1d392:	da00      	bge.n	1d396 <_svfiprintf_r+0x482>
   1d394:	e12b      	b.n	1d5ee <_svfiprintf_r+0x6da>
   1d396:	2380      	movs	r3, #128	; 0x80
   1d398:	4649      	mov	r1, r9
   1d39a:	4399      	bics	r1, r3
   1d39c:	9b06      	ldr	r3, [sp, #24]
   1d39e:	4689      	mov	r9, r1
   1d3a0:	9209      	str	r2, [sp, #36]	; 0x24
   1d3a2:	2400      	movs	r4, #0
   1d3a4:	2b00      	cmp	r3, #0
   1d3a6:	d1ab      	bne.n	1d300 <_svfiprintf_r+0x3ec>
   1d3a8:	e705      	b.n	1d1b6 <_svfiprintf_r+0x2a2>
   1d3aa:	4650      	mov	r0, sl
   1d3ac:	4692      	mov	sl, r2
   1d3ae:	2800      	cmp	r0, #0
   1d3b0:	d001      	beq.n	1d3b6 <_svfiprintf_r+0x4a2>
   1d3b2:	f000 fbd6 	bl	1db62 <_svfiprintf_r+0xc4e>
   1d3b6:	2310      	movs	r3, #16
   1d3b8:	464a      	mov	r2, r9
   1d3ba:	431a      	orrs	r2, r3
   1d3bc:	4691      	mov	r9, r2
   1d3be:	2320      	movs	r3, #32
   1d3c0:	464a      	mov	r2, r9
   1d3c2:	4013      	ands	r3, r2
   1d3c4:	d000      	beq.n	1d3c8 <_svfiprintf_r+0x4b4>
   1d3c6:	e64d      	b.n	1d064 <_svfiprintf_r+0x150>
   1d3c8:	2210      	movs	r2, #16
   1d3ca:	4649      	mov	r1, r9
   1d3cc:	400a      	ands	r2, r1
   1d3ce:	d100      	bne.n	1d3d2 <_svfiprintf_r+0x4be>
   1d3d0:	e2f1      	b.n	1d9b6 <_svfiprintf_r+0xaa2>
   1d3d2:	9909      	ldr	r1, [sp, #36]	; 0x24
   1d3d4:	000a      	movs	r2, r1
   1d3d6:	6809      	ldr	r1, [r1, #0]
   1d3d8:	3204      	adds	r2, #4
   1d3da:	9106      	str	r1, [sp, #24]
   1d3dc:	2100      	movs	r1, #0
   1d3de:	9107      	str	r1, [sp, #28]
   1d3e0:	a90c      	add	r1, sp, #48	; 0x30
   1d3e2:	71cb      	strb	r3, [r1, #7]
   1d3e4:	9b02      	ldr	r3, [sp, #8]
   1d3e6:	2b00      	cmp	r3, #0
   1d3e8:	da00      	bge.n	1d3ec <_svfiprintf_r+0x4d8>
   1d3ea:	e30a      	b.n	1da02 <_svfiprintf_r+0xaee>
   1d3ec:	2380      	movs	r3, #128	; 0x80
   1d3ee:	4649      	mov	r1, r9
   1d3f0:	4399      	bics	r1, r3
   1d3f2:	9b06      	ldr	r3, [sp, #24]
   1d3f4:	4689      	mov	r9, r1
   1d3f6:	9209      	str	r2, [sp, #36]	; 0x24
   1d3f8:	2b00      	cmp	r3, #0
   1d3fa:	d000      	beq.n	1d3fe <_svfiprintf_r+0x4ea>
   1d3fc:	e650      	b.n	1d0a0 <_svfiprintf_r+0x18c>
   1d3fe:	9b02      	ldr	r3, [sp, #8]
   1d400:	2400      	movs	r4, #0
   1d402:	2b00      	cmp	r3, #0
   1d404:	d100      	bne.n	1d408 <_svfiprintf_r+0x4f4>
   1d406:	e360      	b.n	1daca <_svfiprintf_r+0xbb6>
   1d408:	2200      	movs	r2, #0
   1d40a:	2300      	movs	r3, #0
   1d40c:	9206      	str	r2, [sp, #24]
   1d40e:	9307      	str	r3, [sp, #28]
   1d410:	9a06      	ldr	r2, [sp, #24]
   1d412:	9b07      	ldr	r3, [sp, #28]
   1d414:	2007      	movs	r0, #7
   1d416:	46b8      	mov	r8, r7
   1d418:	46a4      	mov	ip, r4
   1d41a:	ad1c      	add	r5, sp, #112	; 0x70
   1d41c:	075f      	lsls	r7, r3, #29
   1d41e:	08d4      	lsrs	r4, r2, #3
   1d420:	0001      	movs	r1, r0
   1d422:	08de      	lsrs	r6, r3, #3
   1d424:	4327      	orrs	r7, r4
   1d426:	0033      	movs	r3, r6
   1d428:	003e      	movs	r6, r7
   1d42a:	4011      	ands	r1, r2
   1d42c:	3d01      	subs	r5, #1
   1d42e:	3130      	adds	r1, #48	; 0x30
   1d430:	7029      	strb	r1, [r5, #0]
   1d432:	003a      	movs	r2, r7
   1d434:	431e      	orrs	r6, r3
   1d436:	d1f1      	bne.n	1d41c <_svfiprintf_r+0x508>
   1d438:	9206      	str	r2, [sp, #24]
   1d43a:	9307      	str	r3, [sp, #28]
   1d43c:	464a      	mov	r2, r9
   1d43e:	4647      	mov	r7, r8
   1d440:	4664      	mov	r4, ip
   1d442:	07d2      	lsls	r2, r2, #31
   1d444:	d400      	bmi.n	1d448 <_svfiprintf_r+0x534>
   1d446:	e0e7      	b.n	1d618 <_svfiprintf_r+0x704>
   1d448:	2930      	cmp	r1, #48	; 0x30
   1d44a:	d100      	bne.n	1d44e <_svfiprintf_r+0x53a>
   1d44c:	e0e4      	b.n	1d618 <_svfiprintf_r+0x704>
   1d44e:	2330      	movs	r3, #48	; 0x30
   1d450:	3d01      	subs	r5, #1
   1d452:	702b      	strb	r3, [r5, #0]
   1d454:	ab1c      	add	r3, sp, #112	; 0x70
   1d456:	1b5b      	subs	r3, r3, r5
   1d458:	9304      	str	r3, [sp, #16]
   1d45a:	e6b4      	b.n	1d1c6 <_svfiprintf_r+0x2b2>
   1d45c:	4650      	mov	r0, sl
   1d45e:	4692      	mov	sl, r2
   1d460:	2800      	cmp	r0, #0
   1d462:	d000      	beq.n	1d466 <_svfiprintf_r+0x552>
   1d464:	e38c      	b.n	1db80 <_svfiprintf_r+0xc6c>
   1d466:	49c7      	ldr	r1, [pc, #796]	; (1d784 <_svfiprintf_r+0x870>)
   1d468:	464a      	mov	r2, r9
   1d46a:	0692      	lsls	r2, r2, #26
   1d46c:	d500      	bpl.n	1d470 <_svfiprintf_r+0x55c>
   1d46e:	e630      	b.n	1d0d2 <_svfiprintf_r+0x1be>
   1d470:	464a      	mov	r2, r9
   1d472:	06d2      	lsls	r2, r2, #27
   1d474:	d400      	bmi.n	1d478 <_svfiprintf_r+0x564>
   1d476:	e257      	b.n	1d928 <_svfiprintf_r+0xa14>
   1d478:	9a09      	ldr	r2, [sp, #36]	; 0x24
   1d47a:	6810      	ldr	r0, [r2, #0]
   1d47c:	9006      	str	r0, [sp, #24]
   1d47e:	2000      	movs	r0, #0
   1d480:	3204      	adds	r2, #4
   1d482:	9007      	str	r0, [sp, #28]
   1d484:	9209      	str	r2, [sp, #36]	; 0x24
   1d486:	4648      	mov	r0, r9
   1d488:	2201      	movs	r2, #1
   1d48a:	4002      	ands	r2, r0
   1d48c:	d000      	beq.n	1d490 <_svfiprintf_r+0x57c>
   1d48e:	e632      	b.n	1d0f6 <_svfiprintf_r+0x1e2>
   1d490:	ab0c      	add	r3, sp, #48	; 0x30
   1d492:	71da      	strb	r2, [r3, #7]
   1d494:	9b02      	ldr	r3, [sp, #8]
   1d496:	2b00      	cmp	r3, #0
   1d498:	da00      	bge.n	1d49c <_svfiprintf_r+0x588>
   1d49a:	e2d9      	b.n	1da50 <_svfiprintf_r+0xb3c>
   1d49c:	2380      	movs	r3, #128	; 0x80
   1d49e:	464a      	mov	r2, r9
   1d4a0:	439a      	bics	r2, r3
   1d4a2:	4691      	mov	r9, r2
   1d4a4:	9a06      	ldr	r2, [sp, #24]
   1d4a6:	9b07      	ldr	r3, [sp, #28]
   1d4a8:	0010      	movs	r0, r2
   1d4aa:	4318      	orrs	r0, r3
   1d4ac:	d100      	bne.n	1d4b0 <_svfiprintf_r+0x59c>
   1d4ae:	e632      	b.n	1d116 <_svfiprintf_r+0x202>
   1d4b0:	2400      	movs	r4, #0
   1d4b2:	e639      	b.n	1d128 <_svfiprintf_r+0x214>
   1d4b4:	464b      	mov	r3, r9
   1d4b6:	4661      	mov	r1, ip
   1d4b8:	430b      	orrs	r3, r1
   1d4ba:	4699      	mov	r9, r3
   1d4bc:	7813      	ldrb	r3, [r2, #0]
   1d4be:	e584      	b.n	1cfca <_svfiprintf_r+0xb6>
   1d4c0:	1c53      	adds	r3, r2, #1
   1d4c2:	9301      	str	r3, [sp, #4]
   1d4c4:	7813      	ldrb	r3, [r2, #0]
   1d4c6:	2b2a      	cmp	r3, #42	; 0x2a
   1d4c8:	d100      	bne.n	1d4cc <_svfiprintf_r+0x5b8>
   1d4ca:	e32a      	b.n	1db22 <_svfiprintf_r+0xc0e>
   1d4cc:	0018      	movs	r0, r3
   1d4ce:	3830      	subs	r0, #48	; 0x30
   1d4d0:	2100      	movs	r1, #0
   1d4d2:	9a01      	ldr	r2, [sp, #4]
   1d4d4:	2809      	cmp	r0, #9
   1d4d6:	d80d      	bhi.n	1d4f4 <_svfiprintf_r+0x5e0>
   1d4d8:	008b      	lsls	r3, r1, #2
   1d4da:	3201      	adds	r2, #1
   1d4dc:	1859      	adds	r1, r3, r1
   1d4de:	1e53      	subs	r3, r2, #1
   1d4e0:	781b      	ldrb	r3, [r3, #0]
   1d4e2:	0049      	lsls	r1, r1, #1
   1d4e4:	1809      	adds	r1, r1, r0
   1d4e6:	0018      	movs	r0, r3
   1d4e8:	3830      	subs	r0, #48	; 0x30
   1d4ea:	2809      	cmp	r0, #9
   1d4ec:	d9f4      	bls.n	1d4d8 <_svfiprintf_r+0x5c4>
   1d4ee:	2900      	cmp	r1, #0
   1d4f0:	da00      	bge.n	1d4f4 <_svfiprintf_r+0x5e0>
   1d4f2:	e2cc      	b.n	1da8e <_svfiprintf_r+0xb7a>
   1d4f4:	9102      	str	r1, [sp, #8]
   1d4f6:	0019      	movs	r1, r3
   1d4f8:	3920      	subs	r1, #32
   1d4fa:	2958      	cmp	r1, #88	; 0x58
   1d4fc:	d800      	bhi.n	1d500 <_svfiprintf_r+0x5ec>
   1d4fe:	e56a      	b.n	1cfd6 <_svfiprintf_r+0xc2>
   1d500:	4650      	mov	r0, sl
   1d502:	4692      	mov	sl, r2
   1d504:	2800      	cmp	r0, #0
   1d506:	d000      	beq.n	1d50a <_svfiprintf_r+0x5f6>
   1d508:	e337      	b.n	1db7a <_svfiprintf_r+0xc66>
   1d50a:	2b00      	cmp	r3, #0
   1d50c:	d100      	bne.n	1d510 <_svfiprintf_r+0x5fc>
   1d50e:	e2ae      	b.n	1da6e <_svfiprintf_r+0xb5a>
   1d510:	ad12      	add	r5, sp, #72	; 0x48
   1d512:	702b      	strb	r3, [r5, #0]
   1d514:	2300      	movs	r3, #0
   1d516:	aa0c      	add	r2, sp, #48	; 0x30
   1d518:	71d3      	strb	r3, [r2, #7]
   1d51a:	3301      	adds	r3, #1
   1d51c:	9301      	str	r3, [sp, #4]
   1d51e:	9304      	str	r3, [sp, #16]
   1d520:	e675      	b.n	1d20e <_svfiprintf_r+0x2fa>
   1d522:	2100      	movs	r1, #0
   1d524:	0018      	movs	r0, r3
   1d526:	000b      	movs	r3, r1
   1d528:	3830      	subs	r0, #48	; 0x30
   1d52a:	0099      	lsls	r1, r3, #2
   1d52c:	3201      	adds	r2, #1
   1d52e:	18cb      	adds	r3, r1, r3
   1d530:	1e51      	subs	r1, r2, #1
   1d532:	7809      	ldrb	r1, [r1, #0]
   1d534:	005b      	lsls	r3, r3, #1
   1d536:	18c3      	adds	r3, r0, r3
   1d538:	0008      	movs	r0, r1
   1d53a:	3830      	subs	r0, #48	; 0x30
   1d53c:	2809      	cmp	r0, #9
   1d53e:	d9f4      	bls.n	1d52a <_svfiprintf_r+0x616>
   1d540:	9305      	str	r3, [sp, #20]
   1d542:	000b      	movs	r3, r1
   1d544:	e542      	b.n	1cfcc <_svfiprintf_r+0xb8>
   1d546:	4650      	mov	r0, sl
   1d548:	4692      	mov	sl, r2
   1d54a:	2800      	cmp	r0, #0
   1d54c:	d000      	beq.n	1d550 <_svfiprintf_r+0x63c>
   1d54e:	e31b      	b.n	1db88 <_svfiprintf_r+0xc74>
   1d550:	464b      	mov	r3, r9
   1d552:	069b      	lsls	r3, r3, #26
   1d554:	d500      	bpl.n	1d558 <_svfiprintf_r+0x644>
   1d556:	e1ee      	b.n	1d936 <_svfiprintf_r+0xa22>
   1d558:	464b      	mov	r3, r9
   1d55a:	06db      	lsls	r3, r3, #27
   1d55c:	d500      	bpl.n	1d560 <_svfiprintf_r+0x64c>
   1d55e:	e260      	b.n	1da22 <_svfiprintf_r+0xb0e>
   1d560:	464b      	mov	r3, r9
   1d562:	065b      	lsls	r3, r3, #25
   1d564:	d400      	bmi.n	1d568 <_svfiprintf_r+0x654>
   1d566:	e25c      	b.n	1da22 <_svfiprintf_r+0xb0e>
   1d568:	4669      	mov	r1, sp
   1d56a:	9b09      	ldr	r3, [sp, #36]	; 0x24
   1d56c:	8989      	ldrh	r1, [r1, #12]
   1d56e:	681a      	ldr	r2, [r3, #0]
   1d570:	3304      	adds	r3, #4
   1d572:	9201      	str	r2, [sp, #4]
   1d574:	8011      	strh	r1, [r2, #0]
   1d576:	9309      	str	r3, [sp, #36]	; 0x24
   1d578:	e4e7      	b.n	1cf4a <_svfiprintf_r+0x36>
   1d57a:	7813      	ldrb	r3, [r2, #0]
   1d57c:	2b6c      	cmp	r3, #108	; 0x6c
   1d57e:	d100      	bne.n	1d582 <_svfiprintf_r+0x66e>
   1d580:	e248      	b.n	1da14 <_svfiprintf_r+0xb00>
   1d582:	4649      	mov	r1, r9
   1d584:	2010      	movs	r0, #16
   1d586:	4301      	orrs	r1, r0
   1d588:	4689      	mov	r9, r1
   1d58a:	e51e      	b.n	1cfca <_svfiprintf_r+0xb6>
   1d58c:	464b      	mov	r3, r9
   1d58e:	4641      	mov	r1, r8
   1d590:	430b      	orrs	r3, r1
   1d592:	4699      	mov	r9, r3
   1d594:	7813      	ldrb	r3, [r2, #0]
   1d596:	e518      	b.n	1cfca <_svfiprintf_r+0xb6>
   1d598:	4650      	mov	r0, sl
   1d59a:	4692      	mov	sl, r2
   1d59c:	2800      	cmp	r0, #0
   1d59e:	d100      	bne.n	1d5a2 <_svfiprintf_r+0x68e>
   1d5a0:	e68a      	b.n	1d2b8 <_svfiprintf_r+0x3a4>
   1d5a2:	ab0c      	add	r3, sp, #48	; 0x30
   1d5a4:	71dc      	strb	r4, [r3, #7]
   1d5a6:	e687      	b.n	1d2b8 <_svfiprintf_r+0x3a4>
   1d5a8:	9b09      	ldr	r3, [sp, #36]	; 0x24
   1d5aa:	4692      	mov	sl, r2
   1d5ac:	1d1e      	adds	r6, r3, #4
   1d5ae:	681d      	ldr	r5, [r3, #0]
   1d5b0:	2300      	movs	r3, #0
   1d5b2:	aa0c      	add	r2, sp, #48	; 0x30
   1d5b4:	71d3      	strb	r3, [r2, #7]
   1d5b6:	2d00      	cmp	r5, #0
   1d5b8:	d100      	bne.n	1d5bc <_svfiprintf_r+0x6a8>
   1d5ba:	e279      	b.n	1dab0 <_svfiprintf_r+0xb9c>
   1d5bc:	9b02      	ldr	r3, [sp, #8]
   1d5be:	2b00      	cmp	r3, #0
   1d5c0:	da00      	bge.n	1d5c4 <_svfiprintf_r+0x6b0>
   1d5c2:	e25f      	b.n	1da84 <_svfiprintf_r+0xb70>
   1d5c4:	001a      	movs	r2, r3
   1d5c6:	2100      	movs	r1, #0
   1d5c8:	0028      	movs	r0, r5
   1d5ca:	f7fb fe39 	bl	19240 <memchr>
   1d5ce:	2800      	cmp	r0, #0
   1d5d0:	d100      	bne.n	1d5d4 <_svfiprintf_r+0x6c0>
   1d5d2:	e29d      	b.n	1db10 <_svfiprintf_r+0xbfc>
   1d5d4:	1b43      	subs	r3, r0, r5
   1d5d6:	9304      	str	r3, [sp, #16]
   1d5d8:	ab0c      	add	r3, sp, #48	; 0x30
   1d5da:	79dc      	ldrb	r4, [r3, #7]
   1d5dc:	2300      	movs	r3, #0
   1d5de:	9609      	str	r6, [sp, #36]	; 0x24
   1d5e0:	9302      	str	r3, [sp, #8]
   1d5e2:	e5f0      	b.n	1d1c6 <_svfiprintf_r+0x2b2>
   1d5e4:	464b      	mov	r3, r9
   1d5e6:	432b      	orrs	r3, r5
   1d5e8:	4699      	mov	r9, r3
   1d5ea:	7813      	ldrb	r3, [r2, #0]
   1d5ec:	e4ed      	b.n	1cfca <_svfiprintf_r+0xb6>
   1d5ee:	9209      	str	r2, [sp, #36]	; 0x24
   1d5f0:	2400      	movs	r4, #0
   1d5f2:	9a06      	ldr	r2, [sp, #24]
   1d5f4:	9b07      	ldr	r3, [sp, #28]
   1d5f6:	0011      	movs	r1, r2
   1d5f8:	4319      	orrs	r1, r3
   1d5fa:	d000      	beq.n	1d5fe <_svfiprintf_r+0x6ea>
   1d5fc:	e680      	b.n	1d300 <_svfiprintf_r+0x3ec>
   1d5fe:	2200      	movs	r2, #0
   1d600:	2300      	movs	r3, #0
   1d602:	9206      	str	r2, [sp, #24]
   1d604:	9307      	str	r3, [sp, #28]
   1d606:	2227      	movs	r2, #39	; 0x27
   1d608:	9b06      	ldr	r3, [sp, #24]
   1d60a:	a912      	add	r1, sp, #72	; 0x48
   1d60c:	3330      	adds	r3, #48	; 0x30
   1d60e:	548b      	strb	r3, [r1, r2]
   1d610:	ab0c      	add	r3, sp, #48	; 0x30
   1d612:	253f      	movs	r5, #63	; 0x3f
   1d614:	469c      	mov	ip, r3
   1d616:	4465      	add	r5, ip
   1d618:	ab1c      	add	r3, sp, #112	; 0x70
   1d61a:	1b5b      	subs	r3, r3, r5
   1d61c:	9304      	str	r3, [sp, #16]
   1d61e:	e5d2      	b.n	1d1c6 <_svfiprintf_r+0x2b2>
   1d620:	9811      	ldr	r0, [sp, #68]	; 0x44
   1d622:	9b10      	ldr	r3, [sp, #64]	; 0x40
   1d624:	aa0c      	add	r2, sp, #48	; 0x30
   1d626:	79d2      	ldrb	r2, [r2, #7]
   1d628:	2a00      	cmp	r2, #0
   1d62a:	d00c      	beq.n	1d646 <_svfiprintf_r+0x732>
   1d62c:	aa0c      	add	r2, sp, #48	; 0x30
   1d62e:	3207      	adds	r2, #7
   1d630:	603a      	str	r2, [r7, #0]
   1d632:	2201      	movs	r2, #1
   1d634:	3001      	adds	r0, #1
   1d636:	3301      	adds	r3, #1
   1d638:	607a      	str	r2, [r7, #4]
   1d63a:	9011      	str	r0, [sp, #68]	; 0x44
   1d63c:	9310      	str	r3, [sp, #64]	; 0x40
   1d63e:	2b07      	cmp	r3, #7
   1d640:	dd00      	ble.n	1d644 <_svfiprintf_r+0x730>
   1d642:	e112      	b.n	1d86a <_svfiprintf_r+0x956>
   1d644:	3708      	adds	r7, #8
   1d646:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   1d648:	2a00      	cmp	r2, #0
   1d64a:	d00b      	beq.n	1d664 <_svfiprintf_r+0x750>
   1d64c:	aa0e      	add	r2, sp, #56	; 0x38
   1d64e:	603a      	str	r2, [r7, #0]
   1d650:	2202      	movs	r2, #2
   1d652:	3002      	adds	r0, #2
   1d654:	3301      	adds	r3, #1
   1d656:	607a      	str	r2, [r7, #4]
   1d658:	9011      	str	r0, [sp, #68]	; 0x44
   1d65a:	9310      	str	r3, [sp, #64]	; 0x40
   1d65c:	2b07      	cmp	r3, #7
   1d65e:	dd00      	ble.n	1d662 <_svfiprintf_r+0x74e>
   1d660:	e10f      	b.n	1d882 <_svfiprintf_r+0x96e>
   1d662:	3708      	adds	r7, #8
   1d664:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
   1d666:	2a80      	cmp	r2, #128	; 0x80
   1d668:	d100      	bne.n	1d66c <_svfiprintf_r+0x758>
   1d66a:	e09f      	b.n	1d7ac <_svfiprintf_r+0x898>
   1d66c:	9a02      	ldr	r2, [sp, #8]
   1d66e:	9904      	ldr	r1, [sp, #16]
   1d670:	1a56      	subs	r6, r2, r1
   1d672:	2e00      	cmp	r6, #0
   1d674:	dd30      	ble.n	1d6d8 <_svfiprintf_r+0x7c4>
   1d676:	4c44      	ldr	r4, [pc, #272]	; (1d788 <_svfiprintf_r+0x874>)
   1d678:	2e10      	cmp	r6, #16
   1d67a:	dd23      	ble.n	1d6c4 <_svfiprintf_r+0x7b0>
   1d67c:	2210      	movs	r2, #16
   1d67e:	4690      	mov	r8, r2
   1d680:	003a      	movs	r2, r7
   1d682:	465f      	mov	r7, fp
   1d684:	46ab      	mov	fp, r5
   1d686:	9d08      	ldr	r5, [sp, #32]
   1d688:	e003      	b.n	1d692 <_svfiprintf_r+0x77e>
   1d68a:	3e10      	subs	r6, #16
   1d68c:	3208      	adds	r2, #8
   1d68e:	2e10      	cmp	r6, #16
   1d690:	dd15      	ble.n	1d6be <_svfiprintf_r+0x7aa>
   1d692:	4641      	mov	r1, r8
   1d694:	3010      	adds	r0, #16
   1d696:	3301      	adds	r3, #1
   1d698:	6014      	str	r4, [r2, #0]
   1d69a:	6051      	str	r1, [r2, #4]
   1d69c:	9011      	str	r0, [sp, #68]	; 0x44
   1d69e:	9310      	str	r3, [sp, #64]	; 0x40
   1d6a0:	2b07      	cmp	r3, #7
   1d6a2:	ddf2      	ble.n	1d68a <_svfiprintf_r+0x776>
   1d6a4:	aa0f      	add	r2, sp, #60	; 0x3c
   1d6a6:	0039      	movs	r1, r7
   1d6a8:	0028      	movs	r0, r5
   1d6aa:	f7ff fb9b 	bl	1cde4 <__ssprint_r>
   1d6ae:	2800      	cmp	r0, #0
   1d6b0:	d16e      	bne.n	1d790 <_svfiprintf_r+0x87c>
   1d6b2:	3e10      	subs	r6, #16
   1d6b4:	9811      	ldr	r0, [sp, #68]	; 0x44
   1d6b6:	9b10      	ldr	r3, [sp, #64]	; 0x40
   1d6b8:	aa1c      	add	r2, sp, #112	; 0x70
   1d6ba:	2e10      	cmp	r6, #16
   1d6bc:	dce9      	bgt.n	1d692 <_svfiprintf_r+0x77e>
   1d6be:	465d      	mov	r5, fp
   1d6c0:	46bb      	mov	fp, r7
   1d6c2:	0017      	movs	r7, r2
   1d6c4:	1980      	adds	r0, r0, r6
   1d6c6:	3301      	adds	r3, #1
   1d6c8:	603c      	str	r4, [r7, #0]
   1d6ca:	607e      	str	r6, [r7, #4]
   1d6cc:	9011      	str	r0, [sp, #68]	; 0x44
   1d6ce:	9310      	str	r3, [sp, #64]	; 0x40
   1d6d0:	2b07      	cmp	r3, #7
   1d6d2:	dd00      	ble.n	1d6d6 <_svfiprintf_r+0x7c2>
   1d6d4:	e0be      	b.n	1d854 <_svfiprintf_r+0x940>
   1d6d6:	3708      	adds	r7, #8
   1d6d8:	9a04      	ldr	r2, [sp, #16]
   1d6da:	3301      	adds	r3, #1
   1d6dc:	4694      	mov	ip, r2
   1d6de:	4460      	add	r0, ip
   1d6e0:	603d      	str	r5, [r7, #0]
   1d6e2:	607a      	str	r2, [r7, #4]
   1d6e4:	9011      	str	r0, [sp, #68]	; 0x44
   1d6e6:	9310      	str	r3, [sp, #64]	; 0x40
   1d6e8:	2b07      	cmp	r3, #7
   1d6ea:	dd00      	ble.n	1d6ee <_svfiprintf_r+0x7da>
   1d6ec:	e096      	b.n	1d81c <_svfiprintf_r+0x908>
   1d6ee:	003a      	movs	r2, r7
   1d6f0:	3208      	adds	r2, #8
   1d6f2:	464b      	mov	r3, r9
   1d6f4:	075b      	lsls	r3, r3, #29
   1d6f6:	d533      	bpl.n	1d760 <_svfiprintf_r+0x84c>
   1d6f8:	9b05      	ldr	r3, [sp, #20]
   1d6fa:	9901      	ldr	r1, [sp, #4]
   1d6fc:	1a5d      	subs	r5, r3, r1
   1d6fe:	2d00      	cmp	r5, #0
   1d700:	dd2e      	ble.n	1d760 <_svfiprintf_r+0x84c>
   1d702:	9b10      	ldr	r3, [sp, #64]	; 0x40
   1d704:	4e21      	ldr	r6, [pc, #132]	; (1d78c <_svfiprintf_r+0x878>)
   1d706:	2d10      	cmp	r5, #16
   1d708:	dd21      	ble.n	1d74e <_svfiprintf_r+0x83a>
   1d70a:	46b0      	mov	r8, r6
   1d70c:	2710      	movs	r7, #16
   1d70e:	9c08      	ldr	r4, [sp, #32]
   1d710:	465e      	mov	r6, fp
   1d712:	e003      	b.n	1d71c <_svfiprintf_r+0x808>
   1d714:	3d10      	subs	r5, #16
   1d716:	3208      	adds	r2, #8
   1d718:	2d10      	cmp	r5, #16
   1d71a:	dd16      	ble.n	1d74a <_svfiprintf_r+0x836>
   1d71c:	491b      	ldr	r1, [pc, #108]	; (1d78c <_svfiprintf_r+0x878>)
   1d71e:	3010      	adds	r0, #16
   1d720:	3301      	adds	r3, #1
   1d722:	6011      	str	r1, [r2, #0]
   1d724:	6057      	str	r7, [r2, #4]
   1d726:	9011      	str	r0, [sp, #68]	; 0x44
   1d728:	9310      	str	r3, [sp, #64]	; 0x40
   1d72a:	2b07      	cmp	r3, #7
   1d72c:	ddf2      	ble.n	1d714 <_svfiprintf_r+0x800>
   1d72e:	aa0f      	add	r2, sp, #60	; 0x3c
   1d730:	0031      	movs	r1, r6
   1d732:	0020      	movs	r0, r4
   1d734:	f7ff fb56 	bl	1cde4 <__ssprint_r>
   1d738:	2800      	cmp	r0, #0
   1d73a:	d000      	beq.n	1d73e <_svfiprintf_r+0x82a>
   1d73c:	e17a      	b.n	1da34 <_svfiprintf_r+0xb20>
   1d73e:	3d10      	subs	r5, #16
   1d740:	9811      	ldr	r0, [sp, #68]	; 0x44
   1d742:	9b10      	ldr	r3, [sp, #64]	; 0x40
   1d744:	aa1c      	add	r2, sp, #112	; 0x70
   1d746:	2d10      	cmp	r5, #16
   1d748:	dce8      	bgt.n	1d71c <_svfiprintf_r+0x808>
   1d74a:	46b3      	mov	fp, r6
   1d74c:	4646      	mov	r6, r8
   1d74e:	1940      	adds	r0, r0, r5
   1d750:	3301      	adds	r3, #1
   1d752:	6016      	str	r6, [r2, #0]
   1d754:	6055      	str	r5, [r2, #4]
   1d756:	9011      	str	r0, [sp, #68]	; 0x44
   1d758:	9310      	str	r3, [sp, #64]	; 0x40
   1d75a:	2b07      	cmp	r3, #7
   1d75c:	dd00      	ble.n	1d760 <_svfiprintf_r+0x84c>
   1d75e:	e0d6      	b.n	1d90e <_svfiprintf_r+0x9fa>
   1d760:	9b05      	ldr	r3, [sp, #20]
   1d762:	9901      	ldr	r1, [sp, #4]
   1d764:	428b      	cmp	r3, r1
   1d766:	da00      	bge.n	1d76a <_svfiprintf_r+0x856>
   1d768:	000b      	movs	r3, r1
   1d76a:	9a03      	ldr	r2, [sp, #12]
   1d76c:	4694      	mov	ip, r2
   1d76e:	449c      	add	ip, r3
   1d770:	4663      	mov	r3, ip
   1d772:	9303      	str	r3, [sp, #12]
   1d774:	2800      	cmp	r0, #0
   1d776:	d15b      	bne.n	1d830 <_svfiprintf_r+0x91c>
   1d778:	2300      	movs	r3, #0
   1d77a:	af1c      	add	r7, sp, #112	; 0x70
   1d77c:	9310      	str	r3, [sp, #64]	; 0x40
   1d77e:	f7ff fbe4 	bl	1cf4a <_svfiprintf_r+0x36>
   1d782:	46c0      	nop			; (mov r8, r8)
   1d784:	00022d48 	.word	0x00022d48
   1d788:	00023354 	.word	0x00023354
   1d78c:	00023344 	.word	0x00023344
   1d790:	46bb      	mov	fp, r7
   1d792:	465b      	mov	r3, fp
   1d794:	899b      	ldrh	r3, [r3, #12]
   1d796:	9803      	ldr	r0, [sp, #12]
   1d798:	065b      	lsls	r3, r3, #25
   1d79a:	d500      	bpl.n	1d79e <_svfiprintf_r+0x88a>
   1d79c:	e1a7      	b.n	1daee <_svfiprintf_r+0xbda>
   1d79e:	b02d      	add	sp, #180	; 0xb4
   1d7a0:	bc3c      	pop	{r2, r3, r4, r5}
   1d7a2:	4690      	mov	r8, r2
   1d7a4:	4699      	mov	r9, r3
   1d7a6:	46a2      	mov	sl, r4
   1d7a8:	46ab      	mov	fp, r5
   1d7aa:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1d7ac:	9a05      	ldr	r2, [sp, #20]
   1d7ae:	9901      	ldr	r1, [sp, #4]
   1d7b0:	1a56      	subs	r6, r2, r1
   1d7b2:	2e00      	cmp	r6, #0
   1d7b4:	dc00      	bgt.n	1d7b8 <_svfiprintf_r+0x8a4>
   1d7b6:	e759      	b.n	1d66c <_svfiprintf_r+0x758>
   1d7b8:	4cd2      	ldr	r4, [pc, #840]	; (1db04 <_svfiprintf_r+0xbf0>)
   1d7ba:	2e10      	cmp	r6, #16
   1d7bc:	dd23      	ble.n	1d806 <_svfiprintf_r+0x8f2>
   1d7be:	2210      	movs	r2, #16
   1d7c0:	4690      	mov	r8, r2
   1d7c2:	003a      	movs	r2, r7
   1d7c4:	465f      	mov	r7, fp
   1d7c6:	46ab      	mov	fp, r5
   1d7c8:	9d08      	ldr	r5, [sp, #32]
   1d7ca:	e003      	b.n	1d7d4 <_svfiprintf_r+0x8c0>
   1d7cc:	3e10      	subs	r6, #16
   1d7ce:	3208      	adds	r2, #8
   1d7d0:	2e10      	cmp	r6, #16
   1d7d2:	dd15      	ble.n	1d800 <_svfiprintf_r+0x8ec>
   1d7d4:	4641      	mov	r1, r8
   1d7d6:	3010      	adds	r0, #16
   1d7d8:	3301      	adds	r3, #1
   1d7da:	6014      	str	r4, [r2, #0]
   1d7dc:	6051      	str	r1, [r2, #4]
   1d7de:	9011      	str	r0, [sp, #68]	; 0x44
   1d7e0:	9310      	str	r3, [sp, #64]	; 0x40
   1d7e2:	2b07      	cmp	r3, #7
   1d7e4:	ddf2      	ble.n	1d7cc <_svfiprintf_r+0x8b8>
   1d7e6:	aa0f      	add	r2, sp, #60	; 0x3c
   1d7e8:	0039      	movs	r1, r7
   1d7ea:	0028      	movs	r0, r5
   1d7ec:	f7ff fafa 	bl	1cde4 <__ssprint_r>
   1d7f0:	2800      	cmp	r0, #0
   1d7f2:	d1cd      	bne.n	1d790 <_svfiprintf_r+0x87c>
   1d7f4:	3e10      	subs	r6, #16
   1d7f6:	9811      	ldr	r0, [sp, #68]	; 0x44
   1d7f8:	9b10      	ldr	r3, [sp, #64]	; 0x40
   1d7fa:	aa1c      	add	r2, sp, #112	; 0x70
   1d7fc:	2e10      	cmp	r6, #16
   1d7fe:	dce9      	bgt.n	1d7d4 <_svfiprintf_r+0x8c0>
   1d800:	465d      	mov	r5, fp
   1d802:	46bb      	mov	fp, r7
   1d804:	0017      	movs	r7, r2
   1d806:	1980      	adds	r0, r0, r6
   1d808:	3301      	adds	r3, #1
   1d80a:	603c      	str	r4, [r7, #0]
   1d80c:	607e      	str	r6, [r7, #4]
   1d80e:	9011      	str	r0, [sp, #68]	; 0x44
   1d810:	9310      	str	r3, [sp, #64]	; 0x40
   1d812:	2b07      	cmp	r3, #7
   1d814:	dd00      	ble.n	1d818 <_svfiprintf_r+0x904>
   1d816:	e10f      	b.n	1da38 <_svfiprintf_r+0xb24>
   1d818:	3708      	adds	r7, #8
   1d81a:	e727      	b.n	1d66c <_svfiprintf_r+0x758>
   1d81c:	aa0f      	add	r2, sp, #60	; 0x3c
   1d81e:	4659      	mov	r1, fp
   1d820:	9808      	ldr	r0, [sp, #32]
   1d822:	f7ff fadf 	bl	1cde4 <__ssprint_r>
   1d826:	2800      	cmp	r0, #0
   1d828:	d1b3      	bne.n	1d792 <_svfiprintf_r+0x87e>
   1d82a:	9811      	ldr	r0, [sp, #68]	; 0x44
   1d82c:	aa1c      	add	r2, sp, #112	; 0x70
   1d82e:	e760      	b.n	1d6f2 <_svfiprintf_r+0x7de>
   1d830:	aa0f      	add	r2, sp, #60	; 0x3c
   1d832:	4659      	mov	r1, fp
   1d834:	9808      	ldr	r0, [sp, #32]
   1d836:	f7ff fad5 	bl	1cde4 <__ssprint_r>
   1d83a:	2800      	cmp	r0, #0
   1d83c:	d09c      	beq.n	1d778 <_svfiprintf_r+0x864>
   1d83e:	e7a8      	b.n	1d792 <_svfiprintf_r+0x87e>
   1d840:	aa0f      	add	r2, sp, #60	; 0x3c
   1d842:	4659      	mov	r1, fp
   1d844:	9808      	ldr	r0, [sp, #32]
   1d846:	f7ff facd 	bl	1cde4 <__ssprint_r>
   1d84a:	2800      	cmp	r0, #0
   1d84c:	d1a1      	bne.n	1d792 <_svfiprintf_r+0x87e>
   1d84e:	af1c      	add	r7, sp, #112	; 0x70
   1d850:	f7ff fb9b 	bl	1cf8a <_svfiprintf_r+0x76>
   1d854:	aa0f      	add	r2, sp, #60	; 0x3c
   1d856:	4659      	mov	r1, fp
   1d858:	9808      	ldr	r0, [sp, #32]
   1d85a:	f7ff fac3 	bl	1cde4 <__ssprint_r>
   1d85e:	2800      	cmp	r0, #0
   1d860:	d197      	bne.n	1d792 <_svfiprintf_r+0x87e>
   1d862:	9811      	ldr	r0, [sp, #68]	; 0x44
   1d864:	9b10      	ldr	r3, [sp, #64]	; 0x40
   1d866:	af1c      	add	r7, sp, #112	; 0x70
   1d868:	e736      	b.n	1d6d8 <_svfiprintf_r+0x7c4>
   1d86a:	aa0f      	add	r2, sp, #60	; 0x3c
   1d86c:	4659      	mov	r1, fp
   1d86e:	9808      	ldr	r0, [sp, #32]
   1d870:	f7ff fab8 	bl	1cde4 <__ssprint_r>
   1d874:	2800      	cmp	r0, #0
   1d876:	d000      	beq.n	1d87a <_svfiprintf_r+0x966>
   1d878:	e78b      	b.n	1d792 <_svfiprintf_r+0x87e>
   1d87a:	9811      	ldr	r0, [sp, #68]	; 0x44
   1d87c:	9b10      	ldr	r3, [sp, #64]	; 0x40
   1d87e:	af1c      	add	r7, sp, #112	; 0x70
   1d880:	e6e1      	b.n	1d646 <_svfiprintf_r+0x732>
   1d882:	aa0f      	add	r2, sp, #60	; 0x3c
   1d884:	4659      	mov	r1, fp
   1d886:	9808      	ldr	r0, [sp, #32]
   1d888:	f7ff faac 	bl	1cde4 <__ssprint_r>
   1d88c:	2800      	cmp	r0, #0
   1d88e:	d000      	beq.n	1d892 <_svfiprintf_r+0x97e>
   1d890:	e77f      	b.n	1d792 <_svfiprintf_r+0x87e>
   1d892:	9811      	ldr	r0, [sp, #68]	; 0x44
   1d894:	9b10      	ldr	r3, [sp, #64]	; 0x40
   1d896:	af1c      	add	r7, sp, #112	; 0x70
   1d898:	e6e4      	b.n	1d664 <_svfiprintf_r+0x750>
   1d89a:	464b      	mov	r3, r9
   1d89c:	06db      	lsls	r3, r3, #27
   1d89e:	d500      	bpl.n	1d8a2 <_svfiprintf_r+0x98e>
   1d8a0:	e0a6      	b.n	1d9f0 <_svfiprintf_r+0xadc>
   1d8a2:	464b      	mov	r3, r9
   1d8a4:	9a09      	ldr	r2, [sp, #36]	; 0x24
   1d8a6:	065b      	lsls	r3, r3, #25
   1d8a8:	d400      	bmi.n	1d8ac <_svfiprintf_r+0x998>
   1d8aa:	e0a2      	b.n	1d9f2 <_svfiprintf_r+0xade>
   1d8ac:	2100      	movs	r1, #0
   1d8ae:	5e53      	ldrsh	r3, [r2, r1]
   1d8b0:	9306      	str	r3, [sp, #24]
   1d8b2:	3204      	adds	r2, #4
   1d8b4:	17db      	asrs	r3, r3, #31
   1d8b6:	9307      	str	r3, [sp, #28]
   1d8b8:	9209      	str	r2, [sp, #36]	; 0x24
   1d8ba:	d400      	bmi.n	1d8be <_svfiprintf_r+0x9aa>
   1d8bc:	e510      	b.n	1d2e0 <_svfiprintf_r+0x3cc>
   1d8be:	9906      	ldr	r1, [sp, #24]
   1d8c0:	9a07      	ldr	r2, [sp, #28]
   1d8c2:	2400      	movs	r4, #0
   1d8c4:	424b      	negs	r3, r1
   1d8c6:	4194      	sbcs	r4, r2
   1d8c8:	9306      	str	r3, [sp, #24]
   1d8ca:	9407      	str	r4, [sp, #28]
   1d8cc:	232d      	movs	r3, #45	; 0x2d
   1d8ce:	aa0c      	add	r2, sp, #48	; 0x30
   1d8d0:	71d3      	strb	r3, [r2, #7]
   1d8d2:	9b02      	ldr	r3, [sp, #8]
   1d8d4:	2b00      	cmp	r3, #0
   1d8d6:	da00      	bge.n	1d8da <_svfiprintf_r+0x9c6>
   1d8d8:	e10c      	b.n	1daf4 <_svfiprintf_r+0xbe0>
   1d8da:	2380      	movs	r3, #128	; 0x80
   1d8dc:	464a      	mov	r2, r9
   1d8de:	439a      	bics	r2, r3
   1d8e0:	9b07      	ldr	r3, [sp, #28]
   1d8e2:	4691      	mov	r9, r2
   1d8e4:	242d      	movs	r4, #45	; 0x2d
   1d8e6:	2b00      	cmp	r3, #0
   1d8e8:	d000      	beq.n	1d8ec <_svfiprintf_r+0x9d8>
   1d8ea:	e50d      	b.n	1d308 <_svfiprintf_r+0x3f4>
   1d8ec:	e084      	b.n	1d9f8 <_svfiprintf_r+0xae4>
   1d8ee:	aa0f      	add	r2, sp, #60	; 0x3c
   1d8f0:	4659      	mov	r1, fp
   1d8f2:	9808      	ldr	r0, [sp, #32]
   1d8f4:	f7ff fa76 	bl	1cde4 <__ssprint_r>
   1d8f8:	2800      	cmp	r0, #0
   1d8fa:	d000      	beq.n	1d8fe <_svfiprintf_r+0x9ea>
   1d8fc:	e749      	b.n	1d792 <_svfiprintf_r+0x87e>
   1d8fe:	9811      	ldr	r0, [sp, #68]	; 0x44
   1d900:	9b10      	ldr	r3, [sp, #64]	; 0x40
   1d902:	af1c      	add	r7, sp, #112	; 0x70
   1d904:	e68e      	b.n	1d624 <_svfiprintf_r+0x710>
   1d906:	7813      	ldrb	r3, [r2, #0]
   1d908:	9109      	str	r1, [sp, #36]	; 0x24
   1d90a:	f7ff fb5e 	bl	1cfca <_svfiprintf_r+0xb6>
   1d90e:	aa0f      	add	r2, sp, #60	; 0x3c
   1d910:	4659      	mov	r1, fp
   1d912:	9808      	ldr	r0, [sp, #32]
   1d914:	f7ff fa66 	bl	1cde4 <__ssprint_r>
   1d918:	2800      	cmp	r0, #0
   1d91a:	d000      	beq.n	1d91e <_svfiprintf_r+0xa0a>
   1d91c:	e739      	b.n	1d792 <_svfiprintf_r+0x87e>
   1d91e:	9811      	ldr	r0, [sp, #68]	; 0x44
   1d920:	e71e      	b.n	1d760 <_svfiprintf_r+0x84c>
   1d922:	4979      	ldr	r1, [pc, #484]	; (1db08 <_svfiprintf_r+0xbf4>)
   1d924:	f7ff fbf7 	bl	1d116 <_svfiprintf_r+0x202>
   1d928:	464a      	mov	r2, r9
   1d92a:	0652      	lsls	r2, r2, #25
   1d92c:	d400      	bmi.n	1d930 <_svfiprintf_r+0xa1c>
   1d92e:	e5a3      	b.n	1d478 <_svfiprintf_r+0x564>
   1d930:	9a09      	ldr	r2, [sp, #36]	; 0x24
   1d932:	8810      	ldrh	r0, [r2, #0]
   1d934:	e5a2      	b.n	1d47c <_svfiprintf_r+0x568>
   1d936:	9909      	ldr	r1, [sp, #36]	; 0x24
   1d938:	9a03      	ldr	r2, [sp, #12]
   1d93a:	680b      	ldr	r3, [r1, #0]
   1d93c:	601a      	str	r2, [r3, #0]
   1d93e:	17d2      	asrs	r2, r2, #31
   1d940:	605a      	str	r2, [r3, #4]
   1d942:	000b      	movs	r3, r1
   1d944:	3304      	adds	r3, #4
   1d946:	9309      	str	r3, [sp, #36]	; 0x24
   1d948:	f7ff faff 	bl	1cf4a <_svfiprintf_r+0x36>
   1d94c:	4649      	mov	r1, r9
   1d94e:	2340      	movs	r3, #64	; 0x40
   1d950:	400b      	ands	r3, r1
   1d952:	9909      	ldr	r1, [sp, #36]	; 0x24
   1d954:	d100      	bne.n	1d958 <_svfiprintf_r+0xa44>
   1d956:	e512      	b.n	1d37e <_svfiprintf_r+0x46a>
   1d958:	000b      	movs	r3, r1
   1d95a:	8809      	ldrh	r1, [r1, #0]
   1d95c:	3304      	adds	r3, #4
   1d95e:	9106      	str	r1, [sp, #24]
   1d960:	2100      	movs	r1, #0
   1d962:	9107      	str	r1, [sp, #28]
   1d964:	a90c      	add	r1, sp, #48	; 0x30
   1d966:	71ca      	strb	r2, [r1, #7]
   1d968:	9a02      	ldr	r2, [sp, #8]
   1d96a:	2a00      	cmp	r2, #0
   1d96c:	da00      	bge.n	1d970 <_svfiprintf_r+0xa5c>
   1d96e:	e0b6      	b.n	1dade <_svfiprintf_r+0xbca>
   1d970:	2280      	movs	r2, #128	; 0x80
   1d972:	4649      	mov	r1, r9
   1d974:	4391      	bics	r1, r2
   1d976:	9a06      	ldr	r2, [sp, #24]
   1d978:	4689      	mov	r9, r1
   1d97a:	9309      	str	r3, [sp, #36]	; 0x24
   1d97c:	2400      	movs	r4, #0
   1d97e:	2a00      	cmp	r2, #0
   1d980:	d000      	beq.n	1d984 <_svfiprintf_r+0xa70>
   1d982:	e4bd      	b.n	1d300 <_svfiprintf_r+0x3ec>
   1d984:	f7ff fc17 	bl	1d1b6 <_svfiprintf_r+0x2a2>
   1d988:	2030      	movs	r0, #48	; 0x30
   1d98a:	aa0e      	add	r2, sp, #56	; 0x38
   1d98c:	7010      	strb	r0, [r2, #0]
   1d98e:	7053      	strb	r3, [r2, #1]
   1d990:	2200      	movs	r2, #0
   1d992:	2302      	movs	r3, #2
   1d994:	4648      	mov	r0, r9
   1d996:	ac0c      	add	r4, sp, #48	; 0x30
   1d998:	71e2      	strb	r2, [r4, #7]
   1d99a:	9a02      	ldr	r2, [sp, #8]
   1d99c:	4318      	orrs	r0, r3
   1d99e:	2a00      	cmp	r2, #0
   1d9a0:	da00      	bge.n	1d9a4 <_svfiprintf_r+0xa90>
   1d9a2:	e0aa      	b.n	1dafa <_svfiprintf_r+0xbe6>
   1d9a4:	2280      	movs	r2, #128	; 0x80
   1d9a6:	4648      	mov	r0, r9
   1d9a8:	4390      	bics	r0, r2
   1d9aa:	0002      	movs	r2, r0
   1d9ac:	431a      	orrs	r2, r3
   1d9ae:	4691      	mov	r9, r2
   1d9b0:	2400      	movs	r4, #0
   1d9b2:	f7ff fbb9 	bl	1d128 <_svfiprintf_r+0x214>
   1d9b6:	4649      	mov	r1, r9
   1d9b8:	2340      	movs	r3, #64	; 0x40
   1d9ba:	400b      	ands	r3, r1
   1d9bc:	9909      	ldr	r1, [sp, #36]	; 0x24
   1d9be:	d100      	bne.n	1d9c2 <_svfiprintf_r+0xaae>
   1d9c0:	e508      	b.n	1d3d4 <_svfiprintf_r+0x4c0>
   1d9c2:	000b      	movs	r3, r1
   1d9c4:	8809      	ldrh	r1, [r1, #0]
   1d9c6:	3304      	adds	r3, #4
   1d9c8:	9106      	str	r1, [sp, #24]
   1d9ca:	2100      	movs	r1, #0
   1d9cc:	9107      	str	r1, [sp, #28]
   1d9ce:	a90c      	add	r1, sp, #48	; 0x30
   1d9d0:	71ca      	strb	r2, [r1, #7]
   1d9d2:	9a02      	ldr	r2, [sp, #8]
   1d9d4:	2a00      	cmp	r2, #0
   1d9d6:	da00      	bge.n	1d9da <_svfiprintf_r+0xac6>
   1d9d8:	e07f      	b.n	1dada <_svfiprintf_r+0xbc6>
   1d9da:	2280      	movs	r2, #128	; 0x80
   1d9dc:	4649      	mov	r1, r9
   1d9de:	4391      	bics	r1, r2
   1d9e0:	9a06      	ldr	r2, [sp, #24]
   1d9e2:	4689      	mov	r9, r1
   1d9e4:	9309      	str	r3, [sp, #36]	; 0x24
   1d9e6:	2a00      	cmp	r2, #0
   1d9e8:	d100      	bne.n	1d9ec <_svfiprintf_r+0xad8>
   1d9ea:	e508      	b.n	1d3fe <_svfiprintf_r+0x4ea>
   1d9ec:	2400      	movs	r4, #0
   1d9ee:	e50f      	b.n	1d410 <_svfiprintf_r+0x4fc>
   1d9f0:	9a09      	ldr	r2, [sp, #36]	; 0x24
   1d9f2:	6813      	ldr	r3, [r2, #0]
   1d9f4:	9301      	str	r3, [sp, #4]
   1d9f6:	e75b      	b.n	1d8b0 <_svfiprintf_r+0x99c>
   1d9f8:	9b06      	ldr	r3, [sp, #24]
   1d9fa:	2b09      	cmp	r3, #9
   1d9fc:	d900      	bls.n	1da00 <_svfiprintf_r+0xaec>
   1d9fe:	e483      	b.n	1d308 <_svfiprintf_r+0x3f4>
   1da00:	e601      	b.n	1d606 <_svfiprintf_r+0x6f2>
   1da02:	9209      	str	r2, [sp, #36]	; 0x24
   1da04:	9a06      	ldr	r2, [sp, #24]
   1da06:	9b07      	ldr	r3, [sp, #28]
   1da08:	0011      	movs	r1, r2
   1da0a:	2400      	movs	r4, #0
   1da0c:	4319      	orrs	r1, r3
   1da0e:	d000      	beq.n	1da12 <_svfiprintf_r+0xafe>
   1da10:	e4fe      	b.n	1d410 <_svfiprintf_r+0x4fc>
   1da12:	e4f9      	b.n	1d408 <_svfiprintf_r+0x4f4>
   1da14:	464b      	mov	r3, r9
   1da16:	432b      	orrs	r3, r5
   1da18:	4699      	mov	r9, r3
   1da1a:	3201      	adds	r2, #1
   1da1c:	7813      	ldrb	r3, [r2, #0]
   1da1e:	f7ff fad4 	bl	1cfca <_svfiprintf_r+0xb6>
   1da22:	9a09      	ldr	r2, [sp, #36]	; 0x24
   1da24:	9903      	ldr	r1, [sp, #12]
   1da26:	6813      	ldr	r3, [r2, #0]
   1da28:	6019      	str	r1, [r3, #0]
   1da2a:	0013      	movs	r3, r2
   1da2c:	3304      	adds	r3, #4
   1da2e:	9309      	str	r3, [sp, #36]	; 0x24
   1da30:	f7ff fa8b 	bl	1cf4a <_svfiprintf_r+0x36>
   1da34:	46b3      	mov	fp, r6
   1da36:	e6ac      	b.n	1d792 <_svfiprintf_r+0x87e>
   1da38:	aa0f      	add	r2, sp, #60	; 0x3c
   1da3a:	4659      	mov	r1, fp
   1da3c:	9808      	ldr	r0, [sp, #32]
   1da3e:	f7ff f9d1 	bl	1cde4 <__ssprint_r>
   1da42:	2800      	cmp	r0, #0
   1da44:	d000      	beq.n	1da48 <_svfiprintf_r+0xb34>
   1da46:	e6a4      	b.n	1d792 <_svfiprintf_r+0x87e>
   1da48:	9811      	ldr	r0, [sp, #68]	; 0x44
   1da4a:	9b10      	ldr	r3, [sp, #64]	; 0x40
   1da4c:	af1c      	add	r7, sp, #112	; 0x70
   1da4e:	e60d      	b.n	1d66c <_svfiprintf_r+0x758>
   1da50:	9809      	ldr	r0, [sp, #36]	; 0x24
   1da52:	9a06      	ldr	r2, [sp, #24]
   1da54:	9b07      	ldr	r3, [sp, #28]
   1da56:	0014      	movs	r4, r2
   1da58:	9009      	str	r0, [sp, #36]	; 0x24
   1da5a:	431c      	orrs	r4, r3
   1da5c:	d101      	bne.n	1da62 <_svfiprintf_r+0xb4e>
   1da5e:	f7ff fb5e 	bl	1d11e <_svfiprintf_r+0x20a>
   1da62:	2400      	movs	r4, #0
   1da64:	f7ff fb60 	bl	1d128 <_svfiprintf_r+0x214>
   1da68:	4689      	mov	r9, r1
   1da6a:	4927      	ldr	r1, [pc, #156]	; (1db08 <_svfiprintf_r+0xbf4>)
   1da6c:	e7f1      	b.n	1da52 <_svfiprintf_r+0xb3e>
   1da6e:	9b11      	ldr	r3, [sp, #68]	; 0x44
   1da70:	9301      	str	r3, [sp, #4]
   1da72:	2b00      	cmp	r3, #0
   1da74:	d100      	bne.n	1da78 <_svfiprintf_r+0xb64>
   1da76:	e68c      	b.n	1d792 <_svfiprintf_r+0x87e>
   1da78:	aa0f      	add	r2, sp, #60	; 0x3c
   1da7a:	4659      	mov	r1, fp
   1da7c:	9808      	ldr	r0, [sp, #32]
   1da7e:	f7ff f9b1 	bl	1cde4 <__ssprint_r>
   1da82:	e686      	b.n	1d792 <_svfiprintf_r+0x87e>
   1da84:	0028      	movs	r0, r5
   1da86:	f7f8 f8c3 	bl	15c10 <strlen>
   1da8a:	9004      	str	r0, [sp, #16]
   1da8c:	e5a4      	b.n	1d5d8 <_svfiprintf_r+0x6c4>
   1da8e:	2101      	movs	r1, #1
   1da90:	4249      	negs	r1, r1
   1da92:	9102      	str	r1, [sp, #8]
   1da94:	e52f      	b.n	1d4f6 <_svfiprintf_r+0x5e2>
   1da96:	2140      	movs	r1, #64	; 0x40
   1da98:	f7f7 fcc8 	bl	1542c <_malloc_r>
   1da9c:	465b      	mov	r3, fp
   1da9e:	6018      	str	r0, [r3, #0]
   1daa0:	6118      	str	r0, [r3, #16]
   1daa2:	2800      	cmp	r0, #0
   1daa4:	d054      	beq.n	1db50 <_svfiprintf_r+0xc3c>
   1daa6:	2340      	movs	r3, #64	; 0x40
   1daa8:	465a      	mov	r2, fp
   1daaa:	6153      	str	r3, [r2, #20]
   1daac:	f7ff fa45 	bl	1cf3a <_svfiprintf_r+0x26>
   1dab0:	9a02      	ldr	r2, [sp, #8]
   1dab2:	2a06      	cmp	r2, #6
   1dab4:	d900      	bls.n	1dab8 <_svfiprintf_r+0xba4>
   1dab6:	2206      	movs	r2, #6
   1dab8:	43d3      	mvns	r3, r2
   1daba:	17db      	asrs	r3, r3, #31
   1dabc:	9204      	str	r2, [sp, #16]
   1dabe:	401a      	ands	r2, r3
   1dac0:	9201      	str	r2, [sp, #4]
   1dac2:	9609      	str	r6, [sp, #36]	; 0x24
   1dac4:	4d11      	ldr	r5, [pc, #68]	; (1db0c <_svfiprintf_r+0xbf8>)
   1dac6:	f7ff fba2 	bl	1d20e <_svfiprintf_r+0x2fa>
   1daca:	464b      	mov	r3, r9
   1dacc:	07db      	lsls	r3, r3, #31
   1dace:	d509      	bpl.n	1dae4 <_svfiprintf_r+0xbd0>
   1dad0:	2130      	movs	r1, #48	; 0x30
   1dad2:	2327      	movs	r3, #39	; 0x27
   1dad4:	aa12      	add	r2, sp, #72	; 0x48
   1dad6:	54d1      	strb	r1, [r2, r3]
   1dad8:	e59a      	b.n	1d610 <_svfiprintf_r+0x6fc>
   1dada:	9309      	str	r3, [sp, #36]	; 0x24
   1dadc:	e792      	b.n	1da04 <_svfiprintf_r+0xaf0>
   1dade:	9309      	str	r3, [sp, #36]	; 0x24
   1dae0:	2400      	movs	r4, #0
   1dae2:	e586      	b.n	1d5f2 <_svfiprintf_r+0x6de>
   1dae4:	2300      	movs	r3, #0
   1dae6:	ad1c      	add	r5, sp, #112	; 0x70
   1dae8:	9304      	str	r3, [sp, #16]
   1daea:	f7ff fb6c 	bl	1d1c6 <_svfiprintf_r+0x2b2>
   1daee:	2001      	movs	r0, #1
   1daf0:	4240      	negs	r0, r0
   1daf2:	e654      	b.n	1d79e <_svfiprintf_r+0x88a>
   1daf4:	242d      	movs	r4, #45	; 0x2d
   1daf6:	f7ff fc03 	bl	1d300 <_svfiprintf_r+0x3ec>
   1dafa:	4681      	mov	r9, r0
   1dafc:	2400      	movs	r4, #0
   1dafe:	f7ff fb13 	bl	1d128 <_svfiprintf_r+0x214>
   1db02:	46c0      	nop			; (mov r8, r8)
   1db04:	00023354 	.word	0x00023354
   1db08:	00022d5c 	.word	0x00022d5c
   1db0c:	00022d70 	.word	0x00022d70
   1db10:	ab0c      	add	r3, sp, #48	; 0x30
   1db12:	79dc      	ldrb	r4, [r3, #7]
   1db14:	9b02      	ldr	r3, [sp, #8]
   1db16:	9609      	str	r6, [sp, #36]	; 0x24
   1db18:	9304      	str	r3, [sp, #16]
   1db1a:	2300      	movs	r3, #0
   1db1c:	9302      	str	r3, [sp, #8]
   1db1e:	f7ff fb52 	bl	1d1c6 <_svfiprintf_r+0x2b2>
   1db22:	9b09      	ldr	r3, [sp, #36]	; 0x24
   1db24:	1d19      	adds	r1, r3, #4
   1db26:	681b      	ldr	r3, [r3, #0]
   1db28:	9302      	str	r3, [sp, #8]
   1db2a:	2b00      	cmp	r3, #0
   1db2c:	db08      	blt.n	1db40 <_svfiprintf_r+0xc2c>
   1db2e:	7853      	ldrb	r3, [r2, #1]
   1db30:	9109      	str	r1, [sp, #36]	; 0x24
   1db32:	9a01      	ldr	r2, [sp, #4]
   1db34:	f7ff fa49 	bl	1cfca <_svfiprintf_r+0xb6>
   1db38:	ab0c      	add	r3, sp, #48	; 0x30
   1db3a:	71dc      	strb	r4, [r3, #7]
   1db3c:	f7ff fa8d 	bl	1d05a <_svfiprintf_r+0x146>
   1db40:	9109      	str	r1, [sp, #36]	; 0x24
   1db42:	2101      	movs	r1, #1
   1db44:	4249      	negs	r1, r1
   1db46:	7853      	ldrb	r3, [r2, #1]
   1db48:	9102      	str	r1, [sp, #8]
   1db4a:	9a01      	ldr	r2, [sp, #4]
   1db4c:	f7ff fa3d 	bl	1cfca <_svfiprintf_r+0xb6>
   1db50:	230c      	movs	r3, #12
   1db52:	9a08      	ldr	r2, [sp, #32]
   1db54:	3801      	subs	r0, #1
   1db56:	6013      	str	r3, [r2, #0]
   1db58:	e621      	b.n	1d79e <_svfiprintf_r+0x88a>
   1db5a:	ab0c      	add	r3, sp, #48	; 0x30
   1db5c:	71dc      	strb	r4, [r3, #7]
   1db5e:	f7ff fbff 	bl	1d360 <_svfiprintf_r+0x44c>
   1db62:	ab0c      	add	r3, sp, #48	; 0x30
   1db64:	71dc      	strb	r4, [r3, #7]
   1db66:	f7ff fc26 	bl	1d3b6 <_svfiprintf_r+0x4a2>
   1db6a:	ab0c      	add	r3, sp, #48	; 0x30
   1db6c:	71dc      	strb	r4, [r3, #7]
   1db6e:	f7ff fb9f 	bl	1d2b0 <_svfiprintf_r+0x39c>
   1db72:	aa0c      	add	r2, sp, #48	; 0x30
   1db74:	71d4      	strb	r4, [r2, #7]
   1db76:	f7ff faa7 	bl	1d0c8 <_svfiprintf_r+0x1b4>
   1db7a:	aa0c      	add	r2, sp, #48	; 0x30
   1db7c:	71d4      	strb	r4, [r2, #7]
   1db7e:	e4c4      	b.n	1d50a <_svfiprintf_r+0x5f6>
   1db80:	aa0c      	add	r2, sp, #48	; 0x30
   1db82:	71d4      	strb	r4, [r2, #7]
   1db84:	4904      	ldr	r1, [pc, #16]	; (1db98 <_svfiprintf_r+0xc84>)
   1db86:	e46f      	b.n	1d468 <_svfiprintf_r+0x554>
   1db88:	ab0c      	add	r3, sp, #48	; 0x30
   1db8a:	71dc      	strb	r4, [r3, #7]
   1db8c:	e4e0      	b.n	1d550 <_svfiprintf_r+0x63c>
   1db8e:	ab0c      	add	r3, sp, #48	; 0x30
   1db90:	71dc      	strb	r4, [r3, #7]
   1db92:	f7ff faec 	bl	1d16e <_svfiprintf_r+0x25a>
   1db96:	46c0      	nop			; (mov r8, r8)
   1db98:	00022d48 	.word	0x00022d48

0001db9c <__swbuf_r>:
   1db9c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1db9e:	0006      	movs	r6, r0
   1dba0:	000f      	movs	r7, r1
   1dba2:	0014      	movs	r4, r2
   1dba4:	2800      	cmp	r0, #0
   1dba6:	d002      	beq.n	1dbae <__swbuf_r+0x12>
   1dba8:	6b83      	ldr	r3, [r0, #56]	; 0x38
   1dbaa:	2b00      	cmp	r3, #0
   1dbac:	d04d      	beq.n	1dc4a <__swbuf_r+0xae>
   1dbae:	69a3      	ldr	r3, [r4, #24]
   1dbb0:	60a3      	str	r3, [r4, #8]
   1dbb2:	230c      	movs	r3, #12
   1dbb4:	5ee2      	ldrsh	r2, [r4, r3]
   1dbb6:	b291      	uxth	r1, r2
   1dbb8:	070b      	lsls	r3, r1, #28
   1dbba:	d53b      	bpl.n	1dc34 <__swbuf_r+0x98>
   1dbbc:	6923      	ldr	r3, [r4, #16]
   1dbbe:	2b00      	cmp	r3, #0
   1dbc0:	d038      	beq.n	1dc34 <__swbuf_r+0x98>
   1dbc2:	2080      	movs	r0, #128	; 0x80
   1dbc4:	25ff      	movs	r5, #255	; 0xff
   1dbc6:	0180      	lsls	r0, r0, #6
   1dbc8:	403d      	ands	r5, r7
   1dbca:	4201      	tst	r1, r0
   1dbcc:	d015      	beq.n	1dbfa <__swbuf_r+0x5e>
   1dbce:	6822      	ldr	r2, [r4, #0]
   1dbd0:	6961      	ldr	r1, [r4, #20]
   1dbd2:	1ad3      	subs	r3, r2, r3
   1dbd4:	428b      	cmp	r3, r1
   1dbd6:	da1b      	bge.n	1dc10 <__swbuf_r+0x74>
   1dbd8:	3301      	adds	r3, #1
   1dbda:	68a1      	ldr	r1, [r4, #8]
   1dbdc:	3901      	subs	r1, #1
   1dbde:	60a1      	str	r1, [r4, #8]
   1dbe0:	1c51      	adds	r1, r2, #1
   1dbe2:	6021      	str	r1, [r4, #0]
   1dbe4:	7017      	strb	r7, [r2, #0]
   1dbe6:	6962      	ldr	r2, [r4, #20]
   1dbe8:	429a      	cmp	r2, r3
   1dbea:	d01a      	beq.n	1dc22 <__swbuf_r+0x86>
   1dbec:	89a3      	ldrh	r3, [r4, #12]
   1dbee:	07db      	lsls	r3, r3, #31
   1dbf0:	d501      	bpl.n	1dbf6 <__swbuf_r+0x5a>
   1dbf2:	2d0a      	cmp	r5, #10
   1dbf4:	d015      	beq.n	1dc22 <__swbuf_r+0x86>
   1dbf6:	0028      	movs	r0, r5
   1dbf8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1dbfa:	4302      	orrs	r2, r0
   1dbfc:	6e61      	ldr	r1, [r4, #100]	; 0x64
   1dbfe:	81a2      	strh	r2, [r4, #12]
   1dc00:	4a13      	ldr	r2, [pc, #76]	; (1dc50 <__swbuf_r+0xb4>)
   1dc02:	400a      	ands	r2, r1
   1dc04:	6662      	str	r2, [r4, #100]	; 0x64
   1dc06:	6961      	ldr	r1, [r4, #20]
   1dc08:	6822      	ldr	r2, [r4, #0]
   1dc0a:	1ad3      	subs	r3, r2, r3
   1dc0c:	428b      	cmp	r3, r1
   1dc0e:	dbe3      	blt.n	1dbd8 <__swbuf_r+0x3c>
   1dc10:	0021      	movs	r1, r4
   1dc12:	0030      	movs	r0, r6
   1dc14:	f7fa fe38 	bl	18888 <_fflush_r>
   1dc18:	2800      	cmp	r0, #0
   1dc1a:	d108      	bne.n	1dc2e <__swbuf_r+0x92>
   1dc1c:	6822      	ldr	r2, [r4, #0]
   1dc1e:	2301      	movs	r3, #1
   1dc20:	e7db      	b.n	1dbda <__swbuf_r+0x3e>
   1dc22:	0021      	movs	r1, r4
   1dc24:	0030      	movs	r0, r6
   1dc26:	f7fa fe2f 	bl	18888 <_fflush_r>
   1dc2a:	2800      	cmp	r0, #0
   1dc2c:	d0e3      	beq.n	1dbf6 <__swbuf_r+0x5a>
   1dc2e:	2501      	movs	r5, #1
   1dc30:	426d      	negs	r5, r5
   1dc32:	e7e0      	b.n	1dbf6 <__swbuf_r+0x5a>
   1dc34:	0021      	movs	r1, r4
   1dc36:	0030      	movs	r0, r6
   1dc38:	f7f9 fcc2 	bl	175c0 <__swsetup_r>
   1dc3c:	2800      	cmp	r0, #0
   1dc3e:	d1f6      	bne.n	1dc2e <__swbuf_r+0x92>
   1dc40:	230c      	movs	r3, #12
   1dc42:	5ee2      	ldrsh	r2, [r4, r3]
   1dc44:	6923      	ldr	r3, [r4, #16]
   1dc46:	b291      	uxth	r1, r2
   1dc48:	e7bb      	b.n	1dbc2 <__swbuf_r+0x26>
   1dc4a:	f7fa ff37 	bl	18abc <__sinit>
   1dc4e:	e7ae      	b.n	1dbae <__swbuf_r+0x12>
   1dc50:	ffffdfff 	.word	0xffffdfff

0001dc54 <__swbuf>:
   1dc54:	b510      	push	{r4, lr}
   1dc56:	4b04      	ldr	r3, [pc, #16]	; (1dc68 <__swbuf+0x14>)
   1dc58:	000a      	movs	r2, r1
   1dc5a:	681b      	ldr	r3, [r3, #0]
   1dc5c:	0001      	movs	r1, r0
   1dc5e:	0018      	movs	r0, r3
   1dc60:	f7ff ff9c 	bl	1db9c <__swbuf_r>
   1dc64:	bd10      	pop	{r4, pc}
   1dc66:	46c0      	nop			; (mov r8, r8)
   1dc68:	10010df0 	.word	0x10010df0

0001dc6c <_wcrtomb_r>:
   1dc6c:	b570      	push	{r4, r5, r6, lr}
   1dc6e:	001d      	movs	r5, r3
   1dc70:	4b11      	ldr	r3, [pc, #68]	; (1dcb8 <_wcrtomb_r+0x4c>)
   1dc72:	b084      	sub	sp, #16
   1dc74:	681b      	ldr	r3, [r3, #0]
   1dc76:	0004      	movs	r4, r0
   1dc78:	6b5b      	ldr	r3, [r3, #52]	; 0x34
   1dc7a:	2900      	cmp	r1, #0
   1dc7c:	d00e      	beq.n	1dc9c <_wcrtomb_r+0x30>
   1dc7e:	2b00      	cmp	r3, #0
   1dc80:	d016      	beq.n	1dcb0 <_wcrtomb_r+0x44>
   1dc82:	20e0      	movs	r0, #224	; 0xe0
   1dc84:	581e      	ldr	r6, [r3, r0]
   1dc86:	002b      	movs	r3, r5
   1dc88:	0020      	movs	r0, r4
   1dc8a:	47b0      	blx	r6
   1dc8c:	1c43      	adds	r3, r0, #1
   1dc8e:	d103      	bne.n	1dc98 <_wcrtomb_r+0x2c>
   1dc90:	2300      	movs	r3, #0
   1dc92:	602b      	str	r3, [r5, #0]
   1dc94:	338a      	adds	r3, #138	; 0x8a
   1dc96:	6023      	str	r3, [r4, #0]
   1dc98:	b004      	add	sp, #16
   1dc9a:	bd70      	pop	{r4, r5, r6, pc}
   1dc9c:	2b00      	cmp	r3, #0
   1dc9e:	d009      	beq.n	1dcb4 <_wcrtomb_r+0x48>
   1dca0:	22e0      	movs	r2, #224	; 0xe0
   1dca2:	a901      	add	r1, sp, #4
   1dca4:	589e      	ldr	r6, [r3, r2]
   1dca6:	0020      	movs	r0, r4
   1dca8:	002b      	movs	r3, r5
   1dcaa:	2200      	movs	r2, #0
   1dcac:	47b0      	blx	r6
   1dcae:	e7ed      	b.n	1dc8c <_wcrtomb_r+0x20>
   1dcb0:	4b02      	ldr	r3, [pc, #8]	; (1dcbc <_wcrtomb_r+0x50>)
   1dcb2:	e7e6      	b.n	1dc82 <_wcrtomb_r+0x16>
   1dcb4:	4b01      	ldr	r3, [pc, #4]	; (1dcbc <_wcrtomb_r+0x50>)
   1dcb6:	e7f3      	b.n	1dca0 <_wcrtomb_r+0x34>
   1dcb8:	10010df0 	.word	0x10010df0
   1dcbc:	10010df4 	.word	0x10010df4

0001dcc0 <wcrtomb>:
   1dcc0:	b570      	push	{r4, r5, r6, lr}
   1dcc2:	4b13      	ldr	r3, [pc, #76]	; (1dd10 <wcrtomb+0x50>)
   1dcc4:	b084      	sub	sp, #16
   1dcc6:	681c      	ldr	r4, [r3, #0]
   1dcc8:	0015      	movs	r5, r2
   1dcca:	6b63      	ldr	r3, [r4, #52]	; 0x34
   1dccc:	2800      	cmp	r0, #0
   1dcce:	d010      	beq.n	1dcf2 <wcrtomb+0x32>
   1dcd0:	2b00      	cmp	r3, #0
   1dcd2:	d018      	beq.n	1dd06 <wcrtomb+0x46>
   1dcd4:	22e0      	movs	r2, #224	; 0xe0
   1dcd6:	589e      	ldr	r6, [r3, r2]
   1dcd8:	000a      	movs	r2, r1
   1dcda:	002b      	movs	r3, r5
   1dcdc:	0001      	movs	r1, r0
   1dcde:	0020      	movs	r0, r4
   1dce0:	47b0      	blx	r6
   1dce2:	1c43      	adds	r3, r0, #1
   1dce4:	d103      	bne.n	1dcee <wcrtomb+0x2e>
   1dce6:	2300      	movs	r3, #0
   1dce8:	602b      	str	r3, [r5, #0]
   1dcea:	338a      	adds	r3, #138	; 0x8a
   1dcec:	6023      	str	r3, [r4, #0]
   1dcee:	b004      	add	sp, #16
   1dcf0:	bd70      	pop	{r4, r5, r6, pc}
   1dcf2:	2b00      	cmp	r3, #0
   1dcf4:	d009      	beq.n	1dd0a <wcrtomb+0x4a>
   1dcf6:	22e0      	movs	r2, #224	; 0xe0
   1dcf8:	a901      	add	r1, sp, #4
   1dcfa:	589e      	ldr	r6, [r3, r2]
   1dcfc:	0020      	movs	r0, r4
   1dcfe:	002b      	movs	r3, r5
   1dd00:	2200      	movs	r2, #0
   1dd02:	47b0      	blx	r6
   1dd04:	e7ed      	b.n	1dce2 <wcrtomb+0x22>
   1dd06:	4b03      	ldr	r3, [pc, #12]	; (1dd14 <wcrtomb+0x54>)
   1dd08:	e7e4      	b.n	1dcd4 <wcrtomb+0x14>
   1dd0a:	4b02      	ldr	r3, [pc, #8]	; (1dd14 <wcrtomb+0x54>)
   1dd0c:	e7f3      	b.n	1dcf6 <wcrtomb+0x36>
   1dd0e:	46c0      	nop			; (mov r8, r8)
   1dd10:	10010df0 	.word	0x10010df0
   1dd14:	10010df4 	.word	0x10010df4

0001dd18 <_wctomb_r>:
   1dd18:	b570      	push	{r4, r5, r6, lr}
   1dd1a:	4c05      	ldr	r4, [pc, #20]	; (1dd30 <_wctomb_r+0x18>)
   1dd1c:	6824      	ldr	r4, [r4, #0]
   1dd1e:	6b64      	ldr	r4, [r4, #52]	; 0x34
   1dd20:	2c00      	cmp	r4, #0
   1dd22:	d003      	beq.n	1dd2c <_wctomb_r+0x14>
   1dd24:	25e0      	movs	r5, #224	; 0xe0
   1dd26:	5964      	ldr	r4, [r4, r5]
   1dd28:	47a0      	blx	r4
   1dd2a:	bd70      	pop	{r4, r5, r6, pc}
   1dd2c:	4c01      	ldr	r4, [pc, #4]	; (1dd34 <_wctomb_r+0x1c>)
   1dd2e:	e7f9      	b.n	1dd24 <_wctomb_r+0xc>
   1dd30:	10010df0 	.word	0x10010df0
   1dd34:	10010df4 	.word	0x10010df4

0001dd38 <__ascii_wctomb>:
   1dd38:	2900      	cmp	r1, #0
   1dd3a:	d004      	beq.n	1dd46 <__ascii_wctomb+0xe>
   1dd3c:	2aff      	cmp	r2, #255	; 0xff
   1dd3e:	d804      	bhi.n	1dd4a <__ascii_wctomb+0x12>
   1dd40:	2001      	movs	r0, #1
   1dd42:	700a      	strb	r2, [r1, #0]
   1dd44:	4770      	bx	lr
   1dd46:	2000      	movs	r0, #0
   1dd48:	e7fc      	b.n	1dd44 <__ascii_wctomb+0xc>
   1dd4a:	238a      	movs	r3, #138	; 0x8a
   1dd4c:	6003      	str	r3, [r0, #0]
   1dd4e:	2001      	movs	r0, #1
   1dd50:	4240      	negs	r0, r0
   1dd52:	e7f7      	b.n	1dd44 <__ascii_wctomb+0xc>

0001dd54 <__gnu_thumb1_case_uqi>:
   1dd54:	b402      	push	{r1}
   1dd56:	4671      	mov	r1, lr
   1dd58:	0849      	lsrs	r1, r1, #1
   1dd5a:	0049      	lsls	r1, r1, #1
   1dd5c:	5c09      	ldrb	r1, [r1, r0]
   1dd5e:	0049      	lsls	r1, r1, #1
   1dd60:	448e      	add	lr, r1
   1dd62:	bc02      	pop	{r1}
   1dd64:	4770      	bx	lr
   1dd66:	46c0      	nop			; (mov r8, r8)

0001dd68 <__gnu_thumb1_case_uhi>:
   1dd68:	b403      	push	{r0, r1}
   1dd6a:	4671      	mov	r1, lr
   1dd6c:	0849      	lsrs	r1, r1, #1
   1dd6e:	0040      	lsls	r0, r0, #1
   1dd70:	0049      	lsls	r1, r1, #1
   1dd72:	5a09      	ldrh	r1, [r1, r0]
   1dd74:	0049      	lsls	r1, r1, #1
   1dd76:	448e      	add	lr, r1
   1dd78:	bc03      	pop	{r0, r1}
   1dd7a:	4770      	bx	lr

0001dd7c <__aeabi_llsl>:
   1dd7c:	4091      	lsls	r1, r2
   1dd7e:	1c03      	adds	r3, r0, #0
   1dd80:	4090      	lsls	r0, r2
   1dd82:	469c      	mov	ip, r3
   1dd84:	3a20      	subs	r2, #32
   1dd86:	4093      	lsls	r3, r2
   1dd88:	4319      	orrs	r1, r3
   1dd8a:	4252      	negs	r2, r2
   1dd8c:	4663      	mov	r3, ip
   1dd8e:	40d3      	lsrs	r3, r2
   1dd90:	4319      	orrs	r1, r3
   1dd92:	4770      	bx	lr

0001dd94 <__aeabi_cdrcmple>:
   1dd94:	4684      	mov	ip, r0
   1dd96:	1c10      	adds	r0, r2, #0
   1dd98:	4662      	mov	r2, ip
   1dd9a:	468c      	mov	ip, r1
   1dd9c:	1c19      	adds	r1, r3, #0
   1dd9e:	4663      	mov	r3, ip
   1dda0:	e000      	b.n	1dda4 <__aeabi_cdcmpeq>
   1dda2:	46c0      	nop			; (mov r8, r8)

0001dda4 <__aeabi_cdcmpeq>:
   1dda4:	b51f      	push	{r0, r1, r2, r3, r4, lr}
   1dda6:	f001 f863 	bl	1ee70 <__ledf2>
   1ddaa:	2800      	cmp	r0, #0
   1ddac:	d401      	bmi.n	1ddb2 <__aeabi_cdcmpeq+0xe>
   1ddae:	2100      	movs	r1, #0
   1ddb0:	42c8      	cmn	r0, r1
   1ddb2:	bd1f      	pop	{r0, r1, r2, r3, r4, pc}

0001ddb4 <__aeabi_dcmpeq>:
   1ddb4:	b510      	push	{r4, lr}
   1ddb6:	f000 ffb7 	bl	1ed28 <__eqdf2>
   1ddba:	4240      	negs	r0, r0
   1ddbc:	3001      	adds	r0, #1
   1ddbe:	bd10      	pop	{r4, pc}

0001ddc0 <__aeabi_dcmplt>:
   1ddc0:	b510      	push	{r4, lr}
   1ddc2:	f001 f855 	bl	1ee70 <__ledf2>
   1ddc6:	2800      	cmp	r0, #0
   1ddc8:	db01      	blt.n	1ddce <__aeabi_dcmplt+0xe>
   1ddca:	2000      	movs	r0, #0
   1ddcc:	bd10      	pop	{r4, pc}
   1ddce:	2001      	movs	r0, #1
   1ddd0:	bd10      	pop	{r4, pc}
   1ddd2:	46c0      	nop			; (mov r8, r8)

0001ddd4 <__aeabi_dcmple>:
   1ddd4:	b510      	push	{r4, lr}
   1ddd6:	f001 f84b 	bl	1ee70 <__ledf2>
   1ddda:	2800      	cmp	r0, #0
   1dddc:	dd01      	ble.n	1dde2 <__aeabi_dcmple+0xe>
   1ddde:	2000      	movs	r0, #0
   1dde0:	bd10      	pop	{r4, pc}
   1dde2:	2001      	movs	r0, #1
   1dde4:	bd10      	pop	{r4, pc}
   1dde6:	46c0      	nop			; (mov r8, r8)

0001dde8 <__aeabi_dcmpgt>:
   1dde8:	b510      	push	{r4, lr}
   1ddea:	f000 ffdd 	bl	1eda8 <__gedf2>
   1ddee:	2800      	cmp	r0, #0
   1ddf0:	dc01      	bgt.n	1ddf6 <__aeabi_dcmpgt+0xe>
   1ddf2:	2000      	movs	r0, #0
   1ddf4:	bd10      	pop	{r4, pc}
   1ddf6:	2001      	movs	r0, #1
   1ddf8:	bd10      	pop	{r4, pc}
   1ddfa:	46c0      	nop			; (mov r8, r8)

0001ddfc <__aeabi_dcmpge>:
   1ddfc:	b510      	push	{r4, lr}
   1ddfe:	f000 ffd3 	bl	1eda8 <__gedf2>
   1de02:	2800      	cmp	r0, #0
   1de04:	da01      	bge.n	1de0a <__aeabi_dcmpge+0xe>
   1de06:	2000      	movs	r0, #0
   1de08:	bd10      	pop	{r4, pc}
   1de0a:	2001      	movs	r0, #1
   1de0c:	bd10      	pop	{r4, pc}
   1de0e:	46c0      	nop			; (mov r8, r8)

0001de10 <__clzsi2>:
   1de10:	211c      	movs	r1, #28
   1de12:	2301      	movs	r3, #1
   1de14:	041b      	lsls	r3, r3, #16
   1de16:	4298      	cmp	r0, r3
   1de18:	d301      	bcc.n	1de1e <__clzsi2+0xe>
   1de1a:	0c00      	lsrs	r0, r0, #16
   1de1c:	3910      	subs	r1, #16
   1de1e:	0a1b      	lsrs	r3, r3, #8
   1de20:	4298      	cmp	r0, r3
   1de22:	d301      	bcc.n	1de28 <__clzsi2+0x18>
   1de24:	0a00      	lsrs	r0, r0, #8
   1de26:	3908      	subs	r1, #8
   1de28:	091b      	lsrs	r3, r3, #4
   1de2a:	4298      	cmp	r0, r3
   1de2c:	d301      	bcc.n	1de32 <__clzsi2+0x22>
   1de2e:	0900      	lsrs	r0, r0, #4
   1de30:	3904      	subs	r1, #4
   1de32:	a202      	add	r2, pc, #8	; (adr r2, 1de3c <__clzsi2+0x2c>)
   1de34:	5c10      	ldrb	r0, [r2, r0]
   1de36:	1840      	adds	r0, r0, r1
   1de38:	4770      	bx	lr
   1de3a:	46c0      	nop			; (mov r8, r8)
   1de3c:	02020304 	.word	0x02020304
   1de40:	01010101 	.word	0x01010101
	...

0001de4c <__ctzsi2>:
   1de4c:	4241      	negs	r1, r0
   1de4e:	4008      	ands	r0, r1
   1de50:	211c      	movs	r1, #28
   1de52:	2301      	movs	r3, #1
   1de54:	041b      	lsls	r3, r3, #16
   1de56:	4298      	cmp	r0, r3
   1de58:	d301      	bcc.n	1de5e <__ctzsi2+0x12>
   1de5a:	0c00      	lsrs	r0, r0, #16
   1de5c:	3910      	subs	r1, #16
   1de5e:	0a1b      	lsrs	r3, r3, #8
   1de60:	4298      	cmp	r0, r3
   1de62:	d301      	bcc.n	1de68 <__ctzsi2+0x1c>
   1de64:	0a00      	lsrs	r0, r0, #8
   1de66:	3908      	subs	r1, #8
   1de68:	091b      	lsrs	r3, r3, #4
   1de6a:	4298      	cmp	r0, r3
   1de6c:	d301      	bcc.n	1de72 <__ctzsi2+0x26>
   1de6e:	0900      	lsrs	r0, r0, #4
   1de70:	3904      	subs	r1, #4
   1de72:	a202      	add	r2, pc, #8	; (adr r2, 1de7c <__ctzsi2+0x30>)
   1de74:	5c10      	ldrb	r0, [r2, r0]
   1de76:	1a40      	subs	r0, r0, r1
   1de78:	4770      	bx	lr
   1de7a:	46c0      	nop			; (mov r8, r8)
   1de7c:	1d1d1c1b 	.word	0x1d1d1c1b
   1de80:	1e1e1e1e 	.word	0x1e1e1e1e
   1de84:	1f1f1f1f 	.word	0x1f1f1f1f
   1de88:	1f1f1f1f 	.word	0x1f1f1f1f

0001de8c <__aeabi_uldivmod>:
   1de8c:	2b00      	cmp	r3, #0
   1de8e:	d111      	bne.n	1deb4 <__aeabi_uldivmod+0x28>
   1de90:	2a00      	cmp	r2, #0
   1de92:	d10f      	bne.n	1deb4 <__aeabi_uldivmod+0x28>
   1de94:	2900      	cmp	r1, #0
   1de96:	d100      	bne.n	1de9a <__aeabi_uldivmod+0xe>
   1de98:	2800      	cmp	r0, #0
   1de9a:	d002      	beq.n	1dea2 <__aeabi_uldivmod+0x16>
   1de9c:	2100      	movs	r1, #0
   1de9e:	43c9      	mvns	r1, r1
   1dea0:	1c08      	adds	r0, r1, #0
   1dea2:	b407      	push	{r0, r1, r2}
   1dea4:	4802      	ldr	r0, [pc, #8]	; (1deb0 <__aeabi_uldivmod+0x24>)
   1dea6:	a102      	add	r1, pc, #8	; (adr r1, 1deb0 <__aeabi_uldivmod+0x24>)
   1dea8:	1840      	adds	r0, r0, r1
   1deaa:	9002      	str	r0, [sp, #8]
   1deac:	bd03      	pop	{r0, r1, pc}
   1deae:	46c0      	nop			; (mov r8, r8)
   1deb0:	00001dd1 	.word	0x00001dd1
   1deb4:	b403      	push	{r0, r1}
   1deb6:	4668      	mov	r0, sp
   1deb8:	b501      	push	{r0, lr}
   1deba:	9802      	ldr	r0, [sp, #8]
   1debc:	f000 f832 	bl	1df24 <__udivmoddi4>
   1dec0:	9b01      	ldr	r3, [sp, #4]
   1dec2:	469e      	mov	lr, r3
   1dec4:	b002      	add	sp, #8
   1dec6:	bc0c      	pop	{r2, r3}
   1dec8:	4770      	bx	lr
   1deca:	46c0      	nop			; (mov r8, r8)

0001decc <__aeabi_lmul>:
   1decc:	b5f0      	push	{r4, r5, r6, r7, lr}
   1dece:	464f      	mov	r7, r9
   1ded0:	4646      	mov	r6, r8
   1ded2:	b4c0      	push	{r6, r7}
   1ded4:	0416      	lsls	r6, r2, #16
   1ded6:	0c36      	lsrs	r6, r6, #16
   1ded8:	4699      	mov	r9, r3
   1deda:	0033      	movs	r3, r6
   1dedc:	0405      	lsls	r5, r0, #16
   1dede:	0c2c      	lsrs	r4, r5, #16
   1dee0:	0c07      	lsrs	r7, r0, #16
   1dee2:	0c15      	lsrs	r5, r2, #16
   1dee4:	4363      	muls	r3, r4
   1dee6:	437e      	muls	r6, r7
   1dee8:	436f      	muls	r7, r5
   1deea:	4365      	muls	r5, r4
   1deec:	0c1c      	lsrs	r4, r3, #16
   1deee:	19ad      	adds	r5, r5, r6
   1def0:	1964      	adds	r4, r4, r5
   1def2:	469c      	mov	ip, r3
   1def4:	42a6      	cmp	r6, r4
   1def6:	d903      	bls.n	1df00 <__aeabi_lmul+0x34>
   1def8:	2380      	movs	r3, #128	; 0x80
   1defa:	025b      	lsls	r3, r3, #9
   1defc:	4698      	mov	r8, r3
   1defe:	4447      	add	r7, r8
   1df00:	4663      	mov	r3, ip
   1df02:	0c25      	lsrs	r5, r4, #16
   1df04:	19ef      	adds	r7, r5, r7
   1df06:	041d      	lsls	r5, r3, #16
   1df08:	464b      	mov	r3, r9
   1df0a:	434a      	muls	r2, r1
   1df0c:	4343      	muls	r3, r0
   1df0e:	0c2d      	lsrs	r5, r5, #16
   1df10:	0424      	lsls	r4, r4, #16
   1df12:	1964      	adds	r4, r4, r5
   1df14:	1899      	adds	r1, r3, r2
   1df16:	19c9      	adds	r1, r1, r7
   1df18:	0020      	movs	r0, r4
   1df1a:	bc0c      	pop	{r2, r3}
   1df1c:	4690      	mov	r8, r2
   1df1e:	4699      	mov	r9, r3
   1df20:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1df22:	46c0      	nop			; (mov r8, r8)

0001df24 <__udivmoddi4>:
   1df24:	b5f0      	push	{r4, r5, r6, r7, lr}
   1df26:	464d      	mov	r5, r9
   1df28:	4656      	mov	r6, sl
   1df2a:	4644      	mov	r4, r8
   1df2c:	465f      	mov	r7, fp
   1df2e:	b4f0      	push	{r4, r5, r6, r7}
   1df30:	4692      	mov	sl, r2
   1df32:	b083      	sub	sp, #12
   1df34:	0004      	movs	r4, r0
   1df36:	000d      	movs	r5, r1
   1df38:	4699      	mov	r9, r3
   1df3a:	428b      	cmp	r3, r1
   1df3c:	d82f      	bhi.n	1df9e <__udivmoddi4+0x7a>
   1df3e:	d02c      	beq.n	1df9a <__udivmoddi4+0x76>
   1df40:	4649      	mov	r1, r9
   1df42:	4650      	mov	r0, sl
   1df44:	f001 fe9e 	bl	1fc84 <__clzdi2>
   1df48:	0029      	movs	r1, r5
   1df4a:	0006      	movs	r6, r0
   1df4c:	0020      	movs	r0, r4
   1df4e:	f001 fe99 	bl	1fc84 <__clzdi2>
   1df52:	1a33      	subs	r3, r6, r0
   1df54:	4698      	mov	r8, r3
   1df56:	3b20      	subs	r3, #32
   1df58:	469b      	mov	fp, r3
   1df5a:	d500      	bpl.n	1df5e <__udivmoddi4+0x3a>
   1df5c:	e074      	b.n	1e048 <__udivmoddi4+0x124>
   1df5e:	4653      	mov	r3, sl
   1df60:	465a      	mov	r2, fp
   1df62:	4093      	lsls	r3, r2
   1df64:	001f      	movs	r7, r3
   1df66:	4653      	mov	r3, sl
   1df68:	4642      	mov	r2, r8
   1df6a:	4093      	lsls	r3, r2
   1df6c:	001e      	movs	r6, r3
   1df6e:	42af      	cmp	r7, r5
   1df70:	d829      	bhi.n	1dfc6 <__udivmoddi4+0xa2>
   1df72:	d026      	beq.n	1dfc2 <__udivmoddi4+0x9e>
   1df74:	465b      	mov	r3, fp
   1df76:	1ba4      	subs	r4, r4, r6
   1df78:	41bd      	sbcs	r5, r7
   1df7a:	2b00      	cmp	r3, #0
   1df7c:	da00      	bge.n	1df80 <__udivmoddi4+0x5c>
   1df7e:	e079      	b.n	1e074 <__udivmoddi4+0x150>
   1df80:	2200      	movs	r2, #0
   1df82:	2300      	movs	r3, #0
   1df84:	9200      	str	r2, [sp, #0]
   1df86:	9301      	str	r3, [sp, #4]
   1df88:	2301      	movs	r3, #1
   1df8a:	465a      	mov	r2, fp
   1df8c:	4093      	lsls	r3, r2
   1df8e:	9301      	str	r3, [sp, #4]
   1df90:	2301      	movs	r3, #1
   1df92:	4642      	mov	r2, r8
   1df94:	4093      	lsls	r3, r2
   1df96:	9300      	str	r3, [sp, #0]
   1df98:	e019      	b.n	1dfce <__udivmoddi4+0xaa>
   1df9a:	4282      	cmp	r2, r0
   1df9c:	d9d0      	bls.n	1df40 <__udivmoddi4+0x1c>
   1df9e:	2200      	movs	r2, #0
   1dfa0:	2300      	movs	r3, #0
   1dfa2:	9200      	str	r2, [sp, #0]
   1dfa4:	9301      	str	r3, [sp, #4]
   1dfa6:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   1dfa8:	2b00      	cmp	r3, #0
   1dfaa:	d001      	beq.n	1dfb0 <__udivmoddi4+0x8c>
   1dfac:	601c      	str	r4, [r3, #0]
   1dfae:	605d      	str	r5, [r3, #4]
   1dfb0:	9800      	ldr	r0, [sp, #0]
   1dfb2:	9901      	ldr	r1, [sp, #4]
   1dfb4:	b003      	add	sp, #12
   1dfb6:	bc3c      	pop	{r2, r3, r4, r5}
   1dfb8:	4690      	mov	r8, r2
   1dfba:	4699      	mov	r9, r3
   1dfbc:	46a2      	mov	sl, r4
   1dfbe:	46ab      	mov	fp, r5
   1dfc0:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1dfc2:	42a3      	cmp	r3, r4
   1dfc4:	d9d6      	bls.n	1df74 <__udivmoddi4+0x50>
   1dfc6:	2200      	movs	r2, #0
   1dfc8:	2300      	movs	r3, #0
   1dfca:	9200      	str	r2, [sp, #0]
   1dfcc:	9301      	str	r3, [sp, #4]
   1dfce:	4643      	mov	r3, r8
   1dfd0:	2b00      	cmp	r3, #0
   1dfd2:	d0e8      	beq.n	1dfa6 <__udivmoddi4+0x82>
   1dfd4:	07fb      	lsls	r3, r7, #31
   1dfd6:	0872      	lsrs	r2, r6, #1
   1dfd8:	431a      	orrs	r2, r3
   1dfda:	4646      	mov	r6, r8
   1dfdc:	087b      	lsrs	r3, r7, #1
   1dfde:	e00e      	b.n	1dffe <__udivmoddi4+0xda>
   1dfe0:	42ab      	cmp	r3, r5
   1dfe2:	d101      	bne.n	1dfe8 <__udivmoddi4+0xc4>
   1dfe4:	42a2      	cmp	r2, r4
   1dfe6:	d80c      	bhi.n	1e002 <__udivmoddi4+0xde>
   1dfe8:	1aa4      	subs	r4, r4, r2
   1dfea:	419d      	sbcs	r5, r3
   1dfec:	2001      	movs	r0, #1
   1dfee:	1924      	adds	r4, r4, r4
   1dff0:	416d      	adcs	r5, r5
   1dff2:	2100      	movs	r1, #0
   1dff4:	3e01      	subs	r6, #1
   1dff6:	1824      	adds	r4, r4, r0
   1dff8:	414d      	adcs	r5, r1
   1dffa:	2e00      	cmp	r6, #0
   1dffc:	d006      	beq.n	1e00c <__udivmoddi4+0xe8>
   1dffe:	42ab      	cmp	r3, r5
   1e000:	d9ee      	bls.n	1dfe0 <__udivmoddi4+0xbc>
   1e002:	3e01      	subs	r6, #1
   1e004:	1924      	adds	r4, r4, r4
   1e006:	416d      	adcs	r5, r5
   1e008:	2e00      	cmp	r6, #0
   1e00a:	d1f8      	bne.n	1dffe <__udivmoddi4+0xda>
   1e00c:	465b      	mov	r3, fp
   1e00e:	9800      	ldr	r0, [sp, #0]
   1e010:	9901      	ldr	r1, [sp, #4]
   1e012:	1900      	adds	r0, r0, r4
   1e014:	4169      	adcs	r1, r5
   1e016:	2b00      	cmp	r3, #0
   1e018:	db22      	blt.n	1e060 <__udivmoddi4+0x13c>
   1e01a:	002b      	movs	r3, r5
   1e01c:	465a      	mov	r2, fp
   1e01e:	40d3      	lsrs	r3, r2
   1e020:	002a      	movs	r2, r5
   1e022:	4644      	mov	r4, r8
   1e024:	40e2      	lsrs	r2, r4
   1e026:	001c      	movs	r4, r3
   1e028:	465b      	mov	r3, fp
   1e02a:	0015      	movs	r5, r2
   1e02c:	2b00      	cmp	r3, #0
   1e02e:	db2c      	blt.n	1e08a <__udivmoddi4+0x166>
   1e030:	0026      	movs	r6, r4
   1e032:	409e      	lsls	r6, r3
   1e034:	0033      	movs	r3, r6
   1e036:	0026      	movs	r6, r4
   1e038:	4647      	mov	r7, r8
   1e03a:	40be      	lsls	r6, r7
   1e03c:	0032      	movs	r2, r6
   1e03e:	1a80      	subs	r0, r0, r2
   1e040:	4199      	sbcs	r1, r3
   1e042:	9000      	str	r0, [sp, #0]
   1e044:	9101      	str	r1, [sp, #4]
   1e046:	e7ae      	b.n	1dfa6 <__udivmoddi4+0x82>
   1e048:	4642      	mov	r2, r8
   1e04a:	2320      	movs	r3, #32
   1e04c:	1a9b      	subs	r3, r3, r2
   1e04e:	4652      	mov	r2, sl
   1e050:	40da      	lsrs	r2, r3
   1e052:	4641      	mov	r1, r8
   1e054:	0013      	movs	r3, r2
   1e056:	464a      	mov	r2, r9
   1e058:	408a      	lsls	r2, r1
   1e05a:	0017      	movs	r7, r2
   1e05c:	431f      	orrs	r7, r3
   1e05e:	e782      	b.n	1df66 <__udivmoddi4+0x42>
   1e060:	4642      	mov	r2, r8
   1e062:	2320      	movs	r3, #32
   1e064:	1a9b      	subs	r3, r3, r2
   1e066:	002a      	movs	r2, r5
   1e068:	4646      	mov	r6, r8
   1e06a:	409a      	lsls	r2, r3
   1e06c:	0023      	movs	r3, r4
   1e06e:	40f3      	lsrs	r3, r6
   1e070:	4313      	orrs	r3, r2
   1e072:	e7d5      	b.n	1e020 <__udivmoddi4+0xfc>
   1e074:	4642      	mov	r2, r8
   1e076:	2320      	movs	r3, #32
   1e078:	2100      	movs	r1, #0
   1e07a:	1a9b      	subs	r3, r3, r2
   1e07c:	2200      	movs	r2, #0
   1e07e:	9100      	str	r1, [sp, #0]
   1e080:	9201      	str	r2, [sp, #4]
   1e082:	2201      	movs	r2, #1
   1e084:	40da      	lsrs	r2, r3
   1e086:	9201      	str	r2, [sp, #4]
   1e088:	e782      	b.n	1df90 <__udivmoddi4+0x6c>
   1e08a:	4642      	mov	r2, r8
   1e08c:	2320      	movs	r3, #32
   1e08e:	0026      	movs	r6, r4
   1e090:	1a9b      	subs	r3, r3, r2
   1e092:	40de      	lsrs	r6, r3
   1e094:	002f      	movs	r7, r5
   1e096:	46b4      	mov	ip, r6
   1e098:	4097      	lsls	r7, r2
   1e09a:	4666      	mov	r6, ip
   1e09c:	003b      	movs	r3, r7
   1e09e:	4333      	orrs	r3, r6
   1e0a0:	e7c9      	b.n	1e036 <__udivmoddi4+0x112>
   1e0a2:	46c0      	nop			; (mov r8, r8)

0001e0a4 <__aeabi_dadd>:
   1e0a4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1e0a6:	4656      	mov	r6, sl
   1e0a8:	465f      	mov	r7, fp
   1e0aa:	464d      	mov	r5, r9
   1e0ac:	4644      	mov	r4, r8
   1e0ae:	b4f0      	push	{r4, r5, r6, r7}
   1e0b0:	000f      	movs	r7, r1
   1e0b2:	0ffd      	lsrs	r5, r7, #31
   1e0b4:	46aa      	mov	sl, r5
   1e0b6:	0309      	lsls	r1, r1, #12
   1e0b8:	007c      	lsls	r4, r7, #1
   1e0ba:	002e      	movs	r6, r5
   1e0bc:	005f      	lsls	r7, r3, #1
   1e0be:	0f45      	lsrs	r5, r0, #29
   1e0c0:	0a49      	lsrs	r1, r1, #9
   1e0c2:	0d7f      	lsrs	r7, r7, #21
   1e0c4:	4329      	orrs	r1, r5
   1e0c6:	00c5      	lsls	r5, r0, #3
   1e0c8:	0318      	lsls	r0, r3, #12
   1e0ca:	46bc      	mov	ip, r7
   1e0cc:	0a40      	lsrs	r0, r0, #9
   1e0ce:	0f57      	lsrs	r7, r2, #29
   1e0d0:	0d64      	lsrs	r4, r4, #21
   1e0d2:	0fdb      	lsrs	r3, r3, #31
   1e0d4:	4338      	orrs	r0, r7
   1e0d6:	00d2      	lsls	r2, r2, #3
   1e0d8:	459a      	cmp	sl, r3
   1e0da:	d100      	bne.n	1e0de <__aeabi_dadd+0x3a>
   1e0dc:	e0aa      	b.n	1e234 <__aeabi_dadd+0x190>
   1e0de:	4666      	mov	r6, ip
   1e0e0:	1ba6      	subs	r6, r4, r6
   1e0e2:	2e00      	cmp	r6, #0
   1e0e4:	dc00      	bgt.n	1e0e8 <__aeabi_dadd+0x44>
   1e0e6:	e0ff      	b.n	1e2e8 <__aeabi_dadd+0x244>
   1e0e8:	4663      	mov	r3, ip
   1e0ea:	2b00      	cmp	r3, #0
   1e0ec:	d139      	bne.n	1e162 <__aeabi_dadd+0xbe>
   1e0ee:	0003      	movs	r3, r0
   1e0f0:	4313      	orrs	r3, r2
   1e0f2:	d000      	beq.n	1e0f6 <__aeabi_dadd+0x52>
   1e0f4:	e0d9      	b.n	1e2aa <__aeabi_dadd+0x206>
   1e0f6:	076b      	lsls	r3, r5, #29
   1e0f8:	d009      	beq.n	1e10e <__aeabi_dadd+0x6a>
   1e0fa:	230f      	movs	r3, #15
   1e0fc:	402b      	ands	r3, r5
   1e0fe:	2b04      	cmp	r3, #4
   1e100:	d005      	beq.n	1e10e <__aeabi_dadd+0x6a>
   1e102:	1d2b      	adds	r3, r5, #4
   1e104:	42ab      	cmp	r3, r5
   1e106:	41ad      	sbcs	r5, r5
   1e108:	426d      	negs	r5, r5
   1e10a:	1949      	adds	r1, r1, r5
   1e10c:	001d      	movs	r5, r3
   1e10e:	020b      	lsls	r3, r1, #8
   1e110:	d400      	bmi.n	1e114 <__aeabi_dadd+0x70>
   1e112:	e082      	b.n	1e21a <__aeabi_dadd+0x176>
   1e114:	4bca      	ldr	r3, [pc, #808]	; (1e440 <__aeabi_dadd+0x39c>)
   1e116:	3401      	adds	r4, #1
   1e118:	429c      	cmp	r4, r3
   1e11a:	d100      	bne.n	1e11e <__aeabi_dadd+0x7a>
   1e11c:	e0fe      	b.n	1e31c <__aeabi_dadd+0x278>
   1e11e:	000a      	movs	r2, r1
   1e120:	4656      	mov	r6, sl
   1e122:	4bc8      	ldr	r3, [pc, #800]	; (1e444 <__aeabi_dadd+0x3a0>)
   1e124:	08ed      	lsrs	r5, r5, #3
   1e126:	401a      	ands	r2, r3
   1e128:	0750      	lsls	r0, r2, #29
   1e12a:	0564      	lsls	r4, r4, #21
   1e12c:	0252      	lsls	r2, r2, #9
   1e12e:	4305      	orrs	r5, r0
   1e130:	0b12      	lsrs	r2, r2, #12
   1e132:	0d64      	lsrs	r4, r4, #21
   1e134:	2100      	movs	r1, #0
   1e136:	0312      	lsls	r2, r2, #12
   1e138:	0d0b      	lsrs	r3, r1, #20
   1e13a:	051b      	lsls	r3, r3, #20
   1e13c:	0564      	lsls	r4, r4, #21
   1e13e:	0b12      	lsrs	r2, r2, #12
   1e140:	431a      	orrs	r2, r3
   1e142:	0863      	lsrs	r3, r4, #1
   1e144:	4cc0      	ldr	r4, [pc, #768]	; (1e448 <__aeabi_dadd+0x3a4>)
   1e146:	07f6      	lsls	r6, r6, #31
   1e148:	4014      	ands	r4, r2
   1e14a:	431c      	orrs	r4, r3
   1e14c:	0064      	lsls	r4, r4, #1
   1e14e:	0864      	lsrs	r4, r4, #1
   1e150:	4334      	orrs	r4, r6
   1e152:	0028      	movs	r0, r5
   1e154:	0021      	movs	r1, r4
   1e156:	bc3c      	pop	{r2, r3, r4, r5}
   1e158:	4690      	mov	r8, r2
   1e15a:	4699      	mov	r9, r3
   1e15c:	46a2      	mov	sl, r4
   1e15e:	46ab      	mov	fp, r5
   1e160:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1e162:	4bb7      	ldr	r3, [pc, #732]	; (1e440 <__aeabi_dadd+0x39c>)
   1e164:	429c      	cmp	r4, r3
   1e166:	d0c6      	beq.n	1e0f6 <__aeabi_dadd+0x52>
   1e168:	2380      	movs	r3, #128	; 0x80
   1e16a:	041b      	lsls	r3, r3, #16
   1e16c:	4318      	orrs	r0, r3
   1e16e:	2e38      	cmp	r6, #56	; 0x38
   1e170:	dd00      	ble.n	1e174 <__aeabi_dadd+0xd0>
   1e172:	e0eb      	b.n	1e34c <__aeabi_dadd+0x2a8>
   1e174:	2e1f      	cmp	r6, #31
   1e176:	dd00      	ble.n	1e17a <__aeabi_dadd+0xd6>
   1e178:	e11e      	b.n	1e3b8 <__aeabi_dadd+0x314>
   1e17a:	2320      	movs	r3, #32
   1e17c:	1b9b      	subs	r3, r3, r6
   1e17e:	469c      	mov	ip, r3
   1e180:	0003      	movs	r3, r0
   1e182:	4667      	mov	r7, ip
   1e184:	40bb      	lsls	r3, r7
   1e186:	4698      	mov	r8, r3
   1e188:	0013      	movs	r3, r2
   1e18a:	4647      	mov	r7, r8
   1e18c:	40f3      	lsrs	r3, r6
   1e18e:	433b      	orrs	r3, r7
   1e190:	4667      	mov	r7, ip
   1e192:	40ba      	lsls	r2, r7
   1e194:	1e57      	subs	r7, r2, #1
   1e196:	41ba      	sbcs	r2, r7
   1e198:	4313      	orrs	r3, r2
   1e19a:	0002      	movs	r2, r0
   1e19c:	40f2      	lsrs	r2, r6
   1e19e:	1aeb      	subs	r3, r5, r3
   1e1a0:	429d      	cmp	r5, r3
   1e1a2:	41b6      	sbcs	r6, r6
   1e1a4:	001d      	movs	r5, r3
   1e1a6:	1a8a      	subs	r2, r1, r2
   1e1a8:	4276      	negs	r6, r6
   1e1aa:	1b91      	subs	r1, r2, r6
   1e1ac:	020b      	lsls	r3, r1, #8
   1e1ae:	d531      	bpl.n	1e214 <__aeabi_dadd+0x170>
   1e1b0:	024a      	lsls	r2, r1, #9
   1e1b2:	0a56      	lsrs	r6, r2, #9
   1e1b4:	2e00      	cmp	r6, #0
   1e1b6:	d100      	bne.n	1e1ba <__aeabi_dadd+0x116>
   1e1b8:	e0b4      	b.n	1e324 <__aeabi_dadd+0x280>
   1e1ba:	0030      	movs	r0, r6
   1e1bc:	f7ff fe28 	bl	1de10 <__clzsi2>
   1e1c0:	0003      	movs	r3, r0
   1e1c2:	3b08      	subs	r3, #8
   1e1c4:	2b1f      	cmp	r3, #31
   1e1c6:	dd00      	ble.n	1e1ca <__aeabi_dadd+0x126>
   1e1c8:	e0b5      	b.n	1e336 <__aeabi_dadd+0x292>
   1e1ca:	2220      	movs	r2, #32
   1e1cc:	0029      	movs	r1, r5
   1e1ce:	1ad2      	subs	r2, r2, r3
   1e1d0:	40d1      	lsrs	r1, r2
   1e1d2:	409e      	lsls	r6, r3
   1e1d4:	000a      	movs	r2, r1
   1e1d6:	409d      	lsls	r5, r3
   1e1d8:	4332      	orrs	r2, r6
   1e1da:	429c      	cmp	r4, r3
   1e1dc:	dd00      	ble.n	1e1e0 <__aeabi_dadd+0x13c>
   1e1de:	e0b1      	b.n	1e344 <__aeabi_dadd+0x2a0>
   1e1e0:	1b1c      	subs	r4, r3, r4
   1e1e2:	1c63      	adds	r3, r4, #1
   1e1e4:	2b1f      	cmp	r3, #31
   1e1e6:	dd00      	ble.n	1e1ea <__aeabi_dadd+0x146>
   1e1e8:	e0d5      	b.n	1e396 <__aeabi_dadd+0x2f2>
   1e1ea:	2120      	movs	r1, #32
   1e1ec:	0014      	movs	r4, r2
   1e1ee:	0028      	movs	r0, r5
   1e1f0:	1ac9      	subs	r1, r1, r3
   1e1f2:	408c      	lsls	r4, r1
   1e1f4:	40d8      	lsrs	r0, r3
   1e1f6:	408d      	lsls	r5, r1
   1e1f8:	4304      	orrs	r4, r0
   1e1fa:	40da      	lsrs	r2, r3
   1e1fc:	1e68      	subs	r0, r5, #1
   1e1fe:	4185      	sbcs	r5, r0
   1e200:	0011      	movs	r1, r2
   1e202:	4325      	orrs	r5, r4
   1e204:	2400      	movs	r4, #0
   1e206:	e776      	b.n	1e0f6 <__aeabi_dadd+0x52>
   1e208:	4641      	mov	r1, r8
   1e20a:	4331      	orrs	r1, r6
   1e20c:	d100      	bne.n	1e210 <__aeabi_dadd+0x16c>
   1e20e:	e234      	b.n	1e67a <__aeabi_dadd+0x5d6>
   1e210:	0031      	movs	r1, r6
   1e212:	4645      	mov	r5, r8
   1e214:	076b      	lsls	r3, r5, #29
   1e216:	d000      	beq.n	1e21a <__aeabi_dadd+0x176>
   1e218:	e76f      	b.n	1e0fa <__aeabi_dadd+0x56>
   1e21a:	4656      	mov	r6, sl
   1e21c:	0748      	lsls	r0, r1, #29
   1e21e:	08ed      	lsrs	r5, r5, #3
   1e220:	08c9      	lsrs	r1, r1, #3
   1e222:	4305      	orrs	r5, r0
   1e224:	4b86      	ldr	r3, [pc, #536]	; (1e440 <__aeabi_dadd+0x39c>)
   1e226:	429c      	cmp	r4, r3
   1e228:	d035      	beq.n	1e296 <__aeabi_dadd+0x1f2>
   1e22a:	030a      	lsls	r2, r1, #12
   1e22c:	0564      	lsls	r4, r4, #21
   1e22e:	0b12      	lsrs	r2, r2, #12
   1e230:	0d64      	lsrs	r4, r4, #21
   1e232:	e77f      	b.n	1e134 <__aeabi_dadd+0x90>
   1e234:	4663      	mov	r3, ip
   1e236:	1ae3      	subs	r3, r4, r3
   1e238:	469b      	mov	fp, r3
   1e23a:	2b00      	cmp	r3, #0
   1e23c:	dc00      	bgt.n	1e240 <__aeabi_dadd+0x19c>
   1e23e:	e08b      	b.n	1e358 <__aeabi_dadd+0x2b4>
   1e240:	4667      	mov	r7, ip
   1e242:	2f00      	cmp	r7, #0
   1e244:	d03c      	beq.n	1e2c0 <__aeabi_dadd+0x21c>
   1e246:	4f7e      	ldr	r7, [pc, #504]	; (1e440 <__aeabi_dadd+0x39c>)
   1e248:	42bc      	cmp	r4, r7
   1e24a:	d100      	bne.n	1e24e <__aeabi_dadd+0x1aa>
   1e24c:	e753      	b.n	1e0f6 <__aeabi_dadd+0x52>
   1e24e:	2780      	movs	r7, #128	; 0x80
   1e250:	043f      	lsls	r7, r7, #16
   1e252:	4338      	orrs	r0, r7
   1e254:	465b      	mov	r3, fp
   1e256:	2b38      	cmp	r3, #56	; 0x38
   1e258:	dc00      	bgt.n	1e25c <__aeabi_dadd+0x1b8>
   1e25a:	e0f7      	b.n	1e44c <__aeabi_dadd+0x3a8>
   1e25c:	4302      	orrs	r2, r0
   1e25e:	1e50      	subs	r0, r2, #1
   1e260:	4182      	sbcs	r2, r0
   1e262:	2000      	movs	r0, #0
   1e264:	b2d2      	uxtb	r2, r2
   1e266:	1953      	adds	r3, r2, r5
   1e268:	1842      	adds	r2, r0, r1
   1e26a:	42ab      	cmp	r3, r5
   1e26c:	4189      	sbcs	r1, r1
   1e26e:	001d      	movs	r5, r3
   1e270:	4249      	negs	r1, r1
   1e272:	1889      	adds	r1, r1, r2
   1e274:	020b      	lsls	r3, r1, #8
   1e276:	d5cd      	bpl.n	1e214 <__aeabi_dadd+0x170>
   1e278:	4b71      	ldr	r3, [pc, #452]	; (1e440 <__aeabi_dadd+0x39c>)
   1e27a:	3401      	adds	r4, #1
   1e27c:	429c      	cmp	r4, r3
   1e27e:	d100      	bne.n	1e282 <__aeabi_dadd+0x1de>
   1e280:	e13d      	b.n	1e4fe <__aeabi_dadd+0x45a>
   1e282:	2001      	movs	r0, #1
   1e284:	4a6f      	ldr	r2, [pc, #444]	; (1e444 <__aeabi_dadd+0x3a0>)
   1e286:	086b      	lsrs	r3, r5, #1
   1e288:	400a      	ands	r2, r1
   1e28a:	4028      	ands	r0, r5
   1e28c:	4318      	orrs	r0, r3
   1e28e:	07d5      	lsls	r5, r2, #31
   1e290:	4305      	orrs	r5, r0
   1e292:	0851      	lsrs	r1, r2, #1
   1e294:	e72f      	b.n	1e0f6 <__aeabi_dadd+0x52>
   1e296:	002b      	movs	r3, r5
   1e298:	430b      	orrs	r3, r1
   1e29a:	d100      	bne.n	1e29e <__aeabi_dadd+0x1fa>
   1e29c:	e1cb      	b.n	1e636 <__aeabi_dadd+0x592>
   1e29e:	2380      	movs	r3, #128	; 0x80
   1e2a0:	031b      	lsls	r3, r3, #12
   1e2a2:	430b      	orrs	r3, r1
   1e2a4:	031a      	lsls	r2, r3, #12
   1e2a6:	0b12      	lsrs	r2, r2, #12
   1e2a8:	e744      	b.n	1e134 <__aeabi_dadd+0x90>
   1e2aa:	3e01      	subs	r6, #1
   1e2ac:	2e00      	cmp	r6, #0
   1e2ae:	d16d      	bne.n	1e38c <__aeabi_dadd+0x2e8>
   1e2b0:	1aae      	subs	r6, r5, r2
   1e2b2:	42b5      	cmp	r5, r6
   1e2b4:	419b      	sbcs	r3, r3
   1e2b6:	1a09      	subs	r1, r1, r0
   1e2b8:	425b      	negs	r3, r3
   1e2ba:	1ac9      	subs	r1, r1, r3
   1e2bc:	0035      	movs	r5, r6
   1e2be:	e775      	b.n	1e1ac <__aeabi_dadd+0x108>
   1e2c0:	0007      	movs	r7, r0
   1e2c2:	4317      	orrs	r7, r2
   1e2c4:	d100      	bne.n	1e2c8 <__aeabi_dadd+0x224>
   1e2c6:	e716      	b.n	1e0f6 <__aeabi_dadd+0x52>
   1e2c8:	2301      	movs	r3, #1
   1e2ca:	425b      	negs	r3, r3
   1e2cc:	469c      	mov	ip, r3
   1e2ce:	44e3      	add	fp, ip
   1e2d0:	465b      	mov	r3, fp
   1e2d2:	2b00      	cmp	r3, #0
   1e2d4:	d000      	beq.n	1e2d8 <__aeabi_dadd+0x234>
   1e2d6:	e0e0      	b.n	1e49a <__aeabi_dadd+0x3f6>
   1e2d8:	18aa      	adds	r2, r5, r2
   1e2da:	42aa      	cmp	r2, r5
   1e2dc:	419b      	sbcs	r3, r3
   1e2de:	1809      	adds	r1, r1, r0
   1e2e0:	425b      	negs	r3, r3
   1e2e2:	1859      	adds	r1, r3, r1
   1e2e4:	0015      	movs	r5, r2
   1e2e6:	e7c5      	b.n	1e274 <__aeabi_dadd+0x1d0>
   1e2e8:	2e00      	cmp	r6, #0
   1e2ea:	d175      	bne.n	1e3d8 <__aeabi_dadd+0x334>
   1e2ec:	1c66      	adds	r6, r4, #1
   1e2ee:	0576      	lsls	r6, r6, #21
   1e2f0:	0d76      	lsrs	r6, r6, #21
   1e2f2:	2e01      	cmp	r6, #1
   1e2f4:	dc00      	bgt.n	1e2f8 <__aeabi_dadd+0x254>
   1e2f6:	e0f3      	b.n	1e4e0 <__aeabi_dadd+0x43c>
   1e2f8:	1aae      	subs	r6, r5, r2
   1e2fa:	46b0      	mov	r8, r6
   1e2fc:	4545      	cmp	r5, r8
   1e2fe:	41bf      	sbcs	r7, r7
   1e300:	1a0e      	subs	r6, r1, r0
   1e302:	427f      	negs	r7, r7
   1e304:	1bf6      	subs	r6, r6, r7
   1e306:	0237      	lsls	r7, r6, #8
   1e308:	d400      	bmi.n	1e30c <__aeabi_dadd+0x268>
   1e30a:	e08f      	b.n	1e42c <__aeabi_dadd+0x388>
   1e30c:	1b55      	subs	r5, r2, r5
   1e30e:	42aa      	cmp	r2, r5
   1e310:	41b6      	sbcs	r6, r6
   1e312:	1a41      	subs	r1, r0, r1
   1e314:	4276      	negs	r6, r6
   1e316:	1b8e      	subs	r6, r1, r6
   1e318:	469a      	mov	sl, r3
   1e31a:	e74b      	b.n	1e1b4 <__aeabi_dadd+0x110>
   1e31c:	4656      	mov	r6, sl
   1e31e:	2200      	movs	r2, #0
   1e320:	2500      	movs	r5, #0
   1e322:	e707      	b.n	1e134 <__aeabi_dadd+0x90>
   1e324:	0028      	movs	r0, r5
   1e326:	f7ff fd73 	bl	1de10 <__clzsi2>
   1e32a:	3020      	adds	r0, #32
   1e32c:	0003      	movs	r3, r0
   1e32e:	3b08      	subs	r3, #8
   1e330:	2b1f      	cmp	r3, #31
   1e332:	dc00      	bgt.n	1e336 <__aeabi_dadd+0x292>
   1e334:	e749      	b.n	1e1ca <__aeabi_dadd+0x126>
   1e336:	002a      	movs	r2, r5
   1e338:	3828      	subs	r0, #40	; 0x28
   1e33a:	4082      	lsls	r2, r0
   1e33c:	2500      	movs	r5, #0
   1e33e:	429c      	cmp	r4, r3
   1e340:	dc00      	bgt.n	1e344 <__aeabi_dadd+0x2a0>
   1e342:	e74d      	b.n	1e1e0 <__aeabi_dadd+0x13c>
   1e344:	493f      	ldr	r1, [pc, #252]	; (1e444 <__aeabi_dadd+0x3a0>)
   1e346:	1ae4      	subs	r4, r4, r3
   1e348:	4011      	ands	r1, r2
   1e34a:	e6d4      	b.n	1e0f6 <__aeabi_dadd+0x52>
   1e34c:	4302      	orrs	r2, r0
   1e34e:	1e50      	subs	r0, r2, #1
   1e350:	4182      	sbcs	r2, r0
   1e352:	b2d3      	uxtb	r3, r2
   1e354:	2200      	movs	r2, #0
   1e356:	e722      	b.n	1e19e <__aeabi_dadd+0xfa>
   1e358:	2b00      	cmp	r3, #0
   1e35a:	d000      	beq.n	1e35e <__aeabi_dadd+0x2ba>
   1e35c:	e0f3      	b.n	1e546 <__aeabi_dadd+0x4a2>
   1e35e:	1c63      	adds	r3, r4, #1
   1e360:	469c      	mov	ip, r3
   1e362:	055b      	lsls	r3, r3, #21
   1e364:	0d5b      	lsrs	r3, r3, #21
   1e366:	2b01      	cmp	r3, #1
   1e368:	dc00      	bgt.n	1e36c <__aeabi_dadd+0x2c8>
   1e36a:	e09f      	b.n	1e4ac <__aeabi_dadd+0x408>
   1e36c:	4b34      	ldr	r3, [pc, #208]	; (1e440 <__aeabi_dadd+0x39c>)
   1e36e:	459c      	cmp	ip, r3
   1e370:	d100      	bne.n	1e374 <__aeabi_dadd+0x2d0>
   1e372:	e0c3      	b.n	1e4fc <__aeabi_dadd+0x458>
   1e374:	18aa      	adds	r2, r5, r2
   1e376:	1809      	adds	r1, r1, r0
   1e378:	42aa      	cmp	r2, r5
   1e37a:	4180      	sbcs	r0, r0
   1e37c:	4240      	negs	r0, r0
   1e37e:	1841      	adds	r1, r0, r1
   1e380:	07cd      	lsls	r5, r1, #31
   1e382:	0852      	lsrs	r2, r2, #1
   1e384:	4315      	orrs	r5, r2
   1e386:	0849      	lsrs	r1, r1, #1
   1e388:	4664      	mov	r4, ip
   1e38a:	e6b4      	b.n	1e0f6 <__aeabi_dadd+0x52>
   1e38c:	4b2c      	ldr	r3, [pc, #176]	; (1e440 <__aeabi_dadd+0x39c>)
   1e38e:	429c      	cmp	r4, r3
   1e390:	d000      	beq.n	1e394 <__aeabi_dadd+0x2f0>
   1e392:	e6ec      	b.n	1e16e <__aeabi_dadd+0xca>
   1e394:	e6af      	b.n	1e0f6 <__aeabi_dadd+0x52>
   1e396:	0011      	movs	r1, r2
   1e398:	3c1f      	subs	r4, #31
   1e39a:	40e1      	lsrs	r1, r4
   1e39c:	000c      	movs	r4, r1
   1e39e:	2b20      	cmp	r3, #32
   1e3a0:	d100      	bne.n	1e3a4 <__aeabi_dadd+0x300>
   1e3a2:	e07f      	b.n	1e4a4 <__aeabi_dadd+0x400>
   1e3a4:	2140      	movs	r1, #64	; 0x40
   1e3a6:	1acb      	subs	r3, r1, r3
   1e3a8:	409a      	lsls	r2, r3
   1e3aa:	4315      	orrs	r5, r2
   1e3ac:	1e6a      	subs	r2, r5, #1
   1e3ae:	4195      	sbcs	r5, r2
   1e3b0:	2100      	movs	r1, #0
   1e3b2:	4325      	orrs	r5, r4
   1e3b4:	2400      	movs	r4, #0
   1e3b6:	e72d      	b.n	1e214 <__aeabi_dadd+0x170>
   1e3b8:	0033      	movs	r3, r6
   1e3ba:	0007      	movs	r7, r0
   1e3bc:	3b20      	subs	r3, #32
   1e3be:	40df      	lsrs	r7, r3
   1e3c0:	003b      	movs	r3, r7
   1e3c2:	2e20      	cmp	r6, #32
   1e3c4:	d070      	beq.n	1e4a8 <__aeabi_dadd+0x404>
   1e3c6:	2740      	movs	r7, #64	; 0x40
   1e3c8:	1bbe      	subs	r6, r7, r6
   1e3ca:	40b0      	lsls	r0, r6
   1e3cc:	4302      	orrs	r2, r0
   1e3ce:	1e50      	subs	r0, r2, #1
   1e3d0:	4182      	sbcs	r2, r0
   1e3d2:	4313      	orrs	r3, r2
   1e3d4:	2200      	movs	r2, #0
   1e3d6:	e6e2      	b.n	1e19e <__aeabi_dadd+0xfa>
   1e3d8:	2c00      	cmp	r4, #0
   1e3da:	d04f      	beq.n	1e47c <__aeabi_dadd+0x3d8>
   1e3dc:	4c18      	ldr	r4, [pc, #96]	; (1e440 <__aeabi_dadd+0x39c>)
   1e3de:	45a4      	cmp	ip, r4
   1e3e0:	d100      	bne.n	1e3e4 <__aeabi_dadd+0x340>
   1e3e2:	e0ab      	b.n	1e53c <__aeabi_dadd+0x498>
   1e3e4:	2480      	movs	r4, #128	; 0x80
   1e3e6:	0424      	lsls	r4, r4, #16
   1e3e8:	4276      	negs	r6, r6
   1e3ea:	4321      	orrs	r1, r4
   1e3ec:	2e38      	cmp	r6, #56	; 0x38
   1e3ee:	dd00      	ble.n	1e3f2 <__aeabi_dadd+0x34e>
   1e3f0:	e0df      	b.n	1e5b2 <__aeabi_dadd+0x50e>
   1e3f2:	2e1f      	cmp	r6, #31
   1e3f4:	dd00      	ble.n	1e3f8 <__aeabi_dadd+0x354>
   1e3f6:	e143      	b.n	1e680 <__aeabi_dadd+0x5dc>
   1e3f8:	2720      	movs	r7, #32
   1e3fa:	1bbc      	subs	r4, r7, r6
   1e3fc:	46a1      	mov	r9, r4
   1e3fe:	000c      	movs	r4, r1
   1e400:	464f      	mov	r7, r9
   1e402:	40bc      	lsls	r4, r7
   1e404:	46a0      	mov	r8, r4
   1e406:	002c      	movs	r4, r5
   1e408:	4647      	mov	r7, r8
   1e40a:	40f4      	lsrs	r4, r6
   1e40c:	433c      	orrs	r4, r7
   1e40e:	464f      	mov	r7, r9
   1e410:	40bd      	lsls	r5, r7
   1e412:	1e6f      	subs	r7, r5, #1
   1e414:	41bd      	sbcs	r5, r7
   1e416:	40f1      	lsrs	r1, r6
   1e418:	432c      	orrs	r4, r5
   1e41a:	1b15      	subs	r5, r2, r4
   1e41c:	42aa      	cmp	r2, r5
   1e41e:	4192      	sbcs	r2, r2
   1e420:	1a41      	subs	r1, r0, r1
   1e422:	4252      	negs	r2, r2
   1e424:	1a89      	subs	r1, r1, r2
   1e426:	4664      	mov	r4, ip
   1e428:	469a      	mov	sl, r3
   1e42a:	e6bf      	b.n	1e1ac <__aeabi_dadd+0x108>
   1e42c:	4641      	mov	r1, r8
   1e42e:	4645      	mov	r5, r8
   1e430:	4331      	orrs	r1, r6
   1e432:	d000      	beq.n	1e436 <__aeabi_dadd+0x392>
   1e434:	e6be      	b.n	1e1b4 <__aeabi_dadd+0x110>
   1e436:	2600      	movs	r6, #0
   1e438:	2400      	movs	r4, #0
   1e43a:	2500      	movs	r5, #0
   1e43c:	e6f2      	b.n	1e224 <__aeabi_dadd+0x180>
   1e43e:	46c0      	nop			; (mov r8, r8)
   1e440:	000007ff 	.word	0x000007ff
   1e444:	ff7fffff 	.word	0xff7fffff
   1e448:	800fffff 	.word	0x800fffff
   1e44c:	2b1f      	cmp	r3, #31
   1e44e:	dc59      	bgt.n	1e504 <__aeabi_dadd+0x460>
   1e450:	2720      	movs	r7, #32
   1e452:	1aff      	subs	r7, r7, r3
   1e454:	46bc      	mov	ip, r7
   1e456:	0007      	movs	r7, r0
   1e458:	4663      	mov	r3, ip
   1e45a:	409f      	lsls	r7, r3
   1e45c:	465b      	mov	r3, fp
   1e45e:	46b9      	mov	r9, r7
   1e460:	0017      	movs	r7, r2
   1e462:	40df      	lsrs	r7, r3
   1e464:	46b8      	mov	r8, r7
   1e466:	464f      	mov	r7, r9
   1e468:	4643      	mov	r3, r8
   1e46a:	431f      	orrs	r7, r3
   1e46c:	4663      	mov	r3, ip
   1e46e:	409a      	lsls	r2, r3
   1e470:	1e53      	subs	r3, r2, #1
   1e472:	419a      	sbcs	r2, r3
   1e474:	465b      	mov	r3, fp
   1e476:	433a      	orrs	r2, r7
   1e478:	40d8      	lsrs	r0, r3
   1e47a:	e6f4      	b.n	1e266 <__aeabi_dadd+0x1c2>
   1e47c:	000c      	movs	r4, r1
   1e47e:	432c      	orrs	r4, r5
   1e480:	d05c      	beq.n	1e53c <__aeabi_dadd+0x498>
   1e482:	43f6      	mvns	r6, r6
   1e484:	2e00      	cmp	r6, #0
   1e486:	d155      	bne.n	1e534 <__aeabi_dadd+0x490>
   1e488:	1b55      	subs	r5, r2, r5
   1e48a:	42aa      	cmp	r2, r5
   1e48c:	41a4      	sbcs	r4, r4
   1e48e:	1a41      	subs	r1, r0, r1
   1e490:	4264      	negs	r4, r4
   1e492:	1b09      	subs	r1, r1, r4
   1e494:	469a      	mov	sl, r3
   1e496:	4664      	mov	r4, ip
   1e498:	e688      	b.n	1e1ac <__aeabi_dadd+0x108>
   1e49a:	4f96      	ldr	r7, [pc, #600]	; (1e6f4 <__aeabi_dadd+0x650>)
   1e49c:	42bc      	cmp	r4, r7
   1e49e:	d000      	beq.n	1e4a2 <__aeabi_dadd+0x3fe>
   1e4a0:	e6d8      	b.n	1e254 <__aeabi_dadd+0x1b0>
   1e4a2:	e628      	b.n	1e0f6 <__aeabi_dadd+0x52>
   1e4a4:	2200      	movs	r2, #0
   1e4a6:	e780      	b.n	1e3aa <__aeabi_dadd+0x306>
   1e4a8:	2000      	movs	r0, #0
   1e4aa:	e78f      	b.n	1e3cc <__aeabi_dadd+0x328>
   1e4ac:	000b      	movs	r3, r1
   1e4ae:	432b      	orrs	r3, r5
   1e4b0:	2c00      	cmp	r4, #0
   1e4b2:	d000      	beq.n	1e4b6 <__aeabi_dadd+0x412>
   1e4b4:	e0c2      	b.n	1e63c <__aeabi_dadd+0x598>
   1e4b6:	2b00      	cmp	r3, #0
   1e4b8:	d100      	bne.n	1e4bc <__aeabi_dadd+0x418>
   1e4ba:	e101      	b.n	1e6c0 <__aeabi_dadd+0x61c>
   1e4bc:	0003      	movs	r3, r0
   1e4be:	4313      	orrs	r3, r2
   1e4c0:	d100      	bne.n	1e4c4 <__aeabi_dadd+0x420>
   1e4c2:	e618      	b.n	1e0f6 <__aeabi_dadd+0x52>
   1e4c4:	18ab      	adds	r3, r5, r2
   1e4c6:	42ab      	cmp	r3, r5
   1e4c8:	41b6      	sbcs	r6, r6
   1e4ca:	1809      	adds	r1, r1, r0
   1e4cc:	4276      	negs	r6, r6
   1e4ce:	1871      	adds	r1, r6, r1
   1e4d0:	020a      	lsls	r2, r1, #8
   1e4d2:	d400      	bmi.n	1e4d6 <__aeabi_dadd+0x432>
   1e4d4:	e109      	b.n	1e6ea <__aeabi_dadd+0x646>
   1e4d6:	4a88      	ldr	r2, [pc, #544]	; (1e6f8 <__aeabi_dadd+0x654>)
   1e4d8:	001d      	movs	r5, r3
   1e4da:	4011      	ands	r1, r2
   1e4dc:	4664      	mov	r4, ip
   1e4de:	e60a      	b.n	1e0f6 <__aeabi_dadd+0x52>
   1e4e0:	2c00      	cmp	r4, #0
   1e4e2:	d15b      	bne.n	1e59c <__aeabi_dadd+0x4f8>
   1e4e4:	000e      	movs	r6, r1
   1e4e6:	432e      	orrs	r6, r5
   1e4e8:	d000      	beq.n	1e4ec <__aeabi_dadd+0x448>
   1e4ea:	e08a      	b.n	1e602 <__aeabi_dadd+0x55e>
   1e4ec:	0001      	movs	r1, r0
   1e4ee:	4311      	orrs	r1, r2
   1e4f0:	d100      	bne.n	1e4f4 <__aeabi_dadd+0x450>
   1e4f2:	e0c2      	b.n	1e67a <__aeabi_dadd+0x5d6>
   1e4f4:	0001      	movs	r1, r0
   1e4f6:	0015      	movs	r5, r2
   1e4f8:	469a      	mov	sl, r3
   1e4fa:	e5fc      	b.n	1e0f6 <__aeabi_dadd+0x52>
   1e4fc:	4664      	mov	r4, ip
   1e4fe:	2100      	movs	r1, #0
   1e500:	2500      	movs	r5, #0
   1e502:	e68f      	b.n	1e224 <__aeabi_dadd+0x180>
   1e504:	2320      	movs	r3, #32
   1e506:	425b      	negs	r3, r3
   1e508:	469c      	mov	ip, r3
   1e50a:	44dc      	add	ip, fp
   1e50c:	4663      	mov	r3, ip
   1e50e:	0007      	movs	r7, r0
   1e510:	40df      	lsrs	r7, r3
   1e512:	465b      	mov	r3, fp
   1e514:	46bc      	mov	ip, r7
   1e516:	2b20      	cmp	r3, #32
   1e518:	d100      	bne.n	1e51c <__aeabi_dadd+0x478>
   1e51a:	e0ac      	b.n	1e676 <__aeabi_dadd+0x5d2>
   1e51c:	2340      	movs	r3, #64	; 0x40
   1e51e:	465f      	mov	r7, fp
   1e520:	1bdb      	subs	r3, r3, r7
   1e522:	4098      	lsls	r0, r3
   1e524:	4302      	orrs	r2, r0
   1e526:	1e50      	subs	r0, r2, #1
   1e528:	4182      	sbcs	r2, r0
   1e52a:	4663      	mov	r3, ip
   1e52c:	4313      	orrs	r3, r2
   1e52e:	001a      	movs	r2, r3
   1e530:	2000      	movs	r0, #0
   1e532:	e698      	b.n	1e266 <__aeabi_dadd+0x1c2>
   1e534:	4c6f      	ldr	r4, [pc, #444]	; (1e6f4 <__aeabi_dadd+0x650>)
   1e536:	45a4      	cmp	ip, r4
   1e538:	d000      	beq.n	1e53c <__aeabi_dadd+0x498>
   1e53a:	e757      	b.n	1e3ec <__aeabi_dadd+0x348>
   1e53c:	0001      	movs	r1, r0
   1e53e:	0015      	movs	r5, r2
   1e540:	4664      	mov	r4, ip
   1e542:	469a      	mov	sl, r3
   1e544:	e5d7      	b.n	1e0f6 <__aeabi_dadd+0x52>
   1e546:	2c00      	cmp	r4, #0
   1e548:	d139      	bne.n	1e5be <__aeabi_dadd+0x51a>
   1e54a:	000c      	movs	r4, r1
   1e54c:	432c      	orrs	r4, r5
   1e54e:	d06e      	beq.n	1e62e <__aeabi_dadd+0x58a>
   1e550:	43db      	mvns	r3, r3
   1e552:	2b00      	cmp	r3, #0
   1e554:	d01a      	beq.n	1e58c <__aeabi_dadd+0x4e8>
   1e556:	4c67      	ldr	r4, [pc, #412]	; (1e6f4 <__aeabi_dadd+0x650>)
   1e558:	45a4      	cmp	ip, r4
   1e55a:	d068      	beq.n	1e62e <__aeabi_dadd+0x58a>
   1e55c:	2b38      	cmp	r3, #56	; 0x38
   1e55e:	dd00      	ble.n	1e562 <__aeabi_dadd+0x4be>
   1e560:	e0a4      	b.n	1e6ac <__aeabi_dadd+0x608>
   1e562:	2b1f      	cmp	r3, #31
   1e564:	dd00      	ble.n	1e568 <__aeabi_dadd+0x4c4>
   1e566:	e0ae      	b.n	1e6c6 <__aeabi_dadd+0x622>
   1e568:	2420      	movs	r4, #32
   1e56a:	000f      	movs	r7, r1
   1e56c:	1ae4      	subs	r4, r4, r3
   1e56e:	40a7      	lsls	r7, r4
   1e570:	46b9      	mov	r9, r7
   1e572:	002f      	movs	r7, r5
   1e574:	40df      	lsrs	r7, r3
   1e576:	46b8      	mov	r8, r7
   1e578:	46a3      	mov	fp, r4
   1e57a:	464f      	mov	r7, r9
   1e57c:	4644      	mov	r4, r8
   1e57e:	4327      	orrs	r7, r4
   1e580:	465c      	mov	r4, fp
   1e582:	40a5      	lsls	r5, r4
   1e584:	1e6c      	subs	r4, r5, #1
   1e586:	41a5      	sbcs	r5, r4
   1e588:	40d9      	lsrs	r1, r3
   1e58a:	433d      	orrs	r5, r7
   1e58c:	18ad      	adds	r5, r5, r2
   1e58e:	4295      	cmp	r5, r2
   1e590:	419b      	sbcs	r3, r3
   1e592:	1809      	adds	r1, r1, r0
   1e594:	425b      	negs	r3, r3
   1e596:	1859      	adds	r1, r3, r1
   1e598:	4664      	mov	r4, ip
   1e59a:	e66b      	b.n	1e274 <__aeabi_dadd+0x1d0>
   1e59c:	000c      	movs	r4, r1
   1e59e:	432c      	orrs	r4, r5
   1e5a0:	d115      	bne.n	1e5ce <__aeabi_dadd+0x52a>
   1e5a2:	0001      	movs	r1, r0
   1e5a4:	4311      	orrs	r1, r2
   1e5a6:	d07b      	beq.n	1e6a0 <__aeabi_dadd+0x5fc>
   1e5a8:	0001      	movs	r1, r0
   1e5aa:	0015      	movs	r5, r2
   1e5ac:	469a      	mov	sl, r3
   1e5ae:	4c51      	ldr	r4, [pc, #324]	; (1e6f4 <__aeabi_dadd+0x650>)
   1e5b0:	e5a1      	b.n	1e0f6 <__aeabi_dadd+0x52>
   1e5b2:	430d      	orrs	r5, r1
   1e5b4:	1e69      	subs	r1, r5, #1
   1e5b6:	418d      	sbcs	r5, r1
   1e5b8:	2100      	movs	r1, #0
   1e5ba:	b2ec      	uxtb	r4, r5
   1e5bc:	e72d      	b.n	1e41a <__aeabi_dadd+0x376>
   1e5be:	4c4d      	ldr	r4, [pc, #308]	; (1e6f4 <__aeabi_dadd+0x650>)
   1e5c0:	45a4      	cmp	ip, r4
   1e5c2:	d034      	beq.n	1e62e <__aeabi_dadd+0x58a>
   1e5c4:	2480      	movs	r4, #128	; 0x80
   1e5c6:	0424      	lsls	r4, r4, #16
   1e5c8:	425b      	negs	r3, r3
   1e5ca:	4321      	orrs	r1, r4
   1e5cc:	e7c6      	b.n	1e55c <__aeabi_dadd+0x4b8>
   1e5ce:	0004      	movs	r4, r0
   1e5d0:	4314      	orrs	r4, r2
   1e5d2:	d04e      	beq.n	1e672 <__aeabi_dadd+0x5ce>
   1e5d4:	08ed      	lsrs	r5, r5, #3
   1e5d6:	074c      	lsls	r4, r1, #29
   1e5d8:	432c      	orrs	r4, r5
   1e5da:	2580      	movs	r5, #128	; 0x80
   1e5dc:	08c9      	lsrs	r1, r1, #3
   1e5de:	032d      	lsls	r5, r5, #12
   1e5e0:	4229      	tst	r1, r5
   1e5e2:	d008      	beq.n	1e5f6 <__aeabi_dadd+0x552>
   1e5e4:	08c6      	lsrs	r6, r0, #3
   1e5e6:	422e      	tst	r6, r5
   1e5e8:	d105      	bne.n	1e5f6 <__aeabi_dadd+0x552>
   1e5ea:	08d2      	lsrs	r2, r2, #3
   1e5ec:	0741      	lsls	r1, r0, #29
   1e5ee:	4311      	orrs	r1, r2
   1e5f0:	000c      	movs	r4, r1
   1e5f2:	469a      	mov	sl, r3
   1e5f4:	0031      	movs	r1, r6
   1e5f6:	0f62      	lsrs	r2, r4, #29
   1e5f8:	00c9      	lsls	r1, r1, #3
   1e5fa:	00e5      	lsls	r5, r4, #3
   1e5fc:	4311      	orrs	r1, r2
   1e5fe:	4c3d      	ldr	r4, [pc, #244]	; (1e6f4 <__aeabi_dadd+0x650>)
   1e600:	e579      	b.n	1e0f6 <__aeabi_dadd+0x52>
   1e602:	0006      	movs	r6, r0
   1e604:	4316      	orrs	r6, r2
   1e606:	d100      	bne.n	1e60a <__aeabi_dadd+0x566>
   1e608:	e575      	b.n	1e0f6 <__aeabi_dadd+0x52>
   1e60a:	1aae      	subs	r6, r5, r2
   1e60c:	46b0      	mov	r8, r6
   1e60e:	4545      	cmp	r5, r8
   1e610:	41bf      	sbcs	r7, r7
   1e612:	1a0e      	subs	r6, r1, r0
   1e614:	427f      	negs	r7, r7
   1e616:	1bf6      	subs	r6, r6, r7
   1e618:	0237      	lsls	r7, r6, #8
   1e61a:	d400      	bmi.n	1e61e <__aeabi_dadd+0x57a>
   1e61c:	e5f4      	b.n	1e208 <__aeabi_dadd+0x164>
   1e61e:	1b55      	subs	r5, r2, r5
   1e620:	42aa      	cmp	r2, r5
   1e622:	41b6      	sbcs	r6, r6
   1e624:	1a41      	subs	r1, r0, r1
   1e626:	4276      	negs	r6, r6
   1e628:	1b89      	subs	r1, r1, r6
   1e62a:	469a      	mov	sl, r3
   1e62c:	e563      	b.n	1e0f6 <__aeabi_dadd+0x52>
   1e62e:	0001      	movs	r1, r0
   1e630:	0015      	movs	r5, r2
   1e632:	4664      	mov	r4, ip
   1e634:	e55f      	b.n	1e0f6 <__aeabi_dadd+0x52>
   1e636:	2200      	movs	r2, #0
   1e638:	2500      	movs	r5, #0
   1e63a:	e57b      	b.n	1e134 <__aeabi_dadd+0x90>
   1e63c:	2b00      	cmp	r3, #0
   1e63e:	d03b      	beq.n	1e6b8 <__aeabi_dadd+0x614>
   1e640:	0003      	movs	r3, r0
   1e642:	4313      	orrs	r3, r2
   1e644:	d015      	beq.n	1e672 <__aeabi_dadd+0x5ce>
   1e646:	08ed      	lsrs	r5, r5, #3
   1e648:	074b      	lsls	r3, r1, #29
   1e64a:	432b      	orrs	r3, r5
   1e64c:	2580      	movs	r5, #128	; 0x80
   1e64e:	08c9      	lsrs	r1, r1, #3
   1e650:	032d      	lsls	r5, r5, #12
   1e652:	4229      	tst	r1, r5
   1e654:	d007      	beq.n	1e666 <__aeabi_dadd+0x5c2>
   1e656:	08c4      	lsrs	r4, r0, #3
   1e658:	422c      	tst	r4, r5
   1e65a:	d104      	bne.n	1e666 <__aeabi_dadd+0x5c2>
   1e65c:	0741      	lsls	r1, r0, #29
   1e65e:	000b      	movs	r3, r1
   1e660:	0021      	movs	r1, r4
   1e662:	08d2      	lsrs	r2, r2, #3
   1e664:	4313      	orrs	r3, r2
   1e666:	00c9      	lsls	r1, r1, #3
   1e668:	0f5a      	lsrs	r2, r3, #29
   1e66a:	4311      	orrs	r1, r2
   1e66c:	00dd      	lsls	r5, r3, #3
   1e66e:	4c21      	ldr	r4, [pc, #132]	; (1e6f4 <__aeabi_dadd+0x650>)
   1e670:	e541      	b.n	1e0f6 <__aeabi_dadd+0x52>
   1e672:	4c20      	ldr	r4, [pc, #128]	; (1e6f4 <__aeabi_dadd+0x650>)
   1e674:	e53f      	b.n	1e0f6 <__aeabi_dadd+0x52>
   1e676:	2000      	movs	r0, #0
   1e678:	e754      	b.n	1e524 <__aeabi_dadd+0x480>
   1e67a:	2600      	movs	r6, #0
   1e67c:	2500      	movs	r5, #0
   1e67e:	e5d1      	b.n	1e224 <__aeabi_dadd+0x180>
   1e680:	0034      	movs	r4, r6
   1e682:	000f      	movs	r7, r1
   1e684:	3c20      	subs	r4, #32
   1e686:	40e7      	lsrs	r7, r4
   1e688:	003c      	movs	r4, r7
   1e68a:	2e20      	cmp	r6, #32
   1e68c:	d02b      	beq.n	1e6e6 <__aeabi_dadd+0x642>
   1e68e:	2740      	movs	r7, #64	; 0x40
   1e690:	1bbe      	subs	r6, r7, r6
   1e692:	40b1      	lsls	r1, r6
   1e694:	430d      	orrs	r5, r1
   1e696:	1e69      	subs	r1, r5, #1
   1e698:	418d      	sbcs	r5, r1
   1e69a:	2100      	movs	r1, #0
   1e69c:	432c      	orrs	r4, r5
   1e69e:	e6bc      	b.n	1e41a <__aeabi_dadd+0x376>
   1e6a0:	2180      	movs	r1, #128	; 0x80
   1e6a2:	2600      	movs	r6, #0
   1e6a4:	0309      	lsls	r1, r1, #12
   1e6a6:	4c13      	ldr	r4, [pc, #76]	; (1e6f4 <__aeabi_dadd+0x650>)
   1e6a8:	2500      	movs	r5, #0
   1e6aa:	e5bb      	b.n	1e224 <__aeabi_dadd+0x180>
   1e6ac:	430d      	orrs	r5, r1
   1e6ae:	1e69      	subs	r1, r5, #1
   1e6b0:	418d      	sbcs	r5, r1
   1e6b2:	2100      	movs	r1, #0
   1e6b4:	b2ed      	uxtb	r5, r5
   1e6b6:	e769      	b.n	1e58c <__aeabi_dadd+0x4e8>
   1e6b8:	0001      	movs	r1, r0
   1e6ba:	0015      	movs	r5, r2
   1e6bc:	4c0d      	ldr	r4, [pc, #52]	; (1e6f4 <__aeabi_dadd+0x650>)
   1e6be:	e51a      	b.n	1e0f6 <__aeabi_dadd+0x52>
   1e6c0:	0001      	movs	r1, r0
   1e6c2:	0015      	movs	r5, r2
   1e6c4:	e517      	b.n	1e0f6 <__aeabi_dadd+0x52>
   1e6c6:	001c      	movs	r4, r3
   1e6c8:	000f      	movs	r7, r1
   1e6ca:	3c20      	subs	r4, #32
   1e6cc:	40e7      	lsrs	r7, r4
   1e6ce:	003c      	movs	r4, r7
   1e6d0:	2b20      	cmp	r3, #32
   1e6d2:	d00c      	beq.n	1e6ee <__aeabi_dadd+0x64a>
   1e6d4:	2740      	movs	r7, #64	; 0x40
   1e6d6:	1afb      	subs	r3, r7, r3
   1e6d8:	4099      	lsls	r1, r3
   1e6da:	430d      	orrs	r5, r1
   1e6dc:	1e69      	subs	r1, r5, #1
   1e6de:	418d      	sbcs	r5, r1
   1e6e0:	2100      	movs	r1, #0
   1e6e2:	4325      	orrs	r5, r4
   1e6e4:	e752      	b.n	1e58c <__aeabi_dadd+0x4e8>
   1e6e6:	2100      	movs	r1, #0
   1e6e8:	e7d4      	b.n	1e694 <__aeabi_dadd+0x5f0>
   1e6ea:	001d      	movs	r5, r3
   1e6ec:	e592      	b.n	1e214 <__aeabi_dadd+0x170>
   1e6ee:	2100      	movs	r1, #0
   1e6f0:	e7f3      	b.n	1e6da <__aeabi_dadd+0x636>
   1e6f2:	46c0      	nop			; (mov r8, r8)
   1e6f4:	000007ff 	.word	0x000007ff
   1e6f8:	ff7fffff 	.word	0xff7fffff

0001e6fc <__aeabi_ddiv>:
   1e6fc:	b5f0      	push	{r4, r5, r6, r7, lr}
   1e6fe:	4656      	mov	r6, sl
   1e700:	464d      	mov	r5, r9
   1e702:	4644      	mov	r4, r8
   1e704:	465f      	mov	r7, fp
   1e706:	b4f0      	push	{r4, r5, r6, r7}
   1e708:	001d      	movs	r5, r3
   1e70a:	030e      	lsls	r6, r1, #12
   1e70c:	004c      	lsls	r4, r1, #1
   1e70e:	0fcb      	lsrs	r3, r1, #31
   1e710:	b087      	sub	sp, #28
   1e712:	0007      	movs	r7, r0
   1e714:	4692      	mov	sl, r2
   1e716:	4681      	mov	r9, r0
   1e718:	0b36      	lsrs	r6, r6, #12
   1e71a:	0d64      	lsrs	r4, r4, #21
   1e71c:	4698      	mov	r8, r3
   1e71e:	d06a      	beq.n	1e7f6 <__aeabi_ddiv+0xfa>
   1e720:	4b6d      	ldr	r3, [pc, #436]	; (1e8d8 <__aeabi_ddiv+0x1dc>)
   1e722:	429c      	cmp	r4, r3
   1e724:	d035      	beq.n	1e792 <__aeabi_ddiv+0x96>
   1e726:	2280      	movs	r2, #128	; 0x80
   1e728:	0f43      	lsrs	r3, r0, #29
   1e72a:	0412      	lsls	r2, r2, #16
   1e72c:	4313      	orrs	r3, r2
   1e72e:	00f6      	lsls	r6, r6, #3
   1e730:	431e      	orrs	r6, r3
   1e732:	00c3      	lsls	r3, r0, #3
   1e734:	4699      	mov	r9, r3
   1e736:	4b69      	ldr	r3, [pc, #420]	; (1e8dc <__aeabi_ddiv+0x1e0>)
   1e738:	2700      	movs	r7, #0
   1e73a:	469c      	mov	ip, r3
   1e73c:	2300      	movs	r3, #0
   1e73e:	4464      	add	r4, ip
   1e740:	9302      	str	r3, [sp, #8]
   1e742:	032b      	lsls	r3, r5, #12
   1e744:	0068      	lsls	r0, r5, #1
   1e746:	0b1b      	lsrs	r3, r3, #12
   1e748:	0fed      	lsrs	r5, r5, #31
   1e74a:	4651      	mov	r1, sl
   1e74c:	469b      	mov	fp, r3
   1e74e:	0d40      	lsrs	r0, r0, #21
   1e750:	9500      	str	r5, [sp, #0]
   1e752:	d100      	bne.n	1e756 <__aeabi_ddiv+0x5a>
   1e754:	e078      	b.n	1e848 <__aeabi_ddiv+0x14c>
   1e756:	4b60      	ldr	r3, [pc, #384]	; (1e8d8 <__aeabi_ddiv+0x1dc>)
   1e758:	4298      	cmp	r0, r3
   1e75a:	d06c      	beq.n	1e836 <__aeabi_ddiv+0x13a>
   1e75c:	465b      	mov	r3, fp
   1e75e:	00da      	lsls	r2, r3, #3
   1e760:	0f4b      	lsrs	r3, r1, #29
   1e762:	2180      	movs	r1, #128	; 0x80
   1e764:	0409      	lsls	r1, r1, #16
   1e766:	430b      	orrs	r3, r1
   1e768:	4313      	orrs	r3, r2
   1e76a:	469b      	mov	fp, r3
   1e76c:	4653      	mov	r3, sl
   1e76e:	00d9      	lsls	r1, r3, #3
   1e770:	4b5a      	ldr	r3, [pc, #360]	; (1e8dc <__aeabi_ddiv+0x1e0>)
   1e772:	469c      	mov	ip, r3
   1e774:	2300      	movs	r3, #0
   1e776:	4460      	add	r0, ip
   1e778:	4642      	mov	r2, r8
   1e77a:	1a20      	subs	r0, r4, r0
   1e77c:	406a      	eors	r2, r5
   1e77e:	4692      	mov	sl, r2
   1e780:	9001      	str	r0, [sp, #4]
   1e782:	431f      	orrs	r7, r3
   1e784:	2f0f      	cmp	r7, #15
   1e786:	d900      	bls.n	1e78a <__aeabi_ddiv+0x8e>
   1e788:	e0b0      	b.n	1e8ec <__aeabi_ddiv+0x1f0>
   1e78a:	4855      	ldr	r0, [pc, #340]	; (1e8e0 <__aeabi_ddiv+0x1e4>)
   1e78c:	00bf      	lsls	r7, r7, #2
   1e78e:	59c0      	ldr	r0, [r0, r7]
   1e790:	4687      	mov	pc, r0
   1e792:	4337      	orrs	r7, r6
   1e794:	d000      	beq.n	1e798 <__aeabi_ddiv+0x9c>
   1e796:	e088      	b.n	1e8aa <__aeabi_ddiv+0x1ae>
   1e798:	2300      	movs	r3, #0
   1e79a:	4699      	mov	r9, r3
   1e79c:	3302      	adds	r3, #2
   1e79e:	2708      	movs	r7, #8
   1e7a0:	2600      	movs	r6, #0
   1e7a2:	9302      	str	r3, [sp, #8]
   1e7a4:	e7cd      	b.n	1e742 <__aeabi_ddiv+0x46>
   1e7a6:	4643      	mov	r3, r8
   1e7a8:	46b3      	mov	fp, r6
   1e7aa:	4649      	mov	r1, r9
   1e7ac:	9300      	str	r3, [sp, #0]
   1e7ae:	9b02      	ldr	r3, [sp, #8]
   1e7b0:	9a00      	ldr	r2, [sp, #0]
   1e7b2:	4692      	mov	sl, r2
   1e7b4:	2b02      	cmp	r3, #2
   1e7b6:	d000      	beq.n	1e7ba <__aeabi_ddiv+0xbe>
   1e7b8:	e1bf      	b.n	1eb3a <__aeabi_ddiv+0x43e>
   1e7ba:	2100      	movs	r1, #0
   1e7bc:	4653      	mov	r3, sl
   1e7be:	2201      	movs	r2, #1
   1e7c0:	2600      	movs	r6, #0
   1e7c2:	4689      	mov	r9, r1
   1e7c4:	401a      	ands	r2, r3
   1e7c6:	4b44      	ldr	r3, [pc, #272]	; (1e8d8 <__aeabi_ddiv+0x1dc>)
   1e7c8:	2100      	movs	r1, #0
   1e7ca:	0336      	lsls	r6, r6, #12
   1e7cc:	0d0c      	lsrs	r4, r1, #20
   1e7ce:	0524      	lsls	r4, r4, #20
   1e7d0:	0b36      	lsrs	r6, r6, #12
   1e7d2:	4326      	orrs	r6, r4
   1e7d4:	4c43      	ldr	r4, [pc, #268]	; (1e8e4 <__aeabi_ddiv+0x1e8>)
   1e7d6:	051b      	lsls	r3, r3, #20
   1e7d8:	4026      	ands	r6, r4
   1e7da:	431e      	orrs	r6, r3
   1e7dc:	0076      	lsls	r6, r6, #1
   1e7de:	07d2      	lsls	r2, r2, #31
   1e7e0:	0876      	lsrs	r6, r6, #1
   1e7e2:	4316      	orrs	r6, r2
   1e7e4:	4648      	mov	r0, r9
   1e7e6:	0031      	movs	r1, r6
   1e7e8:	b007      	add	sp, #28
   1e7ea:	bc3c      	pop	{r2, r3, r4, r5}
   1e7ec:	4690      	mov	r8, r2
   1e7ee:	4699      	mov	r9, r3
   1e7f0:	46a2      	mov	sl, r4
   1e7f2:	46ab      	mov	fp, r5
   1e7f4:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1e7f6:	0033      	movs	r3, r6
   1e7f8:	4303      	orrs	r3, r0
   1e7fa:	d04f      	beq.n	1e89c <__aeabi_ddiv+0x1a0>
   1e7fc:	2e00      	cmp	r6, #0
   1e7fe:	d100      	bne.n	1e802 <__aeabi_ddiv+0x106>
   1e800:	e1bc      	b.n	1eb7c <__aeabi_ddiv+0x480>
   1e802:	0030      	movs	r0, r6
   1e804:	f7ff fb04 	bl	1de10 <__clzsi2>
   1e808:	0003      	movs	r3, r0
   1e80a:	3b0b      	subs	r3, #11
   1e80c:	2b1c      	cmp	r3, #28
   1e80e:	dd00      	ble.n	1e812 <__aeabi_ddiv+0x116>
   1e810:	e1ad      	b.n	1eb6e <__aeabi_ddiv+0x472>
   1e812:	221d      	movs	r2, #29
   1e814:	0001      	movs	r1, r0
   1e816:	1ad3      	subs	r3, r2, r3
   1e818:	3908      	subs	r1, #8
   1e81a:	003a      	movs	r2, r7
   1e81c:	408f      	lsls	r7, r1
   1e81e:	408e      	lsls	r6, r1
   1e820:	40da      	lsrs	r2, r3
   1e822:	46b9      	mov	r9, r7
   1e824:	4316      	orrs	r6, r2
   1e826:	4b30      	ldr	r3, [pc, #192]	; (1e8e8 <__aeabi_ddiv+0x1ec>)
   1e828:	2700      	movs	r7, #0
   1e82a:	469c      	mov	ip, r3
   1e82c:	2300      	movs	r3, #0
   1e82e:	4460      	add	r0, ip
   1e830:	4244      	negs	r4, r0
   1e832:	9302      	str	r3, [sp, #8]
   1e834:	e785      	b.n	1e742 <__aeabi_ddiv+0x46>
   1e836:	4653      	mov	r3, sl
   1e838:	465a      	mov	r2, fp
   1e83a:	4313      	orrs	r3, r2
   1e83c:	d12c      	bne.n	1e898 <__aeabi_ddiv+0x19c>
   1e83e:	2300      	movs	r3, #0
   1e840:	2100      	movs	r1, #0
   1e842:	469b      	mov	fp, r3
   1e844:	3302      	adds	r3, #2
   1e846:	e797      	b.n	1e778 <__aeabi_ddiv+0x7c>
   1e848:	430b      	orrs	r3, r1
   1e84a:	d020      	beq.n	1e88e <__aeabi_ddiv+0x192>
   1e84c:	465b      	mov	r3, fp
   1e84e:	2b00      	cmp	r3, #0
   1e850:	d100      	bne.n	1e854 <__aeabi_ddiv+0x158>
   1e852:	e19e      	b.n	1eb92 <__aeabi_ddiv+0x496>
   1e854:	4658      	mov	r0, fp
   1e856:	f7ff fadb 	bl	1de10 <__clzsi2>
   1e85a:	0003      	movs	r3, r0
   1e85c:	3b0b      	subs	r3, #11
   1e85e:	2b1c      	cmp	r3, #28
   1e860:	dd00      	ble.n	1e864 <__aeabi_ddiv+0x168>
   1e862:	e18f      	b.n	1eb84 <__aeabi_ddiv+0x488>
   1e864:	0002      	movs	r2, r0
   1e866:	4659      	mov	r1, fp
   1e868:	3a08      	subs	r2, #8
   1e86a:	4091      	lsls	r1, r2
   1e86c:	468b      	mov	fp, r1
   1e86e:	211d      	movs	r1, #29
   1e870:	1acb      	subs	r3, r1, r3
   1e872:	4651      	mov	r1, sl
   1e874:	40d9      	lsrs	r1, r3
   1e876:	000b      	movs	r3, r1
   1e878:	4659      	mov	r1, fp
   1e87a:	430b      	orrs	r3, r1
   1e87c:	4651      	mov	r1, sl
   1e87e:	469b      	mov	fp, r3
   1e880:	4091      	lsls	r1, r2
   1e882:	4b19      	ldr	r3, [pc, #100]	; (1e8e8 <__aeabi_ddiv+0x1ec>)
   1e884:	469c      	mov	ip, r3
   1e886:	4460      	add	r0, ip
   1e888:	4240      	negs	r0, r0
   1e88a:	2300      	movs	r3, #0
   1e88c:	e774      	b.n	1e778 <__aeabi_ddiv+0x7c>
   1e88e:	2300      	movs	r3, #0
   1e890:	2100      	movs	r1, #0
   1e892:	469b      	mov	fp, r3
   1e894:	3301      	adds	r3, #1
   1e896:	e76f      	b.n	1e778 <__aeabi_ddiv+0x7c>
   1e898:	2303      	movs	r3, #3
   1e89a:	e76d      	b.n	1e778 <__aeabi_ddiv+0x7c>
   1e89c:	2300      	movs	r3, #0
   1e89e:	4699      	mov	r9, r3
   1e8a0:	3301      	adds	r3, #1
   1e8a2:	2704      	movs	r7, #4
   1e8a4:	2600      	movs	r6, #0
   1e8a6:	9302      	str	r3, [sp, #8]
   1e8a8:	e74b      	b.n	1e742 <__aeabi_ddiv+0x46>
   1e8aa:	2303      	movs	r3, #3
   1e8ac:	270c      	movs	r7, #12
   1e8ae:	9302      	str	r3, [sp, #8]
   1e8b0:	e747      	b.n	1e742 <__aeabi_ddiv+0x46>
   1e8b2:	2201      	movs	r2, #1
   1e8b4:	1ad5      	subs	r5, r2, r3
   1e8b6:	2d38      	cmp	r5, #56	; 0x38
   1e8b8:	dc00      	bgt.n	1e8bc <__aeabi_ddiv+0x1c0>
   1e8ba:	e1b0      	b.n	1ec1e <__aeabi_ddiv+0x522>
   1e8bc:	4653      	mov	r3, sl
   1e8be:	401a      	ands	r2, r3
   1e8c0:	2100      	movs	r1, #0
   1e8c2:	2300      	movs	r3, #0
   1e8c4:	2600      	movs	r6, #0
   1e8c6:	4689      	mov	r9, r1
   1e8c8:	e77e      	b.n	1e7c8 <__aeabi_ddiv+0xcc>
   1e8ca:	2300      	movs	r3, #0
   1e8cc:	2680      	movs	r6, #128	; 0x80
   1e8ce:	4699      	mov	r9, r3
   1e8d0:	2200      	movs	r2, #0
   1e8d2:	0336      	lsls	r6, r6, #12
   1e8d4:	4b00      	ldr	r3, [pc, #0]	; (1e8d8 <__aeabi_ddiv+0x1dc>)
   1e8d6:	e777      	b.n	1e7c8 <__aeabi_ddiv+0xcc>
   1e8d8:	000007ff 	.word	0x000007ff
   1e8dc:	fffffc01 	.word	0xfffffc01
   1e8e0:	00023468 	.word	0x00023468
   1e8e4:	800fffff 	.word	0x800fffff
   1e8e8:	000003f3 	.word	0x000003f3
   1e8ec:	455e      	cmp	r6, fp
   1e8ee:	d900      	bls.n	1e8f2 <__aeabi_ddiv+0x1f6>
   1e8f0:	e172      	b.n	1ebd8 <__aeabi_ddiv+0x4dc>
   1e8f2:	d100      	bne.n	1e8f6 <__aeabi_ddiv+0x1fa>
   1e8f4:	e16d      	b.n	1ebd2 <__aeabi_ddiv+0x4d6>
   1e8f6:	9b01      	ldr	r3, [sp, #4]
   1e8f8:	464d      	mov	r5, r9
   1e8fa:	3b01      	subs	r3, #1
   1e8fc:	9301      	str	r3, [sp, #4]
   1e8fe:	2300      	movs	r3, #0
   1e900:	0034      	movs	r4, r6
   1e902:	9302      	str	r3, [sp, #8]
   1e904:	465b      	mov	r3, fp
   1e906:	021e      	lsls	r6, r3, #8
   1e908:	0e0b      	lsrs	r3, r1, #24
   1e90a:	431e      	orrs	r6, r3
   1e90c:	020b      	lsls	r3, r1, #8
   1e90e:	9303      	str	r3, [sp, #12]
   1e910:	0c33      	lsrs	r3, r6, #16
   1e912:	4699      	mov	r9, r3
   1e914:	0433      	lsls	r3, r6, #16
   1e916:	0c1b      	lsrs	r3, r3, #16
   1e918:	4649      	mov	r1, r9
   1e91a:	0020      	movs	r0, r4
   1e91c:	9300      	str	r3, [sp, #0]
   1e91e:	f7e5 fce6 	bl	42ee <__aeabi_uidiv>
   1e922:	9b00      	ldr	r3, [sp, #0]
   1e924:	0037      	movs	r7, r6
   1e926:	4343      	muls	r3, r0
   1e928:	0006      	movs	r6, r0
   1e92a:	4649      	mov	r1, r9
   1e92c:	0020      	movs	r0, r4
   1e92e:	4698      	mov	r8, r3
   1e930:	f7e5 fcdd 	bl	42ee <__aeabi_uidiv>
   1e934:	0c2c      	lsrs	r4, r5, #16
   1e936:	0409      	lsls	r1, r1, #16
   1e938:	430c      	orrs	r4, r1
   1e93a:	45a0      	cmp	r8, r4
   1e93c:	d909      	bls.n	1e952 <__aeabi_ddiv+0x256>
   1e93e:	19e4      	adds	r4, r4, r7
   1e940:	1e73      	subs	r3, r6, #1
   1e942:	42a7      	cmp	r7, r4
   1e944:	d900      	bls.n	1e948 <__aeabi_ddiv+0x24c>
   1e946:	e15c      	b.n	1ec02 <__aeabi_ddiv+0x506>
   1e948:	45a0      	cmp	r8, r4
   1e94a:	d800      	bhi.n	1e94e <__aeabi_ddiv+0x252>
   1e94c:	e159      	b.n	1ec02 <__aeabi_ddiv+0x506>
   1e94e:	3e02      	subs	r6, #2
   1e950:	19e4      	adds	r4, r4, r7
   1e952:	4643      	mov	r3, r8
   1e954:	1ae4      	subs	r4, r4, r3
   1e956:	4649      	mov	r1, r9
   1e958:	0020      	movs	r0, r4
   1e95a:	f7e5 fcc8 	bl	42ee <__aeabi_uidiv>
   1e95e:	0003      	movs	r3, r0
   1e960:	9a00      	ldr	r2, [sp, #0]
   1e962:	4680      	mov	r8, r0
   1e964:	4353      	muls	r3, r2
   1e966:	4649      	mov	r1, r9
   1e968:	0020      	movs	r0, r4
   1e96a:	469b      	mov	fp, r3
   1e96c:	f7e5 fcbf 	bl	42ee <__aeabi_uidiv>
   1e970:	042a      	lsls	r2, r5, #16
   1e972:	0409      	lsls	r1, r1, #16
   1e974:	0c12      	lsrs	r2, r2, #16
   1e976:	430a      	orrs	r2, r1
   1e978:	4593      	cmp	fp, r2
   1e97a:	d90d      	bls.n	1e998 <__aeabi_ddiv+0x29c>
   1e97c:	4643      	mov	r3, r8
   1e97e:	19d2      	adds	r2, r2, r7
   1e980:	3b01      	subs	r3, #1
   1e982:	4297      	cmp	r7, r2
   1e984:	d900      	bls.n	1e988 <__aeabi_ddiv+0x28c>
   1e986:	e13a      	b.n	1ebfe <__aeabi_ddiv+0x502>
   1e988:	4593      	cmp	fp, r2
   1e98a:	d800      	bhi.n	1e98e <__aeabi_ddiv+0x292>
   1e98c:	e137      	b.n	1ebfe <__aeabi_ddiv+0x502>
   1e98e:	2302      	movs	r3, #2
   1e990:	425b      	negs	r3, r3
   1e992:	469c      	mov	ip, r3
   1e994:	19d2      	adds	r2, r2, r7
   1e996:	44e0      	add	r8, ip
   1e998:	465b      	mov	r3, fp
   1e99a:	1ad2      	subs	r2, r2, r3
   1e99c:	4643      	mov	r3, r8
   1e99e:	0436      	lsls	r6, r6, #16
   1e9a0:	4333      	orrs	r3, r6
   1e9a2:	469b      	mov	fp, r3
   1e9a4:	9903      	ldr	r1, [sp, #12]
   1e9a6:	0c18      	lsrs	r0, r3, #16
   1e9a8:	0c0b      	lsrs	r3, r1, #16
   1e9aa:	001d      	movs	r5, r3
   1e9ac:	9305      	str	r3, [sp, #20]
   1e9ae:	0409      	lsls	r1, r1, #16
   1e9b0:	465b      	mov	r3, fp
   1e9b2:	0c09      	lsrs	r1, r1, #16
   1e9b4:	000c      	movs	r4, r1
   1e9b6:	041b      	lsls	r3, r3, #16
   1e9b8:	0c1b      	lsrs	r3, r3, #16
   1e9ba:	4344      	muls	r4, r0
   1e9bc:	9104      	str	r1, [sp, #16]
   1e9be:	4359      	muls	r1, r3
   1e9c0:	436b      	muls	r3, r5
   1e9c2:	4368      	muls	r0, r5
   1e9c4:	191b      	adds	r3, r3, r4
   1e9c6:	0c0d      	lsrs	r5, r1, #16
   1e9c8:	18eb      	adds	r3, r5, r3
   1e9ca:	429c      	cmp	r4, r3
   1e9cc:	d903      	bls.n	1e9d6 <__aeabi_ddiv+0x2da>
   1e9ce:	2480      	movs	r4, #128	; 0x80
   1e9d0:	0264      	lsls	r4, r4, #9
   1e9d2:	46a4      	mov	ip, r4
   1e9d4:	4460      	add	r0, ip
   1e9d6:	0c1c      	lsrs	r4, r3, #16
   1e9d8:	0409      	lsls	r1, r1, #16
   1e9da:	041b      	lsls	r3, r3, #16
   1e9dc:	0c09      	lsrs	r1, r1, #16
   1e9de:	1820      	adds	r0, r4, r0
   1e9e0:	185d      	adds	r5, r3, r1
   1e9e2:	4282      	cmp	r2, r0
   1e9e4:	d200      	bcs.n	1e9e8 <__aeabi_ddiv+0x2ec>
   1e9e6:	e0de      	b.n	1eba6 <__aeabi_ddiv+0x4aa>
   1e9e8:	d100      	bne.n	1e9ec <__aeabi_ddiv+0x2f0>
   1e9ea:	e0d7      	b.n	1eb9c <__aeabi_ddiv+0x4a0>
   1e9ec:	1a16      	subs	r6, r2, r0
   1e9ee:	9b02      	ldr	r3, [sp, #8]
   1e9f0:	469c      	mov	ip, r3
   1e9f2:	1b5d      	subs	r5, r3, r5
   1e9f4:	45ac      	cmp	ip, r5
   1e9f6:	419b      	sbcs	r3, r3
   1e9f8:	425b      	negs	r3, r3
   1e9fa:	1af6      	subs	r6, r6, r3
   1e9fc:	42b7      	cmp	r7, r6
   1e9fe:	d100      	bne.n	1ea02 <__aeabi_ddiv+0x306>
   1ea00:	e106      	b.n	1ec10 <__aeabi_ddiv+0x514>
   1ea02:	4649      	mov	r1, r9
   1ea04:	0030      	movs	r0, r6
   1ea06:	f7e5 fc72 	bl	42ee <__aeabi_uidiv>
   1ea0a:	9b00      	ldr	r3, [sp, #0]
   1ea0c:	0004      	movs	r4, r0
   1ea0e:	4343      	muls	r3, r0
   1ea10:	4649      	mov	r1, r9
   1ea12:	0030      	movs	r0, r6
   1ea14:	4698      	mov	r8, r3
   1ea16:	f7e5 fc6a 	bl	42ee <__aeabi_uidiv>
   1ea1a:	0c2e      	lsrs	r6, r5, #16
   1ea1c:	0409      	lsls	r1, r1, #16
   1ea1e:	430e      	orrs	r6, r1
   1ea20:	45b0      	cmp	r8, r6
   1ea22:	d909      	bls.n	1ea38 <__aeabi_ddiv+0x33c>
   1ea24:	19f6      	adds	r6, r6, r7
   1ea26:	1e63      	subs	r3, r4, #1
   1ea28:	42b7      	cmp	r7, r6
   1ea2a:	d900      	bls.n	1ea2e <__aeabi_ddiv+0x332>
   1ea2c:	e0f3      	b.n	1ec16 <__aeabi_ddiv+0x51a>
   1ea2e:	45b0      	cmp	r8, r6
   1ea30:	d800      	bhi.n	1ea34 <__aeabi_ddiv+0x338>
   1ea32:	e0f0      	b.n	1ec16 <__aeabi_ddiv+0x51a>
   1ea34:	3c02      	subs	r4, #2
   1ea36:	19f6      	adds	r6, r6, r7
   1ea38:	4643      	mov	r3, r8
   1ea3a:	1af3      	subs	r3, r6, r3
   1ea3c:	4649      	mov	r1, r9
   1ea3e:	0018      	movs	r0, r3
   1ea40:	9302      	str	r3, [sp, #8]
   1ea42:	f7e5 fc54 	bl	42ee <__aeabi_uidiv>
   1ea46:	9b00      	ldr	r3, [sp, #0]
   1ea48:	0006      	movs	r6, r0
   1ea4a:	4343      	muls	r3, r0
   1ea4c:	4649      	mov	r1, r9
   1ea4e:	9802      	ldr	r0, [sp, #8]
   1ea50:	4698      	mov	r8, r3
   1ea52:	f7e5 fc4c 	bl	42ee <__aeabi_uidiv>
   1ea56:	042d      	lsls	r5, r5, #16
   1ea58:	0409      	lsls	r1, r1, #16
   1ea5a:	0c2d      	lsrs	r5, r5, #16
   1ea5c:	430d      	orrs	r5, r1
   1ea5e:	45a8      	cmp	r8, r5
   1ea60:	d909      	bls.n	1ea76 <__aeabi_ddiv+0x37a>
   1ea62:	19ed      	adds	r5, r5, r7
   1ea64:	1e73      	subs	r3, r6, #1
   1ea66:	42af      	cmp	r7, r5
   1ea68:	d900      	bls.n	1ea6c <__aeabi_ddiv+0x370>
   1ea6a:	e0d6      	b.n	1ec1a <__aeabi_ddiv+0x51e>
   1ea6c:	45a8      	cmp	r8, r5
   1ea6e:	d800      	bhi.n	1ea72 <__aeabi_ddiv+0x376>
   1ea70:	e0d3      	b.n	1ec1a <__aeabi_ddiv+0x51e>
   1ea72:	3e02      	subs	r6, #2
   1ea74:	19ed      	adds	r5, r5, r7
   1ea76:	0424      	lsls	r4, r4, #16
   1ea78:	0021      	movs	r1, r4
   1ea7a:	4643      	mov	r3, r8
   1ea7c:	4331      	orrs	r1, r6
   1ea7e:	9e04      	ldr	r6, [sp, #16]
   1ea80:	9a05      	ldr	r2, [sp, #20]
   1ea82:	0030      	movs	r0, r6
   1ea84:	1aed      	subs	r5, r5, r3
   1ea86:	040b      	lsls	r3, r1, #16
   1ea88:	0c0c      	lsrs	r4, r1, #16
   1ea8a:	0c1b      	lsrs	r3, r3, #16
   1ea8c:	4358      	muls	r0, r3
   1ea8e:	4366      	muls	r6, r4
   1ea90:	4353      	muls	r3, r2
   1ea92:	4354      	muls	r4, r2
   1ea94:	199a      	adds	r2, r3, r6
   1ea96:	0c03      	lsrs	r3, r0, #16
   1ea98:	189b      	adds	r3, r3, r2
   1ea9a:	429e      	cmp	r6, r3
   1ea9c:	d903      	bls.n	1eaa6 <__aeabi_ddiv+0x3aa>
   1ea9e:	2280      	movs	r2, #128	; 0x80
   1eaa0:	0252      	lsls	r2, r2, #9
   1eaa2:	4694      	mov	ip, r2
   1eaa4:	4464      	add	r4, ip
   1eaa6:	0c1a      	lsrs	r2, r3, #16
   1eaa8:	0400      	lsls	r0, r0, #16
   1eaaa:	041b      	lsls	r3, r3, #16
   1eaac:	0c00      	lsrs	r0, r0, #16
   1eaae:	1914      	adds	r4, r2, r4
   1eab0:	181b      	adds	r3, r3, r0
   1eab2:	42a5      	cmp	r5, r4
   1eab4:	d350      	bcc.n	1eb58 <__aeabi_ddiv+0x45c>
   1eab6:	d04d      	beq.n	1eb54 <__aeabi_ddiv+0x458>
   1eab8:	2301      	movs	r3, #1
   1eaba:	4319      	orrs	r1, r3
   1eabc:	4a96      	ldr	r2, [pc, #600]	; (1ed18 <__aeabi_ddiv+0x61c>)
   1eabe:	9b01      	ldr	r3, [sp, #4]
   1eac0:	4694      	mov	ip, r2
   1eac2:	4463      	add	r3, ip
   1eac4:	2b00      	cmp	r3, #0
   1eac6:	dc00      	bgt.n	1eaca <__aeabi_ddiv+0x3ce>
   1eac8:	e6f3      	b.n	1e8b2 <__aeabi_ddiv+0x1b6>
   1eaca:	074a      	lsls	r2, r1, #29
   1eacc:	d009      	beq.n	1eae2 <__aeabi_ddiv+0x3e6>
   1eace:	220f      	movs	r2, #15
   1ead0:	400a      	ands	r2, r1
   1ead2:	2a04      	cmp	r2, #4
   1ead4:	d005      	beq.n	1eae2 <__aeabi_ddiv+0x3e6>
   1ead6:	1d0a      	adds	r2, r1, #4
   1ead8:	428a      	cmp	r2, r1
   1eada:	4189      	sbcs	r1, r1
   1eadc:	4249      	negs	r1, r1
   1eade:	448b      	add	fp, r1
   1eae0:	0011      	movs	r1, r2
   1eae2:	465a      	mov	r2, fp
   1eae4:	01d2      	lsls	r2, r2, #7
   1eae6:	d508      	bpl.n	1eafa <__aeabi_ddiv+0x3fe>
   1eae8:	465a      	mov	r2, fp
   1eaea:	4b8c      	ldr	r3, [pc, #560]	; (1ed1c <__aeabi_ddiv+0x620>)
   1eaec:	401a      	ands	r2, r3
   1eaee:	4693      	mov	fp, r2
   1eaf0:	2280      	movs	r2, #128	; 0x80
   1eaf2:	00d2      	lsls	r2, r2, #3
   1eaf4:	4694      	mov	ip, r2
   1eaf6:	9b01      	ldr	r3, [sp, #4]
   1eaf8:	4463      	add	r3, ip
   1eafa:	4a89      	ldr	r2, [pc, #548]	; (1ed20 <__aeabi_ddiv+0x624>)
   1eafc:	4293      	cmp	r3, r2
   1eafe:	dd00      	ble.n	1eb02 <__aeabi_ddiv+0x406>
   1eb00:	e65b      	b.n	1e7ba <__aeabi_ddiv+0xbe>
   1eb02:	465a      	mov	r2, fp
   1eb04:	08c9      	lsrs	r1, r1, #3
   1eb06:	0750      	lsls	r0, r2, #29
   1eb08:	4308      	orrs	r0, r1
   1eb0a:	0256      	lsls	r6, r2, #9
   1eb0c:	4651      	mov	r1, sl
   1eb0e:	2201      	movs	r2, #1
   1eb10:	055b      	lsls	r3, r3, #21
   1eb12:	4681      	mov	r9, r0
   1eb14:	0b36      	lsrs	r6, r6, #12
   1eb16:	0d5b      	lsrs	r3, r3, #21
   1eb18:	400a      	ands	r2, r1
   1eb1a:	e655      	b.n	1e7c8 <__aeabi_ddiv+0xcc>
   1eb1c:	2380      	movs	r3, #128	; 0x80
   1eb1e:	031b      	lsls	r3, r3, #12
   1eb20:	421e      	tst	r6, r3
   1eb22:	d011      	beq.n	1eb48 <__aeabi_ddiv+0x44c>
   1eb24:	465a      	mov	r2, fp
   1eb26:	421a      	tst	r2, r3
   1eb28:	d10e      	bne.n	1eb48 <__aeabi_ddiv+0x44c>
   1eb2a:	465e      	mov	r6, fp
   1eb2c:	431e      	orrs	r6, r3
   1eb2e:	0336      	lsls	r6, r6, #12
   1eb30:	0b36      	lsrs	r6, r6, #12
   1eb32:	002a      	movs	r2, r5
   1eb34:	4689      	mov	r9, r1
   1eb36:	4b7b      	ldr	r3, [pc, #492]	; (1ed24 <__aeabi_ddiv+0x628>)
   1eb38:	e646      	b.n	1e7c8 <__aeabi_ddiv+0xcc>
   1eb3a:	2b03      	cmp	r3, #3
   1eb3c:	d100      	bne.n	1eb40 <__aeabi_ddiv+0x444>
   1eb3e:	e0e1      	b.n	1ed04 <__aeabi_ddiv+0x608>
   1eb40:	2b01      	cmp	r3, #1
   1eb42:	d1bb      	bne.n	1eabc <__aeabi_ddiv+0x3c0>
   1eb44:	401a      	ands	r2, r3
   1eb46:	e6bb      	b.n	1e8c0 <__aeabi_ddiv+0x1c4>
   1eb48:	431e      	orrs	r6, r3
   1eb4a:	0336      	lsls	r6, r6, #12
   1eb4c:	0b36      	lsrs	r6, r6, #12
   1eb4e:	4642      	mov	r2, r8
   1eb50:	4b74      	ldr	r3, [pc, #464]	; (1ed24 <__aeabi_ddiv+0x628>)
   1eb52:	e639      	b.n	1e7c8 <__aeabi_ddiv+0xcc>
   1eb54:	2b00      	cmp	r3, #0
   1eb56:	d0b1      	beq.n	1eabc <__aeabi_ddiv+0x3c0>
   1eb58:	197d      	adds	r5, r7, r5
   1eb5a:	1e4a      	subs	r2, r1, #1
   1eb5c:	42af      	cmp	r7, r5
   1eb5e:	d952      	bls.n	1ec06 <__aeabi_ddiv+0x50a>
   1eb60:	0011      	movs	r1, r2
   1eb62:	42a5      	cmp	r5, r4
   1eb64:	d1a8      	bne.n	1eab8 <__aeabi_ddiv+0x3bc>
   1eb66:	9a03      	ldr	r2, [sp, #12]
   1eb68:	429a      	cmp	r2, r3
   1eb6a:	d1a5      	bne.n	1eab8 <__aeabi_ddiv+0x3bc>
   1eb6c:	e7a6      	b.n	1eabc <__aeabi_ddiv+0x3c0>
   1eb6e:	0003      	movs	r3, r0
   1eb70:	003e      	movs	r6, r7
   1eb72:	3b28      	subs	r3, #40	; 0x28
   1eb74:	409e      	lsls	r6, r3
   1eb76:	2300      	movs	r3, #0
   1eb78:	4699      	mov	r9, r3
   1eb7a:	e654      	b.n	1e826 <__aeabi_ddiv+0x12a>
   1eb7c:	f7ff f948 	bl	1de10 <__clzsi2>
   1eb80:	3020      	adds	r0, #32
   1eb82:	e641      	b.n	1e808 <__aeabi_ddiv+0x10c>
   1eb84:	0003      	movs	r3, r0
   1eb86:	4652      	mov	r2, sl
   1eb88:	3b28      	subs	r3, #40	; 0x28
   1eb8a:	409a      	lsls	r2, r3
   1eb8c:	2100      	movs	r1, #0
   1eb8e:	4693      	mov	fp, r2
   1eb90:	e677      	b.n	1e882 <__aeabi_ddiv+0x186>
   1eb92:	4650      	mov	r0, sl
   1eb94:	f7ff f93c 	bl	1de10 <__clzsi2>
   1eb98:	3020      	adds	r0, #32
   1eb9a:	e65e      	b.n	1e85a <__aeabi_ddiv+0x15e>
   1eb9c:	9b02      	ldr	r3, [sp, #8]
   1eb9e:	2600      	movs	r6, #0
   1eba0:	42ab      	cmp	r3, r5
   1eba2:	d300      	bcc.n	1eba6 <__aeabi_ddiv+0x4aa>
   1eba4:	e723      	b.n	1e9ee <__aeabi_ddiv+0x2f2>
   1eba6:	9e03      	ldr	r6, [sp, #12]
   1eba8:	9902      	ldr	r1, [sp, #8]
   1ebaa:	46b4      	mov	ip, r6
   1ebac:	4461      	add	r1, ip
   1ebae:	4688      	mov	r8, r1
   1ebb0:	45b0      	cmp	r8, r6
   1ebb2:	41b6      	sbcs	r6, r6
   1ebb4:	465b      	mov	r3, fp
   1ebb6:	4276      	negs	r6, r6
   1ebb8:	19f6      	adds	r6, r6, r7
   1ebba:	18b2      	adds	r2, r6, r2
   1ebbc:	3b01      	subs	r3, #1
   1ebbe:	9102      	str	r1, [sp, #8]
   1ebc0:	4297      	cmp	r7, r2
   1ebc2:	d213      	bcs.n	1ebec <__aeabi_ddiv+0x4f0>
   1ebc4:	4290      	cmp	r0, r2
   1ebc6:	d84f      	bhi.n	1ec68 <__aeabi_ddiv+0x56c>
   1ebc8:	d100      	bne.n	1ebcc <__aeabi_ddiv+0x4d0>
   1ebca:	e08e      	b.n	1ecea <__aeabi_ddiv+0x5ee>
   1ebcc:	1a16      	subs	r6, r2, r0
   1ebce:	469b      	mov	fp, r3
   1ebd0:	e70d      	b.n	1e9ee <__aeabi_ddiv+0x2f2>
   1ebd2:	4589      	cmp	r9, r1
   1ebd4:	d200      	bcs.n	1ebd8 <__aeabi_ddiv+0x4dc>
   1ebd6:	e68e      	b.n	1e8f6 <__aeabi_ddiv+0x1fa>
   1ebd8:	0874      	lsrs	r4, r6, #1
   1ebda:	464b      	mov	r3, r9
   1ebdc:	07f6      	lsls	r6, r6, #31
   1ebde:	0035      	movs	r5, r6
   1ebe0:	085b      	lsrs	r3, r3, #1
   1ebe2:	431d      	orrs	r5, r3
   1ebe4:	464b      	mov	r3, r9
   1ebe6:	07db      	lsls	r3, r3, #31
   1ebe8:	9302      	str	r3, [sp, #8]
   1ebea:	e68b      	b.n	1e904 <__aeabi_ddiv+0x208>
   1ebec:	4297      	cmp	r7, r2
   1ebee:	d1ed      	bne.n	1ebcc <__aeabi_ddiv+0x4d0>
   1ebf0:	9903      	ldr	r1, [sp, #12]
   1ebf2:	9c02      	ldr	r4, [sp, #8]
   1ebf4:	42a1      	cmp	r1, r4
   1ebf6:	d9e5      	bls.n	1ebc4 <__aeabi_ddiv+0x4c8>
   1ebf8:	1a3e      	subs	r6, r7, r0
   1ebfa:	469b      	mov	fp, r3
   1ebfc:	e6f7      	b.n	1e9ee <__aeabi_ddiv+0x2f2>
   1ebfe:	4698      	mov	r8, r3
   1ec00:	e6ca      	b.n	1e998 <__aeabi_ddiv+0x29c>
   1ec02:	001e      	movs	r6, r3
   1ec04:	e6a5      	b.n	1e952 <__aeabi_ddiv+0x256>
   1ec06:	42ac      	cmp	r4, r5
   1ec08:	d83e      	bhi.n	1ec88 <__aeabi_ddiv+0x58c>
   1ec0a:	d074      	beq.n	1ecf6 <__aeabi_ddiv+0x5fa>
   1ec0c:	0011      	movs	r1, r2
   1ec0e:	e753      	b.n	1eab8 <__aeabi_ddiv+0x3bc>
   1ec10:	2101      	movs	r1, #1
   1ec12:	4249      	negs	r1, r1
   1ec14:	e752      	b.n	1eabc <__aeabi_ddiv+0x3c0>
   1ec16:	001c      	movs	r4, r3
   1ec18:	e70e      	b.n	1ea38 <__aeabi_ddiv+0x33c>
   1ec1a:	001e      	movs	r6, r3
   1ec1c:	e72b      	b.n	1ea76 <__aeabi_ddiv+0x37a>
   1ec1e:	2d1f      	cmp	r5, #31
   1ec20:	dc3c      	bgt.n	1ec9c <__aeabi_ddiv+0x5a0>
   1ec22:	2320      	movs	r3, #32
   1ec24:	000a      	movs	r2, r1
   1ec26:	4658      	mov	r0, fp
   1ec28:	1b5b      	subs	r3, r3, r5
   1ec2a:	4098      	lsls	r0, r3
   1ec2c:	40ea      	lsrs	r2, r5
   1ec2e:	4099      	lsls	r1, r3
   1ec30:	4302      	orrs	r2, r0
   1ec32:	1e48      	subs	r0, r1, #1
   1ec34:	4181      	sbcs	r1, r0
   1ec36:	465e      	mov	r6, fp
   1ec38:	4311      	orrs	r1, r2
   1ec3a:	40ee      	lsrs	r6, r5
   1ec3c:	074b      	lsls	r3, r1, #29
   1ec3e:	d009      	beq.n	1ec54 <__aeabi_ddiv+0x558>
   1ec40:	230f      	movs	r3, #15
   1ec42:	400b      	ands	r3, r1
   1ec44:	2b04      	cmp	r3, #4
   1ec46:	d005      	beq.n	1ec54 <__aeabi_ddiv+0x558>
   1ec48:	000b      	movs	r3, r1
   1ec4a:	1d19      	adds	r1, r3, #4
   1ec4c:	4299      	cmp	r1, r3
   1ec4e:	419b      	sbcs	r3, r3
   1ec50:	425b      	negs	r3, r3
   1ec52:	18f6      	adds	r6, r6, r3
   1ec54:	0233      	lsls	r3, r6, #8
   1ec56:	d53c      	bpl.n	1ecd2 <__aeabi_ddiv+0x5d6>
   1ec58:	4653      	mov	r3, sl
   1ec5a:	2201      	movs	r2, #1
   1ec5c:	2100      	movs	r1, #0
   1ec5e:	401a      	ands	r2, r3
   1ec60:	2600      	movs	r6, #0
   1ec62:	2301      	movs	r3, #1
   1ec64:	4689      	mov	r9, r1
   1ec66:	e5af      	b.n	1e7c8 <__aeabi_ddiv+0xcc>
   1ec68:	2302      	movs	r3, #2
   1ec6a:	425b      	negs	r3, r3
   1ec6c:	469c      	mov	ip, r3
   1ec6e:	9c03      	ldr	r4, [sp, #12]
   1ec70:	44e3      	add	fp, ip
   1ec72:	46a4      	mov	ip, r4
   1ec74:	9b02      	ldr	r3, [sp, #8]
   1ec76:	4463      	add	r3, ip
   1ec78:	4698      	mov	r8, r3
   1ec7a:	45a0      	cmp	r8, r4
   1ec7c:	41b6      	sbcs	r6, r6
   1ec7e:	4276      	negs	r6, r6
   1ec80:	19f6      	adds	r6, r6, r7
   1ec82:	9302      	str	r3, [sp, #8]
   1ec84:	18b2      	adds	r2, r6, r2
   1ec86:	e6b1      	b.n	1e9ec <__aeabi_ddiv+0x2f0>
   1ec88:	9803      	ldr	r0, [sp, #12]
   1ec8a:	1e8a      	subs	r2, r1, #2
   1ec8c:	0041      	lsls	r1, r0, #1
   1ec8e:	4281      	cmp	r1, r0
   1ec90:	41b6      	sbcs	r6, r6
   1ec92:	4276      	negs	r6, r6
   1ec94:	19f6      	adds	r6, r6, r7
   1ec96:	19ad      	adds	r5, r5, r6
   1ec98:	9103      	str	r1, [sp, #12]
   1ec9a:	e761      	b.n	1eb60 <__aeabi_ddiv+0x464>
   1ec9c:	221f      	movs	r2, #31
   1ec9e:	4252      	negs	r2, r2
   1eca0:	1ad3      	subs	r3, r2, r3
   1eca2:	465a      	mov	r2, fp
   1eca4:	40da      	lsrs	r2, r3
   1eca6:	0013      	movs	r3, r2
   1eca8:	2d20      	cmp	r5, #32
   1ecaa:	d029      	beq.n	1ed00 <__aeabi_ddiv+0x604>
   1ecac:	2240      	movs	r2, #64	; 0x40
   1ecae:	4658      	mov	r0, fp
   1ecb0:	1b55      	subs	r5, r2, r5
   1ecb2:	40a8      	lsls	r0, r5
   1ecb4:	4301      	orrs	r1, r0
   1ecb6:	1e48      	subs	r0, r1, #1
   1ecb8:	4181      	sbcs	r1, r0
   1ecba:	2007      	movs	r0, #7
   1ecbc:	430b      	orrs	r3, r1
   1ecbe:	4018      	ands	r0, r3
   1ecc0:	2600      	movs	r6, #0
   1ecc2:	2800      	cmp	r0, #0
   1ecc4:	d009      	beq.n	1ecda <__aeabi_ddiv+0x5de>
   1ecc6:	220f      	movs	r2, #15
   1ecc8:	2600      	movs	r6, #0
   1ecca:	401a      	ands	r2, r3
   1eccc:	0019      	movs	r1, r3
   1ecce:	2a04      	cmp	r2, #4
   1ecd0:	d1bb      	bne.n	1ec4a <__aeabi_ddiv+0x54e>
   1ecd2:	000b      	movs	r3, r1
   1ecd4:	0770      	lsls	r0, r6, #29
   1ecd6:	0276      	lsls	r6, r6, #9
   1ecd8:	0b36      	lsrs	r6, r6, #12
   1ecda:	08db      	lsrs	r3, r3, #3
   1ecdc:	4303      	orrs	r3, r0
   1ecde:	4699      	mov	r9, r3
   1ece0:	2201      	movs	r2, #1
   1ece2:	4653      	mov	r3, sl
   1ece4:	401a      	ands	r2, r3
   1ece6:	2300      	movs	r3, #0
   1ece8:	e56e      	b.n	1e7c8 <__aeabi_ddiv+0xcc>
   1ecea:	9902      	ldr	r1, [sp, #8]
   1ecec:	428d      	cmp	r5, r1
   1ecee:	d8bb      	bhi.n	1ec68 <__aeabi_ddiv+0x56c>
   1ecf0:	469b      	mov	fp, r3
   1ecf2:	2600      	movs	r6, #0
   1ecf4:	e67b      	b.n	1e9ee <__aeabi_ddiv+0x2f2>
   1ecf6:	9803      	ldr	r0, [sp, #12]
   1ecf8:	4298      	cmp	r0, r3
   1ecfa:	d3c5      	bcc.n	1ec88 <__aeabi_ddiv+0x58c>
   1ecfc:	0011      	movs	r1, r2
   1ecfe:	e732      	b.n	1eb66 <__aeabi_ddiv+0x46a>
   1ed00:	2000      	movs	r0, #0
   1ed02:	e7d7      	b.n	1ecb4 <__aeabi_ddiv+0x5b8>
   1ed04:	2680      	movs	r6, #128	; 0x80
   1ed06:	465b      	mov	r3, fp
   1ed08:	0336      	lsls	r6, r6, #12
   1ed0a:	431e      	orrs	r6, r3
   1ed0c:	0336      	lsls	r6, r6, #12
   1ed0e:	0b36      	lsrs	r6, r6, #12
   1ed10:	9a00      	ldr	r2, [sp, #0]
   1ed12:	4689      	mov	r9, r1
   1ed14:	4b03      	ldr	r3, [pc, #12]	; (1ed24 <__aeabi_ddiv+0x628>)
   1ed16:	e557      	b.n	1e7c8 <__aeabi_ddiv+0xcc>
   1ed18:	000003ff 	.word	0x000003ff
   1ed1c:	feffffff 	.word	0xfeffffff
   1ed20:	000007fe 	.word	0x000007fe
   1ed24:	000007ff 	.word	0x000007ff

0001ed28 <__eqdf2>:
   1ed28:	b5f0      	push	{r4, r5, r6, r7, lr}
   1ed2a:	465f      	mov	r7, fp
   1ed2c:	4656      	mov	r6, sl
   1ed2e:	464d      	mov	r5, r9
   1ed30:	4644      	mov	r4, r8
   1ed32:	b4f0      	push	{r4, r5, r6, r7}
   1ed34:	031f      	lsls	r7, r3, #12
   1ed36:	005c      	lsls	r4, r3, #1
   1ed38:	0fdb      	lsrs	r3, r3, #31
   1ed3a:	469a      	mov	sl, r3
   1ed3c:	4b19      	ldr	r3, [pc, #100]	; (1eda4 <__eqdf2+0x7c>)
   1ed3e:	030e      	lsls	r6, r1, #12
   1ed40:	004d      	lsls	r5, r1, #1
   1ed42:	0fc9      	lsrs	r1, r1, #31
   1ed44:	4680      	mov	r8, r0
   1ed46:	0b36      	lsrs	r6, r6, #12
   1ed48:	0d6d      	lsrs	r5, r5, #21
   1ed4a:	468b      	mov	fp, r1
   1ed4c:	4691      	mov	r9, r2
   1ed4e:	0b3f      	lsrs	r7, r7, #12
   1ed50:	0d64      	lsrs	r4, r4, #21
   1ed52:	429d      	cmp	r5, r3
   1ed54:	d019      	beq.n	1ed8a <__eqdf2+0x62>
   1ed56:	4b13      	ldr	r3, [pc, #76]	; (1eda4 <__eqdf2+0x7c>)
   1ed58:	429c      	cmp	r4, r3
   1ed5a:	d01b      	beq.n	1ed94 <__eqdf2+0x6c>
   1ed5c:	2301      	movs	r3, #1
   1ed5e:	42a5      	cmp	r5, r4
   1ed60:	d006      	beq.n	1ed70 <__eqdf2+0x48>
   1ed62:	0018      	movs	r0, r3
   1ed64:	bc3c      	pop	{r2, r3, r4, r5}
   1ed66:	4690      	mov	r8, r2
   1ed68:	4699      	mov	r9, r3
   1ed6a:	46a2      	mov	sl, r4
   1ed6c:	46ab      	mov	fp, r5
   1ed6e:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1ed70:	42be      	cmp	r6, r7
   1ed72:	d1f6      	bne.n	1ed62 <__eqdf2+0x3a>
   1ed74:	45c8      	cmp	r8, r9
   1ed76:	d1f4      	bne.n	1ed62 <__eqdf2+0x3a>
   1ed78:	45d3      	cmp	fp, sl
   1ed7a:	d010      	beq.n	1ed9e <__eqdf2+0x76>
   1ed7c:	2d00      	cmp	r5, #0
   1ed7e:	d1f0      	bne.n	1ed62 <__eqdf2+0x3a>
   1ed80:	4330      	orrs	r0, r6
   1ed82:	0003      	movs	r3, r0
   1ed84:	1e5a      	subs	r2, r3, #1
   1ed86:	4193      	sbcs	r3, r2
   1ed88:	e7eb      	b.n	1ed62 <__eqdf2+0x3a>
   1ed8a:	0031      	movs	r1, r6
   1ed8c:	2301      	movs	r3, #1
   1ed8e:	4301      	orrs	r1, r0
   1ed90:	d1e7      	bne.n	1ed62 <__eqdf2+0x3a>
   1ed92:	e7e0      	b.n	1ed56 <__eqdf2+0x2e>
   1ed94:	433a      	orrs	r2, r7
   1ed96:	2301      	movs	r3, #1
   1ed98:	2a00      	cmp	r2, #0
   1ed9a:	d1e2      	bne.n	1ed62 <__eqdf2+0x3a>
   1ed9c:	e7de      	b.n	1ed5c <__eqdf2+0x34>
   1ed9e:	2300      	movs	r3, #0
   1eda0:	e7df      	b.n	1ed62 <__eqdf2+0x3a>
   1eda2:	46c0      	nop			; (mov r8, r8)
   1eda4:	000007ff 	.word	0x000007ff

0001eda8 <__gedf2>:
   1eda8:	b5f0      	push	{r4, r5, r6, r7, lr}
   1edaa:	465f      	mov	r7, fp
   1edac:	4644      	mov	r4, r8
   1edae:	4656      	mov	r6, sl
   1edb0:	464d      	mov	r5, r9
   1edb2:	b4f0      	push	{r4, r5, r6, r7}
   1edb4:	031f      	lsls	r7, r3, #12
   1edb6:	0b3c      	lsrs	r4, r7, #12
   1edb8:	4f2c      	ldr	r7, [pc, #176]	; (1ee6c <__gedf2+0xc4>)
   1edba:	030e      	lsls	r6, r1, #12
   1edbc:	004d      	lsls	r5, r1, #1
   1edbe:	46a3      	mov	fp, r4
   1edc0:	005c      	lsls	r4, r3, #1
   1edc2:	4684      	mov	ip, r0
   1edc4:	0b36      	lsrs	r6, r6, #12
   1edc6:	0d6d      	lsrs	r5, r5, #21
   1edc8:	0fc9      	lsrs	r1, r1, #31
   1edca:	4690      	mov	r8, r2
   1edcc:	0d64      	lsrs	r4, r4, #21
   1edce:	0fdb      	lsrs	r3, r3, #31
   1edd0:	42bd      	cmp	r5, r7
   1edd2:	d02b      	beq.n	1ee2c <__gedf2+0x84>
   1edd4:	4f25      	ldr	r7, [pc, #148]	; (1ee6c <__gedf2+0xc4>)
   1edd6:	42bc      	cmp	r4, r7
   1edd8:	d02e      	beq.n	1ee38 <__gedf2+0x90>
   1edda:	2d00      	cmp	r5, #0
   1eddc:	d10e      	bne.n	1edfc <__gedf2+0x54>
   1edde:	4330      	orrs	r0, r6
   1ede0:	0007      	movs	r7, r0
   1ede2:	4681      	mov	r9, r0
   1ede4:	4278      	negs	r0, r7
   1ede6:	4178      	adcs	r0, r7
   1ede8:	2c00      	cmp	r4, #0
   1edea:	d117      	bne.n	1ee1c <__gedf2+0x74>
   1edec:	465f      	mov	r7, fp
   1edee:	433a      	orrs	r2, r7
   1edf0:	d114      	bne.n	1ee1c <__gedf2+0x74>
   1edf2:	464b      	mov	r3, r9
   1edf4:	2000      	movs	r0, #0
   1edf6:	2b00      	cmp	r3, #0
   1edf8:	d00a      	beq.n	1ee10 <__gedf2+0x68>
   1edfa:	e006      	b.n	1ee0a <__gedf2+0x62>
   1edfc:	2c00      	cmp	r4, #0
   1edfe:	d102      	bne.n	1ee06 <__gedf2+0x5e>
   1ee00:	4658      	mov	r0, fp
   1ee02:	4302      	orrs	r2, r0
   1ee04:	d001      	beq.n	1ee0a <__gedf2+0x62>
   1ee06:	4299      	cmp	r1, r3
   1ee08:	d01a      	beq.n	1ee40 <__gedf2+0x98>
   1ee0a:	2301      	movs	r3, #1
   1ee0c:	4248      	negs	r0, r1
   1ee0e:	4318      	orrs	r0, r3
   1ee10:	bc3c      	pop	{r2, r3, r4, r5}
   1ee12:	4690      	mov	r8, r2
   1ee14:	4699      	mov	r9, r3
   1ee16:	46a2      	mov	sl, r4
   1ee18:	46ab      	mov	fp, r5
   1ee1a:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1ee1c:	2800      	cmp	r0, #0
   1ee1e:	d0f2      	beq.n	1ee06 <__gedf2+0x5e>
   1ee20:	4258      	negs	r0, r3
   1ee22:	4158      	adcs	r0, r3
   1ee24:	2201      	movs	r2, #1
   1ee26:	4240      	negs	r0, r0
   1ee28:	4310      	orrs	r0, r2
   1ee2a:	e7f1      	b.n	1ee10 <__gedf2+0x68>
   1ee2c:	0037      	movs	r7, r6
   1ee2e:	4307      	orrs	r7, r0
   1ee30:	d0d0      	beq.n	1edd4 <__gedf2+0x2c>
   1ee32:	2002      	movs	r0, #2
   1ee34:	4240      	negs	r0, r0
   1ee36:	e7eb      	b.n	1ee10 <__gedf2+0x68>
   1ee38:	465f      	mov	r7, fp
   1ee3a:	4317      	orrs	r7, r2
   1ee3c:	d0cd      	beq.n	1edda <__gedf2+0x32>
   1ee3e:	e7f8      	b.n	1ee32 <__gedf2+0x8a>
   1ee40:	42a5      	cmp	r5, r4
   1ee42:	dce2      	bgt.n	1ee0a <__gedf2+0x62>
   1ee44:	db05      	blt.n	1ee52 <__gedf2+0xaa>
   1ee46:	455e      	cmp	r6, fp
   1ee48:	d8df      	bhi.n	1ee0a <__gedf2+0x62>
   1ee4a:	d008      	beq.n	1ee5e <__gedf2+0xb6>
   1ee4c:	2000      	movs	r0, #0
   1ee4e:	455e      	cmp	r6, fp
   1ee50:	d2de      	bcs.n	1ee10 <__gedf2+0x68>
   1ee52:	4248      	negs	r0, r1
   1ee54:	4148      	adcs	r0, r1
   1ee56:	2301      	movs	r3, #1
   1ee58:	4240      	negs	r0, r0
   1ee5a:	4318      	orrs	r0, r3
   1ee5c:	e7d8      	b.n	1ee10 <__gedf2+0x68>
   1ee5e:	45c4      	cmp	ip, r8
   1ee60:	d8d3      	bhi.n	1ee0a <__gedf2+0x62>
   1ee62:	2000      	movs	r0, #0
   1ee64:	45c4      	cmp	ip, r8
   1ee66:	d3f4      	bcc.n	1ee52 <__gedf2+0xaa>
   1ee68:	e7d2      	b.n	1ee10 <__gedf2+0x68>
   1ee6a:	46c0      	nop			; (mov r8, r8)
   1ee6c:	000007ff 	.word	0x000007ff

0001ee70 <__ledf2>:
   1ee70:	b5f0      	push	{r4, r5, r6, r7, lr}
   1ee72:	465f      	mov	r7, fp
   1ee74:	464d      	mov	r5, r9
   1ee76:	4644      	mov	r4, r8
   1ee78:	4656      	mov	r6, sl
   1ee7a:	b4f0      	push	{r4, r5, r6, r7}
   1ee7c:	031c      	lsls	r4, r3, #12
   1ee7e:	0b24      	lsrs	r4, r4, #12
   1ee80:	46a4      	mov	ip, r4
   1ee82:	4c2f      	ldr	r4, [pc, #188]	; (1ef40 <__ledf2+0xd0>)
   1ee84:	030f      	lsls	r7, r1, #12
   1ee86:	004d      	lsls	r5, r1, #1
   1ee88:	005e      	lsls	r6, r3, #1
   1ee8a:	0fc9      	lsrs	r1, r1, #31
   1ee8c:	4680      	mov	r8, r0
   1ee8e:	0b3f      	lsrs	r7, r7, #12
   1ee90:	0d6d      	lsrs	r5, r5, #21
   1ee92:	468b      	mov	fp, r1
   1ee94:	4691      	mov	r9, r2
   1ee96:	0d76      	lsrs	r6, r6, #21
   1ee98:	0fdb      	lsrs	r3, r3, #31
   1ee9a:	42a5      	cmp	r5, r4
   1ee9c:	d020      	beq.n	1eee0 <__ledf2+0x70>
   1ee9e:	4c28      	ldr	r4, [pc, #160]	; (1ef40 <__ledf2+0xd0>)
   1eea0:	42a6      	cmp	r6, r4
   1eea2:	d022      	beq.n	1eeea <__ledf2+0x7a>
   1eea4:	2d00      	cmp	r5, #0
   1eea6:	d112      	bne.n	1eece <__ledf2+0x5e>
   1eea8:	4338      	orrs	r0, r7
   1eeaa:	4244      	negs	r4, r0
   1eeac:	4144      	adcs	r4, r0
   1eeae:	2e00      	cmp	r6, #0
   1eeb0:	d020      	beq.n	1eef4 <__ledf2+0x84>
   1eeb2:	2c00      	cmp	r4, #0
   1eeb4:	d00d      	beq.n	1eed2 <__ledf2+0x62>
   1eeb6:	425c      	negs	r4, r3
   1eeb8:	4163      	adcs	r3, r4
   1eeba:	2401      	movs	r4, #1
   1eebc:	425b      	negs	r3, r3
   1eebe:	431c      	orrs	r4, r3
   1eec0:	0020      	movs	r0, r4
   1eec2:	bc3c      	pop	{r2, r3, r4, r5}
   1eec4:	4690      	mov	r8, r2
   1eec6:	4699      	mov	r9, r3
   1eec8:	46a2      	mov	sl, r4
   1eeca:	46ab      	mov	fp, r5
   1eecc:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1eece:	2e00      	cmp	r6, #0
   1eed0:	d017      	beq.n	1ef02 <__ledf2+0x92>
   1eed2:	455b      	cmp	r3, fp
   1eed4:	d019      	beq.n	1ef0a <__ledf2+0x9a>
   1eed6:	465b      	mov	r3, fp
   1eed8:	425c      	negs	r4, r3
   1eeda:	2301      	movs	r3, #1
   1eedc:	431c      	orrs	r4, r3
   1eede:	e7ef      	b.n	1eec0 <__ledf2+0x50>
   1eee0:	0039      	movs	r1, r7
   1eee2:	2402      	movs	r4, #2
   1eee4:	4301      	orrs	r1, r0
   1eee6:	d1eb      	bne.n	1eec0 <__ledf2+0x50>
   1eee8:	e7d9      	b.n	1ee9e <__ledf2+0x2e>
   1eeea:	4661      	mov	r1, ip
   1eeec:	2402      	movs	r4, #2
   1eeee:	4311      	orrs	r1, r2
   1eef0:	d1e6      	bne.n	1eec0 <__ledf2+0x50>
   1eef2:	e7d7      	b.n	1eea4 <__ledf2+0x34>
   1eef4:	4661      	mov	r1, ip
   1eef6:	430a      	orrs	r2, r1
   1eef8:	d1db      	bne.n	1eeb2 <__ledf2+0x42>
   1eefa:	2400      	movs	r4, #0
   1eefc:	2800      	cmp	r0, #0
   1eefe:	d0df      	beq.n	1eec0 <__ledf2+0x50>
   1ef00:	e7e9      	b.n	1eed6 <__ledf2+0x66>
   1ef02:	4661      	mov	r1, ip
   1ef04:	430a      	orrs	r2, r1
   1ef06:	d1e4      	bne.n	1eed2 <__ledf2+0x62>
   1ef08:	e7e5      	b.n	1eed6 <__ledf2+0x66>
   1ef0a:	42b5      	cmp	r5, r6
   1ef0c:	dd03      	ble.n	1ef16 <__ledf2+0xa6>
   1ef0e:	2201      	movs	r2, #1
   1ef10:	425c      	negs	r4, r3
   1ef12:	4314      	orrs	r4, r2
   1ef14:	e7d4      	b.n	1eec0 <__ledf2+0x50>
   1ef16:	42b5      	cmp	r5, r6
   1ef18:	dbcd      	blt.n	1eeb6 <__ledf2+0x46>
   1ef1a:	4567      	cmp	r7, ip
   1ef1c:	d8db      	bhi.n	1eed6 <__ledf2+0x66>
   1ef1e:	d009      	beq.n	1ef34 <__ledf2+0xc4>
   1ef20:	2400      	movs	r4, #0
   1ef22:	4567      	cmp	r7, ip
   1ef24:	d2cc      	bcs.n	1eec0 <__ledf2+0x50>
   1ef26:	4659      	mov	r1, fp
   1ef28:	424c      	negs	r4, r1
   1ef2a:	4161      	adcs	r1, r4
   1ef2c:	2401      	movs	r4, #1
   1ef2e:	4249      	negs	r1, r1
   1ef30:	430c      	orrs	r4, r1
   1ef32:	e7c5      	b.n	1eec0 <__ledf2+0x50>
   1ef34:	45c8      	cmp	r8, r9
   1ef36:	d8ce      	bhi.n	1eed6 <__ledf2+0x66>
   1ef38:	2400      	movs	r4, #0
   1ef3a:	45c8      	cmp	r8, r9
   1ef3c:	d3f3      	bcc.n	1ef26 <__ledf2+0xb6>
   1ef3e:	e7bf      	b.n	1eec0 <__ledf2+0x50>
   1ef40:	000007ff 	.word	0x000007ff

0001ef44 <__aeabi_dmul>:
   1ef44:	b5f0      	push	{r4, r5, r6, r7, lr}
   1ef46:	465f      	mov	r7, fp
   1ef48:	4656      	mov	r6, sl
   1ef4a:	464d      	mov	r5, r9
   1ef4c:	4644      	mov	r4, r8
   1ef4e:	b4f0      	push	{r4, r5, r6, r7}
   1ef50:	030d      	lsls	r5, r1, #12
   1ef52:	4699      	mov	r9, r3
   1ef54:	004e      	lsls	r6, r1, #1
   1ef56:	0b2b      	lsrs	r3, r5, #12
   1ef58:	b087      	sub	sp, #28
   1ef5a:	0007      	movs	r7, r0
   1ef5c:	4692      	mov	sl, r2
   1ef5e:	4680      	mov	r8, r0
   1ef60:	469b      	mov	fp, r3
   1ef62:	0d76      	lsrs	r6, r6, #21
   1ef64:	0fcc      	lsrs	r4, r1, #31
   1ef66:	2e00      	cmp	r6, #0
   1ef68:	d069      	beq.n	1f03e <__aeabi_dmul+0xfa>
   1ef6a:	4b6d      	ldr	r3, [pc, #436]	; (1f120 <__aeabi_dmul+0x1dc>)
   1ef6c:	429e      	cmp	r6, r3
   1ef6e:	d035      	beq.n	1efdc <__aeabi_dmul+0x98>
   1ef70:	465b      	mov	r3, fp
   1ef72:	2280      	movs	r2, #128	; 0x80
   1ef74:	00dd      	lsls	r5, r3, #3
   1ef76:	0412      	lsls	r2, r2, #16
   1ef78:	0f43      	lsrs	r3, r0, #29
   1ef7a:	4313      	orrs	r3, r2
   1ef7c:	432b      	orrs	r3, r5
   1ef7e:	469b      	mov	fp, r3
   1ef80:	00c3      	lsls	r3, r0, #3
   1ef82:	4698      	mov	r8, r3
   1ef84:	4b67      	ldr	r3, [pc, #412]	; (1f124 <__aeabi_dmul+0x1e0>)
   1ef86:	2700      	movs	r7, #0
   1ef88:	469c      	mov	ip, r3
   1ef8a:	2300      	movs	r3, #0
   1ef8c:	4466      	add	r6, ip
   1ef8e:	9301      	str	r3, [sp, #4]
   1ef90:	464a      	mov	r2, r9
   1ef92:	0315      	lsls	r5, r2, #12
   1ef94:	0050      	lsls	r0, r2, #1
   1ef96:	0fd2      	lsrs	r2, r2, #31
   1ef98:	4653      	mov	r3, sl
   1ef9a:	0b2d      	lsrs	r5, r5, #12
   1ef9c:	0d40      	lsrs	r0, r0, #21
   1ef9e:	4691      	mov	r9, r2
   1efa0:	d100      	bne.n	1efa4 <__aeabi_dmul+0x60>
   1efa2:	e076      	b.n	1f092 <__aeabi_dmul+0x14e>
   1efa4:	4a5e      	ldr	r2, [pc, #376]	; (1f120 <__aeabi_dmul+0x1dc>)
   1efa6:	4290      	cmp	r0, r2
   1efa8:	d06c      	beq.n	1f084 <__aeabi_dmul+0x140>
   1efaa:	2280      	movs	r2, #128	; 0x80
   1efac:	0f5b      	lsrs	r3, r3, #29
   1efae:	0412      	lsls	r2, r2, #16
   1efb0:	4313      	orrs	r3, r2
   1efb2:	4a5c      	ldr	r2, [pc, #368]	; (1f124 <__aeabi_dmul+0x1e0>)
   1efb4:	00ed      	lsls	r5, r5, #3
   1efb6:	4694      	mov	ip, r2
   1efb8:	431d      	orrs	r5, r3
   1efba:	4653      	mov	r3, sl
   1efbc:	2200      	movs	r2, #0
   1efbe:	00db      	lsls	r3, r3, #3
   1efc0:	4460      	add	r0, ip
   1efc2:	4649      	mov	r1, r9
   1efc4:	1836      	adds	r6, r6, r0
   1efc6:	1c70      	adds	r0, r6, #1
   1efc8:	4061      	eors	r1, r4
   1efca:	9002      	str	r0, [sp, #8]
   1efcc:	4317      	orrs	r7, r2
   1efce:	2f0f      	cmp	r7, #15
   1efd0:	d900      	bls.n	1efd4 <__aeabi_dmul+0x90>
   1efd2:	e0af      	b.n	1f134 <__aeabi_dmul+0x1f0>
   1efd4:	4854      	ldr	r0, [pc, #336]	; (1f128 <__aeabi_dmul+0x1e4>)
   1efd6:	00bf      	lsls	r7, r7, #2
   1efd8:	59c7      	ldr	r7, [r0, r7]
   1efda:	46bf      	mov	pc, r7
   1efdc:	465b      	mov	r3, fp
   1efde:	431f      	orrs	r7, r3
   1efe0:	d000      	beq.n	1efe4 <__aeabi_dmul+0xa0>
   1efe2:	e088      	b.n	1f0f6 <__aeabi_dmul+0x1b2>
   1efe4:	2300      	movs	r3, #0
   1efe6:	469b      	mov	fp, r3
   1efe8:	4698      	mov	r8, r3
   1efea:	3302      	adds	r3, #2
   1efec:	2708      	movs	r7, #8
   1efee:	9301      	str	r3, [sp, #4]
   1eff0:	e7ce      	b.n	1ef90 <__aeabi_dmul+0x4c>
   1eff2:	4649      	mov	r1, r9
   1eff4:	2a02      	cmp	r2, #2
   1eff6:	d06a      	beq.n	1f0ce <__aeabi_dmul+0x18a>
   1eff8:	2a03      	cmp	r2, #3
   1effa:	d100      	bne.n	1effe <__aeabi_dmul+0xba>
   1effc:	e209      	b.n	1f412 <__aeabi_dmul+0x4ce>
   1effe:	2a01      	cmp	r2, #1
   1f000:	d000      	beq.n	1f004 <__aeabi_dmul+0xc0>
   1f002:	e1bb      	b.n	1f37c <__aeabi_dmul+0x438>
   1f004:	4011      	ands	r1, r2
   1f006:	2200      	movs	r2, #0
   1f008:	2300      	movs	r3, #0
   1f00a:	2500      	movs	r5, #0
   1f00c:	4690      	mov	r8, r2
   1f00e:	b2cc      	uxtb	r4, r1
   1f010:	2100      	movs	r1, #0
   1f012:	032d      	lsls	r5, r5, #12
   1f014:	0d0a      	lsrs	r2, r1, #20
   1f016:	0512      	lsls	r2, r2, #20
   1f018:	0b2d      	lsrs	r5, r5, #12
   1f01a:	4315      	orrs	r5, r2
   1f01c:	4a43      	ldr	r2, [pc, #268]	; (1f12c <__aeabi_dmul+0x1e8>)
   1f01e:	051b      	lsls	r3, r3, #20
   1f020:	4015      	ands	r5, r2
   1f022:	431d      	orrs	r5, r3
   1f024:	006d      	lsls	r5, r5, #1
   1f026:	07e4      	lsls	r4, r4, #31
   1f028:	086d      	lsrs	r5, r5, #1
   1f02a:	4325      	orrs	r5, r4
   1f02c:	4640      	mov	r0, r8
   1f02e:	0029      	movs	r1, r5
   1f030:	b007      	add	sp, #28
   1f032:	bc3c      	pop	{r2, r3, r4, r5}
   1f034:	4690      	mov	r8, r2
   1f036:	4699      	mov	r9, r3
   1f038:	46a2      	mov	sl, r4
   1f03a:	46ab      	mov	fp, r5
   1f03c:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1f03e:	4303      	orrs	r3, r0
   1f040:	d052      	beq.n	1f0e8 <__aeabi_dmul+0x1a4>
   1f042:	465b      	mov	r3, fp
   1f044:	2b00      	cmp	r3, #0
   1f046:	d100      	bne.n	1f04a <__aeabi_dmul+0x106>
   1f048:	e18a      	b.n	1f360 <__aeabi_dmul+0x41c>
   1f04a:	4658      	mov	r0, fp
   1f04c:	f7fe fee0 	bl	1de10 <__clzsi2>
   1f050:	0003      	movs	r3, r0
   1f052:	3b0b      	subs	r3, #11
   1f054:	2b1c      	cmp	r3, #28
   1f056:	dd00      	ble.n	1f05a <__aeabi_dmul+0x116>
   1f058:	e17b      	b.n	1f352 <__aeabi_dmul+0x40e>
   1f05a:	221d      	movs	r2, #29
   1f05c:	1ad3      	subs	r3, r2, r3
   1f05e:	003a      	movs	r2, r7
   1f060:	0001      	movs	r1, r0
   1f062:	465d      	mov	r5, fp
   1f064:	40da      	lsrs	r2, r3
   1f066:	3908      	subs	r1, #8
   1f068:	408d      	lsls	r5, r1
   1f06a:	0013      	movs	r3, r2
   1f06c:	408f      	lsls	r7, r1
   1f06e:	432b      	orrs	r3, r5
   1f070:	469b      	mov	fp, r3
   1f072:	46b8      	mov	r8, r7
   1f074:	4b2e      	ldr	r3, [pc, #184]	; (1f130 <__aeabi_dmul+0x1ec>)
   1f076:	2700      	movs	r7, #0
   1f078:	469c      	mov	ip, r3
   1f07a:	2300      	movs	r3, #0
   1f07c:	4460      	add	r0, ip
   1f07e:	4246      	negs	r6, r0
   1f080:	9301      	str	r3, [sp, #4]
   1f082:	e785      	b.n	1ef90 <__aeabi_dmul+0x4c>
   1f084:	4652      	mov	r2, sl
   1f086:	432a      	orrs	r2, r5
   1f088:	d12c      	bne.n	1f0e4 <__aeabi_dmul+0x1a0>
   1f08a:	2500      	movs	r5, #0
   1f08c:	2300      	movs	r3, #0
   1f08e:	2202      	movs	r2, #2
   1f090:	e797      	b.n	1efc2 <__aeabi_dmul+0x7e>
   1f092:	4652      	mov	r2, sl
   1f094:	432a      	orrs	r2, r5
   1f096:	d021      	beq.n	1f0dc <__aeabi_dmul+0x198>
   1f098:	2d00      	cmp	r5, #0
   1f09a:	d100      	bne.n	1f09e <__aeabi_dmul+0x15a>
   1f09c:	e154      	b.n	1f348 <__aeabi_dmul+0x404>
   1f09e:	0028      	movs	r0, r5
   1f0a0:	f7fe feb6 	bl	1de10 <__clzsi2>
   1f0a4:	0003      	movs	r3, r0
   1f0a6:	3b0b      	subs	r3, #11
   1f0a8:	2b1c      	cmp	r3, #28
   1f0aa:	dd00      	ble.n	1f0ae <__aeabi_dmul+0x16a>
   1f0ac:	e146      	b.n	1f33c <__aeabi_dmul+0x3f8>
   1f0ae:	211d      	movs	r1, #29
   1f0b0:	1acb      	subs	r3, r1, r3
   1f0b2:	4651      	mov	r1, sl
   1f0b4:	0002      	movs	r2, r0
   1f0b6:	40d9      	lsrs	r1, r3
   1f0b8:	4653      	mov	r3, sl
   1f0ba:	3a08      	subs	r2, #8
   1f0bc:	4095      	lsls	r5, r2
   1f0be:	4093      	lsls	r3, r2
   1f0c0:	430d      	orrs	r5, r1
   1f0c2:	4a1b      	ldr	r2, [pc, #108]	; (1f130 <__aeabi_dmul+0x1ec>)
   1f0c4:	4694      	mov	ip, r2
   1f0c6:	4460      	add	r0, ip
   1f0c8:	4240      	negs	r0, r0
   1f0ca:	2200      	movs	r2, #0
   1f0cc:	e779      	b.n	1efc2 <__aeabi_dmul+0x7e>
   1f0ce:	2401      	movs	r4, #1
   1f0d0:	2200      	movs	r2, #0
   1f0d2:	400c      	ands	r4, r1
   1f0d4:	4b12      	ldr	r3, [pc, #72]	; (1f120 <__aeabi_dmul+0x1dc>)
   1f0d6:	2500      	movs	r5, #0
   1f0d8:	4690      	mov	r8, r2
   1f0da:	e799      	b.n	1f010 <__aeabi_dmul+0xcc>
   1f0dc:	2500      	movs	r5, #0
   1f0de:	2300      	movs	r3, #0
   1f0e0:	2201      	movs	r2, #1
   1f0e2:	e76e      	b.n	1efc2 <__aeabi_dmul+0x7e>
   1f0e4:	2203      	movs	r2, #3
   1f0e6:	e76c      	b.n	1efc2 <__aeabi_dmul+0x7e>
   1f0e8:	2300      	movs	r3, #0
   1f0ea:	469b      	mov	fp, r3
   1f0ec:	4698      	mov	r8, r3
   1f0ee:	3301      	adds	r3, #1
   1f0f0:	2704      	movs	r7, #4
   1f0f2:	9301      	str	r3, [sp, #4]
   1f0f4:	e74c      	b.n	1ef90 <__aeabi_dmul+0x4c>
   1f0f6:	2303      	movs	r3, #3
   1f0f8:	270c      	movs	r7, #12
   1f0fa:	9301      	str	r3, [sp, #4]
   1f0fc:	e748      	b.n	1ef90 <__aeabi_dmul+0x4c>
   1f0fe:	2300      	movs	r3, #0
   1f100:	2580      	movs	r5, #128	; 0x80
   1f102:	4698      	mov	r8, r3
   1f104:	2400      	movs	r4, #0
   1f106:	032d      	lsls	r5, r5, #12
   1f108:	4b05      	ldr	r3, [pc, #20]	; (1f120 <__aeabi_dmul+0x1dc>)
   1f10a:	e781      	b.n	1f010 <__aeabi_dmul+0xcc>
   1f10c:	465d      	mov	r5, fp
   1f10e:	4643      	mov	r3, r8
   1f110:	9a01      	ldr	r2, [sp, #4]
   1f112:	e76f      	b.n	1eff4 <__aeabi_dmul+0xb0>
   1f114:	465d      	mov	r5, fp
   1f116:	4643      	mov	r3, r8
   1f118:	0021      	movs	r1, r4
   1f11a:	9a01      	ldr	r2, [sp, #4]
   1f11c:	e76a      	b.n	1eff4 <__aeabi_dmul+0xb0>
   1f11e:	46c0      	nop			; (mov r8, r8)
   1f120:	000007ff 	.word	0x000007ff
   1f124:	fffffc01 	.word	0xfffffc01
   1f128:	000234a8 	.word	0x000234a8
   1f12c:	800fffff 	.word	0x800fffff
   1f130:	000003f3 	.word	0x000003f3
   1f134:	4642      	mov	r2, r8
   1f136:	0c12      	lsrs	r2, r2, #16
   1f138:	4691      	mov	r9, r2
   1f13a:	0c1a      	lsrs	r2, r3, #16
   1f13c:	4694      	mov	ip, r2
   1f13e:	4642      	mov	r2, r8
   1f140:	0417      	lsls	r7, r2, #16
   1f142:	464a      	mov	r2, r9
   1f144:	041b      	lsls	r3, r3, #16
   1f146:	0c1b      	lsrs	r3, r3, #16
   1f148:	435a      	muls	r2, r3
   1f14a:	4660      	mov	r0, ip
   1f14c:	4690      	mov	r8, r2
   1f14e:	464a      	mov	r2, r9
   1f150:	4342      	muls	r2, r0
   1f152:	0010      	movs	r0, r2
   1f154:	9203      	str	r2, [sp, #12]
   1f156:	4662      	mov	r2, ip
   1f158:	001c      	movs	r4, r3
   1f15a:	0c3f      	lsrs	r7, r7, #16
   1f15c:	437a      	muls	r2, r7
   1f15e:	437c      	muls	r4, r7
   1f160:	4442      	add	r2, r8
   1f162:	9201      	str	r2, [sp, #4]
   1f164:	0c22      	lsrs	r2, r4, #16
   1f166:	4692      	mov	sl, r2
   1f168:	9a01      	ldr	r2, [sp, #4]
   1f16a:	4452      	add	r2, sl
   1f16c:	4590      	cmp	r8, r2
   1f16e:	d906      	bls.n	1f17e <__aeabi_dmul+0x23a>
   1f170:	4682      	mov	sl, r0
   1f172:	2080      	movs	r0, #128	; 0x80
   1f174:	0240      	lsls	r0, r0, #9
   1f176:	4680      	mov	r8, r0
   1f178:	44c2      	add	sl, r8
   1f17a:	4650      	mov	r0, sl
   1f17c:	9003      	str	r0, [sp, #12]
   1f17e:	0c10      	lsrs	r0, r2, #16
   1f180:	9004      	str	r0, [sp, #16]
   1f182:	4648      	mov	r0, r9
   1f184:	0424      	lsls	r4, r4, #16
   1f186:	0c24      	lsrs	r4, r4, #16
   1f188:	0412      	lsls	r2, r2, #16
   1f18a:	1912      	adds	r2, r2, r4
   1f18c:	9205      	str	r2, [sp, #20]
   1f18e:	0c2a      	lsrs	r2, r5, #16
   1f190:	042d      	lsls	r5, r5, #16
   1f192:	0c2d      	lsrs	r5, r5, #16
   1f194:	4368      	muls	r0, r5
   1f196:	002c      	movs	r4, r5
   1f198:	4682      	mov	sl, r0
   1f19a:	4648      	mov	r0, r9
   1f19c:	437c      	muls	r4, r7
   1f19e:	4350      	muls	r0, r2
   1f1a0:	4681      	mov	r9, r0
   1f1a2:	0c20      	lsrs	r0, r4, #16
   1f1a4:	4680      	mov	r8, r0
   1f1a6:	4357      	muls	r7, r2
   1f1a8:	4457      	add	r7, sl
   1f1aa:	4447      	add	r7, r8
   1f1ac:	45ba      	cmp	sl, r7
   1f1ae:	d903      	bls.n	1f1b8 <__aeabi_dmul+0x274>
   1f1b0:	2080      	movs	r0, #128	; 0x80
   1f1b2:	0240      	lsls	r0, r0, #9
   1f1b4:	4680      	mov	r8, r0
   1f1b6:	44c1      	add	r9, r8
   1f1b8:	0c38      	lsrs	r0, r7, #16
   1f1ba:	043f      	lsls	r7, r7, #16
   1f1bc:	46b8      	mov	r8, r7
   1f1be:	4448      	add	r0, r9
   1f1c0:	0424      	lsls	r4, r4, #16
   1f1c2:	0c24      	lsrs	r4, r4, #16
   1f1c4:	9001      	str	r0, [sp, #4]
   1f1c6:	9804      	ldr	r0, [sp, #16]
   1f1c8:	44a0      	add	r8, r4
   1f1ca:	4440      	add	r0, r8
   1f1cc:	9004      	str	r0, [sp, #16]
   1f1ce:	4658      	mov	r0, fp
   1f1d0:	0c00      	lsrs	r0, r0, #16
   1f1d2:	4681      	mov	r9, r0
   1f1d4:	4658      	mov	r0, fp
   1f1d6:	0404      	lsls	r4, r0, #16
   1f1d8:	0c20      	lsrs	r0, r4, #16
   1f1da:	4682      	mov	sl, r0
   1f1dc:	0007      	movs	r7, r0
   1f1de:	4648      	mov	r0, r9
   1f1e0:	435f      	muls	r7, r3
   1f1e2:	464c      	mov	r4, r9
   1f1e4:	4343      	muls	r3, r0
   1f1e6:	4660      	mov	r0, ip
   1f1e8:	4360      	muls	r0, r4
   1f1ea:	4664      	mov	r4, ip
   1f1ec:	4683      	mov	fp, r0
   1f1ee:	4650      	mov	r0, sl
   1f1f0:	4344      	muls	r4, r0
   1f1f2:	0c38      	lsrs	r0, r7, #16
   1f1f4:	4684      	mov	ip, r0
   1f1f6:	18e4      	adds	r4, r4, r3
   1f1f8:	4464      	add	r4, ip
   1f1fa:	42a3      	cmp	r3, r4
   1f1fc:	d903      	bls.n	1f206 <__aeabi_dmul+0x2c2>
   1f1fe:	2380      	movs	r3, #128	; 0x80
   1f200:	025b      	lsls	r3, r3, #9
   1f202:	469c      	mov	ip, r3
   1f204:	44e3      	add	fp, ip
   1f206:	4648      	mov	r0, r9
   1f208:	043f      	lsls	r7, r7, #16
   1f20a:	0c23      	lsrs	r3, r4, #16
   1f20c:	0c3f      	lsrs	r7, r7, #16
   1f20e:	0424      	lsls	r4, r4, #16
   1f210:	19e4      	adds	r4, r4, r7
   1f212:	4657      	mov	r7, sl
   1f214:	4368      	muls	r0, r5
   1f216:	436f      	muls	r7, r5
   1f218:	4684      	mov	ip, r0
   1f21a:	464d      	mov	r5, r9
   1f21c:	4650      	mov	r0, sl
   1f21e:	4355      	muls	r5, r2
   1f220:	4342      	muls	r2, r0
   1f222:	0c38      	lsrs	r0, r7, #16
   1f224:	4681      	mov	r9, r0
   1f226:	4462      	add	r2, ip
   1f228:	444a      	add	r2, r9
   1f22a:	445b      	add	r3, fp
   1f22c:	4594      	cmp	ip, r2
   1f22e:	d903      	bls.n	1f238 <__aeabi_dmul+0x2f4>
   1f230:	2080      	movs	r0, #128	; 0x80
   1f232:	0240      	lsls	r0, r0, #9
   1f234:	4684      	mov	ip, r0
   1f236:	4465      	add	r5, ip
   1f238:	9803      	ldr	r0, [sp, #12]
   1f23a:	043f      	lsls	r7, r7, #16
   1f23c:	4683      	mov	fp, r0
   1f23e:	9804      	ldr	r0, [sp, #16]
   1f240:	0c3f      	lsrs	r7, r7, #16
   1f242:	4684      	mov	ip, r0
   1f244:	44e3      	add	fp, ip
   1f246:	45c3      	cmp	fp, r8
   1f248:	4180      	sbcs	r0, r0
   1f24a:	4240      	negs	r0, r0
   1f24c:	4682      	mov	sl, r0
   1f24e:	0410      	lsls	r0, r2, #16
   1f250:	4684      	mov	ip, r0
   1f252:	9801      	ldr	r0, [sp, #4]
   1f254:	4467      	add	r7, ip
   1f256:	4684      	mov	ip, r0
   1f258:	4467      	add	r7, ip
   1f25a:	44a3      	add	fp, r4
   1f25c:	46bc      	mov	ip, r7
   1f25e:	45a3      	cmp	fp, r4
   1f260:	41a4      	sbcs	r4, r4
   1f262:	4699      	mov	r9, r3
   1f264:	44d4      	add	ip, sl
   1f266:	4264      	negs	r4, r4
   1f268:	4287      	cmp	r7, r0
   1f26a:	41bf      	sbcs	r7, r7
   1f26c:	45d4      	cmp	ip, sl
   1f26e:	4180      	sbcs	r0, r0
   1f270:	44e1      	add	r9, ip
   1f272:	46a0      	mov	r8, r4
   1f274:	4599      	cmp	r9, r3
   1f276:	419b      	sbcs	r3, r3
   1f278:	427f      	negs	r7, r7
   1f27a:	4240      	negs	r0, r0
   1f27c:	44c8      	add	r8, r9
   1f27e:	4307      	orrs	r7, r0
   1f280:	0c12      	lsrs	r2, r2, #16
   1f282:	18ba      	adds	r2, r7, r2
   1f284:	45a0      	cmp	r8, r4
   1f286:	41a4      	sbcs	r4, r4
   1f288:	425f      	negs	r7, r3
   1f28a:	003b      	movs	r3, r7
   1f28c:	4264      	negs	r4, r4
   1f28e:	4323      	orrs	r3, r4
   1f290:	18d7      	adds	r7, r2, r3
   1f292:	4643      	mov	r3, r8
   1f294:	197d      	adds	r5, r7, r5
   1f296:	0ddb      	lsrs	r3, r3, #23
   1f298:	026d      	lsls	r5, r5, #9
   1f29a:	431d      	orrs	r5, r3
   1f29c:	465b      	mov	r3, fp
   1f29e:	025a      	lsls	r2, r3, #9
   1f2a0:	9b05      	ldr	r3, [sp, #20]
   1f2a2:	431a      	orrs	r2, r3
   1f2a4:	1e53      	subs	r3, r2, #1
   1f2a6:	419a      	sbcs	r2, r3
   1f2a8:	465b      	mov	r3, fp
   1f2aa:	0ddb      	lsrs	r3, r3, #23
   1f2ac:	431a      	orrs	r2, r3
   1f2ae:	4643      	mov	r3, r8
   1f2b0:	025b      	lsls	r3, r3, #9
   1f2b2:	4313      	orrs	r3, r2
   1f2b4:	01ea      	lsls	r2, r5, #7
   1f2b6:	d507      	bpl.n	1f2c8 <__aeabi_dmul+0x384>
   1f2b8:	2201      	movs	r2, #1
   1f2ba:	085c      	lsrs	r4, r3, #1
   1f2bc:	4013      	ands	r3, r2
   1f2be:	4323      	orrs	r3, r4
   1f2c0:	07ea      	lsls	r2, r5, #31
   1f2c2:	9e02      	ldr	r6, [sp, #8]
   1f2c4:	4313      	orrs	r3, r2
   1f2c6:	086d      	lsrs	r5, r5, #1
   1f2c8:	4a57      	ldr	r2, [pc, #348]	; (1f428 <__aeabi_dmul+0x4e4>)
   1f2ca:	18b2      	adds	r2, r6, r2
   1f2cc:	2a00      	cmp	r2, #0
   1f2ce:	dd4b      	ble.n	1f368 <__aeabi_dmul+0x424>
   1f2d0:	0758      	lsls	r0, r3, #29
   1f2d2:	d009      	beq.n	1f2e8 <__aeabi_dmul+0x3a4>
   1f2d4:	200f      	movs	r0, #15
   1f2d6:	4018      	ands	r0, r3
   1f2d8:	2804      	cmp	r0, #4
   1f2da:	d005      	beq.n	1f2e8 <__aeabi_dmul+0x3a4>
   1f2dc:	1d18      	adds	r0, r3, #4
   1f2de:	4298      	cmp	r0, r3
   1f2e0:	419b      	sbcs	r3, r3
   1f2e2:	425b      	negs	r3, r3
   1f2e4:	18ed      	adds	r5, r5, r3
   1f2e6:	0003      	movs	r3, r0
   1f2e8:	01e8      	lsls	r0, r5, #7
   1f2ea:	d504      	bpl.n	1f2f6 <__aeabi_dmul+0x3b2>
   1f2ec:	4a4f      	ldr	r2, [pc, #316]	; (1f42c <__aeabi_dmul+0x4e8>)
   1f2ee:	4015      	ands	r5, r2
   1f2f0:	2280      	movs	r2, #128	; 0x80
   1f2f2:	00d2      	lsls	r2, r2, #3
   1f2f4:	18b2      	adds	r2, r6, r2
   1f2f6:	484e      	ldr	r0, [pc, #312]	; (1f430 <__aeabi_dmul+0x4ec>)
   1f2f8:	4282      	cmp	r2, r0
   1f2fa:	dd00      	ble.n	1f2fe <__aeabi_dmul+0x3ba>
   1f2fc:	e6e7      	b.n	1f0ce <__aeabi_dmul+0x18a>
   1f2fe:	2401      	movs	r4, #1
   1f300:	08db      	lsrs	r3, r3, #3
   1f302:	0768      	lsls	r0, r5, #29
   1f304:	4318      	orrs	r0, r3
   1f306:	026d      	lsls	r5, r5, #9
   1f308:	0553      	lsls	r3, r2, #21
   1f30a:	4680      	mov	r8, r0
   1f30c:	0b2d      	lsrs	r5, r5, #12
   1f30e:	0d5b      	lsrs	r3, r3, #21
   1f310:	400c      	ands	r4, r1
   1f312:	e67d      	b.n	1f010 <__aeabi_dmul+0xcc>
   1f314:	2280      	movs	r2, #128	; 0x80
   1f316:	4659      	mov	r1, fp
   1f318:	0312      	lsls	r2, r2, #12
   1f31a:	4211      	tst	r1, r2
   1f31c:	d008      	beq.n	1f330 <__aeabi_dmul+0x3ec>
   1f31e:	4215      	tst	r5, r2
   1f320:	d106      	bne.n	1f330 <__aeabi_dmul+0x3ec>
   1f322:	4315      	orrs	r5, r2
   1f324:	032d      	lsls	r5, r5, #12
   1f326:	4698      	mov	r8, r3
   1f328:	0b2d      	lsrs	r5, r5, #12
   1f32a:	464c      	mov	r4, r9
   1f32c:	4b41      	ldr	r3, [pc, #260]	; (1f434 <__aeabi_dmul+0x4f0>)
   1f32e:	e66f      	b.n	1f010 <__aeabi_dmul+0xcc>
   1f330:	465d      	mov	r5, fp
   1f332:	4315      	orrs	r5, r2
   1f334:	032d      	lsls	r5, r5, #12
   1f336:	0b2d      	lsrs	r5, r5, #12
   1f338:	4b3e      	ldr	r3, [pc, #248]	; (1f434 <__aeabi_dmul+0x4f0>)
   1f33a:	e669      	b.n	1f010 <__aeabi_dmul+0xcc>
   1f33c:	0003      	movs	r3, r0
   1f33e:	4655      	mov	r5, sl
   1f340:	3b28      	subs	r3, #40	; 0x28
   1f342:	409d      	lsls	r5, r3
   1f344:	2300      	movs	r3, #0
   1f346:	e6bc      	b.n	1f0c2 <__aeabi_dmul+0x17e>
   1f348:	4650      	mov	r0, sl
   1f34a:	f7fe fd61 	bl	1de10 <__clzsi2>
   1f34e:	3020      	adds	r0, #32
   1f350:	e6a8      	b.n	1f0a4 <__aeabi_dmul+0x160>
   1f352:	0003      	movs	r3, r0
   1f354:	3b28      	subs	r3, #40	; 0x28
   1f356:	409f      	lsls	r7, r3
   1f358:	2300      	movs	r3, #0
   1f35a:	46bb      	mov	fp, r7
   1f35c:	4698      	mov	r8, r3
   1f35e:	e689      	b.n	1f074 <__aeabi_dmul+0x130>
   1f360:	f7fe fd56 	bl	1de10 <__clzsi2>
   1f364:	3020      	adds	r0, #32
   1f366:	e673      	b.n	1f050 <__aeabi_dmul+0x10c>
   1f368:	2401      	movs	r4, #1
   1f36a:	1aa6      	subs	r6, r4, r2
   1f36c:	2e38      	cmp	r6, #56	; 0x38
   1f36e:	dd07      	ble.n	1f380 <__aeabi_dmul+0x43c>
   1f370:	2200      	movs	r2, #0
   1f372:	400c      	ands	r4, r1
   1f374:	2300      	movs	r3, #0
   1f376:	2500      	movs	r5, #0
   1f378:	4690      	mov	r8, r2
   1f37a:	e649      	b.n	1f010 <__aeabi_dmul+0xcc>
   1f37c:	9e02      	ldr	r6, [sp, #8]
   1f37e:	e7a3      	b.n	1f2c8 <__aeabi_dmul+0x384>
   1f380:	2e1f      	cmp	r6, #31
   1f382:	dc20      	bgt.n	1f3c6 <__aeabi_dmul+0x482>
   1f384:	2220      	movs	r2, #32
   1f386:	002c      	movs	r4, r5
   1f388:	0018      	movs	r0, r3
   1f38a:	1b92      	subs	r2, r2, r6
   1f38c:	40f0      	lsrs	r0, r6
   1f38e:	4094      	lsls	r4, r2
   1f390:	4093      	lsls	r3, r2
   1f392:	4304      	orrs	r4, r0
   1f394:	1e58      	subs	r0, r3, #1
   1f396:	4183      	sbcs	r3, r0
   1f398:	431c      	orrs	r4, r3
   1f39a:	40f5      	lsrs	r5, r6
   1f39c:	0763      	lsls	r3, r4, #29
   1f39e:	d009      	beq.n	1f3b4 <__aeabi_dmul+0x470>
   1f3a0:	230f      	movs	r3, #15
   1f3a2:	4023      	ands	r3, r4
   1f3a4:	2b04      	cmp	r3, #4
   1f3a6:	d005      	beq.n	1f3b4 <__aeabi_dmul+0x470>
   1f3a8:	0023      	movs	r3, r4
   1f3aa:	1d1c      	adds	r4, r3, #4
   1f3ac:	429c      	cmp	r4, r3
   1f3ae:	4192      	sbcs	r2, r2
   1f3b0:	4252      	negs	r2, r2
   1f3b2:	18ad      	adds	r5, r5, r2
   1f3b4:	022b      	lsls	r3, r5, #8
   1f3b6:	d51f      	bpl.n	1f3f8 <__aeabi_dmul+0x4b4>
   1f3b8:	2401      	movs	r4, #1
   1f3ba:	2200      	movs	r2, #0
   1f3bc:	400c      	ands	r4, r1
   1f3be:	2301      	movs	r3, #1
   1f3c0:	2500      	movs	r5, #0
   1f3c2:	4690      	mov	r8, r2
   1f3c4:	e624      	b.n	1f010 <__aeabi_dmul+0xcc>
   1f3c6:	201f      	movs	r0, #31
   1f3c8:	002c      	movs	r4, r5
   1f3ca:	4240      	negs	r0, r0
   1f3cc:	1a82      	subs	r2, r0, r2
   1f3ce:	40d4      	lsrs	r4, r2
   1f3d0:	2e20      	cmp	r6, #32
   1f3d2:	d01c      	beq.n	1f40e <__aeabi_dmul+0x4ca>
   1f3d4:	2240      	movs	r2, #64	; 0x40
   1f3d6:	1b96      	subs	r6, r2, r6
   1f3d8:	40b5      	lsls	r5, r6
   1f3da:	432b      	orrs	r3, r5
   1f3dc:	1e58      	subs	r0, r3, #1
   1f3de:	4183      	sbcs	r3, r0
   1f3e0:	2007      	movs	r0, #7
   1f3e2:	4323      	orrs	r3, r4
   1f3e4:	4018      	ands	r0, r3
   1f3e6:	2500      	movs	r5, #0
   1f3e8:	2800      	cmp	r0, #0
   1f3ea:	d009      	beq.n	1f400 <__aeabi_dmul+0x4bc>
   1f3ec:	220f      	movs	r2, #15
   1f3ee:	2500      	movs	r5, #0
   1f3f0:	401a      	ands	r2, r3
   1f3f2:	001c      	movs	r4, r3
   1f3f4:	2a04      	cmp	r2, #4
   1f3f6:	d1d8      	bne.n	1f3aa <__aeabi_dmul+0x466>
   1f3f8:	0023      	movs	r3, r4
   1f3fa:	0768      	lsls	r0, r5, #29
   1f3fc:	026d      	lsls	r5, r5, #9
   1f3fe:	0b2d      	lsrs	r5, r5, #12
   1f400:	2401      	movs	r4, #1
   1f402:	08db      	lsrs	r3, r3, #3
   1f404:	4303      	orrs	r3, r0
   1f406:	4698      	mov	r8, r3
   1f408:	400c      	ands	r4, r1
   1f40a:	2300      	movs	r3, #0
   1f40c:	e600      	b.n	1f010 <__aeabi_dmul+0xcc>
   1f40e:	2500      	movs	r5, #0
   1f410:	e7e3      	b.n	1f3da <__aeabi_dmul+0x496>
   1f412:	2280      	movs	r2, #128	; 0x80
   1f414:	2401      	movs	r4, #1
   1f416:	0312      	lsls	r2, r2, #12
   1f418:	4315      	orrs	r5, r2
   1f41a:	032d      	lsls	r5, r5, #12
   1f41c:	4698      	mov	r8, r3
   1f41e:	0b2d      	lsrs	r5, r5, #12
   1f420:	400c      	ands	r4, r1
   1f422:	4b04      	ldr	r3, [pc, #16]	; (1f434 <__aeabi_dmul+0x4f0>)
   1f424:	e5f4      	b.n	1f010 <__aeabi_dmul+0xcc>
   1f426:	46c0      	nop			; (mov r8, r8)
   1f428:	000003ff 	.word	0x000003ff
   1f42c:	feffffff 	.word	0xfeffffff
   1f430:	000007fe 	.word	0x000007fe
   1f434:	000007ff 	.word	0x000007ff

0001f438 <__aeabi_dsub>:
   1f438:	b5f0      	push	{r4, r5, r6, r7, lr}
   1f43a:	4657      	mov	r7, sl
   1f43c:	464e      	mov	r6, r9
   1f43e:	4645      	mov	r5, r8
   1f440:	b4e0      	push	{r5, r6, r7}
   1f442:	000e      	movs	r6, r1
   1f444:	0011      	movs	r1, r2
   1f446:	0ff2      	lsrs	r2, r6, #31
   1f448:	4692      	mov	sl, r2
   1f44a:	00c5      	lsls	r5, r0, #3
   1f44c:	0f42      	lsrs	r2, r0, #29
   1f44e:	0318      	lsls	r0, r3, #12
   1f450:	0337      	lsls	r7, r6, #12
   1f452:	0074      	lsls	r4, r6, #1
   1f454:	0a40      	lsrs	r0, r0, #9
   1f456:	0f4e      	lsrs	r6, r1, #29
   1f458:	0a7f      	lsrs	r7, r7, #9
   1f45a:	4330      	orrs	r0, r6
   1f45c:	4ecf      	ldr	r6, [pc, #828]	; (1f79c <__aeabi_dsub+0x364>)
   1f45e:	4317      	orrs	r7, r2
   1f460:	005a      	lsls	r2, r3, #1
   1f462:	0d64      	lsrs	r4, r4, #21
   1f464:	0d52      	lsrs	r2, r2, #21
   1f466:	0fdb      	lsrs	r3, r3, #31
   1f468:	00c9      	lsls	r1, r1, #3
   1f46a:	42b2      	cmp	r2, r6
   1f46c:	d100      	bne.n	1f470 <__aeabi_dsub+0x38>
   1f46e:	e0e5      	b.n	1f63c <__aeabi_dsub+0x204>
   1f470:	2601      	movs	r6, #1
   1f472:	4073      	eors	r3, r6
   1f474:	1aa6      	subs	r6, r4, r2
   1f476:	46b4      	mov	ip, r6
   1f478:	4553      	cmp	r3, sl
   1f47a:	d100      	bne.n	1f47e <__aeabi_dsub+0x46>
   1f47c:	e0af      	b.n	1f5de <__aeabi_dsub+0x1a6>
   1f47e:	2e00      	cmp	r6, #0
   1f480:	dc00      	bgt.n	1f484 <__aeabi_dsub+0x4c>
   1f482:	e10d      	b.n	1f6a0 <__aeabi_dsub+0x268>
   1f484:	2a00      	cmp	r2, #0
   1f486:	d13a      	bne.n	1f4fe <__aeabi_dsub+0xc6>
   1f488:	0003      	movs	r3, r0
   1f48a:	430b      	orrs	r3, r1
   1f48c:	d000      	beq.n	1f490 <__aeabi_dsub+0x58>
   1f48e:	e0e4      	b.n	1f65a <__aeabi_dsub+0x222>
   1f490:	076b      	lsls	r3, r5, #29
   1f492:	d009      	beq.n	1f4a8 <__aeabi_dsub+0x70>
   1f494:	230f      	movs	r3, #15
   1f496:	402b      	ands	r3, r5
   1f498:	2b04      	cmp	r3, #4
   1f49a:	d005      	beq.n	1f4a8 <__aeabi_dsub+0x70>
   1f49c:	1d2b      	adds	r3, r5, #4
   1f49e:	42ab      	cmp	r3, r5
   1f4a0:	41ad      	sbcs	r5, r5
   1f4a2:	426d      	negs	r5, r5
   1f4a4:	197f      	adds	r7, r7, r5
   1f4a6:	001d      	movs	r5, r3
   1f4a8:	023b      	lsls	r3, r7, #8
   1f4aa:	d400      	bmi.n	1f4ae <__aeabi_dsub+0x76>
   1f4ac:	e088      	b.n	1f5c0 <__aeabi_dsub+0x188>
   1f4ae:	4bbb      	ldr	r3, [pc, #748]	; (1f79c <__aeabi_dsub+0x364>)
   1f4b0:	3401      	adds	r4, #1
   1f4b2:	429c      	cmp	r4, r3
   1f4b4:	d100      	bne.n	1f4b8 <__aeabi_dsub+0x80>
   1f4b6:	e110      	b.n	1f6da <__aeabi_dsub+0x2a2>
   1f4b8:	003a      	movs	r2, r7
   1f4ba:	4bb9      	ldr	r3, [pc, #740]	; (1f7a0 <__aeabi_dsub+0x368>)
   1f4bc:	4651      	mov	r1, sl
   1f4be:	401a      	ands	r2, r3
   1f4c0:	2301      	movs	r3, #1
   1f4c2:	0750      	lsls	r0, r2, #29
   1f4c4:	08ed      	lsrs	r5, r5, #3
   1f4c6:	0252      	lsls	r2, r2, #9
   1f4c8:	0564      	lsls	r4, r4, #21
   1f4ca:	4305      	orrs	r5, r0
   1f4cc:	0b12      	lsrs	r2, r2, #12
   1f4ce:	0d64      	lsrs	r4, r4, #21
   1f4d0:	400b      	ands	r3, r1
   1f4d2:	2100      	movs	r1, #0
   1f4d4:	0028      	movs	r0, r5
   1f4d6:	0312      	lsls	r2, r2, #12
   1f4d8:	0d0d      	lsrs	r5, r1, #20
   1f4da:	0b12      	lsrs	r2, r2, #12
   1f4dc:	0564      	lsls	r4, r4, #21
   1f4de:	052d      	lsls	r5, r5, #20
   1f4e0:	4315      	orrs	r5, r2
   1f4e2:	0862      	lsrs	r2, r4, #1
   1f4e4:	4caf      	ldr	r4, [pc, #700]	; (1f7a4 <__aeabi_dsub+0x36c>)
   1f4e6:	07db      	lsls	r3, r3, #31
   1f4e8:	402c      	ands	r4, r5
   1f4ea:	4314      	orrs	r4, r2
   1f4ec:	0064      	lsls	r4, r4, #1
   1f4ee:	0864      	lsrs	r4, r4, #1
   1f4f0:	431c      	orrs	r4, r3
   1f4f2:	0021      	movs	r1, r4
   1f4f4:	bc1c      	pop	{r2, r3, r4}
   1f4f6:	4690      	mov	r8, r2
   1f4f8:	4699      	mov	r9, r3
   1f4fa:	46a2      	mov	sl, r4
   1f4fc:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1f4fe:	4ba7      	ldr	r3, [pc, #668]	; (1f79c <__aeabi_dsub+0x364>)
   1f500:	429c      	cmp	r4, r3
   1f502:	d0c5      	beq.n	1f490 <__aeabi_dsub+0x58>
   1f504:	2380      	movs	r3, #128	; 0x80
   1f506:	041b      	lsls	r3, r3, #16
   1f508:	4318      	orrs	r0, r3
   1f50a:	4663      	mov	r3, ip
   1f50c:	2b38      	cmp	r3, #56	; 0x38
   1f50e:	dd00      	ble.n	1f512 <__aeabi_dsub+0xda>
   1f510:	e0fd      	b.n	1f70e <__aeabi_dsub+0x2d6>
   1f512:	2b1f      	cmp	r3, #31
   1f514:	dd00      	ble.n	1f518 <__aeabi_dsub+0xe0>
   1f516:	e130      	b.n	1f77a <__aeabi_dsub+0x342>
   1f518:	4662      	mov	r2, ip
   1f51a:	2320      	movs	r3, #32
   1f51c:	1a9b      	subs	r3, r3, r2
   1f51e:	0002      	movs	r2, r0
   1f520:	409a      	lsls	r2, r3
   1f522:	4666      	mov	r6, ip
   1f524:	4690      	mov	r8, r2
   1f526:	000a      	movs	r2, r1
   1f528:	4099      	lsls	r1, r3
   1f52a:	40f2      	lsrs	r2, r6
   1f52c:	4646      	mov	r6, r8
   1f52e:	1e4b      	subs	r3, r1, #1
   1f530:	4199      	sbcs	r1, r3
   1f532:	4332      	orrs	r2, r6
   1f534:	4311      	orrs	r1, r2
   1f536:	4663      	mov	r3, ip
   1f538:	0002      	movs	r2, r0
   1f53a:	40da      	lsrs	r2, r3
   1f53c:	1a69      	subs	r1, r5, r1
   1f53e:	428d      	cmp	r5, r1
   1f540:	419b      	sbcs	r3, r3
   1f542:	000d      	movs	r5, r1
   1f544:	1aba      	subs	r2, r7, r2
   1f546:	425b      	negs	r3, r3
   1f548:	1ad7      	subs	r7, r2, r3
   1f54a:	023b      	lsls	r3, r7, #8
   1f54c:	d535      	bpl.n	1f5ba <__aeabi_dsub+0x182>
   1f54e:	027a      	lsls	r2, r7, #9
   1f550:	0a53      	lsrs	r3, r2, #9
   1f552:	4698      	mov	r8, r3
   1f554:	4643      	mov	r3, r8
   1f556:	2b00      	cmp	r3, #0
   1f558:	d100      	bne.n	1f55c <__aeabi_dsub+0x124>
   1f55a:	e0c4      	b.n	1f6e6 <__aeabi_dsub+0x2ae>
   1f55c:	4640      	mov	r0, r8
   1f55e:	f7fe fc57 	bl	1de10 <__clzsi2>
   1f562:	0003      	movs	r3, r0
   1f564:	3b08      	subs	r3, #8
   1f566:	2b1f      	cmp	r3, #31
   1f568:	dd00      	ble.n	1f56c <__aeabi_dsub+0x134>
   1f56a:	e0c5      	b.n	1f6f8 <__aeabi_dsub+0x2c0>
   1f56c:	2220      	movs	r2, #32
   1f56e:	0029      	movs	r1, r5
   1f570:	1ad2      	subs	r2, r2, r3
   1f572:	4647      	mov	r7, r8
   1f574:	40d1      	lsrs	r1, r2
   1f576:	409f      	lsls	r7, r3
   1f578:	000a      	movs	r2, r1
   1f57a:	409d      	lsls	r5, r3
   1f57c:	433a      	orrs	r2, r7
   1f57e:	429c      	cmp	r4, r3
   1f580:	dd00      	ble.n	1f584 <__aeabi_dsub+0x14c>
   1f582:	e0c0      	b.n	1f706 <__aeabi_dsub+0x2ce>
   1f584:	1b1c      	subs	r4, r3, r4
   1f586:	1c63      	adds	r3, r4, #1
   1f588:	2b1f      	cmp	r3, #31
   1f58a:	dd00      	ble.n	1f58e <__aeabi_dsub+0x156>
   1f58c:	e0e4      	b.n	1f758 <__aeabi_dsub+0x320>
   1f58e:	2120      	movs	r1, #32
   1f590:	0014      	movs	r4, r2
   1f592:	0028      	movs	r0, r5
   1f594:	1ac9      	subs	r1, r1, r3
   1f596:	40d8      	lsrs	r0, r3
   1f598:	408c      	lsls	r4, r1
   1f59a:	408d      	lsls	r5, r1
   1f59c:	4304      	orrs	r4, r0
   1f59e:	40da      	lsrs	r2, r3
   1f5a0:	1e68      	subs	r0, r5, #1
   1f5a2:	4185      	sbcs	r5, r0
   1f5a4:	0017      	movs	r7, r2
   1f5a6:	4325      	orrs	r5, r4
   1f5a8:	2400      	movs	r4, #0
   1f5aa:	e771      	b.n	1f490 <__aeabi_dsub+0x58>
   1f5ac:	4642      	mov	r2, r8
   1f5ae:	4663      	mov	r3, ip
   1f5b0:	431a      	orrs	r2, r3
   1f5b2:	d100      	bne.n	1f5b6 <__aeabi_dsub+0x17e>
   1f5b4:	e24c      	b.n	1fa50 <__aeabi_dsub+0x618>
   1f5b6:	4667      	mov	r7, ip
   1f5b8:	4645      	mov	r5, r8
   1f5ba:	076b      	lsls	r3, r5, #29
   1f5bc:	d000      	beq.n	1f5c0 <__aeabi_dsub+0x188>
   1f5be:	e769      	b.n	1f494 <__aeabi_dsub+0x5c>
   1f5c0:	2301      	movs	r3, #1
   1f5c2:	4651      	mov	r1, sl
   1f5c4:	0778      	lsls	r0, r7, #29
   1f5c6:	08ed      	lsrs	r5, r5, #3
   1f5c8:	08fa      	lsrs	r2, r7, #3
   1f5ca:	400b      	ands	r3, r1
   1f5cc:	4305      	orrs	r5, r0
   1f5ce:	4973      	ldr	r1, [pc, #460]	; (1f79c <__aeabi_dsub+0x364>)
   1f5d0:	428c      	cmp	r4, r1
   1f5d2:	d038      	beq.n	1f646 <__aeabi_dsub+0x20e>
   1f5d4:	0312      	lsls	r2, r2, #12
   1f5d6:	0564      	lsls	r4, r4, #21
   1f5d8:	0b12      	lsrs	r2, r2, #12
   1f5da:	0d64      	lsrs	r4, r4, #21
   1f5dc:	e779      	b.n	1f4d2 <__aeabi_dsub+0x9a>
   1f5de:	2e00      	cmp	r6, #0
   1f5e0:	dc00      	bgt.n	1f5e4 <__aeabi_dsub+0x1ac>
   1f5e2:	e09a      	b.n	1f71a <__aeabi_dsub+0x2e2>
   1f5e4:	2a00      	cmp	r2, #0
   1f5e6:	d047      	beq.n	1f678 <__aeabi_dsub+0x240>
   1f5e8:	4a6c      	ldr	r2, [pc, #432]	; (1f79c <__aeabi_dsub+0x364>)
   1f5ea:	4294      	cmp	r4, r2
   1f5ec:	d100      	bne.n	1f5f0 <__aeabi_dsub+0x1b8>
   1f5ee:	e74f      	b.n	1f490 <__aeabi_dsub+0x58>
   1f5f0:	2280      	movs	r2, #128	; 0x80
   1f5f2:	0412      	lsls	r2, r2, #16
   1f5f4:	4310      	orrs	r0, r2
   1f5f6:	4662      	mov	r2, ip
   1f5f8:	2a38      	cmp	r2, #56	; 0x38
   1f5fa:	dc00      	bgt.n	1f5fe <__aeabi_dsub+0x1c6>
   1f5fc:	e108      	b.n	1f810 <__aeabi_dsub+0x3d8>
   1f5fe:	4301      	orrs	r1, r0
   1f600:	1e48      	subs	r0, r1, #1
   1f602:	4181      	sbcs	r1, r0
   1f604:	2200      	movs	r2, #0
   1f606:	b2c9      	uxtb	r1, r1
   1f608:	1949      	adds	r1, r1, r5
   1f60a:	19d2      	adds	r2, r2, r7
   1f60c:	42a9      	cmp	r1, r5
   1f60e:	41bf      	sbcs	r7, r7
   1f610:	000d      	movs	r5, r1
   1f612:	427f      	negs	r7, r7
   1f614:	18bf      	adds	r7, r7, r2
   1f616:	023a      	lsls	r2, r7, #8
   1f618:	d400      	bmi.n	1f61c <__aeabi_dsub+0x1e4>
   1f61a:	e142      	b.n	1f8a2 <__aeabi_dsub+0x46a>
   1f61c:	4a5f      	ldr	r2, [pc, #380]	; (1f79c <__aeabi_dsub+0x364>)
   1f61e:	3401      	adds	r4, #1
   1f620:	4294      	cmp	r4, r2
   1f622:	d100      	bne.n	1f626 <__aeabi_dsub+0x1ee>
   1f624:	e14e      	b.n	1f8c4 <__aeabi_dsub+0x48c>
   1f626:	2001      	movs	r0, #1
   1f628:	4a5d      	ldr	r2, [pc, #372]	; (1f7a0 <__aeabi_dsub+0x368>)
   1f62a:	0869      	lsrs	r1, r5, #1
   1f62c:	403a      	ands	r2, r7
   1f62e:	4028      	ands	r0, r5
   1f630:	4308      	orrs	r0, r1
   1f632:	07d5      	lsls	r5, r2, #31
   1f634:	4305      	orrs	r5, r0
   1f636:	0857      	lsrs	r7, r2, #1
   1f638:	469a      	mov	sl, r3
   1f63a:	e729      	b.n	1f490 <__aeabi_dsub+0x58>
   1f63c:	0006      	movs	r6, r0
   1f63e:	430e      	orrs	r6, r1
   1f640:	d000      	beq.n	1f644 <__aeabi_dsub+0x20c>
   1f642:	e717      	b.n	1f474 <__aeabi_dsub+0x3c>
   1f644:	e714      	b.n	1f470 <__aeabi_dsub+0x38>
   1f646:	0029      	movs	r1, r5
   1f648:	4311      	orrs	r1, r2
   1f64a:	d100      	bne.n	1f64e <__aeabi_dsub+0x216>
   1f64c:	e1f9      	b.n	1fa42 <__aeabi_dsub+0x60a>
   1f64e:	2180      	movs	r1, #128	; 0x80
   1f650:	0309      	lsls	r1, r1, #12
   1f652:	430a      	orrs	r2, r1
   1f654:	0312      	lsls	r2, r2, #12
   1f656:	0b12      	lsrs	r2, r2, #12
   1f658:	e73b      	b.n	1f4d2 <__aeabi_dsub+0x9a>
   1f65a:	2301      	movs	r3, #1
   1f65c:	425b      	negs	r3, r3
   1f65e:	4698      	mov	r8, r3
   1f660:	44c4      	add	ip, r8
   1f662:	4663      	mov	r3, ip
   1f664:	2b00      	cmp	r3, #0
   1f666:	d172      	bne.n	1f74e <__aeabi_dsub+0x316>
   1f668:	1a69      	subs	r1, r5, r1
   1f66a:	428d      	cmp	r5, r1
   1f66c:	419b      	sbcs	r3, r3
   1f66e:	1a3f      	subs	r7, r7, r0
   1f670:	425b      	negs	r3, r3
   1f672:	1aff      	subs	r7, r7, r3
   1f674:	000d      	movs	r5, r1
   1f676:	e768      	b.n	1f54a <__aeabi_dsub+0x112>
   1f678:	0002      	movs	r2, r0
   1f67a:	430a      	orrs	r2, r1
   1f67c:	d100      	bne.n	1f680 <__aeabi_dsub+0x248>
   1f67e:	e707      	b.n	1f490 <__aeabi_dsub+0x58>
   1f680:	2201      	movs	r2, #1
   1f682:	4252      	negs	r2, r2
   1f684:	4690      	mov	r8, r2
   1f686:	44c4      	add	ip, r8
   1f688:	4662      	mov	r2, ip
   1f68a:	2a00      	cmp	r2, #0
   1f68c:	d000      	beq.n	1f690 <__aeabi_dsub+0x258>
   1f68e:	e0e6      	b.n	1f85e <__aeabi_dsub+0x426>
   1f690:	1869      	adds	r1, r5, r1
   1f692:	42a9      	cmp	r1, r5
   1f694:	41b6      	sbcs	r6, r6
   1f696:	183f      	adds	r7, r7, r0
   1f698:	4276      	negs	r6, r6
   1f69a:	19f7      	adds	r7, r6, r7
   1f69c:	000d      	movs	r5, r1
   1f69e:	e7ba      	b.n	1f616 <__aeabi_dsub+0x1de>
   1f6a0:	2e00      	cmp	r6, #0
   1f6a2:	d000      	beq.n	1f6a6 <__aeabi_dsub+0x26e>
   1f6a4:	e080      	b.n	1f7a8 <__aeabi_dsub+0x370>
   1f6a6:	1c62      	adds	r2, r4, #1
   1f6a8:	0552      	lsls	r2, r2, #21
   1f6aa:	0d52      	lsrs	r2, r2, #21
   1f6ac:	2a01      	cmp	r2, #1
   1f6ae:	dc00      	bgt.n	1f6b2 <__aeabi_dsub+0x27a>
   1f6b0:	e0f9      	b.n	1f8a6 <__aeabi_dsub+0x46e>
   1f6b2:	1a6a      	subs	r2, r5, r1
   1f6b4:	4691      	mov	r9, r2
   1f6b6:	454d      	cmp	r5, r9
   1f6b8:	41b6      	sbcs	r6, r6
   1f6ba:	1a3a      	subs	r2, r7, r0
   1f6bc:	4276      	negs	r6, r6
   1f6be:	1b92      	subs	r2, r2, r6
   1f6c0:	4690      	mov	r8, r2
   1f6c2:	0212      	lsls	r2, r2, #8
   1f6c4:	d400      	bmi.n	1f6c8 <__aeabi_dsub+0x290>
   1f6c6:	e099      	b.n	1f7fc <__aeabi_dsub+0x3c4>
   1f6c8:	1b4d      	subs	r5, r1, r5
   1f6ca:	42a9      	cmp	r1, r5
   1f6cc:	4189      	sbcs	r1, r1
   1f6ce:	1bc7      	subs	r7, r0, r7
   1f6d0:	4249      	negs	r1, r1
   1f6d2:	1a7a      	subs	r2, r7, r1
   1f6d4:	4690      	mov	r8, r2
   1f6d6:	469a      	mov	sl, r3
   1f6d8:	e73c      	b.n	1f554 <__aeabi_dsub+0x11c>
   1f6da:	4652      	mov	r2, sl
   1f6dc:	2301      	movs	r3, #1
   1f6de:	2500      	movs	r5, #0
   1f6e0:	4013      	ands	r3, r2
   1f6e2:	2200      	movs	r2, #0
   1f6e4:	e6f5      	b.n	1f4d2 <__aeabi_dsub+0x9a>
   1f6e6:	0028      	movs	r0, r5
   1f6e8:	f7fe fb92 	bl	1de10 <__clzsi2>
   1f6ec:	3020      	adds	r0, #32
   1f6ee:	0003      	movs	r3, r0
   1f6f0:	3b08      	subs	r3, #8
   1f6f2:	2b1f      	cmp	r3, #31
   1f6f4:	dc00      	bgt.n	1f6f8 <__aeabi_dsub+0x2c0>
   1f6f6:	e739      	b.n	1f56c <__aeabi_dsub+0x134>
   1f6f8:	002a      	movs	r2, r5
   1f6fa:	3828      	subs	r0, #40	; 0x28
   1f6fc:	4082      	lsls	r2, r0
   1f6fe:	2500      	movs	r5, #0
   1f700:	429c      	cmp	r4, r3
   1f702:	dc00      	bgt.n	1f706 <__aeabi_dsub+0x2ce>
   1f704:	e73e      	b.n	1f584 <__aeabi_dsub+0x14c>
   1f706:	4f26      	ldr	r7, [pc, #152]	; (1f7a0 <__aeabi_dsub+0x368>)
   1f708:	1ae4      	subs	r4, r4, r3
   1f70a:	4017      	ands	r7, r2
   1f70c:	e6c0      	b.n	1f490 <__aeabi_dsub+0x58>
   1f70e:	4301      	orrs	r1, r0
   1f710:	1e48      	subs	r0, r1, #1
   1f712:	4181      	sbcs	r1, r0
   1f714:	2200      	movs	r2, #0
   1f716:	b2c9      	uxtb	r1, r1
   1f718:	e710      	b.n	1f53c <__aeabi_dsub+0x104>
   1f71a:	2e00      	cmp	r6, #0
   1f71c:	d000      	beq.n	1f720 <__aeabi_dsub+0x2e8>
   1f71e:	e0f1      	b.n	1f904 <__aeabi_dsub+0x4cc>
   1f720:	1c62      	adds	r2, r4, #1
   1f722:	4694      	mov	ip, r2
   1f724:	0552      	lsls	r2, r2, #21
   1f726:	0d52      	lsrs	r2, r2, #21
   1f728:	2a01      	cmp	r2, #1
   1f72a:	dc00      	bgt.n	1f72e <__aeabi_dsub+0x2f6>
   1f72c:	e0a0      	b.n	1f870 <__aeabi_dsub+0x438>
   1f72e:	4a1b      	ldr	r2, [pc, #108]	; (1f79c <__aeabi_dsub+0x364>)
   1f730:	4594      	cmp	ip, r2
   1f732:	d100      	bne.n	1f736 <__aeabi_dsub+0x2fe>
   1f734:	e0c5      	b.n	1f8c2 <__aeabi_dsub+0x48a>
   1f736:	1869      	adds	r1, r5, r1
   1f738:	42a9      	cmp	r1, r5
   1f73a:	4192      	sbcs	r2, r2
   1f73c:	183f      	adds	r7, r7, r0
   1f73e:	4252      	negs	r2, r2
   1f740:	19d2      	adds	r2, r2, r7
   1f742:	0849      	lsrs	r1, r1, #1
   1f744:	07d5      	lsls	r5, r2, #31
   1f746:	430d      	orrs	r5, r1
   1f748:	0857      	lsrs	r7, r2, #1
   1f74a:	4664      	mov	r4, ip
   1f74c:	e6a0      	b.n	1f490 <__aeabi_dsub+0x58>
   1f74e:	4b13      	ldr	r3, [pc, #76]	; (1f79c <__aeabi_dsub+0x364>)
   1f750:	429c      	cmp	r4, r3
   1f752:	d000      	beq.n	1f756 <__aeabi_dsub+0x31e>
   1f754:	e6d9      	b.n	1f50a <__aeabi_dsub+0xd2>
   1f756:	e69b      	b.n	1f490 <__aeabi_dsub+0x58>
   1f758:	0011      	movs	r1, r2
   1f75a:	3c1f      	subs	r4, #31
   1f75c:	40e1      	lsrs	r1, r4
   1f75e:	000c      	movs	r4, r1
   1f760:	2b20      	cmp	r3, #32
   1f762:	d100      	bne.n	1f766 <__aeabi_dsub+0x32e>
   1f764:	e080      	b.n	1f868 <__aeabi_dsub+0x430>
   1f766:	2140      	movs	r1, #64	; 0x40
   1f768:	1acb      	subs	r3, r1, r3
   1f76a:	409a      	lsls	r2, r3
   1f76c:	4315      	orrs	r5, r2
   1f76e:	1e6a      	subs	r2, r5, #1
   1f770:	4195      	sbcs	r5, r2
   1f772:	2700      	movs	r7, #0
   1f774:	4325      	orrs	r5, r4
   1f776:	2400      	movs	r4, #0
   1f778:	e71f      	b.n	1f5ba <__aeabi_dsub+0x182>
   1f77a:	4663      	mov	r3, ip
   1f77c:	0002      	movs	r2, r0
   1f77e:	3b20      	subs	r3, #32
   1f780:	40da      	lsrs	r2, r3
   1f782:	4663      	mov	r3, ip
   1f784:	2b20      	cmp	r3, #32
   1f786:	d071      	beq.n	1f86c <__aeabi_dsub+0x434>
   1f788:	2340      	movs	r3, #64	; 0x40
   1f78a:	4666      	mov	r6, ip
   1f78c:	1b9b      	subs	r3, r3, r6
   1f78e:	4098      	lsls	r0, r3
   1f790:	4301      	orrs	r1, r0
   1f792:	1e48      	subs	r0, r1, #1
   1f794:	4181      	sbcs	r1, r0
   1f796:	4311      	orrs	r1, r2
   1f798:	2200      	movs	r2, #0
   1f79a:	e6cf      	b.n	1f53c <__aeabi_dsub+0x104>
   1f79c:	000007ff 	.word	0x000007ff
   1f7a0:	ff7fffff 	.word	0xff7fffff
   1f7a4:	800fffff 	.word	0x800fffff
   1f7a8:	2c00      	cmp	r4, #0
   1f7aa:	d048      	beq.n	1f83e <__aeabi_dsub+0x406>
   1f7ac:	4cca      	ldr	r4, [pc, #808]	; (1fad8 <__aeabi_dsub+0x6a0>)
   1f7ae:	42a2      	cmp	r2, r4
   1f7b0:	d100      	bne.n	1f7b4 <__aeabi_dsub+0x37c>
   1f7b2:	e0a2      	b.n	1f8fa <__aeabi_dsub+0x4c2>
   1f7b4:	4274      	negs	r4, r6
   1f7b6:	46a1      	mov	r9, r4
   1f7b8:	2480      	movs	r4, #128	; 0x80
   1f7ba:	0424      	lsls	r4, r4, #16
   1f7bc:	4327      	orrs	r7, r4
   1f7be:	464c      	mov	r4, r9
   1f7c0:	2c38      	cmp	r4, #56	; 0x38
   1f7c2:	dd00      	ble.n	1f7c6 <__aeabi_dsub+0x38e>
   1f7c4:	e0db      	b.n	1f97e <__aeabi_dsub+0x546>
   1f7c6:	2c1f      	cmp	r4, #31
   1f7c8:	dd00      	ble.n	1f7cc <__aeabi_dsub+0x394>
   1f7ca:	e144      	b.n	1fa56 <__aeabi_dsub+0x61e>
   1f7cc:	464e      	mov	r6, r9
   1f7ce:	2420      	movs	r4, #32
   1f7d0:	1ba4      	subs	r4, r4, r6
   1f7d2:	003e      	movs	r6, r7
   1f7d4:	40a6      	lsls	r6, r4
   1f7d6:	46a2      	mov	sl, r4
   1f7d8:	46b0      	mov	r8, r6
   1f7da:	464c      	mov	r4, r9
   1f7dc:	002e      	movs	r6, r5
   1f7de:	40e6      	lsrs	r6, r4
   1f7e0:	46b4      	mov	ip, r6
   1f7e2:	4646      	mov	r6, r8
   1f7e4:	4664      	mov	r4, ip
   1f7e6:	4326      	orrs	r6, r4
   1f7e8:	4654      	mov	r4, sl
   1f7ea:	40a5      	lsls	r5, r4
   1f7ec:	1e6c      	subs	r4, r5, #1
   1f7ee:	41a5      	sbcs	r5, r4
   1f7f0:	0034      	movs	r4, r6
   1f7f2:	432c      	orrs	r4, r5
   1f7f4:	464d      	mov	r5, r9
   1f7f6:	40ef      	lsrs	r7, r5
   1f7f8:	1b0d      	subs	r5, r1, r4
   1f7fa:	e028      	b.n	1f84e <__aeabi_dsub+0x416>
   1f7fc:	464a      	mov	r2, r9
   1f7fe:	4643      	mov	r3, r8
   1f800:	464d      	mov	r5, r9
   1f802:	431a      	orrs	r2, r3
   1f804:	d000      	beq.n	1f808 <__aeabi_dsub+0x3d0>
   1f806:	e6a5      	b.n	1f554 <__aeabi_dsub+0x11c>
   1f808:	2300      	movs	r3, #0
   1f80a:	2400      	movs	r4, #0
   1f80c:	2500      	movs	r5, #0
   1f80e:	e6de      	b.n	1f5ce <__aeabi_dsub+0x196>
   1f810:	2a1f      	cmp	r2, #31
   1f812:	dc5a      	bgt.n	1f8ca <__aeabi_dsub+0x492>
   1f814:	4666      	mov	r6, ip
   1f816:	2220      	movs	r2, #32
   1f818:	1b92      	subs	r2, r2, r6
   1f81a:	0006      	movs	r6, r0
   1f81c:	4096      	lsls	r6, r2
   1f81e:	4691      	mov	r9, r2
   1f820:	46b0      	mov	r8, r6
   1f822:	4662      	mov	r2, ip
   1f824:	000e      	movs	r6, r1
   1f826:	40d6      	lsrs	r6, r2
   1f828:	4642      	mov	r2, r8
   1f82a:	4316      	orrs	r6, r2
   1f82c:	464a      	mov	r2, r9
   1f82e:	4091      	lsls	r1, r2
   1f830:	1e4a      	subs	r2, r1, #1
   1f832:	4191      	sbcs	r1, r2
   1f834:	0002      	movs	r2, r0
   1f836:	4660      	mov	r0, ip
   1f838:	4331      	orrs	r1, r6
   1f83a:	40c2      	lsrs	r2, r0
   1f83c:	e6e4      	b.n	1f608 <__aeabi_dsub+0x1d0>
   1f83e:	003c      	movs	r4, r7
   1f840:	432c      	orrs	r4, r5
   1f842:	d05a      	beq.n	1f8fa <__aeabi_dsub+0x4c2>
   1f844:	43f4      	mvns	r4, r6
   1f846:	46a1      	mov	r9, r4
   1f848:	2c00      	cmp	r4, #0
   1f84a:	d152      	bne.n	1f8f2 <__aeabi_dsub+0x4ba>
   1f84c:	1b4d      	subs	r5, r1, r5
   1f84e:	42a9      	cmp	r1, r5
   1f850:	4189      	sbcs	r1, r1
   1f852:	1bc7      	subs	r7, r0, r7
   1f854:	4249      	negs	r1, r1
   1f856:	1a7f      	subs	r7, r7, r1
   1f858:	0014      	movs	r4, r2
   1f85a:	469a      	mov	sl, r3
   1f85c:	e675      	b.n	1f54a <__aeabi_dsub+0x112>
   1f85e:	4a9e      	ldr	r2, [pc, #632]	; (1fad8 <__aeabi_dsub+0x6a0>)
   1f860:	4294      	cmp	r4, r2
   1f862:	d000      	beq.n	1f866 <__aeabi_dsub+0x42e>
   1f864:	e6c7      	b.n	1f5f6 <__aeabi_dsub+0x1be>
   1f866:	e613      	b.n	1f490 <__aeabi_dsub+0x58>
   1f868:	2200      	movs	r2, #0
   1f86a:	e77f      	b.n	1f76c <__aeabi_dsub+0x334>
   1f86c:	2000      	movs	r0, #0
   1f86e:	e78f      	b.n	1f790 <__aeabi_dsub+0x358>
   1f870:	2c00      	cmp	r4, #0
   1f872:	d000      	beq.n	1f876 <__aeabi_dsub+0x43e>
   1f874:	e0c8      	b.n	1fa08 <__aeabi_dsub+0x5d0>
   1f876:	003b      	movs	r3, r7
   1f878:	432b      	orrs	r3, r5
   1f87a:	d100      	bne.n	1f87e <__aeabi_dsub+0x446>
   1f87c:	e10f      	b.n	1fa9e <__aeabi_dsub+0x666>
   1f87e:	0003      	movs	r3, r0
   1f880:	430b      	orrs	r3, r1
   1f882:	d100      	bne.n	1f886 <__aeabi_dsub+0x44e>
   1f884:	e604      	b.n	1f490 <__aeabi_dsub+0x58>
   1f886:	1869      	adds	r1, r5, r1
   1f888:	42a9      	cmp	r1, r5
   1f88a:	419b      	sbcs	r3, r3
   1f88c:	183f      	adds	r7, r7, r0
   1f88e:	425b      	negs	r3, r3
   1f890:	19df      	adds	r7, r3, r7
   1f892:	023b      	lsls	r3, r7, #8
   1f894:	d400      	bmi.n	1f898 <__aeabi_dsub+0x460>
   1f896:	e11a      	b.n	1face <__aeabi_dsub+0x696>
   1f898:	4b90      	ldr	r3, [pc, #576]	; (1fadc <__aeabi_dsub+0x6a4>)
   1f89a:	000d      	movs	r5, r1
   1f89c:	401f      	ands	r7, r3
   1f89e:	4664      	mov	r4, ip
   1f8a0:	e5f6      	b.n	1f490 <__aeabi_dsub+0x58>
   1f8a2:	469a      	mov	sl, r3
   1f8a4:	e689      	b.n	1f5ba <__aeabi_dsub+0x182>
   1f8a6:	003a      	movs	r2, r7
   1f8a8:	432a      	orrs	r2, r5
   1f8aa:	2c00      	cmp	r4, #0
   1f8ac:	d15c      	bne.n	1f968 <__aeabi_dsub+0x530>
   1f8ae:	2a00      	cmp	r2, #0
   1f8b0:	d175      	bne.n	1f99e <__aeabi_dsub+0x566>
   1f8b2:	0002      	movs	r2, r0
   1f8b4:	430a      	orrs	r2, r1
   1f8b6:	d100      	bne.n	1f8ba <__aeabi_dsub+0x482>
   1f8b8:	e0ca      	b.n	1fa50 <__aeabi_dsub+0x618>
   1f8ba:	0007      	movs	r7, r0
   1f8bc:	000d      	movs	r5, r1
   1f8be:	469a      	mov	sl, r3
   1f8c0:	e5e6      	b.n	1f490 <__aeabi_dsub+0x58>
   1f8c2:	4664      	mov	r4, ip
   1f8c4:	2200      	movs	r2, #0
   1f8c6:	2500      	movs	r5, #0
   1f8c8:	e681      	b.n	1f5ce <__aeabi_dsub+0x196>
   1f8ca:	4662      	mov	r2, ip
   1f8cc:	0006      	movs	r6, r0
   1f8ce:	3a20      	subs	r2, #32
   1f8d0:	40d6      	lsrs	r6, r2
   1f8d2:	4662      	mov	r2, ip
   1f8d4:	46b0      	mov	r8, r6
   1f8d6:	2a20      	cmp	r2, #32
   1f8d8:	d100      	bne.n	1f8dc <__aeabi_dsub+0x4a4>
   1f8da:	e0b7      	b.n	1fa4c <__aeabi_dsub+0x614>
   1f8dc:	2240      	movs	r2, #64	; 0x40
   1f8de:	4666      	mov	r6, ip
   1f8e0:	1b92      	subs	r2, r2, r6
   1f8e2:	4090      	lsls	r0, r2
   1f8e4:	4301      	orrs	r1, r0
   1f8e6:	4642      	mov	r2, r8
   1f8e8:	1e48      	subs	r0, r1, #1
   1f8ea:	4181      	sbcs	r1, r0
   1f8ec:	4311      	orrs	r1, r2
   1f8ee:	2200      	movs	r2, #0
   1f8f0:	e68a      	b.n	1f608 <__aeabi_dsub+0x1d0>
   1f8f2:	4c79      	ldr	r4, [pc, #484]	; (1fad8 <__aeabi_dsub+0x6a0>)
   1f8f4:	42a2      	cmp	r2, r4
   1f8f6:	d000      	beq.n	1f8fa <__aeabi_dsub+0x4c2>
   1f8f8:	e761      	b.n	1f7be <__aeabi_dsub+0x386>
   1f8fa:	0007      	movs	r7, r0
   1f8fc:	000d      	movs	r5, r1
   1f8fe:	0014      	movs	r4, r2
   1f900:	469a      	mov	sl, r3
   1f902:	e5c5      	b.n	1f490 <__aeabi_dsub+0x58>
   1f904:	2c00      	cmp	r4, #0
   1f906:	d141      	bne.n	1f98c <__aeabi_dsub+0x554>
   1f908:	003c      	movs	r4, r7
   1f90a:	432c      	orrs	r4, r5
   1f90c:	d078      	beq.n	1fa00 <__aeabi_dsub+0x5c8>
   1f90e:	43f4      	mvns	r4, r6
   1f910:	46a1      	mov	r9, r4
   1f912:	2c00      	cmp	r4, #0
   1f914:	d020      	beq.n	1f958 <__aeabi_dsub+0x520>
   1f916:	4c70      	ldr	r4, [pc, #448]	; (1fad8 <__aeabi_dsub+0x6a0>)
   1f918:	42a2      	cmp	r2, r4
   1f91a:	d071      	beq.n	1fa00 <__aeabi_dsub+0x5c8>
   1f91c:	464c      	mov	r4, r9
   1f91e:	2c38      	cmp	r4, #56	; 0x38
   1f920:	dd00      	ble.n	1f924 <__aeabi_dsub+0x4ec>
   1f922:	e0b2      	b.n	1fa8a <__aeabi_dsub+0x652>
   1f924:	2c1f      	cmp	r4, #31
   1f926:	dd00      	ble.n	1f92a <__aeabi_dsub+0x4f2>
   1f928:	e0bc      	b.n	1faa4 <__aeabi_dsub+0x66c>
   1f92a:	2620      	movs	r6, #32
   1f92c:	1b34      	subs	r4, r6, r4
   1f92e:	46a2      	mov	sl, r4
   1f930:	003c      	movs	r4, r7
   1f932:	4656      	mov	r6, sl
   1f934:	40b4      	lsls	r4, r6
   1f936:	464e      	mov	r6, r9
   1f938:	46a0      	mov	r8, r4
   1f93a:	002c      	movs	r4, r5
   1f93c:	40f4      	lsrs	r4, r6
   1f93e:	46a4      	mov	ip, r4
   1f940:	4644      	mov	r4, r8
   1f942:	4666      	mov	r6, ip
   1f944:	4334      	orrs	r4, r6
   1f946:	46a4      	mov	ip, r4
   1f948:	4654      	mov	r4, sl
   1f94a:	40a5      	lsls	r5, r4
   1f94c:	4664      	mov	r4, ip
   1f94e:	1e6e      	subs	r6, r5, #1
   1f950:	41b5      	sbcs	r5, r6
   1f952:	4325      	orrs	r5, r4
   1f954:	464c      	mov	r4, r9
   1f956:	40e7      	lsrs	r7, r4
   1f958:	186d      	adds	r5, r5, r1
   1f95a:	428d      	cmp	r5, r1
   1f95c:	4189      	sbcs	r1, r1
   1f95e:	183f      	adds	r7, r7, r0
   1f960:	4249      	negs	r1, r1
   1f962:	19cf      	adds	r7, r1, r7
   1f964:	0014      	movs	r4, r2
   1f966:	e656      	b.n	1f616 <__aeabi_dsub+0x1de>
   1f968:	2a00      	cmp	r2, #0
   1f96a:	d12f      	bne.n	1f9cc <__aeabi_dsub+0x594>
   1f96c:	0002      	movs	r2, r0
   1f96e:	430a      	orrs	r2, r1
   1f970:	d100      	bne.n	1f974 <__aeabi_dsub+0x53c>
   1f972:	e084      	b.n	1fa7e <__aeabi_dsub+0x646>
   1f974:	0007      	movs	r7, r0
   1f976:	000d      	movs	r5, r1
   1f978:	469a      	mov	sl, r3
   1f97a:	4c57      	ldr	r4, [pc, #348]	; (1fad8 <__aeabi_dsub+0x6a0>)
   1f97c:	e588      	b.n	1f490 <__aeabi_dsub+0x58>
   1f97e:	433d      	orrs	r5, r7
   1f980:	1e6f      	subs	r7, r5, #1
   1f982:	41bd      	sbcs	r5, r7
   1f984:	b2ec      	uxtb	r4, r5
   1f986:	2700      	movs	r7, #0
   1f988:	1b0d      	subs	r5, r1, r4
   1f98a:	e760      	b.n	1f84e <__aeabi_dsub+0x416>
   1f98c:	4c52      	ldr	r4, [pc, #328]	; (1fad8 <__aeabi_dsub+0x6a0>)
   1f98e:	42a2      	cmp	r2, r4
   1f990:	d036      	beq.n	1fa00 <__aeabi_dsub+0x5c8>
   1f992:	4274      	negs	r4, r6
   1f994:	2680      	movs	r6, #128	; 0x80
   1f996:	0436      	lsls	r6, r6, #16
   1f998:	46a1      	mov	r9, r4
   1f99a:	4337      	orrs	r7, r6
   1f99c:	e7be      	b.n	1f91c <__aeabi_dsub+0x4e4>
   1f99e:	0002      	movs	r2, r0
   1f9a0:	430a      	orrs	r2, r1
   1f9a2:	d100      	bne.n	1f9a6 <__aeabi_dsub+0x56e>
   1f9a4:	e574      	b.n	1f490 <__aeabi_dsub+0x58>
   1f9a6:	1a6a      	subs	r2, r5, r1
   1f9a8:	4690      	mov	r8, r2
   1f9aa:	4545      	cmp	r5, r8
   1f9ac:	41b6      	sbcs	r6, r6
   1f9ae:	1a3a      	subs	r2, r7, r0
   1f9b0:	4276      	negs	r6, r6
   1f9b2:	1b92      	subs	r2, r2, r6
   1f9b4:	4694      	mov	ip, r2
   1f9b6:	0212      	lsls	r2, r2, #8
   1f9b8:	d400      	bmi.n	1f9bc <__aeabi_dsub+0x584>
   1f9ba:	e5f7      	b.n	1f5ac <__aeabi_dsub+0x174>
   1f9bc:	1b4d      	subs	r5, r1, r5
   1f9be:	42a9      	cmp	r1, r5
   1f9c0:	4189      	sbcs	r1, r1
   1f9c2:	1bc7      	subs	r7, r0, r7
   1f9c4:	4249      	negs	r1, r1
   1f9c6:	1a7f      	subs	r7, r7, r1
   1f9c8:	469a      	mov	sl, r3
   1f9ca:	e561      	b.n	1f490 <__aeabi_dsub+0x58>
   1f9cc:	0002      	movs	r2, r0
   1f9ce:	430a      	orrs	r2, r1
   1f9d0:	d03a      	beq.n	1fa48 <__aeabi_dsub+0x610>
   1f9d2:	08ed      	lsrs	r5, r5, #3
   1f9d4:	077c      	lsls	r4, r7, #29
   1f9d6:	432c      	orrs	r4, r5
   1f9d8:	2580      	movs	r5, #128	; 0x80
   1f9da:	08fa      	lsrs	r2, r7, #3
   1f9dc:	032d      	lsls	r5, r5, #12
   1f9de:	422a      	tst	r2, r5
   1f9e0:	d008      	beq.n	1f9f4 <__aeabi_dsub+0x5bc>
   1f9e2:	08c7      	lsrs	r7, r0, #3
   1f9e4:	422f      	tst	r7, r5
   1f9e6:	d105      	bne.n	1f9f4 <__aeabi_dsub+0x5bc>
   1f9e8:	0745      	lsls	r5, r0, #29
   1f9ea:	002c      	movs	r4, r5
   1f9ec:	003a      	movs	r2, r7
   1f9ee:	469a      	mov	sl, r3
   1f9f0:	08c9      	lsrs	r1, r1, #3
   1f9f2:	430c      	orrs	r4, r1
   1f9f4:	0f67      	lsrs	r7, r4, #29
   1f9f6:	00d2      	lsls	r2, r2, #3
   1f9f8:	00e5      	lsls	r5, r4, #3
   1f9fa:	4317      	orrs	r7, r2
   1f9fc:	4c36      	ldr	r4, [pc, #216]	; (1fad8 <__aeabi_dsub+0x6a0>)
   1f9fe:	e547      	b.n	1f490 <__aeabi_dsub+0x58>
   1fa00:	0007      	movs	r7, r0
   1fa02:	000d      	movs	r5, r1
   1fa04:	0014      	movs	r4, r2
   1fa06:	e543      	b.n	1f490 <__aeabi_dsub+0x58>
   1fa08:	003a      	movs	r2, r7
   1fa0a:	432a      	orrs	r2, r5
   1fa0c:	d043      	beq.n	1fa96 <__aeabi_dsub+0x65e>
   1fa0e:	0002      	movs	r2, r0
   1fa10:	430a      	orrs	r2, r1
   1fa12:	d019      	beq.n	1fa48 <__aeabi_dsub+0x610>
   1fa14:	08ed      	lsrs	r5, r5, #3
   1fa16:	077c      	lsls	r4, r7, #29
   1fa18:	432c      	orrs	r4, r5
   1fa1a:	2580      	movs	r5, #128	; 0x80
   1fa1c:	08fa      	lsrs	r2, r7, #3
   1fa1e:	032d      	lsls	r5, r5, #12
   1fa20:	422a      	tst	r2, r5
   1fa22:	d007      	beq.n	1fa34 <__aeabi_dsub+0x5fc>
   1fa24:	08c6      	lsrs	r6, r0, #3
   1fa26:	422e      	tst	r6, r5
   1fa28:	d104      	bne.n	1fa34 <__aeabi_dsub+0x5fc>
   1fa2a:	0747      	lsls	r7, r0, #29
   1fa2c:	003c      	movs	r4, r7
   1fa2e:	0032      	movs	r2, r6
   1fa30:	08c9      	lsrs	r1, r1, #3
   1fa32:	430c      	orrs	r4, r1
   1fa34:	00d7      	lsls	r7, r2, #3
   1fa36:	0f62      	lsrs	r2, r4, #29
   1fa38:	00e5      	lsls	r5, r4, #3
   1fa3a:	4317      	orrs	r7, r2
   1fa3c:	469a      	mov	sl, r3
   1fa3e:	4c26      	ldr	r4, [pc, #152]	; (1fad8 <__aeabi_dsub+0x6a0>)
   1fa40:	e526      	b.n	1f490 <__aeabi_dsub+0x58>
   1fa42:	2200      	movs	r2, #0
   1fa44:	2500      	movs	r5, #0
   1fa46:	e544      	b.n	1f4d2 <__aeabi_dsub+0x9a>
   1fa48:	4c23      	ldr	r4, [pc, #140]	; (1fad8 <__aeabi_dsub+0x6a0>)
   1fa4a:	e521      	b.n	1f490 <__aeabi_dsub+0x58>
   1fa4c:	2000      	movs	r0, #0
   1fa4e:	e749      	b.n	1f8e4 <__aeabi_dsub+0x4ac>
   1fa50:	2300      	movs	r3, #0
   1fa52:	2500      	movs	r5, #0
   1fa54:	e5bb      	b.n	1f5ce <__aeabi_dsub+0x196>
   1fa56:	464c      	mov	r4, r9
   1fa58:	003e      	movs	r6, r7
   1fa5a:	3c20      	subs	r4, #32
   1fa5c:	40e6      	lsrs	r6, r4
   1fa5e:	464c      	mov	r4, r9
   1fa60:	46b4      	mov	ip, r6
   1fa62:	2c20      	cmp	r4, #32
   1fa64:	d031      	beq.n	1faca <__aeabi_dsub+0x692>
   1fa66:	2440      	movs	r4, #64	; 0x40
   1fa68:	464e      	mov	r6, r9
   1fa6a:	1ba6      	subs	r6, r4, r6
   1fa6c:	40b7      	lsls	r7, r6
   1fa6e:	433d      	orrs	r5, r7
   1fa70:	1e6c      	subs	r4, r5, #1
   1fa72:	41a5      	sbcs	r5, r4
   1fa74:	4664      	mov	r4, ip
   1fa76:	432c      	orrs	r4, r5
   1fa78:	2700      	movs	r7, #0
   1fa7a:	1b0d      	subs	r5, r1, r4
   1fa7c:	e6e7      	b.n	1f84e <__aeabi_dsub+0x416>
   1fa7e:	2280      	movs	r2, #128	; 0x80
   1fa80:	2300      	movs	r3, #0
   1fa82:	0312      	lsls	r2, r2, #12
   1fa84:	4c14      	ldr	r4, [pc, #80]	; (1fad8 <__aeabi_dsub+0x6a0>)
   1fa86:	2500      	movs	r5, #0
   1fa88:	e5a1      	b.n	1f5ce <__aeabi_dsub+0x196>
   1fa8a:	433d      	orrs	r5, r7
   1fa8c:	1e6f      	subs	r7, r5, #1
   1fa8e:	41bd      	sbcs	r5, r7
   1fa90:	2700      	movs	r7, #0
   1fa92:	b2ed      	uxtb	r5, r5
   1fa94:	e760      	b.n	1f958 <__aeabi_dsub+0x520>
   1fa96:	0007      	movs	r7, r0
   1fa98:	000d      	movs	r5, r1
   1fa9a:	4c0f      	ldr	r4, [pc, #60]	; (1fad8 <__aeabi_dsub+0x6a0>)
   1fa9c:	e4f8      	b.n	1f490 <__aeabi_dsub+0x58>
   1fa9e:	0007      	movs	r7, r0
   1faa0:	000d      	movs	r5, r1
   1faa2:	e4f5      	b.n	1f490 <__aeabi_dsub+0x58>
   1faa4:	464e      	mov	r6, r9
   1faa6:	003c      	movs	r4, r7
   1faa8:	3e20      	subs	r6, #32
   1faaa:	40f4      	lsrs	r4, r6
   1faac:	46a0      	mov	r8, r4
   1faae:	464c      	mov	r4, r9
   1fab0:	2c20      	cmp	r4, #32
   1fab2:	d00e      	beq.n	1fad2 <__aeabi_dsub+0x69a>
   1fab4:	2440      	movs	r4, #64	; 0x40
   1fab6:	464e      	mov	r6, r9
   1fab8:	1ba4      	subs	r4, r4, r6
   1faba:	40a7      	lsls	r7, r4
   1fabc:	433d      	orrs	r5, r7
   1fabe:	1e6f      	subs	r7, r5, #1
   1fac0:	41bd      	sbcs	r5, r7
   1fac2:	4644      	mov	r4, r8
   1fac4:	2700      	movs	r7, #0
   1fac6:	4325      	orrs	r5, r4
   1fac8:	e746      	b.n	1f958 <__aeabi_dsub+0x520>
   1faca:	2700      	movs	r7, #0
   1facc:	e7cf      	b.n	1fa6e <__aeabi_dsub+0x636>
   1face:	000d      	movs	r5, r1
   1fad0:	e573      	b.n	1f5ba <__aeabi_dsub+0x182>
   1fad2:	2700      	movs	r7, #0
   1fad4:	e7f2      	b.n	1fabc <__aeabi_dsub+0x684>
   1fad6:	46c0      	nop			; (mov r8, r8)
   1fad8:	000007ff 	.word	0x000007ff
   1fadc:	ff7fffff 	.word	0xff7fffff

0001fae0 <__aeabi_dcmpun>:
   1fae0:	b570      	push	{r4, r5, r6, lr}
   1fae2:	4e0e      	ldr	r6, [pc, #56]	; (1fb1c <__aeabi_dcmpun+0x3c>)
   1fae4:	030c      	lsls	r4, r1, #12
   1fae6:	031d      	lsls	r5, r3, #12
   1fae8:	0049      	lsls	r1, r1, #1
   1faea:	005b      	lsls	r3, r3, #1
   1faec:	0b24      	lsrs	r4, r4, #12
   1faee:	0d49      	lsrs	r1, r1, #21
   1faf0:	0b2d      	lsrs	r5, r5, #12
   1faf2:	0d5b      	lsrs	r3, r3, #21
   1faf4:	42b1      	cmp	r1, r6
   1faf6:	d004      	beq.n	1fb02 <__aeabi_dcmpun+0x22>
   1faf8:	4908      	ldr	r1, [pc, #32]	; (1fb1c <__aeabi_dcmpun+0x3c>)
   1fafa:	2000      	movs	r0, #0
   1fafc:	428b      	cmp	r3, r1
   1fafe:	d008      	beq.n	1fb12 <__aeabi_dcmpun+0x32>
   1fb00:	bd70      	pop	{r4, r5, r6, pc}
   1fb02:	4304      	orrs	r4, r0
   1fb04:	2001      	movs	r0, #1
   1fb06:	2c00      	cmp	r4, #0
   1fb08:	d1fa      	bne.n	1fb00 <__aeabi_dcmpun+0x20>
   1fb0a:	4904      	ldr	r1, [pc, #16]	; (1fb1c <__aeabi_dcmpun+0x3c>)
   1fb0c:	2000      	movs	r0, #0
   1fb0e:	428b      	cmp	r3, r1
   1fb10:	d1f6      	bne.n	1fb00 <__aeabi_dcmpun+0x20>
   1fb12:	4315      	orrs	r5, r2
   1fb14:	0028      	movs	r0, r5
   1fb16:	1e45      	subs	r5, r0, #1
   1fb18:	41a8      	sbcs	r0, r5
   1fb1a:	e7f1      	b.n	1fb00 <__aeabi_dcmpun+0x20>
   1fb1c:	000007ff 	.word	0x000007ff

0001fb20 <__aeabi_d2iz>:
   1fb20:	030b      	lsls	r3, r1, #12
   1fb22:	b530      	push	{r4, r5, lr}
   1fb24:	4d13      	ldr	r5, [pc, #76]	; (1fb74 <__aeabi_d2iz+0x54>)
   1fb26:	0b1a      	lsrs	r2, r3, #12
   1fb28:	004b      	lsls	r3, r1, #1
   1fb2a:	0d5b      	lsrs	r3, r3, #21
   1fb2c:	0fc9      	lsrs	r1, r1, #31
   1fb2e:	2400      	movs	r4, #0
   1fb30:	42ab      	cmp	r3, r5
   1fb32:	dd11      	ble.n	1fb58 <__aeabi_d2iz+0x38>
   1fb34:	4c10      	ldr	r4, [pc, #64]	; (1fb78 <__aeabi_d2iz+0x58>)
   1fb36:	42a3      	cmp	r3, r4
   1fb38:	dc10      	bgt.n	1fb5c <__aeabi_d2iz+0x3c>
   1fb3a:	2480      	movs	r4, #128	; 0x80
   1fb3c:	0364      	lsls	r4, r4, #13
   1fb3e:	4322      	orrs	r2, r4
   1fb40:	4c0e      	ldr	r4, [pc, #56]	; (1fb7c <__aeabi_d2iz+0x5c>)
   1fb42:	1ae4      	subs	r4, r4, r3
   1fb44:	2c1f      	cmp	r4, #31
   1fb46:	dd0c      	ble.n	1fb62 <__aeabi_d2iz+0x42>
   1fb48:	480d      	ldr	r0, [pc, #52]	; (1fb80 <__aeabi_d2iz+0x60>)
   1fb4a:	1ac3      	subs	r3, r0, r3
   1fb4c:	40da      	lsrs	r2, r3
   1fb4e:	0013      	movs	r3, r2
   1fb50:	425c      	negs	r4, r3
   1fb52:	2900      	cmp	r1, #0
   1fb54:	d100      	bne.n	1fb58 <__aeabi_d2iz+0x38>
   1fb56:	001c      	movs	r4, r3
   1fb58:	0020      	movs	r0, r4
   1fb5a:	bd30      	pop	{r4, r5, pc}
   1fb5c:	4b09      	ldr	r3, [pc, #36]	; (1fb84 <__aeabi_d2iz+0x64>)
   1fb5e:	18cc      	adds	r4, r1, r3
   1fb60:	e7fa      	b.n	1fb58 <__aeabi_d2iz+0x38>
   1fb62:	40e0      	lsrs	r0, r4
   1fb64:	4c08      	ldr	r4, [pc, #32]	; (1fb88 <__aeabi_d2iz+0x68>)
   1fb66:	46a4      	mov	ip, r4
   1fb68:	4463      	add	r3, ip
   1fb6a:	409a      	lsls	r2, r3
   1fb6c:	0013      	movs	r3, r2
   1fb6e:	4303      	orrs	r3, r0
   1fb70:	e7ee      	b.n	1fb50 <__aeabi_d2iz+0x30>
   1fb72:	46c0      	nop			; (mov r8, r8)
   1fb74:	000003fe 	.word	0x000003fe
   1fb78:	0000041d 	.word	0x0000041d
   1fb7c:	00000433 	.word	0x00000433
   1fb80:	00000413 	.word	0x00000413
   1fb84:	7fffffff 	.word	0x7fffffff
   1fb88:	fffffbed 	.word	0xfffffbed

0001fb8c <__aeabi_i2d>:
   1fb8c:	b570      	push	{r4, r5, r6, lr}
   1fb8e:	2800      	cmp	r0, #0
   1fb90:	d030      	beq.n	1fbf4 <__aeabi_i2d+0x68>
   1fb92:	17c3      	asrs	r3, r0, #31
   1fb94:	18c4      	adds	r4, r0, r3
   1fb96:	405c      	eors	r4, r3
   1fb98:	0fc5      	lsrs	r5, r0, #31
   1fb9a:	0020      	movs	r0, r4
   1fb9c:	f7fe f938 	bl	1de10 <__clzsi2>
   1fba0:	4b17      	ldr	r3, [pc, #92]	; (1fc00 <__aeabi_i2d+0x74>)
   1fba2:	4a18      	ldr	r2, [pc, #96]	; (1fc04 <__aeabi_i2d+0x78>)
   1fba4:	1a1b      	subs	r3, r3, r0
   1fba6:	1ad2      	subs	r2, r2, r3
   1fba8:	2a1f      	cmp	r2, #31
   1fbaa:	dd18      	ble.n	1fbde <__aeabi_i2d+0x52>
   1fbac:	4a16      	ldr	r2, [pc, #88]	; (1fc08 <__aeabi_i2d+0x7c>)
   1fbae:	1ad2      	subs	r2, r2, r3
   1fbb0:	4094      	lsls	r4, r2
   1fbb2:	2200      	movs	r2, #0
   1fbb4:	0324      	lsls	r4, r4, #12
   1fbb6:	055b      	lsls	r3, r3, #21
   1fbb8:	0b24      	lsrs	r4, r4, #12
   1fbba:	0d5b      	lsrs	r3, r3, #21
   1fbbc:	2100      	movs	r1, #0
   1fbbe:	0010      	movs	r0, r2
   1fbc0:	0324      	lsls	r4, r4, #12
   1fbc2:	0d0a      	lsrs	r2, r1, #20
   1fbc4:	0512      	lsls	r2, r2, #20
   1fbc6:	0b24      	lsrs	r4, r4, #12
   1fbc8:	4314      	orrs	r4, r2
   1fbca:	4a10      	ldr	r2, [pc, #64]	; (1fc0c <__aeabi_i2d+0x80>)
   1fbcc:	051b      	lsls	r3, r3, #20
   1fbce:	4014      	ands	r4, r2
   1fbd0:	431c      	orrs	r4, r3
   1fbd2:	0064      	lsls	r4, r4, #1
   1fbd4:	07ed      	lsls	r5, r5, #31
   1fbd6:	0864      	lsrs	r4, r4, #1
   1fbd8:	432c      	orrs	r4, r5
   1fbda:	0021      	movs	r1, r4
   1fbdc:	bd70      	pop	{r4, r5, r6, pc}
   1fbde:	0021      	movs	r1, r4
   1fbe0:	4091      	lsls	r1, r2
   1fbe2:	000a      	movs	r2, r1
   1fbe4:	210b      	movs	r1, #11
   1fbe6:	1a08      	subs	r0, r1, r0
   1fbe8:	40c4      	lsrs	r4, r0
   1fbea:	055b      	lsls	r3, r3, #21
   1fbec:	0324      	lsls	r4, r4, #12
   1fbee:	0b24      	lsrs	r4, r4, #12
   1fbf0:	0d5b      	lsrs	r3, r3, #21
   1fbf2:	e7e3      	b.n	1fbbc <__aeabi_i2d+0x30>
   1fbf4:	2500      	movs	r5, #0
   1fbf6:	2300      	movs	r3, #0
   1fbf8:	2400      	movs	r4, #0
   1fbfa:	2200      	movs	r2, #0
   1fbfc:	e7de      	b.n	1fbbc <__aeabi_i2d+0x30>
   1fbfe:	46c0      	nop			; (mov r8, r8)
   1fc00:	0000041e 	.word	0x0000041e
   1fc04:	00000433 	.word	0x00000433
   1fc08:	00000413 	.word	0x00000413
   1fc0c:	800fffff 	.word	0x800fffff

0001fc10 <__aeabi_ui2d>:
   1fc10:	b570      	push	{r4, r5, r6, lr}
   1fc12:	1e05      	subs	r5, r0, #0
   1fc14:	d028      	beq.n	1fc68 <__aeabi_ui2d+0x58>
   1fc16:	f7fe f8fb 	bl	1de10 <__clzsi2>
   1fc1a:	4b15      	ldr	r3, [pc, #84]	; (1fc70 <__aeabi_ui2d+0x60>)
   1fc1c:	4a15      	ldr	r2, [pc, #84]	; (1fc74 <__aeabi_ui2d+0x64>)
   1fc1e:	1a1b      	subs	r3, r3, r0
   1fc20:	1ad2      	subs	r2, r2, r3
   1fc22:	2a1f      	cmp	r2, #31
   1fc24:	dd16      	ble.n	1fc54 <__aeabi_ui2d+0x44>
   1fc26:	002c      	movs	r4, r5
   1fc28:	4a13      	ldr	r2, [pc, #76]	; (1fc78 <__aeabi_ui2d+0x68>)
   1fc2a:	2500      	movs	r5, #0
   1fc2c:	1ad2      	subs	r2, r2, r3
   1fc2e:	4094      	lsls	r4, r2
   1fc30:	055a      	lsls	r2, r3, #21
   1fc32:	0324      	lsls	r4, r4, #12
   1fc34:	0b24      	lsrs	r4, r4, #12
   1fc36:	0d52      	lsrs	r2, r2, #21
   1fc38:	2100      	movs	r1, #0
   1fc3a:	0324      	lsls	r4, r4, #12
   1fc3c:	0d0b      	lsrs	r3, r1, #20
   1fc3e:	0b24      	lsrs	r4, r4, #12
   1fc40:	051b      	lsls	r3, r3, #20
   1fc42:	4323      	orrs	r3, r4
   1fc44:	4c0d      	ldr	r4, [pc, #52]	; (1fc7c <__aeabi_ui2d+0x6c>)
   1fc46:	0512      	lsls	r2, r2, #20
   1fc48:	4023      	ands	r3, r4
   1fc4a:	4313      	orrs	r3, r2
   1fc4c:	005b      	lsls	r3, r3, #1
   1fc4e:	0028      	movs	r0, r5
   1fc50:	0859      	lsrs	r1, r3, #1
   1fc52:	bd70      	pop	{r4, r5, r6, pc}
   1fc54:	210b      	movs	r1, #11
   1fc56:	002c      	movs	r4, r5
   1fc58:	1a08      	subs	r0, r1, r0
   1fc5a:	40c4      	lsrs	r4, r0
   1fc5c:	4095      	lsls	r5, r2
   1fc5e:	0324      	lsls	r4, r4, #12
   1fc60:	055a      	lsls	r2, r3, #21
   1fc62:	0b24      	lsrs	r4, r4, #12
   1fc64:	0d52      	lsrs	r2, r2, #21
   1fc66:	e7e7      	b.n	1fc38 <__aeabi_ui2d+0x28>
   1fc68:	2200      	movs	r2, #0
   1fc6a:	2400      	movs	r4, #0
   1fc6c:	e7e4      	b.n	1fc38 <__aeabi_ui2d+0x28>
   1fc6e:	46c0      	nop			; (mov r8, r8)
   1fc70:	0000041e 	.word	0x0000041e
   1fc74:	00000433 	.word	0x00000433
   1fc78:	00000413 	.word	0x00000413
   1fc7c:	800fffff 	.word	0x800fffff

0001fc80 <__aeabi_idiv0>:
   1fc80:	4770      	bx	lr
   1fc82:	46c0      	nop			; (mov r8, r8)

0001fc84 <__clzdi2>:
   1fc84:	b510      	push	{r4, lr}
   1fc86:	2900      	cmp	r1, #0
   1fc88:	d103      	bne.n	1fc92 <__clzdi2+0xe>
   1fc8a:	f7fe f8c1 	bl	1de10 <__clzsi2>
   1fc8e:	3020      	adds	r0, #32
   1fc90:	e002      	b.n	1fc98 <__clzdi2+0x14>
   1fc92:	1c08      	adds	r0, r1, #0
   1fc94:	f7fe f8bc 	bl	1de10 <__clzsi2>
   1fc98:	bd10      	pop	{r4, pc}
   1fc9a:	46c0      	nop			; (mov r8, r8)

0001fc9c <lgs>:
   1fc9c:	4d5b 474c 005d                              [MLG].

0001fca2 <lge>:
   1fca2:	0a0d 4e00 544f 4649 3a59 000d 4c42 2045     ...NOTIFY:..BLE 
   1fcb2:	7830 3536 000d 4c42 2045 6f63 6e6e 6365     0x65..BLE connec
   1fcc2:	0d74 4200 454c 6420 7369 6f63 6e6e 6365     t..BLE disconnec
   1fcd2:	0d74 6500 746e 7265 6520 6576 746e 5b20     t..enter event [
   1fce2:	6425 0d5d 000a                              %d]...

0001fce8 <__FUNCTION__.9696>:
   1fce8:	6c62 5f65 6572 6461 725f 7165 635f 0062     ble_read_req_cb.
   1fcf8:	7325 003a 6168 6c64 7265 255b 5d78 0a0d     %s:.hadler[%x]..
	...

0001fd09 <__FUNCTION__.9701>:
   1fd09:	6c62 5f65 6572 6461 635f 6e6f 5f6e 6170     ble_read_conn_pa
   1fd19:	6172 006d 3025 7832 0020 000d 0061 2e31     ram.%02x ...a.1.
   1fd29:	2e30 0033 2d2d 2d2d 2d2d 2d2d 2d2d 252d     0.3.-----------%
   1fd39:	5b73 7325 2d5d 2d2d 2d2d 2d2d 2d2d 2d2d     s[%s]-----------
   1fd49:	0a0d 2e00 2f2e 7273 2f63 616d 6e69 632e     ...../src/main.c
   1fd59:	2500 5b73 3125 7330 253a 5d64 7325 003a     .%s[%10s:%d]%s:.

0001fd69 <__FUNCTION__.9709>:
   1fd69:	616d 6e69 6d00 7365 2068 7473 6361 206b     main.mesh stack 
   1fd79:	6e69 7469 7320 6174 7472 2500 0073 6c61     init start.%s.al
   1fd89:	2069 6170 6172 656d 6574 2072 7265 6f72     i parameter erro
   1fd99:	2172 5b00                                        r!.

0001fd9c <lgs>:
   1fd9c:	4d5b 474c 005d                              [MLG].

0001fda2 <lge>:
   1fda2:	0a0d 6c00 7361 2074 7263 2063 6461 7264     ...last crc addr
   1fdb2:	203d 6c25 0a78 6600 616c 6873 6461 7264     = %lx..flashaddr
   1fdc2:	255b 5d78 6f20 6174 7245 7361 5065 6761     [%x] otaErasePag
   1fdd2:	5b65 7825 205d 6c74 6e65 255b 5d78 4300     e[%x] tlen[%x].C
   1fde2:	6568 6b63 7553 5b6d 7825 205d 5363 6d75     heckSum[%x] cSum
   1fdf2:	255b 5d78 6300 646f 2065 7263 2063 7473     [%x].code crc st
   1fe02:	7461 7375 255b 5d64 0700 5a09 2d58 544f     atus[%d]...ZX-OT
   1fe12:	1241 42ff 3643 3132 0038 4d4c 0000 8034     A..BC6218.LM..4.
	...
   1fe2e:	0080 0080 0000 5554 0a0d 0a0d 6544 6166     ......TU....Defa
   1fe3e:	6c75 5f74 6148 646e 656c 0d72 0d0a 0000     ult_Handler.....
	...

0001fe50 <lgs>:
   1fe50:	4d5b 474c 005d                              [MLG].

0001fe56 <lge>:
   1fe56:	0a0d 4d00 505f 4f52 5f56 5453 5241 4554     ...M_PROV_STARTE
   1fe66:	0044 5f4d 5250 564f 535f 4355 4543 4445     D.M_PROV_SUCCEED
   1fe76:	4d00 505f 4f52 5f56 4146 4c49 4445 4d00     .M_PROV_FAILED.M
   1fe86:	505f 4f52 5f56 5553 4343 4545 5f44 5041     _PROV_SUCCEED_AP
   1fe96:	0050                                        P.

0001fe98 <ali_app_array>:
   1fe98:	2f9d 0000 2f25 0000 2f45 0000 3101 0000     ./..%/..E/...1..
   1fea8:	3299 0000 2f9d 0000 2f25 0000 2f45 0000     .2.../..%/..E/..
   1feb8:	3101 0000 3299 0000 363d 0000 35bd 0000     .1...2..=6...5..
   1fec8:	35e9 0000 36cd 0000 3881 0000 3dd5 0000     .5...6...8...=..
   1fed8:	3d59 0000 3d79 0000 3de9 0000 3fad 0000     Y=..y=...=...?..
   1fee8:	2e2e 2e5c 5c2e 2e2e 6d5c 7365 2f68 7061     ..\..\..\mesh/ap
   1fef8:	2f70 7061 5f70 656d 6873 632e 2500 5b73     p/app_mesh.c.%s[
   1ff08:	3125 7330 253a 5d64 7325 003a               %10s:%d]%s:.

0001ff14 <__FUNCTION__.9108>:
   1ff14:	7061 5f70 656d 6873 655f 616e 6c62 6465     app_mesh_enabled
   1ff24:	635f 0062 2500 0073                         _cb..%s.

0001ff2c <__FUNCTION__.9113>:
   1ff2c:	7061 5f70 656d 6873 645f 7369 6261 656c     app_mesh_disable
   1ff3c:	5f64 6263 6100                                   d_cb.

0001ff41 <__FUNCTION__.9122>:
   1ff41:	7061 5f70 656d 6873 705f 6f72 5f76 7473     app_mesh_prov_st
   1ff51:	7461 5f65 6263 7300 6174 6574 255b 5d73     ate_cb.state[%s]
   1ff61:	7000 6f72 2076 6170 6172 206d 6572 2071     .prov param req 
   1ff71:	6263 6100                                        cb.

0001ff74 <__FUNCTION__.9135>:
   1ff74:	7061 5f70 656d 6873 705f 6f72 5f76 6f6f     app_mesh_prov_oo
   1ff84:	5f62 7561 6874 725f 7165 635f 0062 7561     b_auth_req_cb.au
   1ff94:	6874 6d5f 7465 6f68 3a64 7830 3025 7832     th_method:0x%02x
   1ffa4:	612c 7475 5f68 6361 6974 6e6f 303a 2578     ,auth_action:0x%
   1ffb4:	3430 2c78 7561 6874 735f 7a69 3a65 7830     04x,auth_size:0x
   1ffc4:	3025 7832 6100 7475 2068 6176 206c 6572     %02x.auth val re
   1ffd4:	7571 7365 0074                              quest.

0001ffda <__FUNCTION__.9140>:
   1ffda:	7061 5f70 656d 6873 625f 6675 625f 6f6c     app_mesh_buf_blo
   1ffea:	6b63 665f 6572 6465 635f 0062               ck_freed_cb.

0001fff6 <__FUNCTION__.9145>:
   1fff6:	7061 5f70 656d 6873 6c5f 616f 6564 5f64     app_mesh_loaded_
   20006:	6263 6100                                        cb.

00020009 <__FUNCTION__.9155>:
   20009:	7061 5f70 656d 6873 725f 7365 7465 695f     app_mesh_reset_i
   20019:	646e 635f 0062                              nd_cb.

0002001f <__FUNCTION__.9160>:
   2001f:	7061 5f70 656d 6873 635f 6d6f 6f70 645f     app_mesh_compo_d
   2002f:	7461 5f61 6572 5f71 6263 fc00 0002 0000     ata_req_cb......
   2003f:	0800 0100 0100 0500 0000 0200 0000 0010     ................
   2004f:	0313 0013 a100                                   .....

00020054 <app_mesh_cb>:
   20054:	26a1 0000 26e5 0000 2741 0000 27cd 0000     .&...&..A'...'..
   20064:	2819 0000 2895 0000 28dd 0000 2925 0000     .(...(...(..%)..
   20074:	292d 0000 2979 0000                         -)..y)..

0002007c <__FUNCTION__.9169>:
   2007c:	7061 5f70 656d 6873 695f 696e 0074 6564     app_mesh_init.de
   2008c:	6976 6563 7420 7079 5b65 6425 005d 7061     vice type[%d].ap
   2009c:	2070 656d 6873 7320 6174 7472 0d3a 000a     p mesh start:...

000200ac <__FUNCTION__.9192>:
   200ac:	7061 5f70 656d 6873 735f 6174 7472 6c00     app_mesh_start.l
   200bc:	616f 2064 7473 726f 6465 6320 6e6f 6966     oad stored confi
   200cc:	2067 6164 6174 7320 6174 7574 5b73 7825     g data status[%x
   200dc:	005d 656d 6873 7320 6174 6b63 6520 616e     ].mesh stack ena
   200ec:	6c62 6465 0a0d 5b00                              bled...

000200f3 <lgs>:
   200f3:	4d5b 474c 005d                              [MLG].

000200f9 <lge>:
   200f9:	0a0d 2e00 5c2e 2e2e 2e5c 5c2e 656d 6873     .....\..\..\mesh
   20109:	612f 7070 612f 696c 6c5f 6769 7468 612f     /app/ali_light/a
   20119:	696c 6c5f 6769 7468 632e 2500 5b73 3125     li_light.c.%s[%1
   20129:	7330 253a 5d64 7325 003a                    0s:%d]%s:.

00020133 <__FUNCTION__.9335>:
   20133:	6c61 5f69 696c 6867 5f74 6962 646e 745f     ali_light_bind_t
   20143:	6d69 7265 635f 0062 5f6d 6274 6b5f 7965     imer_cb.m_tb_key
   20153:	615f 7070 665f 6e69 2064 7265 6f72 0072     _app_find error.
   20163:	7325 7400 3e2d 696c 5b64 7825 205d 5f70     %s.t->lid[%x] p_
   20173:	6c61 5f69 696c 6867 2d74 6d3e 646f 6c65     ali_light->model
   20183:	635f 746e 255b 5d78 7320 6174 7574 5b73     _cnt[%x] status[
   20193:	7825 005d 6c61 5f69 696c 6867 5f74 6570     %x].ali_light_pe
   201a3:	6972 646f 695f 646e 745f 6d69 7265 635f     riod_ind_timer_c
   201b3:	0062                                        b.

000201b5 <__FUNCTION__.9357>:
   201b5:	6c61 5f69 696c 6867 5f74 7571 6369 5f6b     ali_light_quick_
   201c5:	6572 7473 726f 5f65 6974 656d 5f72 6263     restore_timer_cb
	...

000201d7 <__FUNCTION__.9362>:
   201d7:	6c61 5f69 696c 6867 5f74 7571 6369 5f6b     ali_light_quick_
   201e7:	6572 7473 726f 5f65 6e69 7469 6100               restore_init.

000201f4 <__FUNCTION__.9373>:
   201f4:	6c61 5f69 696c 6867 5f74 7270 766f 735f     ali_light_prov_s
   20204:	6174 6574 675f 7465 6200 6e6f 2064 7473     tate_get.bond st
   20214:	7461 7375 255b 5d64 6100                         atus[%d].

0002021d <__FUNCTION__.9380>:
   2021d:	6c61 5f69 696c 6867 5f74 6170 6172 5f6d     ali_light_param_
   2022d:	6e69 7469 6400 7665 6369 2065 7974 6570     init.device type
   2023d:	6920 2073 6863 6e61 6567 2064 255b 5d64      is changed [%d]
   2024d:	7420 206f 255b 5d64 4100 494c 5620 4e45      to [%d].ALI VEN
   2025d:	4f44 2052 4552 5643 6100                         DOR RECV.

00020266 <__FUNCTION__.9395>:
   20266:	6c61 5f69 696c 6867 5f74 6e69 7469 2d00     ali_light_init.-
   20276:	2d2d 2d2d 2d2d 6e69 7469 6c20 6769 7468     ------init light
   20286:	2d2d 2d2d 2d2d 2d2d 002d                    ---------.

00020290 <lgs>:
   20290:	4d5b 474c 005d                              [MLG].

00020296 <lge>:
   20296:	0a0d 2e00 5c2e 2e2e 2e5c 5c2e 656d 6873     .....\..\..\mesh
   202a6:	612f 7070 612f 696c 735f 636f 656b 2f74     /app/ali_socket/
   202b6:	6c61 5f69 6f73 6b63 7465 632e 2500 5b73     ali_socket.c.%s[
   202c6:	3125 7330 253a 5d64 7325 003a               %10s:%d]%s:.

000202d2 <__FUNCTION__.9176>:
   202d2:	6c61 5f69 6f73 6b63 7465 625f 6e69 5f64     ali_socket_bind_
   202e2:	6974 656d 5f72 6263 6d00 745f 5f62 656b     timer_cb.m_tb_ke
   202f2:	5f79 7061 5f70 6966 646e 6520 7272 726f     y_app_find error
   20302:	2500 0073 7473 7461 7375 255b 5d78 6c00     .%s.status[%x].l
   20312:	6465 7320 6174 7574 2073 203d 6425 6100          ed status = %d.

00020321 <__FUNCTION__.9202>:
   20321:	6c61 5f69 6f73 6b63 7465 625f 6e74 675f     ali_socket_btn_g
   20331:	7465 745f 6d69 7265 635f 0062 6176 5b6c     et_timer_cb.val[
   20341:	7825 005d 6c61 5f69 6f73 6b63 7465 695f     %x].ali_socket_i
   20351:	646e 735f 7374 745f 6d69 7265 635f 0062     nd_sts_timer_cb.

00020361 <__FUNCTION__.9215>:
   20361:	6c61 5f69 6f73 6b63 7465 705f 6f72 5f76     ali_socket_prov_
   20371:	7473 7461 5f65 6567 0074 6f62 6e75 2064     state_get.bound 
   20381:	6173 7574 5b73 6425 005d                    satus[%d].

0002038b <__FUNCTION__.9224>:
   2038b:	6c61 5f69 6f73 6b63 7465 665f 6361 6f74     ali_socket_facto
   2039b:	7972 725f 7365 7465 6100                         ry_reset.

000203a4 <__FUNCTION__.9233>:
   203a4:	6c61 5f69 6f73 6b63 7465 695f 696e 0074     ali_socket_init.
   203b4:	6564 6976 6563 7420 7079 2065 7369 6320     device type is c
   203c4:	6168 676e 6465 5b20 6425 205d 6f74 5b20     hanged [%d] to [
   203d4:	6425 005d 5f70 6c61 5f69 6f73 6b63 7465     %d].p_ali_socket
   203e4:	255b 5d70 6520 6552 616c 5379 255b 5d70     [%p] eRelayS[%p]
	...

000203f5 <__FUNCTION__.9248>:
   203f5:	6c61 5f69 6f73 6b63 7465 655f 656c 5f63     ali_socket_elec_
   20405:	6572 616c 5f79 6573 0074 7463 6c72 7420     relay_set.ctrl t
   20415:	206f 255b 5d78 6100 696c 735f 636f 656b     o [%x].ali_socke
   20425:	5f74 6c65 6365 725f 6c65 7961 735f 7465     t_elec_relay_set
   20435:	7320 7661 2065 6164 6174 5b00                     save data.

00020440 <lgs>:
   20440:	4d5b 474c 005d                              [MLG].

00020446 <lge>:
   20446:	0a0d 2e00 5c2e 2e2e 2e5c 5c2e 656d 6873     .....\..\..\mesh
   20456:	612f 7070 612f 696c 485f 6165 6974 676e     /app/ali_Heating
   20466:	6154 6c62 2f65 6c61 5f69 6548 7461 6e69     Table/ali_Heatin
   20476:	5467 6261 656c 632e 2500 5b73 3125 7330     gTable.c.%s[%10s
   20486:	253a 5d64 7325 003a                         :%d]%s:.

0002048e <__FUNCTION__.9313>:
   2048e:	625f 6e69 5f64 6974 656d 5f72 6263 6d00     _bind_timer_cb.m
   2049e:	745f 5f62 656b 5f79 7061 5f70 6966 646e     _tb_key_app_find
   204ae:	6520 7272 726f 2500 0073 2d74 6c3e 6469      error.%s.t->lid
   204be:	255b 5d78 7020 7473 6548 7461 6154 6c62     [%x] pstHeatTabl
   204ce:	2d65 6d3e 646f 6c65 635f 746e 255b 5d78     e->model_cnt[%x]
   204de:	7320 6174 7574 5b73 7825 005d 705f 7265      status[%x]._per
   204ee:	6f69 5f64 6e69 5f64 6974 656d 5f72 6263     iod_ind_timer_cb
	...

000204ff <__FUNCTION__.9335>:
   204ff:	715f 6975 6b63 725f 7365 6f74 6572 745f     _quick_restore_t
   2050f:	6d69 7265 635f 0062 5f00                         imer_cb..

00020518 <__FUNCTION__.9354>:
   20518:	705f 7261 6d61 695f 696e 0074 6564 6976     _param_init.devi
   20528:	6563 7420 7079 2065 7369 6320 6168 676e     ce type is chang
   20538:	6465 5b20 6425 205d 6f74 5b20 6425 005d     ed [%d] to [%d].

00020548 <__FUNCTION__.9362>:
   20548:	6c61 5f69 6568 7461 6e69 5f67 6174 6c62     ali_heating_tabl
   20558:	5f65 7270 766f 735f 6174 6574 675f 7465     e_prov_state_get
   20568:	6200 6e6f 2064 7473 7461 7375 255b 5d64     .bond status[%d]
	...

00020579 <__FUNCTION__.9370>:
   20579:	6c61 5f69 6568 7461 6e69 5f67 6174 6c62     ali_heating_tabl
   20589:	5f65 6e69 7469 2d00 2d2d 2d2d 2d2d 6e69     e_init.-------in
   20599:	7469 6c20 6769 7468 2d2d 2d2d 2d2d 2d2d     it light--------
   205a9:	002d                                        -.

000205ab <__FUNCTION__.9340>:
   205ab:	715f 6975 6b63 725f 7365 6f74 6572 695f     _quick_restore_i
   205bb:	696e 0074 656c 2064 7473 7461 7375 3d20     nit.led status =
   205cb:	2520 0064                                    %d.

000205cf <lgs>:
   205cf:	4d5b 474c 005d                              [MLG].

000205d5 <lge>:
   205d5:	0a0d 6100 696c 635f 6e6f 6966 5f67 7561     ...ali_config_au
   205e5:	6874 765f 6c61 725f 6165 0064 2e2e 2e5c     th_val_read...\.
   205f5:	5c2e 2e2e 6d5c 7365 2f68 7061 2f70 6c61     .\..\mesh/app/al
   20605:	5f69 6f63 666e 6769 632e 2500 5b73 3125     i_config.c.%s[%1
   20615:	7330 253a 5d64 7325 003a                    0s:%d]%s:.

0002061f <__FUNCTION__.8844>:
   2061f:	6c61 5f69 6f63 666e 6769 705f 6469 725f     ali_config_pid_r
   2062f:	6165 0064 7270 646f 6375 5f74 6469 3d20     ead.product_id =
   2063f:	2520 0d64 000a 7325 6100                          %d...%s.

00020648 <__FUNCTION__.8861>:
   20648:	6c61 5f69 6f63 666e 6769 645f 7461 5f61     ali_config_data_
   20658:	6e69 7469 6300 6372 5b63 7825 205d 7263     init.crcc[%x] cr
   20668:	7363 255b 5d78 0000                         cs[%x]..

00020670 <co_rate_to_phy_mask>:
   20670:	0201 0404                                   ....

00020674 <co_phy_value_to_mask>:
   20674:	0100 0402                                   ....

00020678 <co_phy_mask_to_value>:
   20678:	0100 0002 0003                                   .....

0002067d <co_phy_to_rate>:
   2067d:	0000 0301                                   ....

00020681 <co_rate_to_phy>:
   20681:	0201 0303 0100                                   .....

00020686 <co_default_bdaddr>:
   20686:	2301 6745 ab89                              .#Eg..

0002068c <co_null_bdaddr>:
   2068c:	0000 0000 0000                              ......

00020692 <co_sca2ppm>:
   20692:	01f4 00fa 0096 0064 004b 0032 001e 0014     ......d.K.2.....

000206a2 <one_bits>:
   206a2:	0100 0201 0201 0302 0201 0302 0302 0403     ................

000206b2 <lgs>:
   206b2:	4d5b 474c 005d                              [MLG].

000206b8 <lge>:
   206b8:	0a0d 5b00 656c 3d6e 6425 0d5d 000a 7830     ...[len=%d]...0x
   206c8:	3025 5832 002c 0a0d 0000 0000               %02X,.......

000206d4 <lgs>:
   206d4:	4d5b 474c 005d                              [MLG].

000206da <lge>:
   206da:	0a0d 0000 0000                              ......

000206e0 <m_al_adv_api>:
   206e0:	4cc9 0000 4d15 0000 4b7d 0000 2e2e 2e5c     .L...M..}K....\.
   206f0:	5c2e 2e2e 6d5c 7365 2f68 5f6d 6c61 6d2f     .\..\mesh/m_al/m
   20700:	615f 5f6c 6461 2e76 0063 7325 255b 3031     _al_adv.c.%s[%10
   20710:	3a73 6425 255d 3a73 6d00                         s:%d]%s:.

00020719 <__FUNCTION__.8888>:
   20719:	5f6d 6c61 615f 7664 735f 6e65 0064 2500     m_al_adv_send..%
   20729:	0073 6572 7663 6120 7664 6420 7461 0061     s.recv adv data.

00020739 <lgs>:
   20739:	4d5b 474c 005d                              [MLG].

0002073f <lge>:
   2073f:	0a0d 6100 7365 6b20 7965 6100 7365 7620     ...aes key.aes v
   2074f:	6c61 6100 7365 7220 7365 6100 7365 7220     al.aes res.aes r
   2075f:	6e61 2064 6572 0073 6d63 6361 6b20 7965     and res.cmac key
   2076f:	7620 6c61 6300 616d 2063 656d 7373 6761      val.cmac messag
   2077f:	2065 6176 006c 3173 6d20 7365 6173 6567     e val.s1 message
   2078f:	7300 2031 6572 0073 316b 7320 6c61 0074     .s1 res.k1 salt.
   2079f:	316b 6e20 6b00 2031 0070 316b 7220 7365     k1 n.k1 p.k1 res
   207af:	6b00 2032 006e 326b 7020 6b00 2032 6572     .k2 n.k2 p.k2 re
   207bf:	0073 336b 6e20 6b00 2033 6572 0073 346b     s.k3 n.k3 res.k4
   207cf:	6e20 6b00 2034 6572 0073 6363 206d 656b      n.k4 res.ccm ke
   207df:	0079 6363 206d 6f6e 636e 0065 6363 206d     y.ccm nonce.ccm 
   207ef:	6e69 6d20 7365 6173 6567 2e00 5c2e 2e2e     in message...\..
   207ff:	2e5c 5c2e 656d 6873 702f 726f 2f74 6f70     \..\mesh/port/po
   2080f:	7472 6553 2e63 0068 7325 255b 3031 3a73     rtSec.h.%s[%10s:
   2081f:	6425 255d 3a73 6d00                              %d]%s:.

00020826 <__FUNCTION__.9093>:
   20826:	656d 6873 735f 6365 615f 7365 635f 6d63     mesh_sec_aes_ccm
   20836:	6300 6d63 6d20 6369 6c5f 6e65 3d20 2520     .ccm mic_len = %
   20846:	0064 7325 6300 6d63 6320 7069 6568 2072     d.%s.ccm cipher 
   20856:	203d 6425 6300 6d63 6120 7475 2068 6164     = %d.ccm auth da
   20866:	6174 2e00 5c2e 2e2e 2e5c 5c2e 656d 6873     ta...\..\..\mesh
   20876:	6d2f 615f 2f6c 5f6d 6c61 735f 6365 632e     /m_al/m_al_sec.c
	...

00020887 <__FUNCTION__.9205>:
   20887:	5f6d 6c61 735f 6365 705f 6275 6b5f 7965     m_al_sec_pub_key
   20897:	725f 6165 0064 0000 5b00                         _read....

000208a0 <lgs>:
   208a0:	4d5b 474c 005d                              [MLG].

000208a6 <lge>:
   208a6:	0a0d 0000 0000                              ......

000208ac <m_al_msg_handler_tab>:
   208ac:	ffff 0000 557d 0000 0000 0000 4daf 0000     ....}U.......M..
   208bc:	0001 0000 4d51 0000 2e2e 2e5c 5c2e 2e2e     ....QM....\..\..
   208cc:	6d5c 7365 2f68 5f6d 6c61 6d2f 615f 5f6c     \mesh/m_al/m_al_
   208dc:	6174 6b73 632e 2500 5b73 3125 7330 253a     task.c.%s[%10s:%
   208ec:	5d64 7325 003a                              d]%s:.

000208f2 <__FUNCTION__.9549>:
   208f2:	5f6d 6c61 695f 696e 0074 5f70 6c61 655f     m_al_init.p_al_e
   20902:	766e 3d20 2520 0070 7325 6d00                    nv = %p.%s.

0002090d <__FUNCTION__.9570>:
   2090d:	5f6d 6c61 695f 746e 6d5f 7365 6173 6567     m_al_int_message
   2091d:	685f 6e61 6c64 7265 6d00 6773 695f 5b64     _handler.msg_id[
   2092d:	7825 205d 7273 5f63 6469 255b 5d78 5b00          %x] src_id[%x].

0002093c <lgs>:
   2093c:	4d5b 474c 005d                              [MLG].

00020942 <lge>:
   20942:	0a0d 2e00 5c2e 2e2e 2e5c 5c2e 656d 6873     .....\..\..\mesh
   20952:	6d2f 646f 6c65 2f73 7273 2f63 6d6d 635f     /models/src/mm_c
   20962:	6d6f 632e 2500 5b73 3125 7330 253a 5d64     om.c.%s[%10s:%d]
   20972:	7325 003a                                   %s:.

00020976 <__FUNCTION__.8544>:
   20976:	6d5f 646f 6c65 5f73 7872 635f 0062 6f6d     _models_rx_cb.mo
   20986:	6564 5f6c 696c 5b64 6425 205d 706f 6f63     del_lid[%d] opco
   20996:	6564 305b 2578 5d78 2500 0073               de[0x%x].%s.

000209a2 <__FUNCTION__.8572>:
   209a2:	6d5f 646f 6c65 5f73 6573 746e 635f 0062     _models_sent_cb.
   209b2:	6f6d 6564 5f6c 696c 5b64 7825 205d 7874     model_lid[%x] tx
   209c2:	685f 6c64 305b 2578 5d78 5f00                    _hdl[0x%x].

000209cd <__FUNCTION__.8578>:
   209cd:	6d5f 646f 6c65 5f73 7570 6c62 7369 5f68     _models_publish_
   209dd:	6570 6972 646f 635f 0062 696c 5b64 7825     period_cb.lid[%x
   209ed:	205d 6570 6972 646f 6d5f 5b73 7825 005d     ] period_ms[%x].
   209fd:	0000 3500                                        ...

00020a00 <_models_cb>:
   20a00:	5735 0000 5855 0000 5811 0000 58a5 0000     5W..UX...X...X..

00020a10 <__FUNCTION__.8588>:
   20a10:	6362 6d5f 5f6d 6572 6967 7473 7265 6d5f     bc_mm_register_m
   20a20:	646f 6c65 0073 4449 255b 5d78 4f20 4646     odels.ID[%x] OFF
   20a30:	255b 5d78 5620 4e45 255b 5d78 4c20 4449     [%x] VEN[%x] LID
   20a40:	255b 5d78 5b00                                   [%x].

00020a45 <lgs>:
   20a45:	4d5b 474c 005d                              [MLG].

00020a4b <lge>:
   20a4b:	0a0d 3100 3200 2e00 5c2e 2e2e 2e5c 5c2e     ...1.2...\..\..\
   20a5b:	656d 6873 6d2f 646f 6c65 2f73 7273 2f63     mesh/models/src/
   20a6b:	6c61 2f69 6576 646e 726f 2f73 6d6d 615f     ali/vendors/mm_a
   20a7b:	696c 2e73 0063 7325 255b 3031 3a73 6425     lis.c.%s[%10s:%d
   20a8b:	255d 3a73 6200                                   ]%s:.

00020a90 <__FUNCTION__.9378>:
   20a90:	6362 6d5f 5f6d 6c61 7369 6f5f 6370 646f     bc_mm_alis_opcod
   20aa0:	5f65 6863 6365 006b 706f 255b 5d78 2500     e_check.op[%x].%
   20ab0:	0073 6c61 7369 6d5f 6d5f 646f 6c65 725f     s.alis_m_model_r
   20ac0:	6365 5f76 6c61 7369 6d5f 6773 6200               ecv_alis_msg.

00020acd <__FUNCTION__.9403>:
   20acd:	6362 6d5f 5f6d 6c61 7369 735f 6e65 5f64     bc_mm_alis_send_
   20add:	6e69 6964 6163 6974 6e6f 6d00 5f6d 6c61     indication.mm_al
   20aed:	7369 745f 3e2d 696c 5b64 7825 205d 7473     is_t->lid[%x] st
   20afd:	5b73 7825 005d                              s[%x].

00020b03 <__FUNCTION__.9420>:
   20b03:	6362 6d5f 5f6d 6c61 5f69 6576 646e 726f     bc_mm_ali_vendor
   20b13:	735f 6e65 0064                              _send.

00020b19 <__FUNCTION__.9426>:
   20b19:	6362 6d5f 5f6d 6c61 7369 675f 7465 725f     bc_mm_alis_get_r
   20b29:	6e61 6f64 5f6d 6974 656d 7400 255b 5d78     andom_time.t[%x]
	...

00020b3a <lgs>:
   20b3a:	4d5b 474c 005d                              [MLG].

00020b40 <__FUNCTION__.6398>:
   20b40:	6362 6d5f 5f6d 6567 5f6e 6e6f 666f 5f66     bc_mm_gen_onoff_
   20b50:	706f 6f63 6564 635f 6568 6b63 0d00               opcode_check.

00020b5d <lge>:
   20b5d:	0a0d 6200                                        ...

00020b60 <__FUNCTION__.6404>:
   20b60:	6362 6d5f 5f6d 6572 7663 675f 6e65 6f5f     bc_mm_recv_gen_o
   20b70:	6f6e 6666 6d5f 6773 2e00 5c2e 2e2e 2e5c     noff_msg...\..\.
   20b80:	5c2e 656d 6873 6d2f 646f 6c65 2f73 7273     .\mesh/models/sr
   20b90:	2f63 6567 2f6e 6567 736e 622f 5f63 6d6d     c/gen/gens/bc_mm
   20ba0:	675f 6e65 5f73 6f6f 632e 2500 5b73 3125     _gens_oo.c.%s[%1
   20bb0:	7330 253a 5d64 7325 003a 706f 6f63 6564     0s:%d]%s:.opcode
   20bc0:	3d20 2520 3830 0078 7325 6f00 6370 646f      = %08x.%s.opcod
   20bd0:	2065 203d 7830 3025 7838 6920 646e 3e2d     e = 0x%08x ind->
   20be0:	6f6d 6564 5f6c 696c 2064 203d 7825 6200     model_lid = %x.b
   20bf0:	5f63 6d6d 725f 6365 5f76 6567 5f6e 6e6f     c_mm_recv_gen_on
   20c00:	666f 5f66 736d 0067 7473 5b73 7825 005d     off_msg.sts[%x].

00020c10 <lgs>:
   20c10:	4d5b 474c 005d                              [MLG].

00020c16 <lge>:
   20c16:	0a0d 2e00 5c2e 2e2e 2e5c 5c2e 656d 6873     .....\..\..\mesh
   20c26:	6d2f 646f 6c65 2f73 7273 2f63 696c 6867     /models/src/ligh
   20c36:	2f74 696c 6867 7374 622f 5f63 6d6d 6c5f     t/lights/bc_mm_l
   20c46:	6769 7468 5f73 6e6c 632e 2500 5b73 3125     ights_ln.c.%s[%1
   20c56:	7330 253a 5d64 7325 003a                    0s:%d]%s:.

00020c60 <__FUNCTION__.8715>:
   20c60:	6362 6d5f 5f6d 696c 6867 6e74 7365 5f73     bc_mm_lightness_
   20c70:	706f 6f63 6564 635f 6568 6b63 6f00 6370     opcode_check.opc
   20c80:	646f 2065 203d 3025 7838 2500 0073          ode = %08x.%s.

00020c8e <__FUNCTION__.8722>:
   20c8e:	6362 6d5f 5f6d 6572 7663 6c5f 6769 7468     bc_mm_recv_light
   20c9e:	656e 7373 6d5f 6773 6c00 7665 6c65 255b     ness_msg.level[%
   20cae:	5d78 5420 4449 255b 5d78 5b00                    x] TID[%x].

00020cb9 <lgs>:
   20cb9:	4d5b 474c 005d                              [MLG].

00020cbf <lge>:
   20cbf:	0a0d 2e00 5c2e 2e2e 2e5c 5c2e 656d 6873     .....\..\..\mesh
   20ccf:	6d2f 646f 6c65 2f73 7273 2f63 696c 6867     /models/src/ligh
   20cdf:	2f74 696c 6867 7374 622f 5f63 6d6d 6c5f     t/lights/bc_mm_l
   20cef:	6769 7468 5f73 7463 2e6c 0063 7325 255b     ights_ctl.c.%s[%
   20cff:	3031 3a73 6425 255d 3a73 6200                    10s:%d]%s:.

00020d0a <__FUNCTION__.8745>:
   20d0a:	6362 6d5f 5f6d 7463 5f6c 706f 6f63 6564     bc_mm_ctl_opcode
   20d1a:	635f 6568 6b63 6f00 6370 646f 2065 203d     _check.opcode = 
   20d2a:	3025 7838 2500 0073                         %08x.%s.

00020d32 <__FUNCTION__.8752>:
   20d32:	6362 6d5f 5f6d 6572 7663 635f 6c74 6d5f     bc_mm_recv_ctl_m
   20d42:	6773 7400 6d65 6570 6172 7574 6572 5b3a     sg.temperature:[
   20d52:	7825 205d 6974 5b64 7825 005d 7473 5b73     %x] tid[%x].sts[
   20d62:	7825 005d                                   %x].

00020d66 <lgs>:
   20d66:	4d5b 474c 005d                              [MLG].

00020d6c <lge>:
   20d6c:	0a0d 5b00                                        ...

00020d6f <lgs>:
   20d6f:	4d5b 474c 005d                              [MLG].

00020d75 <lge>:
   20d75:	0a0d 2e00 5c2e 2e2e 2e5c 5c2e 656d 6873     .....\..\..\mesh
   20d85:	702f 726f 2f74 6365 2e63 0063 7325 255b     /port/ecc.c.%s[%
   20d95:	3031 3a73 6425 255d 3a73 6500                    10s:%d]%s:.

00020da0 <__FUNCTION__.9881>:
   20da0:	6365 6864 735f 6168 6572 5f64 6573 7263     ecdh_shared_secr
   20db0:	7465 6500 6463 5f68 6873 7261 6465 735f     et.ecdh_shared_s
   20dc0:	6365 6572 2e74 0a20 2500 0073 6365 5f63     ecret. ..%s.ecc_
   20dd0:	6176 696c 5f64 6f70 6e69 2074 6166 6c69     valid_point fail
   20de0:	6465 202e 000a                              ed. ..

00020de6 <lgs>:
   20de6:	4d5b 474c 005d                              [MLG].

00020dec <lge>:
   20dec:	0a0d 5b00                                        ...

00020def <lgs>:
   20def:	4d5b 474c 005d                              [MLG].

00020df5 <lge>:
   20df5:	0a0d 2e00 5c2e 2e2e 2e5c 5c2e 656d 6873     .....\..\..\mesh
   20e05:	702f 726f 2f74 6f70 7472 6c42 2e65 0063     /port/portBle.c.
   20e15:	7325 255b 3031 3a73 6425 255d 3a73 6d00          %s[%10s:%d]%s:.

00020e24 <__FUNCTION__.9516>:
   20e24:	656d 6873 625f 656c 735f 6174 7472 0000     mesh_ble_start..
   20e34:	7325 6d00                                        %s.

00020e37 <__FUNCTION__.9523>:
   20e37:	656d 6873 625f 656c 735f 6f74 0070 6c63     mesh_ble_stop.cl
   20e47:	736f 2065 6f6e 636e 6e6f 656e 7463 6120     ose nonconnect a
   20e57:	7664 6d00                                        dv.

00020e5a <__FUNCTION__.9538>:
   20e5a:	656d 6873 615f 7664 645f 7461 5f61 6573     mesh_adv_data_se
   20e6a:	646e 6900 6c74 255b 5d64 6e20 5b62 6425     nd.itl[%d] nb[%d
   20e7a:	005d 656d 6873 6120 7664 6420 7461 2061     ].mesh adv data 
   20e8a:	6573 646e 0200 0201                         send....

00020e92 <__FUNCTION__.9546>:
   20e92:	656d 6873 635f 6e6f 615f 7664 645f 7461     mesh_con_adv_dat
   20ea2:	5f61 6573 646e 6900 6c74 3d20 2520 0064     a_send.itl = %d.
   20eb2:	656d 6873 6320 6e6f 6120 7664 6420 7461     mesh con adv dat
   20ec2:	2061 6573 646e 6d00                              a send.

00020ec9 <__FUNCTION__.9551>:
   20ec9:	656d 6873 635f 6e6f 615f 7664 735f 6f74     mesh_con_adv_sto
   20ed9:	0070                                        p.

00020edb <__FUNCTION__.9556>:
   20edb:	656d 6873 635f 6e6f 735f 6f74 0070          mesh_con_stop.

00020ee9 <__FUNCTION__.9561>:
   20ee9:	656d 6873 615f 7664 735f 6163 5f6e 7473     mesh_adv_scan_st
   20ef9:	7261 0074 7469 206c 203d 7830 3025 7832     art.itl = 0x%02x
	...

00020f0a <__FUNCTION__.9566>:
   20f0a:	656d 6873 615f 7664 735f 6163 5f6e 7473     mesh_adv_scan_st
   20f1a:	706f 6d00                                        op.

00020f1d <__FUNCTION__.9573>:
   20f1d:	656d 6873 635f 6e6f 6e5f 746f 6669 0079     mesh_con_notify.

00020f2d <__FUNCTION__.9590>:
   20f2d:	656d 6873 635f 6e6f 725f 6165 5f64 6663     mesh_con_read_cf
   20f3d:	006d                                        m.

00020f3f <__FUNCTION__.9595>:
   20f3f:	656d 6873 635f 6e6f 775f 6972 6574 725f     mesh_con_write_r
   20f4f:	7073 6700                                        sp.

00020f52 <__FUNCTION__.9600>:
   20f52:	6167 7474 5f63 6567 5f74 746d 0075          gattc_get_mtu.

00020f60 <__FUNCTION__.9606>:
   20f60:	7461 6d74 725f 7365 7265 6576 685f 6e61     attm_reserve_han
   20f70:	6c64 5f65 6172 676e 0065                    dle_range.

00020f7a <__FUNCTION__.9618>:
   20f7a:	7461 6d74 735f 6376 635f 6572 7461 5f65     attm_svc_create_
   20f8a:	6264 6100                                        db.

00020f8d <__FUNCTION__.9624>:
   20f8d:	7461 6d74 6264 735f 6376 765f 7369 6269     attmdb_svc_visib
   20f9d:	6c69 7469 5f79 6573 0074 6573 2074 616d     ility_set.set ma
   20fad:	0063                                        c.

00020faf <__FUNCTION__.9635>:
   20faf:	656d 6873 6d5f 6361 675f 7465 6d00               mesh_mac_get.

00020fbc <__FUNCTION__.9642>:
   20fbc:	656d 6873 665f 616c 6873 725f 6165 0064     mesh_flash_read.
   20fcc:	6461 7264 253d 3830 0078 6572 6461 6520     addr=%08x.read e
   20fdc:	646e 6d00                                        nd.

00020fdf <__FUNCTION__.9652>:
   20fdf:	656d 6873 665f 616c 6873 775f 6972 6574     mesh_flash_write
   20fef:	6100 6464 2072 203d 3025 7838 7700 6972     .addr = %08x.wri
   20fff:	6574 6420 7461 0061 7277 7469 2065 6e65     te data.write en
   2100f:	0064                                        d.

00021011 <__FUNCTION__.9663>:
   21011:	656d 6873 665f 616c 6873 775f 6972 6574     mesh_flash_write
   21021:	6e5f 7265 7361 0065                         _nerase.

00021029 <__FUNCTION__.9671>:
   21029:	656d 6873 665f 616c 6873 655f 6172 6573     mesh_flash_erase
   21039:	6500 6172 6573 6420 7461 2061 6461 7264     .erase data addr
   21049:	303d 2578 3830 0078                         =0x%08x.

00021051 <lgs>:
   21051:	4d5b 474c 005d                              [MLG].

00021057 <lge>:
   21057:	0a0d 0000                                        ...

0002105a <const_Rb>:
	...
   21066:	0000 8700                                   ....

0002106a <const_Zero>:
	...
   2107a:	6d63 6361 7220 7365 6c75 0074               cmac result.

00021086 <smk2>:
   21086:	6d73 326b                                   smk2

0002108a <smk3>:
   2108a:	6d73 336b                                   smk3

0002108e <smk4>:
   2108e:	6d73 346b                                   smk4

00021092 <t1>:
   21092:	0201                                             .

00021093 <t2>:
   21093:	0302                                             .

00021094 <t3>:
   21094:	6903 3664 0134 6469 0136 6363 206d 6e65     .id64.id6.ccm en
   210a4:	7263 7079 2074 6572 0073 6363 206d 6564     crypt res.ccm de
   210b4:	7263 7079 2074 7573 6363 7365 0073 2e2e     crypt success...
   210c4:	2e5c 5c2e 2e2e 6d5c 7365 2f68 6f70 7472     \..\..\mesh/port
   210d4:	702f 726f 5374 6365 632e 2500 5b73 3125     /portSec.c.%s[%1
   210e4:	7330 253a 5d64 7325 003a                    0s:%d]%s:.

000210ee <__FUNCTION__.9846>:
   210ee:	656d 6873 615f 7365 635f 6d63 6300 6d63     mesh_aes_ccm.ccm
   210fe:	6420 6365 7972 7470 6520 7272 726f 2500      decrypt error.%
   2110e:	0073                                        s.

00021110 <__FUNCTION__.9870>:
   21110:	656d 6873 705f 6275 6b5f 7965 725f 6165     mesh_pub_key_rea
   21120:	0064 6572 656e 2077 203d 6425 6c00 636f     d.renew = %d.loc
   21130:	6c61 7220 6165 2064 7570 5f62 656b 5f79     al read pub_key_
   21140:	0078 6f6c 6163 206c 6572 6461 7020 6275     x.local read pub
   21150:	6b5f 7965 795f 6c00 636f 6c61 7220 6165     _key_y.local rea
   21160:	2064 7270 5f76 656b 0079 6365 6864 735f     d prv_key.ecdh_s
   21170:	6365 6572 2074 5f70 7570 5f62 656b 5f79     ecret p_pub_key_
   21180:	0078 6365 6864 735f 6365 6572 2074 5f70     x.ecdh_secret p_
   21190:	7570 5f62 656b 5f79 0079 6365 6864 735f     pub_key_y.ecdh_s
   211a0:	6365 6572 2074 7270 5f76 656b 0079 6365     ecret prv_key.ec
   211b0:	6864 735f 6365 6572 2074 6572 0073 0000     dh_secret res...

000211c0 <xHeapStructSize>:
   211c0:	0008 0000                                   ....

000211c4 <lgs>:
   211c4:	4d5b 474c 005d                              [MLG].

000211ca <lge>:
   211ca:	0a0d 2e00 5c2e 2e2e 2e5c 5c2e 656d 6873     .....\..\..\mesh
   211da:	732f 6372 6d2f 615f 6970 632e 2500 5b73     /src/m_api.c.%s[
   211ea:	3125 7330 253a 5d64 7325 003a               %10s:%d]%s:.

000211f6 <__FUNCTION__.10117>:
   211f6:	5f6d 7061 5f69 6562 7261 7265 6f5f 6570     m_api_bearer_ope
   21206:	6172 6974 6e6f 6f5f 6570 5f6e 6263 0000     ration_open_cb..
   21216:	7325 5300 6174 7472 7020 6f72 6976 6973     %s.Start provisi
   21226:	6e6f 6e69 0067                              oning.

0002122c <__FUNCTION__.10217>:
   2122c:	5f6d 7061 5f69 656d 7373 6761 5f65 6168     m_api_message_ha
   2123c:	646e 656c 0072 736d 5f67 6469 255b 5d78     ndler.msg_id[%x]
   2124c:	7320 6372 695f 5b64 7825 005d                src_id[%x].

00021258 <__FUNCTION__.10234>:
   21258:	6362 6d5f 735f 6e65 5f64 7461 6574 746e     bc_m_send_attent
   21268:	6f69 5f6e 7075 6164 6574 695f 646e 2500     ion_update_ind.%
   21278:	0064                                        d.

0002127a <__FUNCTION__.10239>:
   2127a:	6362 6d5f 735f 6e65 5f64 6f63 706d 5f6f     bc_m_send_compo_
   2128a:	6164 6174 725f 7165 695f 646e 6200               data_req_ind.

00021297 <__FUNCTION__.10244>:
   21297:	6362 6d5f 735f 6e65 5f64 6166 6c75 5f74     bc_m_send_fault_
   212a7:	6567 5f74 6572 5f71 6e69 0064               get_req_ind.

000212b3 <__FUNCTION__.10251>:
   212b3:	6362 6d5f 735f 6e65 5f64 6166 6c75 5f74     bc_m_send_fault_
   212c3:	6574 7473 725f 7165 695f 646e 6200               test_req_ind.

000212d0 <__FUNCTION__.10256>:
   212d0:	6362 6d5f 735f 6e65 5f64 6166 6c75 5f74     bc_m_send_fault_
   212e0:	6c63 6165 5f72 6e69 0064                    clear_ind.

000212ea <__FUNCTION__.10262>:
   212ea:	6362 6d5f 735f 6e65 5f64 6166 6c75 5f74     bc_m_send_fault_
   212fa:	6570 6972 646f 695f 646e 6200                    period_ind.

00021305 <__FUNCTION__.10272>:
   21305:	6362 6d5f 735f 6e65 5f64 6f6e 6564 725f     bc_m_send_node_r
   21315:	7365 7465 695f 646e 0100 0100 0200 0300     eset_ind........
   21325:	0400 0800 0000 5b00                              .......

0002132c <lgs>:
   2132c:	4d5b 474c 005d                              [MLG].

00021332 <lge>:
   21332:	0a0d 2e00 5c2e 2e2e 2e5c 5c2e 656d 6873     .....\..\..\mesh
   21342:	732f 6372 6d2f 625f 6e63 6d2f 625f 6e63     /src/m_bcn/m_bcn
   21352:	632e 2500 5b73 3125 7330 253a 5d64 7325     .c.%s[%10s:%d]%s
   21362:	003a                                        :.

00021364 <__FUNCTION__.9096>:
   21364:	5f6d 6362 5f6e 6461 5f76 7874 635f 6568     m_bcn_adv_tx_che
   21374:	6b63 0000 7325 6d00                              ck..%s.

0002137b <__FUNCTION__.9111>:
   2137b:	5f6d 6362 5f6e 6573 646e 6d00                    m_bcn_send.

00021386 <__FUNCTION__.9154>:
   21386:	5f6d 6362 5f6e 7270 7065 735f 6365 7275     m_bcn_prep_secur
   21396:	5f65 6362 006e 6562 6361 6e6f 6420 7461     e_bcn.beacon dat
   213a6:	2061 6572 7663 6465 6d00                         a recved.

000213af <__FUNCTION__.9198>:
   213af:	5f6d 6362 5f6e 6263 745f 6d69 7265 625f     m_bcn_cb_timer_b
   213bf:	6e63 655f 7078 7269 6465 0000 2500               cn_expired...

000213cc <m_bcn_cb>:
   213cc:	9725 0000 96a5 0000 9761 0000 97c1 0000     %.......a.......

000213dc <__FUNCTION__.9242>:
   213dc:	5f6d 6362 5f6e 7473 7261 5f74 7874 755f     m_bcn_start_tx_u
   213ec:	706e 6f72 5f76 6362 006e                    nprov_bcn.

000213f6 <__FUNCTION__.9249>:
   213f6:	5f6d 6362 5f6e 7473 706f 745f 5f78 6e75     m_bcn_stop_tx_un
   21406:	7270 766f 625f 6e63 6300 656c 7261 6220     prov_bcn.clear b
   21416:	6e63 7420 6d69 7265 0000                    cn timer..

00021420 <lgs>:
   21420:	4d5b 474c 005d                              [MLG].

00021426 <lge>:
   21426:	0a0d 2e00 5c2e 2e2e 2e5c 5c2e 656d 6873     .....\..\..\mesh
   21436:	732f 6372 6d2f 625f 6165 6572 2f72 5f6d     /src/m_bearer/m_
   21446:	6562 7261 7265 632e 2500 5b73 3125 7330     bearer.c.%s[%10s
   21456:	253a 5d64 7325 003a                         :%d]%s:.

0002145e <__FUNCTION__.9074>:
   2145e:	5f6d 6562 7261 7265 735f 6e65 0064 2500     m_bearer_send..%
   2146e:	0073                                        s.

00021470 <__FUNCTION__.9088>:
   21470:	5f6d 6562 7261 7265 755f 6470 7461 0065     m_bearer_update.

00021480 <__FUNCTION__.9103>:
   21480:	5f6d 6562 7261 7265 735f 6e65 5f64 6f63     m_bearer_send_co
   21490:	746e 6e69 6575 7300 6174 7574 2073 203d     ntinue.status = 
   214a0:	6425 6d00                                        %d.

000214a3 <__FUNCTION__.9133>:
   214a3:	5f6d 6562 7261 7265 735f 6174 7472 6200     m_bearer_start.b
   214b3:	6165 6572 5f72 7974 6570 3d20 2520 0064     earer_type = %d.
   214c3:	6263 655f 646e 3d20 2520 0064               cb_end = %d.

000214cf <__FUNCTION__.9152>:
   214cf:	5f6d 6562 7261 7265 735f 6174 7472 6465     m_bearer_started
   214df:	2500 0070                                   .%p.

000214e3 <CSWTCH.47>:
   214e3:	0100 0002 e100                                   .....

000214e8 <m_bearer_api>:
   214e8:	9be1 0000 9c91 0000                         ........

000214f0 <lgs>:
   214f0:	4d5b 474c 005d                              [MLG].

000214f6 <lge>:
   214f6:	0a0d 0000 0000                              ......

000214fc <m_bearer_adv_cb>:
   214fc:	a1d1 0000 a251 0000 a12d 0000 a121 0000     ....Q...-...!...
   2150c:	2e2e 2e5c 5c2e 2e2e 6d5c 7365 2f68 7273     ..\..\..\mesh/sr
   2151c:	2f63 5f6d 6562 7261 7265 6d2f 625f 6165     c/m_bearer/m_bea
   2152c:	6572 5f72 6461 2e76 0063 7325 255b 3031     rer_adv.c.%s[%10
   2153c:	3a73 6425 255d 3a73 6d00                         s:%d]%s:.

00021545 <__FUNCTION__.9084>:
   21545:	5f6d 6562 7261 7265 615f 7664 725f 0078     m_bearer_adv_rx.
   21555:	2500 0073                                   .%s.

00021559 <__FUNCTION__.9101>:
   21559:	5f6d 6562 7261 7265 615f 7664 735f 6174     m_bearer_adv_sta
   21569:	7472 6465 6d00                                   rted.

0002156e <__FUNCTION__.9133>:
   2156e:	5f6d 6562 7261 7265 615f 7664 745f 5f78     m_bearer_adv_tx_
   2157e:	7270 7065 7261 0065                         prepare.

00021586 <__FUNCTION__.9153>:
   21586:	5f6d 6562 7261 7265 615f 7664 735f 6e65     m_bearer_adv_sen
   21596:	0064 7473 7461 7375 3d20 2520 0064          d.status = %d.

000215a4 <__FUNCTION__.9160>:
   215a4:	5f6d 6562 7261 7265 615f 7664 755f 6470     m_bearer_adv_upd
   215b4:	7461 0065 6361 6974 6e6f 253d 2064 6562     ate.action=%d be
   215c4:	7261 7320 6174 6574 255b 5d78 5b00               ar state[%x].

000215d1 <lgs>:
   215d1:	4d5b 474c 005d                              [MLG].

000215d7 <lge>:
   215d7:	0a0d 0000 5b00                                   .....

000215dc <lgs>:
   215dc:	4d5b 474c 005d                              [MLG].

000215e2 <lge>:
   215e2:	0a0d 3700                                        ...

000215e5 <m_fnd_confs_vtad_salt>:
   215e5:	4f37 0609 d194 aaee af5d c47b fa9d cef7     7O......].{.....
   215f5:	6f6d 6564 5f6c 696c 5b64 7825 205d 656e     model_lid[%x] ne
   21605:	5f74 696c 5b64 7825 205d 7364 5b74 7825     t_lid[%x] dst[%x
   21615:	005d 2e2e 2e5c 5c2e 2e2e 6d5c 7365 2f68     ]...\..\..\mesh/
   21625:	7273 2f63 5f6d 6e66 2f64 5f6d 6e66 5f64     src/m_fnd/m_fnd_
   21635:	6f63 666e 2e73 0063 7325 255b 3031 3a73     confs.c.%s[%10s:
   21645:	6425 255d 3a73 6d00                              %d]%s:.

0002164c <__FUNCTION__.9314>:
   2164c:	5f6d 6e66 5f64 6f63 666e 5f73 6263 615f     m_fnd_confs_cb_a
   2165c:	7070 656b 5f79 6461 6564 0064 656e 6b74     ppkey_added.netk
   2166c:	7965 615f 7070 656b 5f79 6469 3d20 2520     ey_appkey_id = %
   2167c:	0064 7325 6300 6e6f 6966 2067 7061 6b70     d.%s.config appk
   2168c:	7965 7220 6365 2076 6164 6174 0020 6e66     ey recv data .fn
   2169c:	2064 7270 636f 7365 2073 706f 6563 6564     d process opcede
   216ac:	255b 5d78 6d00                                   [%x].

000216b1 <__FUNCTION__.9326>:
   216b1:	5f6d 6e66 5f64 6f63 666e 5f73 6168 646e     m_fnd_confs_hand
   216c1:	656c 5f72 6f6d 6564 5f6c 7573 7362 0000     ler_model_subs..
   216d1:	2d2d 6f6d 6564 5f6c 7061 0070 5f6d 6274     --model_app.m_tb
   216e1:	6d5f 6f69 675f 7465 6c5f 636f 6c61 695f     _mio_get_local_i
   216f1:	2064 7265 6f72 0072 5f6d 6274 6b5f 7965     d error.m_tb_key
   21701:	615f 7070 665f 6e69 2064 7265 6f72 0072     _app_find error.
   21711:	7265 6f72 2072 7473 7461 7375 255b 5d78     error status[%x]
	...

00021722 <__FUNCTION__.9516>:
   21722:	5f6d 6e66 5f64 6f63 666e 5f73 6168 646e     m_fnd_confs_hand
   21732:	656c 5f72 6f63 706d 5f6f 6164 6174 675f     ler_compo_data_g
   21742:	7465 6d00                                        et.

00021745 <__FUNCTION__.9613>:
   21745:	5f6d 6e66 5f64 6f63 666e 5f73 6263 725f     m_fnd_confs_cb_r
   21755:	0078                                        x.

00021757 <__FUNCTION__.9622>:
   21757:	5f6d 6e66 5f64 6f63 666e 5f73 6263 6f5f     m_fnd_confs_cb_o
   21767:	6370 646f 5f65 6863 6365 006b               pcode_check.

00021773 <__FUNCTION__.9633>:
   21773:	5f6d 6e66 5f64 6f63 666e 5f73 6263 735f     m_fnd_confs_cb_s
   21783:	6e65 0074 c100                                   ent..

00021788 <m_fnd_confs_cb>:
   21788:	b9c1 0000 badd 0000 ba4d 0000 0000 0000     ........M.......

00021798 <lgs>:
   21798:	4d5b 474c 005d                              [MLG].

0002179e <lge>:
   2179e:	0a0d 6600 646e 6820 746c 7368 6f20 6370     ...fnd hlths opc
   217ae:	6465 5b65 7825 005d 2e2e 2e5c 5c2e 2e2e     ede[%x]...\..\..
   217be:	6d5c 7365 2f68 7273 2f63 5f6d 6e66 2f64     \mesh/src/m_fnd/
   217ce:	5f6d 6e66 5f64 6c68 6874 2e73 0063 7325     m_fnd_hlths.c.%s
   217de:	255b 3031 3a73 6425 255d 3a73 6d00               [%10s:%d]%s:.

000217eb <__FUNCTION__.9071>:
   217eb:	5f6d 6e66 5f64 6c68 6874 5f73 6263 725f     m_fnd_hlths_cb_r
   217fb:	0078 2500 0073                              x..%s.

00021801 <__FUNCTION__.9079>:
   21801:	5f6d 6e66 5f64 6c68 6874 5f73 6263 6f5f     m_fnd_hlths_cb_o
   21811:	6370 646f 5f65 6863 6365 006b               pcode_check.

0002181d <__FUNCTION__.9089>:
   2181d:	5f6d 6e66 5f64 6c68 6874 5f73 6263 735f     m_fnd_hlths_cb_s
   2182d:	6e65 0074                                   ent.

00021831 <__FUNCTION__.9095>:
   21831:	5f6d 6e66 5f64 6c68 6874 5f73 6263 705f     m_fnd_hlths_cb_p
   21841:	6275 696c 6873 705f 7265 6f69 0064 a900          ublish_period..

00021850 <m_fnd_hlths_cb>:
   21850:	bda9 0000 be91 0000 be25 0000 bedd 0000     ........%.......

00021860 <lgs>:
   21860:	4d5b 474c 005d                              [MLG].

00021866 <lge>:
   21866:	0a0d 2e00 5c2e 2e2e 2e5c 5c2e 656d 6873     .....\..\..\mesh
   21876:	732f 6372 6d2f 6c5f 7961 6d2f 6c5f 7961     /src/m_lay/m_lay
   21886:	615f 6363 7365 2e73 0063 7325 255b 3031     _access.c.%s[%10
   21896:	3a73 6425 255d 3a73 6d00                         s:%d]%s:.

0002189f <__FUNCTION__.9162>:
   2189f:	5f6d 616c 5f79 6361 6563 7373 6d5f 646f     m_lay_access_mod
   218af:	6c65 635f 6568 6b63 0000 7325 7200 6365     el_check..%s.rec
   218bf:	2076 6361 6563 7373 6420 7461 0061 0000     v access data...
	...

000218d0 <m_lay_access_cb>:
   218d0:	c195 0000 c2e9 0000 2d2d 2d2d 2d2d 2d2d     ........--------
   218e0:	6d2d 6c5f 7961 685f 5f62 6263 735f 6174     -m_lay_hb_cb_sta
   218f0:	6574 755f 6470 7461 6465 7420 7079 5b65     te_updated type[
   21900:	7825 2d5d 2d2d 2d2d 7200 6365 2076 6268     %x]-----.recv hb
   21910:	2073 6164 6174 0000                         s data..

00021918 <m_lay_hb_cb>:
   21918:	c779 0000 c781 0000                         y.......

00021920 <m_lay_hb_state_cb>:
   21920:	c715 0000                                   ....

00021924 <lgs>:
   21924:	4d5b 474c 005d                              [MLG].

0002192a <lge>:
   2192a:	0a0d 2e00 5c2e 2e2e 2e5c 5c2e 656d 6873     .....\..\..\mesh
   2193a:	732f 6372 6d2f 6c5f 7961 6d2f 6c5f 7961     /src/m_lay/m_lay
   2194a:	6c5f 7274 6e61 2e73 0063 7325 255b 3031     _ltrans.c.%s[%10
   2195a:	3a73 6425 255d 3a73 6d00                         s:%d]%s:.

00021963 <__FUNCTION__.9250>:
   21963:	5f6d 616c 5f79 746c 6172 736e 735f 6e65     m_lay_ltrans_sen
   21973:	0064 2500 0073 5f6d 616c 5f79 746c 6172     d..%s.m_lay_ltra
   21983:	736e 735f 6e65 0064 6572 7663 6c20 7274     ns_send.recv ltr
   21993:	6e61 2073 6164 6174 9500                         ans data.

0002199c <m_lay_ltrans_api>:
   2199c:	cc95 0000                                   ....

000219a0 <m_lay_ltrans_cb>:
   219a0:	cdc1 0000 cdf9 0000 0000 0000 0000 0000     ................

000219b0 <lgs>:
   219b0:	4d5b 474c 005d                              [MLG].

000219b6 <lge>:
   219b6:	0a0d 2e00 5c2e 2e2e 2e5c 5c2e 656d 6873     .....\..\..\mesh
   219c6:	732f 6372 6d2f 6c5f 7961 6d2f 6c5f 7961     /src/m_lay/m_lay
   219d6:	6e5f 7465 632e 2500 5b73 3125 7330 253a     _net.c.%s[%10s:%
   219e6:	5d64 7325 003a                              d]%s:.

000219ec <__FUNCTION__.9247>:
   219ec:	5f6d 616c 5f79 656e 5f74 6863 6365 5f6b     m_lay_net_check_
   219fc:	6e65 7263 7079 5f74 7571 7565 0065 2500     encrypt_queue..%
   21a0c:	0073                                        s.

00021a0e <__FUNCTION__.9255>:
   21a0e:	5f6d 616c 5f79 656e 5f74 6e65 7263 7079     m_lay_net_encryp
   21a1e:	5f74 7265 0072 2d2d 2d2d 6e65 7263 6f79     t_err.----encryo
   21a2e:	2074 7265 6f72 2d72 2d2d 002d               t error----.

00021a3a <__FUNCTION__.9261>:
   21a3a:	5f6d 616c 5f79 656e 5f74 6564 7263 7079     m_lay_net_decryp
   21a4a:	5f74 7265 0072 2d2d 2d2d 6564 7263 6f79     t_err.----decryo
   21a5a:	2074 7265 6f72 2d72 2d2d 002d               t error----.

00021a66 <__FUNCTION__.9295>:
   21a66:	5f6d 616c 5f79 656e 5f74 6363 5f6d 6e65     m_lay_net_ccm_en
   21a76:	5f63 6966 696e 6873 6465 635f 0062 7473     c_finished_cb.st
   21a86:	7461 7375 3d20 2520 0064                    atus = %d.

00021a90 <__FUNCTION__.9305>:
   21a90:	5f6d 616c 5f79 656e 5f74 626f 7566 6373     m_lay_net_obfusc
   21aa0:	725f 6165 7964 635f 0062 5f70 7562 5f66     _ready_cb.p_buf_
   21ab0:	746c 6172 736e 3d20 2520 0070 5f70 6e65     ltrans = %p.p_en
   21ac0:	5f76 746c 6172 736e 3e2d 656e 5f74 696c     v_ltrans->net_li
   21ad0:	2064 203d 6425 6d00                              d = %d.

00021ad7 <__FUNCTION__.9326>:
   21ad7:	5f6d 616c 5f79 656e 5f74 626f 7566 6373     m_lay_net_obfusc
   21ae7:	665f 6e69 7369 6568 5f64 6263 6e00 7465     _finished_cb.net
   21af7:	6520 636e 7072 2079 6164 6174 6d00                encrpy data.

00021b04 <__FUNCTION__.9352>:
   21b04:	5f6d 616c 5f79 656e 5f74 6564 6f73 6662     m_lay_net_desobf
   21b14:	7375 5f63 6966 696e 6873 6465 635f 0062     usc_finished_cb.
   21b24:	6f74 656b 5f6e 6469 3d20 2520 2064 7473     token_id = %d st
   21b34:	7461 7375 3d20 2520 0064 6572 7663 6420     atus = %d.recv d
   21b44:	7365 626f 7566 6373 6420 7461 0061          esobfusc data.

00021b52 <__FUNCTION__.9389>:
   21b52:	5f6d 616c 5f79 656e 5f74 6363 5f6d 6564     m_lay_net_ccm_de
   21b62:	5f63 6966 696e 6873 6465 635f 0062 7369     c_finished_cb.is
   21b72:	6c5f 636f 6c61 645f 7473 255b 5d64 7020     _local_dst[%d] p
   21b82:	655f 766e 3e2d 7364 5b74 7825 005d          _env->dst[%x].

00021b90 <__FUNCTION__.9236>:
   21b90:	5f6d 616c 5f79 656e 5f74 6863 6365 5f6b     m_lay_net_check_
   21ba0:	6572 616c 0079 7474 5b6c 7825 005d 6863     relay.ttl[%x].ch
   21bb0:	6365 206b 656e 7478 6420 6365 7972 7470     eck next decrypt
	...

00021bc1 <__FUNCTION__.9451>:
   21bc1:	5f6d 616c 5f79 656e 5f74 6573 646e 6900     m_lay_net_send.i
   21bd1:	746e 5f66 7974 6570 3d20 2520 0064 5f6d     ntf_type = %d.m_
   21be1:	616c 5f79 656e 5f74 6573 646e 6300 6d63     lay_net_send.ccm
   21bf1:	6520 636e 6d00                                    enc.

00021bf6 <__FUNCTION__.9462>:
   21bf6:	5f6d 616c 5f79 656e 5f74 6573 746e 7200     m_lay_net_sent.r
   21c06:	6365 2076 656e 2074 6164 6174 0000          ecv net data..

00021c14 <m_lay_net_api>:
   21c14:	de59 0000                                   Y...

00021c18 <m_lay_net_cb>:
   21c18:	dfa1 0000 e079 0000 e17d 0000 e1b1 0000     ....y...}.......

00021c28 <lgs>:
   21c28:	4d5b 474c 005d                              [MLG].

00021c2e <lge>:
   21c2e:	0a0d 2e00 5c2e 2e2e 2e5c 5c2e 656d 6873     .....\..\..\mesh
   21c3e:	732f 6372 6d2f 6c5f 7961 6d2f 6c5f 7961     /src/m_lay/m_lay
   21c4e:	755f 7274 6e61 2e73 0063 7325 255b 3031     _utrans.c.%s[%10
   21c5e:	3a73 6425 255d 3a73 6d00                         s:%d]%s:.

00021c67 <__FUNCTION__.9229>:
   21c67:	5f6d 616c 5f79 7475 6172 736e 635f 6d63     m_lay_utrans_ccm
   21c77:	645f 6365 725f 6165 7964 635f 0062 6567     _dec_ready_cb.ge
   21c87:	2074 6564 2076 656b 0079 7325 6700 7465     t dev key.%s.get
   21c97:	6120 7070 6b20 7965 6120 7070 6c5f 6469      app key app_lid
   21ca7:	3d20 2520 0064 7473 7461 7375 255b 5d78      = %d.status[%x]
	...

00021cb8 <__FUNCTION__.9239>:
   21cb8:	5f6d 616c 5f79 7475 6172 736e 635f 6d63     m_lay_utrans_ccm
   21cc8:	645f 6365 665f 6e69 7369 6568 5f64 6263     _dec_finished_cb
   21cd8:	7400 6b6f 6e65 695f 2064 203d 6425 7320     .token_id = %d s
   21ce8:	6174 7574 2073 203d 6425 6700 7465 7520     tatus = %d.get u
   21cf8:	7274 6e61 2073 6564 2063 6164 6174 6d00     trans dec data.m
   21d08:	6c5f 7961 755f 7274 6e61 5f73 6573 646e     _lay_utrans_send
   21d18:	6d00 6c5f 7961 755f 7274 6e61 5f73 7872     .m_lay_utrans_rx
	...

00021d29 <__FUNCTION__.9280>:
   21d29:	5f6d 616c 5f79 7475 6172 736e 745f 0078     m_lay_utrans_tx.
   21d39:	0000 b500                                        ...

00021d3c <m_lay_utrans_api>:
   21d3c:	e7b5 0000                                   ....

00021d40 <m_lay_utrans_cb>:
   21d40:	e815 0000 e885 0000                         ........

00021d48 <lgs>:
   21d48:	4d5b 474c 005d                              [MLG].

00021d4e <lge>:
   21d4e:	0a0d 3e00 0042 423e 4248 4242 4248 0048     ...>B.>BHBBBHBH.
   21d5e:	423e 4242 4242 3e00 3233 3347 4732 0000     >BBBBB.>32G32G..
   21d6e:	313e 4736 3200 4235 4238 0000 0000          >16G.25B8B....

00021d7c <m_prov_pdu_handlers>:
   21d7c:	eb79 0000 1d51 0002 0001 0000 ec9d 0000     y...Q...........
   21d8c:	1d54 0002 000b 0000 ecf1 0000 1d5e 0002     T...........^...
   21d9c:	0005 0000 ee19 0000 1d65 0002 0040 0000     ........e...@...
   21dac:	ef91 0000 1d6d 0002 0000 0000 efe5 0000     ....m...........
   21dbc:	1d6e 0002 0010 0000 f099 0000 1d6e 0002     n...........n...
   21dcc:	0010 0000 f101 0000 1d73 0002 0021 0000     ........s...!...
   21ddc:	f199 0000 1d6d 0002 0000 0000 f1ed 0000     ....m...........
   21dec:	1d51 0002 0001 0000                         Q.......

00021df4 <m_prov_cfm_key_p_val>:
   21df4:	636b 7072                                   kcrp

00021df8 <m_prov_session_key_p_val>:
   21df8:	736b 7072                                   ksrp

00021dfc <m_prov_session_nonce_p_val>:
   21dfc:	736e 7072                                   nsrp

00021e00 <m_prov_device_key_p_val>:
   21e00:	646b 7072 2e2e 2e5c 5c2e 2e2e 6d5c 7365     kdrp..\..\..\mes
   21e10:	2f68 7273 2f63 5f6d 7270 766f 6d2f 705f     h/src/m_prov/m_p
   21e20:	6f72 2e76 0063 7325 255b 3031 3a73 6425     rov.c.%s[%10s:%d
   21e30:	255d 3a73 6d00                                   ]%s:.

00021e35 <__FUNCTION__.10362>:
   21e35:	5f6d 7270 766f 735f 6174 6574 735f 6e65     m_prov_state_sen
   21e45:	0064 7325 6d00                                   d.%s.

00021e4a <__FUNCTION__.10393>:
   21e4a:	5f6d 7270 766f 705f 7564 695f 766e 7469     m_prov_pdu_invit
   21e5a:	5f65 6168 646e 656c 0072 7473 7461 2065     e_handler.state 
   21e6a:	203d 6425 6420 7461 2061 203d 7830 3025     = %d data = 0x%0
   21e7a:	7832 7300 6e65 2064 6564 6976 6563 6320     2x.send device c
   21e8a:	7061 6261 6c69 7469 6569 0073               apabilities.

00021e96 <__FUNCTION__.10403>:
   21e96:	5f6d 7270 766f 705f 7564 635f 7061 6261     m_prov_pdu_capab
   21ea6:	6c69 7469 6569 5f73 6168 646e 656c 0072     ilities_handler.

00021eb6 <__FUNCTION__.10410>:
   21eb6:	5f6d 7270 766f 705f 7564 735f 6174 7472     m_prov_pdu_start
   21ec6:	685f 6e61 6c64 7265 6d00                         _handler.

00021ecf <__FUNCTION__.10428>:
   21ecf:	5f6d 7270 766f 705f 7564 705f 6275 6b5f     m_prov_pdu_pub_k
   21edf:	7965 685f 6e61 6c64 7265 7300 6174 6574     ey_handler.state
   21eef:	3d20 2520 0064 6572 7663 7020 6f72 2076      = %d.recv prov 
   21eff:	7570 2062 656b 2079 0078 6572 7663 7020     pub key x.recv p
   21f0f:	6f72 2076 7570 2062 656b 2079 0079 6573     rov pub key y.se
   21f1f:	646e 6420 7665 7020 6275 6b20 7965 7820     nd dev pub key x
   21f2f:	7300 6e65 2064 6564 2076 7570 2062 656b     .send dev pub ke
   21f3f:	2079 0079 6f63 666e 7269 616d 6974 6e6f     y y.confirmation
   21f4f:	7320 6c61 6574 2064 656b 2079 6d00                salted key .

00021f5c <__FUNCTION__.10436>:
   21f5c:	5f6d 7270 766f 705f 7564 695f 706e 7475     m_prov_pdu_input
   21f6c:	635f 706d 685f 6e61 6c64 7265 6d00               _cmp_handler.

00021f79 <__FUNCTION__.10445>:
   21f79:	5f6d 7270 766f 705f 7564 635f 6d66 685f     m_prov_pdu_cfm_h
   21f89:	6e61 6c64 7265 7000 6f72 2076 6470 2075     andler.prov pdu 
   21f99:	6663 206d 6168 646e 656c 0072 7270 766f     cfm handler.prov
   21fa9:	7020 7564 7220 6e61 6f64 006d                pdu random.

00021fb5 <__FUNCTION__.10459>:
   21fb5:	5f6d 7270 766f 705f 7564 645f 7461 5f61     m_prov_pdu_data_
   21fc5:	6168 646e 656c 0072                         handler.

00021fcd <__FUNCTION__.10465>:
   21fcd:	5f6d 7270 766f 705f 7564 635f 706d 685f     m_prov_pdu_cmp_h
   21fdd:	6e61 6c64 7265 6d00                              andler.

00021fe4 <__FUNCTION__.10472>:
   21fe4:	5f6d 7270 766f 705f 7564 665f 6961 656c     m_prov_pdu_faile
   21ff4:	5f64 6168 646e 656c 0072                    d_handler.

00021ffe <__FUNCTION__.10495>:
   21ffe:	5f6d 7270 766f 635f 6d66 735f 6c61 5f74     m_prov_cfm_salt_
   2200e:	6966 696e 6873 6465 635f 0062 7473 7461     finished_cb.stat
   2201e:	7375 3d20 2520 0064 7270 766f 6320 6d66     us = %d.prov cfm
   2202e:	7320 6c61 2074 6966 696e 6873 6465 6d00           salt finished.

0002203d <__FUNCTION__.10514>:
   2203d:	5f6d 7270 766f 705f 6173 746c 665f 6e69     m_prov_psalt_fin
   2204d:	7369 6568 5f64 6263 7300 6174 7574 2073     ished_cb.status 
   2205d:	203d 6425 7320 6174 6574 3d20 2520 0064     = %d state = %d.
   2206d:	7270 766f 7020 6173 746c 6620 6e69 7369     prov psalt finis
   2207d:	6568 0064                                   hed.

00022081 <__FUNCTION__.10525>:
   22081:	5f6d 7270 766f 705f 6275 6b5f 7965 725f     m_prov_pub_key_r
   22091:	7365 635f 0062 7473 7461 7375 3d20 2520     es_cb.status = %
   220a1:	2c64 7320 6174 6574 3d20 2520 0064 7270     d, state = %d.pr
   220b1:	766f 7020 6275 6c20 7965 7220 7365 7820     ov pub ley res x
   220c1:	7000 6f72 2076 7570 2062 656c 2079 6572     .prov pub ley re
   220d1:	2073 0079                                   s y.

000220d5 <__FUNCTION__.10533>:
   220d5:	5f6d 7270 766f 655f 6463 5f68 6573 7263     m_prov_ecdh_secr
   220e5:	7465 725f 7365 635f 0062 7270 766f 6520     et_res_cb.prov e
   220f5:	6463 2068 6573 7263 7465 7220 7365 7820     cdh secret res x
	...

00022106 <__FUNCTION__.10547>:
   22106:	5f6d 7270 766f 725f 6e61 5f64 6966 696e     m_prov_rand_fini
   22116:	6873 6465 635f 0062 7270 766f 7220 6e61     shed_cb.prov ran
   22126:	2064 6966 696e 6873 6465 6d00                    d finished.

00022131 <__FUNCTION__.10559>:
   22131:	5f6d 7270 766f 6b5f 5f31 6572 6461 5f79     m_prov_k1_ready_
   22141:	6263 7000 6d5f 705f 6f72 5f76 6e65 2076     cb.p_m_prov_env 
   22151:	203d 7025 6d00                                   = %p.

00022156 <__FUNCTION__.10572>:
   22156:	5f6d 7270 766f 6b5f 5f31 6966 696e 6873     m_prov_k1_finish
   22166:	6465 635f 0062 7473 7461 7375 3d20 2520     ed_cb.status = %
   22176:	2064 5f70 5f6d 7270 766f 655f 766e 3d20     d p_m_prov_env =
   22186:	2520 0070 7270 766f 6b20 2031 6966 696e      %p.prov k1 fini
   22196:	6873 6465 7300 6e65 2064 6564 6976 6563     shed.send device
   221a6:	7220 6e61 6f64 206d 756e 626d 7265 6d00           random number.

000221b5 <__FUNCTION__.10602>:
   221b5:	5f6d 7270 766f 635f 616d 5f63 6966 696e     m_prov_cmac_fini
   221c5:	6873 6465 635f 0062 7270 766f 6320 616d     shed_cb.prov cma
   221d5:	2063 6966 696e 6873 6465 7600 6c61 6469     c finished.valid
   221e5:	6900 766e 6c61 6469 6d00                         .invalid.

000221ee <__FUNCTION__.10632>:
   221ee:	5f6d 7270 766f 635f 6d63 665f 6e69 7369     m_prov_ccm_finis
   221fe:	6568 5f64 6263 3e00 3631 4847 4c42 0048     hed_cb.>16GHBLH.

0002220e <__FUNCTION__.10645>:
   2220e:	5f6d 7270 766f 6e5f 7465 6b5f 7965 615f     m_prov_net_key_a
   2221e:	6464 6465 635f 0062 7473 7461 7375 3d20     dded_cb.status =
   2222e:	2520 2064 656b 5f79 696c 2064 203d 7830      %d key_lid = 0x
   2223e:	3025 7832 6d00                                   %02x.

00022243 <__FUNCTION__.10659>:
   22243:	5f6d 7270 766f 6c5f 6e69 5f6b 6974 656d     m_prov_link_time
   22253:	756f 5f74 6263 7000 6f72 5f76 696c 6b6e     out_cb.prov_link
   22263:	7420 6d69 6f65 7475 6d00                          timeout.

0002226c <__FUNCTION__.10698>:
   2226c:	5f6d 7270 766f 705f 7261 6d61 725f 7073     m_prov_param_rsp
	...

0002227d <__FUNCTION__.10713>:
   2227d:	5f6d 7270 766f 6c5f 6e69 5f6b 706f 6e65     m_prov_link_open
	...

0002228e <__FUNCTION__.10718>:
   2228e:	5f6d 7270 766f 6c5f 6e69 5f6b 6c63 736f     m_prov_link_clos
   2229e:	6465 7200 6165 6f73 206e 203d 6425 6d00     ed.reason = %d.m
   222ae:	615f 5f6c 6573 5f63 7570 5f62 656b 5f79     _al_sec_pub_key_
   222be:	6572 6461 5b00                                   read.

000222c3 <lgs>:
   222c3:	4d5b 474c 005d                              [MLG].

000222c9 <lge>:
   222c9:	0a0d 0000                                        ...

000222cc <m_prov_adv_crctable>:
   222cc:	9100 72e3 9607 75e4 9f0e 7ced 9809 7bea     ...r...u...|...{
   222dc:	8d1c 6eff 8a1b 69f8 8312 60f1 8415 67f6     ...n...i...`...g
   222ec:	a938 4adb ae3f 4ddc a736 44d5 a031 43d2     8..J?..M6..D1..C
   222fc:	b524 56c7 b223 51c0 bb2a 58c9 bc2d 5fce     $..V#..Q*..X-.._
   2230c:	e170 0293 e677 0594 ef7e 0c9d e879 0b9a     p...w...~...y...
   2231c:	fd6c 1e8f fa6b 1988 f362 1081 f465 1786     l...k...b...e...
   2232c:	d948 3aab de4f 3dac d746 34a5 d041 33a2     H..:O..=F..4A..3
   2233c:	c554 26b7 c253 21b0 cb5a 28b9 cc5d 2fbe     T..&S..!Z..(]../
   2234c:	71e0 9203 76e7 9504 7fee 9c0d 78e9 9b0a     .q...v.......x..
   2235c:	6dfc 8e1f 6afb 8918 63f2 8011 64f5 8716     .m...j...c...d..
   2236c:	49d8 aa3b 4edf ad3c 47d6 a435 40d1 a332     .I;..N<..G5..@2.
   2237c:	55c4 b627 52c3 b120 5bca b829 5ccd bf2e     .U'..R ..[)..\..
   2238c:	0190 e273 0697 e574 0f9e ec7d 0899 eb7a     ..s...t...}...z.
   2239c:	1d8c fe6f 1a8b f968 1382 f061 1485 f766     ..o...h...a...f.
   223ac:	39a8 da4b 3eaf dd4c 37a6 d445 30a1 d342     .9K..>L..7E..0B.
   223bc:	25b4 c657 22b3 c150 2bba c859 2cbd cf5e     .%W.."P..+Y..,^.
   223cc:	2e2e 2e5c 5c2e 2e2e 6d5c 7365 2f68 7273     ..\..\..\mesh/sr
   223dc:	2f63 5f6d 7270 766f 6d2f 705f 6f72 5f76     c/m_prov/m_prov_
   223ec:	6461 5f76 7274 6e61 2e73 0063 7325 255b     adv_trans.c.%s[%
   223fc:	3031 3a73 6425 255d 3a73 6d00                    10s:%d]%s:.

00022407 <__FUNCTION__.9144>:
   22407:	5f6d 7270 766f 615f 7664 745f 6172 736e     m_prov_adv_trans
   22417:	745f 5f78 6573 0074 2500 0073 6564 616c     _tx_set..%s.dela
   22427:	2079 203d 6425 6d00                              y = %d.

0002242e <__FUNCTION__.9155>:
   2242e:	5f6d 7270 766f 615f 7664 745f 6172 736e     m_prov_adv_trans
   2243e:	745f 5f78 6263 7000 615f 7664 725f 7365     _tx_cb.p_adv_res
   2244e:	3d20 203d 554e 4c4c 6900 666e 206f 7265      == NULL.info er
   2245e:	6f72 0072 6361 6e6b 776f 656c 6764 656d     ror.acknowledgme
   2246e:	746e 6100 7664 7320 6e65 2064 7265 6f72     nt.adv send erro
   2247e:	0072 696c 6b6e 6320 6f6c 6573 7020 6361     r.link close pac
   2248e:	656b 0074 696c 6b6e 6320 6f6c 6573 7400     ket.link close.t
   2249e:	5f78 7571 7565 2065 7369 6e20 746f 6520     x_queue is not e
   224ae:	706d 7974 7400 5f78 7571 7565 2065 7369     mpty.tx_queue is
   224be:	6520 706d 7974 4e00 544f 4948 474e 5420      empty.NOTHING T
   224ce:	204f 4542 5320 4e45 0054                    O BE SENT.

000224d8 <__FUNCTION__.9248>:
   224d8:	5f6d 7270 766f 615f 7664 745f 6172 736e     m_prov_adv_trans
   224e8:	725f 0078 5f6d 7270 766f 6c5f 6e69 5f6b     _rx.m_prov_link_
   224f8:	706f 6e65 4d00 505f 4f52 5f56 5047 4643     open.M_PROV_GPCF
   22508:	425f 4145 4552 5f52 5443 004c 5f4d 5250     _BEARER_CTL.M_PR
   22518:	564f 4c5f 4e49 5f4b 504f 4e45 6c00 6e69     OV_LINK_OPEN.lin
   22528:	5f6b 6e69 6f66 3d20 2520 0064 5f4d 5250     k_info = %d.M_PR
   22538:	564f 4c5f 4e49 5f4b 4c43 534f 0045 5f4d     OV_LINK_CLOSE.M_
   22548:	5250 564f 475f 4350 5f46 5254 4e41 5f53     PROV_GPCF_TRANS_
   22558:	5453 5241 0054 6c61 6572 6461 2079 6572     START.already re
   22568:	6563 7669 6465 4e00 7765 7020 6361 656b     ceived.New packe
   22578:	2074 6572 6563 7669 6465 4d00 505f 4f52     t received.M_PRO
   22588:	5f56 5047 4643 545f 4152 534e 435f 4e4f     V_GPCF_TRANS_CON
   22598:	0054 5f4d 5250 564f 475f 4350 5f46 5254     T.M_PROV_GPCF_TR
   225a8:	4e41 5f53 4341 004b                         ANS_ACK.

000225b0 <__FUNCTION__.9299>:
   225b0:	5f6d 7270 766f 615f 7664 745f 6172 736e     m_prov_adv_trans
   225c0:	735f 6e65 0074 0000                         _sent...

000225c8 <lgs>:
   225c8:	4d5b 474c 005d                              [MLG].

000225ce <lge>:
   225ce:	0a0d 7200 6365 2076 7270 766f 6420 7461     ...recv prov dat
   225de:	0061 2e2e 2e5c 5c2e 2e2e 6d5c 7365 2f68     a...\..\..\mesh/
   225ee:	7273 2f63 5f6d 7270 766f 6d2f 705f 6f72     src/m_prov/m_pro
   225fe:	5f76 6562 7261 7265 632e 2500 5b73 3125     v_bearer.c.%s[%1
   2260e:	7330 253a 5d64 7325 003a                    0s:%d]%s:.

00022618 <__FUNCTION__.9897>:
   22618:	5f6d 7270 766f 625f 6165 6572 5f72 6c63     m_prov_bearer_cl
   22628:	736f 6465 635f 0062 2500 0073               osed_cb..%s.

00022634 <m_prov_bearer_cb>:
   22634:	1139 0001 10fd 0001 1151 0001 1169 0001     9.......Q...i...

00022644 <lgs>:
   22644:	4d5b 474c 005d                              [MLG].

0002264a <lge>:
   2264a:	0a0d 0000                                        ...

0002264d <m_tb_key_k2_p>:
	...

0002264e <m_tb_key_k1_beacon_salt>:
   2264e:	3dec 3839 2267 3f6e c123 b793 619a 2c24     .=98g"n?#....a$,

0002265e <m_tb_key_k1_p>:
   2265e:	3801 3132 6964 2e2e 2e5c 5c2e 2e2e 6d5c     .821di..\..\..\m
   2266e:	7365 2f68 7273 2f63 5f6d 6274 6d2f 745f     esh/src/m_tb/m_t
   2267e:	5f62 656b 2e79 0063 7325 255b 3031 3a73     b_key.c.%s[%10s:
   2268e:	6425 255d 3a73 6d00                              %d]%s:.

00022695 <__FUNCTION__.9154>:
   22695:	5f6d 6274 6b5f 7965 6b5f 5f32 6572 6461     m_tb_key_k2_read
   226a5:	5f79 6263 7000 6b5f 7965 3d20 2520 2070     y_cb.p_key = %p 
   226b5:	656b 5f79 7974 6570 3d20 3020 2578 3230     key_type = 0x%02
   226c5:	0078 7325 6d00                                   x.%s.

000226ca <__FUNCTION__.9180>:
   226ca:	5f6d 6274 6b5f 7965 665f 6e69 7369 6568     m_tb_key_finishe
   226da:	5f64 6263 7000 6b5f 7965 3d20 2520 2070     d_cb.p_key = %p 
   226ea:	7473 7461 2065 203d 7830 3025 7832 6b20     state = 0x%02x k
   226fa:	7965 745f 7079 2065 203d 7830 3025 7832     ey_type = 0x%02x
   2270a:	6e00 7465 4b20 7965 6920 2073 6572 6461     .net Key is read
   2271a:	2079 6f74 6220 2065 7375 6465 6e00 7765     y to be used.new
   2272a:	6e20 7465 4b20 7965 0020 7061 6c70 6369      net Key .applic
   2273a:	7461 6f69 206e 656b 2079 6966 696e 6873     ation key finish
   2274a:	6465 6d00                                        ed.

0002274d <__FUNCTION__.9231>:
   2274d:	5f6d 6274 6b5f 7965 645f 7665 615f 6464     m_tb_key_dev_add
	...

0002275f <__FUNCTION__.9247>:
   2275f:	5f6d 6274 6b5f 7965 6e5f 7465 615f 6464     m_tb_key_net_add
	...

00022770 <__FUNCTION__.9324>:
   22770:	5f6d 6274 6b5f 7965 6e5f 7465 675f 7465     m_tb_key_net_get
   22780:	6e00 7465 6b5f 7965 6c5f 6469 3d20 3020     .net_key_lid = 0
   22790:	2578 0078                                   x%x.

00022794 <__FUNCTION__.9364>:
   22794:	5f6d 6274 6b5f 7965 615f 7070 615f 6464     m_tb_key_app_add
	...

000227a5 <__FUNCTION__.9500>:
   227a5:	5f6d 6274 6b5f 7965 6d5f 646f 6c65 625f     m_tb_key_model_b
   227b5:	6e69 0064 7061 5f70 656b 5f79 696c 5b64     ind.app_key_lid[
   227c5:	7830 7825 6d5d 646f 6c65 6c5f 6469 305b     0x%x]model_lid[0
   227d5:	2578 5d78 7300 6174 7574 2073 203d 6425     x%x].status = %d
   227e5:	6e00 7465 6b5f 7965 6c5f 6469 255b 5d64     .net_key_lid[%d]
   227f5:	6620 616c 7367 255b 5d64 6920 5b76 6425      flags[%d] iv[%d
   22805:	005d 5b00                                        ]..

00022808 <lgs>:
   22808:	4d5b 474c 005d                              [MLG].

0002280e <lge>:
   2280e:	0a0d 6c00 6469 305b 2578 5d78 6f20 6666     ...lid[0x%x] off
   2281e:	6573 5b74 7830 7825 205d 6f6d 6564 5f6c     set[0x%x] model_
   2282e:	6469 305b 2578 5d78 6500 6461 7264 305b     id[0x%x].eaddr[0
   2283e:	2578 5d78 6d20 646f 6c65 695f 5b64 7830     x%x] model_id[0x
   2284e:	7825 205d 6576 646e 726f 255b 5d64 7000     %x] vendor[%d].p
   2285e:	6972 5f6d 6461 7264 305b 2578 5d78 6120     rim_addr[0x%x] a
   2286e:	6464 5f72 666f 7366 7465 305b 2578 5d78     ddr_offset[0x%x]
   2287e:	7320 6174 7574 5b73 7830 7825 205d 6f6d      status[0x%x] mo
   2288e:	6564 5f6c 6469 305b 2578 5d78 7000 6d5f     del_id[0x%x].p_m
   2289e:	646f 6c65 6c5f 6469 305b 2578 5d78 0000     odel_lid[0x%x]..
	...

000228b0 <CSWTCH.65>:
   228b0:	0064 0000 03e8 0000 2710 0000 27c0 0009     d........'...'..
   228c0:	2e2e 2e5c 5c2e 2e2e 6d5c 7365 2f68 7273     ..\..\..\mesh/sr
   228d0:	2f63 5f6d 6274 6d2f 745f 5f62 696d 2e6f     c/m_tb/m_tb_mio.
   228e0:	0063 7325 255b 3031 3a73 6425 255d 3a73     c.%s[%10s:%d]%s:
	...

000228f1 <__FUNCTION__.9178>:
   228f1:	5f6d 6274 6d5f 6f69 735f 7465 705f 6972     m_tb_mio_set_pri
   22901:	5f6d 6461 7264 7000 6972 5f6d 6461 7264     m_addr.prim_addr
   22911:	3d20 3020 2578 3430 0078 7325 5b00                = 0x%04x.%s.

0002291e <lgs>:
   2291e:	4d5b 474c 005d                              [MLG].

00022924 <lge>:
   22924:	0a0d 2e00 5c2e 2e2e 2e5c 5c2e 656d 6873     .....\..\..\mesh
   22934:	732f 6372 6d2f 745f 2f62 5f6d 6274 735f     /src/m_tb/m_tb_s
   22944:	6365 632e 2500 5b73 3125 7330 253a 5d64     ec.c.%s[%10s:%d]
   22954:	7325 003a                                   %s:.

00022958 <__FUNCTION__.8157>:
   22958:	5f6d 6274 735f 6365 665f 6e75 5f63 6e65     m_tb_sec_func_en
   22968:	5f64 6168 646e 656c 0072 5f70 6f74 656b     d_handler.p_toke
   22978:	206e 203d 7025 7420 6b6f 6e65 695f 2064     n = %p token_id 
   22988:	203d 7830 3025 7832 2500 0073               = 0x%02x.%s.

00022994 <__FUNCTION__.8222>:
   22994:	5f6d 6274 735f 6365 735f 6174 7472 7400     m_tb_sec_start.t
   229a4:	6b6f 6e65 695f 2064 203d 6425 6620 6e75     oken_id = %d fun
   229b4:	5f63 7974 6570 3d20 2520 0064 5245 2052     c_type = %d.ERR 
   229c4:	5f4d 4254 535f 4345 4e5f 4e4f 0045 5f4d     M_TB_SEC_NONE.M_
   229d4:	4254 535f 4345 4e5f 4e4f 0045 7562 7973     TB_SEC_NONE.busy
   229e4:	3d20 2520 0064                               = %d.

000229ea <lgs>:
   229ea:	4d5b 474c 005d                              [MLG].

000229f0 <lge>:
   229f0:	0a0d 2e00 5c2e 2e2e 2e5c 5c2e 656d 6873     .....\..\..\mesh
   22a00:	732f 6372 6d2f 745f 2f62 5f6d 6274 735f     /src/m_tb/m_tb_s
   22a10:	6174 6574 632e 2500 5b73 3125 7330 253a     tate.c.%s[%10s:%
   22a20:	5d64 7325 003a                              d]%s:.

00022a26 <__FUNCTION__.9100>:
   22a26:	5f6d 6274 735f 6174 6574 735f 7465 705f     m_tb_state_set_p
   22a36:	6f72 5f76 7473 7461 0065 6e69 6f66 3d20     rov_state.info =
   22a46:	3020 2578 3430 0064 7325 6d00                     0x%04d.%s.

00022a51 <__FUNCTION__.9125>:
   22a51:	5f6d 6274 735f 6174 6574 735f 7465 615f     m_tb_state_set_a
   22a61:	7474 6e65 6974 6e6f 735f 6174 6574 0000     ttention_state..

00022a71 <lgs>:
   22a71:	4d5b 474c 005d                              [MLG].

00022a77 <lge>:
   22a77:	0a0d 2e00 5c2e 2e2e 2e5c 5c2e 656d 6873     .....\..\..\mesh
   22a87:	732f 6372 6d2f 745f 2f62 5f6d 6274 735f     /src/m_tb/m_tb_s
   22a97:	6f74 6572 775f 7476 632e 2500 5b73 3125     tore_wvt.c.%s[%1
   22aa7:	7330 253a 5d64 7325 003a                    0s:%d]%s:.

00022ab1 <__FUNCTION__.9946>:
   22ab1:	5f6d 6274 735f 6f74 6572 6c5f 616f 5f64     m_tb_store_load_
   22ac1:	7366 006d 6573 2074 7473 7461 2065 7270     fsm.set state pr
   22ad1:	766f 2500 0073                              ov.%s.

00022ad7 <__FUNCTION__.9954>:
   22ad7:	5f6d 6274 635f 6568 6b63 735f 6f74 6572     m_tb_check_store
   22ae7:	5f64 6e69 6f66 6400 7461 2061 6f70 6e69     d_info.data poin
   22af7:	6574 2072 203d 7830 3025 7838 6c20 6e65     ter = 0x%08x len
   22b07:	7467 2068 203d 6425 7200 7465 253d 0064     gth = %d.ret=%d.

00022b17 <__FUNCTION__.9989>:
   22b17:	5f6d 6274 735f 6f74 6572 6c5f 616f 0064     m_tb_store_load.
   22b27:	7473 7461 7375 253d 0064                    status=%d.

00022b31 <__FUNCTION__.9798>:
   22b31:	5f6d 6274 735f 6f74 6572 755f 6470 7461     m_tb_store_updat
   22b41:	5f65 7570 6c62 5f69 6170 6172 5f6d 6e69     e_publi_param_in
   22b51:	0064 7061 5f70 656b 5f79 696c 5b64 7825     d.app_key_lid[%x
   22b61:	005d                                        ].

00022b63 <__FUNCTION__.10025>:
   22b63:	5f6d 6274 735f 6f74 6572 735f 7661 0065     m_tb_store_save.
   22b73:	7075 5f64 7974 6570 3d20 2520 0064 6173     upd_type = %d.sa
   22b83:	6576 6320 6e6f 6966 2067 6164 6174 6f00     ve config data.o
   22b93:	7974 6570 255b 5d64 6f20 656c 676e 6874     type[%d] olength
   22ba3:	255b 5d64 6e20 7974 6570 255b 5d64 6e20     [%d] ntype[%d] n
   22bb3:	656c 676e 6874 255b 5d64 0000 0a00 0000     length[%d]......
   22bc3:	4200 0164 a600 0164 a600 0164 5000 0164     .Bd...d...d..Pd.
   22bd3:	a600 0164 a600 0164 a600 0164 a600 0164     ..d...d...d...d.
   22be3:	a600 0164 a600 0164 6c00 015e 5c00 0164     ..d...d..l^..\d.
   22bf3:	a600 0164 9a00 015d 8000 015e a600 0164     ..d...]...^...d.
   22c03:	d000 015e dc00 015e dc00 015e dc00 015e     ..^...^...^...^.
   22c13:	dc00 015e dc00 015e dc00 015e dc00 015e     ..^...^...^...^.
   22c23:	dc00 015e dc00 015e a600 0164 a600 0164     ..^...^...d...d.
   22c33:	a600 0164 a600 0164 a600 0164 a600 0164     ..d...d...d...d.
   22c43:	a600 0164 a600 0164 a600 0164 a600 0164     ..d...d...d...d.
   22c53:	0400 015f c400 015f a600 0164 c400 015f     .._..._...d..._.
   22c63:	a600 0164 a600 0164 a600 0164 a600 0164     ..d...d...d...d.
   22c73:	5c00 0160 a600 0164 a600 0164 6800 0160     .\`...d...d..h`.
   22c83:	a600 0164 a600 0164 a600 0164 a600 0164     ..d...d...d...d.
   22c93:	a600 0164 d200 0161 a600 0164 a600 0164     ..d...a...d...d.
   22ca3:	0c00 0163 a600 0164 a600 0164 a600 0164     ..c...d...d...d.
   22cb3:	a600 0164 a600 0164 a600 0164 a600 0164     ..d...d...d...d.
   22cc3:	a600 0164 a600 0164 a600 0164 6400 0164     ..d...d...d..dd.
   22cd3:	a800 0162 c400 015f c400 015f c400 015f     ..b..._..._..._.
   22ce3:	b800 0162 a800 0162 a600 0164 a600 0164     ..b...b...d...d.
   22cf3:	c400 0162 a600 0164 d800 0162 3400 0162     ..b...d...b..4b.
   22d03:	a600 015d 4400 0162 a600 0164 5000 0162     ..]..Db...d..Pb.
   22d13:	a600 0164 c400 0163 a600 0164 a600 0164     ..d...c...d...d.
   22d23:	d400 0163 3000                                   ..c..

00022d28 <zeroes.7271>:
   22d28:	3030 3030 3030 3030 3030 3030 3030 3030     0000000000000000
   22d38:	4e49 0046 6e69 0066 414e 004e 616e 006e     INF.inf.NAN.nan.
   22d48:	3130 3332 3534 3736 3938 4241 4443 4645     0123456789ABCDEF
   22d58:	0000 0000 3130 3332 3534 3736 3938 6261     ....0123456789ab
   22d68:	6463 6665 0000 0000 6e28 6c75 296c 0000     cdef....(null)..
   22d78:	0030 0000                                   0...

00022d7c <blanks.7270>:
   22d7c:	2020 2020 2020 2020 2020 2020 2020 2020                     
   22d8c:	6e49 6966 696e 7974 0000 0000 614e 004e     Infinity....NaN.

00022d9c <_global_impure_ptr>:
   22d9c:	09c8 1001                                   ....

00022da0 <__mprec_tens>:
   22da0:	0000 0000 0000 3ff0 0000 0000 0000 4024     .......?......$@
   22db0:	0000 0000 0000 4059 0000 0000 4000 408f     ......Y@.....@.@
   22dc0:	0000 0000 8800 40c3 0000 0000 6a00 40f8     .......@.....j.@
   22dd0:	0000 0000 8480 412e 0000 0000 12d0 4163     .......A......cA
   22de0:	0000 0000 d784 4197 0000 0000 cd65 41cd     .......A....e..A
   22df0:	0000 2000 a05f 4202 0000 e800 4876 4237     ... _..B....vH7B
   22e00:	0000 a200 1a94 426d 0000 e540 309c 42a2     ......mB..@..0.B
   22e10:	0000 1e90 bcc4 42d6 0000 2634 6bf5 430c     .......B..4&.k.C
   22e20:	8000 37e0 c379 4341 a000 85d8 3457 4376     ...7y.AC....W4vC
   22e30:	c800 674e c16d 43ab 3d00 6091 58e4 43e1     ..Ngm..C.=.`.X.C
   22e40:	8c40 78b5 af1d 4415 ef50 d6e2 1ae4 444b     @..x...DP.....KD
   22e50:	d592 064d f0cf 4480 4af6 c7e1 2d02 44b5     ..M....D.J...-.D
   22e60:	9db4 79d9 7843 44ea                         ...yCx.D

00022e68 <p05.6085>:
   22e68:	0005 0000 0019 0000 007d 0000 0000 0000     ........}.......

00022e78 <__mprec_bigtens>:
   22e78:	8000 37e0 c379 4341 6e17 b505 b8b5 4693     ...7y.AC.n.....F
   22e88:	f9f5 e93f 4f03 4d38 1d32 f930 7748 5a82     ..?..O8M2.0.Hw.Z
   22e98:	bf3c 7f73 4fdd 7515                         <.s..O.u

00022ea0 <__mprec_tinytens>:
   22ea0:	89bc 97d8 d2b2 3c9c a733 d5a8 f623 3949     .......<3...#.I9
   22eb0:	a73d 44f4 0ffd 32a5 979d cf8c ba08 255b     =..D...2......[%
   22ec0:	6f43 64ac 0628 0ac8 a9fe 0001 aa40 0001     Co.d(.......@...
   22ed0:	aa40 0001 aa1c 0001 aa40 0001 aa40 0001     @.......@...@...
   22ee0:	aa40 0001 aa40 0001 aa40 0001 aa40 0001     @...@...@...@...
   22ef0:	a878 0001 a88c 0001 aa40 0001 a2f8 0001     x.......@.......
   22f00:	a4fc 0001 aa40 0001 a54c 0001 a558 0001     ....@...L...X...
   22f10:	a558 0001 a558 0001 a558 0001 a558 0001     X...X...X...X...
   22f20:	a558 0001 a558 0001 a558 0001 a558 0001     X...X...X...X...
   22f30:	aa40 0001 aa40 0001 aa40 0001 aa40 0001     @...@...@...@...
   22f40:	aa40 0001 aa40 0001 aa40 0001 aa40 0001     @...@...@...@...
   22f50:	aa40 0001 aa40 0001 a586 0001 a648 0001     @...@.......H...
   22f60:	aa40 0001 a648 0001 aa40 0001 aa40 0001     @...H...@...@...
   22f70:	aa40 0001 aa40 0001 a6e0 0001 aa40 0001     @...@.......@...
   22f80:	aa40 0001 a6ec 0001 aa40 0001 aa40 0001     @.......@...@...
   22f90:	aa40 0001 aa40 0001 aa40 0001 a75a 0001     @...@...@...Z...
   22fa0:	aa40 0001 aa40 0001 a7bc 0001 aa40 0001     @...@.......@...
   22fb0:	aa40 0001 aa40 0001 aa40 0001 aa40 0001     @...@...@...@...
   22fc0:	aa40 0001 aa40 0001 aa40 0001 aa40 0001     @...@...@...@...
   22fd0:	aa40 0001 a9c8 0001 a9b8 0001 a648 0001     @...........H...
   22fe0:	a648 0001 a648 0001 aa28 0001 a9b8 0001     H...H...(.......
   22ff0:	aa40 0001 aa40 0001 a97c 0001 aa40 0001     @...@...|...@...
   23000:	a990 0001 a3a2 0001 a304 0001 a894 0001     ................
   23010:	aa40 0001 a8a0 0001 aa40 0001 a8f8 0001     @.......@.......
   23020:	aa40 0001 aa40 0001 a908 0001               @...@.......

0002302c <zeroes.7256>:
   2302c:	3030 3030 3030 3030 3030 3030 3030 3030     0000000000000000

0002303c <blanks.7255>:
   2303c:	2020 2020 2020 2020 2020 2020 2020 2020                     
   2304c:	c22e 0001 c2ec 0001 c2ec 0001 c23c 0001     ............<...
   2305c:	c2ec 0001 c2ec 0001 c2ec 0001 c2ec 0001     ................
   2306c:	c2ec 0001 c2ec 0001 c074 0001 c032 0001     ........t...2...
   2307c:	c2ec 0001 bc18 0001 c03a 0001 c2ec 0001     ........:.......
   2308c:	bea2 0001 c00e 0001 c00e 0001 c00e 0001     ................
   2309c:	c00e 0001 c00e 0001 c00e 0001 c00e 0001     ................
   230ac:	c00e 0001 c00e 0001 c2ec 0001 c2ec 0001     ................
   230bc:	c2ec 0001 c2ec 0001 c2ec 0001 c2ec 0001     ................
   230cc:	c2ec 0001 c2ec 0001 c2ec 0001 c2ec 0001     ................
   230dc:	beae 0001 c2ec 0001 c2ec 0001 c2ec 0001     ................
   230ec:	c2ec 0001 c2ec 0001 c2ec 0001 c2ec 0001     ................
   230fc:	c2ec 0001 c2ec 0001 c2ec 0001 bf52 0001     ............R...
   2310c:	c2ec 0001 c2ec 0001 c2ec 0001 c2ec 0001     ................
   2311c:	c2ec 0001 c158 0001 c2ec 0001 c2ec 0001     ....X...........
   2312c:	c1b4 0001 c2ec 0001 c2ec 0001 c2ec 0001     ................
   2313c:	c2ec 0001 c2ec 0001 c2ec 0001 c2ec 0001     ................
   2314c:	c2ec 0001 c2ec 0001 c2ec 0001 c208 0001     ................
   2315c:	c2e0 0001 c2ec 0001 c2ec 0001 c2ec 0001     ................
   2316c:	c29e 0001 c2e0 0001 c2ec 0001 c2ec 0001     ................
   2317c:	c2aa 0001 c2ec 0001 c2bc 0001 c088 0001     ................
   2318c:	bc24 0001 c14e 0001 c2ec 0001 c094 0001     $...N...........
   2319c:	c2ec 0001 c0d2 0001 c2ec 0001 c2ec 0001     ................
   231ac:	c248 0001                                   H...

000231b0 <zeroes.7250>:
   231b0:	3030 3030 3030 3030 3030 3030 3030 3030     0000000000000000

000231c0 <blanks.7249>:
   231c0:	2020 2020 2020 2020 2020 2020 2020 2020                     
   231d0:	0043 0000 4f50 4953 0058 0000 002e 0000     C...POSIX.......
   231e0:	d0ae 0001 d500 0001 d500 0001 d0a4 0001     ................
   231f0:	d500 0001 d500 0001 d500 0001 d500 0001     ................
   23200:	d500 0001 d500 0001 cfde 0001 d1e2 0001     ................
   23210:	d500 0001 cff6 0001 d4c0 0001 d500 0001     ................
   23220:	d4b4 0001 d522 0001 d522 0001 d522 0001     ...."..."..."...
   23230:	d522 0001 d522 0001 d522 0001 d522 0001     "..."..."..."...
   23240:	d522 0001 d522 0001 d500 0001 d500 0001     "..."...........
   23250:	d500 0001 d500 0001 d500 0001 d500 0001     ................
   23260:	d500 0001 d500 0001 d500 0001 d500 0001     ................
   23270:	d2a4 0001 d500 0001 d500 0001 d500 0001     ................
   23280:	d500 0001 d500 0001 d500 0001 d500 0001     ................
   23290:	d500 0001 d500 0001 d500 0001 d3aa 0001     ................
   232a0:	d500 0001 d500 0001 d500 0001 d500 0001     ................
   232b0:	d500 0001 d354 0001 d500 0001 d500 0001     ....T...........
   232c0:	d45c 0001 d500 0001 d500 0001 d500 0001     \...............
   232d0:	d500 0001 d500 0001 d500 0001 d500 0001     ................
   232e0:	d500 0001 d500 0001 d500 0001 d1ec 0001     ................
   232f0:	d598 0001 d500 0001 d500 0001 d500 0001     ................
   23300:	d58c 0001 d598 0001 d500 0001 d500 0001     ................
   23310:	d57a 0001 d500 0001 d546 0001 d04e 0001     z.......F...N...
   23320:	d002 0001 d5e4 0001 d500 0001 d5a8 0001     ................
   23330:	d500 0001 d162 0001 d500 0001 d500 0001     ....b...........
   23340:	d0bc 0001                                   ....

00023344 <blanks.7235>:
   23344:	2020 2020 2020 2020 2020 2020 2020 2020                     

00023354 <zeroes.7236>:
   23354:	3030 3030 3030 3030 3030 3030 3030 3030     0000000000000000

00023364 <_ctype_>:
   23364:	2000 2020 2020 2020 2020 2828 2828 2028     .         ((((( 
   23374:	2020 2020 2020 2020 2020 2020 2020 2020                     
   23384:	8820 1010 1010 1010 1010 1010 1010 1010      ...............
   23394:	0410 0404 0404 0404 0404 1004 1010 1010     ................
   233a4:	1010 4141 4141 4141 0101 0101 0101 0101     ..AAAAAA........
   233b4:	0101 0101 0101 0101 0101 0101 1010 1010     ................
   233c4:	1010 4242 4242 4242 0202 0202 0202 0202     ..BBBBBB........
   233d4:	0202 0202 0202 0202 0202 0202 1010 1010     ................
   233e4:	0020 0000 0000 0000 0000 0000 0000 0000      ...............
	...
   23468:	e8ec 0001 e7ba 0001 e8c0 0001 e7b0 0001     ................
   23478:	e8c0 0001 e8ca 0001 e8c0 0001 e7b0 0001     ................
   23488:	e7ba 0001 e7ba 0001 e8ca 0001 e7b0 0001     ................
   23498:	e7a6 0001 e7a6 0001 e7a6 0001 eb1c 0001     ................
   234a8:	f134 0001 eff4 0001 eff4 0001 eff2 0001     4...............
   234b8:	f10c 0001 f10c 0001 f0fe 0001 eff2 0001     ................
   234c8:	f10c 0001 f0fe 0001 f10c 0001 eff2 0001     ................
   234d8:	f114 0001 f114 0001 f114 0001 f314 0001     ................
